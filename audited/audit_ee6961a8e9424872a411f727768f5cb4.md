# Audit Report

## Title
Unstable Bytecode Deployment Bypass via Missing Compilation Metadata

## Summary
The `reject_unstable_bytecode` function in AptosVM only validates the unstable flag when compilation metadata is present. An attacker can deploy bytecode compiled with unstable compiler or language versions on mainnet by simply removing the compilation metadata from the bytecode, completely bypassing the stability check.

## Finding Description

The Aptos blockchain implements a safety mechanism to prevent deployment of unstable code on production networks. This is enforced through two related components:

1. **Compilation Metadata Structure**: The `CompilationMetadata` struct tracks whether code was compiled with unstable versions. [1](#0-0) 

The struct uses `#[derive(Default)]`, which provides a default implementation that sets `unstable: false` with empty version strings. This is problematic because it incorrectly suggests stability. [2](#0-1) 

The codebase explicitly defines which versions are stable vs unstable for production use. [3](#0-2) [4](#0-3) 

2. **Validation Function**: The `reject_unstable_bytecode` function is supposed to prevent unstable code from being deployed on mainnet: [5](#0-4) 

**The Critical Flaw**: The validation logic only checks the `unstable` flag **IF** compilation metadata is present (line 1745: `if let Some(metadata) = get_compilation_metadata(module)`). If metadata is absent, the function returns `Ok(())` and allows deployment. [6](#0-5) 

The `get_compilation_metadata` function returns `None` when metadata is not found, rather than enforcing its presence.

This function is called during module publishing: [7](#0-6) 

**Attack Path**:
1. Attacker compiles Move code using unstable compiler version (e.g., V2_1) or language version (e.g., V2_4, V2_5)
2. Attacker manually strips the `compilation_metadata` entry from the compiled bytecode
3. Attacker submits the modified bytecode to mainnet
4. The `reject_unstable_bytecode` check finds no metadata and returns `Ok()`
5. Unstable code is deployed on mainnet, violating the safety policy

**Secondary Issue**: The `Default` trait implementation provides an unsafe default that sets `unstable: false`. While not directly exploited in the main validation path, this represents a design flaw that could lead to vulnerabilities if the default is used in other contexts.

## Impact Explanation

This vulnerability allows **significant protocol violations** meeting **High severity** criteria per the Aptos bug bounty program.

**Immediate Impact**:
- Circumvents the documented security policy that unstable compiler/language versions should not run on production networks
- Enables deployment of code compiled with features that haven't undergone full security auditing or stability testing

**Potential Critical Impact**:
Unstable versions are explicitly marked as such because they may contain:
- **Consensus-breaking bugs**: Different validators might execute unstable bytecode differently, leading to chain splits and violating the Deterministic Execution invariant
- **Move VM vulnerabilities**: Incomplete bytecode verification, gas calculation errors, or memory safety issues
- **State corruption**: Bugs in unstable language features could corrupt the Jellyfish Merkle tree or cause storage inconsistencies

The comments in the codebase explicitly document this risk: [8](#0-7) [9](#0-8) 

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
- **Low technical barrier**: Bytecode manipulation requires only basic binary editing tools
- **No special privileges needed**: Any user can submit module deployment transactions
- **Easy to automate**: The attack can be scripted and repeated
- **No validator collusion required**: Entirely client-side manipulation

The metadata section in Move bytecode is simply a vector of key-value pairs that can be trivially removed or modified before submission.

## Recommendation

**Immediate Fix**: Require compilation metadata to be present and enforce validation of version strings on mainnet.

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            // REQUIRE metadata to be present on mainnet
            let metadata = get_compilation_metadata(module)
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                        .with_message(
                            "compilation metadata required for mainnet deployment".to_string()
                        )
                        .finish(Location::Undefined)
                })?;
            
            // Validate version strings are parseable
            metadata.compiler_version().map_err(|e| {
                PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(format!("invalid compiler version: {}", e))
                    .finish(Location::Undefined)
            })?;
            
            metadata.language_version().map_err(|e| {
                PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(format!("invalid language version: {}", e))
                    .finish(Location::Undefined)
            })?;
            
            // Check unstable flag
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string()
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

**Additional Fix**: Remove the unsafe Default implementation or make it explicitly unsafe:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompilationMetadata {
    pub unstable: bool,
    pub compiler_version: String,
    pub language_version: String,
}

impl Default for CompilationMetadata {
    fn default() -> Self {
        // Conservative default: assume unstable unless proven otherwise
        Self {
            unstable: true,
            compiler_version: String::new(),
            language_version: String::new(),
        }
    }
}
```

## Proof of Concept

```rust
// File: test_unstable_bypass.rs
use move_binary_format::CompiledModule;
use move_model::metadata::{CompilationMetadata, COMPILATION_METADATA_KEY};
use move_core_types::metadata::Metadata;

#[test]
fn test_unstable_deployment_bypass() {
    // Step 1: Create a module compiled with unstable version (simulated)
    let mut module = create_test_module_with_unstable_metadata();
    
    // Step 2: Verify it has unstable metadata
    let metadata_before = get_compilation_metadata(&module);
    assert!(metadata_before.is_some());
    assert!(metadata_before.unwrap().unstable);
    
    // Step 3: Strip the compilation metadata
    module.metadata.retain(|m| m.key != COMPILATION_METADATA_KEY);
    
    // Step 4: Verify metadata is now absent
    let metadata_after = get_compilation_metadata(&module);
    assert!(metadata_after.is_none());
    
    // Step 5: Simulate mainnet validation
    let vm = create_aptos_vm_for_mainnet();
    let result = vm.reject_unstable_bytecode(&[module]);
    
    // Step 6: Validation INCORRECTLY passes because metadata is absent
    assert!(result.is_ok()); // This should fail but doesn't!
    
    println!("VULNERABILITY CONFIRMED: Unstable bytecode bypassed mainnet check");
}

fn create_test_module_with_unstable_metadata() -> CompiledModule {
    // Create module with CompilerVersion::V2_1 (unstable)
    let unstable_metadata = CompilationMetadata::new(
        CompilerVersion::V2_1, // Unstable compiler
        LanguageVersion::V2_3   // Stable language
    );
    
    let metadata = Metadata {
        key: COMPILATION_METADATA_KEY.to_vec(),
        value: bcs::to_bytes(&unstable_metadata).unwrap(),
    };
    
    CompiledModule {
        version: 6,
        metadata: vec![metadata],
        // ... other fields
        ..Default::default()
    }
}
```

**Reproduction Steps**:
1. Compile a Move module using unstable compiler version (e.g., `--compiler-version 2.1`)
2. Use a hex editor or binary manipulation tool to remove the metadata section with key `compilation_metadata`
3. Submit the modified bytecode to a mainnet-configured test environment
4. Observe that the deployment succeeds despite using unstable compiler version

## Notes

This vulnerability represents a **fundamental gap in the security policy enforcement** for Aptos mainnet. The codebase explicitly documents that unstable versions should not be allowed on production networks, but the implementation fails to enforce this when metadata is absent. The fix should be deployed as soon as possible to prevent deployment of potentially dangerous unstable bytecode on mainnet.

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L17-24)
```rust
pub const LATEST_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_5;

/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
pub const LATEST_STABLE_LANGUAGE_VERSION: &str = LATEST_STABLE_LANGUAGE_VERSION_VALUE.to_str();

pub const LATEST_STABLE_COMPILER_VERSION_VALUE: CompilerVersion = CompilerVersion::V2_0;
pub const LATEST_STABLE_COMPILER_VERSION: &str = LATEST_STABLE_COMPILER_VERSION_VALUE.to_str();
```

**File:** third_party/move/move-model/src/metadata.rs (L49-62)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}
```

**File:** third_party/move/move-model/src/metadata.rs (L148-157)
```rust
impl CompilerVersion {
    /// Return true if this is a stable compiler version. A non-stable version
    /// should not be allowed on production networks.
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1690)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```
