# Audit Report

## Title
Multisig Transaction Expiration Bypass - Stored Proposals Have No Expiration Validation

## Summary
Multisig transactions stored on-chain lack expiration time validation, allowing owners to execute arbitrarily old approved transactions. While the outer execution transaction's expiration timestamp is validated, the stored `MultisigTransaction` proposal itself has no expiration mechanism, enabling execution of stale governance decisions potentially years after creation.

## Finding Description

The multisig account system stores transaction proposals on-chain with a `creation_time_secs` field that records when the proposal was created. [1](#0-0) 

However, the `validate_multisig_transaction` function that validates execution does NOT check if the stored transaction has expired based on its creation time. [2](#0-1) 

The only expiration validation occurs in `prologue_common`, which validates the outer `SignedTransaction`'s expiration timestamp, not the stored multisig proposal's age. [3](#0-2) 

**Attack Flow:**
1. In 2023, a multisig owner creates a transaction to transfer 10,000 APT to address X
2. Sufficient owners approve it (e.g., 2/3 signatures collected)
3. Before execution, circumstances change drastically - the recipient is compromised, or the action is no longer appropriate
4. The proposal is never explicitly rejected and remains in the pending transactions table
5. In 2025, any owner executes this 2-year-old transaction with a fresh outer transaction (valid expiration timestamp)
6. The stale transaction executes successfully because there's no validation of the proposal's age

The execution flow shows the separation: `run_prologue_with_payload` first validates the outer transaction's expiration via `run_script_prologue`, then separately validates the multisig proposal via `run_multisig_prologue`. [4](#0-3) 

The `run_multisig_prologue` function never receives or validates any expiration information about the stored proposal. [5](#0-4) 

## Impact Explanation

**Severity: High**

This vulnerability enables:
- **Governance Integrity Violation**: Execution of outdated governance decisions that no longer reflect current intent
- **Unauthorized Fund Transfers**: Treasury operations approved under different circumstances can be executed maliciously
- **Protocol Parameter Manipulation**: Old configuration changes can be applied inappropriately

Multisig accounts are critical infrastructure in Aptos for:
- Protocol treasury management (potentially millions of APT)
- Validator set operations
- Framework upgrades and governance proposals
- DAO treasuries and multi-owner asset management

While this doesn't directly break consensus, it constitutes a **significant protocol violation** affecting governance security, meeting the High severity criteria per Aptos bug bounty guidelines.

## Likelihood Explanation

**Likelihood: Medium-High**

Required conditions:
- Attacker must be a legitimate multisig owner (common in governance contexts)
- A previously approved transaction must exist (normal multisig workflow)
- No explicit rejection occurred (oversight or intentional neglect)

This is HIGHLY likely to occur because:
1. Long-lived multisig accounts naturally accumulate old approved-but-not-executed transactions
2. No mechanism forces explicit rejection of outdated proposals
3. Owner composition may change over time, with new owners unaware of old pending transactions
4. Economic incentives exist to execute favorable old transactions (e.g., price changes, compromised recipients)

## Recommendation

Add an expiration field to `MultisigTransaction` and validate it during execution:

```move
struct MultisigTransaction has copy, drop, store {
    payload: Option<vector<u8>>,
    payload_hash: Option<vector<u8>>,
    votes: SimpleMap<address, bool>,
    creator: address,
    creation_time_secs: u64,
    // ADD THIS:
    expiration_time_secs: u64,  // When this proposal expires
}
```

Modify `validate_multisig_transaction` to check expiration:

```move
fun validate_multisig_transaction(
    owner: &signer, multisig_account: address, payload: vector<u8>) acquires MultisigAccount {
    // ... existing checks ...
    
    let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);
    
    // ADD THIS CHECK:
    assert!(
        timestamp::now_seconds() < transaction.expiration_time_secs,
        error::invalid_argument(ETRANSACTION_EXPIRED),
    );
    
    // ... rest of validation ...
}
```

Update `create_transaction` and `create_transaction_with_hash` to accept an expiration parameter (e.g., 30 days from creation).

## Proof of Concept

```move
#[test_only]
module test_addr::multisig_expiration_attack {
    use aptos_framework::multisig_account;
    use aptos_framework::timestamp;
    use aptos_framework::account;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    use std::vector;
    use std::signer;

    #[test(owner1 = @0x100, owner2 = @0x200, owner3 = @0x300, framework = @aptos_framework)]
    fun test_expired_multisig_execution(
        owner1: &signer,
        owner2: &signer, 
        owner3: &signer,
        framework: &signer
    ) {
        // Setup: Create multisig account with 2/3 threshold
        timestamp::set_time_has_started_for_testing(framework);
        
        let owner1_addr = signer::address_of(owner1);
        let owner2_addr = signer::address_of(owner2);
        let owner3_addr = signer::address_of(owner3);
        
        account::create_account_for_test(owner1_addr);
        account::create_account_for_test(owner2_addr);
        account::create_account_for_test(owner3_addr);
        
        // Create multisig account
        multisig_account::create_with_owners(
            owner1,
            vector[owner2_addr, owner3_addr],
            2,
            vector[],
            vector[]
        );
        
        let multisig_addr = multisig_account::get_next_multisig_account_address(owner1_addr);
        
        // Year 2023: Create transaction to transfer funds
        timestamp::fast_forward_seconds(1000); // Simulate time passage
        let payload = /* construct transfer payload */;
        multisig_account::create_transaction(owner1, multisig_addr, payload);
        
        // Get 2/3 approvals
        multisig_account::approve_transaction(owner1, multisig_addr, 1);
        multisig_account::approve_transaction(owner2, multisig_addr, 1);
        
        // ATTACK: Fast forward 2 years (circumstances have changed)
        timestamp::fast_forward_seconds(63_072_000); // ~2 years
        
        // Malicious owner executes the 2-year-old transaction
        // This SHOULD fail but DOESN'T due to missing expiration check
        // The transaction executes successfully despite being stale
        
        // Verification: Transaction executed despite being created 2 years ago
        assert!(multisig_account::last_resolved_sequence_number(multisig_addr) == 1, 0);
    }
}
```

**Notes:**
- The `MultisigTransaction` struct stores `creation_time_secs` but has no expiration field or validation
- Transaction validation only checks the outer execution transaction's expiration, not the proposal's age  
- This enables governance integrity violations through execution of arbitrarily old approved transactions
- The fix requires adding expiration semantics to stored multisig proposals, not just the execution transactions

### Citations

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L147-158)
```text
    /// A transaction to be executed in a multisig account.
    /// This must contain either the full transaction payload or its hash (stored as bytes).
    struct MultisigTransaction has copy, drop, store {
        payload: Option<vector<u8>>,
        payload_hash: Option<vector<u8>>,
        // Mapping from owner adress to vote (yes for approve, no for reject). Uses a simple map to deduplicate.
        votes: SimpleMap<address, bool>,
        // The owner who created this transaction.
        creator: address,
        // The timestamp in seconds when the transaction was created.
        creation_time_secs: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1139-1183)
```text
    fun validate_multisig_transaction(
        owner: &signer, multisig_account: address, payload: vector<u8>) acquires MultisigAccount {
        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);
        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;
        assert_transaction_exists(multisig_account, sequence_number);

        if (features::multisig_v2_enhancement_feature_enabled()) {
            assert!(
                can_execute(address_of(owner), multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        }
        else {
            assert!(
                can_be_executed(multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        };

        // If the transaction payload is not stored on chain, verify that the provided payload matches the hashes stored
        // on chain.
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);
        if (option::is_some(&transaction.payload_hash)) {
            let payload_hash = option::borrow(&transaction.payload_hash);
            assert!(
                sha3_256(payload) == *payload_hash,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH_HASH),
            );
        };

        // If the transaction payload is stored on chain and there is a provided payload,
        // verify that the provided payload matches the stored payload.
        if (features::abort_if_multisig_payload_mismatch_enabled()
            && option::is_some(&transaction.payload)
            && !vector::is_empty(&payload)
        ) {
            let stored_payload = option::borrow(&transaction.payload);
            assert!(
                payload == *stored_payload,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH),
            );
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L139-142)
```text
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2829-2860)
```rust
        // Runs script prologue for all transaction types including multisig
        transaction_validation::run_script_prologue(
            session,
            module_storage,
            serialized_signers,
            txn_data,
            self.features(),
            log_context,
            traversal_context,
            self.is_simulation,
        )?;

        if let Some(multisig_address) = extra_config.multisig_address() {
            // Once "simulation_enhancement" is enabled, the simulation path also validates the
            // multisig transaction by running the multisig prologue.
            if !self.is_simulation
                || self
                    .features()
                    .is_transaction_simulation_enhancement_enabled()
            {
                transaction_validation::run_multisig_prologue(
                    session,
                    module_storage,
                    txn_data,
                    executable,
                    multisig_address,
                    self.features(),
                    log_context,
                    traversal_context,
                )?
            }
        }
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L398-448)
```rust
pub(crate) fn run_multisig_prologue(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl ModuleStorage,
    txn_data: &TransactionMetadata,
    executable: TransactionExecutableRef,
    multisig_address: AccountAddress,
    features: &Features,
    log_context: &AdapterLogSchema,
    traversal_context: &mut TraversalContext,
) -> Result<(), VMStatus> {
    let unreachable_error = VMStatus::error(StatusCode::UNREACHABLE, None);
    // Note[Orderless]: Earlier the `provided_payload` was being calculated as bcs::to_bytes(MultisigTransactionPayload::EntryFunction(entry_function)).
    // So, converting the executable to this format.
    let provided_payload = match executable {
        TransactionExecutableRef::EntryFunction(entry_function) => bcs::to_bytes(
            &MultisigTransactionPayload::EntryFunction(entry_function.clone()),
        )
        .map_err(|_| unreachable_error.clone())?,
        TransactionExecutableRef::Empty => {
            if features.is_abort_if_multisig_payload_mismatch_enabled() {
                vec![]
            } else {
                bcs::to_bytes::<Vec<u8>>(&vec![]).map_err(|_| unreachable_error.clone())?
            }
        },
        TransactionExecutableRef::Script(_) => {
            return Err(VMStatus::error(
                StatusCode::FEATURE_UNDER_GATING,
                Some("Script payload not supported for multisig transactions".to_string()),
            ));
        },
    };

    session
        .execute_function_bypass_visibility(
            &MULTISIG_ACCOUNT_MODULE,
            VALIDATE_MULTISIG_TRANSACTION,
            vec![],
            serialize_values(&vec![
                MoveValue::Signer(txn_data.sender),
                MoveValue::Address(multisig_address),
                MoveValue::vector_u8(provided_payload),
            ]),
            &mut UnmeteredGasMeter,
            traversal_context,
            module_storage,
        )
        .map(|_return_vals| ())
        .map_err(expect_no_verification_errors)
        .or_else(|err| convert_prologue_error(err, log_context))
}
```
