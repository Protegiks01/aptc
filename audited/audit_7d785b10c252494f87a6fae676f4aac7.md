# Audit Report

## Title
Non-Atomic Genesis Configuration Operations Lead to Repository Corruption

## Summary
The `SetValidatorConfiguration` command performs two sequential file write operations (`operator.yaml` and `owner.yaml`) without transactional guarantees. If the first write succeeds but the second fails due to network errors, disk failures, or process interruption, the genesis repository is left in an inconsistent state, preventing genesis generation and requiring manual intervention.

## Finding Description

The vulnerability exists in the `SetValidatorConfiguration::execute()` method [1](#0-0) , which performs two separate file operations:

Both the `Client::Local` and `Client::Github` implementations lack transactional semantics [2](#0-1) . Each `put()` call is independent:

- For **Local repositories**: Each write independently creates directories and writes files with no rollback mechanism
- For **GitHub repositories**: Each write makes a separate HTTP API call [3](#0-2)  with no transaction support

During genesis generation, the `get_config` function expects **both** files to exist [4](#0-3)  and [5](#0-4) . If either file is missing, the validator configuration cannot be loaded [6](#0-5) , causing the entire genesis generation to fail [7](#0-6) .

**Failure Scenarios:**
- **Network failures**: Connection timeout, API rate limiting, GitHub service outage between the two API calls
- **Disk errors**: Disk full, I/O error, filesystem corruption, quota exceeded
- **Process interruption**: SIGKILL, system crash, out-of-memory killer
- **Permission issues**: Second file write denied after first succeeds

## Impact Explanation

This qualifies as **HIGH severity** under the Aptos Bug Bounty program's "Significant protocol violations" category:

1. **Genesis Ceremony Failure**: The blockchain cannot be initialized until the inconsistent state is manually repaired
2. **Coordination Breakdown**: Multiple validators attempting genesis will encounter confusing errors about missing configurations
3. **Manual Intervention Required**: Operators must manually delete partial files or re-run commands, risking further errors
4. **No Automated Recovery**: The system provides no rollback, repair, or retry mechanisms

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable." The genesis repository represents shared coordination state among validators, and its corruption prevents the one-time genesis ceremony from completing successfully.

While not Critical severity (no funds at risk, no running chain affected), the impact is significant because genesis is a foundational operation that must succeed for the blockchain to launch.

## Likelihood Explanation

**HIGH likelihood** in production environments:

- **Network-dependent operations**: GitHub API calls are subject to timeouts, rate limits, and service interruptions that occur regularly in distributed systems
- **Disk operations**: Local filesystem writes can fail due to quota limits, disk full conditions, or I/O errors, especially in containerized or resource-constrained environments
- **No protective mechanisms**: The code has no retry logic, no atomic commit semantics, and no validation that both files were written successfully before returning

Genesis ceremonies typically involve multiple validators coordinating through a shared repository. With each validator running the command independently, the probability of at least one experiencing a transient failure is non-negligible.

## Recommendation

Implement transactional semantics for multi-file operations. For **local repositories**, use a two-phase commit pattern:

```rust
pub fn put_transactional(&self, operations: Vec<(PathBuf, Vec<u8>)>) -> CliTypedResult<()> {
    match self {
        Client::Local(local_repository_path) => {
            // Write to temporary files first
            let temp_files: Vec<_> = operations.iter().map(|(path, content)| {
                let full_path = local_repository_path.join(path);
                let temp_path = full_path.with_extension("tmp");
                (full_path, temp_path, content)
            }).collect();
            
            // Phase 1: Write all temp files
            for (_, temp_path, content) in &temp_files {
                if let Some(dir) = temp_path.parent() {
                    create_dir_if_not_exist(dir)?;
                }
                write_to_file(temp_path, &temp_path.display().to_string(), content)?;
            }
            
            // Phase 2: Atomically rename all files
            for (final_path, temp_path, _) in temp_files {
                std::fs::rename(&temp_path, &final_path)
                    .map_err(|e| CliError::IO(final_path.display().to_string(), e))?;
            }
        },
        Client::Github(_) => {
            // For GitHub, batch operations are not supported by the API
            // Best effort: document the non-transactional nature and add verification
            for (path, content) in operations {
                self.put(&path, content)?;
            }
            // Verify all files were written
            for (path, _) in operations {
                self.get(&path)?; // Will fail if file doesn't exist
            }
        }
    }
    Ok(())
}
```

Update `SetValidatorConfiguration::execute()` to use the transactional method:

```rust
let operations = vec![
    (operator_file, to_yaml(&operator_config)?.into_bytes()),
    (owner_file, to_yaml(&owner_config)?.into_bytes()),
];
git_client.put_transactional(operations)?;
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_transactional_safety {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_partial_write_leaves_inconsistent_state() {
        // Setup: Create temporary directory
        let temp_dir = TempDir::new().unwrap();
        let client = Client::local(temp_dir.path().to_path_buf());
        
        // Simulate validator configuration
        let username = "validator1";
        let operator_file = PathBuf::from(username).join("operator.yaml");
        let owner_file = PathBuf::from(username).join("owner.yaml");
        
        // Write operator file successfully
        let operator_content = "operator: test";
        client.put(&operator_file, &operator_content).unwrap();
        
        // Verify operator file exists
        assert!(temp_dir.path().join(&operator_file).exists());
        
        // Simulate failure: Make owner directory read-only
        let owner_dir = temp_dir.path().join(username);
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&owner_dir).unwrap().permissions();
            perms.set_mode(0o444); // Read-only
            fs::set_permissions(&owner_dir, perms).unwrap();
        }
        
        // Second write fails
        let owner_content = "owner: test";
        let result = client.put(&owner_file, &owner_content);
        assert!(result.is_err());
        
        // State is now inconsistent: operator.yaml exists, owner.yaml doesn't
        assert!(temp_dir.path().join(&operator_file).exists());
        assert!(!temp_dir.path().join(&owner_file).exists());
        
        // This inconsistent state will cause genesis generation to fail
        // when get_config() tries to read both files
    }
}
```

**Notes**

The vulnerability stems from treating multiple interdependent file operations as separate atomic operations rather than a single logical transaction. While individual `put()` operations are atomic, the **multi-file update required for validator configuration** is not. The genesis repository serves as a coordination mechanism for a distributed ceremony, making consistency guarantees critical. This issue is particularly problematic because genesis is typically a one-time operation where failures are unexpected and recovery procedures are not well-established.

### Citations

**File:** crates/aptos/src/genesis/keys.rs (L259-260)
```rust
        git_client.put(operator_file.as_path(), &operator_config)?;
        git_client.put(owner_file.as_path(), &owner_config)
```

**File:** crates/aptos/src/genesis/git.rs (L187-213)
```rust
    pub fn put<T: Serialize + ?Sized>(&self, name: &Path, input: &T) -> CliTypedResult<()> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(name);

                // Create repository path and any sub-directories
                if let Some(dir) = path.parent() {
                    self.create_dir(dir)?;
                } else {
                    return Err(CliError::UnexpectedError(format!(
                        "Path should always have a parent {}",
                        path.display()
                    )));
                }
                write_to_file(
                    path.as_path(),
                    &path.display().to_string(),
                    to_yaml(input)?.as_bytes(),
                )?;
            },
            Client::Github(client) => {
                client.put(&name.display().to_string(), &to_base64_encoded_yaml(input)?)?;
            },
        }

        Ok(())
    }
```

**File:** crates/aptos-github-client/src/lib.rs (L168-188)
```rust
    pub fn put(&self, path: &str, content: &str) -> Result<(), Error> {
        let json = match self.get_sha(path) {
            Ok(hash) => {
                json!({ "branch": self.branch.to_string(), "content": content, "message": format!("[aptos-management] {}", path), "sha": hash })
            },
            Err(Error::NotFound(_)) => {
                json!({ "branch": self.branch.to_string(), "content": content, "message": format!("[aptos-management] {}", path) })
            },
            Err(e) => return Err(e),
        };

        let resp = self
            .upgrade_request(ureq::put(&self.post_url(path)))
            .send_json(json);

        match resp.status() {
            200 => Ok(()),
            201 => Ok(()),
            _ => Err(resp.into()),
        }
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L334-340)
```rust
            Err(failure) => {
                if let CliError::UnexpectedError(failure) = failure {
                    errors.push(format!("{}: {}", user, failure));
                } else {
                    errors.push(format!("{}: {:?}", user, failure));
                }
            },
```

**File:** crates/aptos/src/genesis/mod.rs (L344-348)
```rust
    if errors.is_empty() {
        Ok(validators)
    } else {
        Err(errors)
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L361-361)
```rust
    let owner_config = client.get::<StringOwnerConfiguration>(owner_file)?;
```

**File:** crates/aptos/src/genesis/mod.rs (L454-454)
```rust
    let operator_config = client.get::<StringOperatorConfiguration>(operator_file)?;
```
