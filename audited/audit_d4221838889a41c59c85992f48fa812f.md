# Audit Report

## Title
Database State Divergence Causes Proposer Election Inconsistency in LeaderReputation Mode

## Summary
When `LeaderReputationType::ProposerAndVoterV2` is used (the default configuration), the `LeaderReputation` proposer election implementation includes the database accumulator root hash in its seed for weighted random proposer selection. Since `UnequivocalProposerElection.get_valid_proposer()` blindly delegates to this underlying implementation, validators with divergent database states will compute different valid proposers for the same round, causing them to incorrectly reject valid proposals and accept wrong proposals, leading to consensus liveness degradation.

## Finding Description

The vulnerability exists in the proposer election delegation chain: [1](#0-0) 

The `UnequivocalProposerElection` wrapper delegates `get_valid_proposer()` to the underlying proposer election without any consistency validation. When the underlying implementation is `LeaderReputation` with `use_root_hash=true` (default for V2+): [2](#0-1) 

The proposer selection includes the database root hash in its randomness seed: [3](#0-2) 

This root hash comes from the validator's local database state: [4](#0-3) 

**Critical Issues:**

1. **Empty event window returns `HashValue::zero()`** (line 151) - validators without historical data use a different seed
2. **Database query failures return `HashValue::zero()`** (line 161) - database errors cause inconsistent proposer selection  
3. **Different `max_version` values** (line 131) - validators with different sync states compute different versions, leading to different root hashes
4. **Acknowledged but unhandled** - the code warns "Elected proposers are unlikely to match!!" at line 120 but continues anyway

When validators have different database states (common during state sync lag, node startup, or database issues), they compute different root hashes, leading to different proposer selections. The proposal validation in `RoundManager` then rejects blocks: [5](#0-4) 

## Impact Explanation

This constitutes **High Severity** under the Aptos bug bounty criteria ("Validator node slowdowns" and "Significant protocol violations"):

1. **Consensus Liveness Degradation**: When validators disagree on the valid proposer, legitimate proposals fail to gather 2f+1 votes, causing round failures and reducing network throughput
2. **State Sync Amplification**: Validators lagging in state sync will consistently reject valid proposals, creating a feedback loop that further degrades their participation
3. **Network Partition Risk**: During network issues that cause database divergence, validators may split into groups that accept different proposers, severely impacting liveness
4. **Validator Set Instability**: New validators joining the network (with empty databases) will use `HashValue::zero()` as their seed, disagreeing with the rest of the network on proposer selection

The developers acknowledge this issue with the warning message but do not properly handle it, allowing the inconsistency to proceed.

## Likelihood Explanation

**High Likelihood** - This occurs naturally in production environments:

- State sync lag is common in distributed blockchain networks
- Validators joining the network start with empty/incomplete databases  
- Database pruning creates different historical windows across validators
- Network partitions temporarily cause database divergence
- Database I/O errors can trigger the `HashValue::zero()` fallback

The default configuration (`ProposerAndVoterV2`) enables this behavior, meaning all Aptos networks using default settings are affected.

## Recommendation

**Option 1 - Use Deterministic Seed (Immediate Fix):**
Disable `use_root_hash` for proposer selection to ensure all validators compute the same proposer deterministically: [6](#0-5) 

Change line 385 to always use `false` instead of `leader_reputation_type.use_root_hash_for_seed()`, or update the default configuration to use V1 mode.

**Option 2 - Consensus-Based Root Hash (Proper Fix):**
Instead of using the local database's root hash, use the root hash from the most recent committed block's QC. This ensures all validators agree on the seed source since QCs require 2f+1 validator signatures. Modify `LeaderReputation` to:
1. Extract the committed state root from the certified block
2. Use that agreed-upon hash in the seed
3. Only fall back to local database state if no recent QC is available (genesis case)

**Option 3 - Add Validation Layer:**
Add a verification mechanism in `UnequivocalProposerElection` that checks for proposer election consistency by comparing multiple rounds' selections for anomalies, and logging warnings when validators appear to be diverging.

## Proof of Concept

```rust
// Reproduction steps demonstrating the vulnerability:
// 1. Create two validator nodes with different database states
// 2. Configure both to use LeaderReputationType::ProposerAndVoterV2
// 3. Query proposer election for the same round

use aptos_consensus::liveness::leader_reputation::{LeaderReputation, AptosDBBackend};
use aptos_crypto::HashValue;

// Validator A: Has full historical data
// Database returns root_hash = HashValue::from_hex("0xabcd...")

// Validator B: Just joined network, empty database  
// Returns HashValue::zero() per line 151

// For round N with epoch E:
// Validator A computes: seed = [0xabcd..., E, N]
// Validator B computes: seed = [0x0000..., E, N]

// choose_index() with different seeds returns different indices
// Result: Validator A accepts proposer X, Validator B accepts proposer Y

// When proposer X broadcasts block for round N:
// - Validator A: is_valid_proposal() returns true
// - Validator B: is_valid_proposal() returns false, rejects block

// This can be reproduced by:
// 1. Setting up LocalBlockStorage with different states
// 2. Creating two LeaderReputation instances with use_root_hash=true
// 3. Calling get_valid_proposer() on both for the same round
// 4. Observing different proposer selections
```

## Notes

The vulnerability is explicitly acknowledged in the codebase with a warning message stating "Elected proposers are unlikely to match!!" but the system continues operation despite this known inconsistency. This suggests awareness of the issue but inadequate mitigation. The default V2 configuration prioritizes unpredictability (using root hash) over consistency, which is inappropriate for a safety-critical consensus protocol where all validators must agree on leader election results.

### Citations

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L23-26)
```rust
impl ProposerElection for UnequivocalProposerElection {
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposer_election.get_valid_proposer(round)
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L541-544)
```rust
    pub fn use_root_hash_for_seed(&self) -> bool {
        // all versions after V1 should use root hash
        !matches!(self, Self::ProposerAndVoter(_))
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L149-164)
```rust
        if result.is_empty() {
            warn!("No events in the requested window could be found");
            (result, HashValue::zero())
        } else {
            let root_hash = self
                .aptos_db
                .get_accumulator_root_hash(max_version)
                .unwrap_or_else(|_| {
                    error!(
                        "We couldn't fetch accumulator hash for the {} version, for {} epoch, {} round",
                        max_version, target_epoch, target_round,
                    );
                    HashValue::zero()
                });
            (result, root_hash)
        }
```

**File:** consensus/src/liveness/leader_reputation.rs (L717-730)
```rust
        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/src/epoch_manager.rs (L385-385)
```rust
                    leader_reputation_type.use_root_hash_for_seed(),
```
