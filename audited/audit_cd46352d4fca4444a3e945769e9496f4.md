# Audit Report

## Title
Inconsistent Error Metric Labeling Creates Monitoring Blind Spots in Storage Service

## Summary
The storage service's error tracking system uses inconsistent labeling across different error paths. While standard request errors use the `get_label()` function to populate the `STORAGE_ERRORS_ENCOUNTERED` metric with static labels, subscription request failures and invalid optimistic fetch errors bypass this standardized tracking, creating fragmented observability that could obscure attack patterns.

## Finding Description

The `get_label()` function in `error.rs` defines four static labels for error categorization: [1](#0-0) 

These labels are used to track errors in the `STORAGE_ERRORS_ENCOUNTERED` metric for standard request processing: [2](#0-1) 

However, **subscription request failures** follow a completely different error tracking path that bypasses the standard metric: [3](#0-2) 

When subscription requests fail validation in `add_subscription_request()`: [4](#0-3) 

These errors are handled by `handle_subscription_request_failure()`, which only updates `SUBSCRIPTION_EVENTS` with a "subscription_failure" label, not `STORAGE_ERRORS_ENCOUNTERED`.

Additionally, **invalid optimistic fetch errors** are logged but have no metric tracking at all: [5](#0-4) 

## Impact Explanation

This issue is correctly classified as **Low Severity** because:

1. **No direct security control is bypassed** - errors are still logged and handled appropriately
2. **Subscription errors are tracked** - just in a different metric (`SUBSCRIPTION_EVENTS` vs `STORAGE_ERRORS_ENCOUNTERED`)
3. **Request moderator protection remains active** - invalid requests still trigger peer blocking mechanisms
4. **No funds, consensus, or availability impact** - purely an observability/monitoring concern

The impact is limited to monitoring fragmentation: operators relying solely on `STORAGE_ERRORS_ENCOUNTERED` for alerting would miss subscription-related attack patterns, requiring them to also monitor `SUBSCRIPTION_EVENTS` and log analysis for optimistic fetch issues.

## Likelihood Explanation

The likelihood of exploitation is **low** because:
- Monitoring systems typically aggregate multiple metrics and logs
- The request moderator already provides rate limiting for misbehaving peers
- Subscription errors are still tracked (different metric) and logged
- No actual security control can be bypassed through this inconsistency

## Recommendation

Centralize all error tracking through a unified metric collection function:

```rust
// In handler.rs, create a unified error tracking function
fn track_error_metric(
    peer_network_id: &PeerNetworkId,
    error: &Error,
    error_context: &str,  // e.g., "standard", "subscription", "optimistic_fetch"
) {
    increment_counter(
        &metrics::STORAGE_ERRORS_ENCOUNTERED,
        peer_network_id.network_id(),
        error.get_label().into(),
    );
}

// Update handle_subscription_request_failure to use unified tracking
fn handle_subscription_request_failure(...) {
    // ... existing logging ...
    
    // Track in standard error metric
    track_error_metric(&peer_network_id, &error, "subscription");
    
    // Keep subscription-specific metric for backwards compatibility
    update_failed_subscription_metrics(peer_network_id);
    
    // ... existing response handling ...
}
```

Also track invalid optimistic fetch errors: [5](#0-4) 

Add metric tracking before the log statement:
```rust
fn remove_invalid_optimistic_fetches(...) {
    for peer_network_id in peers_with_invalid_optimistic_fetches {
        if let Some((peer_network_id, optimistic_fetch)) =
            optimistic_fetches.remove(&peer_network_id)
        {
            // Track the error in metrics
            let error = Error::InvalidRequest(
                "Mismatch between known version and epoch!".into()
            );
            increment_counter(
                &metrics::STORAGE_ERRORS_ENCOUNTERED,
                peer_network_id.network_id(),
                error.get_label().into(),
            );
            
            // ... existing warning log ...
        }
    }
}
```

## Proof of Concept

This is not a security vulnerability requiring a PoC, but the inconsistency can be demonstrated by:

1. Sending valid storage requests that fail → observe `STORAGE_ERRORS_ENCOUNTERED` metric increments with appropriate labels
2. Sending invalid subscription requests → observe only `SUBSCRIPTION_EVENTS` metric increments, no `STORAGE_ERRORS_ENCOUNTERED` update
3. Triggering invalid optimistic fetch → observe only logs, no metric updates

The labels from `get_label()` are consistently used where applied, but not all error paths use them, creating monitoring fragmentation rather than a security exploit.

---

**Notes:**

While this represents a genuine inconsistency in error metric labeling, it does **not** constitute a security vulnerability under the strict validation criteria. The issue is correctly categorized as "Low" severity and represents an observability/code quality concern rather than an exploitable security flaw. All errors are still logged, subscription errors have alternative tracking, and security controls (request moderation, rate limiting) remain effective. A proper fix would improve operational monitoring consistency but would not close any security gap.

### Citations

**File:** state-sync/storage-service/server/src/error.rs (L21-28)
```rust
    pub fn get_label(&self) -> &'static str {
        match self {
            Error::InvalidRequest(_) => "invalid_request",
            Error::StorageErrorEncountered(_) => "storage_error",
            Error::TooManyInvalidRequests(_) => "too_many_invalid_requests",
            Error::UnexpectedErrorEncountered(_) => "unexpected_error",
        }
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L152-158)
```rust
                Err(error) => {
                    // Update the error counter
                    increment_counter(
                        &metrics::STORAGE_ERRORS_ENCOUNTERED,
                        peer_network_id.network_id(),
                        error.get_label().into(),
                    );
```

**File:** state-sync/storage-service/server/src/handler.rs (L354-380)
```rust
    fn handle_subscription_request_failure(
        &self,
        peer_network_id: PeerNetworkId,
        request: StorageServiceRequest,
        error: Error,
        subscription_request: SubscriptionRequest,
    ) {
        // Something went wrong when adding the request to the stream
        sample!(
            SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
            warn!(LogSchema::new(LogEntry::SubscriptionRequest)
                .error(&error)
                .peer_network_id(&peer_network_id)
                .request(&request)
            );
        );

        // Update the subscription metrics
        update_failed_subscription_metrics(peer_network_id);

        // Notify the client of the failure
        self.send_response(
            request,
            Err(StorageServiceError::InvalidRequest(error.to_string())),
            subscription_request.take_response_sender(),
        );
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L346-355)
```rust
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L590-604)
```rust
    for peer_network_id in peers_with_invalid_optimistic_fetches {
        if let Some((peer_network_id, optimistic_fetch)) =
            optimistic_fetches.remove(&peer_network_id)
        {
            warn!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                .error(&Error::InvalidRequest(
                    "Mismatch between known version and epoch!".into()
                ))
                .request(&optimistic_fetch.request)
                .message(&format!(
                    "Dropping invalid optimistic fetch request for peer: {:?}!",
                    peer_network_id
                )));
        }
    }
```
