# Audit Report

## Title
Malicious Peers Can Bypass Mempool Health Checks via Fabricated Timestamp Injection

## Summary
Malicious peers can inject arbitrary `ledger_timestamp_usecs` values in `NodeInformationResponse` messages without validation, allowing them to bypass health checks in the mempool's peer prioritization logic. This enables attackers to maintain high priority for transaction broadcasting even when far behind sync or completely non-functional.

## Finding Description

The vulnerability exists in the peer monitoring service client's handling of `NodeInformationResponse` data and its subsequent use in mempool health checks.

**Vulnerable Code Flow**:

1. **Server generates legitimate response** [1](#0-0) 

2. **Client accepts response without validation** [2](#0-1) 

3. **Mempool retrieves unvalidated metadata** [3](#0-2) 

4. **Health check uses fabricated timestamp** [4](#0-3) 

**Attack Scenarios**:

**Scenario 1 - Future Timestamp Attack**: A malicious peer sends `ledger_timestamp_usecs` set to far future (e.g., current_time + 10 years). When the health check executes `current_timestamp_usecs.saturating_sub(peer_ledger_timestamp_usecs)`, the `saturating_sub` returns 0 (preventing underflow), making `0 < max_sync_lag_usecs` evaluate to `true`, marking the peer as healthy.

**Scenario 2 - Recent Timestamp Attack**: A malicious peer that is actually thousands of epochs behind sends `ledger_timestamp_usecs` set to current_time - 1 second, appearing perfectly synced and healthy.

The health check prioritizes "healthy" peers [5](#0-4) , enabling malicious peers to receive more transaction broadcasts from honest nodes.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Honest fullnodes and validators waste bandwidth broadcasting transactions to malicious peers that don't forward them, degrading network propagation efficiency.

2. **Significant Protocol Violations**: The peer prioritization mechanism is a critical protocol component for network efficiency. Manipulation breaks the trust model that peer-reported metadata is used for optimization decisions.

3. **Transaction Censorship Vector**: Malicious peers prioritized for broadcast can selectively drop transactions, enabling censorship attacks without requiring validator compromise.

4. **Network Resource Exhaustion**: Multiple malicious peers can collectively waste significant bandwidth of honest nodes, reducing overall network throughput.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Any peer can send crafted responses; no special privileges required
- **No Authentication**: The `ledger_timestamp_usecs` field has no cryptographic binding or cross-validation
- **Direct Impact**: Immediate effect on peer prioritization without complex setup
- **Low Cost**: Attacker only needs to run malicious peer nodes
- **Detection Difficulty**: Fabricated timestamps are indistinguishable from network delays in monitoring

## Recommendation

Implement timestamp validation in the peer monitoring service client:

```rust
// In peer-monitoring-service/client/src/peer_states/node_info.rs
pub fn record_node_info_response(&mut self, node_info_response: NodeInformationResponse) {
    // Validate timestamp is not in the future
    let current_time_usecs = self.time_service.now_unix_time().as_micros() as u64;
    let max_acceptable_drift_usecs = 60 * 1_000_000; // 60 seconds tolerance
    
    if node_info_response.ledger_timestamp_usecs > current_time_usecs + max_acceptable_drift_usecs {
        warn!("Rejecting node info response with future timestamp from peer");
        self.handle_request_failure();
        return;
    }
    
    // Validate timestamp is not too far in the past (beyond chain history)
    let max_history_secs = 7 * 24 * 3600; // 7 days
    let max_history_usecs = max_history_secs * 1_000_000;
    if current_time_usecs.saturating_sub(node_info_response.ledger_timestamp_usecs) > max_history_usecs {
        warn!("Rejecting node info response with ancient timestamp from peer");
        self.handle_request_failure();
        return;
    }
    
    // Update the request tracker with a successful response
    self.request_tracker.write().record_response_success();
    
    // Save the node info
    self.recorded_node_info_response = Some(node_info_response);
}
```

Additionally, consider cross-validating peer timestamps against the local node's highest synced ledger timestamp.

## Proof of Concept

```rust
#[test]
fn test_malicious_peer_future_timestamp_bypass() {
    use aptos_config::config::MempoolConfig;
    use aptos_time_service::TimeService;
    use aptos_peer_monitoring_service_types::{
        response::NodeInformationResponse, 
        PeerMonitoringMetadata
    };
    
    // Create a mempool config with 10 second max sync lag
    let mempool_config = MempoolConfig {
        max_sync_lag_before_unhealthy_secs: 10,
        ..MempoolConfig::default()
    };
    
    let time_service = TimeService::mock();
    let current_time_usecs = time_service.now_unix_time().as_micros() as u64;
    
    // Malicious peer sends timestamp from year 3000
    let future_timestamp = current_time_usecs + (1000 * 365 * 24 * 3600 * 1_000_000u64);
    
    let malicious_response = NodeInformationResponse {
        ledger_timestamp_usecs: future_timestamp,
        ..Default::default()
    };
    
    let malicious_metadata = PeerMonitoringMetadata {
        latest_node_info_response: Some(malicious_response),
        ..Default::default()
    };
    
    // The malicious peer appears healthy due to saturating_sub returning 0
    let is_healthy = check_peer_metadata_health(
        &mempool_config, 
        &time_service, 
        &Some(&malicious_metadata)
    );
    
    // This should be false but is true - demonstrating the vulnerability
    assert!(is_healthy, "Malicious peer with future timestamp bypassed health check!");
    
    // Compare with legitimate peer that is 15 seconds behind (should be unhealthy)
    let legitimate_old_timestamp = current_time_usecs - (15 * 1_000_000);
    let legitimate_response = NodeInformationResponse {
        ledger_timestamp_usecs: legitimate_old_timestamp,
        ..Default::default()
    };
    let legitimate_metadata = PeerMonitoringMetadata {
        latest_node_info_response: Some(legitimate_response),
        ..Default::default()
    };
    
    let is_legitimate_healthy = check_peer_metadata_health(
        &mempool_config,
        &time_service,
        &Some(&legitimate_metadata)
    );
    
    assert!(!is_legitimate_healthy, "Legitimate old peer correctly marked unhealthy");
    
    // Malicious peer is prioritized over legitimate peer - security violation
    assert!(is_healthy && !is_legitimate_healthy, 
        "Malicious peer prioritized over legitimate peer!");
}
```

**Notes**

This vulnerability violates the implicit security invariant that peer-reported metadata is bounded by reasonable values. While the mempool is pre-consensus and doesn't directly affect consensus safety, it impacts network efficiency and enables censorship vectors. The attack requires no validator privileges and is trivially exploitable by any network peer. The use of `saturating_sub` prevents arithmetic underflow but inadvertently enables the bypass when timestamps are in the future.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L259-281)
```rust
    fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the node information
        let build_information = aptos_build_info::get_build_information();
        let current_time: Instant = self.time_service.now();
        let uptime = current_time.duration_since(self.start_time);
        let (highest_synced_epoch, highest_synced_version) =
            self.storage.get_highest_synced_epoch_and_version()?;
        let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
        let lowest_available_version = self.storage.get_lowest_available_version()?;

        // Create and return the response
        let node_information_response = NodeInformationResponse {
            build_information,
            highest_synced_epoch,
            highest_synced_version,
            ledger_timestamp_usecs,
            lowest_available_version,
            uptime,
        };
        Ok(PeerMonitoringServiceResponse::NodeInformation(
            node_information_response,
        ))
    }
```

**File:** peer-monitoring-service/client/src/peer_states/node_info.rs (L47-53)
```rust
    pub fn record_node_info_response(&mut self, node_info_response: NodeInformationResponse) {
        // Update the request tracker with a successful response
        self.request_tracker.write().record_response_success();

        // Save the node info
        self.recorded_node_info_response = Some(node_info_response);
    }
```

**File:** mempool/src/shared_mempool/network.rs (L253-255)
```rust
                let monitoring_metadata = all_connected_peers
                    .get(peer)
                    .map(|metadata| metadata.get_peer_monitoring_metadata());
```

**File:** mempool/src/shared_mempool/priority.rs (L562-589)
```rust
fn check_peer_metadata_health(
    mempool_config: &MempoolConfig,
    time_service: &TimeService,
    monitoring_metadata: &Option<&PeerMonitoringMetadata>,
) -> bool {
    monitoring_metadata
        .and_then(|metadata| {
            metadata
                .latest_node_info_response
                .as_ref()
                .map(|node_information_response| {
                    // Get the peer's ledger timestamp and the current timestamp
                    let peer_ledger_timestamp_usecs =
                        node_information_response.ledger_timestamp_usecs;
                    let current_timestamp_usecs = get_timestamp_now_usecs(time_service);

                    // Calculate the max sync lag before the peer is considered unhealthy (in microseconds)
                    let max_sync_lag_secs =
                        mempool_config.max_sync_lag_before_unhealthy_secs as u64;
                    let max_sync_lag_usecs = max_sync_lag_secs * MICROS_PER_SECOND;

                    // Determine if the peer is healthy
                    current_timestamp_usecs.saturating_sub(peer_ledger_timestamp_usecs)
                        < max_sync_lag_usecs
                })
        })
        .unwrap_or(false) // If metadata is missing, consider the peer unhealthy
}
```

**File:** mempool/src/shared_mempool/priority.rs (L593-611)
```rust
fn compare_peer_health(
    mempool_config: &MempoolConfig,
    time_service: &TimeService,
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Check the health of the peer monitoring metadata
    let is_healthy_a =
        check_peer_metadata_health(mempool_config, time_service, monitoring_metadata_a);
    let is_healthy_b =
        check_peer_metadata_health(mempool_config, time_service, monitoring_metadata_b);

    // Compare the health statuses
    match (is_healthy_a, is_healthy_b) {
        (true, false) => Ordering::Greater, // A is healthy, B is unhealthy
        (false, true) => Ordering::Less,    // A is unhealthy, B is healthy
        _ => Ordering::Equal,               // Both are healthy or unhealthy
    }
}
```
