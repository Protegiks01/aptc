# Audit Report

## Title
Unreachable Code Bypasses Locals Safety Verification in Move Bytecode Verifier

## Summary
The Move bytecode verifier's locals safety analysis only examines reachable code blocks. Unreachable blocks containing `Ret` instructions with safety violations (e.g., returning with non-droppable locals still available) pass verification unchecked, violating Move's safety guarantees.

## Finding Description

The Move bytecode verifier implements locals safety checking through abstract interpretation. However, the abstract interpreter only analyzes blocks reachable from the function entry point, silently skipping unreachable blocks. [1](#0-0) 

When a block is not in the invariant map (`inv_map`), the comment claims this "can only happen when all predecessors have errors," but this is also true for unreachable blocks with no path from entry. The verifier skips these blocks entirely with `continue`, never analyzing their instructions. [2](#0-1) 

The CFG construction builds `traversal_successors` only for reachable blocks discovered via depth-first search from the entry block: [3](#0-2) 

The locals safety verifier checks `Ret` instructions to ensure all Available/MaybeAvailable locals have the `drop` ability: [4](#0-3) 

**Attack Path:**
1. Attacker crafts malicious bytecode (bypassing the compiler) with an unreachable block
2. That block contains: `StLoc(0)` storing a non-droppable value to local 0, followed by `Ret`
3. The bytecode passes all verification steps:
   - Control flow verification succeeds (unreachable blocks don't violate CFG properties)
   - Locals safety analysis skips the unreachable block
   - No error is raised for the safety violation in the `Ret` instruction
4. If the code later becomes reachable (VM bug, bytecode transformation, or future changes), it executes with violated safety invariants

## Impact Explanation

**Severity: High**

This violates **Move VM Safety** (Critical Invariant #3) by allowing bytecode that doesn't respect memory safety constraints to pass verification. While unreachable code cannot execute immediately, this breaks defense-in-depth:

1. **Verification Bypass**: The bytecode verifier is the final safety gate. It must reject ALL invalid bytecode, regardless of reachability, to prevent exploitation via VM bugs or future changes.

2. **VM Implementation Risk**: If a bug in the Move VM or JIT compiler makes unreachable code executable, the safety violation becomes exploitable.

3. **Consensus Risk**: Different validator implementations might have different bugs that trigger unreachable code. This could cause non-deterministic execution, breaking **Deterministic Execution** (Critical Invariant #1).

4. **Future Refactoring Risk**: Code transformations, optimizations, or bytecode versioning changes could make unreachable code reachable without re-verification.

Per Aptos Bug Bounty criteria, this is a **High Severity** "Significant protocol violation" - the verifier's core safety guarantee is compromised.

## Likelihood Explanation

**Likelihood: Medium-High**

While the Move compiler includes unreachable code removal passes, attackers can:
- Craft bytecode directly without using the compiler
- Exploit bugs in code generation that skip unreachable removal
- Target future bytecode versions with different verification rules

The vulnerability is deterministic and always exploitable when unreachable code with violations is submitted. The barrier is only the attacker's ability to deploy raw bytecode.

## Recommendation

The bytecode verifier must analyze ALL blocks in the CFG, not just reachable ones. Add explicit validation that unreachable code contains no safety violations, or reject bytecode with unreachable blocks entirely.

**Option 1: Reject unreachable code**
```rust
// In control_flow.rs after verify_reducibility
fn verify_all_blocks_reachable(function_view: &FunctionView) -> PartialVMResult<()> {
    let reachable = function_view.cfg().reachable_from(function_view.cfg().entry_block_id());
    let all_blocks = function_view.cfg().blocks();
    
    if reachable.len() != all_blocks.len() {
        return Err(PartialVMError::new(StatusCode::UNREACHABLE_CODE_FOUND));
    }
    Ok(())
}
```

**Option 2: Analyze all blocks**
```rust
// In absint.rs, modify analyze_function to verify all blocks
pub fn analyze_function(
    &mut self,
    initial_state: Self::State,
    function_view: &FunctionView,
    meter: &mut impl Meter,
) -> PartialVMResult<()> {
    // ... existing worklist algorithm ...
    
    // After worklist completes, verify all blocks were analyzed
    for block_id in function_view.cfg().blocks() {
        if !inv_map.contains_key(&block_id) {
            // Analyze unreachable block with initial state
            self.execute_block(block_id, &initial_state, function_view, meter)?;
        }
    }
    Ok(())
}
```

## Proof of Concept

```rust
// Add to third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/
use move_binary_format::file_format::{
    empty_module, Bytecode, CodeUnit, FunctionDefinition, FunctionHandle,
    IdentifierIndex, ModuleHandleIndex, Signature, SignatureIndex, SignatureToken,
    StructDefinition, StructHandle, StructHandleIndex, TypeSignature,
};
use move_bytecode_verifier::verify_module;
use move_core_types::identifier::Identifier;

#[test]
fn test_unreachable_ret_safety_violation() {
    let mut module = empty_module();
    
    // Create a non-droppable struct (no abilities)
    module.struct_handles.push(StructHandle {
        module: ModuleHandleIndex(0),
        name: IdentifierIndex(1),
        abilities: AbilitySet::EMPTY, // No drop ability
        type_parameters: vec![],
    });
    module.identifiers.push(Identifier::new("NonDroppable").unwrap());
    
    module.struct_defs.push(StructDefinition {
        struct_handle: StructHandleIndex(0),
        field_information: StructFieldInformation::Declared(vec![]),
    });
    
    // Signature for local of non-droppable type
    module.signatures.push(Signature(vec![
        SignatureToken::Struct(StructHandleIndex(0))
    ]));
    
    // Function with unreachable block containing safety violation
    module.function_handles.push(FunctionHandle {
        module: ModuleHandleIndex(0),
        name: IdentifierIndex(0),
        parameters: SignatureIndex(0),
        return_: SignatureIndex(0),
        type_parameters: vec![],
        access_specifiers: None,
        attributes: vec![],
    });
    
    module.function_defs.push(FunctionDefinition {
        function: FunctionHandleIndex(0),
        code: Some(CodeUnit {
            locals: SignatureIndex(1), // Local 0 is NonDroppable
            code: vec![
                // Reachable code - exits immediately
                Bytecode::Ret,
                
                // UNREACHABLE BLOCK - Should trigger safety violation but doesn't
                Bytecode::Pack(StructHandleIndex(0)), // Create non-droppable value
                Bytecode::StLoc(0), // Store to local 0
                Bytecode::Ret, // SAFETY VIOLATION: Returning with non-droppable local available
            ],
        }),
        ..Default::default()
    });
    
    module.identifiers.insert(0, Identifier::new("test").unwrap());
    
    // This should FAIL verification but PASSES because unreachable block is not analyzed
    let result = verify_module(&module);
    assert!(result.is_ok(), "Unreachable safety violation passed verification!");
}
```

The test demonstrates that bytecode with unreachable safety violations incorrectly passes verification, confirming the vulnerability.

**Notes**

This vulnerability exists at the core bytecode verification layer, affecting all Aptos nodes. The compiler's unreachable code removal is a separate layer that doesn't prevent manually crafted malicious bytecode from being submitted. The verifier must be the authoritative safety check, rejecting all invalid bytecode regardless of how it was generated or which blocks are reachable.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/absint.rs (L71-73)
```rust
        let entry_block_id = function_view.cfg().entry_block_id();
        let mut next_block = Some(entry_block_id);
        inv_map.insert(entry_block_id, BlockInvariant { pre: initial_state });
```

**File:** third_party/move/move-bytecode-verifier/src/absint.rs (L75-84)
```rust
        while let Some(block_id) = next_block {
            let block_invariant = match inv_map.get_mut(&block_id) {
                Some(invariant) => invariant,
                None => {
                    // This can only happen when all predecessors have errors,
                    // so skip the block and move on to the next one
                    next_block = function_view.cfg().next_block(block_id);
                    continue;
                },
            };
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L133-209)
```rust
        let mut exploration: Map<BlockId, Exploration> = Map::new();
        let mut stack = vec![ENTRY_BLOCK_ID];

        // For every loop in the CFG that is reachable from the entry block, there is an entry in
        // `loop_heads` mapping to all the back edges pointing to it, and vice versa.
        //
        // Entry in `loop_heads` implies loop in the CFG is justified by the comments in the loop
        // below.  Loop in the CFG implies entry in `loop_heads` is justified by considering the
        // point at which the first node in that loop, `F` is added to the `exploration` map:
        //
        // - By definition `F` is part of a loop, meaning there is a block `L` such that:
        //
        //     F - ... -> L -> F
        //
        // - `F` will not transition to `Done` until all the nodes reachable from it (including `L`)
        //   have been visited.
        // - Because `F` is the first node seen in the loop, all the other nodes in the loop
        //   (including `L`) will be visited while `F` is `InProgress`.
        // - Therefore, we will process the `L -> F` edge while `F` is `InProgress`.
        // - Therefore, we will record a back edge to it.
        let mut loop_heads: Map<BlockId, Set<BlockId>> = Map::new();

        // Blocks appear in `post_order` after all the blocks in their (non-reflexive) sub-graph.
        let mut post_order = Vec::with_capacity(blocks.len());

        while let Some(block) = stack.pop() {
            match exploration.entry(block) {
                Entry::Vacant(entry) => {
                    // Record the fact that exploration of this block and its sub-graph has started.
                    entry.insert(Exploration::InProgress);

                    // Push the block back on the stack to finish processing it, and mark it as done
                    // once its sub-graph has been traversed.
                    stack.push(block);

                    for succ in &blocks[&block].successors {
                        match exploration.get(succ) {
                            // This successor has never been visited before, add it to the stack to
                            // be explored before `block` gets marked `Done`.
                            None => stack.push(*succ),

                            // This block's sub-graph was being explored, meaning it is a (reflexive
                            // transitive) predecessor of `block` as well as being a successor,
                            // implying a loop has been detected -- greedily choose the successor
                            // block as the loop head.
                            Some(Exploration::InProgress) => {
                                loop_heads.entry(*succ).or_default().insert(block);
                            },

                            // Cross-edge detected, this block and its entire sub-graph (modulo
                            // cycles) has already been explored via a different path, and is
                            // already present in `post_order`.
                            Some(Exploration::Done) => { /* skip */ },
                        };
                    }
                },

                Entry::Occupied(mut entry) => match entry.get() {
                    // Already traversed the sub-graph reachable from this block, so skip it.
                    Exploration::Done => continue,

                    // Finish up the traversal by adding this block to the post-order traversal
                    // after its sub-graph (modulo cycles).
                    Exploration::InProgress => {
                        post_order.push(block);
                        entry.insert(Exploration::Done);
                    },
                },
            }
        }

        let traversal_order = {
            // This reverse post order is akin to a topological sort (ignoring cycles) and is
            // different from a pre-order in the presence of diamond patterns in the graph.
            post_order.reverse();
            post_order
        };
```

**File:** third_party/move/move-bytecode-verifier/src/locals_safety/mod.rs (L73-90)
```rust
        Bytecode::Ret => {
            let local_states = state.local_states();
            meter.add_items(Scope::Function, RET_PER_LOCAL_COST, local_states.len())?;
            let all_local_abilities = state.all_local_abilities();
            assert!(local_states.len() == all_local_abilities.len());
            for (local_state, local_abilities) in local_states.iter().zip(all_local_abilities) {
                match local_state {
                    LocalState::MaybeAvailable | LocalState::Available
                        if !local_abilities.has_drop() =>
                    {
                        return Err(
                            state.error(StatusCode::UNSAFE_RET_UNUSED_VALUES_WITHOUT_DROP, offset)
                        )
                    },
                    _ => (),
                }
            }
        },
```
