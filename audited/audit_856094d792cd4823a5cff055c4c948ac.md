# Audit Report

## Title
Missing Base Gas Cost for BCS Serialization Causes Undercharging for Zero-Sized Types

## Summary
The `bcs::to_bytes` native function lacks a base gas cost, charging only per-byte serialization costs. When serializing empty structs (zero-sized types), which produce zero bytes of output, no gas is charged for the computational work performed after the initial struct definition loading. This violates gas metering principles and creates a resource fairness issue.

## Finding Description

The `native_to_bytes` function in `bcs.rs` charges gas only based on the serialized output size, with no base cost for the operation itself. [1](#0-0) 

The gas schedule defines only a per-byte cost for `bcs::to_bytes`, unlike other similar operations: [2](#0-1) 

Compare this to `bcs::serialized_size`, which correctly charges a base cost: [3](#0-2) [4](#0-3) 

Empty structs exist in production code throughout the Aptos framework: [5](#0-4) 

When an empty struct is serialized via BCS, it produces zero bytes (empty tuple serialization): [6](#0-5) 

**Attack Path:**
1. User creates or references an empty struct type (e.g., `Untransferable {}` from the framework)
2. In a transaction, repeatedly calls `bcs::to_bytes` on instances of the empty struct
3. First call charges gas for struct definition loading (cached afterwards)
4. Subsequent calls perform computational work but charge 0 gas:
   - Reference reading (line 93)
   - Serialization context setup (lines 95-100)
   - BCS serialization logic execution
   - Vector allocation
5. Each call charges: `36 * 0 = 0` gas units for serialization work

## Impact Explanation

This is a **Low Severity** issue that constitutes a non-critical implementation bug and minor gas metering inefficiency. While it violates Invariant #9 (Resource Limits), the actual impact is limited:

- The computational cost per undercharged call is minimal (reference read of empty struct, context setup)
- Transaction gas limits prevent massive exploitation within a single transaction
- Does not cause fund loss, consensus breaks, or critical availability issues
- Represents a fairness issue rather than a security vulnerability

The issue does not meet Critical, High, or Medium severity thresholds as it does not cause validator node slowdowns at scale, significant protocol violations, or state manipulation requiring intervention.

## Likelihood Explanation

Likelihood is LOW. While technically exploitable by any user:
- The per-call resource savings are minimal
- Transaction gas limits cap total exploitation
- Attack provides minimal benefit to the attacker
- Not economically attractive for abuse at scale

## Recommendation

Add a base gas cost to `bcs::to_bytes` consistent with `bcs::serialized_size`. Update the gas schedule:

```rust
[bcs_to_bytes_base: InternalGas, "bcs.to_bytes.base", 735],
[bcs_to_bytes_per_byte_serialized: InternalGasPerByte, "bcs.to_bytes.per_byte_serialized", 36],
```

Update `native_to_bytes` to charge the base cost before serialization (after type layout construction).

## Proof of Concept

```move
module 0x1::exploit {
    use std::bcs;
    
    struct Empty {}
    
    public entry fun exploit_gas_undercharge() {
        let empty = Empty {};
        
        // First call charges for struct definition loading
        let _ = bcs::to_bytes(&empty);
        
        // Subsequent calls in loop charge 0 gas for serialization
        // (only module dependency gas if not cached)
        let i = 0;
        while (i < 1000) {
            let _ = bcs::to_bytes(&empty); // Each charges 0 gas
            i = i + 1;
        };
    }
}
```

Each `bcs::to_bytes` call after caching performs computational work (reference reading, serialization setup, BCS logic execution) but charges 0 gas since the output is 0 bytes.

## Notes

This issue was identified as part of examining edge cases in BCS serialization. While it represents a legitimate gas metering bug where computational work is undercharged, the practical security impact is minimal due to:

1. **Limited per-call cost**: The computational overhead of serializing an empty struct is very small
2. **Transaction gas limits**: Prevent unbounded exploitation within single transactions  
3. **Caching mechanisms**: Struct definition loading (the more expensive operation) is cached

The fix is straightforward and aligns with the gas charging pattern used by other native functions (`bcs::serialized_size`, `hash::sha2_256`, etc.) which all include base costs to account for fixed operational overhead regardless of input/output size.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L110-111)
```rust
    context
        .charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L133-133)
```rust
    context.charge(BCS_SERIALIZED_SIZE_BASE)?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L20-21)
```rust
        [bcs_to_bytes_per_byte_serialized: InternalGasPerByte, "bcs.to_bytes.per_byte_serialized", 36],
        [bcs_to_bytes_failure: InternalGas, "bcs.to_bytes.failure", 3676],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L42-44)
```rust
        [bcs_serialized_size_base: InternalGas, { RELEASE_V1_18.. => "bcs.serialized_size.base" }, 735],
        [bcs_serialized_size_per_byte_serialized: InternalGasPerByte, { RELEASE_V1_18.. => "bcs.serialized_size.per_byte_serialized" }, 36],
        [bcs_serialized_size_failure: InternalGas, { RELEASE_V1_18.. => "bcs.serialized_size.failure" }, 3676],
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L119-123)
```text
    struct Untransferable has key {}

    #[resource_group(scope = global)]
    /// A shared resource group for storing object resources together in storage.
    struct ObjectGroup {}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5062-5079)
```rust
            let field_layouts = self.layout.fields(None);
            let mut t = serializer.serialize_tuple(values.len())?;
            if field_layouts.len() != values.len() {
                return Err(invariant_violation::<S>(format!(
                    "cannot serialize struct value {:?} as {:?} -- number of fields mismatch",
                    self.value, self.layout
                )));
            }
            for (field_layout, value) in field_layouts.iter().zip(values.iter()) {
                t.serialize_element(&SerializationReadyValue {
                    ctx: self.ctx,
                    layout: field_layout,
                    value,
                    depth: self.depth + 1,
                })?;
            }
            t.end()
        }
```
