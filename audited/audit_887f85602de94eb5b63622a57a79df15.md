# Audit Report

## Title
Rosetta API Incorrectly Reports Pending Inactive Balances Including Operator Commission

## Summary
The `get_stake_balances()` function in the Rosetta API returns the total `stake_pool.pending_inactive` value when querying a staker's pending_inactive balance, incorrectly including the operator's unlocked commission. This causes over-reporting of staker balances and under-reporting of operator commission balances.

## Finding Description

The vulnerability exists in the balance reporting logic for staking contracts via the Rosetta API. [1](#0-0) 

When commission is extracted or stake is unlocked in the staking_contract module, funds move from `active` to `pending_inactive` in the underlying stake pool. [2](#0-1) [3](#0-2) 

The staking_contract module correctly tracks individual ownership via a `distribution_pool` using share-based accounting. [4](#0-3)  Each recipient (staker or operator) receives shares when their funds are unlocked. [5](#0-4) 

However, the Rosetta API bypasses this distribution_pool accounting and directly returns the aggregate `stake_pool.pending_inactive` value, which contains funds belonging to multiple parties (stakers and operators).

**Attack Scenario:**
1. Staker has 1000 active stake (900 principal + 100 rewards), commission rate 10%
2. Staker calls `unlock_stake(600)`
3. First, `request_commission_internal` extracts 10 commission → moves to pending_inactive [6](#0-5) 
4. Then 600 staker funds → moves to pending_inactive
5. Total `pending_inactive` = 610 (10 operator + 600 staker)
6. Rosetta API query for staker's pending_inactive returns **610** instead of **600**
7. Rosetta API query for operator's commission returns **0** (calculated from current active only) [7](#0-6)  instead of **10**

## Impact Explanation

**Severity Assessment: LOW**

While the question categorizes this as "High", this bug does not meet the Aptos Bug Bounty criteria for High or Medium severity:

- **Not High Severity**: Does not cause validator slowdowns, API crashes, or protocol violations. The API returns incorrect values but continues functioning.
  
- **Not Medium Severity**: No direct funds loss or manipulation. The underlying staking_contract module tracks all funds correctly in the distribution_pool. Actual withdrawals via `distribute_internal` work correctly as they query the distribution_pool, not the Rosetta API.

- **Fits Low Severity**: This is a "non-critical implementation bug" - an API layer reporting inaccuracy that does not affect the blockchain protocol itself.

**Actual Impact:**
- Integrators (wallets, explorers) using Rosetta API display incorrect balances
- User confusion about reported vs actual balances
- Potential downstream accounting discrepancies in systems relying on Rosetta API
- No direct theft, fund loss, consensus impact, or protocol manipulation possible

## Likelihood Explanation

**Likelihood: HIGH** (for the bug manifesting, not for exploitation)

This bug manifests whenever:
1. Any staker has a staking contract with non-zero commission
2. The staker or operator requests commission or unlocks stake
3. An integrator queries balances via Rosetta API before distribution occurs

However, this is **not exploitable** for direct financial gain or protocol manipulation. The bug only affects API-layer reporting; the protocol correctly tracks all funds.

## Recommendation

The Rosetta API should query the staking contract's `distribution_pool` to determine the specific owner's share of `pending_inactive` funds, rather than returning the aggregate pool value.

**Recommended Fix:**

The Rosetta API should either:
1. Call a new view function in staking_contract.move that queries `pool_u64::balance(distribution_pool, owner_address)` to get the owner's specific share of inactive+pending_inactive funds, or
2. For staker pending_inactive: Return `pending_inactive - (commission already in pending_inactive)`
3. For operator commission: Include both active commission and pending_inactive commission

A proper implementation would require adding a view function to staking_contract.move:

```move
#[view]
public fun get_distribution_amount(staker: address, operator: address, recipient: address): u64 {
    let staking_contracts = &borrow_global<Store>(staker).staking_contracts;
    let staking_contract = simple_map::borrow(staking_contracts, &operator);
    pool_u64::balance(&staking_contract.distribution_pool, recipient)
}
```

Then update the Rosetta API to call this function instead of using `stake_pool.pending_inactive` directly.

## Proof of Concept

```move
#[test(aptos_framework = @0x1, staker = @0xAAA, operator = @0xBBB)]
public entry fun test_pending_inactive_reporting_bug(
    aptos_framework: &signer, staker: &signer, operator: &signer
) {
    // Setup staking contract with 10% commission
    setup_staking_contract(aptos_framework, staker, operator, 100000, 10);
    
    let staker_addr = signer::address_of(staker);
    let operator_addr = signer::address_of(operator);
    let pool_addr = stake_pool_address(staker_addr, operator_addr);
    
    // Earn rewards to generate commission
    stake::end_epoch(); // Accumulate 100 coins reward
    
    // Unlock stake - this will extract 10 commission + 600 staker funds
    unlock_stake(staker, operator_addr, 600);
    
    // Query stake pool directly - shows 610 total pending_inactive
    let (_, _, _, pending_inactive) = stake::get_stake(pool_addr);
    assert!(pending_inactive == 610, 0); // 10 operator + 600 staker
    
    // Rosetta API would incorrectly return 610 for staker's pending_inactive
    // But staker only unlocked 600 - the other 10 is operator's commission
    
    // Query distribution pool - shows correct individual amounts
    let staker_distribution = pool_u64::balance(&get_distribution_pool(staker_addr, operator_addr), staker_addr);
    let operator_distribution = pool_u64::balance(&get_distribution_pool(staker_addr, operator_addr), operator_addr);
    
    assert!(staker_distribution == 600, 1); // Correct
    assert!(operator_distribution == 10, 2); // Correct
}
```

---

**Note**: While this is a valid bug in balance reporting, it does not meet the threshold for Critical, High, or Medium severity per the Aptos Bug Bounty criteria, as it does not enable fund theft, protocol manipulation, consensus violations, or cause system unavailability. It is an API-layer reporting inaccuracy with no direct security impact on the blockchain protocol itself.

### Citations

**File:** crates/aptos-rosetta/src/types/misc.rs (L354-356)
```rust
        } else if owner_account.is_pending_inactive_stake() {
            // pending_inactive will not have commission because commission has already been extracted
            requested_balance = Some(stake_pool.pending_inactive.to_string());
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L72-84)
```text
    struct StakingContract has store {
        // Recorded principal after the last commission distribution.
        // This is only used to calculate the commission the operator should be receiving.
        principal: u64,
        pool_address: address,
        // The stake pool's owner capability. This can be used to control funds in the stake pool.
        owner_cap: OwnerCapability,
        commission_percentage: u64,
        // Current distributions, including operator commission withdrawals and staker's partial withdrawals.
        distribution_pool: Pool,
        // Just in case we need the SignerCap for stake pool account in the future.
        signer_cap: SignerCapability
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L699-701)
```text
        // Request to unlock the commission from the stake pool.
        // This won't become fully unlocked until the stake pool's lockup expires.
        stake::unlock_with_cap(commission_amount, &staking_contract.owner_cap);
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L753-759)
```text
        let commission_paid =
            request_commission_internal(
                operator,
                staking_contract,
                &mut store.add_distribution_events,
                &mut store.request_commission_events
            );
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L778-780)
```text
        // Request to unlock the distribution amount from the stake pool.
        // This won't become fully unlocked until the stake pool's lockup expires.
        stake::unlock_with_cap(amount, &staking_contract.owner_cap);
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1028-1054)
```text
        operator: address,
        staking_contract: &mut StakingContract,
        recipient: address,
        coins_amount: u64,
        add_distribution_events: &mut EventHandle<AddDistributionEvent>
    ) {
        let distribution_pool = &mut staking_contract.distribution_pool;
        let (_, _, _, total_distribution_amount) =
            stake::get_stake(staking_contract.pool_address);
        update_distribution_pool(
            distribution_pool,
            total_distribution_amount,
            operator,
            staking_contract.commission_percentage
        );

        pool_u64::buy_in(distribution_pool, recipient, coins_amount);
        let pool_address = staking_contract.pool_address;
        if (std::features::module_event_migration_enabled()) {
            emit(AddDistribution { operator, pool_address, amount: coins_amount });
        } else {
            emit_event(
                add_distribution_events,
                AddDistributionEvent { operator, pool_address, amount: coins_amount }
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1057-1072)
```text
    fun get_staking_contract_amounts_internal(
        staking_contract: &StakingContract
    ): (u64, u64, u64) {
        // Pending_inactive is not included in the calculation because pending_inactive can only come from:
        // 1. Outgoing commissions. This means commission has already been extracted.
        // 2. Stake withdrawals from stakers. This also means commission has already been extracted as
        // request_commission_internal is called in unlock_stake
        let (active, _, pending_active, _) =
            stake::get_stake(staking_contract.pool_address);
        let total_active_stake = active + pending_active;
        let accumulated_rewards = total_active_stake - staking_contract.principal;
        let commission_amount =
            accumulated_rewards * staking_contract.commission_percentage / 100;

        (total_active_stake, accumulated_rewards, commission_amount)
    }
```
