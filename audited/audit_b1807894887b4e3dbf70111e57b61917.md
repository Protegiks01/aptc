# Audit Report

## Title
Silent Failure in Global Data Summary Refresh Causes Indefinite Stale Data Operation in State Sync Service

## Summary
The `refresh_global_data_summary()` function in the Data Streaming Service logs and ignores errors when fetching updated global data summaries, allowing the service to operate indefinitely with stale or empty cached data. This creates a denial-of-service condition where stream creation fails even when data is available, and can prevent nodes from synchronizing state properly.

## Finding Description

The vulnerability exists in the error handling path of `refresh_global_data_summary()`: [1](#0-0) 

When `fetch_global_data_summary()` returns an error, the function only logs it and increments a metric counter without updating the cached `global_data_summary`. This breaks the following security guarantees:

**1. Service Initialization Failure**: The service initializes with an empty `GlobalDataSummary`: [2](#0-1) 

If all initial refresh attempts fail, the cache remains empty permanently, causing all stream creation requests to fail.

**2. Stream Creation Rejection**: When creating new streams, the service validates against the cached advertised data: [3](#0-2) 

If the cache contains stale data (e.g., versions 0-1000) but clients request newer data (e.g., versions 1500-2000), stream creation fails with `Error::DataIsUnavailable` even though the data exists in the network.

**3. Error Condition Trigger**: The fetch fails when `verify_optimal_chunk_sizes()` detects zero chunk sizes: [4](#0-3) 

Zero chunk sizes occur when the underlying `AptosDataClient` calculates them from peer storage summaries where a majority of peers advertise zero values: [5](#0-4) 

The median calculation in `median_or_max()` returns 0 if the median peer-advertised chunk size is 0: [6](#0-5) 

**Attack Scenario**:
1. Attacker controls a majority of peers connected to victim node OR exploits network partition
2. Malicious peers advertise `ProtocolMetadata` with zero chunk sizes
3. Victim node's `AptosDataClient` calculates global summary with zero optimal chunk sizes
4. `refresh_global_data_summary()` in streaming service fails validation and logs error
5. Cached data remains stale/empty indefinitely
6. All new stream creation attempts fail, preventing state synchronization
7. Node becomes unable to sync state, degrading network participation

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Validators cannot create new data streams to sync state, degrading consensus participation
- **Significant protocol violations**: State sync service operates with fundamentally incorrect network state view
- **Service availability**: Full nodes cannot serve sync requests correctly, impacting network health

The vulnerability enables:
1. **Persistent DoS**: Service becomes permanently unusable if initial refreshes fail
2. **Stale Data Operations**: Service makes decisions based on outdated network state (wrong advertised ranges, wrong optimal chunk sizes)
3. **Cascade Failures**: Nodes unable to sync may fall behind and eventually drop from validator set

Unlike transient network issues, this vulnerability has no recovery mechanism - the service continues operating with stale data until manual intervention.

## Likelihood Explanation

**Likelihood: Medium to High**

Triggering conditions:
1. **Malicious Peer Attack**: Attacker needs majority control of peers connected to victim (high bar for well-connected nodes, but feasible during network partitions or for isolated nodes)
2. **Network Partition**: During network splits, nodes may only connect to a subset of peers with invalid storage summaries
3. **Implementation Bugs**: Bugs in peer storage summary calculation could produce zero chunk sizes
4. **Startup Race Condition**: Service starts before data client establishes peer connections, leaving cache empty

The vulnerability is particularly severe because:
- The background refresh task runs every 50ms by default, continuously failing without recovery
- There's no circuit breaker or maximum staleness threshold
- The error is only logged, not monitored by operational alerts
- Manual intervention is required to recover [7](#0-6) 

## Recommendation

Implement proper error handling with staleness detection and circuit breaker:

```rust
fn refresh_global_data_summary<T: AptosDataClientInterface + Send + Clone + 'static>(
    aptos_data_client: T,
    cached_global_data_summary: Arc<ArcSwap<GlobalDataSummary>>,
) {
    // Fetch the global data summary and update the cache
    match fetch_global_data_summary(aptos_data_client) {
        Ok(global_data_summary) => {
            // Update the cached global data summary
            cached_global_data_summary.store(Arc::new(global_data_summary));
        },
        Err(error) => {
            // Log error and increment counter
            sample!(
                SampleRate::Duration(Duration::from_secs(GLOBAL_DATA_REFRESH_LOG_FREQ_SECS)),
                warn!(LogSchema::new(LogEntry::RefreshGlobalData)
                    .event(LogEvent::Error)
                    .error(&error))
            );
            metrics::increment_counter(&metrics::GLOBAL_DATA_SUMMARY_ERROR, error.get_label());
            
            // **FIX**: Store empty summary to force stream validation failures
            // This ensures streams fail fast rather than operating with stale data
            cached_global_data_summary.store(Arc::new(GlobalDataSummary::empty()));
        },
    }
}
```

Additional improvements:
1. Add staleness threshold checking before stream creation
2. Implement circuit breaker that pauses service after N consecutive failures
3. Add health check endpoint exposing last successful refresh timestamp
4. Fail stream creation if data summary is empty rather than silently returning stale data

## Proof of Concept

```rust
// Reproduction test demonstrating the vulnerability
#[tokio::test]
async fn test_stale_data_on_persistent_refresh_failure() {
    use aptos_data_client::global_summary::{GlobalDataSummary, OptimalChunkSizes};
    
    // Create mock data client that returns invalid chunk sizes
    let mock_data_client = create_mock_client_with_zero_chunk_sizes();
    
    // Create streaming service
    let config = DataStreamingServiceConfig::default();
    let (stream_requests, _) = aptos_channel::new(QueueStyle::LIFO, 10, None);
    let streaming_service = DataStreamingService::new(
        AptosDataClientConfig::default(),
        config,
        mock_data_client,
        stream_requests,
        TimeService::mock(),
    );
    
    // Initial cache is empty
    assert!(streaming_service.get_global_data_summary().is_empty());
    
    // Attempt refresh - this will fail due to zero chunk sizes
    refresh_global_data_summary(
        streaming_service.aptos_data_client.clone(),
        streaming_service.global_data_summary.clone(),
    );
    
    // Cache remains empty even after refresh attempt
    assert!(streaming_service.get_global_data_summary().is_empty());
    
    // Try to create stream - this will fail with DataIsUnavailable
    // even if the actual network has the requested data
    let result = streaming_service.process_new_stream_request(
        &create_transaction_stream_request(0, 1000),
        create_stream_update_notifier(),
    );
    
    // Demonstrates DoS: stream creation fails due to stale/empty cache
    assert!(matches!(result, Err(Error::DataIsUnavailable(_))));
}

fn create_mock_client_with_zero_chunk_sizes() -> MockAptosDataClient {
    // Mock client that returns GlobalDataSummary with zero optimal chunk sizes
    // This simulates malicious peers advertising invalid metadata
    let mut mock = MockAptosDataClient::new();
    mock.expect_get_global_data_summary()
        .returning(|| GlobalDataSummary {
            advertised_data: AdvertisedData::empty(),
            optimal_chunk_sizes: OptimalChunkSizes {
                epoch_chunk_size: 0,  // Invalid!
                state_chunk_size: 0,
                transaction_chunk_size: 0,
                transaction_output_chunk_size: 0,
            },
        });
    mock
}
```

**Demonstration Steps**:
1. Node starts with empty global data summary cache
2. Background refresher attempts to fetch updated summary
3. Data client returns summary with zero chunk sizes (from malicious/buggy peers)
4. `verify_optimal_chunk_sizes()` returns error
5. Error is logged but cache remains empty
6. All subsequent stream creation requests fail with `DataIsUnavailable`
7. Node cannot sync state, degrading network participation

This violates the **State Consistency** and **Resource Limits** invariants by allowing the service to operate in an invalid state indefinitely.

## Notes

The vulnerability exists at the intersection of two caching layers:
1. `AptosDataClient.global_summary_cache` (updated by poller from peer states)
2. `DataStreamingService.global_data_summary` (updated by periodic refresh)

The streaming service cache becomes permanently stale when the data client cache contains invalid data (zero chunk sizes), creating a persistent failure mode without recovery. The 50ms refresh interval means the service continuously fails without operator visibility beyond logs and metrics.

### Citations

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L106-106)
```rust
            global_data_summary: Arc::new(ArcSwap::new(Arc::new(GlobalDataSummary::empty()))),
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L266-287)
```rust
        refresh_global_data_summary(
            self.aptos_data_client.clone(),
            self.global_data_summary.clone(),
        );

        // Create a new data stream
        let stream_id = self.stream_id_generator.next();
        let advertised_data = self.get_global_data_summary().advertised_data.clone();
        let (data_stream, stream_listener) = DataStream::new(
            self.data_client_config,
            self.streaming_service_config,
            stream_id,
            &request_message.stream_request,
            stream_update_notifier,
            self.aptos_data_client.clone(),
            self.notification_id_generator.clone(),
            &advertised_data,
            self.time_service.clone(),
        )?;

        // Verify the data stream can be fulfilled using the currently advertised data
        data_stream.ensure_data_is_available(&advertised_data)?;
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L430-451)
```rust
/// Refreshes the global data summary and updates the cache
fn refresh_global_data_summary<T: AptosDataClientInterface + Send + Clone + 'static>(
    aptos_data_client: T,
    cached_global_data_summary: Arc<ArcSwap<GlobalDataSummary>>,
) {
    // Fetch the global data summary and update the cache
    match fetch_global_data_summary(aptos_data_client) {
        Ok(global_data_summary) => {
            // Update the cached global data summary
            cached_global_data_summary.store(Arc::new(global_data_summary));
        },
        Err(error) => {
            // Otherwise, log an error and increment the error counter
            sample!(
                SampleRate::Duration(Duration::from_secs(GLOBAL_DATA_REFRESH_LOG_FREQ_SECS)),
                warn!(LogSchema::new(LogEntry::RefreshGlobalData)
                    .event(LogEvent::Error)
                    .error(&error))
            );
            metrics::increment_counter(&metrics::GLOBAL_DATA_SUMMARY_ERROR, error.get_label());
        },
    }
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L478-490)
```rust
fn verify_optimal_chunk_sizes(optimal_chunk_sizes: &OptimalChunkSizes) -> Result<(), Error> {
    if optimal_chunk_sizes.state_chunk_size == 0
        || optimal_chunk_sizes.epoch_chunk_size == 0
        || optimal_chunk_sizes.transaction_chunk_size == 0
        || optimal_chunk_sizes.transaction_output_chunk_size == 0
    {
        Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Found at least one optimal chunk size of zero: {:?}",
            optimal_chunk_sizes
        )))
    } else {
        Ok(())
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L396-407)
```rust
        // Calculate optimal chunk sizes based on the advertised data
        let optimal_chunk_sizes = calculate_optimal_chunk_sizes(
            &self.data_client_config,
            max_epoch_chunk_sizes,
            max_state_chunk_sizes,
            max_transaction_chunk_sizes,
            max_transaction_output_chunk_sizes,
        );
        GlobalDataSummary {
            advertised_data,
            optimal_chunk_sizes,
        }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L448-456)
```rust
fn median_or_max<T: Ord + Copy>(mut values: Vec<T>, max_value: T) -> T {
    // Calculate median
    values.sort_unstable();
    let idx = values.len() / 2;
    let median = values.get(idx).copied();

    // Return median or max
    min(median.unwrap_or(max_value), max_value)
}
```

**File:** config/src/config/state_sync_config.rs (L270-270)
```rust
            global_summary_refresh_interval_ms: 50,
```
