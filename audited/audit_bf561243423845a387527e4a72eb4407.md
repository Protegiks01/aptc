# Audit Report

## Title
Incomplete Module Dependency Validation in State Snapshot Restoration

## Summary
The state snapshot restoration process validates individual module bytecode but fails to verify that module dependency graphs are complete and consistent. This allows snapshots containing modules with missing or incomplete dependencies to pass validation, causing execution failures when those modules are later invoked.

## Finding Description

The state snapshot restoration system in Aptos provides an optional `validate_modules` flag that performs module validation during restoration. However, this validation is incomplete. [1](#0-0) 

The `validate_modules` function only performs basic bytecode verification using `verify_module_with_config` on each module individually. It does NOT:

1. **Verify dependency existence**: Check if all dependencies referenced by a module exist in the snapshot
2. **Validate dependency graphs**: Ensure the dependency graph is complete and acyclic
3. **Perform linking checks**: Verify that dependencies are compatible and properly linked

In contrast, during normal module publishing, the system performs comprehensive dependency validation: [2](#0-1) 

The publishing flow calls `unmetered_get_existing_lazily_verified_module` for each dependency, which fails with a linker error if dependencies are missing.

**Attack Propagation:**

If blockchain state becomes inconsistent through any means (consensus bug, storage corruption, race condition during module publishing), a snapshot of that inconsistent state will:
1. Pass cryptographic verification (Merkle proofs validate data integrity, not semantic correctness)
2. Pass `validate_modules` checks (only validates individual module bytecode)
3. Restore successfully to the database
4. Cause execution failures when modules with missing dependencies are invoked [3](#0-2) 

The Move VM attempts to load all dependencies during module execution, failing with `LINKER_ERROR` if any are missing: [4](#0-3) 

## Impact Explanation

This issue qualifies as **Medium Severity** under Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Nodes that restore from snapshots with incomplete dependency graphs will have state that causes transaction execution failures, requiring manual investigation and recovery
- **Breaks deterministic execution invariant**: Different nodes may experience failures at different times depending on which transactions invoke affected modules
- **Amplifies other vulnerabilities**: If any bug allows inconsistent module state, snapshots propagate this inconsistency across the network without detection

The issue does NOT qualify as Critical because:
- It does not directly enable fund theft or consensus violations
- It requires pre-existing state inconsistency (cannot be exploited standalone)
- Cryptographic verification prevents arbitrary snapshot manipulation

## Likelihood Explanation

**Moderate likelihood** due to:

**Enabling conditions:**
- Any bug in module publishing, genesis initialization, or framework upgrades that allows incomplete dependencies
- Storage corruption or race conditions during state transitions
- Manual snapshot construction for testing/debugging purposes

**Mitigating factors:**
- Module publishing already has dependency checks that prevent most inconsistent states
- Cryptographic verification prevents arbitrary snapshot tampering
- The issue requires `validate_modules=true` flag (defaults to false in production)

**Real-world scenarios:**
- Framework upgrades that modify module dependencies
- Concurrent module publishing operations
- Backup/restore operations during system maintenance

## Recommendation

Enhance the `validate_modules` function to perform complete dependency graph validation:

```rust
fn validate_modules(blob: &[(StateKey, StateValue)]) {
    let features = Features::default();
    let config = aptos_prod_verifier_config(LATEST_GAS_FEATURE_VERSION, &features);
    
    // First pass: collect all modules
    let mut modules = BTreeMap::new();
    for (key, value) in blob {
        if let StateKeyInner::AccessPath(p) = key.inner() {
            if let Path::Code(module_id) = p.get_path() {
                if let Ok(module) = CompiledModule::deserialize(value.bytes()) {
                    if let Err(err) = verify_module_with_config(&config, &module) {
                        error!("Module {:?} failed validation: {:?}", module_id, err);
                        continue;
                    }
                    modules.insert(module_id.clone(), module);
                } else {
                    error!("Module {:?} failed to deserialize", module_id);
                }
            }
        }
    }
    
    // Second pass: verify all dependencies exist
    for (module_id, module) in &modules {
        for dep_id in module.immediate_dependencies() {
            if !modules.contains_key(&dep_id) {
                error!(
                    "Module {:?} has missing dependency {:?}", 
                    module_id, dep_id
                );
            }
        }
        
        // Verify friends exist
        for friend_id in module.immediate_friends() {
            if !modules.contains_key(&friend_id) {
                error!(
                    "Module {:?} declares non-existent friend {:?}",
                    module_id, friend_id
                );
            }
        }
    }
    
    // Third pass: detect cyclic dependencies using DependencyGraph
    // This uses the existing infrastructure from move-bytecode-utils
}
```

Additionally:
1. Make `validate_modules` default to `true` for production restores
2. Add dependency validation to the snapshot creation process as a pre-flight check
3. Document the limitation clearly if validation remains optional

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_snapshot_with_missing_dependency() {
    // Create Module M
    let module_m_code = r#"
        module 0x42::M {
            public fun foo() {}
        }
    "#;
    
    // Create Module N that depends on M
    let module_n_code = r#"
        module 0x42::N {
            use 0x42::M;
            public fun bar() { M::foo(); }
        }
    "#;
    
    let module_m = compile_module(module_m_code);
    let module_n = compile_module(module_n_code);
    
    // Create a snapshot blob containing ONLY module N (missing dependency M)
    let mut snapshot_blob = vec![];
    let module_n_key = StateKey::module(&AccountAddress::from_hex_literal("0x42").unwrap(), "N");
    let module_n_value = StateValue::new_legacy(module_n.serialize().unwrap());
    snapshot_blob.push((module_n_key, module_n_value));
    
    // Run validate_modules - this should fail but currently only validates
    // individual module bytecode, not dependencies
    StateSnapshotRestoreController::validate_modules(&snapshot_blob);
    // ^ This passes even though M is missing!
    
    // Now attempt to execute N::bar() after restore
    // This will fail with LINKER_ERROR because M doesn't exist
    let err = execute_function("0x42::N", "bar", vec![]).unwrap_err();
    assert_eq!(err.major_status(), StatusCode::LINKER_ERROR);
}
```

## Notes

This vulnerability represents a **defense-in-depth gap** rather than a directly exploitable attack vector. The primary security boundary is the module publishing validation that prevents inconsistent state from being created initially. However, snapshot validation provides a critical secondary check that could catch:

1. Bugs in module publishing logic
2. Storage layer corruption
3. Race conditions during concurrent operations
4. Issues during framework upgrades

The current incomplete validation creates a false sense of security when `validate_modules=true` is enabled, as operators may assume comprehensive validation is occurring when it is not.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L233-251)
```rust
    fn validate_modules(blob: &[(StateKey, StateValue)]) {
        // TODO: Instead of using default features, fetch them from the state.
        let features = Features::default();

        let config = aptos_prod_verifier_config(LATEST_GAS_FEATURE_VERSION, &features);
        for (key, value) in blob {
            if let StateKeyInner::AccessPath(p) = key.inner() {
                if let Path::Code(module_id) = p.get_path() {
                    if let Ok(module) = CompiledModule::deserialize(value.bytes()) {
                        if let Err(err) = verify_module_with_config(&config, &module) {
                            error!("Module {:?} failed validation: {:?}", module_id, err);
                        }
                    } else {
                        error!("Module {:?} failed to deserialize", module_id);
                    }
                }
            }
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L262-270)
```rust
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L253-262)
```rust
        let mut visited = HashSet::new();
        visited.insert(id.clone());
        Ok(Some(visit_dependencies_and_verify(
            id,
            module,
            version,
            &mut visited,
            self,
        )?))
    }
```

**File:** third_party/move/move-vm/integration-tests/src/tests/bad_storage_tests.rs (L264-324)
```rust
#[test]
fn test_missing_module_dependency() {
    // Compile two modules M, N where N depends on M.
    let code = r#"
        module {{ADDR}}::M {
            public fun foo() {}
        }

        module {{ADDR}}::N {
            use {{ADDR}}::M;

            public fun bar() { M::foo(); }
        }
    "#;
    let code = code.replace("{{ADDR}}", &format!("0x{}", TEST_ADDR.to_hex()));
    let mut units = compile_units(&code).unwrap();
    let n = as_module(units.pop().unwrap());
    let m = as_module(units.pop().unwrap());

    let mut blob_m = vec![];
    m.serialize(&mut blob_m).unwrap();
    let mut blob_n = vec![];
    n.serialize(&mut blob_n).unwrap();

    let module_id = ModuleId::new(TEST_ADDR, Identifier::new("N").unwrap());
    let fun_name = Identifier::new("bar").unwrap();

    // Publish M and N and call N::bar. Everything should work.
    {
        let mut storage = InMemoryStorage::new();

        storage.add_module_bytes(m.self_addr(), m.self_name(), blob_m.into());
        storage.add_module_bytes(n.self_addr(), n.self_name(), blob_n.clone().into());

        let result = execute_function_with_single_storage_for_test(
            &storage,
            &module_id,
            &fun_name,
            &[],
            vec![],
        );
        assert_ok!(result);
    }

    // Publish only N and try to call N::bar. The VM should fail to find M and raise
    // an invariant violation.
    {
        let mut storage = InMemoryStorage::new();
        storage.add_module_bytes(n.self_addr(), n.self_name(), blob_n.into());

        let err = execute_function_with_single_storage_for_test(
            &storage,
            &module_id,
            &fun_name,
            &[],
            vec![],
        )
        .unwrap_err();
        assert_eq!(err.major_status(), StatusCode::LINKER_ERROR);
    }
}
```
