# Audit Report

## Title
DKG Sigma Protocol Lacks Runtime RNG Validation - Deterministic RNG in Smoke-Test Mode Enables Secret Extraction

## Summary
The `prove()` method in the sigma protocol implementation accepts any RNG implementing the `CryptoRng` marker trait without runtime validation. When the `smoke-test` feature is enabled, the DKG uses a deterministic RNG seeded with the validator's address, allowing attackers to reconstruct the exact randomness used in zero-knowledge proofs and extract secret DKG shares.

## Finding Description

The sigma protocol implementation in the Aptos DKG module lacks cryptographic validation of the RNG used for proof generation. Specifically:

1. **No Runtime Validation**: The `prove()` function accepts a generic RNG parameter constrained only by the `CryptoRng` marker trait, which provides zero runtime guarantees. [1](#0-0) 

2. **Marker Trait Limitation**: `CryptoRng` is an empty marker trait with no methods - any type can trivially implement it without providing cryptographic security. [2](#0-1) 

3. **Predictable RNG in Smoke-Test Mode**: When compiled with the `smoke-test` feature, the DKG manager uses a deterministic RNG seeded solely with the validator's address: [3](#0-2) 

4. **Secret Extraction Attack**: In the sigma protocol's `prove_homomorphism` function, the compromised RNG is used to generate the critical randomness `r`: [4](#0-3) 

The proof equation `z = r + c*witness` means that if an attacker knows `r` (by reconstructing the RNG), they can extract the witness: `witness = (z - r) / c`. [5](#0-4) 

5. **DKG Secret Compromise**: The witness in the DKG context contains the actual secret shares being distributed, along with encryption randomness: [6](#0-5) 

6. **Feature Flag Exposure**: The smoke-test feature is explicitly exposed in the aptos-node configuration: [7](#0-6) 

**Attack Scenario:**
If a validator node is compiled/run with `--features smoke-test` (either accidentally in a testnet with real value, or deliberately in a misconfigured environment):
- The validator uses `StdRng::from_seed(validator_addr.into_bytes())`
- They broadcast their DKG transcript
- An attacker observing the transcript can extract the validator's address (public information)
- Attacker recreates the RNG and regenerates all random values
- Attacker extracts secret DKG shares from sigma protocol proofs
- With enough shares, attacker reconstructs the shared secret and compromises validator keys

## Impact Explanation

**Critical Severity** - This vulnerability enables direct extraction of cryptographic secrets from DKG transcripts, leading to:

1. **Loss of Funds**: Compromised validator private keys allow theft of staked assets
2. **Consensus Safety Violation**: Attacker can sign malicious blocks with stolen validator keys, potentially causing chain splits or double-spending
3. **Cryptographic Correctness Invariant Broken**: The DKG protocol's zero-knowledge property is completely bypassed

This meets the Critical severity criteria per Aptos bug bounty: "Loss of Funds (theft or minting)" and "Consensus/Safety violations."

## Likelihood Explanation

**Low to Medium Likelihood**:

**Factors Reducing Likelihood:**
- Smoke-test feature is clearly marked for testing purposes only
- Production deployments should use the default secure RNG path
- Requires misconfiguration or deliberate feature enablement

**Factors Increasing Likelihood:**
- Feature flag is trivially enabled (`--features smoke-test`)
- No runtime safeguards or warnings when smoke-test mode is active
- Testnets or development environments may use this mode with real value
- Human error in deployment scripts could enable this feature
- The design flaw (no runtime validation) creates risk for future code changes

The lack of defense-in-depth is concerning - a single configuration error leads to complete cryptographic compromise with no warning or detection.

## Recommendation

Implement multiple layers of defense:

**1. Runtime RNG Validation:**
```rust
fn prove<Ct: Serialize, R: RngCore + CryptoRng>(
    &self,
    witness: &Self::Domain,
    statement: &Self::Codomain,
    cntxt: &Ct,
    rng: &mut R,
) -> Proof<<Self as fixed_base_msms::Trait>::Scalar, Self> {
    // Add runtime check to ensure we're not using a weak RNG
    #[cfg(feature = "smoke-test")]
    {
        panic!("SECURITY: smoke-test feature should never be enabled in production!");
    }
    
    prove_homomorphism(self, witness, statement, cntxt, true, rng, &self.dst())
}
```

**2. Remove Deterministic RNG in Smoke-Test:**
Replace the deterministic seeding with a properly seeded RNG even in smoke-test mode, or use mocked transcripts instead:

```rust
let mut rng = StdRng::from_rng(thread_rng()).unwrap();
// For smoke tests, use deterministic transcript generation, not deterministic RNG
```

**3. Add Compile-Time Warning:**
```rust
#[cfg(feature = "smoke-test")]
compile_error!("WARNING: smoke-test feature should only be used in isolated test environments!");
```

## Proof of Concept

```rust
// PoC demonstrating secret extraction when smoke-test mode is enabled

use aptos_types::account_address::AccountAddress;
use rand::SeedableRng;
use rand_chacha::ChaChaRng as StdRng;
use ark_ff::PrimeField;

fn extract_secret_from_transcript(
    validator_addr: AccountAddress,
    proof_z: FieldElement,  // From observed transcript
    proof_c: FieldElement,  // Fiat-Shamir challenge (reconstructible)
) -> FieldElement {
    // Step 1: Recreate the validator's RNG
    let mut rng = StdRng::from_seed(validator_addr.into_bytes());
    
    // Step 2: Regenerate the exact randomness used in the proof
    // This follows the same code path as the victim validator
    let r = sample_field_element(&mut rng);
    
    // Step 3: Extract the secret witness using the sigma protocol equation
    // z = r + c*witness  =>  witness = (z - r) / c
    let witness = (proof_z - r) * proof_c.inverse().unwrap();
    
    // witness now contains the victim's DKG secret share!
    witness
}

// To test:
// 1. Compile aptos-node with --features smoke-test
// 2. Run DKG and capture a transcript
// 3. Run this PoC with the validator's address and proof values
// 4. Verify extracted witness matches the original secret
```

**Notes:**
- This vulnerability violates the "Cryptographic Correctness" invariant (#10) which requires secure cryptographic operations
- The smoke-test feature creates a deterministic RNG that makes all "random" values predictable
- Even without smoke-test, the lack of runtime validation is a systemic design flaw that could be exploited through future code changes or dependency compromises
- The `CryptoRng` trait is defined in `rand_core` and is explicitly documented as a marker with no security guarantees on its own

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L23-23)
```rust
use rand_core::{CryptoRng, RngCore};
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L41-49)
```rust
    fn prove<Ct: Serialize, R: RngCore + CryptoRng>(
        &self,
        witness: &Self::Domain,
        statement: &Self::Codomain,
        cntxt: &Ct, // for SoK purposes
        rng: &mut R,
    ) -> Proof<<Self as fixed_base_msms::Trait>::Scalar, Self> { // or C::ScalarField
        prove_homomorphism(self, witness, statement, cntxt, true, rng, &self.dst())
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L482-482)
```rust
    let r = witness.rand(rng);
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L497-497)
```rust
    let z = r.scaled_add(&witness, c);
```

**File:** dkg/src/dkg_manager/mod.rs (L325-329)
```rust
        let mut rng = if cfg!(feature = "smoke-test") {
            StdRng::from_seed(self.my_addr.into_bytes())
        } else {
            StdRng::from_rng(thread_rng()).unwrap()
        };
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L688-692)
```rust
        let witness = HkzgWeightedElgamalWitness {
            hkzg_randomness,
            chunked_plaintexts: Scalar::vecvecvec_from_inner(f_evals_weighted),
            elgamal_randomness,
        };
```

**File:** aptos-node/Cargo.toml (L98-98)
```text
smoke-test = ["aptos-jwk-consensus/smoke-test", "aptos-dkg-runtime/smoke-test"]
```
