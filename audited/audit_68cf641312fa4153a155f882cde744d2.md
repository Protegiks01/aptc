# Audit Report

## Title
Integer Overflow in Round Number Metrics Causes Silent Monitoring Failure at High Round Values

## Summary
The consensus monitoring infrastructure casts u64 round numbers to i64 when exporting Prometheus metrics, causing integer wraparound when rounds exceed `i64::MAX` (9,223,372,036,854,775,807). This results in negative metric values that break monitoring dashboards, automated health checkers, and security alerting systems, effectively blinding operators to consensus attacks occurring near high round numbers.

## Finding Description

Round numbers in Aptos consensus are defined as `u64` values [1](#0-0) , supporting values from 0 to 18,446,744,073,709,551,615. However, multiple locations in the codebase cast these u64 rounds to i64 when setting Prometheus IntGauge metrics:

**Primary vulnerable locations:**

1. **Committed round tracking**: When blocks are committed, the round is cast to i64 [2](#0-1) 

2. **Ordered block round tracking**: Optional block rounds are also cast to i64 [3](#0-2) 

3. **Block store initialization**: Round values at startup are cast [4](#0-3) 

4. **Pending votes tracking**: Current round from vote data is cast [5](#0-4) 

5. **Safety data persistence**: All safety-critical round fields are cast when persisted [6](#0-5) 

**The vulnerability mechanism:**

When a round number exceeds `i64::MAX` (2^63 - 1), the unchecked `as i64` cast causes wraparound:
- Round 9,223,372,036,854,775,808 becomes -9,223,372,036,854,775,808
- Round 18,446,744,073,709,551,615 becomes -1

**Impact on monitoring systems:**

1. **ConsensusRoundChecker failure**: The automated health checker compares round values to detect if rounds are progressing [7](#0-6) . When metrics wrap to negative values, the checker incorrectly reports "Consensus round went backwards!" even though consensus is functioning normally.

2. **Dashboard corruption**: Grafana dashboards and other monitoring tools displaying these metrics will show nonsensical negative values or extreme jumps, making it impossible to diagnose actual consensus issues.

3. **Alerting system blindness**: Automated alerting based on round progression metrics will fail or trigger false positives, masking real attacks occurring at high round numbers.

While the `next_round()` function includes overflow protection using `checked_add` [8](#0-7) , this only prevents rounds from incrementing past `u64::MAX` through normal operation. It does not protect the metrics export layer from misrepresenting high round values.

## Impact Explanation

**Severity: Medium** (per Aptos bug bounty criteria)

This vulnerability falls under "State inconsistencies requiring intervention" because:

1. **Monitoring Infrastructure Failure**: The primary security impact is the complete breakdown of consensus monitoring and alerting when round numbers are high. Operators lose visibility into the actual state of consensus.

2. **Attack Detection Blindness**: An attacker exploiting a consensus vulnerability at high round numbers would go undetected because:
   - Monitoring dashboards show incorrect/negative values
   - Automated checkers report false positives
   - Security alerting systems fail to trigger correctly

3. **Operational Risk**: During a real incident involving high round numbers, operators would be unable to distinguish between monitoring system failure and actual consensus failure, delaying incident response.

4. **Does not directly break consensus**: The consensus protocol itself continues to function correctly. The vulnerability is in the observability layer, not the consensus logic.

This does not qualify as Critical or High severity because it does not directly cause loss of funds, break consensus safety, or enable direct attacks. However, it significantly degrades the security posture by breaking monitoring infrastructure.

## Likelihood Explanation

**Likelihood: Low-to-Medium**

- **Under normal operation**: Reaching `i64::MAX` rounds (9.2 quintillion) through sequential consensus is practically impossible, even over decades of operation.

- **However**: The vulnerability becomes relevant in several scenarios:
  1. **Fast-forward sync bugs**: If state synchronization or epoch transitions incorrectly set high round numbers
  2. **Genesis/recovery scenarios**: Network recovery from state snapshots might use high round numbers
  3. **Any bug causing round jumps**: A separate vulnerability causing unexpected round increases would trigger this monitoring failure
  4. **Testing/staging environments**: Networks that artificially advance rounds for testing purposes

The likelihood increases if round manipulation vulnerabilities exist elsewhere in the codebase (not investigated in this audit).

## Recommendation

Replace all unchecked `as i64` casts with safe conversions that either:

**Option 1 - Saturating cast** (recommended):
```rust
// In consensus/src/counters.rs:1328
LAST_COMMITTED_ROUND.set(block.round().min(i64::MAX as u64) as i64);

// In consensus/src/counters.rs:1332  
LAST_COMMITTED_OPT_BLOCK_ROUND.set(block.round().min(i64::MAX as u64) as i64);
```

**Option 2 - Use Gauge instead of IntGauge**:
Convert metrics to use `Gauge` (f64) instead of `IntGauge` (i64), which can represent the full u64 range without loss:
```rust
pub static LAST_COMMITTED_ROUND: Lazy<Gauge> = Lazy::new(|| {
    register_gauge!(
        "aptos_consensus_last_committed_round",
        "This counter is set to the round of the highest committed block."
    )
    .unwrap()
});

// Then use:
LAST_COMMITTED_ROUND.set(block.round() as f64);
```

**Option 3 - Add explicit validation**:
```rust
fn set_round_metric(gauge: &IntGauge, round: u64) {
    if round > i64::MAX as u64 {
        warn!("Round {} exceeds i64::MAX, clamping metric", round);
        gauge.set(i64::MAX);
    } else {
        gauge.set(round as i64);
    }
}
```

Apply the chosen fix to all identified locations in the codebase. Option 2 (using Gauge/f64) is most robust as it eliminates the fundamental type mismatch between u64 rounds and i64 metrics.

## Proof of Concept

```rust
#[test]
fn test_round_metric_overflow() {
    use aptos_metrics_core::{register_int_gauge, IntGauge};
    use once_cell::sync::Lazy;
    
    static TEST_GAUGE: Lazy<IntGauge> = Lazy::new(|| {
        register_int_gauge!(
            "test_round_metric",
            "Test gauge for round overflow"
        ).unwrap()
    });
    
    // Round just below i64::MAX - works correctly
    let safe_round: u64 = 9_223_372_036_854_775_807; // i64::MAX
    TEST_GAUGE.set(safe_round as i64);
    assert_eq!(TEST_GAUGE.get(), 9_223_372_036_854_775_807);
    
    // Round at i64::MAX + 1 - wraps to negative!
    let overflow_round: u64 = 9_223_372_036_854_775_808;
    TEST_GAUGE.set(overflow_round as i64);
    assert_eq!(TEST_GAUGE.get(), -9_223_372_036_854_775_808); // NEGATIVE!
    
    // This simulates what ConsensusRoundChecker sees:
    let previous_round = 9_223_372_036_854_775_807_i64; // Just before overflow
    let latest_round = -9_223_372_036_854_775_808_i64;   // After overflow
    
    // The checker thinks rounds went backwards!
    assert!(latest_round < previous_round);
    
    println!("Vulnerability confirmed: Round {} cast to i64 becomes {}",
             overflow_round, overflow_round as i64);
}
```

**Test demonstrating monitoring failure:**
```rust
#[test]
fn test_consensus_round_checker_false_positive() {
    // Simulates ConsensusRoundChecker logic from 
    // ecosystem/node-checker/src/checker/consensus_round.rs:54
    
    let round_before_overflow = i64::MAX;
    let round_after_overflow = (i64::MAX as u64 + 1) as i64; // Wraps to i64::MIN
    
    // This is the actual check from ConsensusRoundChecker
    if round_after_overflow < round_before_overflow {
        println!("FALSE POSITIVE: Checker reports 'Consensus round went backwards!'");
        println!("Previous: {}, Latest: {}", round_before_overflow, round_after_overflow);
        assert!(true); // This false positive WILL trigger
    } else {
        assert!(false, "Expected false positive did not occur");
    }
}
```

## Notes

This vulnerability directly answers the security question: "Can logging of maximum u64 values for rounds (approaching overflow) cause issues in log analysis tools that assume smaller numbers, leading to missed detection of consensus attacks near round number wraparound?"

**Answer: Yes.** The codebase exports round numbers as i64 metrics, causing wraparound when rounds exceed `i64::MAX`. This breaks monitoring infrastructure and could mask security issues at high round numbers.

### Citations

**File:** consensus/consensus-types/src/common.rs (L33-33)
```rust
pub type Round = u64;
```

**File:** consensus/src/counters.rs (L1328-1328)
```rust
    LAST_COMMITTED_ROUND.set(block.round() as i64);
```

**File:** consensus/src/counters.rs (L1332-1332)
```rust
        LAST_COMMITTED_OPT_BLOCK_ROUND.set(block.round() as i64);
```

**File:** consensus/src/block_storage/block_store.rs (L307-307)
```rust
        counters::LAST_COMMITTED_ROUND.set(block_store.ordered_root().round() as i64);
```

**File:** consensus/src/pending_votes.rs (L343-343)
```rust
        let cur_round = vote.vote_data().proposed().round() as i64;
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L152-158)
```rust
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);
```

**File:** ecosystem/node-checker/src/checker/consensus_round.rs (L54-59)
```rust
        if latest_round < previous_round {
            Self::build_result(
                "Consensus round went backwards!".to_string(),
                0,
                format!("Successfully pulled metrics from target node twice, but the second time the consensus round went backwards (from {} to {}", previous_round, latest_round),
            )
```

**File:** consensus/safety-rules/src/safety_rules.rs (L36-38)
```rust
pub(crate) fn next_round(round: Round) -> Result<Round, Error> {
    u64::checked_add(round, 1).ok_or(Error::IncorrectRound(round))
}
```
