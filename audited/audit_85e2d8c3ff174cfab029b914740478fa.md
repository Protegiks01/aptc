# Audit Report

## Title
FxHasher Hash Collision Attack Enables StateKey Registry Shard DoS via Controlled Address and Name Inputs

## Summary
The `StateKeyRegistry` uses FxHasher (a non-cryptographic hash function) to determine sharding for StateKey storage, hashing only 3 bytes of input (address last byte, name first/last bytes). Attackers can craft resource accounts and Move modules with colliding hash values, forcing all StateKeys to map to a single registry shard and causing RwLock contention that degrades validator node performance.

## Finding Description

The `StateKeyRegistry` implements sharded storage for StateKey objects using `hash_address_and_name` to determine which shard (out of 8 for resources/modules, 4 for raw) should store each StateKey. [1](#0-0) 

This function uses FxHasher and only hashes 3 bytes of input. The codebase explicitly acknowledges FxHasher's vulnerability: [2](#0-1) 

**Attacker Control Vectors:**

1. **Addresses:** When creating resource accounts using `create_resource_address`, attackers control the seed parameter: [3](#0-2) 

By grinding ~256 different seeds, attackers can find addresses with any desired last byte.

2. **Struct/Module Names:** When publishing Move modules, developers fully control struct and module names: [4](#0-3) 

**Attack Execution:**

1. Attacker creates 1000 resource accounts by grinding seeds to produce addresses all ending in `0x00`
2. Attacker publishes Move modules with struct names like `"a"`, `"aa"`, `"aaa"` (all starting and ending with `'a'`)
3. All StateKeys for these resources hash to similar values: `hash(0x00, 'a', 'a') % 8 = constant_shard`
4. All 1000 StateKeys map to the same registry shard (e.g., shard 0)

**Contention Points:**

Each shard uses a TwoKeyRegistry with a single RwLock: [5](#0-4) 

During StateKey creation, write locks are acquired: [6](#0-5) 

During StateKey destruction, write locks are also acquired for cleanup: [7](#0-6) 

All operations on the 1000 colliding StateKeys contend on the same RwLock while the other 7 shards remain idle.

## Impact Explanation

This vulnerability enables **validator node slowdowns**, qualifying as **High Severity** per the Aptos bug bounty program (up to $50,000).

**Performance Degradation Mechanism:**
- Single shard becomes a bottleneck with 1000+ entries
- All concurrent StateKey creation/removal operations serialize on one RwLock
- Other 7 shards remain underutilized (12.5% efficiency vs. 100% ideal)
- During block execution with high transaction throughput, this creates sustained contention

**Affected Operations:**
- Transaction execution accessing resources/modules (StateKey creation)
- StateKey object garbage collection (StateKey removal via Drop)
- Any operation requiring StateKey lookups on the congested shard

The attack does NOT cause consensus violations or fund loss, but can significantly degrade validator performance during periods of high load.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attack Feasibility:**
- **Address Grinding:** Computationally trivial (~256 hash attempts per desired last byte)
- **Name Control:** Fully controlled via Move module publishing
- **Cost:** Gas fees for creating 1000 resource accounts + publishing modules (moderate but feasible for motivated attacker)
- **Detection:** Difficult to distinguish from legitimate heavy usage

**Triggering Conditions:**
- Requires sustained transaction load accessing the malicious StateKeys
- Most impactful during peak network activity
- Effect compounds with number of colliding StateKeys created

The attack is practical because:
1. FxHasher has known, exploitable collision properties
2. Input space is only 2^24 combinations (3 bytes)
3. Attacker controls both input parameters
4. No defense mechanisms prevent deliberately colliding inputs

## Recommendation

**Replace FxHasher with a collision-resistant hash function for sharding decisions.**

Use `ahash::AHasher` (already available in the codebase, shown in benchmarks) or SipHash for the sharding hash:

```rust
pub fn hash_address_and_name(address: &AccountAddress, name: &[u8]) -> usize {
    use std::hash::{Hash, Hasher};
    let mut hasher = ahash::AHasher::default();
    hasher.write(address.as_ref());
    hasher.write(name);
    hasher.finish() as usize
}
```

**Key improvements:**
1. Hash **all** address bytes, not just the last one
2. Hash **all** name bytes, not just first/last
3. Use AHasher which provides DoS resistance against hash flooding attacks
4. Maintains performance (AHasher is designed for speed while being collision-resistant)

The benchmarks already compare these hashers: [8](#0-7) 

## Proof of Concept

```rust
#[test]
fn test_hash_collision_attack() {
    use aptos_types::state_store::state_key::{registry::StateKeyRegistry, StateKey};
    use move_core_types::{account_address::AccountAddress, identifier::Identifier, language_storage::StructTag};
    
    // Attacker creates addresses with same last byte
    let addresses: Vec<AccountAddress> = (0..100)
        .map(|i| {
            // Simulate grinding: create addresses ending in 0x00
            let mut bytes = [0u8; 32];
            bytes[0..4].copy_from_slice(&i.to_le_bytes());
            bytes[31] = 0x00; // Force last byte to 0x00
            AccountAddress::new(bytes)
        })
        .collect();
    
    // Attacker creates struct names with same first/last byte
    let struct_tag = StructTag {
        address: AccountAddress::ONE,
        module: Identifier::new("test").unwrap(),
        name: Identifier::new("a").unwrap(), // First = 'a', Last = 'a'
        type_args: vec![],
    };
    
    // Verify all hash to same shard
    let mut shard_distribution = [0; 8];
    for addr in &addresses {
        let shard = StateKeyRegistry::hash_address_and_name(addr, struct_tag.name.as_bytes()) % 8;
        shard_distribution[shard] += 1;
    }
    
    // All 100 StateKeys should map to same shard
    let max_shard_count = *shard_distribution.iter().max().unwrap();
    assert!(max_shard_count >= 90, "Hash collision: {} keys in one shard", max_shard_count);
    
    // Demonstrate the imbalance
    println!("Shard distribution: {:?}", shard_distribution);
    // Expected: [100, 0, 0, 0, 0, 0, 0, 0] or similar extreme imbalance
}
```

**Note:** This PoC demonstrates the hash collision attack vector. In production, an attacker would need to pay gas fees to create these accounts and publish modules, but the vulnerability is exploitable given sufficient resources.

### Citations

**File:** types/src/state_store/state_key/registry.rs (L45-69)
```rust
impl Drop for Entry {
    fn drop(&mut self) {
        match &self.deserialized {
            StateKeyInner::AccessPath(AccessPath { address, path }) => {
                use crate::access_path::Path;

                match &bcs::from_bytes::<Path>(path).expect("Failed to deserialize Path.") {
                    Path::Code(module_id) => REGISTRY
                        .module(address, &module_id.name)
                        .maybe_remove(&module_id.address, &module_id.name),
                    Path::Resource(struct_tag) => REGISTRY
                        .resource(struct_tag, address)
                        .maybe_remove(struct_tag, address),
                    Path::ResourceGroup(struct_tag) => REGISTRY
                        .resource_group(struct_tag, address)
                        .maybe_remove(struct_tag, address),
                }
            },
            StateKeyInner::TableItem { handle, key } => {
                REGISTRY.table_item(handle, key).maybe_remove(handle, key)
            },
            StateKeyInner::Raw(bytes) => REGISTRY.raw(bytes).maybe_remove(bytes, &()),
        }
    }
}
```

**File:** types/src/state_store/state_key/registry.rs (L71-73)
```rust
pub(crate) struct TwoKeyRegistry<Key1, Key2> {
    inner: RwLock<HashMap<Key1, HashMap<Key2, Weak<Entry>>>>,
}
```

**File:** types/src/state_store/state_key/registry.rs (L123-149)
```rust
        let mut locked = self.inner.write();

        Ok(match locked.get_mut(key1) {
            None => {
                let mut map2 = locked.entry(key1.to_owned()).insert(HashMap::new());
                let entry = Entry::new(deserialized, encoded, hash_value);
                Self::insert_key2(map2.get_mut(), key2.to_owned(), entry)
            },
            Some(map2) => match map2.get(key2) {
                None => {
                    let entry = Entry::new(deserialized, encoded, hash_value);
                    Self::insert_key2(map2, key2.to_owned(), entry)
                },
                Some(weak) => match weak.upgrade() {
                    Some(entry) => {
                        // some other thread has added it
                        entry
                    },
                    None => {
                        // previous version of this key is being dropped.
                        let entry = Entry::new(deserialized, encoded, hash_value);
                        Self::insert_key2(map2, key2.to_owned(), entry)
                    },
                },
            },
        })
    }
```

**File:** types/src/state_store/state_key/registry.rs (L212-220)
```rust
    pub fn hash_address_and_name(address: &AccountAddress, name: &[u8]) -> usize {
        let mut hasher = fxhash::FxHasher::default();
        hasher.write_u8(address.as_ref()[AccountAddress::LENGTH - 1]);
        if !name.is_empty() {
            hasher.write_u8(name[0]);
            hasher.write_u8(name[name.len() - 1]);
        }
        hasher.finish() as usize
    }
```

**File:** third_party/move/move-vm/runtime/src/runtime_ref_checks.rs (L105-108)
```rust
/// A deterministic hash map (used in the Rust compiler), expected to perform well.
/// Not resistant to hash collision attacks, nor is it cryptographically secure.
/// Should not be used for iterating over keys without sorting first.
type UnorderedMap<K, V> = HashMap<K, V, FxBuildHasher>;
```

**File:** types/src/account_address.rs (L230-236)
```rust
pub fn create_resource_address(address: AccountAddress, seed: &[u8]) -> AccountAddress {
    let mut input = bcs::to_bytes(&address).unwrap();
    input.extend(seed);
    input.push(Scheme::DeriveResourceAccountAddress as u8);
    let hash = HashValue::sha3_256_of(&input);
    AccountAddress::from_bytes(hash.as_ref()).unwrap()
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L108-108)
```rust
            let state_key = StateKey::module_id(&module_id);
```

**File:** types/benches/state_key.rs (L56-70)
```rust
    group.bench_function("fxhasher_struct_tag", |b| {
        b.iter(|| {
            let mut hasher = FxHasher::default();
            Hash::hash(&struct_tag, &mut hasher);
            hasher.finish()
        })
    });

    group.bench_function("ahasher_struct_tag", |b| {
        b.iter(|| {
            let mut hasher = ahash::AHasher::default();
            Hash::hash(&struct_tag, &mut hasher);
            hasher.finish()
        })
    });
```
