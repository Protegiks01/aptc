# Audit Report

## Title
Unauthenticated Remote Executor Network Communication Allows Message Injection and Consensus Disruption

## Summary
The remote executor service uses an unauthenticated and unencrypted network communication protocol (plain TCP/HTTP gRPC) that allows attackers to inject crafted error messages, causing the coordinator to skip block execution and break consensus determinism.

## Finding Description

The executor service implements a distributed sharded execution architecture where a coordinator delegates transaction execution to remote executor shards via `NetworkController`. This communication has **no authentication or encryption**. [1](#0-0) [2](#0-1) 

The network uses plain HTTP (not HTTPS) and raw TCP connections with no cryptographic protection. When the coordinator receives execution results from shards: [3](#0-2) 

An attacker performing a man-in-the-middle attack can intercept legitimate execution results and inject a crafted `RemoteExecutionResult` containing a fake `VMStatus` error. The BCS deserialization at line 168 will accept any properly formatted message, regardless of source authenticity.

When this error propagates to consensus: [4](#0-3) 

The coordinator logs the error and **returns early without executing the block** (line 625), while other nodes in the network that weren't attacked will execute the block normally, creating a **ledger fork** and violating the **Deterministic Execution** invariant.

## Impact Explanation

**Critical Severity** - This breaks **Invariant #1: Deterministic Execution** and **Invariant #2: Consensus Safety**:

- Attacked nodes skip block execution, creating different state roots
- Non-attacked nodes execute blocks normally  
- Network partitions into inconsistent ledger states
- Requires hardfork to recover (non-recoverable network partition)

This qualifies as **Critical Severity** ($1M category) per the bug bounty program: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

**However, critical limitation**: This vulnerability only affects deployments that explicitly enable the remote executor feature via command-line flags. Investigation shows this feature is **currently only used in `executor-benchmark`**, not in production `aptos-node` validators: [5](#0-4) 

## Likelihood Explanation

**Current Production**: **Zero likelihood** - The remote executor feature is not enabled in production validator deployments. Only the benchmark binary uses it.

**If Feature Enabled**: **High likelihood** - Attack requires:
- MITM position on network between coordinator and shards (achievable via compromised network infrastructure, BGP hijacking, or malicious cloud provider)
- BCS serialization knowledge (public specification)
- Ability to craft valid `RemoteExecutionResult` with error `VMStatus`

The lack of any authentication makes exploitation trivial once MITM position is achieved.

## Recommendation

**Immediate**: Document that remote executor feature is **experimental/benchmark-only** and must not be used in production without security hardening.

**Long-term**: Implement mutual TLS authentication and encryption:

```rust
// In NetworkController::new()
pub fn new(service: String, listen_addr: SocketAddr, timeout_ms: u64, 
           tls_config: Option<TlsConfig>) -> Self {
    // Add TLS configuration for GRPC channels
    // Verify peer certificates against allowlist
    // Encrypt all messages in transit
}
```

Add message authentication codes (HMACs) or digital signatures:
```rust
struct AuthenticatedMessage {
    message: RemoteExecutionResult,
    signature: Signature,  // Sign with shard's private key
    shard_id: ShardId,
}
```

Validate sender identity before deserializing execution results.

## Proof of Concept

Since this feature requires specific deployment configuration (remote executor addresses), a full PoC requires:

1. **Setup**: Start coordinator and shards with remote addresses configured
2. **MITM**: Intercept network traffic between coordinator and shard
3. **Inject**: Send crafted `RemoteExecutionResult`:

```rust
use aptos_executor_service::RemoteExecutionResult;
use move_core_types::vm_status::{VMStatus, StatusCode};

// Craft fake error result
let fake_error = RemoteExecutionResult::new(
    Err(VMStatus::Error {
        status_code: StatusCode::OUT_OF_GAS,
        sub_status: None,
        message: Some("Injected error".to_string()),
    })
);

// Serialize and send to coordinator
let malicious_bytes = bcs::to_bytes(&fake_error).unwrap();
// Send via hijacked network connection
```

The coordinator will skip execution upon receiving this message.

## Notes

**Critical Caveat**: This vulnerability is **NOT exploitable on current production Aptos mainnet or testnet** because the remote executor feature is only used in benchmark tools, not in production `aptos-node` validators. The code exists in the production repository but is not active in deployed validators.

This represents a **defense-in-depth issue** and **code quality concern** that should be addressed before any future production use of the remote executor feature, but does not constitute an immediate threat to the current Aptos network.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L132-138)
```rust
    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** secure/net/src/lib.rs (L149-269)
```rust
pub struct NetworkClient {
    service: String,
    server: SocketAddr,
    stream: Option<NetworkStream>,
    /// Read, Write, Connect timeout in milliseconds.
    timeout_ms: u64,
}

impl NetworkClient {
    pub fn new(service: String, server: SocketAddr, timeout_ms: u64) -> Self {
        Self {
            service,
            server,
            stream: None,
            timeout_ms,
        }
    }

    fn increment_counter(&self, method: Method, result: MethodResult) {
        increment_counter(&self.service, NetworkMode::Client, method, result)
    }

    /// Blocking read until able to successfully read an entire message
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);
        let stream = self.server()?;
        let result = stream.read();
        if let Err(err) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(&self.server));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }
        result
    }

    /// Shutdown the internal network stream
    pub fn shutdown(&mut self) -> Result<(), Error> {
        info!(SecureNetLogSchema::new(
            &self.service,
            NetworkMode::Client,
            LogEvent::Shutdown,
        ));

        let stream = self.stream.take().ok_or(Error::NoActiveStream)?;
        stream.shutdown()?;
        Ok(())
    }

    /// Blocking write until able to successfully send an entire message
    pub fn write(&mut self, data: &[u8]) -> Result<(), Error> {
        self.increment_counter(Method::Write, MethodResult::Query);
        let stream = self.server()?;
        let result = stream.write(data);
        if let Err(err) = &result {
            self.increment_counter(Method::Write, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::DisconnectedPeerOnWrite,
            )
            .error(err)
            .remote_peer(&self.server));

            self.stream = None;
        } else {
            self.increment_counter(Method::Write, MethodResult::Success);
        }
        result
    }

    fn server(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionAttempt,
            )
            .remote_peer(&self.server));

            let timeout = std::time::Duration::from_millis(self.timeout_ms);
            let mut stream = TcpStream::connect_timeout(&self.server, timeout);

            let sleeptime = time::Duration::from_millis(100);
            while let Err(err) = stream {
                self.increment_counter(Method::Connect, MethodResult::Failure);
                warn!(SecureNetLogSchema::new(
                    &self.service,
                    NetworkMode::Client,
                    LogEvent::ConnectionFailed,
                )
                .error(&err.into())
                .remote_peer(&self.server));

                thread::sleep(sleeptime);
                stream = TcpStream::connect_timeout(&self.server, timeout);
            }

            let stream = stream?;
            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, self.server, self.timeout_ms));
            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&self.server));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L617-626)
```rust
        let executed_blocks = match inner {
            Ok(result) => result,
            Err(e) => {
                log_executor_error_occurred(
                    e,
                    &counters::BUFFER_MANAGER_RECEIVED_EXECUTOR_ERROR_COUNT,
                    block_id,
                );
                return;
            },
```

**File:** execution/executor-benchmark/src/main.rs (L632-648)
```rust
        remote_executor_client::set_remote_addresses(
            opt.pipeline_opt
                .sharding_opt
                .remote_executor_addresses
                .clone()
                .unwrap(),
        );
        assert_eq!(
            execution_shards,
            remote_executor_client::get_remote_addresses().len(),
            "Number of execution shards ({}) must be equal to the number of remote addresses ({}).",
            execution_shards,
            remote_executor_client::get_remote_addresses().len()
        );
        remote_executor_client::set_coordinator_address(
            opt.pipeline_opt.sharding_opt.coordinator_address.unwrap(),
        );
```
