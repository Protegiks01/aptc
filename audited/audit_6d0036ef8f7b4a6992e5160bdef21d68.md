# Audit Report

## Title
Missing Upper Bound Validation in Gas Estimation Configuration Enables Resource Exhaustion

## Summary
The `sanitize()` function in `gas_estimation_config.rs` does not enforce maximum values for `block_history` fields (`low_block_history`, `market_block_history`, `aggressive_block_history`), allowing arbitrarily large values that cause memory exhaustion, database I/O saturation, and API denial of service when the `/estimate_gas_price` endpoint is invoked.

## Finding Description

The `sanitize()` function validates that block history values are greater than zero and that `aggressive_block_history` exceeds both `low_block_history` and `market_block_history`, but critically fails to enforce any upper bounds. [1](#0-0) 

When the `/estimate_gas_price` API endpoint is called, the gas estimation logic uses `aggressive_block_history` as the loop limit to iterate through historical blocks. [2](#0-1) 

The endpoint is publicly accessible and invoked during transaction submission for gas price estimation. [3](#0-2) 

**Attack Scenario:**

1. An operator configures `aggressive_block_history: 10000000` (10 million blocks) in the node config
2. The sanitize function accepts this value since it only validates `> 0` and relative ordering
3. When `/estimate_gas_price` is called:
   - The loop iterates up to 10 million times calling `db.get_block_info_by_version()` for each iteration
   - Multiple vectors are allocated proportional to the configured history size
   - The cache grows unbounded up to `max_block_history` entries [4](#0-3) 
   - Each block requires database reads and memory for storing block metadata [5](#0-4) 
   - Vector sorting operations on potentially hundreds of thousands of elements [6](#0-5) 

4. Multiple concurrent API requests compound the resource exhaustion
5. This affects validator nodes serving the API, degrading consensus participation and block production

**Broken Invariants:**
- **Resource Limits**: "All operations must respect gas, storage, and computational limits" - The unbounded configuration allows operations that exceed reasonable resource limits
- **API Availability**: The node's API becomes unresponsive or crashes under the resource load

The cache structure stores potentially millions of entries as a `BTreeMap<(u64, u64), u64>`. [7](#0-6)  With 10 million entries at ~24 bytes per entry plus tree overhead, this consumes hundreds of megabytes of memory persistently.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

1. **Validator Node Slowdowns**: If deployed on validator nodes (which often expose APIs), the resource exhaustion directly impacts validator performance, delaying block production and consensus participation

2. **API Crashes**: The unbounded resource consumption causes API timeouts, out-of-memory conditions, or complete service unavailability

3. **Cascading Failures**: Transaction submission tools and wallets that call `/estimate_gas_price` before submitting transactions will fail or timeout, disrupting network usability

4. **Persistent Impact**: The configuration persists across restarts, causing continuous degradation until manually corrected

The default values are reasonable (10, 30, 120 blocks), but nothing prevents setting values 1000x larger. [8](#0-7) 

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can manifest through:

1. **Accidental Misconfiguration**: Operators unfamiliar with implications may set large values thinking "more history = better accuracy"

2. **Config File Compromise**: If an attacker gains access to modify configuration files (through system compromise, supply chain attack on config templates, or social engineering), they can set malicious values

3. **Untrusted Config Sources**: Operators copying configuration from untrusted or malicious sources

4. **Operational Errors**: Misplaced decimal points or copy-paste errors (e.g., typing 10000000 instead of 1000)

The configuration is loaded at node startup and persists, requiring manual intervention to correct. [9](#0-8) 

While requiring configuration file access, the sanitize function exists specifically to catch such errors before they cause operational issues. The presence of lower bound validation but absence of upper bound validation represents an incomplete security control.

## Recommendation

Add maximum value validation to the `sanitize()` function:

```rust
fn sanitize(
    node_config: &NodeConfig,
    _node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = Self::get_sanitizer_name();
    let gas_estimation_config = &node_config.api.gas_estimation;

    // Define reasonable maximum values
    const MAX_LOW_BLOCK_HISTORY: usize = 100;
    const MAX_MARKET_BLOCK_HISTORY: usize = 500;
    const MAX_AGGRESSIVE_BLOCK_HISTORY: usize = 10_000;

    // Validate upper bounds
    if gas_estimation_config.low_block_history > MAX_LOW_BLOCK_HISTORY {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!(
                "low_block_history {} exceeds maximum {}",
                gas_estimation_config.low_block_history,
                MAX_LOW_BLOCK_HISTORY
            ),
        ));
    }

    if gas_estimation_config.market_block_history > MAX_MARKET_BLOCK_HISTORY {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!(
                "market_block_history {} exceeds maximum {}",
                gas_estimation_config.market_block_history,
                MAX_MARKET_BLOCK_HISTORY
            ),
        ));
    }

    if gas_estimation_config.aggressive_block_history > MAX_AGGRESSIVE_BLOCK_HISTORY {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!(
                "aggressive_block_history {} exceeds maximum {}",
                gas_estimation_config.aggressive_block_history,
                MAX_AGGRESSIVE_BLOCK_HISTORY
            ),
        ));
    }

    // Existing validations...
    if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
        || gas_estimation_config.market_block_history
            > gas_estimation_config.aggressive_block_history
    {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!(
                "aggressive block history {} must be > low {}, market {}",
                gas_estimation_config.aggressive_block_history,
                gas_estimation_config.low_block_history,
                gas_estimation_config.market_block_history
            ),
        ));
    }

    if gas_estimation_config.low_block_history == 0
        || gas_estimation_config.market_block_history == 0
        || gas_estimation_config.aggressive_block_history == 0
    {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!(
                "low {}, market {}, aggressive {} block history must be > 0",
                gas_estimation_config.low_block_history,
                gas_estimation_config.market_block_history,
                gas_estimation_config.aggressive_block_history
            ),
        ));
    }

    Ok(())
}
```

The suggested maximums balance historical data coverage with resource constraints:
- 100 blocks for low (~10-20 minutes of history)
- 500 blocks for market (~1-2 hours)
- 10,000 blocks for aggressive (~1-2 days)

These limits prevent resource exhaustion while providing sufficient historical data for accurate gas price estimation.

## Proof of Concept

```rust
#[cfg(test)]
mod test_resource_exhaustion {
    use super::*;
    use crate::config::ApiConfig;

    #[test]
    fn test_sanitize_accepts_excessive_block_history() {
        // Create a node config with dangerously large block history values
        let node_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    low_block_history: 1_000_000,
                    market_block_history: 5_000_000,
                    aggressive_block_history: 10_000_000,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // Current implementation incorrectly accepts these values
        let result = GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );
        
        // This should fail but currently succeeds
        assert!(result.is_ok(), "Sanitize should reject excessive values but currently accepts them");
    }

    #[test] 
    fn test_sanitize_should_enforce_upper_bounds() {
        // After fix, this test demonstrates proper validation
        let node_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    aggressive_block_history: 100_000, // Exceeds reasonable maximum
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // With the fix, this should fail
        let result = GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );
        
        assert!(result.is_err(), "Should reject excessive aggressive_block_history");
    }
}
```

To demonstrate the resource exhaustion in a live environment:
1. Modify `node.yaml` configuration to set `aggressive_block_history: 10000000`
2. Start the node (it will accept the configuration)
3. Call `GET /v1/estimate_gas_price`
4. Monitor memory usage, database I/O, and API response time
5. Observe resource exhaustion and API unavailability

**Notes**

The vulnerability is particularly concerning because:
- Configuration sanitization is the last line of defense against operational errors
- The incomplete validation (checking lower bounds but not upper bounds) suggests an oversight rather than intentional design
- The resource consumption scales linearly with the configured values, making the impact predictable and severe
- Validator nodes commonly expose APIs for monitoring and transaction submission, directly linking this to consensus impact

### Citations

**File:** config/src/config/gas_estimation_config.rs (L38-50)
```rust
impl Default for GasEstimationConfig {
    fn default() -> GasEstimationConfig {
        GasEstimationConfig {
            enabled: true,
            static_override: None,
            full_block_txns: 250,
            low_block_history: 10,
            market_block_history: 30,
            aggressive_block_history: 120,
            cache_expiration_ms: 500,
            incorporate_reordering_effects: true,
        }
    }
```

**File:** config/src/config/gas_estimation_config.rs (L53-94)
```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Validate aggressive price takes the most history
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be > low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        Ok(())
    }
```

**File:** api/src/context.rs (L1325-1359)
```rust
        let max_block_history = config.aggressive_block_history;
        // 1. Get the block metadata txns
        let mut lookup_version = ledger_info.ledger_version.0;
        let mut blocks = vec![];
        // Skip the first block, which may be partial
        if let Ok((first, _, block)) = self.db.get_block_info_by_version(lookup_version) {
            if block.epoch() == epoch {
                lookup_version = first.saturating_sub(1);
            }
        }
        let mut cached_blocks_hit = false;
        for _i in 0..max_block_history {
            if cache
                .min_inclusion_prices
                .contains_key(&(epoch, lookup_version))
            {
                cached_blocks_hit = true;
                break;
            }
            match self.db.get_block_info_by_version(lookup_version) {
                Ok((first, last, block)) => {
                    if block.epoch() != epoch {
                        break;
                    }
                    lookup_version = first.saturating_sub(1);
                    blocks.push((first, last));
                    if lookup_version == 0 {
                        break;
                    }
                },
                Err(_) => {
                    break;
                },
            }
        }
```

**File:** api/src/context.rs (L1403-1424)
```rust
        let mut latest_prices: Vec<_> = min_inclusion_prices
            .iter()
            .take(config.market_block_history)
            .cloned()
            .collect();
        latest_prices.sort();
        let market_price = match latest_prices.get(latest_prices.len() / 2) {
            None => {
                error!(
                    "prices empty, blocks.len={}, cached_blocks_hit={}, epoch={}, version={}",
                    blocks_len,
                    cached_blocks_hit,
                    ledger_info.epoch.0,
                    ledger_info.ledger_version.0
                );
                return Ok(self.default_gas_estimation(min_gas_unit_price));
            },
            Some(price) => low_price.max(*price),
        };

        // (3) aggressive
        min_inclusion_prices.sort();
```

**File:** api/src/context.rs (L1447-1452)
```rust
        // GC old entries
        if cache.min_inclusion_prices.len() > max_block_history {
            for _i in max_block_history..cache.min_inclusion_prices.len() {
                cache.min_inclusion_prices.pop_first();
            }
        }
```

**File:** api/src/context.rs (L1630-1636)
```rust
pub struct GasEstimationCache {
    last_updated_epoch: Option<u64>,
    last_updated_time: Option<Instant>,
    estimation: Option<GasEstimation>,
    /// (epoch, lookup_version) -> min_inclusion_price
    min_inclusion_prices: BTreeMap<(u64, u64), u64>,
}
```

**File:** api/src/transactions.rs (L811-847)
```rust
    #[oai(
        path = "/estimate_gas_price",
        method = "get",
        operation_id = "estimate_gas_price",
        tag = "ApiTags::Transactions"
    )]
    async fn estimate_gas_price(&self, accept_type: AcceptType) -> BasicResult<GasEstimation> {
        fail_point_poem("endpoint_encode_submission")?;
        self.context
            .check_api_output_enabled("Estimate gas price", &accept_type)?;

        let context = self.context.clone();
        api_spawn_blocking(move || {
            let latest_ledger_info = context.get_latest_ledger_info()?;
            let gas_estimation = context.estimate_gas_price(&latest_ledger_info)?;
            Self::log_gas_estimation(&gas_estimation);

            match accept_type {
                AcceptType::Json => BasicResponse::try_from_json((
                    gas_estimation,
                    &latest_ledger_info,
                    BasicResponseStatus::Ok,
                )),
                AcceptType::Bcs => {
                    let gas_estimation_bcs = GasEstimationBcs {
                        gas_estimate: gas_estimation.gas_estimate,
                    };
                    BasicResponse::try_from_bcs((
                        gas_estimation_bcs,
                        &latest_ledger_info,
                        BasicResponseStatus::Ok,
                    ))
                },
            }
        })
        .await
    }
```

**File:** config/src/config/node_config_loader.rs (L70-90)
```rust
    /// Load the node config, validate the configuration options
    /// and process the config for the current environment.
    pub fn load_and_sanitize_config(&self) -> Result<NodeConfig, Error> {
        // Load the node config from disk
        let mut node_config = NodeConfig::load_config(&self.node_config_path)?;

        // Load the execution config
        let input_dir = RootPath::new(&self.node_config_path);
        node_config.execution.load_from_path(&input_dir)?;

        // Update the data directory. This needs to be done before
        // we optimize and sanitize the node configs (because some optimizers
        // rely on the data directory for file reading/writing).
        node_config.set_data_dir(node_config.get_data_dir().to_path_buf());

        // Optimize and sanitize the node config
        let local_config_yaml = get_local_config_yaml(&self.node_config_path)?;
        optimize_and_sanitize_node_config(&mut node_config, local_config_yaml)?;

        Ok(node_config)
    }
```
