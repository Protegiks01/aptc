# Audit Report

## Title
Race Condition in Object Code Deployment: Stale Sequence Number Causes Module Address Mismatch and Transaction Failures

## Summary
The `TransactionOptions::sequence_number()` function returns potentially stale sequence numbers that are used to predict future object addresses for code deployment. When another transaction increments the sequence number between prediction and submission, the on-chain derived object address differs from the off-chain predicted address, causing module publication to fail with `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER` error. This results in wasted gas, dirty staging area state, and operational disruption.

## Finding Description

The vulnerability exists in the object code deployment flow where sequence numbers are fetched non-atomically:

**Step 1: Off-chain sequence number prediction** [1](#0-0) 

This function fetches the current on-chain sequence number via REST API without any synchronization.

**Step 2: Future sequence number calculation** [2](#0-1) 

The predicted sequence number is used to calculate the object address off-chain.

**Step 3: Object address derivation** [3](#0-2) 

The object address is deterministically computed from creator address and sequence number.

**Step 4: Package compilation with predicted address** [4](#0-3) 

Modules are compiled with the predicted object address embedded in their bytecode.

**Step 5: Transaction submission with fresh sequence number** [5](#0-4) 

When the transaction is actually submitted, a FRESH sequence number is fetched from on-chain state.

**Step 6: On-chain object creation with fresh sequence number** [6](#0-5) 

The object seed is derived on-chain using the current sequence number at execution time.

**Step 7: Module address validation failure** [7](#0-6) 

The Move VM validates that `compiled_module.self_addr() == sender`. If a race condition occurred, the compiled module address (predicted) won't match the object signer address (actual), causing the transaction to fail.

**Race Condition Scenario:**

1. User executes `aptos move create-object-and-publish-package`
2. CLI fetches sequence number N at time T1
3. CLI predicts object address based on sequence number N+X
4. CLI compiles package with modules addressed at predicted object address
5. User confirms deployment (prompt shown)
6. **RACE WINDOW**: Another transaction for the same account is submitted (from another CLI instance, automation, or multisig participant), incrementing sequence number to N+1
7. CLI submits staging transactions with fresh sequence numbers N+1, N+2, etc.
8. Final publish transaction uses sequence number N+X+1 (not N+X!)
9. On-chain object is created at address derived from N+X+1
10. VM rejects modules because `compiled_address(N+X) != object_address(N+X+1)`
11. Transaction fails with `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER`

This breaks the **Transaction Validation** invariant (sequence number integrity) and **State Consistency** invariant (staging area left dirty).

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria:

1. **Financial Loss**: Users waste gas on failed transactions. For chunked publishing, multiple staging transactions succeed and consume gas before the final publish transaction fails.

2. **State Inconsistencies**: The staging area resource remains dirty after failure, requiring manual cleanup via `aptos move clear-staging-area` before retry.

3. **Operational Disruption**: Users experience unexplained transaction failures, wasted time debugging, and need to manually coordinate transaction submission to avoid race conditions.

4. **Silent Failures**: The error message `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER` doesn't clearly indicate the root cause is a sequence number race condition, making debugging difficult.

5. **Multisig Vulnerability**: For multisig accounts where multiple parties can submit transactions, this race condition is highly likely to occur naturally.

This qualifies as **High Severity** under "Significant protocol violations" and "State inconsistencies requiring intervention".

## Likelihood Explanation

**HIGH Likelihood**:

1. **Easy to Trigger**: Any parallel transaction submission (intentional or accidental) triggers the race condition. Common scenarios include:
   - Running multiple CLI commands simultaneously
   - Automated scripts submitting transactions
   - Multisig accounts with multiple signers
   - Wallet applications auto-submitting transactions

2. **No Protection**: The codebase has no synchronization, locking, validation, or retry mechanisms to prevent or recover from this race condition.

3. **Large Time Window**: The race window spans from sequence number fetch (line 1197) to final transaction submission (line 1232-1257), including user confirmation prompt (line 1212), making it easy to hit.

4. **Chunked Publishing**: The vulnerability is more severe for chunked publishing where multiple staging transactions are submitted sequentially, increasing the race window duration.

## Recommendation

Implement atomic sequence number handling for object code deployment:

**Option 1: Defer Object Address Calculation (Recommended)**

Modify the object code deployment flow to defer object address calculation until transaction execution time. Instead of embedding the predicted address in compiled modules, use a placeholder and have the Move VM resolve it during publishing.

**Option 2: Validation and Retry**

Add validation before final transaction submission:
```rust
// Before submitting publish transaction
let current_seq = self.txn_options.sequence_number(sender_address).await?;
if current_seq != predicted_seq {
    return Err(CliError::UnexpectedError(
        format!("Sequence number changed from {} to {}. Another transaction was submitted. Please retry.", 
        predicted_seq, current_seq)
    ));
}
```

**Option 3: Atomic Transaction Builder**

Fetch sequence number atomically within `submit_transaction()` and recalculate object address if needed, recompiling the package if the sequence number changed.

**Option 4: Warning Message**

At minimum, add a clear warning in the CLI:
```rust
println!("WARNING: If another transaction is submitted for this account before publishing completes, the deployment will fail.");
println!("Ensure no other transactions are in progress for account {}", sender_address);
```

## Proof of Concept

**Setup:**
```bash
# Terminal 1: Start object code deployment
aptos move create-object-and-publish-package \
  --address-name my_module \
  --named-addresses my_module=0xcafe \
  --assume-yes
```

**Exploit:**
```bash
# Terminal 2: While Terminal 1 is waiting at the confirmation prompt
# Submit any transaction to increment the sequence number
aptos account transfer \
  --account 0x1 \
  --amount 1 \
  --assume-yes
```

**Expected Result:**
- Terminal 1's publish transaction fails with `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER`
- Gas is wasted on staging transactions (if chunked publishing)
- Staging area is left dirty
- User must run `aptos move clear-staging-area` before retrying

**Alternative PoC (Programmatic):**

```rust
#[tokio::test]
async fn test_sequence_number_race_condition() {
    let account = create_test_account();
    
    // Fetch initial sequence number
    let seq1 = get_sequence_number(&client, account.address()).await.unwrap();
    
    // Submit interfering transaction
    submit_simple_transfer(&client, &account).await.unwrap();
    
    // Try to publish with stale sequence number
    let predicted_object_addr = create_object_code_deployment_address(
        account.address(), 
        seq1 + 1
    );
    
    // Compile package with predicted address
    let package = compile_package_with_address(predicted_object_addr);
    
    // Attempt to publish - should fail
    let result = submit_object_code_deployment(&client, &account, package).await;
    
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("MODULE_ADDRESS_DOES_NOT_MATCH_SENDER"));
}
```

## Notes

This vulnerability is particularly severe for:
- Production deployments where automation or monitoring systems might submit transactions
- Multisig accounts where coordination between signers is required
- Large packages requiring chunked publishing (longer exposure window)
- High-traffic accounts with frequent transaction submission

The fix requires careful redesign of the object code deployment flow to eliminate the race condition window between sequence number prediction and transaction execution.

### Citations

**File:** crates/aptos/src/common/types.rs (L1895-1912)
```rust
    pub async fn sequence_number(&self, sender_address: AccountAddress) -> CliTypedResult<u64> {
        match &self.session {
            None => {
                let client = self.rest_client()?;
                get_sequence_number(&client, sender_address).await
            },
            Some(session_path) => {
                let sess = Session::load(session_path)?;

                let account = sess
                    .state_store()
                    .get_resource::<AccountResource>(sender_address)?;
                let seq_num = account.map(|account| account.sequence_number).unwrap_or(0);

                Ok(seq_num)
            },
        }
    }
```

**File:** crates/aptos/src/common/types.rs (L1958-1960)
```rust
        // Get sequence number for account
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let sequence_number = account.sequence_number;
```

**File:** crates/aptos/src/move_tool/mod.rs (L1181-1200)
```rust
        let sequence_number = if self.chunked_publish_option.chunked_publish {
            // Perform a preliminary build to determine the number of transactions needed for chunked publish mode.
            // This involves building the package with mock account address `0xcafe` to calculate the transaction count.
            let mock_object_address = AccountAddress::from_hex_literal("0xcafe").unwrap();
            self.move_options
                .add_named_address(self.address_name.clone(), mock_object_address.to_string());
            let package = build_package_options(&self.move_options, &self.included_artifacts_args)?;
            let mock_payloads = create_chunked_publish_payloads(
                package,
                PublishType::AccountDeploy,
                None,
                chunked_publish_large_packages_module_address.unwrap(),
                self.chunked_publish_option.chunk_size,
            )?
            .payloads;
            let staging_tx_count = (mock_payloads.len() - 1) as u64;
            self.txn_options.sequence_number(sender_address).await? + staging_tx_count + 1
        } else {
            self.txn_options.sequence_number(sender_address).await? + 1
        };
```

**File:** crates/aptos/src/move_tool/mod.rs (L1202-1205)
```rust
        let object_address = create_object_code_deployment_address(sender_address, sequence_number);

        self.move_options
            .add_named_address(self.address_name, object_address.to_string());
```

**File:** types/src/object_address.rs (L9-17)
```rust
pub fn create_object_code_deployment_address(
    creator: AccountAddress,
    creator_sequence_number: u64,
) -> AccountAddress {
    let mut seed = vec![];
    seed.extend(bcs::to_bytes(OBJECT_CODE_DEPLOYMENT_DOMAIN_SEPARATOR).unwrap());
    seed.extend(bcs::to_bytes(&creator_sequence_number).unwrap());
    create_object_address(creator, &seed)
}
```

**File:** aptos-move/framework/aptos-framework/sources/object_code_deployment.move (L108-114)
```text
    inline fun object_seed(publisher: address): vector<u8> {
        let sequence_number = account::get_sequence_number(publisher) + 1;
        let seeds = vector[];
        vector::append(&mut seeds, bcs::to_bytes(&OBJECT_CODE_DEPLOYMENT_DOMAIN_SEPARATOR));
        vector::append(&mut seeds, bcs::to_bytes(&sequence_number));
        seeds
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L156-171)
```rust
            // Make sure all modules' addresses match the sender. The self address is
            // where the module will actually be published. If we did not check this,
            // the sender could publish a module under anyone's account.
            if addr != sender {
                let msg = format!(
                    "Compiled modules address {} does not match the sender {}",
                    addr, sender
                );
                return Err(verification_error(
                    StatusCode::MODULE_ADDRESS_DOES_NOT_MATCH_SENDER,
                    IndexKind::AddressIdentifier,
                    compiled_module.self_handle_idx().0,
                )
                .with_message(msg)
                .finish(Location::Undefined));
            }
```
