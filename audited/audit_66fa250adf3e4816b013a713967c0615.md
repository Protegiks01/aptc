# Audit Report

## Title
Missing Epoch-Version Consistency Validation in Subscription Stream Metadata Allows Invalid State Sync Proofs

## Summary
The subscription stream handler in the storage service fails to validate that `known_version_at_stream_start` and `known_epoch_at_stream_start` correspond to the same ledger state. This allows clients to claim they are in a future epoch they haven't reached, causing the server to send transaction proofs spanning unvalidated epoch boundaries without providing the necessary epoch ending ledger info. [1](#0-0) 

## Finding Description
When a client initiates a subscription stream, they provide `SubscriptionStreamMetadata` containing both `known_version_at_stream_start` and `known_epoch_at_stream_start`. The server should validate that these two values correspond to the same ledger state (i.e., that the version actually falls within the specified epoch).

The server's validation logic only checks one direction of mismatch: [2](#0-1) 

This validation only detects when `known_version` is **greater than** the epoch ending version (i.e., client claims to be in an old epoch). However, it **fails to detect** when `known_version` is **less than** the epoch starting version (i.e., client claims to be in a future epoch they haven't reached yet).

**Attack Scenario:**
1. Client at version 500 (in epoch 4) sends subscription with:
   - `known_version_at_stream_start = 500`
   - `known_epoch_at_stream_start = 5` (false claim - epoch 5 starts at version 801)

2. Server fetches epoch ending ledger info for epoch 5 (ends at version 1200)

3. Validation check: `if 1200 <= 500` evaluates to FALSE → subscription marked as READY (not invalid) [3](#0-2) 

4. Server generates proof for transactions 501-1200, which spans:
   - Remainder of epoch 4 (501-800)
   - Epoch 4→5 boundary at version 800
   - Epoch 5 transactions (801-1200)

5. Server sends `NewTransactionsWithProof` response containing:
   - Transactions 501-1200
   - Proof relative to version 1200
   - **Only** the epoch 5 ending ledger info (version 1200)
   - **Missing**: epoch 4 ending ledger info (version 800) [4](#0-3) 

The response structure only includes a single `LedgerInfoWithSignatures` (the target), not intermediate epoch ending ledger infos needed to validate epoch boundaries within the transaction range. [5](#0-4) 

**Root Cause**: The codebase has a `get_epoch(version)` method that can determine the actual epoch for any version: [6](#0-5) 

However, this validation is **never performed** in the subscription handling code. The server trusts the client's claimed epoch without verification.

## Impact Explanation
This vulnerability has **High Severity** impact:

1. **State Sync Corruption**: Clients receiving proofs spanning unvalidated epoch boundaries lack the epoch ending ledger info needed to properly validate and process the epoch change. This can lead to:
   - Client state corruption (tracking wrong epoch number)
   - Incorrect validator set usage for signature verification
   - Inability to properly validate transactions across the epoch boundary

2. **Consensus Disruption**: If a validator node is affected by this bug (either maliciously or due to software error), it could:
   - Track incorrect epoch state
   - Use wrong validator sets for block validation
   - Potentially cause consensus disagreement if it participates with corrupted state

3. **State Consistency Violations**: The protocol invariant requiring "State transitions must be atomic and verifiable via Merkle proofs" is broken because clients receive proofs for epoch-spanning transaction ranges without the necessary epoch ending ledger infos to validate those transitions.

Per the Aptos bug bounty criteria, this qualifies as **High Severity** due to:
- Significant protocol violations (incorrect epoch tracking)
- Potential validator node issues (if validators are affected)
- State inconsistencies requiring intervention

## Likelihood Explanation
**Likelihood: Medium to High**

This vulnerability can be triggered by:

1. **Malicious clients**: Intentionally sending mismatched version/epoch metadata to attack state sync infrastructure
2. **Buggy implementations**: Clients with implementation errors that incorrectly track their epoch state
3. **Race conditions**: Clients experiencing timing issues during epoch transitions

The attack requires no special privileges - any peer can send subscription requests with arbitrary metadata values. The server-side validation gap makes this easily exploitable.

## Recommendation

Add validation to ensure `known_version_at_stream_start` actually falls within `known_epoch_at_stream_start`:

```rust
// In identify_ready_and_invalid_subscriptions function, after line 921:
if highest_known_epoch < highest_synced_epoch {
    // NEW: Validate that known_version is actually in known_epoch
    let actual_epoch = match storage.get_epoch(highest_known_version) {
        Ok(epoch) => epoch,
        Err(error) => {
            error!(LogSchema::new(LogEntry::SubscriptionRefresh)
                .error(&error)
                .message(&format!(
                    "Failed to get epoch for version: {:?}!",
                    highest_known_version
                )));
            return;
        },
    };
    
    if actual_epoch != highest_known_epoch {
        // Version and epoch don't match - invalid subscription
        peers_with_invalid_subscriptions
            .lock()
            .push(peer_network_id);
        continue;
    }
    
    // Fetch the epoch ending ledger info from storage...
    // (existing code continues)
}
```

Additionally, consider enhancing the response to include intermediate epoch ending ledger infos when the transaction range spans epoch boundaries, ensuring clients can properly validate all epoch transitions.

## Proof of Concept

```rust
#[tokio::test]
async fn test_mismatched_epoch_version_subscription() {
    // Setup: Create storage with multiple epochs
    // Epoch 0: versions 0-99
    // Epoch 1: versions 100-199
    // Epoch 2: versions 200-299
    let (storage, _, _) = setup_storage_with_multiple_epochs().await;
    
    // Client is at version 150 (in epoch 1)
    // But claims to be in epoch 2
    let subscription_metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: 150,  // Actually in epoch 1
        known_epoch_at_stream_start: 2,      // Falsely claims epoch 2
        subscription_stream_id: 1,
    };
    
    // Create subscription request
    let request = StorageServiceRequest::new(
        DataRequest::SubscribeTransactionsWithProof(
            SubscribeTransactionsWithProofRequest {
                subscription_stream_metadata: subscription_metadata,
                subscription_stream_index: 0,
                include_events: false,
            }
        ),
        false,
    );
    
    // Process the subscription
    // EXPECTED: Server should reject this as invalid
    // ACTUAL: Server accepts it and generates proof spanning epoch 1->2 boundary
    //         without including epoch 1 ending ledger info
    
    let result = process_subscription_request(&storage, request).await;
    
    // Vulnerability: The subscription is accepted when it should be rejected
    assert!(result.is_err(), "Server should reject mismatched epoch/version");
    
    // If accepted, verify the response lacks intermediate epoch ending ledger info
    if let Ok(response) = result {
        match response {
            DataResponse::NewTransactionsWithProof((tx_list, target_li)) => {
                // Response includes transactions spanning epochs 1->2
                assert!(tx_list.first_transaction_version == Some(151));
                
                // But only includes target ledger info (epoch 2 ending)
                // Missing: epoch 1 ending ledger info at version 199
                // This causes client to fail validating the epoch boundary
            },
            _ => panic!("Unexpected response type"),
        }
    }
}
```

## Notes

The vulnerability exists because the subscription validation logic assumes clients provide accurate metadata. While the system has the capability to verify epoch-version correspondence via `get_epoch()`, this validation is never performed in the state sync subscription path. This creates an exploitable gap where malicious or buggy clients can cause state sync corruption by providing inconsistent epoch metadata.

The fix requires minimal changes: adding a single validation check that queries the actual epoch for the provided version and comparing it against the claimed epoch. This validation should occur before processing any subscription request to ensure all subsequent proof generation is based on consistent, verified state.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L418-422)
```rust
pub struct SubscriptionStreamMetadata {
    pub known_version_at_stream_start: u64, // The highest known transaction version at stream start
    pub known_epoch_at_stream_start: u64,   // The highest known epoch at stream start
    pub subscription_stream_id: u64,        // The unique id of the subscription stream
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L920-965)
```rust
            if highest_known_version < highest_synced_version {
                if highest_known_epoch < highest_synced_epoch {
                    // Fetch the epoch ending ledger info from storage (the
                    // peer needs to sync to their epoch ending ledger info).
                    let epoch_ending_ledger_info = match utils::get_epoch_ending_ledger_info(
                        cached_storage_server_summary.clone(),
                        optimistic_fetches.clone(),
                        subscriptions.clone(),
                        highest_known_epoch,
                        lru_response_cache.clone(),
                        request_moderator.clone(),
                        &peer_network_id,
                        storage.clone(),
                        time_service.clone(),
                    ) {
                        Ok(epoch_ending_ledger_info) => epoch_ending_ledger_info,
                        Err(error) => {
                            // Log the failure to fetch the epoch ending ledger info
                            error!(LogSchema::new(LogEntry::SubscriptionRefresh)
                                .error(&error)
                                .message(&format!(
                                    "Failed to get the epoch ending ledger info for epoch: {:?} !",
                                    highest_known_epoch
                                )));

                            return;
                        },
                    };

                    // Check that we haven't been sent an invalid subscription request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_subscriptions
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_subscriptions
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
                } else {
                    peers_with_ready_subscriptions
                        .lock()
                        .push((peer_network_id, highest_synced_ledger_info.clone()));
                };
            }
```

**File:** state-sync/storage-service/types/src/responses.rs (L147-147)
```rust
    NewTransactionsWithProof((TransactionListWithProof, LedgerInfoWithSignatures)),
```

**File:** types/src/transaction/mod.rs (L2245-2250)
```rust
pub struct TransactionListWithProof {
    pub transactions: Vec<Transaction>,
    pub events: Option<Vec<Vec<ContractEvent>>>,
    pub first_transaction_version: Option<Version>,
    pub proof: TransactionInfoListWithProof,
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L204-231)
```rust
    pub(crate) fn get_epoch(&self, version: Version) -> Result<u64> {
        let mut iter = self.db.iter::<EpochByVersionSchema>()?;
        // Search for the end of the previous epoch.
        iter.seek_for_prev(&version)?;
        let (epoch_end_version, epoch) = match iter.next().transpose()? {
            Some(x) => x,
            None => {
                // There should be a genesis LedgerInfo at version 0 (genesis only consists of one
                // transaction), so this normally doesn't happen. However this part of
                // implementation doesn't need to rely on this assumption.
                return Ok(0);
            },
        };
        ensure!(
            epoch_end_version <= version,
            "DB corruption: looking for epoch for version {}, got epoch {} ends at version {}",
            version,
            epoch,
            epoch_end_version
        );
        // If the obtained epoch ended before the given version, return epoch+1, otherwise
        // the given version is exactly the last version of the found epoch.
        Ok(if epoch_end_version < version {
            epoch + 1
        } else {
            epoch
        })
    }
```
