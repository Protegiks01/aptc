# Audit Report

## Title
Event Stream Poisoning via Unvalidated EventHandle GUID Allows Cross-Account Event Exposure

## Summary
The API's `find_event_key` function in `api/src/accounts.rs` deserializes EventHandle resources without validating that the embedded GUID's account address matches the queried account. This allows malicious Move modules to create fake EventHandle structures pointing to arbitrary accounts' event streams, causing clients to receive events from unintended sources and miss their intended notifications.

## Finding Description

The Aptos REST API provides an endpoint `GET /accounts/{address}/events/{event_handle}/{field_name}` to query events by deserializing an EventHandle from a resource field. The vulnerability exists in the `find_event_key` function which extracts the EventKey without validation. [1](#0-0) 

The function deserializes an EventHandle from BCS bytes and directly returns the embedded EventKey at line 643 without verifying that `event_handle.key().get_creator_address()` matches `self.address` (the queried account).

Move's type system only prevents direct construction of `aptos_framework::event::EventHandle` outside the framework, but BCS deserialization is structure-based, not name-based. An attacker can deploy a Move module with structures matching the EventHandle BCS layout: [2](#0-1) [3](#0-2) 

The attacker creates structs with identical field names and types (counter: u64, guid with nested id containing creation_num: u64 and addr: address), sets the addr field to a victim's address, and stores this in a resource. When deserialized, the Rust EventHandle type accepts this due to matching BCS structure: [4](#0-3) 

The attack breaks the API invariant that `/accounts/{address}/events/...` should only return events belonging to that address. Instead, it returns events from whatever address is encoded in the poisoned GUID.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the "Significant protocol violations" category because it breaks event stream isolation, a fundamental security guarantee. Specific impacts:

1. **Privacy Leak**: Any account can expose another account's private event streams by creating poisoned EventHandle resources
2. **Notification Confusion**: Clients monitoring specific accounts receive events from different accounts, causing them to miss critical notifications from the intended source
3. **Protocol Integrity**: Violates the fundamental assumption that resource queries return data scoped to the queried account

This is particularly severe for protocols that rely on EventHandle-based routing or event monitoring for critical operations (e.g., DeFi protocols monitoring deposit/withdrawal events, governance systems tracking votes).

## Likelihood Explanation

**Likelihood: Medium**

The attack is feasible but requires:
1. Attacker deploys a Move module with EventHandle-compatible structs (trivial)
2. Attacker creates resources with poisoned GUIDs pointing to victim accounts (trivial)
3. Clients query the attacker's resources for events (requires social engineering or protocol-level EventHandle indirection)

While direct exploitation requires client cooperation, scenarios exist where this is realistic:
- Protocols using shared registries that store EventHandle references for multiple users
- Indexers or explorers that automatically query resources based on on-chain references
- Smart contracts that programmatically resolve event streams from resource data

## Recommendation

Add validation in `find_event_key` to ensure the EventKey's account address matches the queried account:

```rust
pub fn find_event_key(
    &self,
    struct_tag: MoveStructTag,
    field_name: Identifier,
) -> Result<EventKey, BasicErrorWith404> {
    // ... existing code ...
    
    let event_handle: EventHandle = bcs::from_bytes(&event_handle_bytes)
        .context(format!(...))
        .map_err(|err| { ... })?;
    
    // ADD VALIDATION HERE:
    let event_key = event_handle.key();
    if event_key.get_creator_address() != self.address.into() {
        return Err(BasicErrorWith404::bad_request_with_code(
            anyhow::anyhow!(
                "EventHandle GUID address 0x{} does not match queried account 0x{}",
                event_key.get_creator_address(),
                self.address
            ),
            AptosErrorCode::InvalidInput,
            &self.latest_ledger_info,
        ));
    }
    
    Ok(*event_key)
}
```

## Proof of Concept

**Malicious Move Module:**
```move
module attacker::poison {
    struct PoisonedResource has key {
        fake_events: FakeEventHandle,
    }
    
    struct FakeEventHandle has store {
        counter: u64,
        guid: FakeGUID,
    }
    
    struct FakeGUID has store {
        id: FakeID,
    }
    
    struct FakeID has store {
        creation_num: u64,
        addr: address,
    }
    
    public entry fun poison(account: &signer, victim: address, victim_creation: u64) {
        move_to(account, PoisonedResource {
            fake_events: FakeEventHandle {
                counter: 0,
                guid: FakeGUID {
                    id: FakeID {
                        creation_num: victim_creation,
                        addr: victim,
                    }
                }
            }
        });
    }
}
```

**Exploitation Steps:**
1. Attacker deploys module and calls `poison(@victim, 0)` to target victim's `coin_register_events` (creation_num 0)
2. Client queries: `GET /accounts/{attacker}/events/attacker::poison::PoisonedResource/fake_events`
3. API deserializes FakeEventHandle (BCS-compatible with real EventHandle)
4. API extracts EventKey with victim's address (0xvictim, creation_num 0)
5. API returns victim's coin registration events instead of attacker's events
6. Client believes they're monitoring attacker but receives victim's private event stream

**Notes**

The vulnerability is confirmed in the current codebase. The JSON response format shows EventHandle with nested guid structure matching the Move definition, which enables the BCS layout compatibility exploit: [5](#0-4) 

The framework's friend-only protections for EventHandle creation cannot prevent this attack because BCS deserialization bypasses Move's type system checks, operating purely on structural compatibility.

### Citations

**File:** api/src/accounts.rs (L588-644)
```rust
    pub fn find_event_key(
        &self,
        struct_tag: MoveStructTag,
        field_name: Identifier,
    ) -> Result<EventKey, BasicErrorWith404> {
        // Parse the struct tag
        let struct_tag: StructTag = (&struct_tag)
            .try_into()
            .context("Given event handle was invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;

        // Find the resource and retrieve the struct field
        let (_, resource) = self.find_resource(&struct_tag)?;
        let (_id, value) = resource
            .into_iter()
            .find(|(id, _)| id == &field_name)
            .ok_or_else(|| {
                struct_field_not_found(
                    self.address,
                    &struct_tag,
                    &field_name,
                    self.ledger_version,
                    &self.latest_ledger_info,
                )
            })?;

        // Deserialize the event handle to retrieve the key
        let event_handle_bytes = bcs::to_bytes(&value)
            .context("Failed to serialize event handle from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
        // Deserialization may fail because the bytes are not EventHandle struct type.
        let event_handle: EventHandle = bcs::from_bytes(&event_handle_bytes)
            .context(format!(
                "Deserialization error, field({}) type is not a EventHandle struct",
                field_name
            ))
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;
        Ok(*event_handle.key())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L36-41)
```text
    struct EventHandle<phantom T: drop + store> has store {
        /// Total number of events emitted to this event stream.
        counter: u64,
        /// A globally unique ID for this event stream.
        guid: GUID,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/guid.move (L7-17)
```text
    struct GUID has drop, store {
        id: ID
    }

    /// A non-privileged identifier that can be freely created by anyone. Useful for looking up GUID's.
    struct ID has copy, drop, store {
        /// If creation_num is `i`, this is the `i+1`th GUID created by `addr`
        creation_num: u64,
        /// Address that created the GUID
        addr: address
    }
```

**File:** types/src/event.rs (L86-92)
```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct EventHandle {
    /// Number of events in the event stream.
    count: u64,
    /// The associated globally unique key that is used as the key to the EventStore.
    key: EventKey,
}
```

**File:** api/goldens/aptos_api__tests__state_test__test_get_account_resource.json (L5-12)
```json
    "coin_register_events": {
      "counter": "0",
      "guid": {
        "id": {
          "addr": "0xa550c18",
          "creation_num": "0"
        }
      }
```
