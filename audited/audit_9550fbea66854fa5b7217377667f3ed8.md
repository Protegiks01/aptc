# Audit Report

## Title
Currency Confusion in Lazy Account Creation Fee Validation Allows Underpayment for Storage Fees

## Summary
A currency confusion bug in the `finish_aborted_transaction` function double-counts storage fees when validating minimum account creation fees. The validation check incorrectly adds storage fees (in Octa) on top of `gas_used` (which already includes storage fees converted to gas units), allowing transactions to bypass minimum fee requirements and create accounts while paying approximately half the required storage fees.

## Finding Description

The vulnerability exists in the fee validation logic for lazy account creation during transaction abort. When a transaction from a new account (sequence number 0) aborts, the system performs automatic account creation to ensure the account resource exists for storing transaction metadata.

The buggy validation check occurs here: [1](#0-0) 

This line computes: `actual = gas_used * gas_unit_price + storage_fee - storage_refund`

However, according to the FeeStatement documentation, `gas_used` (which is `total_charge_gas_units`) already includes storage fees converted to gas units: [2](#0-1) 

The storage fee conversion happens in `charge_storage_fee`, which converts Octa to internal gas units and deducts from the gas meter balance: [3](#0-2) 

Since `gas_used` is calculated as `max_gas_amount - balance`: [4](#0-3) 

The calculation effectively becomes:
```
actual = (execution + io + storage_fee/gas_unit_price) * gas_unit_price + storage_fee
       = execution*gas_unit_price + io*gas_unit_price + storage_fee + storage_fee
       = execution*gas_unit_price + io*gas_unit_price + 2*storage_fee
```

This double-counting allows an attacker to set `max_gas_amount` such that only ~50% of the required storage fee is charged, yet the validation check passes because it sees double the actual storage fee amount.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos Bug Bounty criteria:

- **Limited Protocol Violations**: The vulnerability breaks the economic invariant that account creation must meet minimum fee requirements. This undermines the storage pricing model designed to deter state bloat.

- **Limited Funds Loss**: The protocol loses approximately 50% of expected storage fees per exploited account creation. While the per-account loss is modest (estimated 50,000-100,000 Octa based on current gas parameters), this could scale if exploited systematically.

- **State Inconsistencies**: Allows creation of account resources without proper economic deterrence, potentially enabling storage spam attacks at reduced cost.

The impact is constrained because:
- Only affects lazy account creation in failed transactions
- Attacker still pays partial fees (~50% instead of 100%)
- Does not enable direct fund theft or consensus violations

## Likelihood Explanation

**High Likelihood** of exploitation:

1. **Easy Trigger Condition**: Lazy account creation is triggered when any new user (sequence number 0) submits a transaction that aborts, which is a normal and common operation enabled by the DEFAULT_ACCOUNT_RESOURCE or SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION features: [5](#0-4) 

2. **No Special Privileges**: Any user can exploit this by creating new account addresses and submitting transactions designed to abort.

3. **Deterministic Exploit**: An attacker can precisely calculate the required `max_gas_amount` to underpay while passing the validation check.

4. **No Rate Limiting**: The exploit can be repeated across multiple accounts.

## Recommendation

The validation check should not add `storage_fee` separately since it's already included in `gas_used` when multiplied by `gas_unit_price`. The correct calculation should be:

```rust
let actual = gas_used * gas_unit_price - storage_refund;
```

Or alternatively, to be more explicit about the calculation:
```rust
let actual = (fee_statement.execution_gas_used() + fee_statement.io_gas_used()) * gas_unit_price 
           + storage_fee - storage_refund;
```

This ensures storage fees are counted only once in the validation.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a new account address
2. Calculating the minimum storage fee from `hack_account_creation_fee_lower_bound`
3. Setting `max_gas_amount` to approximately 50% of what would normally be required
4. Submitting a transaction that will abort (e.g., entry function that panics)
5. Observing that the account is created despite paying less than the minimum fee

A complete test would require instrumenting the gas meter to show the double-counting in the validation check versus the actual gas charged.

## Notes

The bug is located in the specific path for lazy account creation during aborted transactions. The successful transaction path does not have this validation check, so it is not affected. The vulnerability specifically exploits the mismatch between how `FeeStatement` tracks fees (with storage already converted and included in `total_charge_gas_units`) and how the validation check interprets these values.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L767-767)
```rust
                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2732-2737)
```rust
    fn gas_used(max_gas_amount: Gas, gas_meter: &impl AptosGasMeter) -> u64 {
        max_gas_amount
            .checked_sub(gas_meter.balance())
            .expect("Balance should always be less than or equal to max gas amount")
            .into()
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3457-3461)
```rust
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
```

**File:** types/src/fee_statement.rs (L19-21)
```rust
///        - storage fee charge (storage space): `storage_fee_octas`, to be included in
///          `total_charge_gas_unit`, this number is converted to gas units according to the user
///          specified `gas_unit_price` on the transaction.
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L260-280)
```rust
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
        let gas_consumed_internal = InternalGas::new(
            if gas_consumed_internal > u64::MAX as u128 {
                error!(
                    "Something's wrong in the gas schedule: gas_consumed_internal ({}) > u64::MAX",
                    gas_consumed_internal
                );
                u64::MAX
            } else {
                gas_consumed_internal as u64
            },
        );

        match self.balance.checked_sub(gas_consumed_internal) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.storage_fee_in_internal_units += gas_consumed_internal;
                self.storage_fee_used += amount;
```
