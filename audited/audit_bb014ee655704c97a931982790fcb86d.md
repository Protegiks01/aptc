# Audit Report

## Title
State Key-Value Updates Skipped During KV-Only Replay from Genesis (Version 0)

## Summary
When performing KV-only transaction replay starting from version 0 (genesis transaction), the state key-value updates from write sets are not applied to the state store due to an incorrect condition check. This results in transaction metadata being saved without corresponding state data, causing state inconsistency and rendering the restored node unable to participate in consensus or process transactions.

## Finding Description

The vulnerability exists in the transaction restoration logic when performing KV-only replay from the genesis transaction (version 0). [1](#0-0) 

The condition at line 269 requires `first_version > 0` to apply KV updates from write sets. When `first_version = 0` (genesis transaction), this condition evaluates to false, causing the entire KV replay logic to be skipped.

This scenario occurs during the restore process when no KV snapshot exists: [2](#0-1) 

When `db_next_version = 0` (empty database) and no KV snapshot is available, the restore coordinator sets `kv_replay_version = 0` and initiates KV-only replay from genesis.

**Attack Flow:**
1. Validator operator initiates database restore on an empty node
2. No KV snapshot exists, only transaction backups from version 0 onwards
3. Restore coordinator calls `TransactionRestoreBatchController` with KV-only replay from version 0
4. For genesis transaction (version 0), the write sets are saved but state updates are skipped due to the `first_version > 0` check
5. Database ends up with transaction metadata (transaction info, events, write sets) but no corresponding state key-values
6. State root hash mismatch occurs - transaction info contains the correct state root from genesis, but actual state store is empty
7. Node cannot validate state queries or participate in consensus

**Broken Invariants:**
- **State Consistency**: "State transitions must be atomic and verifiable via Merkle proofs" - Transaction metadata exists without corresponding state
- **Deterministic Execution**: "All validators must produce identical state roots for identical blocks" - Restored node has incorrect state root

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty: "State inconsistencies requiring intervention")

**Impact on System:**
- **State Inconsistency**: Transaction 0 (genesis) metadata is saved but genesis state (validator set, gas schedule, framework modules, configuration) is not applied
- **Validator Unavailability**: Affected node cannot participate in consensus due to state root mismatch
- **Query Failures**: All state reads fail because state store is empty despite transaction history existing
- **Manual Intervention Required**: Node must be wiped and restored again (potentially with full replay instead of KV-only)

**Scope:**
- Affects any validator performing restore operations from version 0 with KV-only replay
- Multiple validators could be affected if they restore from similar backup configurations
- Results in non-functional node that appears to have data but cannot operate

## Likelihood Explanation

**Likelihood: Medium to High**

**Conditions Required:**
1. Validator performs database restore operation (common operational scenario)
2. Starting from empty database (`db_next_version = 0`)
3. No KV snapshot available (only transaction backups)
4. Tree snapshot exists at later version (triggers Phase 1 KV-only replay)

This is a **realistic production scenario** that occurs when:
- Setting up new validator nodes from backups
- Recovering from database corruption
- Migrating validator infrastructure

The bug will trigger automatically during the restore process without any malicious input - it's a deterministic logic error in the restore code path.

## Recommendation

**Fix:** Modify the condition to handle version 0 correctly by checking if the previous state exists or should be initialized:

```rust
// In storage/aptosdb/src/backup/restore_utils.rs, around line 269:

if kv_replay {
    // For version 0 (genesis), we need to initialize state from scratch
    // For version > 0, we need valid state at previous version
    let can_replay = if first_version == 0 {
        true  // Genesis can always be replayed
    } else {
        first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok()
    };
    
    if can_replay {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches,
            state_kv_batches,
        )?;
        state_store.set_state_ignoring_summary(ledger_state);
    }
}
```

**Alternative Fix:** Ensure state is properly initialized before KV replay: [3](#0-2) 

When `first_version = 0`, the `force_state_version_for_kv_restore` call passes `None` to `init_state_ignoring_summary`. Ensure this properly initializes an empty state that can accept genesis updates.

## Proof of Concept

**Reproduction Steps:**

1. Create a backup from a node starting at version 0 (genesis)
2. On a fresh node with empty database, initiate restore with:
   - No KV snapshot available
   - Transaction backups starting from version 0
   - Tree snapshot at a later version (e.g., version 1000)
3. Restore process will trigger KV-only replay from version 0 in Phase 1
4. Observe that genesis transaction metadata is saved but state key-values are missing

**Verification:**
```rust
// After restore completes, verify the inconsistency:
let db = AptosDB::open(...);

// Transaction info exists
assert!(db.get_transaction_info(0).is_ok());

// But state is empty/incorrect
let state_root = db.get_state_root_hash(0)?;
let expected_genesis_root = /* compute from genesis write set */;
assert_ne!(state_root, expected_genesis_root); // State root mismatch!

// State queries fail
assert!(db.get_state_value_by_version(..., 0).is_err());
```

**Expected Behavior:** After restore, transaction metadata AND state key-values should both exist, with matching state root hash.

**Actual Behavior:** Transaction metadata exists but state is missing, causing state root mismatch and node malfunction.

---

**Notes:**

This vulnerability specifically affects the backup/restore subsystem and would be encountered during legitimate operational procedures. While not exploitable by external attackers, it breaks critical state consistency guarantees and would render restored validator nodes non-functional, requiring manual intervention to recover. The bug exists because the original logic assumed `first_version > 0` for all KV replay operations, not accounting for the genesis edge case where version 0 legitimately needs KV replay support.

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L269-277)
```rust
    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L283-294)
```rust
            let kv_replay_version = if let Some(kv_snapshot) = kv_snapshot.as_ref() {
                kv_snapshot.version + 1
            } else {
                db_next_version
            };
            transaction_restore_opt.target_version = tree_snapshot.version;
            TransactionRestoreBatchController::new(
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L567-568)
```rust
        let (first_version, _) = self.replay_from_version.unwrap();
        restore_handler.force_state_version_for_kv_restore(first_version.checked_sub(1))?;
```
