# Audit Report

## Title
Source Digest Metadata Trust Violation: Missing Cryptographic Binding Between PackageMetadata and Published Bytecode

## Summary
The `PackageMetadata` struct includes a `source_digest` field intended to provide cryptographic proof that published bytecode was compiled from specific source files. However, there is **no on-chain verification** that enforces the binding between the claimed `source_digest` and the actual bytecode being published. This allows attackers to publish packages with legitimate-looking `source_digest` values while deploying malicious bytecode, breaking the trust model for package source verification.

## Finding Description
The vulnerability exists across multiple components of the package publishing system:

1. **Source Digest Computation (Off-Chain)**: The `source_digest` is computed by hashing all Move source files and the `Move.toml` manifest. [1](#0-0) 

2. **Metadata Extraction**: The `source_digest` is extracted from compilation artifacts and included in `PackageMetadata` without any binding to the actual bytecode. [2](#0-1) 

3. **On-Chain Storage**: The `PackageMetadata` (including `source_digest`) is stored separately from the bytecode in the on-chain `PackageRegistry`. [3](#0-2) 

4. **Missing On-Chain Verification**: During package publishing, the VM validates module names, dependencies, and metadata structure, but **never verifies** that the bytecode matches what the `source_digest` claims. [4](#0-3) 

5. **Off-Chain Only Verification**: The `verify()` method can compare `source_digest` values, but this is an **off-chain tool**, not an on-chain enforcement mechanism. [5](#0-4) 

**Attack Scenario:**
1. Attacker compiles legitimate source code to obtain a valid `source_digest` (e.g., "ABC123...")
2. Attacker manually crafts malicious bytecode or modifies compiled bytecode to include backdoors
3. Attacker creates `PackageMetadata` with the legitimate `source_digest` from step 1
4. Attacker calls `publish_package_txn()` with the legitimate metadata but malicious bytecode
5. The on-chain package now shows `source_digest: "ABC123..."` but contains malicious bytecode
6. Users/auditors checking the `source_digest` believe they're getting legitimate code

This breaks the fundamental security guarantee that `source_digest` represents the actual deployed code.

## Impact Explanation
**Severity: High** - This qualifies as a "Significant protocol violation" under the High severity category ($50,000).

**Security Guarantees Broken:**
- **Deterministic Execution**: Different validators could be tricked into executing different code if they compile from source vs. use on-chain bytecode
- **Code Integrity**: The `source_digest` metadata becomes meaningless as a trust anchor
- **Audit Trail**: Security audits of source code cannot be trusted to match deployed bytecode

**Potential Exploits:**
- Deploy governance proposal packages with malicious bytecode disguised by legitimate `source_digest`
- Install backdoors in framework packages while appearing to use audited source code
- Bypass security reviews by showing clean sources while deploying malicious bytecode
- Social engineering attacks leveraging the false trust in `source_digest` metadata

This does not qualify as Critical severity because it requires active malicious deployment rather than exploiting existing code, but it represents a severe protocol-level trust violation.

## Likelihood Explanation
**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to publish packages (standard permission via `publish_package_txn`)
- No special privileges or validator access required
- Standard knowledge of Move compilation and bytecode manipulation

**Complexity: Low**
- Compile legitimate source to get valid `source_digest`
- Modify bytecode using standard binary tools or custom serialization
- Submit transaction with mismatched metadata and bytecode
- No complex timing, race conditions, or multi-step attacks required

**Detection Difficulty: High**
- Off-chain verification tools exist but are not mandatory
- Most users trust the on-chain `source_digest` without verification
- No on-chain mechanism alerts when mismatch occurs

The vulnerability is likely to be exploited because:
1. The trust model explicitly relies on `source_digest` for verification
2. No on-chain enforcement prevents the attack
3. Detection requires manual off-chain verification that users rarely perform

## Recommendation

**Immediate Fix:** Add on-chain verification that the published bytecode matches the claimed `source_digest`.

**Implementation Approach:**
1. During package publishing, compute a hash of the actual bytecode modules
2. Verify that recompiling from sources (if provided) produces bytecode matching the hash
3. Alternatively, require the `source_digest` to be computed from bytecode hash, not source hash

**Code Fix Location:** [4](#0-3) 

Add to `validate_publish_request()`:

```rust
// After line 1690, add bytecode verification
fn validate_source_digest_binding(
    metadata: &PackageMetadata,
    modules: &[CompiledModule],
) -> VMResult<()> {
    // Compute hash of actual bytecode
    let mut hasher = Sha256::new();
    for module in modules {
        let bytecode = module.serialize(None);
        hasher.update(Sha256::digest(&bytecode).as_slice());
    }
    let bytecode_digest = format!("{:X}", hasher.finalize());
    
    // Compare with claimed source_digest
    // or verify source_digest derivation if sources provided
    if !verify_digest_matches(&metadata.source_digest, &bytecode_digest) {
        return Err(Self::metadata_validation_error(
            "source_digest does not match published bytecode"
        ));
    }
    Ok(())
}
```

**Alternative Approach:** Deprecate `source_digest` as a source-based hash and replace with a bytecode-based hash that is verifiable on-chain.

## Proof of Concept

**Setup:** Create a malicious package publication demonstrating the vulnerability.

```move
// File: legitimate_source.move (what source_digest claims)
module 0xCAFE::TrustedModule {
    public fun safe_function(): u64 {
        42  // Legitimate behavior
    }
}

// Bytecode published on-chain (manually modified):
// Contains: public fun safe_function(): u64 { abort 999 }
// Or: Contains hidden admin backdoor functions

// Exploitation steps:
// 1. Compile legitimate_source.move -> get source_digest "ABC123..."
// 2. Manually craft malicious bytecode
// 3. Create PackageMetadata:
//    PackageMetadata {
//      name: "TrustedModule",
//      source_digest: "ABC123...",  // From legitimate source
//      modules: [...],
//      ...
//    }
// 4. Publish: publish_package_txn(owner, serialize(metadata), malicious_bytecode)
// 5. On-chain package shows source_digest "ABC123..." but executes malicious code
```

**Verification:**
1. Query on-chain `PackageRegistry` at published address
2. Extract `source_digest` -> shows "ABC123..." (legitimate)
3. Download actual bytecode and decompile
4. Observe bytecode differs from what source_digest claims
5. No on-chain validation prevents or detects this mismatch

**Notes:**
- This attack works because `validate_publish_request()` only checks module names and dependencies, never bytecode-to-digest binding
- The `source_digest` field is purely informational with no cryptographic enforcement
- Off-chain tools can detect this, but on-chain guarantees are completely broken
- This affects all packages published on Aptos, including critical framework upgrades and governance proposals

### Citations

**File:** third_party/move/tools/move-package/src/resolution/digest.rs (L11-51)
```rust
pub fn compute_digest(paths: &[PathBuf]) -> Result<PackageDigest> {
    let mut hashed_files = Vec::new();
    let mut hash = |path: &Path| {
        let contents = std::fs::read(path)?;
        hashed_files.push(format!("{:X}", Sha256::digest(&contents)));
        Ok(())
    };
    let mut maybe_hash_file = |path: &Path| -> Result<()> {
        match path.extension() {
            Some(x) if MOVE_EXTENSION == x => hash(path),
            _ if path.ends_with(SourcePackageLayout::Manifest.path()) => hash(path),
            _ => Ok(()),
        }
    };

    for path in paths {
        if path.is_file() {
            maybe_hash_file(path)?;
        } else {
            for entry in walkdir::WalkDir::new(path)
                .follow_links(true)
                .into_iter()
                .filter_map(|e| e.ok())
            {
                if entry.file_type().is_file() {
                    maybe_hash_file(entry.path())?
                }
            }
        }
    }

    // Sort the hashed files to ensure that the order of files is always stable
    hashed_files.sort();

    let mut hasher = Sha256::new();
    for file_hash in hashed_files.into_iter() {
        hasher.update(file_hash.as_bytes());
    }

    Ok(PackageDigest::from(format!("{:X}", hasher.finalize())))
}
```

**File:** aptos-move/framework/src/built_package.rs (L516-591)
```rust
    pub fn extract_metadata(&self) -> anyhow::Result<PackageMetadata> {
        let source_digest = self
            .package
            .compiled_package_info
            .source_digest
            .map(|s| s.to_string())
            .unwrap_or_default();
        let manifest_file = self.package_path.join("Move.toml");
        let manifest = std::fs::read_to_string(manifest_file)?;
        let custom_props = extract_custom_fields(&manifest)?;
        let manifest = zip_metadata_str(&manifest)?;
        let upgrade_policy = if let Some(val) = custom_props.get(UPGRADE_POLICY_CUSTOM_FIELD) {
            str::parse::<UpgradePolicy>(val.as_ref())?
        } else {
            UpgradePolicy::compat()
        };
        let mut modules = vec![];
        for u in self.package.root_modules() {
            let name = u.unit.name().to_string();
            let source = if self.options.with_srcs {
                zip_metadata_str(&std::fs::read_to_string(&u.source_path)?)?
            } else {
                vec![]
            };
            let source_map = if self.options.with_source_maps {
                zip_metadata(&u.unit.serialize_source_map())?
            } else {
                vec![]
            };
            modules.push(ModuleMetadata {
                name,
                source,
                source_map,
                extension: None,
            })
        }
        let deps = self
            .package
            .deps_compiled_units
            .iter()
            .flat_map(|(name, unit)| match &unit.unit {
                CompiledUnit::Module(m) => {
                    let package_name = name.as_str().to_string();
                    let account = AccountAddress::new(m.address.into_bytes());

                    Some(PackageDep {
                        account,
                        package_name,
                    })
                },
                CompiledUnit::Script(_) => None,
            })
            .chain(
                self.package
                    .bytecode_deps
                    .iter()
                    .map(|(name, module)| PackageDep {
                        account: NumericalAddress::from_account_address(*module.self_addr())
                            .into_inner(),
                        package_name: name.as_str().to_string(),
                    }),
            )
            .collect::<BTreeSet<_>>()
            .into_iter()
            .collect();
        Ok(PackageMetadata {
            name: self.name().to_string(),
            upgrade_policy,
            upgrade_number: 0,
            source_digest,
            manifest,
            modules,
            deps,
            extension: None,
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L29-49)
```text
    /// Metadata for a package. All byte blobs are represented as base64-of-gzipped-bytes
    struct PackageMetadata has copy, drop, store {
        /// Name of this package.
        name: String,
        /// The upgrade policy of this package.
        upgrade_policy: UpgradePolicy,
        /// The numbers of times this module has been upgraded. Also serves as the on-chain version.
        /// This field will be automatically assigned on successful upgrade.
        upgrade_number: u64,
        /// The source digest of the sources in the package. This is constructed by first building the
        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.
        source_digest: String,
        /// The package manifest, in the Move.toml format. Gzipped text.
        manifest: vector<u8>,
        /// The list of modules installed by this package.
        modules: vector<ModuleMetadata>,
        /// Holds PackageDeps.
        deps: vector<PackageDep>,
        /// For future extension
        extension: Option<Any>
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1739)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L195-243)
```rust
    pub fn verify(&self, package_metadata: &PackageMetadata) -> anyhow::Result<()> {
        let self_metadata = self.metadata;

        if self_metadata.name != package_metadata.name {
            bail!(
                "Package name doesn't match {} : {}",
                package_metadata.name,
                self_metadata.name
            )
        } else if self_metadata.deps != package_metadata.deps {
            bail!(
                "Dependencies don't match {:?} : {:?}",
                package_metadata.deps,
                self_metadata.deps
            )
        } else if self_metadata.modules != package_metadata.modules {
            bail!(
                "Modules don't match {:?} : {:?}",
                package_metadata.modules,
                self_metadata.modules
            )
        } else if self_metadata.manifest != package_metadata.manifest {
            bail!(
                "Manifest doesn't match {:?} : {:?}",
                package_metadata.manifest,
                self_metadata.manifest
            )
        } else if self_metadata.upgrade_policy != package_metadata.upgrade_policy {
            bail!(
                "Upgrade policy doesn't match {:?} : {:?}",
                package_metadata.upgrade_policy,
                self_metadata.upgrade_policy
            )
        } else if self_metadata.extension != package_metadata.extension {
            bail!(
                "Extensions doesn't match {:?} : {:?}",
                package_metadata.extension,
                self_metadata.extension
            )
        } else if self_metadata.source_digest != package_metadata.source_digest {
            bail!(
                "Source digests doesn't match {:?} : {:?}",
                package_metadata.source_digest,
                self_metadata.source_digest
            )
        }

        Ok(())
    }
```
