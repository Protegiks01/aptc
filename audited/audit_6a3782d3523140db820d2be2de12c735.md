# Audit Report

## Title
Missing Signature Verification in Signing Phase Allows Invalid Signatures to Propagate Through Consensus

## Summary
The `process()` function in the signing phase extracts a signature from one LedgerInfo and pairs it with a potentially different LedgerInfo without cryptographic verification. During network upgrades with mixed `order_vote_enabled` configurations, this creates invalid signatures that propagate through consensus, triggering expensive signature filtering operations and causing validator slowdowns.

## Finding Description

The vulnerability exists where two independent code paths create LedgerInfo instances that can differ in their `consensus_data_hash` field:

**Path 1 - CommitVote Creation:**
In `sign_and_broadcast_commit_vote()`, a `select!` statement determines the consensus_data_hash by racing three futures. [1](#0-0) 

The selected hash depends on which future completes first, creating a LedgerInfo that gets signed.

**Path 2 - Partial Commit Proof Creation:**
The `generate_commit_ledger_info()` function uses deterministic logic based solely on the `order_vote_enabled` flag. [2](#0-1) 

**The Vulnerability:**
The signing phase extracts a signature from `commit_vote_fut` and pairs it with `commit_ledger_info` without verifying they match. [3](#0-2) 

**Attack Scenario:**
During a network upgrade where validators have different `order_vote_enabled` settings:

1. Validators with `order_vote_enabled=true` create commit proofs using `HashValue::zero()` as consensus_data_hash
2. A validator with `order_vote_enabled=false` receives this commit proof via `commit_proof_fut`
3. The `select!` completes on `commit_proof_fut`, extracting `HashValue::zero()`
4. The signature is created for a LedgerInfo with `HashValue::zero()`
5. Meanwhile, `generate_commit_ledger_info()` with `order_vote_enabled=false` uses `ordered_proof.ledger_info().consensus_data_hash()` (non-zero)
6. The signature (valid for `HashValue::zero()`) is paired with a LedgerInfo containing a different hash

**Propagation:**
The invalid signature is added to the aggregator without verification. [4](#0-3) 

Verification only occurs during aggregation, where failures trigger expensive filtering. [5](#0-4) 

The filtering operation performs parallel cryptographic verification of each signature. [6](#0-5) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty "Validator node slowdowns" category)

This vulnerability causes:

1. **Performance Degradation**: Invalid signatures force validators to execute `filter_invalid_signatures()`, which performs expensive parallel cryptographic operations to identify and remove bad signatures
2. **Consensus Delays**: Failed aggregation attempts require retries with filtering, delaying block commitment
3. **Resource Waste**: Network bandwidth consumed broadcasting invalid signatures to all validators
4. **Amplification Effect**: During mixed-configuration upgrades, multiple validators simultaneously broadcast invalid signatures, compounding slowdown across the network

The impact aligns with the Aptos Bug Bounty HIGH severity category for validator node slowdowns affecting consensus performance.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability manifests under realistic conditions:

1. **Network Upgrades**: Rolling upgrades where validators transition between different `order_vote_enabled` configurations create the mismatch window (Medium-High likelihood)
2. **Race Conditions**: The `select!` statement can complete on `commit_proof_fut` before `order_proof_fut`, creating divergence even with eventual consistency (Medium likelihood)
3. **No Defensive Validation**: The absence of signature verification means any future code changes affecting LedgerInfo creation could trigger this vulnerability

Unlike theoretical vulnerabilities, this occurs naturally during operational procedures (network upgrades) without requiring malicious actors or Byzantine behavior.

## Recommendation

Add defensive signature verification in the signing phase:

```rust
let signature_result = if let Some(fut) = blocks
    .last()
    .expect("Blocks can't be empty")
    .pipeline_futs()
{
    let vote = fut.commit_vote_fut.clone().await
        .map_err(|e| Error::InternalError(e.to_string()))?;
    
    // Verify signature matches commit_ledger_info
    if vote.ledger_info() != &commit_ledger_info {
        return Err(Error::InternalError(
            "Signature mismatch: vote ledger_info differs from commit_ledger_info".to_string()
        ));
    }
    
    Ok(vote.signature().clone())
} else {
    self.safety_rule_handle
        .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
};
```

Additionally, ensure consistent `order_vote_enabled` configuration across all validators during upgrades through coordinated epoch transitions.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring validator A with `order_vote_enabled=true`
2. Configuring validator B with `order_vote_enabled=false`  
3. Having validator A create a commit proof with `HashValue::zero()`
4. Observing validator B receive this proof via `commit_proof_fut`
5. Monitoring validator B create an invalid signature when the `select!` completes on `commit_proof_fut` but `generate_commit_ledger_info` uses non-zero hash
6. Confirming the invalid signature triggers `filter_invalid_signatures()` during aggregation

The code paths are deterministic and the vulnerability is reproducible when the configuration mismatch exists during network operations.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L990-1006)
```rust
        let mut consensus_data_hash = select! {
            Ok(_) = order_vote_rx => {
                HashValue::zero()
            }
            Ok(li) = order_proof_fut => {
                li.ledger_info().ledger_info().consensus_data_hash()
            }
            Ok(li) = commit_proof_fut => {
                li.ledger_info().consensus_data_hash()
            }
            else => {
                return Err(anyhow!("all receivers dropped"))?;
            }
        };
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
```

**File:** consensus/src/pipeline/buffer_item.rs (L25-38)
```rust
fn generate_commit_ledger_info(
    commit_info: &BlockInfo,
    ordered_proof: &LedgerInfoWithSignatures,
    order_vote_enabled: bool,
) -> LedgerInfo {
    LedgerInfo::new(
        commit_info.clone(),
        if order_vote_enabled {
            HashValue::zero()
        } else {
            ordered_proof.ledger_info().consensus_data_hash()
        },
    )
}
```

**File:** consensus/src/pipeline/signing_phase.rs (L79-92)
```rust
        let signature_result = if let Some(fut) = blocks
            .last()
            .expect("Blocks can't be empty")
            .pipeline_futs()
        {
            fut.commit_vote_fut
                .clone()
                .await
                .map(|vote| vote.signature().clone())
                .map_err(|e| Error::InternalError(e.to_string()))
        } else {
            self.safety_rule_handle
                .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
        };
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```

**File:** types/src/ledger_info.rs (L517-535)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```
