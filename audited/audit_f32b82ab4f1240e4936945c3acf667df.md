# Audit Report

## Title
Sybil Attack on Secret Sharing Through Uniform Validator Weights Enables Disproportionate Influence in Randomness Generation

## Summary
The secret sharing mechanism used for on-chain randomness generation assigns a uniform weight of 1 to all validators regardless of their stake amount. This allows an attacker to create multiple minimum-stake validators and gain disproportionate influence in secret reconstruction compared to honest high-stake validators with equivalent total stake, effectively enabling a Sybil attack on the randomness generation system.

## Finding Description

The vulnerability exists in two parallel implementations of secret sharing configuration: [1](#0-0) [2](#0-1) 

Both `get_peer_weight()` functions return a hardcoded value of 1 for all validators, completely ignoring the actual validator stake. This weight is used during secret share aggregation: [3](#0-2) 

The aggregation logic checks if accumulated weight meets the threshold: [4](#0-3) 

**Attack Scenario:**

The staking system allows validators to join if they meet minimum and maximum stake requirements: [5](#0-4) 

The validator set size is limited but generous: [6](#0-5) 

**Exploitation Path:**

1. Attacker has total stake of `S` APT tokens
2. Attacker creates `S / minimum_stake` validators, each staking exactly `minimum_stake`
3. Each validator participates in secret sharing with weight = 1
4. Attacker's total weight in secret reconstruction = `S / minimum_stake`

5. Honest validator with same stake `S` APT keeps it in a single validator
6. Honest validator's weight in secret reconstruction = 1

**Result:** With equal stake, the attacker has `S / minimum_stake` times more influence than the honest validator in secret reconstruction, violating the fundamental security principle that influence should be proportional to stake.

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability meets Critical severity criteria because:

1. **Consensus/Safety Violations**: The secret sharing mechanism is used to generate on-chain randomness, which is critical for:
   - Leader selection in consensus rounds
   - Validator ordering
   - Other randomness-dependent protocol operations

2. **Breaks Core Security Invariants**:
   - Violates "Staking Security: Validator rewards and penalties must be calculated correctly"
   - Violates "Cryptographic Correctness" by undermining the security assumptions of the threshold secret sharing scheme
   - The weighted secret sharing scheme assumes weights reflect true contribution/stake, but uniform weights break this assumption

3. **Network-Wide Impact**: An attacker controlling a disproportionate share of secret reconstruction can:
   - Manipulate randomness generation outcomes
   - Influence leader election unfairly
   - Potentially cause consensus liveness issues if they refuse to participate with their many validators
   - Gain an unfair advantage in any protocol mechanism depending on randomness

4. **Bypasses Economic Security**: The staking system is designed so that influence is proportional to economic investment (stake). This vulnerability completely undermines that model, allowing someone with X stake to gain N×X influence where N is the number of validators they create.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to occur because:

1. **Low Barrier to Entry**: Any party with sufficient capital to meet minimum staking requirements can execute this attack
2. **Economic Incentive**: The attacker gains disproportionate influence without additional cost beyond the capital lockup
3. **No Technical Complexity**: Simply requires creating multiple validator accounts and staking minimum amounts - no cryptographic or protocol expertise needed
4. **Detectable but Unpatchable**: While the pattern of many minimum-stake validators from one entity might be observable, there's no on-chain mechanism to prevent it without fixing the weight calculation
5. **TODO Comment**: The code contains `// daniel todo: use weighted config`, indicating developers are aware weights should be used but haven't implemented it, suggesting this is production code with a known issue

## Recommendation

Implement proper stake-weighted secret sharing. Modify the `get_peer_weight()` function to return the actual validator voting power:

```rust
// In types/src/secret_sharing.rs
pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    // Get the validator's voting power from the validator verifier
    self.validator
        .get_voting_power(peer)
        .unwrap_or(0)
}
```

Similarly for `SecretSharingConfig`:

```rust
// In consensus/src/rand/secret_sharing/types.rs
pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    self.validator
        .get_voting_power(peer)
        .unwrap_or(0)
}
```

Ensure the threshold is also calculated based on total voting power, not just validator count. The threshold should typically be set to `⌈2f+1⌉ / 3` of total voting power to align with BFT assumptions.

Additionally, populate the `weights` HashMap properly during initialization: [7](#0-6) 

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_sybil_attack_on_secret_sharing() {
    use aptos_types::validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo};
    use aptos_crypto::bls12381;
    
    let minimum_stake = 1_000_000u64; // 1M APT
    let total_attacker_stake = 100_000_000u64; // 100M APT
    let num_attacker_validators = (total_attacker_stake / minimum_stake) as usize; // 100 validators
    
    // Attacker creates 100 validators with minimum stake each
    let mut attacker_validators = Vec::new();
    for i in 0..num_attacker_validators {
        let (sk, pk) = bls12381::PrivateKey::generate_for_testing()
            .into_tuple();
        attacker_validators.push(ValidatorConsensusInfo::new(
            AccountAddress::random(),
            pk,
            minimum_stake, // Each has minimum stake
        ));
    }
    
    // Honest validator with same total stake
    let (honest_sk, honest_pk) = bls12381::PrivateKey::generate_for_testing()
        .into_tuple();
    let honest_validator = ValidatorConsensusInfo::new(
        AccountAddress::random(),
        honest_pk,
        total_attacker_stake, // Same total stake as attacker
    );
    
    let mut all_validators = attacker_validators.clone();
    all_validators.push(honest_validator.clone());
    
    let verifier = ValidatorVerifier::new(all_validators);
    
    // Create SecretShareConfig with uniform weights
    let config = SecretShareConfig::new(
        attacker_validators[0].account_address,
        1, // epoch
        Arc::new(verifier),
        digest_key,
        msk_share,
        verification_keys,
        threshold_config,
        encryption_key,
    );
    
    // Demonstrate weight disparity
    let attacker_total_weight: u64 = attacker_validators
        .iter()
        .map(|v| config.get_peer_weight(&v.account_address))
        .sum();
    
    let honest_weight = config.get_peer_weight(&honest_validator.account_address);
    
    // Both have 100M APT staked, but:
    assert_eq!(attacker_total_weight, 100); // Attacker gets 100 weight
    assert_eq!(honest_weight, 1); // Honest validator gets 1 weight
    
    // Attacker has 100x more influence with same stake!
    assert_eq!(attacker_total_weight / honest_weight, 100);
    
    // This violates the principle that influence should be proportional to stake
    // Both have equal stake but vastly different influence in secret reconstruction
}
```

## Notes

The vulnerability exists in production code with a TODO comment acknowledging that weighted config should be used. The current implementation treats all validators equally regardless of stake, fundamentally breaking the economic security model of proof-of-stake consensus. This is particularly critical because secret sharing is used for on-chain randomness generation, which affects leader selection and other consensus-critical operations.

### Citations

**File:** types/src/secret_sharing.rs (L145-169)
```rust
    weights: HashMap<Author, u64>,
}

impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** consensus/src/rand/secret_sharing/types.rs (L99-102)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        // daniel todo: use weighted config
        1
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L38-46)
```rust
    pub fn try_aggregate(
        self,
        secret_share_config: &SecretShareConfig,
        metadata: SecretShareMetadata,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Either<Self, SecretShare> {
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-261)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L100-100)
```text
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```
