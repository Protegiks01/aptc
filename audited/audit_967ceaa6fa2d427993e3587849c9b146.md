# Audit Report

## Title
Circular Module Dependency Detection Bypassed with Lazy Loading Enabled

## Summary
The `build_verified_module_with_linking_checks()` function does NOT detect or reject circular dependencies between modules when lazy loading is enabled (the default configuration). This allows attackers to publish modules with circular dependency chains that are explicitly blocked in eager verification mode, potentially violating deterministic execution guarantees across validator nodes.

## Finding Description

The Move VM runtime has a dedicated circular dependency checker in `cyclic_dependencies::verify_module`, but it is **never invoked** in the codebase. [1](#0-0) 

The `build_verified_module_with_linking_checks()` function only calls `dependencies::verify_module`, which verifies imported modules/structs/functions exist and match signatures, but does **not** check for circular dependencies: [2](#0-1) 

The `dependencies::verify_module` implementation confirms it only checks module existence, struct compatibility, and function signatures: [3](#0-2) 

During module publishing with lazy loading enabled, the code **explicitly states** it skips cyclic dependency checks: [4](#0-3) 

Lazy loading is enabled by default: [5](#0-4) 

Integration tests confirm circular dependencies are **allowed** with lazy loading but **rejected** without it: [6](#0-5) 

**Attack Scenario:**
1. Attacker publishes a bundle containing modules A, B, C where A→B→C→A (circular chain)
2. With lazy loading enabled (default), all modules pass verification and are published
3. Dependencies are fetched lazily using `unmetered_get_existing_lazily_verified_module`, which skips linking checks
4. `build_verified_module_with_linking_checks` is called but does not detect the cycle
5. The circular dependency chain is now on-chain

While this does not directly cause infinite loops during the linking phase itself (as `dependencies::verify_module` does not recursively traverse), it violates the **deterministic execution invariant** because:
- Validators with different feature flags may have different lazy loading configurations
- Modules that pass verification on one validator may fail on another
- This creates potential for consensus disagreements about which modules are valid

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention.

This breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks." 

If validators have different configurations for the lazy loading feature flag (controlled by `ENABLE_LAZY_LOADING` feature flag 95), they will accept/reject circular dependency modules differently: [7](#0-6) 

Production configuration dynamically determines lazy loading via feature flags: [8](#0-7) 

This inconsistency could lead to:
- Different validators accepting different sets of modules
- Potential consensus splits if the feature flag is toggled
- Modules that are "valid" on some nodes but "invalid" on others

## Likelihood Explanation

**High** - The vulnerability is easily exploitable:
- Lazy loading is enabled by default
- Any user can submit module bundles with circular dependencies
- No privileged access required
- The circular dependency checker exists but is completely unused
- Tests confirm the behavior is current and intentional for lazy mode

## Recommendation

**Option 1: Always enforce circular dependency checks**
Call `cyclic_dependencies::verify_module` in addition to `dependencies::verify_module`:

```rust
pub(crate) fn build_verified_module_with_linking_checks(
    &self,
    locally_verified_module: LocallyVerifiedModule,
    immediate_dependencies: &[Arc<Module>],
) -> VMResult<Module> {
    // Add circular dependency check
    let imm_deps_closure = |module_id: &ModuleId| -> PartialVMResult<Vec<ModuleId>> {
        // Return immediate dependencies for the given module
        Ok(immediate_dependencies
            .iter()
            .filter(|m| m.module_id() == module_id)
            .flat_map(|m| m.immediate_dependencies())
            .collect())
    };
    let imm_friends_closure = |module_id: &ModuleId| -> PartialVMResult<Vec<ModuleId>> {
        Ok(vec![]) // Simplified for this example
    };
    
    cyclic_dependencies::verify_module(
        locally_verified_module.0.as_ref(),
        imm_deps_closure,
        imm_friends_closure,
    )?;
    
    dependencies::verify_module(
        &self.vm_config.verifier_config,
        locally_verified_module.0.as_ref(),
        immediate_dependencies
            .iter()
            .map(|module| module.as_ref().as_ref()),
    )?;
    // ... rest of function
}
```

**Option 2: Disable lazy loading by default**
Change the default to `enable_lazy_loading: false` until circular dependency detection is properly implemented for lazy mode.

## Proof of Concept

```move
// Module A
module 0x1::A {
    use 0x1::B;
    public fun call_b() {
        B::call_c();
    }
}

// Module B  
module 0x1::B {
    use 0x1::C;
    public fun call_c() {
        C::call_a();
    }
}

// Module C
module 0x1::C {
    use 0x1::A;
    public fun call_a() {
        A::call_b();
    }
}
```

**Steps to reproduce:**
1. Compile the three modules above into a bundle
2. Submit the bundle for publishing with lazy loading enabled (default)
3. Observe that all three modules are successfully published despite the circular dependency A→B→C→A
4. The same bundle would be rejected with eager verification mode

**Notes**

The circular dependency check exists in the codebase but is completely unused. The existing `cyclic_dependencies::verify_module` function implements DFS-based cycle detection that would catch this issue, but it's never called from any verification path.

The test suite explicitly documents that "cyclic dependencies are allowed to be published (but not called)" with lazy loading, suggesting this may be intentional behavior. However, this creates a security vulnerability where different validator configurations could lead to consensus disagreements about module validity.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/cyclic_dependencies.rs (L68-115)
```rust
pub fn verify_module<D, F>(module: &CompiledModule, imm_deps: D, imm_friends: F) -> VMResult<()>
where
    D: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
    F: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
{
    verify_module_impl(module, imm_deps, imm_friends)
        .map_err(|e| e.finish(Location::Module(module.self_id())))
}

fn verify_module_impl<D, F>(
    module: &CompiledModule,
    imm_deps: D,
    imm_friends: F,
) -> PartialVMResult<()>
where
    D: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
    F: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
{
    let self_id = module.self_id();

    // collect and check that there is no cyclic dependency relation
    let all_deps = collect_all_with_cycle_detection(
        &self_id,
        &module.immediate_dependencies(),
        &imm_deps,
        StatusCode::CYCLIC_MODULE_DEPENDENCY,
    )?;

    // collect and check that there is no cyclic friend relation
    let all_friends = collect_all_with_cycle_detection(
        &self_id,
        &module.immediate_friends(),
        &imm_friends,
        StatusCode::CYCLIC_MODULE_FRIENDSHIP,
    )?;

    // check that any direct/transitive dependency is neither a direct nor transitive friend
    match all_deps.intersection(&all_friends).next() {
        Some(overlap) => Err(PartialVMError::new(
            StatusCode::INVALID_FRIEND_DECL_WITH_MODULES_IN_DEPENDENCIES,
        )
        .with_message(format!(
            "At least one module, {}, appears in both the dependency set and the friend set",
            overlap
        ))),
        None => Ok(()),
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L205-228)
```rust
    pub(crate) fn build_verified_module_with_linking_checks(
        &self,
        locally_verified_module: LocallyVerifiedModule,
        immediate_dependencies: &[Arc<Module>],
    ) -> VMResult<Module> {
        dependencies::verify_module(
            &self.vm_config.verifier_config,
            locally_verified_module.0.as_ref(),
            immediate_dependencies
                .iter()
                .map(|module| module.as_ref().as_ref()),
        )?;
        let result = Module::new(
            &self.natives,
            locally_verified_module.1,
            locally_verified_module.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        );

        // Note: loader V1 implementation does not set locations for this error.
        result.map_err(|e| e.finish(Location::Undefined))
    }
```

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L185-195)
```rust
fn verify_module_impl<'a>(
    module: &CompiledModule,
    dependencies: impl IntoIterator<Item = &'a CompiledModule>,
) -> PartialVMResult<()> {
    let context = &Context::module(module, dependencies);

    verify_imported_modules(context)?;
    verify_imported_structs(context)?;
    verify_imported_functions(context)?;
    verify_all_script_visibility_usage(context)
}
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L259-275)
```rust
                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L77-77)
```rust
            enable_lazy_loading: true,
```

**File:** third_party/move/move-vm/integration-tests/src/tests/module_storage_tests.rs (L228-239)
```rust
    if enable_lazy_loading {
        // With lazy loading, cyclic dependencies are allowed to be published (but not called).
        assert_ok!(module_storage.unmetered_get_lazily_verified_module(&c_id));
        module_storage.assert_cached_state(vec![], vec![&c_id]);
    } else {
        let result =
            module_storage.unmetered_get_eagerly_verified_module(c_id.address(), c_id.name());
        assert_eq!(
            assert_err!(result).major_status(),
            StatusCode::CYCLIC_MODULE_DEPENDENCY
        );
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L145-148)
```rust
    /// With lazy loading, modules are loaded lazily (as opposed to loading the transitive closure
    /// of dependencies). For more details, see:
    ///   AIP-127 (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-127.md)
    ENABLE_LAZY_LOADING = 95,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L255-255)
```rust
        enable_lazy_loading: features.is_lazy_loading_enabled(),
```
