# Audit Report

## Title
Hidden Metadata Files Bypass Validation and Are Processed During Restore Operations

## Summary
The `BackupStorage::list_metadata_files()` implementations in both `LocalFs` and `CommandAdapter` include hidden files (starting with `.`) in their listings without filtering. While the `save_metadata_line()` API enforces `ShellSafeName` validation that prevents creating hidden files, an attacker with direct storage access can bypass this validation and place malicious hidden metadata files. These files are processed during restore operations but may not be visible during security audits, enabling stealth attacks on backup integrity.

## Finding Description

The backup system enforces strict filename validation through the `ShellSafeName` type, which uses the pattern `\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z` to ensure filenames are safe for shell commands and cannot start with a dot. [1](#0-0) 

However, the `list_metadata_files()` implementations do not filter hidden files when listing metadata from storage.

**LocalFs Implementation:**
The `LocalFs::list_metadata_files()` uses `read_dir()` which returns ALL directory entries including hidden files, with no filtering applied: [2](#0-1) 

**CommandAdapter Implementation:**
The `CommandAdapter::list_metadata_files()` executes shell commands that also list all files without filtering: [3](#0-2) 

Production configurations confirm this behavior. For example, the GCS configuration uses `gcloud storage ls` which lists all files: [4](#0-3) 

**Processing All Listed Files:**
During restore operations, the `sync_and_load()` function downloads and parses ALL files returned by `list_metadata_files()` without filtering: [5](#0-4) 

These metadata files are then parsed as JSON and used to build the `MetadataView`: [6](#0-5) 

The parsed metadata controls which backup files are used during restore operations, including transaction backups, state snapshots, and epoch endings: [7](#0-6) 

**Attack Scenario:**
1. Attacker gains direct write access to backup storage (e.g., compromised cloud credentials, misconfigured bucket permissions, or insider access)
2. Attacker creates hidden metadata files (e.g., `.malicious.meta`) bypassing the `ShellSafeName` validation
3. These files contain malicious metadata pointing to attacker-controlled backup files or manipulating restore behavior
4. During restore operations, these hidden files are listed, downloaded, and processed
5. Hidden files may not appear in security audits using standard tools (many skip dotfiles by default)
6. Restore operations use the malicious metadata, potentially restoring incorrect state or attacker-controlled data

## Impact Explanation

This vulnerability is categorized as **Medium Severity** per the Aptos bug bounty program criteria: "State inconsistencies requiring intervention."

The impact includes:
- **Backup Integrity Compromise**: Malicious metadata can cause restore operations to use incorrect backup files
- **Data Corruption Risk**: Restoring from attacker-controlled manifests can corrupt node state
- **Stealth Attack Vector**: Hidden files may not be visible in audits using standard listing tools (`ls`, web console interfaces that skip dotfiles)
- **Continuity Violation**: Malicious metadata can break backup range continuity checks or inject duplicate entries

While this does not directly cause consensus violations or fund loss, it compromises the integrity of backup/restore operations, which are critical for disaster recovery and node bootstrapping. An operator restoring from compromised backups could introduce corrupted state into their node.

## Likelihood Explanation

The likelihood is **Medium** due to the following factors:

**Prerequisites:**
- Attacker needs direct write access to backup storage
- Cannot exploit through normal Aptos node APIs
- Requires compromised cloud storage credentials or insider access

**Feasibility:**
- Cloud storage credential leaks are common (IAM keys in repos, misconfigured permissions)
- Shared backup storage environments may have multiple access points
- Once storage access is obtained, creating hidden files is trivial

**Detection Difficulty:**
- Hidden files may not appear in standard audits
- Many monitoring tools skip dotfiles by default
- No validation or logging alerts for hidden metadata files

## Recommendation

Implement filtering in `list_metadata_files()` implementations to exclude hidden files (filenames starting with `.`):

**For LocalFs:**
```rust
async fn list_metadata_files(&self) -> Result<Vec<FileHandle>> {
    let dir = self.metadata_dir();
    let rel_path = Path::new(Self::METADATA_DIR);

    let mut res = Vec::new();
    if path_exists(&dir).await {
        let mut entries = read_dir(&dir).await.err_notes(&dir)?;
        while let Some(entry) = entries.next_entry().await.err_notes(&dir)? {
            let file_name = entry.file_name();
            // Filter out hidden files (starting with .)
            if let Some(name_str) = file_name.to_str() {
                if !name_str.starts_with('.') {
                    res.push(rel_path.join(file_name).path_to_string()?)
                }
            }
        }
    }
    Ok(res)
}
```

**For CommandAdapter configurations:**
Update sample configs to filter hidden files in the shell command:
```yaml
list_metadata_files: '(gcloud storage ls gs://$BUCKET/$SUB_DIR/metadata/ ||:) | grep -v "/\." | sed -ne "s#gs://.*/metadata/#metadata/#p"'
```

Additionally, consider adding validation that all processed metadata files have valid `ShellSafeName` patterns, and log warnings for any files that don't match expected patterns.

## Proof of Concept

```rust
#[cfg(test)]
mod hidden_file_vulnerability_test {
    use super::*;
    use std::fs::File;
    use std::io::Write;
    use tempfile::TempDir;
    use tokio;

    #[tokio::test]
    async fn test_hidden_metadata_files_are_listed() {
        // Create temporary backup directory
        let temp_dir = TempDir::new().unwrap();
        let backup_dir = temp_dir.path();
        
        // Create LocalFs storage
        let storage = LocalFs::new(backup_dir.to_path_buf());
        
        // Create metadata directory
        let metadata_dir = storage.metadata_dir();
        tokio::fs::create_dir_all(&metadata_dir).await.unwrap();
        
        // Create a legitimate metadata file
        let legit_file = metadata_dir.join("legitimate.meta");
        let mut f = File::create(&legit_file).unwrap();
        writeln!(f, "{{\"Identity\":{{\"id\":\"0x1234\"}}}}").unwrap();
        
        // Create a hidden metadata file (bypassing the API)
        let hidden_file = metadata_dir.join(".malicious.meta");
        let mut f = File::create(&hidden_file).unwrap();
        writeln!(f, "{{\"TransactionBackup\":{{\"first_version\":0,\"last_version\":999999,\"manifest\":\"attacker-controlled-file\"}}}}").unwrap();
        
        // List metadata files
        let files = storage.list_metadata_files().await.unwrap();
        
        // Verify hidden file is included (VULNERABILITY)
        assert!(files.iter().any(|f| f.contains(".malicious.meta")), 
                "Hidden file should be listed - this demonstrates the vulnerability");
        
        println!("Listed files: {:?}", files);
        println!("VULNERABILITY CONFIRMED: Hidden file .malicious.meta is included in listing");
    }
}
```

## Notes

This vulnerability represents a gap between API-level validation (`ShellSafeName`) and storage-level processing (`list_metadata_files`). While the API prevents creating hidden files through legitimate operations, the restore system trusts all files found in storage without validating their names match the expected pattern. This violates the principle of defense in depth and creates a stealth attack vector for adversaries with storage access.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L52-52)
```rust
    const PATTERN: &'static str = r"\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z";
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L111-123)
```rust
    async fn list_metadata_files(&self) -> Result<Vec<FileHandle>> {
        let dir = self.metadata_dir();
        let rel_path = Path::new(Self::METADATA_DIR);

        let mut res = Vec::new();
        if path_exists(&dir).await {
            let mut entries = read_dir(&dir).await.err_notes(&dir)?;
            while let Some(entry) = entries.next_entry().await.err_notes(&dir)? {
                res.push(rel_path.join(entry.file_name()).path_to_string()?)
            }
        }
        Ok(res)
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L126-138)
```rust
    async fn list_metadata_files(&self) -> Result<Vec<FileHandle>> {
        let child = self
            .cmd(&self.config.commands.list_metadata_files, vec![])
            .spawn()?;

        let mut buf = FileHandle::new();
        child
            .into_data_source()
            .read_to_string(&mut buf)
            .await
            .err_notes((file!(), line!(), &buf))?;
        Ok(buf.lines().map(str::to_string).collect())
    }
```

**File:** terraform/helm/fullnode/files/backup/gcs.yaml (L30-30)
```yaml
  list_metadata_files: '(gcloud storage ls gs://$BUCKET/$SUB_DIR/metadata/ ||:) | sed -ne "s#gs://.*/metadata/#metadata/#p"'
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L114-114)
```rust
    let mut remote_file_handles = storage.list_metadata_files().await?;
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L193-207)
```rust
    let mut metadata_vec = Vec::new();
    for h in new_remote_hashes.into_iter().chain(up_to_date_local_hashes) {
        let cached_file = cache_dir.join(h);
        metadata_vec.extend(
            OpenOptions::new()
                .read(true)
                .open(&cached_file)
                .await
                .err_notes(&cached_file)?
                .load_metadata_lines()
                .await
                .err_notes(&cached_file)?
                .into_iter(),
        )
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L211-218)
```rust
        let transaction_backups =
            metadata_view.select_transaction_backups(txn_start_version, target_version)?;
        let epoch_ending_backups = metadata_view.select_epoch_ending_backups(target_version)?;
        let epoch_handles = epoch_ending_backups
            .iter()
            .filter(|e| e.first_version <= target_version)
            .map(|backup| backup.manifest.clone())
            .collect();
```
