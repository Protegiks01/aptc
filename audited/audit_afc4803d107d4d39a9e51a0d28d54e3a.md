# Audit Report

## Title
Missing Economic Parameter Validation in Faucet Configuration Enables Unrestricted Fund Drainage

## Summary
The `validate_config()` function in the Aptos faucet only performs syntactic YAML parsing without semantic validation of economic parameters. This allows operators to deploy faucets with dangerously high `amount_to_fund` values (up to u64::MAX) and no `maximum_amount` cap, enabling any user to drain massive amounts per request once such a misconfigured faucet is deployed.

## Finding Description

The faucet configuration validation is critically incomplete. The `validate_config()` function only deserializes the YAML configuration without validating the economic parameters: [1](#0-0) 

This validation accepts any u64 value for `amount_to_fund` in both `MintFunderConfig` and `TransferFunderConfig`: [2](#0-1) [3](#0-2) 

The `TransactionSubmissionConfig` defines optional maximum amounts, but these are not required: [4](#0-3) 

When no `maximum_amount` is configured, the `get_amount()` function returns the full `amount_to_fund` without limits: [5](#0-4) 

At the Move framework level, the `aptos_coin::mint()` function accepts any u64 amount without validation: [6](#0-5) 

The framework even demonstrates minting u64::MAX in test configurations: [7](#0-6) 

**Attack Scenario:**
1. Operator deploys faucet with `amount_to_fund: 10_000_000_000_000_000` (10 million APT) and no `maximum_amount` set
2. validate_config() accepts this configuration (only checks YAML syntax)
3. Any user makes a fund request without specifying an amount
4. MintFunder mints 10 million APT per request, or TransferFunder drains faucet balance
5. Multiple requests cause massive economic damage or complete fund depletion

## Impact Explanation

**HIGH Severity** - This qualifies as "Limited funds loss or manipulation" under the Aptos bug bounty program.

For **MintFunder** on testnets/devnets:
- Each request can mint billions of OCTA (millions of APT)
- Multiple requests cause severe token inflation
- Destroys testnet economic testing environment
- Default value of 100 billion OCTA (100,000 APT) is already quite high

For **TransferFunder**:
- Single request can drain entire faucet balance if `amount_to_fund` set to u64::MAX
- Immediate service disruption
- Funds loss for the faucet operator

The vulnerability enables fund drainage/manipulation through a configuration weakness that bypasses intended economic controls.

## Likelihood Explanation

**HIGH Likelihood** due to:

1. **No validation guardrails**: validate_config() provides false confidence by logging "Config is valid" without checking parameter reasonableness
2. **Optional protections**: `maximum_amount` is Optional, not enforced
3. **Easy misconfiguration**: Operators may set high `amount_to_fund` for testing and forget to add `maximum_amount`
4. **Silent failure**: No warnings about missing economic limits
5. **Default example shows issue**: The CLI builder uses 100 billion OCTA as default with no maximum_amount in bypass scenarios [8](#0-7) 

Once deployed with such a configuration, ANY user can exploit it through normal faucet requests - no special privileges required.

## Recommendation

Add comprehensive economic parameter validation in `validate_config()`:

```rust
impl ValidateConfig {
    pub async fn validate_config(&self) -> Result<()> {
        let file = File::open(&self.config_path).with_context(|| {
            format!(
                "Failed to load config at {}",
                self.config_path.to_string_lossy()
            )
        })?;
        let reader = BufReader::new(file);
        let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
            format!(
                "Failed to parse config at {}",
                self.config_path.to_string_lossy()
            )
        })?;

        // Add semantic validation
        self.validate_economic_parameters(&run_config)?;

        info!("Config is valid: {:#?}", run_config);
        Ok(())
    }

    fn validate_economic_parameters(&self, config: &RunConfig) -> Result<()> {
        const MAX_REASONABLE_AMOUNT: u64 = 1_000_000_000_000_000; // 1M APT

        match &config.funder_config {
            FunderConfig::MintFunder(mint_config) => {
                if mint_config.amount_to_fund > MAX_REASONABLE_AMOUNT {
                    anyhow::bail!(
                        "amount_to_fund ({}) exceeds maximum reasonable value ({})",
                        mint_config.amount_to_fund,
                        MAX_REASONABLE_AMOUNT
                    );
                }
                
                // Ensure maximum_amount is set
                if mint_config.transaction_submission_config.maximum_amount.is_none() 
                    && mint_config.transaction_submission_config.maximum_amount_with_bypass.is_none() {
                    anyhow::bail!(
                        "At least one of maximum_amount or maximum_amount_with_bypass must be set"
                    );
                }

                // Ensure amount_to_fund doesn't exceed the caps
                if let Some(max) = mint_config.transaction_submission_config.maximum_amount {
                    if mint_config.amount_to_fund > max {
                        anyhow::bail!(
                            "amount_to_fund ({}) exceeds maximum_amount ({})",
                            mint_config.amount_to_fund,
                            max
                        );
                    }
                }
            },
            FunderConfig::TransferFunder(transfer_config) => {
                if transfer_config.amount_to_fund.0 > MAX_REASONABLE_AMOUNT {
                    anyhow::bail!(
                        "amount_to_fund ({}) exceeds maximum reasonable value ({})",
                        transfer_config.amount_to_fund.0,
                        MAX_REASONABLE_AMOUNT
                    );
                }
            },
            _ => {}
        }
        Ok(())
    }
}
```

## Proof of Concept

**Step 1:** Create a malicious configuration file `dangerous_config.yaml`:
```yaml
server_config:
  listen_address: "0.0.0.0"
  listen_port: 8081
  api_path_base: ""

metrics_server_config:
  disable: true
  listen_address: "0.0.0.0"
  listen_port: 9000

bypasser_configs: []
checker_configs: []

funder_config:
  type: mint_funder
  node_url: "http://127.0.0.1:8080/"
  chain_id: 4
  assets:
    apt:
      key_file_path: "/tmp/mint.key"
      do_not_delegate: false
  default_asset: "apt"
  amount_to_fund: 10000000000000000  # 10 million APT
  # Note: maximum_amount intentionally omitted

handler_config:
  use_helpful_errors: true
  return_rejections_early: false
  max_concurrent_requests: 10
```

**Step 2:** Run validation (incorrectly passes):
```bash
cargo run -p aptos-faucet -- validate-config -c dangerous_config.yaml
# Output: "Config is valid"
```

**Step 3:** Deploy and exploit:
```bash
# Start the faucet
cargo run -p aptos-faucet -- run -c dangerous_config.yaml

# Make a fund request (from another terminal)
curl -X POST http://localhost:8081/fund \
  -H "Content-Type: application/json" \
  -d '{"address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"}'

# Result: 10 million APT minted to the address
```

Each successful request mints 10,000,000 APT, causing massive economic damage to the testnet environment.

**Notes**

This vulnerability specifically affects the faucet component's configuration validation layer. While the faucet is primarily used in testnets and development environments, proper configuration validation is a critical security control that prevents operational mistakes from becoming exploitable vulnerabilities. The issue demonstrates a gap between syntactic validation (YAML parsing) and semantic validation (parameter reasonableness checking) that should be addressed to prevent fund drainage scenarios.

### Citations

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L17-35)
```rust
    pub async fn validate_config(&self) -> Result<()> {
        let file = File::open(&self.config_path).with_context(|| {
            format!(
                "Failed to load config at {}",
                self.config_path.to_string_lossy()
            )
        })?;
        let reader = BufReader::new(file);
        let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
            format!(
                "Failed to parse config at {}",
                self.config_path.to_string_lossy()
            )
        })?;

        info!("Config is valid: {:#?}", run_config);

        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L117-120)
```rust
    /// If not provided, defaults to 100_000_000_000.
    #[serde(default = "MintFunderConfig::get_default_amount_to_fund")]
    pub amount_to_fund: u64,
}
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L48-50)
```rust
    /// The amount of coins to fund the receiver account.
    pub amount_to_fund: AmountToFund,

```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L94-104)
```rust
pub struct TransactionSubmissionConfig {
    /// Maximum amount of OCTA to give an account.
    maximum_amount: Option<u64>,

    /// With this it is possible to set a different maximum amount for requests that
    /// were allowed to skip the Checkers by a Bypasser. This can be helpful for CI,
    /// where we might need to mint a greater amount than is normally required in the
    /// standard case. If not given, maximum_amount is used whether the request
    /// bypassed the checks or not.
    maximum_amount_with_bypass: Option<u64>,

```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L81-85)
```text
        let coins = coin::mint<AptosCoin>(
            18446744073709551615,
            &mint_cap,
        );
        coin::deposit<AptosCoin>(signer::address_of(core_resources), coins);
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L278-304)
```rust
            funder_config: FunderConfig::MintFunder(MintFunderConfig {
                api_connection_config: ApiConnectionConfig::new(
                    api_url,
                    None,
                    None,
                    chain_id.unwrap_or_else(ChainId::test),
                ),
                transaction_submission_config: TransactionSubmissionConfig::new(
                    None,    // maximum_amount
                    None,    // maximum_amount_with_bypass
                    30,      // gas_unit_price_ttl_secs
                    None,    // gas_unit_price_override
                    500_000, // max_gas_amount
                    30,      // transaction_expiration_secs
                    35,      // wait_for_outstanding_txns_secs
                    false,   // wait_for_transactions
                ),
                assets: HashMap::from([(
                    DEFAULT_ASSET_NAME.to_string(),
                    MintAssetConfig::new(
                        AssetConfig::new(_key, key_file_path),
                        Some(aptos_test_root_address()),
                        do_not_delegate,
                    ),
                )]),
                default_asset: MintFunderConfig::get_default_asset_name(),
                amount_to_fund: 100_000_000_000,
```
