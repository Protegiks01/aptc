# Audit Report

## Title
PII Leakage: Email Addresses Exposed in Prometheus Metrics and Application Logs

## Summary
Email addresses from the `x-aptos-email` HTTP header are leaked as Prometheus metric labels and in application logs, violating privacy regulations (GDPR, CCPA). The `/metrics` endpoint is publicly accessible without authentication, and logs are written via `tracing::info!`, exposing user email addresses to unauthorized parties.

## Finding Description
The indexer-grpc services extract email addresses from the `x-aptos-email` request header and include them in the `IndexerGrpcRequestMetadata` structure. [1](#0-0) 

This email address is then propagated through three primary leakage vectors:

**Vector 1: Prometheus Metrics Labels**

The `get_label_values()` method includes the email address in the returned vector: [2](#0-1) 

These label values are used in multiple Prometheus metrics:
- `CONNECTION_COUNT` [3](#0-2) 
- `BYTES_READY_TO_TRANSFER_FROM_SERVER` [4](#0-3) 
- `NUM_TRANSACTIONS_STRIPPED` [5](#0-4) 
- `BYTES_READY_TO_TRANSFER_FROM_SERVER_AFTER_STRIPPING` (used for billing) [6](#0-5) 

All these metrics include `"email"` as a label.

**Vector 2: Application Logs**

The `log_grpc_step()` function explicitly logs the email address: [7](#0-6) 

**Vector 3: Public Metrics Endpoint**

The `/metrics` HTTP endpoint exposes all Prometheus metrics without authentication, bound to `0.0.0.0`: [8](#0-7) 

The endpoint is accessible from all network interfaces: [9](#0-8) 

**Exploitation Path:**
1. User makes authenticated request to indexer-grpc service with `x-aptos-email` header
2. Email is extracted and stored in `IndexerGrpcRequestMetadata` [10](#0-9) 
3. Email is propagated to Prometheus metrics as a label value [11](#0-10) 
4. Email is logged via `tracing::info!` throughout request processing
5. Anyone can scrape the `/metrics` endpoint to retrieve all email addresses
6. Logs containing emails are persisted in centralized logging systems

## Impact Explanation
This is a **Medium severity** privacy violation issue:

- **Regulatory Violations**: Exposes PII (email addresses) in violation of GDPR Article 32 (security of processing), CCPA requirements, and other privacy regulations
- **Unauthorized Access**: Email addresses are accessible to anyone with network access to the metrics endpoint or log aggregation systems
- **Data Persistence**: Prometheus metrics and logs are typically retained for extended periods (weeks to months), creating long-term PII exposure
- **Compliance Risk**: Organizations operating these services face potential regulatory fines and enforcement actions
- **Monitoring Systems**: Third-party monitoring tools, alerting systems, and SRE teams gain unauthorized access to user emails

The issue does not directly affect blockchain consensus, execution, or funds, but represents a significant compliance and privacy risk qualifying as Medium severity per the security question categorization.

## Likelihood Explanation
**Likelihood: VERY HIGH**

- Occurs automatically for every authenticated request to indexer-grpc services
- No special conditions or race conditions required
- The `x-aptos-email` header is sent by the API Gateway for all authenticated requests
- Metrics endpoint is publicly accessible without authentication
- Affects all deployments of indexer-grpc-data-service (v1 and v2) and related services
- Continuous exposure as long as services are running

## Recommendation
**Remove email addresses from metrics labels and minimize logging:**

1. **Remove email from metrics labels:**
```rust
// In ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs
impl IndexerGrpcRequestMetadata {
    pub fn get_label_values(&self) -> Vec<&str> {
        vec![
            &self.request_identifier_type,
            &self.request_identifier,
            // REMOVED: &self.request_email,  // DO NOT include PII in metrics
            &self.request_application_name,
            &self.processor_name,
        ]
    }
    
    // Add separate method for non-PII identifiers only
    pub fn get_safe_label_values(&self) -> Vec<&str> {
        vec![
            &self.request_identifier_type,
            &self.request_identifier,
            &self.request_application_name,
            &self.processor_name,
        ]
    }
}
```

2. **Update all metric definitions to remove "email" label:**
```rust
// In ecosystem/indexer-grpc/indexer-grpc-data-service/src/metrics.rs
pub static CONNECTION_COUNT: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "indexer_grpc_data_service_connection_count_v2",
        "Count of connections that data service has established",
        &[
            "identifier_type",
            "identifier",
            // REMOVED: "email",
            "application_name",
            "processor"
        ],
    )
    .unwrap()
});
```

3. **Remove email from structured logging:**
```rust
// In ecosystem/indexer-grpc/indexer-grpc-utils/src/counters.rs
if let Some(request_metadata) = request_metadata {
    tracing::info!(
        start_version,
        end_version,
        // ... other fields ...
        processor_name = &request_metadata.processor_name,
        request_identifier_type = &request_metadata.request_identifier_type,
        request_identifier = &request_metadata.request_identifier,
        // REMOVED: request_email = &request_metadata.request_email,
        request_application_name = &request_metadata.request_application_name,
        connection_id = &request_metadata.request_connection_id,
        // ... rest of fields ...
    );
}
```

4. **If email is needed for internal analytics, hash it first:**
```rust
use sha2::{Sha256, Digest};

pub fn hash_email(email: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(email.as_bytes());
    format!("{:x}", hasher.finalize())
}
```

## Proof of Concept

**Step 1: Deploy indexer-grpc-data-service**
```bash
# Start the service with default configuration
cargo run --bin aptos-indexer-grpc-data-service -- --config-path config.yaml
```

**Step 2: Make authenticated request with email header**
```rust
// Client code
use tonic::metadata::MetadataValue;
use tonic::Request;

let mut request = Request::new(GetTransactionsRequest {
    starting_version: Some(1000),
    transactions_count: Some(10),
});

// API Gateway adds this header
request.metadata_mut().insert(
    "x-aptos-email",
    MetadataValue::from_str("user@example.com").unwrap(),
);
request.metadata_mut().insert(
    "x-aptos-identifier",
    MetadataValue::from_str("app-uuid-1234").unwrap(),
);

// Make request...
let response = client.get_transactions(request).await;
```

**Step 3: Scrape metrics endpoint**
```bash
# Metrics endpoint is publicly accessible
curl http://localhost:8084/metrics | grep user@example.com

# Expected output showing PII leakage:
# indexer_grpc_data_service_connection_count_v2{identifier_type="application",identifier="app-uuid-1234",email="user@example.com",application_name="MyApp",processor="default"} 1
# indexer_grpc_data_service_bytes_ready_to_transfer_from_server{identifier_type="application",identifier="app-uuid-1234",email="user@example.com",application_name="MyApp",processor="default"} 15360
```

**Step 4: Check logs**
```bash
# Email appears in structured logs
tail -f logs/indexer.log | grep user@example.com

# Expected output:
# {"level":"info","request_email":"user@example.com","request_identifier":"app-uuid-1234",...}
```

This demonstrates that email addresses are exposed through both metrics and logs, accessible without authentication.

**Notes:**

1. This vulnerability affects the **indexer-grpc ecosystem** specifically, not the core blockchain consensus, execution, or state management layers. It is an infrastructure/API privacy issue.

2. The email header originates from the **API Gateway** [12](#0-11)  and is intended for internal tracking, not public exposure.

3. Multiple services are affected: `indexer-grpc-data-service`, `indexer-grpc-data-service-v2` (both historical and live variants), and any service using the `log_grpc_step` utility function.

4. The struct also derives `Debug` [13](#0-12) , which could expose email in panic messages or error contexts if the struct is printed using debug formatting.

5. While this doesn't compromise blockchain security directly, it represents a significant operational security and compliance risk for organizations running Aptos infrastructure.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L23-24)
```rust
// These come from API Gateway, see here:
// https://github.com/aptos-labs/api-gateway/blob/0aae1c17fbd0f5e9b50bdb416f62b48d3d1d5e6b/src/common.rs
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L36-36)
```rust
pub const REQUEST_HEADER_APTOS_EMAIL: &str = "x-aptos-email";
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L40-40)
```rust
#[derive(Clone, Serialize, Deserialize, Debug)]
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L60-68)
```rust
    pub fn get_label_values(&self) -> Vec<&str> {
        vec![
            &self.request_identifier_type,
            &self.request_identifier,
            &self.request_email,
            &self.request_application_name,
            &self.processor_name,
        ]
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L72-106)
```rust
pub fn get_request_metadata(req: &Request<GetTransactionsRequest>) -> IndexerGrpcRequestMetadata {
    let request_metadata_pairs = vec![
        (
            "request_identifier_type",
            REQUEST_HEADER_APTOS_IDENTIFIER_TYPE,
        ),
        ("request_identifier", REQUEST_HEADER_APTOS_IDENTIFIER),
        ("request_email", REQUEST_HEADER_APTOS_EMAIL),
        (
            "request_application_name",
            REQUEST_HEADER_APTOS_APPLICATION_NAME,
        ),
        ("request_token", GRPC_AUTH_TOKEN_HEADER),
        ("processor_name", GRPC_REQUEST_NAME_HEADER),
    ];
    let mut request_metadata_map: HashMap<String, String> = request_metadata_pairs
        .into_iter()
        .map(|(key, value)| {
            (
                key.to_string(),
                req.metadata()
                    .get(value)
                    .map(|value| value.to_str().unwrap_or("unspecified").to_string())
                    .unwrap_or("unspecified".to_string()),
            )
        })
        .collect();
    request_metadata_map.insert(
        "request_connection_id".to_string(),
        Uuid::new_v4().to_string(),
    );

    // TODO: update the request name if these are internal requests.
    serde_json::from_str(&serde_json::to_string(&request_metadata_map).unwrap()).unwrap()
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/metrics.rs (L72-85)
```rust
pub static CONNECTION_COUNT: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "indexer_grpc_data_service_connection_count_v2",
        "Count of connections that data service has established",
        &[
            "identifier_type",
            "identifier",
            "email",
            "application_name",
            "processor"
        ],
    )
    .unwrap()
});
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/metrics.rs (L110-123)
```rust
pub static BYTES_READY_TO_TRANSFER_FROM_SERVER: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "indexer_grpc_data_service_bytes_ready_to_transfer_from_server",
        "Count of bytes ready to transfer to the client (pre stripping)",
        &[
            "identifier_type",
            "identifier",
            "email",
            "application_name",
            "processor"
        ],
    )
    .unwrap()
});
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/metrics.rs (L128-141)
```rust
pub static NUM_TRANSACTIONS_STRIPPED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "indexer_grpc_data_service_num_transactions_stripped",
        "Number of transactions that had data (such as events, writesets, payload, signature) stripped from them",
        &[
            "identifier_type",
            "identifier",
            "email",
            "application_name",
            "processor"
        ],
    )
    .unwrap()
});
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/counters.rs (L227-241)
```rust
pub static BYTES_READY_TO_TRANSFER_FROM_SERVER_AFTER_STRIPPING: Lazy<IntCounterVec> =
    Lazy::new(|| {
        register_int_counter_vec!(
            "indexer_grpc_data_service_bytes_ready_to_transfer_from_server_after_stripping",
            "Count of bytes ready to transfer to the client (post stripping)",
            &[
                "identifier_type",
                "identifier",
                "email",
                "application_name",
                "processor"
            ],
        )
        .unwrap()
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/counters.rs (L287-306)
```rust
        tracing::info!(
            start_version,
            end_version,
            start_txn_timestamp_iso,
            end_txn_timestamp_iso,
            num_transactions,
            duration_in_secs,
            size_in_bytes,
            // Request metadata variables
            processor_name = &request_metadata.processor_name,
            request_identifier_type = &request_metadata.request_identifier_type,
            request_identifier = &request_metadata.request_identifier,
            request_email = &request_metadata.request_email,
            request_application_name = &request_metadata.request_application_name,
            connection_id = &request_metadata.request_connection_id,
            service_type,
            step = step.get_step(),
            "{}",
            step.get_label(),
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L203-217)
```rust
    let metrics_endpoint = warp::path("metrics").map(|| {
        // Metrics encoding.
        let metrics = aptos_metrics_core::gather();
        let mut encode_buffer = vec![];
        let encoder = TextEncoder::new();
        // If metrics encoding fails, we want to panic and crash the process.
        encoder
            .encode(&metrics, &mut encode_buffer)
            .context("Failed to encode metrics")
            .unwrap();

        Response::builder()
            .header("Content-Type", "text/plain")
            .body(encode_buffer)
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L257-257)
```rust
        .run(([0, 0, 0, 0], port))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L151-153)
```rust
        CONNECTION_COUNT
            .with_label_values(&request_metadata.get_label_values())
            .inc();
```
