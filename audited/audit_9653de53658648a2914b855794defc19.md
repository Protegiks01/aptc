# Audit Report

## Title
Integer Underflow in Transaction Restore Causing Database Corruption with Invalid Version Numbers

## Summary
The `save_transactions()` function in the restore utilities contains an integer underflow vulnerability when processing empty transaction arrays, resulting in database corruption with an invalid version number of `u64::MAX`.

## Finding Description

The vulnerability exists in the `save_transactions()` function where the last version is calculated without validating that the transaction array is non-empty. [1](#0-0) 

When `txns` is empty (length 0) and `first_version` is 0, the arithmetic `0 + 0 - 1` causes unsigned integer underflow. In Rust's release mode (used in production), this wraps around to `u64::MAX`.

This incorrect `last_version` value is then used to commit to the state KV database: [2](#0-1) 

And to set critical database metadata for ledger commit progress: [3](#0-2) 

The same vulnerable calculation exists in `save_transactions_impl()`: [4](#0-3) 

**Attack Vectors:**

The vulnerability can be triggered through multiple code paths that bypass input validation:

1. **RestoreHandler calls** - used during backup restore operations: [5](#0-4) 

2. **RestoreHandler KV replay** - used during state sync: [6](#0-5) 

3. **Backup-CLI restore logic** - edge cases in transaction filtering can create empty arrays through drain operations: [7](#0-6) 

The drain operations at lines 477-481, 489-493, and 501-506 can result in empty transaction arrays being passed to `save_transactions`.

Note that while the main transaction commit path has validation to prevent empty chunks: [8](#0-7) 

This validation is **not present** in the restore utility functions, creating an exploitable gap.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program:

1. **State Inconsistency**: The database becomes corrupted with version `u64::MAX` for `LedgerCommitProgress` and `OverallCommitProgress`, breaking the State Consistency invariant.

2. **Loss of Availability**: The affected node cannot participate in consensus or state sync because:
   - Version queries return invalid results (u64::MAX)
   - The node believes it has committed up to version `u64::MAX`
   - State synchronization with other nodes fails due to version mismatch
   - The ledger state becomes unverifiable

3. **Requires Manual Intervention**: Recovery requires database restoration from a clean backup or re-syncing from genesis, causing extended downtime for the affected node.

4. **Protocol Violation**: Breaks the fundamental invariant that version numbers must be monotonically increasing and bounded by actual transaction counts.

While this does not affect the entire network (not CRITICAL), it causes significant operational issues for individual nodes during restore operations, qualifying as HIGH severity under "API Crashes" or "Validator Node" availability issues.

## Likelihood Explanation

**Medium-to-High Likelihood:**

1. **Operational Triggers**: 
   - Backup restore operations are routine for node operators
   - State snapshot finalization occurs during state sync
   - Edge cases in backup file processing (filtering based on version ranges) can create empty transaction sets

2. **Missing Input Validation**: The restore utilities lack defensive checks that exist in other code paths, as evidenced by the comparison between the normal commit path and restore path validations.

3. **Production Environment**: Release builds use wrapping arithmetic (not panicking), so the bug silently corrupts data rather than failing fast.

The codebase coding standards explicitly recommend using checked arithmetic to prevent such issues: [9](#0-8) 

However, the restore utilities use direct subtraction operators instead of checked arithmetic.

## Recommendation

Add validation to ensure transaction arrays are non-empty before performing the version calculation in `save_transactions()` and `save_transactions_impl()`:

```rust
// In save_transactions() before line 166:
ensure!(!txns.is_empty(), "Cannot save empty transaction set");

// In save_transactions_impl() before line 279:
ensure!(!txns.is_empty(), "Cannot save empty transaction set");
```

Alternatively, use checked arithmetic:

```rust
let last_version = first_version
    .checked_add(txns.len() as u64)
    .and_then(|v| v.checked_sub(1))
    .ok_or_else(|| anyhow!("Invalid version calculation"))?;
```

## Proof of Concept

The vulnerability can be triggered by:

1. Creating a backup with transactions in a specific version range
2. Attempting to restore with filtering that removes all transactions from a chunk
3. The empty transaction array reaches `save_transactions()` without validation
4. Database corruption occurs with `u64::MAX` version

A concrete scenario:
- Chunk with transactions 100-200
- Set `target_version = 150` and `global_first_version = 250`
- After draining operations in `backup_types/transaction/restore.rs`, all transactions are removed
- Empty arrays are passed to `restore_handler.save_transactions()` with `first_version = 0`
- Calculation `0 + 0 - 1` wraps to `u64::MAX`
- Database metadata corrupted with invalid version number

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L166-166)
```rust
        let last_version = first_version + txns.len() as u64 - 1;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L167-170)
```rust
        state_store
            .state_db
            .state_kv_db
            .commit(last_version, None, sharded_kv_schema_batch)?;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L279-279)
```rust
    let last_version = first_version + txns.len() as u64 - 1;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L280-291)
```rust
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L78-99)
```rust
    pub fn save_transactions(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            false,
        )
    }
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L105-126)
```rust
    pub fn save_transactions_and_replay_kv(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            true,
        )
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L474-527)
```rust
                    // remove the txns that exceeds the target_version to be restored
                    if target_version < last_version {
                        let num_to_keep = (target_version - first_version + 1) as usize;
                        txns.drain(num_to_keep..);
                        persisted_aux_info.drain(num_to_keep..);
                        txn_infos.drain(num_to_keep..);
                        event_vecs.drain(num_to_keep..);
                        write_sets.drain(num_to_keep..);
                        last_version = target_version;
                    }

                    // remove the txns that are before the global_first_version
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
                    }

                    // identify txns to be saved before the first_to_replay version
                    if first_version < first_to_replay {
                        let num_to_save =
                            (min(first_to_replay, last_version + 1) - first_version) as usize;
                        let txns_to_save: Vec<_> = txns.drain(..num_to_save).collect();
                        let persisted_aux_info_to_save: Vec<_> =
                            persisted_aux_info.drain(..num_to_save).collect();
                        let txn_infos_to_save: Vec<_> = txn_infos.drain(..num_to_save).collect();
                        let event_vecs_to_save: Vec<_> = event_vecs.drain(..num_to_save).collect();
                        let write_sets_to_save = write_sets.drain(..num_to_save).collect();
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
                        let last_saved = first_version + num_to_save as u64 - 1;
                        TRANSACTION_SAVE_VERSION.set(last_saved as i64);
                        info!(
                            version = last_saved,
                            accumulative_tps = ((last_saved - global_first_version + 1) as f64
                                / start.elapsed().as_secs_f64())
                                as u64,
                            "Transactions saved."
                        );
                    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L248-248)
```rust
        ensure!(!chunk.is_empty(), "chunk is empty, nothing to save.");
```

**File:** RUST_CODING_STYLE.md (L220-231)
```markdown
### Integer Arithmetic

As every integer operation (`+`, `-`, `/`, `*`, etc.) implies edge-cases (e.g. overflow `u64::MAX + 1`, underflow `0u64 -1`, division by zero, etc.),
we use checked arithmetic instead of directly using math symbols.
It forces us to think of edge-cases, and handle them explicitly.
This is a brief and simplified mini guide of the different functions that exist to handle integer arithmetic:

- [checked\_](https://doc.rust-lang.org/std/primitive.u32.html#method.checked_add): use this function if you want to handle overflow and underflow as a special edge-case. It returns `None` if an underflow or overflow has happened, and `Some(operation_result)` otherwise.
- [overflowing\_](https://doc.rust-lang.org/std/primitive.u32.html#method.overflowing_add): use this function if you want the result of an overflow to potentially wrap around (e.g. `u64::MAX.overflow_add(10) == (9, true)`). It returns the underflowed or overflowed result as well as a flag indicating if an overflow has occurred or not.
- [wrapping\_](https://doc.rust-lang.org/std/primitive.u32.html#method.wrapping_add): this is similar to overflowing operations, except that it returns the result directly. Use this function if you are sure that you want to handle underflow and overflow by wrapping around.
- [saturating\_](https://doc.rust-lang.org/std/primitive.u32.html#method.saturating_add): if an overflow occurs, the result is kept within the boundary of the type (e.g. `u64::MAX.saturating_add(1) == u64::MAX`).

```
