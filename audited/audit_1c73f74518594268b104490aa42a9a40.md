# Audit Report

## Title
Critical Liveness Failure: Consensus Observer Drops All Blocks When Execution Pool is Enabled

## Summary
The consensus observer implementation has an incomplete execution pool feature that causes all blocks to be dropped when execution pool is enabled, leading to a complete loss of liveness for consensus observer nodes. When subsequently disabled, the OrderedBlockStore would be empty (not containing OrderedWithWindow blocks as the question assumes), causing a synchronization gap.

## Finding Description
The security question assumes that `OrderedBlockStore` would contain `OrderedWithWindow` blocks after execution pool is enabled, but the implementation reveals a more severe issue: **OrderedWithWindow blocks are never processed or stored at all**. [1](#0-0) 

When execution pool is enabled (`execution_pool_window_size` is `Some(size)`):

1. **Ordered messages are rejected:** [2](#0-1) 

2. **OrderedWithWindow messages are accepted but immediately dropped** without processing: [3](#0-2) 

The execution pool window size is determined from on-chain consensus config: [4](#0-3) 

**Attack Scenario:**
1. Governance enables execution pool feature (sets window_size in consensus config)
2. All consensus observer nodes receive this config change at epoch boundary
3. Publishers start sending `OrderedBlockWithWindow` messages
4. Observers validate and accept these messages but drop them (line 895 TODO)
5. All consensus observer nodes stop processing blocks entirely
6. If execution pool is later disabled:
   - `OrderedBlockStore` is EMPTY (blocks were dropped, not stored)
   - New `Ordered` messages are accepted and processed
   - **Critical gap exists:** All blocks from the enabled period are missing
7. Observers must enter fallback mode to sync via state sync

## Impact Explanation
This meets **High Severity** criteria per Aptos bug bounty:
- **API crashes**: Consensus observers power API nodes, which would fail to serve requests
- **Significant protocol violations**: Complete liveness failure breaks the consensus observer protocol
- **Network availability**: All fullnodes running consensus observer would stop synchronizing

While validators are unaffected (they use different code paths), this would cause:
- Total loss of API node availability
- Fullnode synchronization failures
- Service disruptions for applications relying on observers
- Potential data availability issues for indexers and analytics services

The question's premise about "execution dependency mismatches" is actually understatedâ€”the real issue is that NO blocks are processed at all when execution pool is enabled.

## Likelihood Explanation
**Likelihood: Medium-High during rollout**

While this requires governance to enable the execution pool feature, the likelihood increases because:
1. The feature appears designed for future use (infrastructure exists)
2. A gradual rollout could accidentally enable it
3. Testing in production-like environments would trigger it
4. The TODO comment suggests this is incomplete work that might be finished, inadvertently activating the bug
5. No runtime checks prevent enabling an incomplete feature

However, it requires **privileged governance access** to trigger, which technically disqualifies this from being an "unprivileged attacker" vulnerability per the validation checklist.

## Recommendation
**Immediate Fix:** Add runtime validation to prevent enabling execution pool while the feature is incomplete:

```rust
// In epoch_state.rs, after line 101:
if let Some(window_size) = consensus_config.window_size() {
    error!(
        LogSchema::new(LogEntry::ConsensusObserver).message(
            "Execution pool is not yet fully implemented! Ignoring window_size config."
        )
    );
    self.execution_pool_window_size = None;
} else {
    self.execution_pool_window_size = None;
}
```

**Complete Fix:** Implement the TODO at line 895 to properly process `OrderedBlockWithWindow` messages:
- Store as `ObservedOrderedBlock::OrderedWithWindow` in `OrderedBlockStore`
- Extract and utilize execution pool window information during finalization
- Ensure execution dependencies are correctly tracked using the window data

Alternatively, if the feature is not ready for production, add a feature gate that explicitly fails if execution pool is enabled before implementation is complete.

## Proof of Concept

Since this requires governance control, a full PoC cannot be provided without privileged access. However, the vulnerability can be demonstrated through code analysis:

**Verification Steps:**
1. Set `execution_pool_window_size = Some(10)` in consensus config via governance
2. Send `OrderedBlockWithWindow` message to consensus observer
3. Observe message passes validation (lines 832-867)
4. Observe message is dropped at line 895 (TODO)
5. Verify `OrderedBlockStore` remains empty
6. Confirm no blocks are processed while feature is enabled

**Expected Impact:**
- Consensus observer stops advancing `last_ordered_block`
- Fallback manager eventually triggers state sync
- API requests fail due to stale state

---

**Note:** This vulnerability **fails the validation checklist** requirement that it must be "exploitable by unprivileged attacker." It requires governance access to enable the execution pool feature. While this is a critical implementation bug that should be fixed before the feature is enabled, it does not meet the strict criteria for a security vulnerability report under the Aptos bug bounty program guidelines.

**Final Assessment:** This is a **critical bug in incomplete feature** rather than an **exploitable vulnerability**.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L645-656)
```rust
        // If execution pool is enabled, ignore the message
        if self.get_execution_pool_window_size().is_some() {
            // Log the failure and update the invalid message counter
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block message from peer: {:?}, but execution pool is enabled! Ignoring: {:?}",
                    peer_network_id, ordered_block.proof_block_info()
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L810-896)
```rust
        // If execution pool is disabled, ignore the message
        let execution_pool_window_size = match self.get_execution_pool_window_size() {
            Some(window_size) => window_size,
            None => {
                // Log the failure and update the invalid message counter
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Received ordered block with window message from peer: {:?}, but execution pool is disabled! Ignoring: {:?}",
                        peer_network_id,
                        ordered_block_with_window.ordered_block().proof_block_info()
                    ))
                );
                increment_invalid_message_counter(
                    &peer_network_id,
                    metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
                );
                return;
            },
        };

        // Verify the ordered blocks before processing
        let ordered_block = ordered_block_with_window.ordered_block();
        if let Err(error) = ordered_block.verify_ordered_blocks() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify ordered block with window! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };

        // Verify the execution pool window contents
        let execution_pool_window = ordered_block_with_window.execution_pool_window();
        if let Err(error) = execution_pool_window.verify_window_contents(execution_pool_window_size)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify execution pool window contents! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };

        // Get the epoch and round of the first block
        let first_block = ordered_block.first_block();
        let first_block_epoch_round = (first_block.epoch(), first_block.round());

        // Determine if the block is behind the last ordered block, or if it is already pending
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
        let block_pending = self
            .observer_block_data
            .lock()
            .existing_pending_block(ordered_block);

        // If the block is out of date or already pending, ignore it
        if block_out_of_date || block_pending {
            // Update the metrics for the dropped ordered block with window
            update_metrics_for_dropped_ordered_block_with_window_message(
                peer_network_id,
                ordered_block,
            );
            return;
        }

        // Update the metrics for the received ordered block with window
        update_metrics_for_ordered_block_with_window_message(peer_network_id, ordered_block);

        // TODO: process the ordered block with window message (instead of just dropping it!)
    }
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L101-101)
```rust
        self.execution_pool_window_size = consensus_config.window_size();
```
