# Audit Report

## Title
Source Map and Source Code Manipulation Bypasses Package Verification

## Summary
Attackers can publish Move packages with mismatched bytecode and source code/source maps, completely bypassing the package verification system. The on-chain bytecode executes malicious logic while stored source code appears benign, deceiving auditors and users.

## Finding Description

The Aptos package publishing and verification system has a critical flaw: there is no cryptographic or structural binding between published bytecode and the source code/source maps stored in `PackageMetadata`.

**Publishing Flow Vulnerability:**

When publishing via `publish_package_txn`, two separate parameters are passed: `metadata_serialized` containing `PackageMetadata` (with source/source_map fields) and `code` containing actual bytecode modules. [1](#0-0) 

The `ModuleMetadata` structure stores source code and source maps as compressed byte arrays, but these are never validated against the bytecode. [2](#0-1) 

The `publish_package` function stores `PackageMetadata` directly into `PackageRegistry` without validation, then calls `request_publish` with only module names and bytecode - never checking if source_map or source correspond to the bytecode. [3](#0-2) 

The VM's `validate_publish_request` validates bytecode structure, dependencies, module names, native functions, resource groups, and events - but does NOT receive or validate source maps at all. [4](#0-3) 

**Verification Gap:**

The `VerifyPackage` command documentation claims it "verifies the bytecode matches a local compilation of the Move code": [5](#0-4) 

However, the implementation passes `false` for `with_bytecode`, meaning it never downloads the actual on-chain bytecode to compare: [6](#0-5) 

The `verify()` method only compares metadata fields (name, deps, modules, manifest, source_digest, etc.) but never compares actual bytecode that executes on-chain: [7](#0-6) 

**Attack Scenario:**

1. Attacker writes `benign.move` (safe code) and `malicious.move` (steals funds), both defining `module 0xAttacker::Token`
2. Compiles both to get `benign.mv` + metadata and `malicious.mv`
3. Publishes with `PackageMetadata` containing source/source_map from benign compilation, but `code=[malicious.mv]`
4. Auditors download metadata, see benign source, compile locally, verify metadata matches - verification passes
5. Users execute transactions - malicious.mv executes, funds stolen

Regular signers can publish code because master signers (non-permissioned signers) have all permissions by default: [8](#0-7) 

## Impact Explanation

**HIGH Severity** - This constitutes a significant protocol violation per the bug bounty criteria:

- **Audit Bypass**: Auditors reviewing on-chain packages are deceived into approving malicious code as safe
- **User Trust Violation**: The verification system's fundamental guarantee ("what you review is what executes") is broken
- **Fund Loss Potential**: Malicious bytecode can steal funds while appearing legitimate to all verification tools
- **Ecosystem-Wide Impact**: All packages relying on the verification system are vulnerable to this attack

This meets HIGH severity criteria for significant protocol violations that can lead to fund loss.

## Likelihood Explanation

**HIGH Likelihood**:
- Requires no special privileges - any account can publish code (master signers have all permissions)
- Attack is straightforward - compile twice, mix bytecode with benign metadata
- No consensus manipulation or validator collusion required
- The verification tool is widely trusted by the ecosystem
- Attack is completely undetectable to standard audit workflows since VerifyPackage passes without downloading bytecode

## Recommendation

1. **Fix VerifyPackage**: Change line 2064 to pass `true` for `with_bytecode`:
   ```rust
   let registry = CachedPackageRegistry::create(url, self.account, true).await?;
   ```

2. **Add bytecode comparison**: Extend the `verify()` method to compare actual on-chain bytecode with locally compiled bytecode, not just metadata.

3. **Cryptographic binding**: Consider adding a hash of the bytecode to `PackageMetadata` and validating it during publishing in `validate_publish_request`.

4. **Source map validation**: Optionally validate that source maps correspond to bytecode structure during publishing.

## Proof of Concept

```move
// benign.move
module 0xAttacker::Token {
    public fun transfer(amount: u64) {
        // Safe implementation
    }
}

// malicious.move  
module 0xAttacker::Token {
    public fun transfer(amount: u64) {
        // Steal funds implementation
    }
}
```

Compile both, then publish with:
- `metadata_serialized` = BCS-serialized PackageMetadata from benign compilation
- `code` = [malicious.mv bytecode]

Run `aptos move verify-package` - it passes without detecting the mismatch.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L58-67)
```text
    struct ModuleMetadata has copy, drop, store {
        /// Name of the module.
        name: String,
        /// Source text, gzipped String. Empty if not provided.
        source: vector<u8>,
        /// Source map, in compressed BCS. Empty if not provided.
        source_map: vector<u8>,
        /// For future extensions.
        extension: Option<Any>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1739)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/mod.rs (L2021-2023)
```rust
/// Downloads a package and verifies the bytecode
///
/// Downloads the package from onchain and verifies the bytecode matches a local compilation of the Move code
```

**File:** crates/aptos/src/move_tool/mod.rs (L2064-2064)
```rust
        let registry = CachedPackageRegistry::create(url, self.account, false).await?;
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L195-243)
```rust
    pub fn verify(&self, package_metadata: &PackageMetadata) -> anyhow::Result<()> {
        let self_metadata = self.metadata;

        if self_metadata.name != package_metadata.name {
            bail!(
                "Package name doesn't match {} : {}",
                package_metadata.name,
                self_metadata.name
            )
        } else if self_metadata.deps != package_metadata.deps {
            bail!(
                "Dependencies don't match {:?} : {:?}",
                package_metadata.deps,
                self_metadata.deps
            )
        } else if self_metadata.modules != package_metadata.modules {
            bail!(
                "Modules don't match {:?} : {:?}",
                package_metadata.modules,
                self_metadata.modules
            )
        } else if self_metadata.manifest != package_metadata.manifest {
            bail!(
                "Manifest doesn't match {:?} : {:?}",
                package_metadata.manifest,
                self_metadata.manifest
            )
        } else if self_metadata.upgrade_policy != package_metadata.upgrade_policy {
            bail!(
                "Upgrade policy doesn't match {:?} : {:?}",
                package_metadata.upgrade_policy,
                self_metadata.upgrade_policy
            )
        } else if self_metadata.extension != package_metadata.extension {
            bail!(
                "Extensions doesn't match {:?} : {:?}",
                package_metadata.extension,
                self_metadata.extension
            )
        } else if self_metadata.source_digest != package_metadata.source_digest {
            bail!(
                "Source digests doesn't match {:?} : {:?}",
                package_metadata.source_digest,
                self_metadata.source_digest
            )
        }

        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/permissioned_signer.move (L561-564)
```text
        if (!is_permissioned_signer(s)) {
            // master signer has all permissions
            return true
        };
```
