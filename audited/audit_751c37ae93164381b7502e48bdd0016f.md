# Audit Report

## Title
Missing Signature Verification for System Transactions in Archive Replay Tool

## Summary
The `SignatureVerifiedTransaction::from()` conversion in the replay-on-archive tool does not verify signatures or cryptographic proofs for system transactions (BlockMetadata, GenesisTransaction, ValidatorTransaction, etc.), blindly marking them as `Valid`. This allows compromised archive databases to inject malicious system transactions that bypass verification during replay.

## Finding Description

The replay tool at `storage/db-tool/src/replay_on_archive.rs` re-executes transactions from archived data to verify consistency. At line 366, transactions are converted using `SignatureVerifiedTransaction::from()`: [1](#0-0) 

The `from()` implementation only verifies signatures for `UserTransaction` types, while blindly marking ALL other transaction types as `Valid`: [2](#0-1) 

This means that system transactions read from the archive bypass all cryptographic verification:

- **BlockMetadata**: No verification of epoch/round/proposer validity [3](#0-2) 

- **ValidatorTransaction**: Has a `verify()` method that checks DKG results against validator signatures, but it's NEVER called during conversion: [4](#0-3) 

- **GenesisTransaction**: Can write arbitrary state via WriteSet without verification [5](#0-4) 

**Attack Scenario:**
1. Attacker compromises an archive database (e.g., during backup/restore operations)
2. Attacker injects malicious system transactions:
   - Fake `ValidatorTransaction` with invalid DKG results
   - Malicious `GenesisTransaction` with arbitrary WriteSet to manipulate state
   - Fake `BlockMetadata` with manipulated epoch/timestamp/proposer data
3. When operators replay the archive to verify integrity, all malicious transactions are marked as `Valid` without verification
4. The tool executes these transactions and compares results against tampered expected values from the same compromised archive
5. Verification passes, certifying the compromised archive as legitimate

**Broken Invariant:** Transaction Validation (Invariant #7) - All transactions must undergo appropriate verification before execution, but system transactions from archives bypass cryptographic checks.

## Impact Explanation

**Severity: Medium**

This vulnerability enables archive tampering that could lead to:

1. **State Inconsistencies**: If compromised archives are used for node bootstrapping or state sync, nodes could diverge with manipulated historical state
2. **False Verification**: Operators using this tool to validate archives before distribution would incorrectly certify compromised data
3. **Trust Exploitation**: If multiple nodes replay different tampered archives, they could end up with inconsistent historical states

While this doesn't directly break active consensus (the tool is diagnostic, not part of the consensus path), it violates state consistency guarantees when historical data is trusted. The impact is limited because:
- Requires local database access (not remote exploitation)
- The tool doesn't commit replayed state to production databases
- Active consensus has separate verification via quorum certificates
- State sync mechanisms have additional LedgerInfo signature verification

However, in backup/restore scenarios where this tool validates archives before use, accepting compromised data could cause state inconsistencies requiring manual intervention.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Access to modify archived database files (insider threat or compromised backup infrastructure)
- Comprehensive tampering of both transactions AND expected verification results
- Operators relying on this tool as the sole verification mechanism for archives

While requiring privileged access to storage systems, backup infrastructure is a known target for sophisticated attackers. Organizations often use such verification tools before restoring from backups or distributing snapshot data to new nodes.

## Recommendation

Add cryptographic verification for system transactions during archive replay:

```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            Transaction::ValidatorTransaction(vt) => {
                // Require validator verifier to be passed in for proper verification
                // For now, mark as Invalid to prevent blind acceptance
                SignatureVerifiedTransaction::Invalid(Transaction::ValidatorTransaction(vt))
            },
            // For other system transactions, verify they come from trusted sources
            // or were part of verified consensus blocks
            _ => {
                // In replay context, system transactions should be verified against
                // LedgerInfo signatures and transaction accumulator proofs
                SignatureVerifiedTransaction::Valid(txn)
            }
        }
    }
}
```

Better solution: Modify the replay tool to verify transactions against cryptographic proofs: [6](#0-5) 

The `get_transaction_range_proof()` method provides accumulator proofs and LedgerInfo signatures. The replay tool should verify each transaction batch against these proofs before accepting them as valid.

## Proof of Concept

```rust
// PoC: Compromised archive with fake ValidatorTransaction
// File: storage/db-tool/src/replay_on_archive_exploit_test.rs

#[test]
fn test_malicious_validator_transaction_bypass() {
    use aptos_types::validator_txn::{ValidatorTransaction, DKGTranscript};
    use aptos_types::transaction::Transaction;
    use aptos_types::transaction::signature_verified_transaction::SignatureVerifiedTransaction;
    
    // Create a malicious ValidatorTransaction with invalid DKG data
    let malicious_dkg = DKGTranscript {
        metadata: DKGTranscriptMetadata {
            epoch: 999,
            author: AccountAddress::ZERO,
        },
        transcript_bytes: vec![0xDE, 0xAD, 0xBE, 0xEF], // Invalid DKG data
    };
    
    let malicious_txn = Transaction::ValidatorTransaction(
        ValidatorTransaction::DKGResult(malicious_dkg)
    );
    
    // Convert using from() - this should verify but doesn't
    let verified_txn = SignatureVerifiedTransaction::from(malicious_txn.clone());
    
    // BUG: Malicious transaction is marked as Valid without verification
    assert!(verified_txn.is_valid()); // This passes!
    
    // The ValidatorTransaction has a verify() method that would catch this
    if let Transaction::ValidatorTransaction(vt) = malicious_txn {
        let verifier = create_test_validator_verifier();
        // This would fail if called
        assert!(vt.verify(&verifier).is_err());
    }
    
    // But in the replay path, verify() is never called
    // So the malicious transaction executes without verification
}
```

**Notes:**

The vulnerability is real but limited in scope. The `SignatureVerifiedTransaction::from()` method assumes system transactions are inherently trustworthy, which holds during normal consensus but fails when reading from potentially compromised archives. While `ValidatorTransaction` has explicit verification logic, it's bypassed during conversion. The replay tool should validate transactions against cryptographic accumulator proofs from the blockchain's LedgerInfo, not just re-execute and compare outputs against potentially tampered expected values from the same archive source.

### Citations

**File:** storage/db-tool/src/replay_on_archive.rs (L364-367)
```rust
        let txns = cur_txns
            .iter()
            .map(|txn| SignatureVerifiedTransaction::from(txn.clone()))
            .collect::<Vec<_>>();
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-139)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
}
```

**File:** types/src/block_metadata.rs (L19-29)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockMetadata {
    id: HashValue,
    epoch: u64,
    round: u64,
    proposer: AccountAddress,
    #[serde(with = "serde_bytes")]
    previous_block_votes_bitvec: Vec<u8>,
    failed_proposer_indices: Vec<u32>,
    timestamp_usecs: u64,
}
```

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** types/src/transaction/mod.rs (L2946-2977)
```rust
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),

    /// Transaction that applies a WriteSet to the current storage, it's applied manually via aptos-db-bootstrapper.
    GenesisTransaction(WriteSetPayload),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is disabled.
    BlockMetadata(BlockMetadata),

    /// Transaction to let the executor update the global state tree and record the root hash
    /// in the TransactionInfo
    /// The hash value inside is unique block id which can generate unique hash of state checkpoint transaction
    StateCheckpoint(HashValue),

    /// Transaction that only proposed by a validator mainly to update on-chain configs.
    ValidatorTransaction(ValidatorTransaction),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is enabled.
    BlockMetadataExt(BlockMetadataExt),

    /// Transaction to let the executor update the global state tree and record the root hash
    /// in the TransactionInfo
    /// The hash value inside is unique block id which can generate unique hash of state checkpoint transaction
    /// Replaces StateCheckpoint, with optionally having more data.
    BlockEpilogue(BlockEpiloguePayload),
}
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L111-137)
```rust
    /// Gets the proof for a transaction chunk.
    /// N.B. the `LedgerInfo` returned will always be in the same epoch of the `last_version`.
    pub fn get_transaction_range_proof(
        &self,
        first_version: Version,
        last_version: Version,
    ) -> Result<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)> {
        ensure!(
            last_version >= first_version,
            "Bad transaction range: [{}, {}]",
            first_version,
            last_version
        );
        let num_transactions = last_version - first_version + 1;
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let epoch = ledger_metadata_db.get_epoch(last_version)?;
        let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        let accumulator_proof = self
            .ledger_db
            .transaction_accumulator_db()
            .get_transaction_range_proof(
                Some(first_version),
                num_transactions,
                ledger_info.ledger_info().version(),
            )?;
        Ok((accumulator_proof, ledger_info))
    }
```
