# Audit Report

## Title
Inconsistent Batch Expiry Gap Calculation Allows Remote Batches to Bypass Minimum Age Filter in OptQuorumStore

## Summary
The quorum store uses two different expiry durations for local batches (60 seconds) and remote batches (500 milliseconds), but all components only receive and use the local batch expiry gap when reverse-calculating batch creation times. This causes remote batches to appear ~59.5 seconds older than they actually are, allowing them to bypass the minimum age filter in OptQuorumStore and potentially degrade consensus performance.

## Finding Description

The `spawn_quorum_store()` function initializes three critical components with the same `batch_expiry_gap_when_init_usecs` value (60 seconds by default): [1](#0-0) [2](#0-1) [3](#0-2) 

However, when batches are actually created, the system uses TWO different expiry durations:

**Local batches** use `batch_expiry_gap_when_init_usecs` (60 seconds): [4](#0-3) 

**Remote batches** use `remote_batch_expiry_gap_when_init_usecs` (500 milliseconds): [5](#0-4) 

The configuration clearly shows these vastly different default values: [6](#0-5) 

The components then reverse-calculate batch creation time by subtracting the expiry gap from the expiration timestamp: [7](#0-6) 

This calculation is critically used to enforce minimum age requirements for OptQuorumStore batches: [8](#0-7) 

**The vulnerability:** For remote batches, the calculated creation time is incorrect by ~59.5 seconds:
- Actual creation time: T
- Actual expiration: T + 500,000 µs
- Calculated creation time: (T + 500,000) - 60,000,000 = T - 59,500,000 µs

This makes remote batches appear to be 59.5 seconds older than they actually are, causing them to always pass the minimum age filter (default 50ms) even when freshly created.

## Impact Explanation

This qualifies as **HIGH severity** under the Aptos bug bounty program ("Validator node slowdowns") because:

1. **Security Control Bypass**: The minimum age filter exists to prevent including batches that haven't propagated to all validators, reducing the likelihood of inline fetches. Remote batches completely bypass this control.

2. **Consensus Performance Impact**: A Byzantine validator (< 1/3 threshold is in-scope for consensus issues) could exploit this by:
   - Creating batches with remote expiry settings
   - Sending them to other validators
   - Having them immediately included in OptQuorumStore proposals
   - Forcing other validators to perform inline fetches since the batches haven't propagated
   - Degrading overall consensus performance through increased latency

3. **Protocol Invariant Violation**: The system is designed to maintain consensus safety and liveness under < 1/3 Byzantine validators. This vulnerability allows Byzantine validators to degrade consensus performance beyond intended limits.

The minimum age requirement is passed from OptQuorumStore parameters: [9](#0-8) 

With default minimum age of 50ms: [10](#0-9) 

## Likelihood Explanation

**Likelihood: High**

1. **Automatic Trigger**: This bug affects all remote batches processed through the system whenever OptQuorumStore is enabled (enabled by default).

2. **No Special Conditions Required**: The vulnerability is triggered by normal protocol operation - any validator receiving remote batches experiences incorrect age calculations.

3. **Exploitability**: A Byzantine validator can deliberately abuse this by creating and broadcasting batches designed to be included immediately, forcing inline fetches across the network.

4. **Wide Impact**: All validators running with OptQuorumStore enabled (default configuration) are affected when processing remote batches.

## Recommendation

**Solution**: Pass both expiry gap values to the components and use the appropriate one based on batch origin.

**Option 1 - Track batch origin in BatchInfo:**
Extend `BatchProofQueue` to track whether batches are local or remote, and use the corresponding expiry gap for calculation.

**Option 2 - Store creation timestamp directly (Recommended):**
Instead of reverse-calculating creation time from expiration, store the actual creation timestamp in the batch metadata. This eliminates the need for reverse calculation entirely and provides accurate timing information.

**Option 3 - Unify expiry durations:**
If there's no strong reason for different expiry durations, standardize on a single value for both local and remote batches to eliminate the inconsistency.

The key fix locations:
- `BatchCoordinator::new()` needs awareness of remote batch expiry gap
- `ProofCoordinator::new()` needs awareness of remote batch expiry gap  
- `BatchProofQueue::new()` needs both expiry gap values and logic to select the correct one
- `BatchProofQueue::pull_internal()` needs to use the correct expiry gap based on batch author

## Proof of Concept

```rust
// Simulation demonstrating the vulnerability

fn test_remote_batch_age_calculation_vulnerability() {
    let local_expiry_gap = 60_000_000_u64; // 60 seconds
    let remote_expiry_gap = 500_000_u64;   // 500 milliseconds
    let min_batch_age = 50_000_u64;        // 50 milliseconds
    
    let current_time = 1000_000_000_u64;
    
    // Remote batch created at current_time
    let remote_batch_creation_time = current_time;
    let remote_batch_expiration = remote_batch_creation_time + remote_expiry_gap;
    
    // Component calculates creation time using LOCAL expiry gap
    let calculated_creation_time = remote_batch_expiration - local_expiry_gap;
    
    // Check minimum age filter (40ms after batch creation)
    let check_time = current_time + 40_000; // 40ms later
    let max_creation_time = check_time - min_batch_age;
    
    println!("Actual creation time: {}", remote_batch_creation_time);
    println!("Calculated creation time: {}", calculated_creation_time);
    println!("Difference: {} µs ({} seconds)", 
             remote_batch_creation_time as i64 - calculated_creation_time as i64,
             (remote_batch_creation_time as i64 - calculated_creation_time as i64) / 1_000_000);
    
    // For local batch (correct behavior)
    println!("\nLocal batch (40ms old):");
    let local_batch_expiration = remote_batch_creation_time + local_expiry_gap;
    let local_calculated_time = local_batch_expiration - local_expiry_gap;
    let local_passes_filter = local_calculated_time <= max_creation_time;
    println!("Passes age filter: {} (CORRECT - should be false)", local_passes_filter);
    
    // For remote batch (incorrect behavior)
    println!("\nRemote batch (40ms old):");
    let remote_passes_filter = calculated_creation_time <= max_creation_time;
    println!("Passes age filter: {} (INCORRECT - should be false)", remote_passes_filter);
    
    assert!(!local_passes_filter, "Local batch correctly filtered out");
    assert!(remote_passes_filter, "VULNERABILITY: Remote batch incorrectly passes filter!");
}
```

Expected output:
```
Actual creation time: 1000000000
Calculated creation time: 940500000
Difference: 59500000 µs (59.5 seconds)

Local batch (40ms old):
Passes age filter: false (CORRECT - should be false)

Remote batch (40ms old):
Passes age filter: true (INCORRECT - should be false)
```

This demonstrates that a 40ms-old remote batch bypasses the 50ms minimum age requirement due to appearing 59.5 seconds older than it actually is.

## Notes

The vulnerability specifically affects OptQuorumStore's optional batch selection mechanism, where the minimum age filter is designed to prevent premature inclusion of batches that may not have fully propagated across the validator network. While the main proof-based consensus flow remains secure, this bypass in the optional batch path can be exploited to degrade consensus performance, which qualifies as HIGH severity under validator slowdown criteria.

### Citations

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L334-334)
```rust
                self.config.batch_expiry_gap_when_init_usecs,
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L353-353)
```rust
            self.config.batch_expiry_gap_when_init_usecs,
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L375-375)
```rust
            self.config.batch_expiry_gap_when_init_usecs,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** consensus/src/quorum_store/batch_generator.rs (L398-399)
```rust
        let expiry_time_usecs = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.remote_batch_expiry_gap_when_init_usecs;
```

**File:** config/src/config/quorum_store_config.rs (L131-132)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
```

**File:** config/src/config/quorum_store_config.rs (L142-142)
```rust
            opt_qs_minimum_batch_age_usecs: Duration::from_millis(50).as_micros() as u64,
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L603-604)
```rust
                    let batch_create_ts_usecs =
                        item.info.expiration() - self.batch_expiry_gap_when_init_usecs;
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L606-612)
```rust
                    // Ensure that the batch was created at least `min_batch_age_usecs` ago to
                    // reduce the chance of inline fetches.
                    if max_batch_creation_ts_usecs
                        .is_some_and(|max_create_ts| batch_create_ts_usecs > max_create_ts)
                    {
                        return None;
                    }
```

**File:** consensus/src/quorum_store/proof_manager.rs (L147-147)
```rust
                        Some(params.minimum_batch_age_usecs),
```
