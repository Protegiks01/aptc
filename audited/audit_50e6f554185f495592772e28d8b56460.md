# Audit Report

## Title
Missing Configuration Validation for `hot_state_kv_db_path` Causes Node Startup Panic

## Summary
The `ConfigSanitizer::sanitize()` implementation for `StorageConfig` validates shard path configurations for `state_kv_db_path`, `state_merkle_db_path`, and `hot_state_merkle_db_path`, but fails to validate `hot_state_kv_db_path`. This allows invalid configurations to pass sanitization and later cause node panics during startup.

## Finding Description
The `StorageConfig::sanitize()` function is responsible for validating storage configuration before node startup. It validates four types of sharded database path configurations defined in `DbPathConfig`: [1](#0-0) 

The sanitizer validates three of these fields but **omits validation for `hot_state_kv_db_path`**:

1. **Lines 749-762**: Validates `state_kv_db_path` including metadata path absoluteness and calls to `get_shard_paths()` [2](#0-1) 

2. **Lines 764-777**: Validates `state_merkle_db_path` with identical checks [3](#0-2) 

3. **Lines 779-794**: Validates `hot_state_merkle_db_path` with identical checks [4](#0-3) 

4. **`hot_state_kv_db_path`: NO VALIDATION** - The sanitizer never checks this field despite it being part of `DbPathConfig` and used during node startup.

When the node starts, `get_dir_paths()` is called to initialize storage paths: [5](#0-4) 

This calls `ShardedDbPaths::new()` which contains an `.expect()` that will panic if `get_shard_paths()` fails: [6](#0-5) 

The `get_shard_paths()` method can fail due to multiple error conditions from the `parse()` function: [7](#0-6) 

**Attack Vector:**
1. Node operator provides configuration with invalid `hot_state_kv_db_path` (e.g., shard ID â‰¥ 16, non-absolute paths, malformed ranges like "abc", "1-2-3", or duplicate shard IDs)
2. Configuration passes sanitization (missing validation)
3. Node initialization calls `FastSyncStorageWrapper::initialize_dbs()`: [8](#0-7) 
4. This calls `config.storage.get_dir_paths()` which processes `hot_state_kv_db_path`
5. `ShardedDbPaths::new()` panics with "Invalid config."
6. Node crashes and cannot start

## Impact Explanation
**Severity: High** (per Aptos Bug Bounty guidelines for validator node crashes)

This vulnerability causes complete validator node unavailability:
- The node cannot start at all with invalid `hot_state_kv_db_path` configuration
- No graceful error handling - immediate panic
- Affects all node types (validator, fullnode) that use hot state storage
- Bypasses the configuration sanitizer's safety guarantees

The configuration sanitizer exists specifically to catch these errors early with clear error messages. This missing validation breaks the **Resource Limits** and **Deterministic Execution** invariants by allowing nodes to crash unexpectedly rather than failing fast with clear diagnostics.

While this requires configuration file access, it represents a significant operational risk:
- Prevents legitimate node operators from detecting configuration errors before deployment
- Could be exploited by malicious actors with config access to cause persistent DoS
- No recovery path without manual intervention to fix the configuration

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to occur because:
1. **Easy to trigger**: Any malformed `hot_state_kv_db_path` configuration will cause the panic
2. **Common configuration errors**: Invalid shard IDs, relative paths, or syntax errors are typical mistakes
3. **No warning signs**: Configuration passes all validation checks, giving false confidence
4. **Operator-controlled**: Node operators routinely modify storage configurations for performance tuning
5. **No defensive programming**: The `.expect()` provides no fallback or recovery mechanism

The vulnerability requires no specialized knowledge to exploit - simply providing an invalid configuration like:
```yaml
storage:
  db_path_overrides:
    hot_state_kv_db_path:
      shard_paths:
        - shards: "16"  # Invalid: >= 16
          path: "/disk1/db"
```

## Recommendation
Add validation for `hot_state_kv_db_path` in the `sanitize()` function, mirroring the existing validation for other sharded database paths:

```rust
// Add this block after line 777 in storage_config.rs, before hot_state_merkle_db_path validation

if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
    if let Some(metadata_path) = hot_state_kv_db_path.metadata_path.as_ref() {
        if !metadata_path.is_absolute() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
            ));
        }
    }

    if let Err(e) = hot_state_kv_db_path.get_shard_paths() {
        return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
    }
}
```

This ensures consistent validation across all sharded database path configurations and prevents node panics from invalid `hot_state_kv_db_path` settings.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::config::{config_sanitizer::ConfigSanitizer, NodeConfig, NodeType};

    #[test]
    #[should_panic(expected = "Invalid config")]
    fn test_missing_hot_state_kv_db_path_validation() {
        // Create a NodeConfig with invalid hot_state_kv_db_path
        let mut node_config = NodeConfig::default();
        node_config.storage.rocksdb_configs.enable_storage_sharding = true;
        node_config.storage.db_path_overrides = Some(DbPathConfig {
            ledger_db_path: None,
            state_kv_db_path: None,
            state_merkle_db_path: None,
            hot_state_kv_db_path: Some(ShardedDbPathConfig {
                metadata_path: None,
                shard_paths: vec![ShardPathConfig {
                    shards: "16".into(), // Invalid: shard ID >= 16
                    path: "/disk1/db".into(),
                }],
            }),
            hot_state_merkle_db_path: None,
        });

        // Sanitization passes (BUG: should fail but doesn't validate hot_state_kv_db_path)
        let result = StorageConfig::sanitize(&node_config, NodeType::Validator, None);
        assert!(result.is_ok(), "Sanitization should pass due to missing validation");

        // But calling get_dir_paths() panics (demonstrates the vulnerability)
        let _paths = node_config.storage.get_dir_paths();
    }

    #[test]
    fn test_hot_state_kv_db_path_should_be_validated() {
        let mut node_config = NodeConfig::default();
        node_config.storage.rocksdb_configs.enable_storage_sharding = true;
        node_config.storage.db_path_overrides = Some(DbPathConfig {
            ledger_db_path: None,
            state_kv_db_path: None,
            state_merkle_db_path: None,
            hot_state_kv_db_path: Some(ShardedDbPathConfig {
                metadata_path: None,
                shard_paths: vec![ShardPathConfig {
                    shards: "abc".into(), // Invalid: not a number
                    path: "/disk1/db".into(),
                }],
            }),
            hot_state_merkle_db_path: None,
        });

        // This SHOULD fail but currently passes
        let result = StorageConfig::sanitize(&node_config, NodeType::Validator, None);
        // EXPECTED: result.is_err()
        // ACTUAL: result.is_ok() (vulnerability)
        assert!(result.is_ok(), "Currently passes - demonstrates missing validation");
    }
}
```

**Notes**
The security question references "line 699" for `get_shard_paths()` calls, but the actual validation calls occur at lines 759, 774, and 791. The vulnerability is the **absence** of a similar validation block for `hot_state_kv_db_path`, which should appear around line 778 but is completely missing from the implementation.

### Citations

**File:** config/src/config/storage_config.rs (L30-38)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
struct DbPathConfig {
    ledger_db_path: Option<PathBuf>,
    state_kv_db_path: Option<ShardedDbPathConfig>,
    state_merkle_db_path: Option<ShardedDbPathConfig>,
    hot_state_kv_db_path: Option<ShardedDbPathConfig>,
    hot_state_merkle_db_path: Option<ShardedDbPathConfig>,
}
```

**File:** config/src/config/storage_config.rs (L80-103)
```rust
    fn parse(path: &str) -> Result<Vec<u8>> {
        let mut shard_ids = vec![];
        for p in path.split(',') {
            let num_or_range: Vec<&str> = p.split('-').collect();
            match num_or_range.len() {
                1 => {
                    let num = u8::from_str(num_or_range[0])?;
                    ensure!(num < 16);
                    shard_ids.push(num);
                },
                2 => {
                    let range_start = u8::from_str(num_or_range[0])?;
                    let range_end = u8::from_str(num_or_range[1])?;
                    ensure!(range_start <= range_end && range_end < 16);
                    for num in range_start..=range_end {
                        shard_ids.push(num);
                    }
                },
                _ => bail!("Invalid path: {path}."),
            }
        }

        Ok(shard_ids)
    }
```

**File:** config/src/config/storage_config.rs (L488-490)
```rust
            if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
                hot_state_kv_db_paths = ShardedDbPaths::new(hot_state_kv_db_path);
            }
```

**File:** config/src/config/storage_config.rs (L621-631)
```rust
    fn new(config: &ShardedDbPathConfig) -> Self {
        let mut shard_paths = arr![None; 16];
        for (shard_id, shard_path) in config.get_shard_paths().expect("Invalid config.") {
            shard_paths[shard_id as usize] = Some(shard_path);
        }

        Self {
            metadata_path: config.metadata_path.clone(),
            shard_paths,
        }
    }
```

**File:** config/src/config/storage_config.rs (L749-762)
```rust
            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** config/src/config/storage_config.rs (L764-777)
```rust
            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** config/src/config/storage_config.rs (L779-794)
```rust
            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L43-59)
```rust
    pub fn initialize_dbs(
        config: &NodeConfig,
        internal_indexer_db: Option<InternalIndexerDB>,
        update_sender: Option<Sender<(Instant, Version)>>,
    ) -> Result<Either<AptosDB, Self>> {
        let mut db_main = AptosDB::open(
            config.storage.get_dir_paths(),
            /*readonly=*/ false,
            config.storage.storage_pruner_config,
            config.storage.rocksdb_configs,
            config.storage.enable_indexer,
            config.storage.buffered_state_target_items,
            config.storage.max_num_nodes_per_lru_cache_shard,
            internal_indexer_db,
            config.storage.hot_state_config,
        )
        .map_err(|err| anyhow!("fast sync DB failed to open {}", err))?;
```
