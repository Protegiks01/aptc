# Audit Report

## Title
Indexer Transaction Filter Size Configuration Lacks Upper Bound Validation Enabling DoS via Misconfiguration

## Summary
The `max_transaction_filter_size_bytes` configuration parameter lacks upper bound validation, allowing operators to set excessively large values that enable DoS attacks on indexer nodes through resource exhaustion from complex transaction filters.

## Finding Description

The indexer-grpc system allows clients to submit transaction filters to query blockchain data. The `parse_transaction_filter()` function validates filter size against a configurable limit: [1](#0-0) 

The default value is set to 10,000 bytes (10KB): [2](#0-1) [3](#0-2) 

However, the configuration sanitizer performs NO validation on this parameter's upper bound: [4](#0-3) 

This allows operators to set arbitrarily large values (e.g., 100MB, 1GB). Combined with the lack of recursion depth limits in nested filter parsing: [5](#0-4) [6](#0-5) [7](#0-6) 

An attacker can craft deeply nested filters causing:
1. **Memory exhaustion** during filter parsing and storage
2. **Stack overflow** during recursive parsing/matching operations
3. **CPU exhaustion** when evaluating complex filters against transaction streams

## Impact Explanation

**Medium Severity** - This affects indexer node availability but not core consensus or blockchain operation. Per Aptos bug bounty criteria, this falls under "API crashes" or "validator node slowdowns" (if indexer fullnodes are affected). However, since indexers are architecturally separate from consensus validators, the impact is limited to data availability services. [8](#0-7) 

## Likelihood Explanation

**Low to Medium** - This vulnerability requires operator misconfiguration. The default 10KB limit is safe and reasonable. However:
- No warnings or documentation guide operators on safe upper bounds
- No runtime validation prevents dangerous configurations
- Once misconfigured, exploitation is trivial for any client
- Indexer nodes are publicly accessible services

## Recommendation

Add configuration validation with a reasonable upper bound:

```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        // ADD THIS VALIDATION
        const MAX_SAFE_FILTER_SIZE: usize = 1_000_000; // 1MB
        if node_config.indexer_grpc.max_transaction_filter_size_bytes > MAX_SAFE_FILTER_SIZE {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "max_transaction_filter_size_bytes ({}) exceeds maximum safe value ({})",
                    node_config.indexer_grpc.max_transaction_filter_size_bytes,
                    MAX_SAFE_FILTER_SIZE
                ),
            ));
        }

        // ... existing checks ...
    }
}
```

Additionally, implement recursion depth limits:

```rust
const MAX_FILTER_RECURSION_DEPTH: usize = 16;

pub fn new_from_proto(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size: Option<usize>,
) -> Result<Self> {
    Self::new_from_proto_with_depth(proto_filter, max_filter_size, 0)
}

fn new_from_proto_with_depth(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size: Option<usize>,
    depth: usize,
) -> Result<Self> {
    ensure!(
        depth < MAX_FILTER_RECURSION_DEPTH,
        "Filter nesting depth exceeds maximum allowed ({})",
        MAX_FILTER_RECURSION_DEPTH
    );
    // ... rest of validation ...
}
```

## Proof of Concept

```rust
#[test]
fn test_misconfigured_large_filter_dos() {
    use aptos_protos::indexer::v1::{BooleanTransactionFilter, LogicalAndFilters};
    
    // Simulate misconfigured node with 100MB limit
    let misconfigured_limit = 100_000_000;
    
    // Create deeply nested filter structure
    let mut filter = create_simple_filter();
    for _ in 0..1000 {
        filter = BooleanTransactionFilter {
            filter: Some(
                boolean_transaction_filter::Filter::LogicalAnd(
                    LogicalAndFilters {
                        filters: vec![filter],
                    }
                )
            ),
        };
    }
    
    // With misconfiguration, this would pass size check but cause stack overflow
    let result = parse_transaction_filter(filter, misconfigured_limit);
    
    // Without depth limits, this can crash the indexer node
    assert!(result.is_err() || would_cause_stack_overflow());
}
```

## Notes

**Important Clarifications:**

1. **Default Configuration is Safe**: The 10KB default is reasonable and prevents exploitation.

2. **Requires Misconfiguration**: This vulnerability only manifests if operators set `max_transaction_filter_size_bytes` to excessively large values without understanding the implications.

3. **Indexer-Only Impact**: This affects indexer nodes, NOT consensus validators. The architecture separates these components, so core blockchain operation remains secure even if indexers are DoS'd.

4. **Configuration Validation Gap**: The root issue is the lack of upper bound validation in `ConfigSanitizer`, allowing dangerous configurations without warnings.

5. **Nested Filter Bypass**: A secondary issue exists where nested filters (AND/OR/NOT) are parsed with `None` for size limits, potentially bypassing protections even with safe top-level limits.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L21-21)
```rust
pub const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** config/src/config/indexer_grpc_config.rs (L21-21)
```rust
const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** config/src/config/indexer_grpc_config.rs (L103-127)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L265-277)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalAndFilters> for LogicalAnd {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalAndFilters) -> Result<Self> {
        Ok(Self {
            and: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L305-317)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalOrFilters> for LogicalOr {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalOrFilters) -> Result<Self> {
        Ok(Self {
            or: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L345-358)
```rust
impl TryFrom<Box<aptos_protos::indexer::v1::BooleanTransactionFilter>> for LogicalNot {
    type Error = anyhow::Error;

    fn try_from(
        proto_filter: Box<aptos_protos::indexer::v1::BooleanTransactionFilter>,
    ) -> Result<Self> {
        Ok(Self {
            not: Box::new(BooleanTransactionFilter::new_from_proto(
                *proto_filter,
                None,
            )?),
        })
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L61-78)
```rust
    let max_transaction_filter_size_bytes =
        node_config.indexer_grpc.max_transaction_filter_size_bytes;

    runtime.spawn(async move {
        let context = Arc::new(Context::new(
            chain_id,
            db,
            mp_sender,
            node_config,
            indexer_reader,
        ));
        let service_context = ServiceContext {
            context: context.clone(),
            processor_task_count,
            processor_batch_size,
            output_batch_size,
            transaction_channel_size,
            max_transaction_filter_size_bytes,
```
