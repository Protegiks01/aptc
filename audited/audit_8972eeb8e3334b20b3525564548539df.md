# Audit Report

## Title
Subscription Metadata Validation Bypass Enabling Resource Exhaustion Attack

## Summary
The storage service server fails to validate subscription metadata values (`known_version_at_stream_start`, `known_epoch_at_stream_start`, `subscription_stream_index`) when creating new subscription streams, allowing malicious peers to create unserviceable subscriptions that waste server resources and cause state tracking inconsistencies.

## Finding Description

At the point where `SubscriptionRequestMetadata` is constructed from request fields, there is no validation of the metadata values: [1](#0-0) 

These unvalidated values flow to the storage service server, which blindly accepts them when creating new subscription streams: [2](#0-1) 

The vulnerability manifests in two ways:

**Attack 1: Invalid Stream Index**
When a new stream is created, `next_index_to_serve` is always initialized to 0, regardless of the first request's `subscription_stream_index`. If a malicious peer sends `subscription_stream_index = 1000000`, the subscription never becomes ready because the check requires the first pending request's index to equal `next_index_to_serve`: [3](#0-2) 

**Attack 2: Extreme Metadata Values**
More critically, if a peer sends `known_version_at_stream_start = u64::MAX` with `subscription_stream_index = 0`, the subscription becomes ready and is processed, but fails during data preparation due to integer overflow: [4](#0-3) 

When this overflow error occurs, the request is popped from pending requests but `next_index_to_serve` is NOT incremented because `update_known_version_and_epoch` is only called on success: [5](#0-4) 

The error is merely logged without removing the stream: [6](#0-5) 

The peer can then repeatedly send the same malicious request, which is accepted because the metadata matches and the index passes validation: [7](#0-6) 

Each new request refreshes `last_stream_update_time`, preventing stream expiration: [8](#0-7) 

Critically, subscription requests bypass the request moderator's rate limiting: [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty program ("State inconsistencies requiring intervention"):

1. **Resource Exhaustion**: The subscription handler runs every 100ms. Each iteration attempts to serve the failing subscription, consuming CPU cycles and generating error logs indefinitely as long as the peer continues sending requests.

2. **State Tracking Corruption**: The subscription stream's internal state becomes inconsistent - `next_index_to_serve` remains stuck while requests are repeatedly processed and discarded.

3. **Amplification Potential**: Multiple malicious peers can create many such subscriptions simultaneously, each consuming server resources.

4. **No Automatic Recovery**: Unlike legitimate timeouts, these malicious subscriptions never expire if the attacker continues sending requests, requiring manual intervention.

While this doesn't directly compromise consensus or funds, it can degrade validator performance through CPU exhaustion and log spam, potentially affecting network liveness if scaled sufficiently.

## Likelihood Explanation

**High likelihood** of exploitation:

- **Low Barrier**: Any authenticated network peer can send subscription requests
- **No Rate Limiting**: Subscription requests bypass the request moderator
- **Simple Exploit**: Attacker only needs to craft malformed subscription requests with extreme metadata values
- **Persistent Impact**: Each malicious peer can maintain indefinite resource consumption
- **Difficult Detection**: Appears as legitimate subscription traffic with processing errors

## Recommendation

Add validation when creating new subscription streams to ensure metadata values are within reasonable bounds:

```rust
impl SubscriptionStreamRequests {
    pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Result<Self, Error> {
        // Validate that the first request has index 0
        let subscription_stream_index = subscription_request.subscription_stream_index();
        if subscription_stream_index != 0 {
            return Err(Error::InvalidRequest(format!(
                "First subscription request must have index 0, found: {}",
                subscription_stream_index
            )));
        }

        // Extract and validate metadata
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        
        // Validate against current ledger state to ensure values are reasonable
        // (implementation would check against storage)
        
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        
        // ... rest of implementation
    }
}
```

Additionally, implement proper error handling that removes the subscription stream entirely when overflow errors occur, preventing repeated processing of failing requests.

## Proof of Concept

```rust
#[tokio::test]
async fn test_malicious_subscription_metadata() {
    use aptos_storage_service_types::requests::{
        SubscribeTransactionsWithProofRequest, SubscriptionStreamMetadata
    };
    
    // Create malicious subscription with extreme known_version
    let malicious_metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: u64::MAX,
        known_epoch_at_stream_start: 0,
        subscription_stream_id: 123,
    };
    
    let malicious_request = SubscribeTransactionsWithProofRequest {
        subscription_stream_metadata: malicious_metadata,
        subscription_stream_index: 0,
        include_events: false,
    };
    
    // Send to storage service - this will be accepted
    // When handler tries to serve it:
    // - Request gets popped from pending
    // - get_storage_request_for_missing_data fails with overflow
    // - Error logged but stream remains
    // - next_index_to_serve stays at 0
    // - Peer can send another identical request
    // - Cycle repeats indefinitely
    
    // Expected: Request should be rejected during stream creation
    // Actual: Request accepted, causes repeated failures
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation where user-controlled metadata values are trusted without bounds checking. The combination of missing validation, inadequate error recovery, and lack of rate limiting for subscription requests creates a viable resource exhaustion attack vector that can affect validator node performance at scale.

### Citations

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1662-1667)
```rust
    let subscription_request_metadata = SubscriptionRequestMetadata {
        known_version_at_stream_start: request.known_version,
        known_epoch_at_stream_start: request.known_epoch,
        subscription_stream_id: request.subscription_stream_id,
        subscription_stream_index: request.subscription_stream_index,
    };
```

**File:** state-sync/storage-service/server/src/subscription.rs (L88-97)
```rust

        // Calculate the start and end versions
        let start_version = known_version.checked_add(1).ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Start version has overflown!".into())
        })?;
        let end_version = known_version
            .checked_add(num_versions_to_fetch)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("End version has overflown!".into())
            })?;
```

**File:** state-sync/storage-service/server/src/subscription.rs (L314-335)
```rust
    pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Self {
        // Extract the relevant information from the request
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

        // Create a new set of pending subscription requests using the first request
        let mut pending_subscription_requests = BTreeMap::new();
        pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        Self {
            highest_known_version,
            highest_known_epoch,
            next_index_to_serve: 0,
            pending_subscription_requests,
            subscription_stream_metadata,
            last_stream_update_time: time_service.now(),
            time_service,
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L346-368)
```rust
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
        }

        // Verify that the subscription request index is valid
        let subscription_request_index = subscription_request.subscription_stream_index();
        if subscription_request_index < self.next_index_to_serve {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                    self.next_index_to_serve, subscription_request_index
                )),
                subscription_request,
            ));
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L389-390)
```rust
        // Refresh the last stream update time
        self.refresh_last_stream_update_time();
```

**File:** state-sync/storage-service/server/src/subscription.rs (L438-443)
```rust
    fn first_request_ready_to_be_served(&self) -> bool {
        if let Some(subscription_request) = self.first_pending_request() {
            subscription_request.subscription_stream_index() == self.next_index_to_serve
        } else {
            false
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L713-719)
```rust
                    // Update the stream's known version and epoch
                    if let Some(mut subscription_stream_requests) =
                        subscriptions.get_mut(&peer_network_id)
                    {
                        subscription_stream_requests
                            .update_known_version_and_epoch(&data_response)?;
                    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L731-735)
```rust
                // Log an error if the handler failed
                if let Err(error) = result {
                    warn!(LogSchema::new(LogEntry::SubscriptionResponse)
                        .error(&Error::UnexpectedErrorEncountered(error.to_string())));
                }
```

**File:** state-sync/storage-service/server/src/handler.rs (L125-134)
```rust
        // Handle any subscription requests
        if request.data_request.is_subscription_request() {
            self.handle_subscription_request(
                storage_service_config,
                peer_network_id,
                request,
                response_sender,
            );
            return;
        }
```
