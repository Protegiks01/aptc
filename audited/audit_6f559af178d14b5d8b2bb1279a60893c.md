# Audit Report

## Title
IpAllowlistBypasser Fails to Validate Localhost IPs Enabling Complete Security Bypass

## Summary
The `IpAllowlistBypasser` implementation does not validate or reject localhost IP addresses (127.0.0.0/8, ::1, 0.0.0.0) in the allowlist configuration, and trusts client-controlled HTTP headers without proxy validation. This allows attackers to bypass all faucet security checks (rate limiting, captcha, IP blocklists) through header injection if localhost IPs are present in the allowlist, or through local access attacks.

## Finding Description

The vulnerability exists across three interconnected components:

**1. No Localhost IP Validation in IpRangeManager** [1](#0-0) 

The `IpRangeManager` reads IP ranges from a configuration file without validating that localhost addresses are excluded. Any IP range, including 127.0.0.0/8 or ::1/128, will be accepted and added to the allowlist.

**2. IpAllowlistBypasser Unconditionally Trusts Configured IPs** [2](#0-1) 

The bypasser performs no runtime validation on the source IP before checking against the allowlist, treating localhost IPs identically to public IPs.

**3. Untrusted Header Processing via RealIp** [3](#0-2) 

The faucet extracts source IP from `RealIp`, which automatically parses X-Forwarded-For, X-Real-IP, and Forwarded headers without validating the request originates from a trusted proxy. [4](#0-3) 

This extracted IP is used directly for security decisions with no additional validation.

**Attack Scenario 1: Header Injection Bypass**

1. Administrator adds `127.0.0.1` to allowlist file (believing it safe for internal testing)
2. Attacker sends HTTP request: `X-Forwarded-For: 127.0.0.1`
3. `RealIp` extracts `127.0.0.1` as source_ip without validating request origin
4. `IpAllowlistBypasser` matches `127.0.0.1` against allowlist and returns true [5](#0-4) 

5. Request bypasses ALL checkers and rate limits, attacker drains faucet with unlimited requests

**Attack Scenario 2: Local Access Exploitation**

1. Administrator configures `127.0.0.1` in allowlist for monitoring/testing
2. Attacker gains any local shell access (SSH, compromised service, etc.)
3. Attacker sends faucet requests from localhost
4. All security checks bypassed, unlimited fund drainage

## Impact Explanation

**Medium Severity** - Meets criteria for "Limited funds loss or manipulation":

- **Fund Drainage**: Attackers can make unlimited faucet requests, draining configured funds completely
- **Rate Limit Bypass**: All rate limiting mechanisms (Redis, memory-based) are circumvented
- **Security Control Bypass**: Captcha verification, IP blocklists, and custom checkers are completely disabled
- **Scope**: Limited to faucet service (testnet funding), does not affect consensus or mainnet

This does not reach High/Critical severity because:
- Does not affect validator nodes or consensus
- Limited to test network faucet funds
- Requires either configuration error or deployment without proper proxy

## Likelihood Explanation

**Medium-High Likelihood**:

**Configuration Error Factor**: Administrators may reasonably add `127.0.0.1` to allowlists for:
- Local testing and development
- Internal monitoring systems
- Believing localhost is "safe" since it's not externally accessible

**Deployment Vulnerability Factor**: 
- Faucet documentation does not warn about localhost IPs in allowlists
- No runtime validation prevents dangerous configurations
- poem's `RealIp` trusts forwarding headers by default without requiring proxy configuration
- Common deployment patterns may lack properly configured reverse proxies

**Attacker Requirements**:
- Scenario 1 (Header Injection): Internet access, knowledge of misconfiguration
- Scenario 2 (Local Access): Shell access to faucet server

## Recommendation

**Immediate Fixes**:

1. **Add Localhost Validation in IpRangeManager**:
```rust
pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
    // ... existing file reading code ...
    for line in std::io::BufReader::new(file).lines() {
        let line = line?;
        if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
            continue;
        }
        
        // Validate parsed network is not localhost
        match line.parse::<Ipv4Net>() {
            Ok(ipv4_net) => {
                if ipv4_net.addr().is_loopback() {
                    bail!("Localhost/loopback addresses not allowed in allowlist: {}", line);
                }
                ipv4_list.add(ipv4_net);
            },
            Err(_) => match line.parse::<Ipv6Net>() {
                Ok(ipv6_net) => {
                    if ipv6_net.addr().is_loopback() {
                        bail!("Localhost/loopback addresses not allowed in allowlist: {}", line);
                    }
                    ipv6_list.add(ipv6_net);
                },
                // ... existing error handling ...
            },
        }
    }
    Ok(Self { ipv4_list, ipv6_list })
}
```

2. **Add Runtime IP Validation in IpAllowlistBypasser**:
```rust
async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
    // Reject localhost IPs regardless of allowlist
    if data.source_ip.is_loopback() {
        return Ok(false);
    }
    Ok(self.manager.contains_ip(&data.source_ip))
}
```

3. **Add Configuration Documentation**: Document in README.md that localhost IPs should never be added to allowlists and explain header injection risks.

4. **Implement Trusted Proxy Configuration**: Add configuration option to specify trusted proxy IPs, only accept forwarding headers from those sources.

## Proof of Concept

```rust
#[cfg(test)]
mod security_tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr};

    #[test]
    fn test_localhost_ip_in_allowlist_vulnerability() {
        // Create allowlist file containing localhost
        let temp_file = std::env::temp_dir().join("test_allowlist.txt");
        std::fs::write(&temp_file, "127.0.0.1/32\n10.0.0.0/8").unwrap();
        
        let config = IpRangeManagerConfig {
            file: temp_file.clone(),
        };
        
        // This should fail but currently succeeds
        let manager = IpRangeManager::new(config).unwrap();
        
        // Verify localhost is in allowlist (vulnerability)
        let localhost = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));
        assert!(manager.contains_ip(&localhost)); // PASSES - VULNERABILITY!
        
        std::fs::remove_file(temp_file).ok();
    }
    
    #[tokio::test]
    async fn test_bypasser_accepts_localhost() {
        use crate::checkers::CheckerData;
        use std::sync::Arc;
        use poem::http::HeaderMap;
        
        // Setup bypasser with localhost in allowlist
        let temp_file = std::env::temp_dir().join("test_bypass.txt");
        std::fs::write(&temp_file, "127.0.0.1/32").unwrap();
        
        let config = IpRangeManagerConfig { file: temp_file.clone() };
        let bypasser = IpAllowlistBypasser::new(config).unwrap();
        
        // Create request with localhost IP (simulating spoofed header)
        let data = CheckerData {
            time_request_received_secs: 0,
            receiver: AccountAddress::random(),
            source_ip: IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)),
            headers: Arc::new(HeaderMap::new()),
        };
        
        // Bypasser allows localhost - all checks bypassed!
        assert!(bypasser.request_can_bypass(data).await.unwrap()); // VULNERABILITY
        
        std::fs::remove_file(temp_file).ok();
    }
}
```

## Notes

While the faucet is a testnet component and not directly critical to consensus, this vulnerability demonstrates a defense-in-depth failure. The code should actively prevent dangerous configurations rather than relying solely on correct operator behavior. The lack of input validation on IP allowlists combined with trusting client-controlled headers creates an exploitable attack surface for fund drainage.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L23-53)
```rust
impl IpRangeManager {
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;

        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        let mut ipv6_list = IpRange::<Ipv6Net>::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            match line.parse::<Ipv4Net>() {
                Ok(ipv4_net) => {
                    ipv4_list.add(ipv4_net);
                },
                Err(_) => match line.parse::<Ipv6Net>() {
                    Ok(ipv6_net) => {
                        ipv6_list.add(ipv6_net);
                    },
                    Err(_) => {
                        bail!("Failed to parse line as IPv4 or IPv6 range: {}", line);
                    },
                },
            }
        }
        Ok(Self {
            ipv4_list,
            ipv6_list,
        })
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L25-29)
```rust
impl BypasserTrait for IpAllowlistBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L102-109)
```rust
    async fn fund(
        &self,
        fund_request: Json<FundRequest>,
        asset: poem_openapi::param::Query<Option<String>>,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```
