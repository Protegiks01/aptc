# Audit Report

## Title
Missing Timestamp Range Validation in Noise Handshake Enables Permanent Peer Lockout

## Summary
The Noise handshake authentication mechanism in the network layer accepts timestamps with no upper bound validation. While replay protection ensures timestamps are strictly increasing, there is no check that timestamps are within a reasonable range of the current time. This allows peers (whether due to clock misconfiguration or malicious intent) to send far-future timestamps, resulting in permanent lockout from peers until manual intervention (node restart).

## Finding Description

The `AntiReplayTimestamps` mechanism in the Noise handshake protocol implements replay attack prevention by ensuring timestamps are strictly increasing per peer. However, it lacks range validation to ensure timestamps are within an acceptable window of the current time. [1](#0-0) 

The `is_replay()` method only validates that the new timestamp is greater than the previously stored timestamp. There is no check that the timestamp is:
- Not too far in the future (e.g., years ahead)
- Within a reasonable clock skew tolerance of the current time

During inbound handshake processing, the server receives and validates the client timestamp: [2](#0-1) 

The validation consists only of:
1. Checking payload length matches expected size
2. Calling `is_replay()` to ensure timestamp is greater than last seen
3. Storing the timestamp if valid

**No range validation occurs.** This means a peer can send `u64::MAX` (approximately year 584,554,050 CE) or any large future timestamp, and it will be accepted and stored.

The test suite explicitly confirms this behavior: [3](#0-2) 

The comment states "perform the handshake again with a valid timestamp in the future, it should work" - any future timestamp is considered valid.

**Contrast with Consensus Layer:** The codebase demonstrates awareness of proper timestamp validation in the consensus layer: [4](#0-3) 

Consensus blocks are validated to be within 5 minutes (300 seconds) of the current time, with blocks exceeding this considered malicious. Additionally, the codebase defines accepted clock skew tolerance: [5](#0-4) 

**Attack Scenarios:**

1. **Clock Misconfiguration:** A validator with an incorrectly configured system clock (e.g., set to year 2124) connects to peers. Their future timestamp is accepted and stored. When they fix their clock and attempt to reconnect with current timestamps, all connections are rejected as replays, permanently locking them out until peers restart.

2. **Malicious Lock-Out:** A Byzantine validator or compromised validator sends connections with timestamp `u64::MAX` to all peers before losing access or exiting the network. This prevents the legitimate operator from reconnecting even after regaining control, extending the impact period.

3. **Strategic Exit:** A malicious validator could use this to lock themselves out in a way that appears as network connectivity issues rather than obvious malicious behavior, potentially avoiding slashing or detection.

The comments acknowledge lack of garbage collection but not the lack of range validation: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific impacts:**
- **Availability:** Validators can be locked out from peer connections, requiring node restarts to recover
- **Operational Disruption:** Manual intervention needed to restore connectivity
- **Consensus Impact:** If multiple validators experience lockout simultaneously (e.g., from coordinated clock issues or attacks), consensus participation could be affected
- **No Permanent Damage:** Timestamps are not persisted; node restart clears the state

The timestamp storage is in-memory only (initialized via `default()` at node startup), providing a recovery path through restart but still requiring operational intervention. [7](#0-6) 

## Likelihood Explanation

**Realistic Scenarios:**
1. **Clock Skew (High Likelihood):** System administrators or automated systems occasionally misconfigure NTP or system clocks, especially after hardware maintenance or timezone changes. This is a documented operational issue in distributed systems.

2. **Byzantine Validator (Medium Likelihood):** In BFT consensus models, up to 1/3 of validators can be Byzantine. A malicious validator with valid credentials could exploit this before being detected or removed.

3. **Compromised Validator (Medium Likelihood):** If a validator's private key is compromised, the attacker could use this technique as a parting shot to extend the impact period.

The vulnerability requires valid validator credentials (private keys matching trusted peers), which limits exploitation to insiders or compromised nodes. However, this is within the BFT threat model where Byzantine validators are expected adversaries.

## Recommendation

Implement timestamp range validation consistent with the consensus layer's approach. Add validation that timestamps must be within a reasonable window of the current time:

```rust
// In upgrade_inbound function, after parsing client_timestamp:
let client_timestamp = u64::from_le_bytes(client_timestamp);

// Validate timestamp is within acceptable range
let current_ts = duration_since_epoch().as_millis() as u64;
const MAX_TIMESTAMP_DRIFT_MS: u64 = 300_000; // 5 minutes, same as consensus

if client_timestamp > current_ts.saturating_add(MAX_TIMESTAMP_DRIFT_MS) {
    return Err(NoiseHandshakeError::InvalidTimestamp(
        remote_peer_short,
        client_timestamp,
        current_ts,
    ));
}

// Also check for unreasonably old timestamps
const MIN_TIMESTAMP_DRIFT_MS: u64 = 300_000; // 5 minutes in the past
if client_timestamp < current_ts.saturating_sub(MIN_TIMESTAMP_DRIFT_MS) {
    return Err(NoiseHandshakeError::InvalidTimestamp(
        remote_peer_short,
        client_timestamp,
        current_ts,
    ));
}

// Then proceed with existing replay check
let mut anti_replay_timestamps = anti_replay_timestamps.write();
if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
    return Err(NoiseHandshakeError::ServerReplayDetected(
        remote_peer_short,
        client_timestamp,
    ));
}
```

Add a new error variant to `NoiseHandshakeError`:
```rust
#[error("noise server: client {0}: timestamp {1} is outside acceptable range (current: {2})")]
InvalidTimestamp(ShortHexStr, u64, u64),
```

## Proof of Concept

```rust
#[test]
fn test_timestamp_far_future_accepted() {
    // This test demonstrates the vulnerability: far-future timestamps are accepted
    let ((client, _), (server, server_public_key)) = build_peers(true, None);
    let server_peer_id = server.network_context.peer_id();

    // Send a timestamp far in the future (100 years from now in milliseconds)
    let far_future = 1000u64 * 1000 * 60 * 60 * 24 * 365 * 100; // ~100 years in ms
    let current_time = duration_since_epoch().as_millis() as u64;
    let far_future_timestamp = current_time + far_future;

    // First handshake with far future timestamp - should ideally fail but currently succeeds
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_session, server_session) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            bad_timestamp(far_future_timestamp),
        ),
        server.upgrade_inbound(listener_socket),
    ));

    // This SUCCEEDS (demonstrating the vulnerability)
    client_session.unwrap();
    server_session.unwrap();

    // Now try to connect with a normal timestamp - this should work but will FAIL
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_session, server_session) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            AntiReplayTimestamps::now, // Current time
        ),
        server.upgrade_inbound(listener_socket),
    ));

    // This FAILS because current timestamp < far_future_timestamp (treated as replay)
    // Demonstrating permanent lockout
    client_session.unwrap_err();
    server_session.unwrap_err();
}

#[test]
fn test_timestamp_max_value_accepted() {
    // Test with u64::MAX - the most extreme case
    let ((client, _), (server, server_public_key)) = build_peers(true, None);
    let server_peer_id = server.network_context.peer_id();

    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_session, server_session) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            bad_timestamp(u64::MAX),
        ),
        server.upgrade_inbound(listener_socket),
    ));

    // This succeeds, demonstrating no upper bound validation
    client_session.unwrap();
    server_session.unwrap();
    
    // Any subsequent connection will fail permanently (until node restart)
}
```

## Notes

While this vulnerability requires valid validator credentials (limiting it to insiders or compromised validators), it represents a significant deviation from security best practices demonstrated elsewhere in the codebase. The consensus layer properly validates timestamps within a 5-minute window, yet the network handshake layer has no such protection. This inconsistency, combined with the realistic clock misconfiguration scenario, makes this a valid operational security concern requiring manual intervention to resolve.

### Citations

**File:** network/framework/src/noise/handshake.rs (L59-65)
```rust
    pub fn is_replay(&self, pubkey: x25519::PublicKey, timestamp: u64) -> bool {
        if let Some(last_timestamp) = self.0.get(&pubkey) {
            &timestamp <= last_timestamp
        } else {
            false
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L86-91)
```rust
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
```

**File:** network/framework/src/noise/handshake.rs (L102-106)
```rust
    pub fn mutual(peers_and_metadata: Arc<PeersAndMetadata>) -> Self {
        HandshakeAuthMode::Mutual {
            anti_replay_timestamps: RwLock::new(AntiReplayTimestamps::default()),
            peers_and_metadata,
        }
```

**File:** network/framework/src/noise/handshake.rs (L431-454)
```rust
        if let Some(anti_replay_timestamps) = self.auth_mode.anti_replay_timestamps() {
            // check that the payload received as the client timestamp (in seconds)
            if payload.len() != AntiReplayTimestamps::TIMESTAMP_SIZE {
                return Err(NoiseHandshakeError::MissingAntiReplayTimestamp(
                    remote_peer_short,
                ));
            }

            let mut client_timestamp = [0u8; AntiReplayTimestamps::TIMESTAMP_SIZE];
            client_timestamp.copy_from_slice(&payload);
            let client_timestamp = u64::from_le_bytes(client_timestamp);

            // check the timestamp is not a replay
            let mut anti_replay_timestamps = anti_replay_timestamps.write();
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }

            // store the timestamp
            anti_replay_timestamps.store_timestamp(remote_public_key, client_timestamp);
        }
```

**File:** network/framework/src/noise/handshake.rs (L680-693)
```rust
        // 5. perform the handshake again with a valid timestamp in the future, it should work
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        let (client_session, server_session) = block_on(join(
            client.upgrade_outbound(
                dialer_socket,
                server_peer_id,
                server_public_key,
                bad_timestamp(2),
            ),
            server.upgrade_inbound(listener_socket),
        ));

        client_session.unwrap();
        server_session.unwrap();
```

**File:** consensus/consensus-types/src/block.rs (L534-539)
```rust
            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
```

**File:** crates/aptos/src/common/types.rs (L87-88)
```rust
pub const US_IN_SECS: u64 = 1_000_000;
pub const ACCEPTED_CLOCK_SKEW_US: u64 = 5 * US_IN_SECS;
```
