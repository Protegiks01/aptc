# Audit Report

## Title
OIDC Provider Governance Proposals Execute Without Feature Flag Validation Causing State Inconsistencies

## Summary
The `generate_oidc_provider_ops_proposal()` function generates governance proposals that modify OIDC provider configurations without checking whether the JWK consensus feature flags are enabled. This allows proposals to execute successfully and update on-chain state even when the JWK consensus subsystem is disabled, resulting in state inconsistencies where configured providers are stored but never used.

## Finding Description
The governance proposal generation in `generate_oidc_provider_ops_proposal()` calls Move functions that lack feature flag checks: [1](#0-0) 

These generated proposals invoke Move functions that modify the `SupportedOIDCProviders` resource without validating feature flag prerequisites: [2](#0-1) [3](#0-2) [4](#0-3) 

However, the JWK consensus subsystem checks feature flags before utilizing these providers: [5](#0-4) 

The conversion logic also ignores `SupportedOIDCProviders` when the feature flag is disabled: [6](#0-5) 

This creates a mismatch where governance believes OIDC providers are configured (on-chain state shows them), but the runtime JWK consensus subsystem doesn't use them because the feature flag check fails at the Rust level.

## Impact Explanation
**Medium Severity** - State inconsistencies requiring intervention:

1. **Silent Failure**: Governance proposals execute successfully but have no practical effect, wasting governance resources and creating confusion
2. **State Divergence**: On-chain `SupportedOIDCProviders` resource diverges from actual runtime behavior
3. **Delayed Activation**: If feature flags are later enabled, previously configured providers activate unexpectedly, potentially including misconfigured or malicious providers added during the disabled period
4. **Governance Integrity**: Violates the expectation that successful governance proposals achieve their intended effects

This breaks the **Governance Integrity** invariant that governance actions should reliably reflect the will of stakeholders.

## Likelihood Explanation
**Medium-High Likelihood**: This can occur whenever:
- Governance participants are unaware of current feature flag states
- Testing environments differ from production feature flag configurations  
- Feature flags are disabled after proposals are drafted but before execution
- Documentation doesn't clearly communicate feature flag prerequisites

The lack of validation makes this a systematic issue affecting any OIDC provider governance proposal executed on networks with disabled JWK consensus features.

## Recommendation
Add feature flag validation to the Move functions called by governance proposals:

```move
public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
    system_addresses::assert_aptos_framework(fx);
    
    // Add feature flag check
    assert!(
        features::jwk_consensus_enabled(),
        error::invalid_state(EJWK_CONSENSUS_NOT_ENABLED)
    );
    
    let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
        config_buffer::extract_v2<SupportedOIDCProviders>()
    } else {
        *borrow_global<SupportedOIDCProviders>(@aptos_framework)
    };
    
    let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
    vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
    config_buffer::upsert(provider_set);
    old_config_url
}
```

Apply similar checks to `remove_oidc_provider_for_next_epoch()` and `remove_issuer_from_observed_jwks()`.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x030000, location = aptos_framework::jwks)]
fun test_oidc_provider_proposal_fails_without_feature_flag(aptos_framework: signer) acquires SupportedOIDCProviders {
    // Initialize without enabling JWK_CONSENSUS feature
    initialize_for_test(&aptos_framework);
    features::change_feature_flags_for_testing(
        &aptos_framework,
        vector[], // Don't enable JWK_CONSENSUS
        vector[features::get_jwk_consensus_feature()]
    );
    
    // Attempt to upsert OIDC provider should fail
    upsert_oidc_provider_for_next_epoch(
        &aptos_framework,
        b"https://accounts.google.com",
        b"https://accounts.google.com/.well-known/openid-configuration"
    );
    // Should abort with EJWK_CONSENSUS_NOT_ENABLED
}

#[test(aptos_framework = @aptos_framework)]
fun test_state_inconsistency_current_behavior(aptos_framework: signer) acquires SupportedOIDCProviders, ObservedJWKs {
    initialize_for_test(&aptos_framework);
    
    // Currently succeeds even with feature disabled
    features::change_feature_flags_for_testing(
        &aptos_framework,
        vector[],
        vector[features::get_jwk_consensus_feature()]
    );
    
    // This succeeds and modifies on-chain state
    upsert_oidc_provider_for_next_epoch(
        &aptos_framework,
        b"https://accounts.google.com",
        b"https://accounts.google.com/.well-known/openid-configuration"
    );
    
    // Verify provider is stored on-chain
    let providers = borrow_global<SupportedOIDCProviders>(@aptos_framework);
    assert!(vector::length(&providers.providers) == 1, 1);
    
    // But JWK consensus config would return Off due to disabled feature
    // This demonstrates the state inconsistency
}
```

**Notes:**
While this is a valid governance safety issue causing state inconsistencies, it requires governance control to execute. Per the Aptos trust model, governance participants are considered trusted actors. An unprivileged attacker cannot exploit this without first gaining governance voting power through legitimate stake and voting mechanisms. The issue represents a governance UX problem and safety gap rather than a direct security vulnerability exploitable by untrusted actors.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/oidc_providers.rs (L21-48)
```rust
pub fn generate_oidc_provider_ops_proposal(
    ops: &[OidcProviderOp],
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> anyhow::Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::jwks"],
        |writer| {
            for op in ops {
                write_op(writer, signer_arg, op);
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("oidc-provider-ops".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L352-363)
```text
    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };
        let ret = remove_oidc_provider_internal(&mut provider_set, name);
        config_buffer::upsert(provider_set);
        ret
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-195)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
        };
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L111-132)
```rust
/// Before `JWKConsensusConfig` is initialized, convert from `Features` and `SupportedOIDCProviders` instead.
impl From<(Option<Features>, Option<SupportedOIDCProviders>)> for OnChainJWKConsensusConfig {
    fn from(
        (features, supported_oidc_providers): (Option<Features>, Option<SupportedOIDCProviders>),
    ) -> Self {
        if let Some(features) = features {
            if features.is_enabled(FeatureFlag::JWK_CONSENSUS) {
                let oidc_providers = supported_oidc_providers
                    .unwrap_or_default()
                    .providers
                    .into_iter()
                    .filter_map(|deprecated| OIDCProvider::try_from(deprecated).ok())
                    .collect();
                OnChainJWKConsensusConfig::V1(ConfigV1 { oidc_providers })
            } else {
                OnChainJWKConsensusConfig::Off
            }
        } else {
            OnChainJWKConsensusConfig::Off
        }
    }
}
```
