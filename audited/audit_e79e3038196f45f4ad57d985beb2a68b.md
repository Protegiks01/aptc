# Audit Report

## Title
Consensus Observer Root Manipulation via Unverified Future-Epoch CommitDecision Messages

## Summary
The consensus observer's message processing flow updates the root ledger info with unverified future-epoch commit decisions before state sync validates them. If validation fails, the corrupted root causes all subsequent valid messages to be rejected, breaking the observer's ability to track blockchain state.

## Finding Description

When a consensus observer receives a `CommitDecision` message for a future epoch from a subscribed network peer, the code bypasses signature verification and immediately updates the root ledger info before any validation occurs.

**Attack Flow:**

1. An attacker operating as a subscribed network peer sends a `CommitDecision` message with:
   - `commit_epoch` greater than the current epoch
   - Invalid or forged BLS signatures in the `LedgerInfoWithSignatures`

2. In `process_commit_decision_message()`, the epoch check fails because `commit_epoch != epoch_state.epoch`, causing signature verification to be completely skipped: [1](#0-0) 

3. The code detects a future epoch/round and calls `update_blocks_for_state_sync_commit()` without any prior verification: [2](#0-1) 

4. This function immediately updates the root with the unverified commit: [3](#0-2) 

5. The `update_root()` function performs no validation: [4](#0-3) 

6. State sync is then initiated, which will verify signatures using the current epoch state and fail for invalid signatures: [5](#0-4) 

7. When state sync fails, the error is only logged and the root remains corrupted: [6](#0-5) 

8. The corrupted root causes all subsequent valid `CommitDecision` messages to be rejected as "old": [7](#0-6) 

The code contains a TODO acknowledging this gap: [8](#0-7) 

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria - Validator Node Issues)

This vulnerability affects consensus observer nodes (used by validator fullnodes and other infrastructure nodes). While it does not directly compromise consensus validators or enable chain splits, it causes significant operational issues:

1. **Observer State Corruption**: The consensus observer's view of blockchain state becomes permanently corrupted until manual intervention or fallback sync (which may take significant time).

2. **Loss of Synchronization**: Once corrupted, the observer rejects all legitimate commit decisions, preventing it from tracking the real blockchain state.

3. **Infrastructure Impact**: Validator fullnodes use consensus observers to efficiently receive consensus updates. Corrupted observers impact their ability to serve queries, provide state sync data, and maintain accurate blockchain views.

4. **No Automatic Recovery**: The error is only logged with no notification mechanism to trigger recovery. The node continues operating with corrupted state.

Note: This does NOT qualify as "Consensus/Safety Violations (Critical)" because it affects observer nodes, not consensus validators themselves. It does not cause validators to commit different blocks, enable double-spending, or create chain splits.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Low Barrier to Entry**: Attacker only needs to be a network peer that the consensus observer subscribes to (no validator keys or stake required).

2. **Deterministic Trigger**: The vulnerability triggers 100% of the time when a future-epoch `CommitDecision` with invalid signatures is received.

3. **No Authentication of Message Content**: While messages must come from subscribed peers, the peer itself can be any network participant, and message content signatures are not verified before root update.

4. **Active Deployment**: Consensus observers are enabled by default on validator fullnodes, making this a real production attack surface.

## Recommendation

Verify commit decision signatures BEFORE updating the root, or implement proper error handling to revert the root if state sync validation fails:

```rust
// Option 1: Delay root update until after state sync succeeds
// Only call update_root() in process_commit_sync_notification() after 
// successful sync validation

// Option 2: Implement recovery mechanism in state sync error handling
if let Err(error) = execution_client
    .clone()
    .sync_to_target(commit_decision.commit_proof().clone())
    .await
{
    error!(/* log error */);
    // Add: Revert corrupted root or trigger fallback sync
    return;
}
```

Additionally, for future-epoch commits where the current epoch state cannot verify signatures, either:
- Request epoch change proofs before accepting future-epoch commits
- Implement a pending queue for unverified future-epoch commits until epoch transition

## Proof of Concept

A PoC would require setting up a consensus observer, establishing a subscription, and sending a malformed `CommitDecision` message with a future epoch and invalid signatures. The observer's root would be corrupted, and all subsequent legitimate messages would be rejected.

```rust
// Pseudocode PoC structure
let malicious_commit = CommitDecision::new(
    LedgerInfoWithSignatures::new(
        future_epoch_ledger_info,
        invalid_signatures, // Forged or empty signatures
    )
);

// Send via network to subscribed consensus observer
// Observer will:
// 1. Skip signature verification (future epoch)
// 2. Update root to malicious commit
// 3. Attempt state sync (will fail due to invalid signatures)
// 4. Root remains corrupted
// 5. All future valid messages rejected
```

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L452-461)
```rust
        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L468-482)
```rust
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L503-522)
```rust
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L299-302)
```rust
    /// Updates the root ledger info
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L101-110)
```rust
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L218-231)
```rust
                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }
```
