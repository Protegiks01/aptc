# Audit Report

## Title
Phantom Distribution Events in Staking Contract Due to Pending Active Stake Mismatch

## Summary
The `request_commission_internal` function in `staking_contract.move` calculates commission based on total active stake (including `pending_active`), but the subsequent `unlock_with_cap` operation can only unlock from the `active` pool. This creates phantom distributions where `AddDistributionEvent` reports amounts exceeding what was actually unlocked, causing the `distribution_pool.total_coins` to exceed actual `pending_inactive` coins in the stake pool.

## Finding Description

The vulnerability occurs in the commission request flow: [1](#0-0) 

The `get_staking_contract_amounts_internal` function calculates `commission_amount` based on `total_active_stake = active + pending_active`. This commission amount is then used in `request_commission_internal`: [2](#0-1) 

The function calls `add_distribution` with the full `commission_amount`, which updates `distribution_pool.total_coins` via `pool_u64::buy_in`: [3](#0-2) [4](#0-3) 

However, the subsequent `stake::unlock_with_cap` call **caps the unlock amount** to available `active` stake only: [5](#0-4) 

**Attack Scenario:**
1. Staking contract has: `active = 50 APT`, `pending_active = 1000 APT`, `principal = 100 APT`, `commission = 50%`
2. Commission calculated: `(1050 - 100) * 50% = 475 APT`
3. `add_distribution(475)` sets `distribution_pool.total_coins = 475 APT`
4. `AddDistributionEvent` emits `amount = 475 APT`
5. `unlock_with_cap(475)` caps to `min(475, 50) = 50 APT`
6. **Result:** `distribution_pool.total_coins = 475 APT`, but actual `pending_inactive = 50 APT`

The Rosetta API reads `AddDistributionEvent` and reports 475 APT distributed, while only 50 APT exists. When `distribute_internal` is later called, shareholders lose ~89% of expected value.

**Contrast with `unlock_stake`:** [6](#0-5) 

The `unlock_stake` function correctly caps the amount **before** calling `add_distribution`, preventing this issue.

## Impact Explanation

**High Severity** - This breaks the fundamental accounting invariant that `distribution_pool.total_coins` must match distributable stake pool coins. 

**Impacts:**
1. **Incorrect Reward Reporting**: Rosetta API reports phantom distributions that never occurred, breaking external integrations and analytics
2. **Loss of Funds**: Distribution pool shareholders receive far less than expected when `distribute()` is called
3. **State Inconsistency**: The distribution pool accounting diverges from actual stake pool state, requiring manual intervention
4. **Validator Economics**: Operators receive inflated share allocations in the distribution pool without corresponding coins backing them

This qualifies as **High Severity** per bug bounty criteria: "Significant protocol violations" and "State inconsistencies requiring intervention."

## Likelihood Explanation

**High Likelihood** - This occurs naturally in normal validator operations:

1. **Common Scenario**: Validators frequently have large `pending_active` when stakers add stake mid-epoch
2. **Automatic Trigger**: Commission requests are routine operations - operators request commission regularly
3. **No Special Conditions**: Requires no malicious intent, just normal staking contract usage
4. **Amplified by High Commission**: Higher commission percentages (50-100%) increase the discrepancy

**Example Timeline:**
- Day 1: Staker adds 1000 APT mid-epoch â†’ goes to `pending_active`
- Day 2: Operator requests commission before epoch transition
- Result: Phantom distribution created immediately

## Recommendation

Add validation in `request_commission_internal` to cap `commission_amount` to available `active` stake before calling `add_distribution`, similar to how `unlock_stake` handles it:

```move
fun request_commission_internal(
    operator: address,
    staking_contract: &mut StakingContract,
    add_distribution_events: &mut EventHandle<AddDistributionEvent>,
    request_commission_events: &mut EventHandle<RequestCommissionEvent>
): u64 {
    let (total_active_stake, accumulated_rewards, commission_amount) =
        get_staking_contract_amounts_internal(staking_contract);
    staking_contract.principal = total_active_stake - commission_amount;

    if (commission_amount == 0) {
        return 0
    };

    // FIX: Cap commission amount to available active stake
    let (active, _, _, _) = stake::get_stake(staking_contract.pool_address);
    if (active < commission_amount) {
        commission_amount = active;
        // Adjust principal to reflect actual commission being taken
        staking_contract.principal = total_active_stake - commission_amount;
    };

    add_distribution(
        operator,
        staking_contract,
        operator,
        commission_amount,
        add_distribution_events
    );

    stake::unlock_with_cap(commission_amount, &staking_contract.owner_cap);
    
    // ... rest of function
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, staker = @0x123, operator = @0x456)]
public entry fun test_phantom_distribution_with_pending_active(
    aptos_framework: &signer,
    staker: &signer,
    operator: &signer,
) {
    // Setup staking contract
    setup(aptos_framework, staker, operator, 100_000_000); // 1M APT
    
    // Create staking contract with 100 APT and 50% commission
    staking_contract::create_staking_contract(
        staker,
        signer::address_of(operator),
        signer::address_of(operator),
        100_00000000, // 100 APT
        50,           // 50% commission
        x"01"
    );
    
    let pool_addr = staking_contract::stake_pool_address(
        signer::address_of(staker),
        signer::address_of(operator)
    );
    
    // Join validator set and generate rewards
    stake::join_validator_set(operator, pool_addr);
    end_epoch(); // Rewards accrue to active
    
    // Simulate large pending_active by adding stake mid-epoch
    staking_contract::add_stake(staker, signer::address_of(operator), 950_00000000); // 950 APT
    // This goes to pending_active, active is still ~100 APT
    
    // Request commission - this should trigger the vulnerability
    staking_contract::request_commission(
        operator,
        signer::address_of(staker),
        signer::address_of(operator)
    );
    
    let (active, _, _, pending_inactive) = stake::get_stake(pool_addr);
    let dist_count = staking_contract::pending_distribution_counts(
        signer::address_of(staker),
        signer::address_of(operator)
    );
    
    // VULNERABILITY: pending_inactive < expected commission
    // Commission should be ~475 APT based on (1050-100)*50%
    // But only ~100 APT can be unlocked from active
    assert!(pending_inactive < 475_00000000, 0);
    assert!(pending_inactive <= active, 1); // Can only unlock what's in active
    
    // Distribution pool believes it has more coins than actually exist
    // AddDistributionEvent emitted 475 APT but only ~100 APT unlocked
}
```

**Notes:**

The vulnerability creates a systematic accounting mismatch between Rosetta's view of reward distributions (based on events) and actual stake pool state. This breaks critical invariant: **Staking Security - Validator rewards must be calculated correctly**. The issue specifically affects the `request_commission` path while `unlock_stake` correctly handles the same scenario, indicating an inconsistency in the codebase that violates deterministic execution principles when commission percentages are applied to mixed active/pending_active stakes.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L674-726)
```text
    fun request_commission_internal(
        operator: address,
        staking_contract: &mut StakingContract,
        add_distribution_events: &mut EventHandle<AddDistributionEvent>,
        request_commission_events: &mut EventHandle<RequestCommissionEvent>
    ): u64 {
        // Unlock just the commission portion from the stake pool.
        let (total_active_stake, accumulated_rewards, commission_amount) =
            get_staking_contract_amounts_internal(staking_contract);
        staking_contract.principal = total_active_stake - commission_amount;

        // Short-circuit if there's no commission to pay.
        if (commission_amount == 0) {
            return 0
        };

        // Add a distribution for the operator.
        add_distribution(
            operator,
            staking_contract,
            operator,
            commission_amount,
            add_distribution_events
        );

        // Request to unlock the commission from the stake pool.
        // This won't become fully unlocked until the stake pool's lockup expires.
        stake::unlock_with_cap(commission_amount, &staking_contract.owner_cap);

        let pool_address = staking_contract.pool_address;
        if (std::features::module_event_migration_enabled()) {
            emit(
                RequestCommission {
                    operator,
                    pool_address,
                    accumulated_rewards,
                    commission_amount
                }
            );
        } else {
            emit_event(
                request_commission_events,
                RequestCommissionEvent {
                    operator,
                    pool_address,
                    accumulated_rewards,
                    commission_amount
                }
            );
        };

        commission_amount
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L761-780)
```text
        // If there's less active stake remaining than the amount requested (potentially due to commission),
        // only withdraw up to the active amount.
        let (active, _, _, _) = stake::get_stake(staking_contract.pool_address);
        if (active < amount) {
            amount = active;
        };
        staking_contract.principal = staking_contract.principal - amount;

        // Record a distribution for the staker.
        add_distribution(
            operator,
            staking_contract,
            staker_address,
            amount,
            &mut store.add_distribution_events
        );

        // Request to unlock the distribution amount from the stake pool.
        // This won't become fully unlocked until the stake pool's lockup expires.
        stake::unlock_with_cap(amount, &staking_contract.owner_cap);
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1027-1054)
```text
    fun add_distribution(
        operator: address,
        staking_contract: &mut StakingContract,
        recipient: address,
        coins_amount: u64,
        add_distribution_events: &mut EventHandle<AddDistributionEvent>
    ) {
        let distribution_pool = &mut staking_contract.distribution_pool;
        let (_, _, _, total_distribution_amount) =
            stake::get_stake(staking_contract.pool_address);
        update_distribution_pool(
            distribution_pool,
            total_distribution_amount,
            operator,
            staking_contract.commission_percentage
        );

        pool_u64::buy_in(distribution_pool, recipient, coins_amount);
        let pool_address = staking_contract.pool_address;
        if (std::features::module_event_migration_enabled()) {
            emit(AddDistribution { operator, pool_address, amount: coins_amount });
        } else {
            emit_event(
                add_distribution_events,
                AddDistributionEvent { operator, pool_address, amount: coins_amount }
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1057-1072)
```text
    fun get_staking_contract_amounts_internal(
        staking_contract: &StakingContract
    ): (u64, u64, u64) {
        // Pending_inactive is not included in the calculation because pending_inactive can only come from:
        // 1. Outgoing commissions. This means commission has already been extracted.
        // 2. Stake withdrawals from stakers. This also means commission has already been extracted as
        // request_commission_internal is called in unlock_stake
        let (active, _, pending_active, _) =
            stake::get_stake(staking_contract.pool_address);
        let total_active_stake = active + pending_active;
        let accumulated_rewards = total_active_stake - staking_contract.principal;
        let commission_amount =
            accumulated_rewards * staking_contract.commission_percentage / 100;

        (total_active_stake, accumulated_rewards, commission_amount)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/pool_u64.move (L134-145)
```text
    public fun buy_in(self: &mut Pool, shareholder: address, coins_amount: u64): u64 {
        if (coins_amount == 0) return 0;

        let new_shares = self.amount_to_shares(coins_amount);
        assert!(MAX_U64 - self.total_coins >= coins_amount, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));
        assert!(MAX_U64 - self.total_shares >= new_shares, error::invalid_argument(EPOOL_TOTAL_COINS_OVERFLOW));

        self.total_coins += coins_amount;
        self.total_shares += new_shares;
        self.add_shares(shareholder, new_shares);
        new_shares
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1117-1150)
```text
    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
        assert_reconfig_not_in_progress();
        // Short-circuit if amount to unlock is 0 so we don't emit events.
        if (amount == 0) {
            return
        };

        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into
        // inactive in the earliest possible epoch transition.
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Cap amount to unlock by maximum active stake.
        let amount = min(amount, coin::value(&stake_pool.active));
        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UnlockStake {
                    pool_address,
                    amount_unlocked: amount,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.unlock_stake_events,
                UnlockStakeEvent {
                    pool_address,
                    amount_unlocked: amount,
                },
            );
        };
    }
```
