# Audit Report

## Title
IP Address Normalization Bypass Allows Rate Limit Evasion in Faucet Redis Rate Limiter

## Summary
The Redis rate limiter in the Aptos faucet does not normalize IP addresses before using them as rate limit keys. This allows attackers with dual-stack connectivity to bypass daily rate limits by alternating between IPv4 and IPv4-mapped IPv6 address representations (e.g., `192.0.2.1` vs `::ffff:192.0.2.1`), effectively multiplying their allowed request quota.

## Finding Description
The vulnerability exists in the `ratelimit_key_value()` function which directly converts the source IP address to a string without normalization: [1](#0-0) 

The `source_ip` field in `CheckerData` is of type `IpAddr`: [2](#0-1) 

This string representation is then used to construct the Redis key for rate limiting: [3](#0-2) 

The problem is that IPv4 addresses and their IPv4-mapped IPv6 equivalents produce different string representations:
- IPv4 `192.0.2.1` → key: `ip:192.0.2.1:12345`
- IPv4-mapped IPv6 `::ffff:192.0.2.1` → key: `ip:::ffff:192.0.2.1:12345`

These are different Redis keys, resulting in separate rate limit counters. An attacker can exploit this by:
1. Exhausting the rate limit using IPv4 address
2. Switching to IPv6 dual-stack connection (appears as IPv4-mapped IPv6)
3. Receiving a fresh rate limit counter
4. Repeating to bypass limits indefinitely

The IP address is extracted from the request without normalization: [4](#0-3) 

## Impact Explanation
This vulnerability qualifies as **Medium severity** per the Aptos bug bounty program criteria:
- **Limited funds loss**: Allows attackers to drain faucet funds faster than the configured rate limits intend
- **Resource abuse**: Bypasses the resource limit invariant that rate limits are meant to enforce
- **Denial of service**: Legitimate users may be denied service if attackers exhaust faucet funds more quickly

The impact is limited to the faucet service and does not affect consensus, validator operations, or the main blockchain. However, it directly undermines the rate limiting mechanism designed to prevent abuse.

## Likelihood Explanation
The likelihood is **Medium to High**:
- **Attacker requirements**: Only needs dual-stack (IPv4 + IPv6) network connectivity, which is increasingly common
- **Complexity**: Low - attacker simply needs to alternate connections or control proxy headers
- **Detection difficulty**: May go unnoticed as requests appear to come from different addresses
- **Exploitability**: If the faucet accepts direct connections or if upstream proxies don't normalize IPs, exploitation is straightforward

The main limiting factor is whether the attacker has dual-stack connectivity or can influence how their IP appears in request headers.

## Recommendation
Normalize IP addresses before using them as rate limit keys. Specifically, convert IPv4-mapped IPv6 addresses to their IPv4 equivalents:

```rust
pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
    match self {
        RatelimitKeyProvider::Ip => {
            // Normalize IPv4-mapped IPv6 addresses to IPv4
            let normalized_ip = match data.source_ip {
                IpAddr::V6(ipv6) => {
                    // Check if this is an IPv4-mapped IPv6 address (::ffff:x.x.x.x)
                    if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                        IpAddr::V4(ipv4)
                    } else {
                        IpAddr::V6(ipv6)
                    }
                },
                ip => ip,
            };
            Ok(normalized_ip.to_string())
        },
        RatelimitKeyProvider::Jwt(jwt_verifier) => {
            jwt_verifier.validate_jwt(data.headers.clone()).await
        },
    }
}
```

Additionally, consider stripping any IPv6 zone identifiers if they can appear in the parsed addresses, though the standard Rust `IpAddr` type doesn't preserve zone identifiers during parsing.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

    #[test]
    fn test_ipv4_mapped_ipv6_creates_different_keys() {
        // Same actual host, different representations
        let ipv4 = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 1));
        let ipv4_mapped_ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x201));
        
        let key_ipv4 = ipv4.to_string();
        let key_ipv6 = ipv4_mapped_ipv6.to_string();
        
        // These produce different strings, thus different Redis keys
        assert_eq!(key_ipv4, "192.0.2.1");
        assert_eq!(key_ipv6, "::ffff:192.0.2.1");
        assert_ne!(key_ipv4, key_ipv6);
        
        // In Redis, this would create two separate counters:
        // ip:192.0.2.1:12345
        // ip:::ffff:192.0.2.1:12345
        
        println!("IPv4 key: {}", key_ipv4);
        println!("IPv4-mapped IPv6 key: {}", key_ipv6);
        println!("Attacker can bypass rate limits by switching between these!");
    }
}
```

To run this proof of concept:
1. Add this test to `crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs`
2. Run: `cargo test test_ipv4_mapped_ipv6_creates_different_keys`
3. Observe that the two representations produce different string keys

### Citations

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L186-200)
```rust
    fn get_key_and_secs_until_next_day(
        &self,
        ratelimit_key_prefix: &str,
        ratelimit_key_value: &str,
    ) -> (String, u64) {
        let now_secs = get_current_time_secs();
        let seconds_until_next_day = seconds_until_next_day(now_secs);
        let key = format!(
            "{}:{}:{}",
            ratelimit_key_prefix,
            ratelimit_key_value,
            days_since_tap_epoch(now_secs)
        );
        (key, seconds_until_next_day)
    }
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L148-153)
```rust
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-241)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };

        let receiver = match fund_request.receiver() {
            Some(receiver) => receiver,
            None => {
                return Err(AptosTapError::new(
                    "Account address, auth key, or pub key must be provided and valid".to_string(),
                    AptosTapErrorCode::InvalidRequest,
                ))
            },
        };

        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
```
