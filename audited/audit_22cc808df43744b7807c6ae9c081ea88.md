# Audit Report

## Title
Cryptographic Soundness Violation in Zeromorph batch_open() - Challenge Derivation Before Commitment Binding

## Summary
The `batch_open()` function in the Zeromorph polynomial commitment scheme implementation derives the batching challenge `gamma` from the transcript before any polynomial commitments are added to it, violating the Fiat-Shamir security requirement and breaking the soundness proof of batch opening.

## Finding Description

The `batch_open()` function violates cryptographic soundness by deriving the verifier challenge before binding it to commitments. [1](#0-0) 

The function immediately derives the batching challenge `gamma` at line 544 using `trs.challenge_scalar()` without first adding the polynomial commitments to the transcript. 

**Expected Batch Opening Protocol:**
1. Prover computes commitments C₁, ..., Cₙ for polynomials f₁, ..., fₙ
2. Commitments are added to the transcript
3. Challenge γ is derived from transcript (containing commitments via Fiat-Shamir)
4. Batched polynomial computed: f = Σ γⁱ·fᵢ
5. Opening proof generated for combined polynomial

**Actual Implementation:**
1. Challenge γ derived immediately (line 544)
2. Batched polynomial computed with γ
3. Opening proof generated

This breaks the binding between the challenge and specific commitments. The trait signature itself acknowledges this issue: [2](#0-1) 

Note the commented-out parameter `//   coms: Vec<Commitment>,` at line 46, indicating awareness that commitments should be involved but aren't properly integrated.

**Cryptographic Impact:** Without commitments in the transcript before challenge derivation, the soundness reduction proof fails. An adversary could potentially:
- Manipulate transcript state before calling `batch_open()`
- Choose polynomials with algebraic relationships that exploit known γ
- Break the statistical binding between γ and commitments required for soundness

## Impact Explanation

**However, this code is explicitly marked as experimental:** [3](#0-2) 

And the trait is marked as work-in-progress: [4](#0-3) 

**Critical Limitation:** This code is **NOT used in production**. The actual Aptos DKG system uses PVSS (Publicly Verifiable Secret Sharing) with `WeightedTranscript`, not this polynomial commitment scheme: [5](#0-4) 

The Zeromorph implementation appears only in benchmarks and is not integrated into any consensus, randomness, or DKG production paths. Therefore, this vulnerability has **no actual production impact** on Aptos validators or the network.

## Likelihood Explanation

Likelihood: **Not Applicable** - The code is experimental and unused in production.

While the cryptographic flaw is real and would be exploitable if this code were deployed, it currently poses no threat to the Aptos network because:
1. Zeromorph is not called by any production code
2. The DKG system uses a different cryptographic primitive (PVSS)
3. The code is explicitly marked for benchmarking only

## Recommendation

Since this is experimental code marked "NOT YET BEEN VETTED," the immediate recommendation is to **maintain the current status** (not using it in production).

If this code is to be production-ready in the future, fix the protocol by:

1. **Modify the trait signature** to accept commitments:
```rust
fn batch_open<R: RngCore + CryptoRng>(
    ck: Self::CommitmentKey,
    polys: Vec<Self::Polynomial>,
    coms: Vec<Self::Commitment>,  // Add this parameter
    challenge: Vec<Self::WitnessField>,
    rs: Option<Vec<Self::WitnessField>>,
    rng: &mut R,
    trs: &mut merlin::Transcript,
) -> Self::Proof;
```

2. **Update implementation** to add commitments to transcript before deriving gamma:
```rust
// Add commitments to transcript FIRST
for com in coms.iter() {
    trs.append_point(&com.0);
}

// THEN derive challenge
let gamma = trs.challenge_scalar();
```

## Proof of Concept

**N/A** - Since this code is not used in production and is explicitly marked as experimental/unvetted, a proof of concept would only demonstrate a vulnerability in unused code. The cryptographic flaw is evident from the code structure itself.

---

## Notes

**Important Context:** While this is a genuine cryptographic soundness issue, it fails the validation checklist requirement for "Clear security harm demonstrated" because:

1. The code is marked "NOT YET BEEN VETTED, ONLY USE FOR BENCHMARKING PURPOSES"
2. It is not integrated into any production Aptos systems
3. The actual DKG implementation uses different cryptography (PVSS)
4. No validator nodes or consensus components depend on this code

The Aptos development team has appropriately marked this as experimental code, preventing any production security impact. This represents responsible development practice rather than a deployed vulnerability.

### Citations

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L6-6)
```rust
// THIS CODE HAS NOT YET BEEN VETTED, ONLY USE FOR BENCHMARKING PURPOSES!!!!!
```

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L533-562)
```rust
    fn batch_open<R: RngCore + CryptoRng>(
        ck: Self::CommitmentKey,
        polys: Vec<Self::Polynomial>,
        //   coms: Vec<Commitment>,
        challenge: Vec<Self::WitnessField>,
        rs: Option<Vec<Self::WitnessField>>,
        rng: &mut R,
        trs: &mut merlin::Transcript,
    ) -> Self::Proof {
        let rs = rs.expect("rs must be present");

        let gamma = trs.challenge_scalar();
        let gammas = powers(gamma, polys.len());

        let combined_poly = polys
            .iter()
            .zip(gammas.iter())
            .fold(Self::Polynomial::zero(), |acc, (poly, gamma_i)| {
                acc + poly * gamma_i
            });
        let eval = Self::evaluate_point(&combined_poly, &challenge);

        let s = rs
            .iter()
            .zip(gammas.iter())
            .fold(Self::WitnessField::zero(), |acc, (r, gamma_i)| {
                acc + (*r * gamma_i)
            });

        Zeromorph::open(&ck, &combined_poly, &challenge, eval, Scalar(s), rng, trs)
```

**File:** crates/aptos-dkg/src/pcs/traits.rs (L6-6)
```rust
// TODO: This trait is still very much a work in progress
```

**File:** crates/aptos-dkg/src/pcs/traits.rs (L43-51)
```rust
    fn batch_open<R: RngCore + CryptoRng>(
        ck: Self::CommitmentKey,
        polys: Vec<Self::Polynomial>,
        //   coms: Vec<Commitment>,
        challenge: Vec<Self::WitnessField>,
        rs: Option<Vec<Self::WitnessField>>,
        rng: &mut R,
        trs: &mut merlin::Transcript,
    ) -> Self::Proof;
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-41)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
pub type DkgPP = <WTrx as Transcript>::PublicParameters;
pub type SSConfig = <WTrx as Transcript>::SecretSharingConfig;
pub type EncPK = <WTrx as Transcript>::EncryptPubKey;
```
