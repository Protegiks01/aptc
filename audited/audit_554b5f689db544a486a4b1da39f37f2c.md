# Audit Report

## Title
Transaction Hash Loss for Encrypted Transactions Due to Post-Mempool Conversion Failure

## Summary

The `create()` function in `api/src/transactions.rs` can fail to return transaction hash information to users after successfully accepting their transaction into mempool. This occurs when encrypted transactions are submitted with BCS encoding but JSON response format is requested, causing `try_into_pending_transaction_poem()` to fail after mempool has already accepted the transaction.

## Finding Description

The vulnerability exists in the transaction submission flow where there is a temporal gap between mempool acceptance and response generation: [1](#0-0) 

When a user submits an encrypted transaction:
1. The transaction passes validation if `allow_encrypted_txns_submission` is enabled: [2](#0-1) 

2. The transaction is successfully submitted to mempool at line 1500, returning `Ok(())`

3. For JSON accept types, the code attempts to convert to `PendingTransaction` to provide the transaction hash to the user (as noted in the comment at line 1515)

4. However, `try_into_pending_transaction_poem()` calls `try_into_transaction_payload()`, which unconditionally fails for encrypted payloads: [3](#0-2) 

5. This failure is returned as an `InternalError` to the user, but **the transaction remains in mempool and will be processed**

6. The user receives an error response without the transaction hash, losing the ability to track their transaction

The transaction hash is critical for users because it's generated as: [4](#0-3) 

Without this hash, users cannot:
- Query transaction status via `/transactions/by_hash/:txn_hash`
- Monitor transaction execution
- Debug transaction failures
- Confirm transaction inclusion in blocks

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria due to:

1. **User Experience Degradation**: Users lose critical transaction tracking capability, violating the API contract that successful submissions return transaction hashes
2. **Potential Duplicate Submissions**: Users may resubmit thinking the transaction failed, potentially causing unintended state changes or loss of funds
3. **State Inconsistency**: Transaction is accepted by system but API indicates failure, creating inconsistent state from user perspective
4. **Limited Scope**: Only affects encrypted transactions when nodes have `allow_encrypted_txns_submission` enabled

While not directly causing consensus or fund loss, this creates operational issues requiring intervention and could indirectly lead to fund loss through duplicate submissions.

## Likelihood Explanation

**Likelihood: Medium-to-Low** under current conditions:

**Prerequisites:**
- Node must have `allow_encrypted_txns_submission` config flag enabled
- User must submit an encrypted transaction (advanced feature)
- User must request JSON response format (`Accept: application/json`) while submitting BCS payload
- The inconsistency between validation allowing encrypted payloads and conversion rejecting them must exist

**Realistic Scenarios:**
- SDK developers testing encrypted transaction features
- Advanced users leveraging BCS for efficiency but wanting JSON responses for parsing
- Automated systems mixing BCS submission with JSON response handling

**Current State:**
The comment "Encrypted payload isn't supported yet" suggests incomplete feature implementation, but the validation code allows encrypted transactions when configured, creating the vulnerability window.

## Recommendation

**Immediate Fix:** Align validation with conversion capabilities. Either:

**Option 1 (Conservative):** Reject encrypted transactions in `try_into_pending_transaction_poem()` early, before mempool submission:

```rust
// In api/src/transactions.rs, around line 1496
async fn create(
    &self,
    accept_type: &AcceptType,
    ledger_info: &LedgerInfo,
    txn: SignedTransaction,
) -> SubmitTransactionResult<PendingTransaction> {
    // For JSON accept type, verify we can convert before submitting to mempool
    if *accept_type == AcceptType::Json {
        let state_view = self.context.latest_state_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| {
                SubmitTransactionError::internal_with_code(
                    e,
                    AptosErrorCode::InternalError,
                    ledger_info,
                )
            })?;
        
        // Pre-validate conversion capability
        state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .try_into_transaction_payload(txn.payload().clone())
            .context("Transaction payload cannot be converted to JSON format")
            .map_err(|err| SubmitTransactionError::bad_request_with_code(
                err,
                AptosErrorCode::InvalidInput,
                ledger_info,
            ))?;
    }
    
    match self.create_internal(txn.clone()).await {
        // ... rest of existing code
```

**Option 2 (Feature-complete):** Implement proper encrypted payload conversion support in `try_into_transaction_payload()` to match the validation's acceptance.

**Additional Safeguard:** Add validation that `accept_type` is `Bcs` when encrypted payloads are submitted, since JSON conversion is unsupported.

## Proof of Concept

```rust
#[tokio::test]
async fn test_encrypted_transaction_hash_loss() {
    use aptos_api_test_context::{new_test_context, TestContext};
    use aptos_types::transaction::{
        RawTransaction, SignedTransaction, TransactionPayload,
        encrypted_payload::EncryptedPayload,
    };
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    
    // Setup test context with encrypted transaction submission enabled
    let mut context = new_test_context().await;
    context.node_config.api.allow_encrypted_txns_submission = true;
    
    // Create an encrypted transaction
    let sender_key = Ed25519PrivateKey::generate_for_testing();
    let sender = aptos_types::account_address::AccountAddress::random();
    
    // Create encrypted payload (simplified for PoC)
    let encrypted_payload = EncryptedPayload::new_for_testing(
        sender,
        vec![1, 2, 3, 4], // dummy encrypted data
    );
    
    let raw_txn = RawTransaction::new(
        sender,
        0,
        TransactionPayload::EncryptedPayload(encrypted_payload),
        1000000,
        1,
        99999999999,
        context.chain_id(),
    );
    
    let signed_txn = SignedTransaction::new(
        raw_txn,
        sender_key.public_key(),
        sender_key.sign(&raw_txn.signing_message()).unwrap(),
    );
    
    // Serialize as BCS
    let bcs_payload = bcs::to_bytes(&signed_txn).unwrap();
    
    // Submit with JSON Accept header
    let response = context
        .post("/transactions")
        .header("Content-Type", "application/x.aptos.signed_transaction+bcs")
        .header("Accept", "application/json")
        .body(bcs_payload)
        .send()
        .await;
    
    // Vulnerability: Response is 500 Internal Error
    // but transaction is in mempool
    assert_eq!(response.status(), 500);
    
    // Verify transaction is actually in mempool
    let txn_hash = signed_txn.committed_hash();
    let mempool_txn = context.get_pending_transaction_by_hash(txn_hash).await;
    
    // Bug: Transaction is in mempool but user got error without hash
    assert!(mempool_txn.is_some(), "Transaction should be in mempool");
    
    // User cannot track transaction since they didn't receive the hash
}
```

## Notes

This vulnerability represents an architectural flaw where validation and conversion logic are inconsistent. The validation layer permits encrypted transactions when configured, but the response generation layer unconditionally rejects them. This creates a "transaction accepted but untrackable" state that violates the API contract and user expectations. The fix requires either completing the encrypted payload feature implementation or properly rejecting such transactions before mempool submission when JSON responses are requested.

### Citations

**File:** api/src/transactions.rs (L1323-1347)
```rust
            TransactionPayload::EncryptedPayload(payload) => {
                if !self.context.node_config.api.allow_encrypted_txns_submission {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted Transaction submission is not allowed yet",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if !payload.is_encrypted() {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted transaction must be in encrypted state",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
            },
```

**File:** api/src/transactions.rs (L1500-1524)
```rust
        match self.create_internal(txn.clone()).await {
            Ok(()) => match accept_type {
                AcceptType::Json => {
                    let state_view = self
                        .context
                        .latest_state_view()
                        .context("Failed to read latest state checkpoint from DB")
                        .map_err(|e| {
                            SubmitTransactionError::internal_with_code(
                                e,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            )
                        })?;

                    // We provide the pending transaction so that users have the hash associated
                    let pending_txn = state_view
                            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                            .try_into_pending_transaction_poem(txn)
                            .context("Failed to build PendingTransaction from mempool response, even though it said the request was accepted")
                            .map_err(|err| SubmitTransactionError::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            ))?;
```

**File:** api/types/src/convert.rs (L405-407)
```rust
            EncryptedPayload(_) => {
                bail!("Encrypted payload isn't supported yet")
            },
```

**File:** api/types/src/transaction.rs (L393-399)
```rust
impl From<(SignedTransaction, TransactionPayload)> for PendingTransaction {
    fn from((txn, payload): (SignedTransaction, TransactionPayload)) -> Self {
        PendingTransaction {
            request: (&txn, payload).into(),
            hash: txn.committed_hash().into(),
        }
    }
```
