# Audit Report

## Title
Keyless ZKP Verification Failure Due to Unvalidated Configuration Parameter Changes

## Summary
The Aptos keyless account system lacks validation and migration logic when the `max_commited_epk_bytes` configuration parameter is changed via governance. This causes all existing ZKP proofs to fail verification unexpectedly, breaking transaction validation for all keyless account users without any recovery mechanism.

## Finding Description

The keyless account verification system computes a public inputs hash during both proof generation and verification. This hash is computed using the `max_commited_epk_bytes` parameter from the on-chain `Configuration` resource. [1](#0-0) 

The circuit used to generate ZKP proofs has a hardcoded constant `MAX_COMMITED_EPK_BYTES` set to 93 bytes: [2](#0-1) 

During transaction validation, the validator fetches the current on-chain Configuration: [3](#0-2) 

And uses it to recompute the public inputs hash: [4](#0-3) 

**The Vulnerability:**

Governance can change the Configuration via `set_configuration_for_next_epoch`: [5](#0-4) 

The Move code documentation acknowledges this parameter change requires circuit changes: [6](#0-5) 

However, there is **no validation** that prevents governance from setting a different value, and **no migration logic** to handle existing proofs. When the configuration changes:

1. Existing ZKP proofs were generated with the old `max_commited_epk_bytes` value (93 bytes)
2. Validators recompute the public inputs hash using the new `max_commited_epk_bytes` value
3. The hashes don't match, causing all proof verifications to fail [7](#0-6) 

The same issue affects nonce reconstruction in OpenID signatures: [8](#0-7) 

## Impact Explanation

**Severity: High to Medium**

This vulnerability causes:

1. **Total liveness loss for keyless accounts**: All users with ZKP-based keyless accounts become unable to submit transactions
2. **No automatic recovery**: Users cannot generate new proofs unless the prover service has been updated with the new circuit
3. **Requires governance intervention**: The only recovery is another governance proposal to restore the original value or deploy an updated circuit
4. **State inconsistency during epoch transition**: If configuration changes take effect mid-epoch, different validators might apply different configurations

This meets the **High Severity** criteria of "Significant protocol violations" and potentially **Medium Severity** for "State inconsistencies requiring intervention."

The impact is particularly severe because:
- Keyless accounts may represent a significant portion of users
- There is no grace period or fallback mechanism
- Recovery requires coordinated governance action and potentially prover service redeployment

## Likelihood Explanation

**Likelihood: Medium to High**

This could occur through:

1. **Accidental misconfiguration**: A governance proposal attempting to "upgrade" keyless parameters without understanding the circuit dependency
2. **Incomplete upgrade process**: Attempting to change parameters before the prover service and circuit are ready
3. **Lack of awareness**: The Move code documents the requirement but provides no enforcement

The likelihood is elevated because:
- No validation prevents this from happening
- The governance process may not catch the incompatibility
- The Move code comments suggest changes are possible, which could mislead proposal authors

## Recommendation

Implement validation and versioning to prevent incompatible configuration changes:

**Option 1: Add validation in the Move module**

Add a check in `set_configuration_for_next_epoch` to ensure `max_commited_epk_bytes` matches the expected circuit constant. This requires storing the expected value on-chain or validating it against a known constant.

**Option 2: Implement configuration versioning**

Add a version field to the Configuration struct that ties it to a specific circuit version. Only allow changes to non-circuit-dependent fields, or require a coordinated upgrade that:
1. Deploys new circuit and prover service
2. Sets new verification key
3. Updates configuration atomically
4. Potentially supports multiple concurrent configurations during a transition period

**Option 3: Add migration period**

Implement a grace period where both old and new configurations are accepted, allowing users time to obtain new proofs.

**Recommended immediate fix:**

Add a validation function in the Move module:

```move
public fun validate_configuration_change(old_config: &Configuration, new_config: &Configuration) {
    // Circuit-dependent parameters must not change
    assert!(
        old_config.max_commited_epk_bytes == new_config.max_commited_epk_bytes,
        E_CIRCUIT_PARAMETER_CHANGE_NOT_ALLOWED
    );
    assert!(
        old_config.max_iss_val_bytes == new_config.max_iss_val_bytes,
        E_CIRCUIT_PARAMETER_CHANGE_NOT_ALLOWED
    );
    assert!(
        old_config.max_extra_field_bytes == new_config.max_extra_field_bytes,
        E_CIRCUIT_PARAMETER_CHANGE_NOT_ALLOWED
    );
    assert!(
        old_config.max_jwt_header_b64_bytes == new_config.max_jwt_header_b64_bytes,
        E_CIRCUIT_PARAMETER_CHANGE_NOT_ALLOWED
    );
}
```

Call this validation in `set_configuration_for_next_epoch` before allowing the change.

## Proof of Concept

**Test scenario demonstrating the vulnerability:**

```rust
// File: types/src/keyless/tests/configuration_change_test.rs

#[test]
fn test_proof_fails_after_config_change() {
    use crate::keyless::*;
    use aptos_crypto::poseidon_bn254;
    
    // Step 1: Create a valid ZKP proof with original config (93 bytes)
    let mut original_config = Configuration::new_for_testing();
    assert_eq!(original_config.max_commited_epk_bytes, 93);
    
    let epk = EphemeralPublicKey::ed25519(...); // sample EPK
    let sig = KeylessSignature { ... }; // sample signature with ZKP
    let pk = KeylessPublicKey { ... }; // sample public key
    let jwk = RSA_JWK { ... }; // sample JWK
    
    // Compute public inputs hash with original config
    let original_hash = get_public_inputs_hash(&sig, &pk, &jwk, &original_config).unwrap();
    
    // Step 2: Simulate governance changing the config parameter
    let mut modified_config = original_config.clone();
    modified_config.max_commited_epk_bytes = 96; // Changed value
    
    // Step 3: Recompute hash with modified config
    let modified_hash = get_public_inputs_hash(&sig, &pk, &jwk, &modified_config).unwrap();
    
    // Step 4: Demonstrate hashes are different
    assert_ne!(original_hash, modified_hash);
    
    // Step 5: Show proof verification would fail
    // The proof was created for original_hash but verification uses modified_hash
    // This will fail in verify_groth16_proof when called with modified_hash
    
    println!("Original hash: {}", original_hash);
    println!("Modified hash: {}", modified_hash);
    println!("Proof verification will fail with modified configuration!");
}
```

**Move integration test:**

```move
#[test(framework = @aptos_framework)]
#[expected_failure(abort_code = 0x10008)] // INVALID_SIGNATURE
fun test_zkp_fails_after_config_change(framework: &signer) {
    use aptos_framework::keyless_account;
    
    // Setup: Initialize with original config
    let original_config = keyless_account::new_configuration(
        vector[],
        3,
        10000000,
        option::none(),
        93,  // max_commited_epk_bytes
        120,
        350,
        300
    );
    keyless_account::update_configuration(framework, original_config);
    
    // Submit a valid transaction with ZKP proof (would succeed)
    // ...
    
    // Governance changes config
    let modified_config = keyless_account::new_configuration(
        vector[],
        3,
        10000000,
        option::none(),
        96,  // CHANGED: max_commited_epk_bytes
        120,
        350,
        300
    );
    keyless_account::set_configuration_for_next_epoch(framework, modified_config);
    
    // Trigger epoch change
    // ...
    
    // Attempt to submit the SAME transaction again
    // Expected: INVALID_SIGNATURE error because hash no longer matches
    // ...
}
```

This demonstrates that configuration parameter changes break existing ZKP proofs without any migration mechanism.

## Notes

The vulnerability is acknowledged in the Move code comments but not enforced programmatically. The system assumes coordination between circuit deployment, prover service updates, and on-chain configuration changes, but provides no safeguards when this coordination fails. A defensive design would validate that circuit-dependent parameters cannot be changed without a corresponding circuit upgrade and migration period.

### Citations

**File:** types/src/keyless/bn254_circom.rs (L331-334)
```rust
    let mut epk_frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
        epk.to_bytes().as_slice(),
        config.max_commited_epk_bytes as usize,
    )?;
```

**File:** types/src/keyless/circuit_constants.rs (L25-26)
```rust
pub(crate) const MAX_COMMITED_EPK_BYTES: u16 =
    3 * poseidon_bn254::keyless::BYTES_PACKED_PER_SCALAR as u16;
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L294-298)
```rust
        let keyless_configuration =
            Configuration::fetch_keyless_config(state_view).map(|(config, config_bytes)| {
                sha3_256.update(&config_bytes);
                config
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-316)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L103-110)
```text
        /// where `max_committed_epk_byte` is passed in as one of the witnesses to the circuit. As a result, (some)
        /// changes to this field could technically be handled by the same circuit: e.g., if we let the epk_i chunks
        /// exceed 31 bytes, but no more than 32, then `max_commited_epk_bytes` could now be in (93, 96]. Whether such a
        /// restricted set of changes is useful remains unclear. Therefore, the verdict will be that...
        ///
        /// If changed: (Likely) requires a circuit change because over-decreasing (or increasing) it leads to fewer (or
        ///   more) EPK chunks. This would break the current way the circuit hashes the nonce and the public inputs.
        ///   => prover service redeployment.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L274-277)
```text
    public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Configuration>(config);
    }
```

**File:** types/src/keyless/groth16_sig.rs (L229-233)
```rust
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
        // println!("Proof verification time: {:?}", start.elapsed());
        if !verified {
            bail!("groth16 proof verification failed")
        }
```

**File:** types/src/keyless/openid_sig.rs (L147-150)
```rust
        let mut frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
            epk.to_bytes().as_slice(),
            config.max_commited_epk_bytes as usize,
        )?;
```
