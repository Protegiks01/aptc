# Audit Report

## Title
Non-Deterministic Layout Validation Breaks Consensus Determinism in Transaction Execution

## Summary
The `randomly_check_layout_matches()` function in `aptos-move/aptos-vm-types/src/change_set.rs` uses non-deterministic randomness (`rand::thread_rng()`) during transaction execution to probabilistically validate type layout consistency. This causes different validators to non-deterministically produce different execution outcomes for identical blocks when layout mismatches occur, violating the fundamental consensus invariant of deterministic execution and potentially causing chain splits.

## Finding Description

The vulnerability exists in the change set squashing logic that runs during transaction execution: [1](#0-0) 

This function uses `rand::thread_rng()` to generate a random number and only performs layout validation with 1% probability (when `random_number == 1`). The function is called during transaction execution when squashing resource write operations: [2](#0-1) [3](#0-2) 

**Execution Path to Consensus:**

1. Consensus initiates block execution via `execute_and_update_state`: [4](#0-3) 

2. This calls VM transaction execution which creates and finishes user sessions: [5](#0-4) 

3. Session finalization calls `finish_with_squashed_change_set`: [6](#0-5) 

4. Which invokes `squash_additional_change_set`: [7](#0-6) 

5. Leading to `squash_additional_resource_writes` which calls the vulnerable function: [8](#0-7) 

**The Consensus Break:**

When a layout mismatch occurs (indicating a bug elsewhere in the system):
- **Validator A** generates `random_number = 1` → detects mismatch → returns `code_invariant_error` → transaction aborts with `DelayedFieldsCodeInvariantError`
- **Validator B** generates `random_number ≠ 1` → skips check → transaction succeeds

The error becomes a fatal block executor error: [9](#0-8) [10](#0-9) 

The error type converts to the DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR status: [11](#0-10) 

This causes validators to produce **different execution results for the same block**, violating the core consensus invariant.

## Impact Explanation

**Critical Severity** - This vulnerability meets the highest severity criteria:

1. **Consensus/Safety Violation**: Different validators produce different state roots for identical blocks, directly violating Aptos invariant #1: "Deterministic Execution: All validators must produce identical state roots for identical blocks"

2. **Chain Split Risk**: If layout mismatches occur (due to bugs in resource group handling, delayed field operations, or type layout tracking), some validators will reject blocks while others accept them, potentially causing a non-recoverable network partition requiring a hard fork

3. **Non-Deterministic Failures**: The 1% probability makes these failures rare and extremely difficult to debug, as the same block could be accepted by 99% of validators but rejected by 1%, making consensus impossible to achieve

4. **Cascading Impact**: Once consensus fails to achieve quorum due to non-deterministic execution, the network halts, causing total loss of liveness

## Likelihood Explanation

**Likelihood: Medium-to-High**

While this vulnerability requires a pre-condition (layouts not matching), several factors make exploitation likely:

1. **Active Code Paths**: The vulnerable function is in the hot path of every transaction execution involving resource writes and change set squashing

2. **Complex Type System**: The Move type system with resource groups, delayed fields, and type layouts is complex enough that bugs causing layout mismatches are plausible

3. **Probabilistic Detection**: The 1% probability means that even if layouts always matched in testing, a rare edge case causing mismatches in production would only be detected probabilistically, making it past testing

4. **Historical Evidence**: The existence of the `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` status code and extensive error handling suggests the system has encountered similar invariant violations before

5. **No Attacker Action Required**: This is a passive vulnerability triggered by normal transaction processing, not requiring active exploitation

## Recommendation

**Immediate Fix**: Remove all non-deterministic behavior from consensus-critical code paths:

```rust
pub fn randomly_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    
    // FIXED: Always check layout equality deterministically
    // Even though expensive, consensus safety requires determinism
    if layout_1.is_some() && layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    
    Ok(())
}
```

**Alternative Approaches:**

1. **Performance-Aware Fix**: If the equality check is truly too expensive, cache layout comparisons or use a deterministic sampling strategy based on transaction hash (not random):

```rust
// Deterministic check based on transaction hash/index
let should_check = txn_hash.to_vec()[0] == 1; // 1/256 probability, but deterministic
```

2. **Development-Only Checks**: Move the expensive validation to debug builds or test environments:

```rust
#[cfg(debug_assertions)]
if layout_1 != layout_2 {
    return Err(code_invariant_error(...));
}
```

3. **Comprehensive Solution**: Fix the root cause by ensuring layouts always match through stronger type safety guarantees in resource group and delayed field handling

## Proof of Concept

**Scenario**: Transaction execution with a layout mismatch (simulating a bug in delayed field or resource group handling)

**Setup**:
1. Create two validators processing the same block
2. Inject a layout mismatch condition in resource squashing
3. Execute the block on both validators multiple times

**Expected Result**: 
- Some executions: Validator A succeeds, Validator B succeeds (both skip check)
- Some executions: Validator A fails, Validator B succeeds (A detects, B skips)
- Some executions: Validator A succeeds, Validator B fails (A skips, B detects)

**Rust Test Demonstration**:

```rust
#[test]
fn test_non_deterministic_layout_check() {
    use aptos_vm_types::change_set::randomly_check_layout_matches;
    use move_core_types::value::MoveTypeLayout;
    
    // Create two different layouts
    let layout1 = Some(&MoveTypeLayout::U64);
    let layout2 = Some(&MoveTypeLayout::U128);
    
    let mut results = vec![];
    
    // Run the check multiple times
    for _ in 0..200 {
        let result = randomly_check_layout_matches(layout1, layout2);
        results.push(result.is_err());
    }
    
    // Non-deterministic behavior: some runs error, some don't
    let error_count = results.iter().filter(|&&x| x).count();
    let success_count = results.len() - error_count;
    
    // With 200 runs and 1% error rate, we expect ~2 errors
    // But some runs will have 0 errors, some will have more
    // This proves non-deterministic behavior
    assert!(error_count > 0, "Expected at least some errors");
    assert!(success_count > 0, "Expected at least some successes");
    
    println!("Non-deterministic results: {} errors, {} successes out of 200 runs", 
             error_count, success_count);
    println!("This proves different validators would reach different conclusions!");
}
```

**Impact**: This test demonstrates that the same input (mismatched layouts) produces different outputs across multiple runs, proving the non-deterministic behavior that breaks consensus.

## Notes

While the code comment suggests layouts are "expected to match" and this is "just an optimization," **any non-determinism in consensus-critical execution paths is a critical vulnerability**. Even if the intention was to catch bugs, the probabilistic nature transforms what should be a deterministic invariant violation into a consensus-breaking race condition. The proper approach is either to always check (accepting the performance cost) or never check in production (accepting the risk of missing bugs), but never to check randomly.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L49-74)
```rust
pub fn randomly_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() {
        // Checking if 2 layouts are equal is a recursive operation and is expensive.
        // We generally call this `randomly_check_layout_matches` function when we know
        // that the layouts are supposed to match. As an optimization, we only randomly
        // check if the layouts are matching.
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
    }
    Ok(())
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L534-537)
```rust
                    randomly_check_layout_matches(
                        type_layout.as_deref(),
                        additional_type_layout.as_deref(),
                    )?;
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L588-588)
```rust
                            randomly_check_layout_matches(Some(layout), Some(additional_layout))?;
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L757-760)
```rust
        Self::squash_additional_resource_writes(
            &mut self.resource_write_set,
            additional_resource_write_set,
        )?;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L858-868)
```rust
            executor
                .execute_and_update_state(
                    (block.id(), txns, auxiliary_info).into(),
                    block.parent_id(),
                    onchain_execution_config,
                )
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
        Ok(start.elapsed())
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1982-2012)
```rust
    fn execute_user_transaction_impl(
        &self,
        resolver: &impl AptosMoveResolver,
        code_storage: &impl AptosCodeStorage,
        txn: &SignedTransaction,
        txn_data: TransactionMetadata,
        is_approved_gov_script: bool,
        log_context: &AdapterLogSchema,
        gas_meter: &mut impl AptosGasMeter,
        mut trace_recorder: impl TraceRecorder,
    ) -> (VMStatus, VMOutput) {
        let _timer = VM_TIMER.timer_with_label("AptosVM::execute_user_transaction_impl");

        let traversal_storage = TraversalStorage::new();
        let mut traversal_context = TraversalContext::new(&traversal_storage);

        // Revalidate the transaction.
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L72-76)
```rust
    ) -> Result<VMChangeSet, VMStatus> {
        let Self { session } = self;
        let change_set =
            session.finish_with_squashed_change_set(change_set_configs, module_storage, false)?;
        Ok(change_set)
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L99-108)
```rust
        let mut change_set = self.into_heads().executor_view.change_set;
        change_set
            .squash_additional_change_set(additional_change_set)
            .map_err(|_err| {
                VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    err_msg("Failed to squash VMChangeSet"),
                )
            })?;
        Ok(change_set)
```

**File:** aptos-move/block-executor/src/executor.rs (L161-166)
```rust
            ExecutionStatus::DelayedFieldsCodeInvariantError(msg) => {
                Err(code_invariant_error(format!(
                    "[Execution] At txn {}, failed with DelayedFieldsCodeInvariantError: {:?}",
                    txn_idx, msg
                )))
            },
```

**File:** aptos-move/block-executor/src/executor.rs (L2250-2257)
```rust
                ExecutionStatus::DelayedFieldsCodeInvariantError(msg) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    alert!("Sequential execution DelayedFieldsCodeInvariantError error by transaction {}: {}", idx as TxnIndex, msg);
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalBlockExecutorError(code_invariant_error(msg)),
                    ));
```

**File:** types/src/error.rs (L45-53)
```rust
impl From<PanicError> for PartialVMError {
    fn from(err: PanicError) -> Self {
        match err {
            PanicError::CodeInvariantError(msg) => {
                PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
                    .with_message(msg)
            },
        }
    }
```
