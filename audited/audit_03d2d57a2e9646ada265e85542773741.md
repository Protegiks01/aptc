# Audit Report

## Title
Missing Randomness Array Length Validation Enables Validator DoS in Chunky PVSS Decryption

## Summary
The `verify()` function in the chunky PVSS weighted transcript implementation fails to validate that the randomness array (`Rs`) has the correct length (`max_weight`). This allows a byzantine validator to create a malformed transcript that passes verification but causes other validators to crash during decryption, violating liveness guarantees.

## Finding Description

The chunky PVSS implementation contains a critical missing validation in the `verify()` function that checks `Cs.len()` and `Vs.len()` but omits validation for `Rs.len()`. [1](#0-0) 

The expected length for `Rs` is `sc.get_max_weight()` as shown in both the `generate()` function [2](#0-1)  and the `encrypt_chunked_shares()` function. [3](#0-2) 

The vulnerability manifests in `Subtranscript::decrypt_own_share()` where ephemeral keys are constructed by taking the first `weight` elements from `Rs`. [4](#0-3)  When a player has `weight > Rs.len()`, the resulting `ephemeral_keys` vector will only contain `Rs.len()` elements. The function then iterates `for i in 0..weight` and accesses `ephemeral_keys[i]`, causing an index out of bounds panic. [5](#0-4) 

**Attack Path:**

1. A byzantine validator creates a transcript with `Rs.len() < max_weight` during DKG dealing
2. The transcript passes verification since `verify()` never validates `Rs.len() == max_weight`
3. The malformed transcript is used in batch encryption setup through `FPTXWeighted::setup()` [6](#0-5) 
4. Validators with `weight > Rs.len()` call `decrypt_own_share()` and experience a panic
5. This occurs during the consensus decryption pipeline for encrypted transaction processing [7](#0-6) 

The vulnerability also appears in the real DKG implementation where `decrypt_own_share()` is called during secret share decryption. [8](#0-7) 

Notably, there are two `decrypt_own_share()` implementations with inconsistent error handling: the `Subtranscript` version panics on out-of-bounds access, while the `Transcript` version uses `decrypt_chunked_scalars()` with `.zip()` which silently truncates. [9](#0-8) 

## Impact Explanation

**Severity: Medium**

This vulnerability causes deterministic validator crashes that affect network liveness. Validators with weight exceeding the malicious `Rs.len()` value will panic during encrypted transaction setup, preventing them from participating in encrypted transaction processing.

The impact aligns with **Medium Severity** criteria per Aptos bug bounty guidelines:
- Creates "state inconsistencies requiring manual intervention" as crashed validators need restart
- Causes "temporary liveness issues" affecting validators' ability to process encrypted transactions
- Does NOT cause fund loss, permanent network halt, or consensus safety violations
- Does NOT split consensus (all validators see the same malformed transcript)

This is not Critical severity because:
- Network can continue with remaining validators (assuming < 1/3 crash)
- Validators can be restarted to recover
- No permanent state corruption or fund theft occurs
- Byzantine validator can only target specific weight ranges

## Likelihood Explanation

**Likelihood: Medium**

The attack requires a byzantine validator (assumed possible under < 1/3 Byzantine fault tolerance in the BFT threat model) to participate in DKG and broadcast a malformed transcript with `Rs.len() < max_weight`.

**Feasibility factors:**
- Attack execution is trivial: simply create transcript with shortened `Rs` array during dealing
- Verification will pass since the PoK and range proof validation operate on existing `Rs` entries without checking array length
- Crash is guaranteed and deterministic for affected validators
- No complex timing or state manipulation required

The straightforward nature of the attack once a byzantine validator exists, combined with the guaranteed impact on targeted validators, justifies Medium likelihood assessment.

## Recommendation

Add explicit validation in the `verify()` function to check that `Rs.len() == sc.get_max_weight()`:

```rust
if self.subtrs.Rs.len() != sc.get_max_weight() {
    bail!(
        "Expected {} randomness vectors, but got {}",
        sc.get_max_weight(),
        self.subtrs.Rs.len()
    );
}
```

This validation should be added immediately after the existing length checks around line 153 in `weighted_transcript.rs`, ensuring that malformed transcripts are rejected during verification before they can cause validators to crash during decryption.

Additionally, consider adding defensive bounds checking in `decrypt_own_share()` to return an error instead of panicking, providing defense in depth.

## Proof of Concept

A byzantine validator can craft a malformed transcript during DKG by modifying the dealing code to generate `Rs` with fewer than `max_weight` elements. When honest validators with high weight attempt to decrypt their shares, they will panic at the array access, causing a crash that requires manual intervention to recover.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L133-153)
```rust
        if eks.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} encryption keys, but got {}",
                sc.get_total_num_players(),
                eks.len()
            );
        }
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L331-336)
```rust
        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L349-355)
```rust
        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L570-605)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let Cs = &self.subtrs.Cs[player.id];
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));

        if !Cs.is_empty() {
            if let Some(first_key) = self.subtrs.Rs.first() {
                debug_assert_eq!(
                    first_key.len(),
                    Cs[0].len(),
                    "Number of ephemeral keys does not match the number of ciphertext chunks"
                );
            }
        }

        let pk_shares = self.get_public_key_share(sc, player);

        let sk_shares: Vec<_> = decrypt_chunked_scalars(
            &Cs,
            &self.subtrs.Rs,
            &dk.dk,
            &pp.pp_elgamal,
            &pp.table,
            pp.ell,
        );

        (
            Scalar::vec_from_inner(sk_shares),
            pk_shares, // TODO: review this formalism... why do we need this here?
        )
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L630-632)
```rust
                Rs: (0..sc.get_max_weight())
                    .map(|_| unsafe_random_points_group(num_chunks_per_share, rng))
                    .collect(),
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L662-673)
```rust
        let elgamal_randomness = Scalar::vecvec_from_inner(
            (0..sc.get_max_weight())
                .map(|_| {
                    chunked_elgamal::correlated_randomness(
                        rng,
                        1 << pp.ell as u64,
                        num_chunks_per_scalar::<E::ScalarField>(pp.ell),
                        &E::ScalarField::ZERO,
                    )
                })
                .collect(),
        );
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L263-273)
```rust
                .decrypt_own_share(
                    threshold_config,
                    &current_player,
                    msk_share_decryption_key,
                    pvss_public_params,
                )
                .0
                .into_iter()
                .map(|s| s.into_fr())
                .collect(),
        };
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L93-103)
```rust
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;

        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L428-435)
```rust
        let (sk, pk) = trx.main.decrypt_own_share(
            &pub_params.pvss_config.wconfig,
            &Player {
                id: player_idx as usize,
            },
            dk,
            &pub_params.pvss_config.pp,
        );
```
