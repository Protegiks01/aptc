# Audit Report

## Title
Missing Validation of Groth16 Verification Key Allows Denial of Service for Keyless Accounts via Governance Proposals

## Summary
The `set_groth16_verification_key_for_next_epoch()` function in the keyless account module does not validate the Groth16 verification key before storing it on-chain. A malformed verification key with `gamma_abc_g1` vector length != 2 will be stored without validation, causing it to fail conversion to `PreparedVerifyingKey` during epoch transitions, resulting in all keyless transactions using ZK proofs to fail.

## Finding Description

This vulnerability represents a **logic bug** where validation code exists but is never called, allowing malformed verification keys to be stored on-chain through governance proposals.

**Critical Code Paths:**

**1. Missing Validation in Governance Path:**
The `set_groth16_verification_key_for_next_epoch()` function directly calls `config_buffer::upsert()` without invoking the existing `validate_groth16_vk()` validation function. [1](#0-0) 

The validation function exists and performs proper cryptographic point validation and structural checks, but is never invoked: [2](#0-1) 

**2. Missing Validation During Epoch Application:**
When the buffered VK is applied during epoch transitions, no validation occurs before storing into the global resource: [3](#0-2) 

**3. Late Bounds Check in Rust Conversion:**
The critical bounds check `if vk.gamma_abc_g1.len() != 2` only occurs during conversion to `PreparedVerifyingKey`, after the malformed VK has already been stored on-chain: [4](#0-3) 

**4. Silent Failure During Environment Initialization:**
When validator nodes initialize their environment, the VK conversion failure is silently swallowed by `.ok()`, setting `keyless_pvk = None`. Note the misleading comment claiming validation happens on-chain: [5](#0-4) 

**5. Transaction Validation Failure:**
When `keyless_pvk` is `None`, all keyless transactions with ZK proofs are rejected: [6](#0-5) 

**Attack Scenario:**
1. Governance proposal includes malformed VK with `gamma_abc_g1.len() = 10,000` (within storage limits at ~313KB)
2. Proposal passes and VK stored without validation
3. At epoch boundary, `on_new_epoch()` applies the malformed VK
4. During environment initialization, `vk.try_into()` fails the length check
5. `.ok()` converts `Err` to `None`, setting `keyless_pvk = None`
6. All subsequent keyless transactions with ZK proofs fail with "Groth16 VK has not been set on-chain" error
7. Users cannot access keyless accounts until governance fixes the VK

## Impact Explanation

**Severity: HIGH**

This vulnerability meets HIGH severity criteria under "Transaction submission failures":

- **Denial of Service**: All keyless account users lose transaction capabilities
- **User Impact**: Affects potentially millions of users if keyless accounts are widely adopted  
- **Temporary Fund Inaccessibility**: Users cannot access funds in keyless accounts during the outage
- **Recovery Complexity**: Requires another governance proposal (days for voting + epoch change) to restore functionality
- **Validator Impact**: All validator nodes will have degraded keyless functionality

While not CRITICAL (no permanent fund loss, no consensus break, no chain halt), it represents a significant protocol availability issue requiring governance intervention to resolve.

## Likelihood Explanation

**Likelihood: MEDIUM**

**This is a Logic Vulnerability:**
- The validation function exists but is never called - clear coding oversight
- Misleading comment in Rust code claims validation happens when it doesn't
- Both governance and genesis functions exhibit the same missing validation pattern

**Realistic Scenario - Accidental Misconfiguration:**
While governance participants are trusted roles, accidental misconfiguration during VK rotation is realistic:
- Complex cryptographic parameters are error-prone
- No automated validation prevents malformed proposals
- The existence of unused validation code suggests this was an oversight, not a design decision

**Barriers:**
- Requires governance voting power
- Detectable during proposal review period
- Recovery possible via subsequent governance action

## Recommendation

Call `validate_groth16_vk()` before storing the VK in both governance and epoch application paths:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // Add this validation
    config_buffer::upsert<Groth16VerificationKey>(vk);
}

public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
    system_addresses::assert_aptos_framework(fx);

    if (config_buffer::does_exist<Groth16VerificationKey>()) {
        let vk = config_buffer::extract_v2();
        validate_groth16_vk(&vk);  // Add this validation
        if (exists<Groth16VerificationKey>(@aptos_framework)) {
            *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
        } else {
            move_to(fx, vk);
        }
    };
    // ... rest of function
}
```

Additionally, add explicit length validation in `validate_groth16_vk()`:
```move
fun validate_groth16_vk(vk: &Groth16VerificationKey) {
    assert!(vector::length(&vk.gamma_abc_g1) == 2, E_INVALID_GAMMA_ABC_LENGTH);
    // ... existing validations
}
```

## Proof of Concept

```move
#[test(fx = @aptos_framework)]
#[expected_failure(abort_code = E_INVALID_BN254_G1_SERIALIZATION)]
fun test_malformed_vk_rejected(fx: &signer) {
    // Create VK with invalid gamma_abc_g1 length
    let malformed_vk = new_groth16_verification_key(
        vector[/* valid 32 bytes */],
        vector[/* valid 64 bytes */], 
        vector[/* valid 64 bytes */],
        vector[/* valid 64 bytes */],
        vector[vector[/* 32 bytes */], vector[/* 32 bytes */], vector[/* extra element */]]  // Length 3 instead of 2
    );
    
    // This should abort but currently doesn't
    set_groth16_verification_key_for_next_epoch(fx, malformed_vk);
}
```

## Notes

This is a **logic vulnerability** where validation code exists but is systematically not called. The misleading comment in the Rust code and the existence of the unused validation function strongly indicate this is a coding oversight rather than an intentional design decision. While requiring governance action, the realistic scenario is accidental misconfiguration during legitimate VK rotation, not malicious governance behavior.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L358-368)
```text
    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
        system_addresses::assert_aptos_framework(fx);

        if (config_buffer::does_exist<Groth16VerificationKey>()) {
            let vk = config_buffer::extract_v2();
            if (exists<Groth16VerificationKey>(@aptos_framework)) {
                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
            } else {
                move_to(fx, vk);
            }
        };
```

**File:** types/src/keyless/groth16_vk.rs (L62-68)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L287-293)
```rust
        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```
