# Audit Report

## Title
Network Private Key Leakage Through NodeConfig Serialization to Logs

## Summary
The `ConfigKey` wrapper fails to prevent private key material from being serialized when `NodeConfig.log_all_configs()` is called during node startup. Network private keys stored in `IdentityFromConfig` are exposed as hex-encoded strings in INFO-level logs, allowing attackers with log access to impersonate nodes on the peer-to-peer network. [1](#0-0) 

## Finding Description

The vulnerability exists in the interaction between multiple serialization layers:

1. **`IdentityFromConfig` contains a private key with flattened serialization**: The struct derives `Serialize` and contains a `ConfigKey<x25519::PrivateKey>` field marked with `#[serde(flatten)]`. [2](#0-1) 

2. **`ConfigKey` derives standard Serialize**: The wrapper struct uses `#[derive(Debug, Deserialize, Serialize)]`, which delegates to the wrapped type's serialization implementation. [3](#0-2) 

3. **`x25519::PrivateKey` serializes to hex strings in human-readable formats**: The `SerializeKey` derive macro checks if the serializer is human-readable (JSON/YAML are) and calls `to_encoded_string()`, which exposes the full private key as `"0x{hex_bytes}"`. [4](#0-3) [5](#0-4) 

4. **Node startup logs the entire config**: During initialization, `setup_environment_and_start_node()` calls `log_all_configs()`, which serializes the entire `NodeConfig` to JSON and logs each field at INFO level. [6](#0-5) 

5. **NetworkConfig contains Identity which can hold IdentityFromConfig**: The `NodeConfig` contains `validator_network` and `full_node_networks` fields that use `NetworkConfig`, which contains an `identity` field of type `Identity` enum that can be `Identity::FromConfig`. [7](#0-6) 

When a node with `Identity::FromConfig` starts, the complete network private key is logged as a hex string like `"key": "0xb0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"`. [8](#0-7) 

## Impact Explanation

**High Severity** - This constitutes a significant protocol violation per the Aptos bug bounty program. The exposure of network private keys allows:

1. **Network Impersonation**: An attacker with the leaked `x25519::PrivateKey` can impersonate the node on the P2P network, establishing authenticated connections with peers.

2. **Consensus Message Eavesdropping**: The attacker can decrypt network traffic intended for the compromised node, potentially observing consensus messages, block proposals, and votes.

3. **Man-in-the-Middle Attacks**: By impersonating nodes, attackers can position themselves between validators to manipulate or delay consensus communication.

4. **Log Infrastructure Compromise**: The vulnerability affects any node using `Identity::FromConfig` (common in test environments and potentially some production setups). Logs are often:
   - Sent to centralized logging systems (Loki, Datadog, CloudWatch)
   - Stored on disk with potentially weak permissions
   - Included in debugging dumps shared with support teams
   - Captured in backup systems

While `x25519::PrivateKey` correctly implements `SilentDebug` to prevent Debug formatting leaks, the `Serialize` trait path bypasses this protection entirely in human-readable formats.

## Likelihood Explanation

**High Likelihood** of occurrence:

1. **Automatic Triggering**: The vulnerability triggers on EVERY node startup that uses `Identity::FromConfig` - no special conditions required.

2. **Common Configuration Pattern**: `Identity::FromConfig` is used in multiple scenarios visible in test configurations and templates.

3. **Realistic Log Exposure Scenarios**:
   - Insider threats (malicious employees with log access)
   - Compromised logging infrastructure
   - Misconfigured log permissions exposing files publicly
   - Logs shared in support tickets or debugging sessions
   - Log aggregation systems with insufficient access controls

4. **Long Exposure Window**: Once logged, private keys remain in log files, log databases, and backups indefinitely until explicitly purged.

## Recommendation

Implement a custom `Serialize` implementation for `ConfigKey<T>` that prevents private key serialization in human-readable formats:

```rust
// In config/src/keys.rs

impl<T: DeserializeOwned + PrivateKey + Serialize> Serialize for ConfigKey<T> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        if serializer.is_human_readable() {
            // Never serialize private keys in human-readable formats (JSON, YAML)
            serializer.serialize_str("<private key elided>")
        } else {
            // Allow binary serialization for secure storage contexts
            self.key.serialize(serializer)
        }
    }
}
```

Alternatively, add `#[serde(skip_serializing)]` to the `key` field in `IdentityFromConfig` if the private key should never be serialized:

```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten, skip_serializing)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,
    #[serde(skip)]
    pub source: IdentitySource,
}
```

Additionally, audit `log_all_configs()` to ensure no sensitive data is logged, or implement filtering for sensitive fields.

## Proof of Concept

```rust
// Add to config/src/config/node_config.rs test module

#[test]
fn test_private_key_leak_through_serialization() {
    use crate::config::{Identity, NetworkConfig};
    use aptos_crypto::{x25519, Uniform};
    use aptos_types::account_address::from_identity_public_key;
    use rand::{rngs::StdRng, SeedableRng};
    
    // Create a network config with Identity::FromConfig
    let mut rng: StdRng = SeedableRng::from_seed([0u8; 32]);
    let private_key = x25519::PrivateKey::generate(&mut rng);
    let peer_id = from_identity_public_key(private_key.public_key());
    
    let mut network_config = NetworkConfig::default();
    network_config.identity = Identity::from_config(private_key.clone(), peer_id);
    
    // Serialize to JSON (human-readable)
    let json = serde_json::to_string_pretty(&network_config).unwrap();
    
    // The private key bytes are exposed as hex string
    let expected_hex = hex::encode(private_key.to_bytes());
    assert!(json.contains(&expected_hex), 
        "Private key leaked in JSON serialization:\n{}", json);
    
    println!("VULNERABILITY CONFIRMED:");
    println!("{}", json);
}
```

**Notes**

While the underlying `x25519::PrivateKey` type correctly implements `SilentDebug` to prevent accidental exposure through Debug formatting, it also implements `SerializeKey` which exposes the full key material when serialized in human-readable formats like JSON and YAML. The `ConfigKey` wrapper, designed to make private keys clonable for configuration purposes, does not override the `Serialize` behavior and thus inherits this vulnerability. The `log_all_configs()` method creates a direct path from node configuration to INFO logs, where network private keys are exposed to anyone with log file access.

### Citations

**File:** config/src/config/node_config.rs (L97-110)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
```

**File:** config/src/config/identity_config.rs (L130-139)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L186-211)
```rust
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
}
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L102-104)
```rust
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```

**File:** aptos-node/src/lib.rs (L690-698)
```rust
pub fn setup_environment_and_start_node(
    mut node_config: NodeConfig,
    remote_log_rx: Option<mpsc::Receiver<TelemetryLog>>,
    logger_filter_update_job: Option<LoggerFilterUpdater>,
    api_port_tx: Option<oneshot::Sender<u16>>,
    indexer_grpc_port_tx: Option<oneshot::Sender<u16>>,
) -> anyhow::Result<AptosHandle> {
    // Log the node config at node startup
    node_config.log_all_configs();
```

**File:** config/src/config/network_config.rs (L55-73)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
```

**File:** testsuite/pangu_lib/template_testnet_files/validator.yaml (L28-31)
```yaml
    identity:
      type: "from_config"
      key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
      peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
```
