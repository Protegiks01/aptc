# Audit Report

## Title
Missing Chain ID Validation in LiveDataServiceInfo Allows Cross-Chain Data Poisoning

## Summary
The indexer gRPC manager accepts `LiveDataServiceInfo` heartbeats from data services without validating that the advertised `chain_id` matches the expected network chain ID. This allows malicious data services to advertise incorrect chain IDs and serve data from the wrong blockchain network to unsuspecting users.

## Finding Description
The vulnerability exists in the indexer gRPC infrastructure's metadata management system. When data services register with the gRPC manager via heartbeat messages, they include a `LiveDataServiceInfo` structure containing their `chain_id`. However, the manager's `handle_live_data_service_info` function accepts and stores this information without any validation. [1](#0-0) 

The function simply stores the received `LiveDataServiceInfo` without comparing `info.chain_id` against the expected `self.chain_id` that the manager was initialized with: [2](#0-1) 

When the manager routes user requests to data services, it only checks `min_servable_version` and stream capacity, but never validates the chain ID: [3](#0-2) 

**Attack Path:**
1. Attacker deploys a malicious data service configured with testnet chain_id (e.g., chain_id=2)
2. Attacker connects this service to a mainnet gRPC manager (chain_id=1)
3. Malicious service sends heartbeat containing `LiveDataServiceInfo` with wrong chain_id: [4](#0-3) 

4. Manager accepts heartbeat without validation and registers the service
5. Users requesting indexed data get routed to the malicious service
6. Users receive testnet transaction data while believing they're querying mainnet

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

- **Significant Protocol Violations**: Breaks the fundamental invariant that all services within a network context must serve data from the same blockchain
- **Data Corruption**: Indexers consuming data from wrong-chain services will populate their databases with incorrect chain data, requiring manual intervention to fix
- **Financial Impact**: Users relying on this data for financial decisions (e.g., payment verification) could suffer losses when acting on wrong-chain transaction data
- **API Reliability**: Could cause crashes or undefined behavior in downstream systems expecting consistent chain data

While not directly affecting consensus nodes, this undermines the integrity of the entire indexer infrastructure that applications depend on.

## Likelihood Explanation
**High Likelihood** - The attack is straightforward to execute:

- **Low Technical Barrier**: Attacker only needs to deploy a data service binary with modified configuration
- **No Authentication Required**: Beyond network connectivity, no additional privileges needed
- **Difficult to Detect**: Without monitoring chain_id in heartbeats, operators won't notice the malicious service
- **Persistent Impact**: Once registered, the service remains in rotation until detected

The only requirement is that the attacker can reach the gRPC manager's network endpoint, which is typically exposed for legitimate data services to connect.

## Recommendation
Add chain ID validation in the `handle_live_data_service_info` and `handle_historical_data_service_info` functions:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate chain_id matches expected value
    if info.chain_id != self.chain_id {
        bail!(
            "Rejected LiveDataServiceInfo from {}: chain_id mismatch (expected {}, got {})",
            address,
            self.chain_id,
            info.chain_id
        );
    }
    
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    if info.stream_info.is_none() {
        info.stream_info = Some(StreamInfo {
            active_streams: vec![],
        });
    }
    entry.value_mut().recent_states.push_back(info);
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

Apply the same validation to `handle_historical_data_service_info`, `handle_fullnode_info`, and `handle_grpc_manager_info`.

## Proof of Concept

**Setup:**
1. Deploy mainnet gRPC manager (chain_id=1)
2. Deploy malicious data service with testnet configuration (chain_id=2)
3. Configure malicious service to connect to mainnet manager

**Execution:**
```bash
# Start mainnet gRPC manager
CHAIN_ID=1 ./indexer-grpc-manager --config mainnet-config.yaml

# Start malicious data service with wrong chain_id
CHAIN_ID=2 ./indexer-grpc-data-service-v2 \
  --grpc-manager-address "http://mainnet-manager:50051" \
  --config malicious-config.yaml

# Observe in manager logs: heartbeat accepted without error
# Query data through manager - receives testnet data on mainnet endpoint
```

**Expected vs Actual Behavior:**
- **Expected**: Manager rejects heartbeat with error "chain_id mismatch"
- **Actual**: Manager accepts heartbeat and routes users to wrong-chain service

**Verification:**
Monitor user queries being routed to the malicious service and receiving transactions with wrong chain IDs, confirming the cross-chain data poisoning.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L128-128)
```rust
    chain_id: u64,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L262-268)
```rust
            Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: self.chain_id,
                timestamp,
                known_latest_version,
                stream_info,
                min_servable_version,
            }))
```
