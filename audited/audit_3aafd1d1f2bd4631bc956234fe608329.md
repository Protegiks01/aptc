# Audit Report

## Title
Validator Stake Can Exceed Maximum Limit Through Reward Accumulation, Bypassing Governance Security Controls

## Summary
Validators can accumulate stake beyond the configured maximum limit through staking rewards and transaction fees, which are added without checking the maximum stake constraint. This bypasses the governance security mechanism designed to prevent excessive voting power concentration.

## Finding Description

The Aptos staking system enforces a maximum stake limit per validator to prevent voting power concentration and maintain governance decentralization. However, this security control has a critical bypass: while manual stake additions via `add_stake()` are checked against the maximum limit, staking rewards and transaction fees distributed during epoch transitions are added to validator stake pools without any maximum stake validation.

**Where the check EXISTS:**

When validators manually add stake, the system enforces the maximum limit: [1](#0-0) 

When validators join the validator set, maximum stake is also verified: [2](#0-1) 

**Where the check is MISSING:**

During epoch transitions, the `distribute_rewards` function mints and merges rewards directly into stake pools without any maximum check: [3](#0-2) 

Transaction fees are similarly added without validation: [4](#0-3) 

The `on_new_epoch` function only validates minimum stake requirements, not maximum: [5](#0-4) 

**Attack Path:**

1. A validator adds stake up to 9,999 APT (just below the typical 10,000 APT maximum)
2. The validator joins the validator set (passes maximum stake check at line 1076)
3. Each epoch, the validator earns staking rewards (typically ~1% per epoch in default configurations)
4. Rewards are minted and merged into the validator's active/pending_inactive stake without checking the maximum limit
5. After 100 epochs of perfect performance, the validator could have ~10,950 APT total stake (9,999 * 1.01^100 ≈ 10,949)
6. This exceeds the 10,000 APT maximum by ~9.5%, concentrating voting power beyond intended limits

The voting power calculation explicitly includes all stake components that can receive rewards: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: The maximum stake limit is a fundamental governance security mechanism. Bypassing it violates the protocol's security guarantees regarding voting power distribution.

2. **Governance Integrity Compromise**: The documented invariant "Governance Integrity: Voting power must be correctly calculated from stake" is broken, as validators can accumulate voting power beyond intended limits.

3. **Stake Concentration Attack Vector**: Over time, high-performing validators can accumulate significantly more stake than the configured maximum, potentially centralizing governance power in fewer hands than intended by the protocol designers.

4. **Hidden Nature**: This vulnerability is particularly insidious because validators appear to comply with stake limits at joining time, but gradually exceed them through normal operations, making the concentration hard to detect.

While this doesn't immediately steal funds or break consensus safety, it fundamentally undermines the governance security model over time.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will occur naturally without any malicious intent:

1. **Automatic Exploitation**: Every successful validator earning rewards will gradually exceed the maximum if they start near the limit
2. **No Special Actions Required**: Validators need only perform their normal duties (proposing blocks, validating)
3. **Accumulates Over Time**: With typical 1% rewards per epoch and epochs occurring regularly, excess accumulation is inevitable
4. **Affects All Long-Running Validators**: Any validator operating near maximum capacity for extended periods will exceed the limit

The only factor limiting immediate impact is time - it takes multiple epochs to accumulate significant excess stake.

## Recommendation

Add maximum stake validation after reward distribution in the `update_stake_pool` function:

```move
fun update_stake_pool(
    validator_perf: &ValidatorPerformance,
    pool_address: address,
    staking_config: &StakingConfig,
) acquires AptosCoinCapabilities, PendingTransactionFee, StakePool, TransactionFeeConfig, ValidatorConfig {
    let stake_pool = borrow_global_mut<StakePool>(pool_address);
    
    // ... existing reward distribution code ...
    
    // Add this validation after all rewards/fees are distributed:
    let (_, maximum_stake) = staking_config::get_required_stake(staking_config);
    let total_voting_power = get_next_epoch_voting_power(stake_pool);
    
    // If stake exceeds maximum, cap it by moving excess to inactive
    if (total_voting_power > maximum_stake) {
        let excess = total_voting_power - maximum_stake;
        let excess_to_extract = min(excess, coin::value(&stake_pool.active));
        if (excess_to_extract > 0) {
            let excess_coins = coin::extract(&mut stake_pool.active, excess_to_extract);
            coin::merge(&mut stake_pool.inactive, excess_coins);
        };
    };
}
```

Alternatively, implement a "soft cap" approach where rewards are reduced proportionally when stake approaches or exceeds the maximum.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
public entry fun test_validator_exceeds_max_stake_through_rewards(
    aptos_framework: &signer,
    validator: &signer,
) acquires AllowedValidators, AptosCoinCapabilities, OwnerCapability, PendingTransactionFee, 
           StakePool, TransactionFeeConfig, ValidatorConfig, ValidatorPerformance, ValidatorSet {
    // Initialize with max stake of 10000
    initialize_for_test_custom(aptos_framework, 100, 10000, LOCKUP_CYCLE_SECONDS, true, 1, 100, 1000000);
    
    let (_sk, pk, pop) = generate_identity();
    // Start with 9950 stake (50 below maximum)
    initialize_test_validator(&pk, &pop, validator, 9950, true, true);
    
    let validator_address = signer::address_of(validator);
    
    // Verify initial state: at 9950, below maximum
    let (active, _, pending_active, _) = get_stake(validator_address);
    assert!(active + pending_active == 9950, 0);
    
    // Run through 10 epochs, earning ~1% rewards each epoch
    let i = 0;
    while (i < 10) {
        end_epoch();
        i = i + 1;
    };
    
    // After 10 epochs with 1% rewards, stake should be approximately:
    // 9950 * (1.01)^10 ≈ 10,994
    let (active_final, _, pending_active_final, _) = get_stake(validator_address);
    let total_stake = active_final + pending_active_final;
    
    // VULNERABILITY: Total stake now exceeds the 10000 maximum
    assert!(total_stake > 10000, 1); // This assertion will PASS, proving the vulnerability
    
    // The validator now has more voting power than the maximum allows
    let voting_power = get_next_epoch_voting_power(borrow_global<StakePool>(validator_address));
    assert!(voting_power > 10000, 2); // Voting power also exceeds maximum
}
```

**Notes**

This vulnerability represents a fundamental flaw in the staking system's enforcement of maximum stake limits. The maximum stake configuration parameter exists specifically to prevent voting power concentration for governance security, as documented in the critical invariants. By allowing rewards to bypass this limit, the protocol undermines its own governance security model. While the excess accumulation is gradual, over extended periods (months to years of network operation), successful validators could accumulate stake significantly exceeding the intended maximum, potentially centralizing governance power and defeating the purpose of the stake limit entirely.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L843-845)
```text
        let (_, maximum_stake) = staking_config::get_required_stake(&staking_config::get());
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_EXCEEDS_MAX));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1399)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1712-1718)
```text
            let mint_cap = &borrow_global<AptosCoinCapabilities>(@aptos_framework).mint_cap;
            if (fee_active > 0) {
                coin::merge(&mut stake_pool.active, coin::mint(fee_active, mint_cap));
            };
            if (fee_pending_inactive > 0) {
                coin::merge(&mut stake_pool.pending_inactive, coin::mint(fee_pending_inactive, mint_cap));
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1787-1812)
```text
    fun distribute_rewards(
        stake: &mut Coin<AptosCoin>,
        num_successful_proposals: u64,
        num_total_proposals: u64,
        rewards_rate: u64,
        rewards_rate_denominator: u64,
    ): u64 acquires AptosCoinCapabilities {
        let stake_amount = coin::value(stake);
        let rewards_amount = if (stake_amount > 0) {
            calculate_rewards_amount(
                stake_amount,
                num_successful_proposals,
                num_total_proposals,
                rewards_rate,
                rewards_rate_denominator
            )
        } else {
            0
        };
        if (rewards_amount > 0) {
            let mint_cap = &borrow_global<AptosCoinCapabilities>(@aptos_framework).mint_cap;
            let rewards = coin::mint(rewards_amount, mint_cap);
            coin::merge(stake, rewards);
        };
        rewards_amount
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1847-1855)
```text
    fun get_next_epoch_voting_power(stake_pool: &StakePool): u64 {
        let value_pending_active = coin::value(&stake_pool.pending_active);
        let value_active = coin::value(&stake_pool.active);
        let value_pending_inactive = coin::value(&stake_pool.pending_inactive);
        spec {
            assume value_pending_active + value_active + value_pending_inactive <= MAX_U64;
        };
        value_pending_active + value_active + value_pending_inactive
    }
```
