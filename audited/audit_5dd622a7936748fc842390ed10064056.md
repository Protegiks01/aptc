# Audit Report

## Title
Premature Batch Deletion via Future Block Timestamps Causing Transaction Loss and Consensus Degradation

## Summary
A malicious block proposer can set block timestamps to the maximum allowed future time (up to 5 minutes ahead), triggering premature deletion of valid batches from the quorum store before their actual expiration time, resulting in transaction loss and potential consensus slowdown.

## Finding Description

The vulnerability exploits a mismatch between block timestamp validation bounds and batch expiration logic in the quorum store.

**Batch Creation and Expiration:**
When batches are created, they receive an expiration time of `current_time + batch_expiry_gap_when_init_usecs` (60 seconds by default). [1](#0-0) [2](#0-1) 

**Block Timestamp Validation:**
Blocks are validated to ensure their timestamp doesn't exceed `current_time + TIMEBOUND` where `TIMEBOUND = 300 seconds` (5 minutes), but there's no minimum timestamp requirement beyond being strictly greater than the parent block's timestamp. [3](#0-2) 

**Batch Deletion Logic:**
When a block is committed, `update_certified_timestamp` is called with the block's timestamp, which then deletes batches where `batch.expiration <= block_timestamp - expiration_buffer_usecs` (60 seconds buffer). [4](#0-3) [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. At time T0, a batch is created with expiration = T0 + 60 seconds
2. A malicious proposer creates a block with timestamp = T0 + 300 seconds (maximum allowed)
3. When this block commits, batches with expiration â‰¤ (T0 + 300) - 60 = T0 + 240 seconds are deleted
4. The victim batch (expiration T0 + 60 seconds) is deleted 239 seconds early (at T0 instead of T0 + 60)

The batch deletion occurs through the database layer: [7](#0-6) 

This breaks the invariant that batches should remain available until their designated expiration time, causing valid transactions to be lost from the quorum store before they can be included in blocks.

## Impact Explanation

**High Severity** - This vulnerability causes:

1. **Transaction Loss**: Valid transactions in prematurely deleted batches are lost from the quorum store and must be re-fetched from mempool
2. **Consensus Performance Degradation**: Reduced batch availability leads to smaller block payloads and lower throughput
3. **Liveness Risk**: In extreme cases where many batches are affected, nodes may struggle to produce blocks with sufficient transactions
4. **Resource Waste**: Repeated batch creation and deletion cycles waste network bandwidth and storage I/O

This qualifies as High severity under the Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations" - the premature batch deletion violates the quorum store's availability guarantees and degrades consensus performance.

## Likelihood Explanation

**High Likelihood:**
- Any validator selected as proposer can execute this attack without requiring special privileges, collusion, or stake majority
- The attack is trivial to execute: simply set the block timestamp to `current_time + 300 seconds`
- The timestamp passes all validation checks in both consensus and VM layers [8](#0-7) 
- Can be performed repeatedly whenever the attacker is selected as proposer
- No cryptographic complexity or sophisticated timing required

## Recommendation

Implement stricter block timestamp validation to prevent timestamps far in the future. Add a maximum timestamp delta check:

```rust
// In consensus-types/src/block.rs, verify_well_formed()
const MAX_TIMESTAMP_DRIFT_USECS: u64 = 10_000_000; // 10 seconds

ensure!(
    self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(MAX_TIMESTAMP_DRIFT_USECS),
    "Block timestamp cannot be more than {} seconds in the future",
    MAX_TIMESTAMP_DRIFT_USECS / 1_000_000
);
```

Additionally, adjust the batch expiration buffer to be larger than the maximum allowed timestamp drift:

```rust
// In quorum_store_builder.rs
let expiration_buffer = Duration::from_secs(30).as_micros() as u64; // Larger than MAX_TIMESTAMP_DRIFT_USECS
```

This ensures that even with maximum timestamp drift, batches are not deleted before their actual expiration time.

## Proof of Concept

```rust
#[test]
fn test_premature_batch_deletion_via_future_timestamp() {
    use aptos_infallible::duration_since_epoch;
    
    // Setup batch store with standard config
    let current_time = duration_since_epoch().as_micros() as u64;
    let expiration_buffer_usecs = Duration::from_secs(60).as_micros() as u64;
    
    // Step 1: Create batch with 60 second expiration
    let batch_expiration = current_time + Duration::from_secs(60).as_micros() as u64;
    let batch = create_test_batch_with_expiration(batch_expiration);
    batch_store.save(&batch).unwrap();
    
    // Step 2: Malicious proposer creates block with timestamp 5 minutes in future
    let malicious_block_timestamp = current_time + Duration::from_secs(300).as_micros() as u64;
    
    // This timestamp passes all validation (parent_timestamp < malicious_timestamp <= current_time + 300s)
    assert!(verify_timestamp_valid(malicious_block_timestamp));
    
    // Step 3: Block commits, triggering batch deletion
    batch_store.update_certified_timestamp(malicious_block_timestamp);
    
    // Step 4: Verify batch was prematurely deleted
    // Deletion threshold: malicious_block_timestamp - expiration_buffer_usecs
    //                   = (current_time + 300s) - 60s
    //                   = current_time + 240s
    // Batch expiration: current_time + 60s
    // Since 60s < 240s, batch is deleted 180 seconds early!
    
    assert!(batch_store.get_batch(&batch.digest()).is_err(), 
            "Batch should be deleted prematurely");
    assert!(current_time + 60_000_000 > duration_since_epoch().as_micros() as u64,
            "Batch actual expiration time has not been reached yet");
}
```

**Notes:**
The vulnerability arises from the design assumption that block timestamps would advance at roughly real-time pace, but the 5-minute future tolerance (intended for clock skew handling) creates a large window for abuse. The `TIMEBOUND` constant was likely chosen to handle network latency and clock synchronization issues, but it inadvertently enables this attack vector when combined with the batch expiration logic that trusts block timestamps as authoritative time sources.

### Citations

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** config/src/config/quorum_store_config.rs (L131-131)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
```

**File:** consensus/consensus-types/src/block.rs (L527-539)
```rust
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
            );

            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
```

**File:** consensus/src/quorum_store/batch_store.rs (L443-472)
```rust
    pub(crate) fn clear_expired_payload(&self, certified_time: u64) -> Vec<HashValue> {
        // To help slow nodes catch up via execution without going to state sync we keep the blocks for 60 extra seconds
        // after the expiration time. This will help remote peers fetch batches that just expired but are within their
        // execution window.
        let expiration_time = certified_time.saturating_sub(self.expiration_buffer_usecs);
        let expired_digests = self.expirations.lock().expire(expiration_time);
        let mut ret = Vec::new();
        for h in expired_digests {
            let removed_value = match self.db_cache.entry(h) {
                Occupied(entry) => {
                    // We need to check up-to-date expiration again because receiving the same
                    // digest with a higher expiration would update the persisted value and
                    // effectively extend the expiration.
                    if entry.get().expiration() <= expiration_time {
                        self.persist_subscribers.remove(entry.get().digest());
                        Some(entry.remove())
                    } else {
                        None
                    }
                },
                Vacant(_) => unreachable!("Expired entry not in cache"),
            };
            // No longer holding the lock on db_cache entry.
            if let Some(value) = removed_value {
                self.free_quota(value);
                ret.push(h);
            }
        }
        ret
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L530-539)
```rust
    pub fn update_certified_timestamp(&self, certified_time: u64) {
        trace!("QS: batch reader updating time {:?}", certified_time);
        self.last_certified_time
            .fetch_max(certified_time, Ordering::SeqCst);

        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
    }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L265-265)
```rust
            Duration::from_secs(60).as_micros() as u64,
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L93-101)
```rust
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchSchema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L32-50)
```text
    public fun update_global_time(
        account: &signer,
        proposer: address,
        timestamp: u64
    ) acquires CurrentTimeMicroseconds {
        // Can only be invoked by AptosVM signer.
        system_addresses::assert_vm(account);

        let global_timer = borrow_global_mut<CurrentTimeMicroseconds>(@aptos_framework);
        let now = global_timer.microseconds;
        if (proposer == @vm_reserved) {
            // NIL block with null address as proposer. Timestamp must be equal.
            assert!(now == timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
        } else {
            // Normal block. Time must advance
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
        };
    }
```
