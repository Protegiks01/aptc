# Audit Report

## Title
Byzantine Validators Can Spoof Timeout Reasons to Falsely Blame and Exclude Honest Validators from OptQS

## Summary
Byzantine validators can attach false timeout reasons to valid timeout signatures, allowing them to falsely blame honest validators for payload unavailability. This causes honest validators to be excluded from Optimistic Quorum Store (OptQS) proposals, degrading network performance and potentially impacting liveness.

## Finding Description

The vulnerability exists because timeout reasons in the AptosBFT consensus protocol are not cryptographically signed. When a validator broadcasts a timeout, only the `TwoChainTimeout` structure (epoch, round, hqc_round) is signed, not the attached `RoundTimeoutReason`.

The signature verification only covers the `TimeoutSigningRepr` structure: [1](#0-0) 

The `RoundTimeout::verify()` method verifies the signature against `timeout.signing_format()` but does not include the reason: [2](#0-1) 

Byzantine validators can exploit this by:
1. Creating valid timeout signatures for legitimate timeouts (epoch, round, hqc_round)
2. Attaching false `RoundTimeoutReason::PayloadUnavailable { missing_authors }` with a bitvec identifying honest validators
3. Broadcasting these spoofed timeout messages

When timeout votes are aggregated, the system accepts timeout reasons with f+1 voting power threshold (not the full 2f+1 quorum): [3](#0-2) 

The f+1 threshold is calculated as `total_voting_power - quorum_voting_power + 1` when `check_super_majority = false`: [4](#0-3) 

When processing timeout messages, the reason is stored without validation against local state: [5](#0-4) 

Once f+1 Byzantine validators report the same false `PayloadUnavailable` reason, the aggregated timeout reason includes the falsely accused honest validators: [6](#0-5) 

This aggregated reason flows into `NewRoundReason` and is tracked by the `ExponentialWindowFailureTracker`: [7](#0-6) 

The tracker extracts the falsely accused validators and adds them to the exclusion list: [8](#0-7) 

These excluded validators are then filtered out during OptQS batch pulling: [9](#0-8) 

## Impact Explanation

This vulnerability falls under **Medium Severity** ($10,000) per the Aptos bug bounty criteria as it causes:

1. **Performance degradation**: Excluding honest validators from OptQS reduces the available batch pool, lowering transaction throughput
2. **State inconsistencies**: False metrics and reputation damage to honest validators
3. **Potential liveness impact**: If enough validators are excluded, proposal generation may be significantly delayed

The impact is limited because:
- It does not break consensus safety (no double-spending or chain splits)
- It does not cause permanent state corruption requiring hard fork
- The exclusion is temporary and resets after successful rounds
- The system can still function, albeit with degraded performance

This aligns with the Medium severity category: "Limited protocol violations with state inconsistencies requiring manual intervention and temporary liveness issues."

## Likelihood Explanation

**Likelihood: Medium to High**

Attack requirements:
- Only f+1 Byzantine validators (by voting power) needed to coordinate
- Under standard BFT assumptions (f < n/3), this is realistic and within the threat model
- No additional cryptographic resources required
- Attack can be executed during any timeout round

The attack is stealthy because:
- False timeout reasons look like legitimate diagnostic information
- No cryptographic verification failures occur
- Metrics appear normal except for the false blame assignment

Byzantine validators have strong economic incentives to execute this attack to degrade competitors' reputations and operational performance.

## Recommendation

Include the `RoundTimeoutReason` in the cryptographic signature by modifying the `TimeoutSigningRepr` structure to include a hash of the reason:

```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub reason_hash: HashValue, // Add cryptographic commitment to reason
}
```

Update the signing and verification logic to include the reason hash, preventing Byzantine validators from attaching false reasons to valid timeout signatures.

Additionally, consider increasing the threshold for timeout reason aggregation from f+1 to 2f+1 to require quorum agreement on the reason, making the attack require Byzantine quorum collusion (>1/3 validators), which violates the BFT threat model assumptions.

## Proof of Concept

While a complete executable PoC would require a full consensus test harness with multiple validator nodes, the attack path is straightforward:

1. Byzantine validator creates valid `TwoChainTimeout` for a legitimate timeout
2. Signs it correctly with their validator key
3. Instead of computing the actual timeout reason from local state, attaches `RoundTimeoutReason::PayloadUnavailable` with a bitvec marking honest validators as missing
4. Broadcasts the `RoundTimeoutMsg` with the valid signature but false reason
5. Coordinates with f Byzantine validators to report the same false reason
6. Honest validators accept these timeout messages (signature verification passes)
7. Aggregation logic selects the false reason (has f+1 voting power)
8. Honest validators are added to the exclusion list for OptQS proposals
9. Network performance degrades as fewer batch sources are available

The vulnerability is exploitable through the standard consensus timeout message flow without requiring any special network conditions or timing attacks.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/src/pending_votes.rs (L93-153)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```

**File:** consensus/src/pending_votes.rs (L224-232)
```rust
        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );
```

**File:** types/src/validator_verifier.rs (L462-480)
```rust
    pub fn check_aggregated_voting_power(
        &self,
        aggregated_voting_power: u128,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let target = if check_super_majority {
            self.quorum_voting_power
        } else {
            self.total_voting_power - self.quorum_voting_power + 1
        };

        if aggregated_voting_power < target {
            return Err(VerifyError::TooLittleVotingPower {
                voting_power: aggregated_voting_power,
                expected_voting_power: target,
            });
        }
        Ok(aggregated_voting_power)
    }
```

**File:** consensus/src/liveness/round_state.rs (L264-276)
```rust
            let (prev_round_timeout_votes, prev_round_timeout_reason) = prev_round_timeout_votes
                .map(|votes| votes.unpack_aggregate(verifier))
                .unzip();

            // The new round reason is QCReady in case both QC.round + 1 == new_round, otherwise
            // it's Timeout and TC.round + 1 == new_round.
            let new_round_reason = if sync_info.highest_certified_round() + 1 == new_round {
                NewRoundReason::QCReady
            } else {
                let prev_round_timeout_reason =
                    prev_round_timeout_reason.unwrap_or(RoundTimeoutReason::Unknown);
                NewRoundReason::Timeout(prev_round_timeout_reason)
            };
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L596-600)
```rust
        for (_, batches) in self
            .author_to_batches
            .iter()
            .filter(|(author, _)| !exclude_authors.contains(author))
        {
```
