# Audit Report

## Title
Insufficient Validation of State Checkpoint Hashes in State Sync Allows Database Corruption

## Summary
During state synchronization, the `DoStateCheckpoint::run()` function only validates the state checkpoint hash at the `last_checkpoint_index` position, allowing malicious state sync peers to inject transaction infos with arbitrary state checkpoint hashes at non-checkpoint positions. This leads to committed chunks containing invalid transaction infos that corrupt the node's database and prevent successful synchronization.

## Finding Description

The vulnerability exists in the state checkpoint validation logic during chunk execution. When a node receives transaction chunks during state sync, it accepts externally-provided transaction infos that include state checkpoint hashes. The critical flaw is in how these hashes are validated: [1](#0-0) 

The validation only checks the hash at `last_checkpoint_index` (typically the end-of-block checkpoint), but accepts all other state checkpoint hashes without verification. For most transactions, the `state_checkpoint_hash` should be `None`, as state roots are only computed periodically (e.g., at block boundaries). [2](#0-1) 

**Attack Flow:**

1. A malicious state sync peer sends a `TransactionOutputListWithProof` containing transaction infos where non-checkpoint transactions have `state_checkpoint_hash` set to `Some(arbitrary_hash)` instead of `None`.

2. During chunk processing in `update_ledger()`, these malicious hashes are extracted: [3](#0-2) 

3. The validation in `get_state_checkpoint_hashes()` only verifies the hash at the checkpoint index, allowing malicious hashes at other positions to pass through unchecked.

4. These malicious hashes are then used to construct new `TransactionInfo` objects: [4](#0-3) 

At line 68, `state_checkpoint_hashes[i]` is used directly without additional validation for non-checkpoint positions.

5. The verification in `ensure_transaction_infos_match()` passes because both the expected and computed transaction infos use the same malicious hashes: [5](#0-4) 

6. The malicious transaction infos are committed to the database: [6](#0-5) 

7. When the final chunk attempts to reach the `verified_target_li`, the transaction accumulator root hash check fails because the transaction info hashes are incorrect (due to malicious state checkpoint hashes): [7](#0-6) 

However, by this point, intermediate chunks with corrupted transaction infos have already been committed to the database.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program criteria ("State inconsistencies requiring intervention"):

- **Database Corruption**: The node's database contains invalid transaction infos with incorrect state checkpoint hashes, violating the State Consistency invariant.
- **Denial of Service**: The victim node cannot complete synchronization and is stuck in a corrupted state.
- **Manual Intervention Required**: Recovery requires resetting the chunk executor and resyncing from scratch.
- **Potential Propagation**: If other nodes sync from the corrupted node before corruption is detected, the issue may spread.

The vulnerability does NOT reach Critical severity because:
- It does not enable theft or minting of funds
- It does not cause permanent network partition (recovery is possible via reset)
- It does not break consensus safety for honest validators (who execute blocks directly)

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires being a state sync peer; no validator access or stake required.
- **Attack Complexity**: Low - the attacker simply needs to craft malicious `TransactionOutputListWithProof` messages with modified state checkpoint hashes.
- **Detection Difficulty**: The attack succeeds silently until the final chunk fails, making it difficult to detect in progress.
- **Affected Nodes**: Any node performing state synchronization from untrusted peers is vulnerable.

## Recommendation

Add comprehensive validation of all state checkpoint hashes, not just the last checkpoint:

```rust
fn get_state_checkpoint_hashes(
    execution_output: &ExecutionOutput,
    known_state_checkpoints: Option<Vec<Option<HashValue>>>,
    state_summary: &LedgerStateSummary,
) -> Result<Vec<Option<HashValue>>> {
    let _timer = OTHER_TIMERS.timer_with(&["get_state_checkpoint_hashes"]);

    let num_txns = execution_output.to_commit.len();
    let last_checkpoint_index = execution_output
        .to_commit
        .state_update_refs()
        .last_inner_checkpoint_index();

    if let Some(known) = known_state_checkpoints {
        ensure!(
            known.len() == num_txns,
            "Bad number of known hashes. {} vs {}",
            known.len(),
            num_txns
        );
        
        // Validate checkpoint hash at last_checkpoint_index
        if let Some(idx) = last_checkpoint_index {
            ensure!(
                known[idx] == Some(state_summary.last_checkpoint().root_hash()),
                "Root hash mismatch with known hashes passed in. {:?} vs {:?}",
                known[idx],
                Some(&state_summary.last_checkpoint().root_hash()),
            );
        }

        // NEW: Validate that all non-checkpoint positions have None
        for (i, hash) in known.iter().enumerate() {
            if Some(i) != last_checkpoint_index {
                ensure!(
                    hash.is_none(),
                    "Non-checkpoint transaction at index {} has unexpected state_checkpoint_hash: {:?}",
                    i,
                    hash
                );
            }
        }

        Ok(known)
    } else {
        // ... existing code for None case ...
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_malicious_state_checkpoint_hashes_rejected() {
    use aptos_executor::chunk_executor::ChunkExecutor;
    use aptos_types::transaction::{TransactionInfo, TransactionOutput};
    
    // Setup: Create a test environment with chunk executor
    let (executor, db) = setup_test_executor();
    
    // Create a malicious chunk where non-checkpoint transaction has state_checkpoint_hash
    let num_txns = 10;
    let checkpoint_index = 9; // Last transaction is checkpoint
    
    let mut transaction_infos = vec![];
    for i in 0..num_txns {
        let state_checkpoint_hash = if i == checkpoint_index {
            Some(HashValue::random()) // Correct checkpoint
        } else if i == 5 {
            Some(HashValue::random()) // MALICIOUS: non-checkpoint with hash
        } else {
            None // Correct: no hash
        };
        
        transaction_infos.push(TransactionInfo::new(
            HashValue::random(),
            HashValue::random(),
            HashValue::random(),
            state_checkpoint_hash,
            100,
            ExecutionStatus::Success,
            None,
        ));
    }
    
    // Create malicious TransactionOutputListWithProof
    let malicious_proof = create_malicious_proof(transaction_infos);
    
    // Attempt to process the malicious chunk
    let result = executor.enqueue_chunk_by_transaction_outputs(
        malicious_proof,
        &verified_target_li,
        None,
    );
    
    // Should fail validation but currently succeeds
    assert!(result.is_ok()); // Currently passes - BUG!
    
    // Update ledger
    let update_result = executor.update_ledger();
    assert!(update_result.is_ok()); // Currently passes - BUG!
    
    // Commit chunk - malicious data is now in database
    let commit_result = executor.commit_chunk();
    assert!(commit_result.is_ok()); // Malicious data committed!
    
    // Verify corruption: check database contains invalid transaction info
    let stored_txn_info = db.get_transaction_info(5).unwrap();
    assert!(stored_txn_info.state_checkpoint_hash().is_some()); // Should be None!
    
    // Final chunk to verified_target_li will fail accumulator check
    // but damage is already done - database is corrupted
}
```

**Notes:**
- This vulnerability specifically affects the state synchronization path where transaction infos come from external peers.
- The consensus execution path (BlockExecutor) is not affected as it passes `None` for `known_state_checkpoints` and computes hashes locally.
- The fix should ensure that only the designated checkpoint position can have a non-None state checkpoint hash.
- Additional validation should verify that all non-checkpoint positions explicitly have `None` as their state checkpoint hash.

### Citations

**File:** execution/executor/src/workflow/do_state_checkpoint.rs (L57-73)
```rust
        if let Some(known) = known_state_checkpoints {
            ensure!(
                known.len() == num_txns,
                "Bad number of known hashes. {} vs {}",
                known.len(),
                num_txns
            );
            if let Some(idx) = last_checkpoint_index {
                ensure!(
                    known[idx] == Some(state_summary.last_checkpoint().root_hash()),
                    "Root hash mismatch with known hashes passed in. {:?} vs {:?}",
                    known[idx],
                    Some(&state_summary.last_checkpoint().root_hash()),
                );
            }

            Ok(known)
```

**File:** types/src/transaction/mod.rs (L2044-2047)
```rust
    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,
```

**File:** execution/executor/src/chunk_executor/mod.rs (L261-288)
```rust
    fn commit_chunk_impl(&self) -> Result<ExecutedChunk> {
        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__total"]);
        let chunk = {
            let _timer =
                CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__next_chunk_to_commit"]);
            self.commit_queue.lock().next_chunk_to_commit()?
        };

        let output = chunk.output.expect_complete_result();
        let num_txns = output.num_transactions_to_commit();
        if chunk.ledger_info_opt.is_some() || num_txns != 0 {
            let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__save_txns"]);
            // TODO(aldenhu): remove since there's no practical strategy to recover from this error.
            fail_point!("executor::commit_chunk", |_| {
                Err(anyhow::anyhow!("Injected error in commit_chunk"))
            });
            self.db.writer.save_transactions(
                output.as_chunk_to_commit(),
                chunk.ledger_info_opt.as_ref(),
                false, // sync_commit
            )?;
        }

        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__dequeue_and_return"]);
        self.commit_queue.lock().dequeue_committed()?;

        Ok(chunk)
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L346-357)
```rust
        let state_checkpoint_output = DoStateCheckpoint::run(
            &output.execution_output,
            &parent_state_summary,
            &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
            Some(
                chunk_verifier
                    .transaction_infos()
                    .iter()
                    .map(|t| t.state_checkpoint_hash())
                    .collect_vec(),
            ),
        )?;
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L47-93)
```rust
    fn assemble_transaction_infos(
        to_commit: &TransactionsWithOutput,
        state_checkpoint_hashes: Vec<Option<HashValue>>,
    ) -> (Vec<TransactionInfo>, Vec<HashValue>) {
        let _timer = OTHER_TIMERS.timer_with(&["assemble_transaction_infos"]);

        (0..to_commit.len())
            .into_par_iter()
            .with_min_len(optimal_min_len(to_commit.len(), 64))
            .map(|i| {
                let txn = &to_commit.transactions[i];
                let txn_output = &to_commit.transaction_outputs[i];
                let persisted_auxiliary_info = &to_commit.persisted_auxiliary_infos[i];
                // Use the auxiliary info hash directly from the persisted info
                let auxiliary_info_hash = match persisted_auxiliary_info {
                    PersistedAuxiliaryInfo::None => None,
                    PersistedAuxiliaryInfo::V1 { .. } => {
                        Some(CryptoHash::hash(persisted_auxiliary_info))
                    },
                    PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => None,
                };
                let state_checkpoint_hash = state_checkpoint_hashes[i];
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
                let write_set_hash = CryptoHash::hash(txn_output.write_set());
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
                );
                let txn_info_hash = txn_info.hash();
                (txn_info, txn_info_hash)
            })
            .unzip()
    }
```

**File:** execution/executor-types/src/ledger_update_output.rs (L90-112)
```rust
    pub fn ensure_transaction_infos_match(
        &self,
        transaction_infos: &[TransactionInfo],
    ) -> Result<()> {
        ensure!(
            self.transaction_infos.len() == transaction_infos.len(),
            "Lengths don't match. {} vs {}",
            self.transaction_infos.len(),
            transaction_infos.len(),
        );

        let mut version = self.first_version();
        for (txn_info, expected_txn_info) in
            zip_eq(self.transaction_infos.iter(), transaction_infos.iter())
        {
            ensure!(
                txn_info == expected_txn_info,
                "Transaction infos don't match. version:{version}, txn_info:{txn_info}, expected_txn_info:{expected_txn_info}",
            );
            version += 1;
        }
        Ok(())
    }
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L82-87)
```rust
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash in target ledger info does not match local computation. {:?} != {:?}",
                li,
                txn_accumulator,
            );
```
