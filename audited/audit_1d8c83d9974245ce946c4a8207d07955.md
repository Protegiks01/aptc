# Audit Report

## Title
Memory Exhaustion via Unbounded Response Size in Node Checker Transaction Verification

## Summary
The node-checker's `get_transaction_by_version()` function accepts arbitrarily large responses from target nodes without enforcing size limits, allowing a malicious node to exhaust the checker's memory by returning crafted TransactionData objects with oversized event or write_set payloads.

## Finding Description

The node-checker service validates target nodes by comparing their transaction data against a trusted baseline node. The vulnerability exists in the HTTP client's response handling when fetching transaction data via BCS (Binary Canonical Serialization). [1](#0-0) 

When `get_transaction_by_version_bcs()` is called, it eventually invokes `response.bytes().await?` which reads the entire HTTP response body into memory without any size validation: [2](#0-1) 

The HTTP client is configured with only a timeout (4 seconds) but no maximum response body size: [3](#0-2) [4](#0-3) 

The `TransactionOnChainData` structure contains unbounded collections that a malicious node can exploit: [5](#0-4) 

**Attack Mechanism:**

While legitimate on-chain transactions are constrained by execution-time limits (64KB transaction size, 10MB events, 10MB write ops), these limits are NOT enforced when a node serves API responses: [6](#0-5) [7](#0-6) 

A malicious target node can bypass these limits by crafting a fake BCS response claiming to contain valid transaction data, but actually containing gigabytes of data in the `events` or `changes` (WriteSet) fields. Since the node-checker trusts the target node to return properly-sized data and doesn't validate response size before deserialization, it will attempt to allocate memory for the entire payload.

**Exploitation Path:**

1. Attacker operates or compromises a target node being monitored
2. Node-checker queries `/transactions/by_version/{version}` with BCS accept header
3. Malicious node returns a crafted BCS response with:
   - Valid BCS encoding structure
   - Extremely large `Vec<ContractEvent>` (e.g., claim 1000 events of 1MB each = 1GB)
   - Or extremely large `WriteSet` data
4. `response.bytes().await?` attempts to read entire response into memory
5. Within the 4-second timeout, on a 1 Gbps connection, 500MB can be transmitted
6. Node-checker exhausts memory and crashes or degrades

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:
- Causes degraded performance or crashes of the node-checker service
- Affects operational monitoring infrastructure
- Could mask malicious node behavior by disabling health checks
- Does not directly impact consensus or validator operations, but impairs visibility

The impact is limited to the node-checker process itself, not the core blockchain network, thus not qualifying for High severity ("validator node slowdowns" refers to actual validator nodes, not monitoring tools).

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Control or compromise a target node being monitored
- Ability to respond to HTTP API requests with crafted data
- Basic understanding of BCS serialization format

**Complexity: Low** - The attack is straightforward and requires no sophisticated cryptographic attacks or consensus manipulation.

**Feasibility: High** - Any node operator can set up a malicious node. The node-checker is designed to monitor potentially untrusted nodes, making this a realistic threat model.

## Recommendation

Implement maximum response body size limits at the HTTP client level:

```rust
// In crates/aptos-rest-client/src/client_builder.rs
pub struct ClientBuilder {
    reqwest_builder: ReqwestClientBuilder,
    version_path_base: String,
    base_url: Url,
    timeout: Duration,
    headers: HeaderMap,
    max_response_size: Option<usize>, // Add this field
}

impl ClientBuilder {
    pub fn new(aptos_base_url: AptosBaseUrl) -> Self {
        // ... existing code ...
        Self {
            reqwest_builder: ReqwestClient::builder(),
            base_url: aptos_base_url.to_url(),
            version_path_base: DEFAULT_VERSION_PATH_BASE.to_string(),
            timeout: Duration::from_secs(10),
            headers,
            max_response_size: Some(50 * 1024 * 1024), // 50MB default limit
        }
    }
    
    pub fn max_response_size(mut self, size: usize) -> Self {
        self.max_response_size = Some(size);
        self
    }
}

// In crates/aptos-rest-client/src/lib.rs
async fn check_and_parse_bcs_response(
    &self,
    response: reqwest::Response,
) -> AptosResult<Response<bytes::Bytes>> {
    let (response, state) = self.check_response(response).await?;
    
    // Add size limit check
    if let Some(content_length) = response.content_length() {
        if content_length > MAX_RESPONSE_SIZE {
            return Err(RestError::Unknown(anyhow!(
                "Response size {} exceeds maximum allowed size {}",
                content_length, MAX_RESPONSE_SIZE
            )));
        }
    }
    
    // Use streaming with size limit
    let mut body = Vec::new();
    let mut stream = response.bytes_stream();
    while let Some(chunk) = stream.next().await {
        let chunk = chunk?;
        if body.len() + chunk.len() > MAX_RESPONSE_SIZE {
            return Err(RestError::Unknown(anyhow!(
                "Response body exceeds maximum allowed size"
            )));
        }
        body.extend_from_slice(&chunk);
    }
    
    Ok(Response::new(bytes::Bytes::from(body), state))
}
```

**Alternative:** Use a streaming BCS deserializer with size validation, or enforce limits based on known transaction constraints (e.g., max 20MB for any transaction response).

## Proof of Concept

```rust
// Test demonstrating memory exhaustion attack
// File: ecosystem/node-checker/tests/memory_exhaustion_test.rs

use axum::{Router, routing::get, response::Response};
use bytes::Bytes;
use std::net::SocketAddr;
use aptos_rest_client::Client;

#[tokio::test]
async fn test_memory_exhaustion_via_oversized_response() {
    // Create malicious server that returns oversized response
    let app = Router::new().route("/v1/transactions/by_version/:version", 
        get(|| async {
            // Create a BCS-encoded response with 100MB of event data
            let mut malicious_data = vec![0u8; 100 * 1024 * 1024];
            
            // Add valid BCS header for TransactionData::OnChain variant
            malicious_data[0] = 0; // Enum discriminant for OnChain
            
            Response::builder()
                .header("Content-Type", "application/x-bcs")
                .body(Bytes::from(malicious_data))
                .unwrap()
        })
    );

    // Start malicious server
    let addr = SocketAddr::from(([127, 0, 0, 1], 3030));
    tokio::spawn(async move {
        axum::Server::bind(&addr)
            .serve(app.into_make_service())
            .await
            .unwrap();
    });

    // Create client pointing to malicious server
    let url = "http://127.0.0.1:3030".parse().unwrap();
    let client = Client::from((reqwest::Client::new(), url));

    // Attempt to fetch transaction - this should exhaust memory
    // Without size limits, this will allocate 100MB
    let result = client.get_transaction_by_version_bcs(1).await;
    
    // In fixed version, this should return an error about size limit
    // In vulnerable version, this allocates 100MB and may cause OOM
    assert!(result.is_err());
}
```

## Notes

This vulnerability specifically affects the node-checker's ability to safely monitor potentially malicious or compromised nodes. The on-chain transaction size limits are correctly enforced during execution but do not protect API consumers from malicious response payloads. The fix should implement defense-in-depth by validating response sizes before deserialization, similar to how the API server enforces request size limits via `PostSizeLimit` middleware.

### Citations

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L34-52)
```rust
    async fn get_transaction_by_version(
        client: &AptosRestClient,
        version: u64,
        node_name: &str,
    ) -> Result<TransactionData, CheckerError> {
        Ok(client
            .get_transaction_by_version_bcs(version)
            .await
            .map_err(|e| {
                CheckerError::NonRetryableEndpointError(
                    TRANSACTIONS_ENDPOINT,
                    anyhow::Error::from(e).context(format!(
                        "The {} node API failed to return the requested transaction at version: {}",
                        node_name, version
                    )),
                )
            })?
            .into_inner())
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1773-1779)
```rust
    async fn check_and_parse_bcs_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<Response<bytes::Bytes>> {
        let (response, state) = self.check_response(response).await?;
        Ok(Response::new(response.bytes().await?, state))
    }
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L122-127)
```rust
        if let Ok(api_client) = target_node_address.get_api_client(Duration::from_secs(4)) {
            let api_index_provider = Arc::new(ApiIndexProvider::new(
                self.provider_configs.api_index.clone(),
                api_client,
            ));
            provider_collection.target_api_index_provider = Some(api_index_provider.clone());
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```

**File:** api/types/src/transaction.rs (L102-115)
```rust
pub struct TransactionOnChainData {
    /// The ledger version of the transaction
    pub version: u64,
    /// The transaction submitted
    pub transaction: aptos_types::transaction::Transaction,
    /// Information about the transaction
    pub info: aptos_types::transaction::TransactionInfo,
    /// Events emitted by the transaction
    pub events: Vec<ContractEvent>,
    /// The accumulator root hash at this version
    pub accumulator_root_hash: aptos_crypto::HashValue,
    /// Final state of resources changed by the transaction
    pub changes: aptos_types::write_set::WriteSet,
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-81)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-172)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
        [
            max_bytes_all_write_ops_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_write_ops_per_transaction" },
            10 << 20, // all write ops from a single transaction are 10MB max
        ],
        [
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
        ],
        [
            max_bytes_all_events_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_events_per_transaction"},
            10 << 20, // all events from a single transaction are 10MB max
        ],
```
