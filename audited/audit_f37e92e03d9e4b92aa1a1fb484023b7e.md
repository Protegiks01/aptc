# Audit Report

## Title
Incomplete Verification Allows Byzantine Validator to Cause Batch Decryption Denial of Service

## Summary
The `verify_decryption_key_share` function does not check that the player ID embedded in the decryption key share matches the expected player ID from the verification key. This verification gap allows a Byzantine validator to create shares with manipulated player IDs that pass cryptographic verification but cause reconstruction to fail.

## Finding Description

During derivation, a decryption key share is created as a tuple `(Player, signature_shares)` where the Player ID is explicitly set: [1](#0-0) 

However, during verification in the weighted scheme (used in production), the verification function **replaces** the player ID from the share with the verification key's player ID before performing the cryptographic check: [2](#0-1) 

This means the player ID in the share (`dk_share.0`) is completely ignored, and no validation occurs to ensure it matches `self.weighted_player`.

During reconstruction, the player IDs **from the shares** are used to compute virtual players for Lagrange interpolation: [3](#0-2) 

**Attack Scenario:**
1. A Byzantine validator receives their legitimate MSK share with player ID `i`
2. They derive a valid decryption key share: `(i, signature_shares_i)`
3. They manually modify the player ID to `j`: `(j, signature_shares_i)` 
4. They broadcast this share with their legitimate author field
5. During verification at honest validators:
   - The verification key for player `i` is selected (based on author)
   - The verification creates tuple `(i, signature_shares_i)` ignoring the share's player ID `j`
   - Cryptographic check passes (signatures match player `i`'s secrets)
6. The malformed share `(j, signature_shares_i)` is stored
7. During reconstruction:
   - Virtual players are computed using player ID `j`
   - Lagrange coefficients for player `j` are used
   - But signatures were created by player `i`
   - **Reconstruction fails with incorrect Lagrange interpolation**

This violates the critical invariant that verification must check all properties enforced during derivation.

## Impact Explanation

**Severity: High** - Significant Protocol Violation

This vulnerability allows a single Byzantine validator (within the assumed < 1/3 Byzantine tolerance) to cause **denial of service** for the batch encryption/decryption system:

- **Liveness Impact**: Inability to decrypt batched transactions prevents transaction processing
- **Protocol Violation**: Verification completeness is a fundamental security property
- **Byzantine Fault**: Exploitable by any validator acting maliciously within Byzantine fault assumptions

The production system uses this weighted scheme: [4](#0-3) 

A malformed share passes verification but causes aggregation to fail: [5](#0-4) 

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attack Requirements**: Requires a Byzantine validator willing to send malformed shares
- **Complexity**: Low - simple modification of player ID in share before broadcasting
- **Detection**: Difficult - shares pass all cryptographic verification
- **Impact Scope**: Affects all validators attempting to decrypt the batch

While this requires validator access (within Byzantine fault model), Aptos is designed to tolerate up to 1/3 Byzantine validators. The verification layer should catch all malformed inputs, including those from Byzantine validators, to maintain defense-in-depth.

## Recommendation

Add explicit player ID validation in the verification function:

```rust
pub fn verify_decryption_key_share(
    &self,
    digest: &Digest,
    dk_share: &WeightedBIBEDecryptionKeyShare,
) -> Result<()> {
    // ADD THIS CHECK:
    if dk_share.0 != self.weighted_player {
        return Err(BatchEncryptionError::PlayerIdMismatch.into());
    }
    
    (self.vks_g2.len() == dk_share.1.len())
        .then_some(())
        .ok_or(BatchEncryptionError::DecryptionKeyVerifyError)?;

    self.vks_g2
        .iter()
        .map(|vk_g2| BIBEVerificationKey {
            mpk_g2: self.mpk_g2,
            vk_g2: *vk_g2,
            player: self.weighted_player,
        })
        .zip(&dk_share.1)
        .try_for_each(|(vk, dk_share_value)| {
            vk.verify_decryption_key_share(
                digest, 
                &(self.weighted_player, dk_share_value.clone())
            )
        })
}
```

Similarly, add validation in the unweighted version: [6](#0-5) 

Add this check after line 140:
```rust
if decryption_key_share.0 != self.player {
    return Err(BatchEncryptionError::PlayerIdMismatch.into());
}
```

## Proof of Concept

```rust
#[test]
fn test_player_id_mismatch_attack() {
    use aptos_batch_encryption::schemes::fptx_weighted::FPTXWeighted;
    use aptos_batch_encryption::traits::BatchThresholdEncryption;
    
    // Setup with 4 validators, threshold 3
    let (ek, digest_key, vks, msk_shares) = 
        FPTXWeighted::setup_for_testing(42, 10, 10, &config);
    
    // Validator 0 derives their share
    let digest = /* create test digest */;
    let mut share_0 = FPTXWeighted::derive_decryption_key_share(
        &msk_shares[0], 
        &digest
    ).unwrap();
    
    // ATTACK: Validator 0 modifies their player ID to player 1
    let malicious_share = (Player { id: 1 }, share_0.1);
    
    // Verification against validator 0's VK should fail but doesn't
    assert!(FPTXWeighted::verify_decryption_key_share(
        &vks[0],
        &digest,
        &malicious_share
    ).is_ok()); // BUG: This passes when it should fail!
    
    // Collect shares for reconstruction (including malicious share)
    let shares = vec![malicious_share, share_1, share_2];
    
    // Reconstruction fails or produces wrong key
    let result = FPTXWeighted::reconstruct_decryption_key(&shares, &config);
    // Expected: reconstruction failure or incorrect key
    assert!(result.is_err() || /* decryption with result fails */);
}
```

## Notes

This vulnerability demonstrates a fundamental violation of verification completeness: properties enforced during derivation (player ID) must be validated during verification. The current implementation only verifies cryptographic correctness but ignores the player ID binding, creating an exploitable gap for Byzantine validators to cause denial of service through malformed shares that pass verification but fail reconstruction.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L104-112)
```rust
        Ok((
            self.weighted_player,
            evals_raw
                .into_iter()
                .map(|eval| BIBEDecryptionKeyShareValue {
                    signature_share_eval: eval,
                })
                .collect(),
        ))
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L166-168)
```rust
            .try_for_each(|(vk, dk_share)| {
                vk.verify_decryption_key_share(digest, &(self.weighted_player, dk_share.clone()))
            })
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L430-445)
```rust
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L89-97)
```rust
        let shares: Vec<SecretKeyShare> = dec_shares
            .map(|dec_share| dec_share.share.clone())
            .take(threshold as usize)
            .collect();
        let decryption_key =
            <FPTXWeighted as BatchThresholdEncryption>::reconstruct_decryption_key(
                &shares,
                &config.config,
            )?;
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L136-150)
```rust
    pub fn verify_decryption_key_share(
        &self,
        digest: &Digest,
        decryption_key_share: &BIBEDecryptionKeyShare,
    ) -> Result<()> {
        verify_bls(
            self.vk_g2,
            digest,
            self.mpk_g2,
            decryption_key_share.1.signature_share_eval,
        )
        .map_err(|_| BatchEncryptionError::DecryptionKeyShareVerifyError)?;

        Ok(())
    }
```
