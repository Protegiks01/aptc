# Audit Report

## Title
Capability::Sign Does Not Protect BLS12381 Consensus Keys - Safety Rules Can Be Bypassed via Direct Key Export

## Summary
The `Capability::Sign` permission model only protects Ed25519 keys stored in Vault's Transit engine. BLS12381 consensus keys are stored as KV secrets and can be exported by any service with `Capability::Read`, allowing direct signing that bypasses all SafetyRules checks. This architectural flaw enables equivocation attacks that violate BFT consensus safety.

## Finding Description

The secure storage system implements a capability-based permission model where `Capability::Sign` is intended to restrict signing operations while preventing key export. However, this protection only applies to Ed25519 keys in the Vault Transit engine, not to BLS12381 consensus keys used by SafetyRules. [1](#0-0) 

The test suite demonstrates that `Capability::Sign` works correctly for Ed25519 keys - a service with only Sign capability cannot export the private key: [2](#0-1) 

However, BLS12381 consensus keys are stored differently - as serialized values in the KV secrets engine: [3](#0-2) 

SafetyRules retrieves the consensus key directly into memory during initialization: [4](#0-3) 

All subsequent signing operations use the in-memory `ValidatorSigner`, bypassing storage-level access controls: [5](#0-4) [6](#0-5) 

### Attack Path

A compromised service with `Capability::Read` (but NOT `Capability::Sign`) can:

1. Call `storage.get::<bls12381::PrivateKey>(CONSENSUS_KEY)` to retrieve the consensus private key
2. Create its own `ValidatorSigner::new(author, Arc::new(consensus_key))`
3. Sign arbitrary consensus messages without any safety rules validation
4. Create equivocating signatures (signing conflicting blocks at the same round/epoch)
5. Break BFT consensus safety guarantees

The safety rules checks enforced by SafetyRules (epoch verification, last_voted_round checks, QC validation) are completely bypassed because the attacker signs directly with the exported key. [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental consensus safety invariant:

- **Consensus Safety Violation**: Enables equivocation attacks where a compromised validator signs conflicting blocks at the same round, violating the core BFT safety property that requires honest validators never equivocate
- **Network Partition**: Could cause different nodes to commit different blocks, leading to chain splits requiring hard fork intervention
- **False Security Model**: `Capability::Sign` provides a false sense of security for consensus operations while only protecting Ed25519 keys

The Aptos consensus protocol relies on SafetyRules to prevent equivocation. This vulnerability completely bypasses SafetyRules by allowing direct access to signing keys through the KV storage interface rather than the intended CryptoStorage signing interface.

## Likelihood Explanation

**High Likelihood** in scenarios where:
- Multiple services share access to the same storage backend with different capability levels
- A service is compromised that has `Capability::Read` but not `Capability::Sign`
- The architectural assumption that "Read cannot Sign" fails for BLS12381 consensus keys

The vulnerability exists in the current codebase design where BLS12381 keys use a different storage pattern than Ed25519 keys, creating an inconsistency in capability enforcement.

## Recommendation

**Implement consistent capability enforcement for BLS12381 consensus keys by using the Vault Transit engine for signing operations instead of exporting keys to memory.**

The fix requires:

1. Store BLS12381 consensus keys in Vault Transit engine (not KV secrets)
2. Modify SafetyRules to call `storage.sign()` instead of exporting the key
3. Ensure SafetyRules validation occurs before calling storage-level signing operations
4. Add a wrapper that enforces safety checks before delegating to CryptoStorage.sign()

Alternatively, if key export is necessary for performance:
- Remove `Capability::Read` from services that shouldn't be able to sign
- Add explicit `Capability::Export` checks before allowing `get()` operations on consensus keys
- Document that KV Read permission grants full signing capability for BLS keys

## Proof of Concept

```rust
// Proof of Concept: Bypassing SafetyRules with only Capability::Read

use aptos_consensus_types::block_data::BlockData;
use aptos_crypto::bls12381;
use aptos_secure_storage::{KVStorage, Storage};
use aptos_types::validator_signer::ValidatorSigner;
use aptos_global_constants::CONSENSUS_KEY;
use std::sync::Arc;

fn exploit_with_read_capability(storage: &Storage, author: AccountAddress) {
    // Step 1: Read consensus key (only requires Capability::Read)
    let consensus_key: bls12381::PrivateKey = storage
        .get(CONSENSUS_KEY)
        .expect("Failed to read consensus key")
        .value;
    
    // Step 2: Create validator signer with exported key
    let malicious_signer = ValidatorSigner::new(author, Arc::new(consensus_key));
    
    // Step 3: Sign equivocating blocks without safety rules checks
    let block_a = BlockData::new_for_testing(/* round 10, parent A */);
    let block_b = BlockData::new_for_testing(/* round 10, parent B - CONFLICT! */);
    
    // Both signatures succeed - equivocation without safety rules validation!
    let sig_a = malicious_signer.sign(&block_a).unwrap();
    let sig_b = malicious_signer.sign(&block_b).unwrap();
    
    // Result: Two valid signatures for conflicting blocks at same round
    // This breaks BFT consensus safety without triggering any SafetyRules checks
}
```

## Notes

This vulnerability highlights a critical architectural inconsistency: the capability-based security model works correctly for Ed25519 keys in the Vault Transit engine but fails for BLS12381 consensus keys stored as KV secrets. The root cause is that SafetyRules exports the consensus key into memory rather than delegating signing operations to the storage backend, which would enforce `Capability::Sign` policies.

The current implementation effectively grants signing capability to any service with KV read access, making `Capability::Sign` meaningless for consensus operations. This violates the principle of least privilege and creates a significant attack surface for compromised services.

### Citations

**File:** secure/storage/src/policy.rs (L50-58)
```rust
/// Represents actions
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Capability {
    Export,
    Read,
    Rotate,
    Sign,
    Write,
}
```

**File:** secure/storage/src/tests/vault.rs (L320-328)
```rust
    // Verify signer policy
    let signer_token = storage.create_token(vec![SIGNER]).unwrap();
    let mut signer_store = create_vault_storage(signer_token.clone(), None, true);
    signer_store.export_private_key(CRYPTO_KEY).unwrap_err();
    signer_store.get_public_key(CRYPTO_KEY).unwrap_err();
    signer_store.rotate_key(CRYPTO_KEY).unwrap_err();
    let signature = signer_store.sign(CRYPTO_KEY, &message).unwrap();
    signature.verify(&message, &pubkey).unwrap_err();
    signature.verify(&message, &new_pubkey).unwrap();
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L98-104)
```rust
    pub fn default_consensus_sk(
        &self,
    ) -> Result<bls12381::PrivateKey, aptos_secure_storage::Error> {
        self.internal_store
            .get::<bls12381::PrivateKey>(CONSENSUS_KEY)
            .map(|v| v.value)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L113-121)
```rust
    pub(crate) fn sign<T: Serialize + CryptoHash>(
        &self,
        message: &T,
    ) -> Result<bls12381::Signature, Error> {
        let signer = self.signer()?;
        signer
            .sign(message)
            .map_err(|err| Error::SerializationError(err.to_string()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L325-330)
```rust
                    // Try to export the consensus key directly from storage.
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** types/src/validator_signer.rs (L31-37)
```rust
    /// Constructs a signature for `message` using `private_key`.
    pub fn sign<T: Serialize + CryptoHash>(
        &self,
        message: &T,
    ) -> Result<bls12381::Signature, CryptoMaterialError> {
        self.private_key.sign(message)
    }
```
