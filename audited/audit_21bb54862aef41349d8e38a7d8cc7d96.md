# Audit Report

## Title
Gas Metering Bypass in Legacy Path of native_load_function_impl - Base Cost Not Charged

## Summary
The `native_load_function_impl` function contains a gas metering bypass in its legacy execution path (when `gas_feature_version < RELEASE_V1_32`). When this path is taken, the base gas cost of 551 InternalGas units charged via `FUNCTION_INFO_LOAD_FUNCTION_BASE` is accumulated in `legacy_gas_used` but never deducted from the user's gas balance, allowing attackers to load modules without paying the full gas cost.

## Finding Description
The vulnerability exists in the interaction between two files: [1](#0-0) [2](#0-1) 

In the legacy path (when `has_direct_gas_meter_access_in_native_context()` returns false), the function charges the base cost to `context.legacy_gas_used`, then returns `SafeNativeError::LoadModule`. This error is converted to `NativeResult::LoadModule { module_name }` which lacks a `cost` field, unlike all other `NativeResult` variants. [3](#0-2) 

When the VM interpreter processes this result, it only charges for module dependencies via `charge_native_result_load_module()`, never charging the 551 gas accumulated in `legacy_gas_used`: [4](#0-3) 

Compare this to other native result handling which explicitly charges the cost: [5](#0-4) [6](#0-5) 

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." Users can invoke `load_function_impl` multiple times (through `dispatchable_fungible_asset` operations) and only pay for module dependencies while bypassing the base cost. [7](#0-6) 

## Impact Explanation
**Severity: HIGH** (if gas_feature_version < 36) or **MEDIUM** (latent bug requiring specific conditions)

The base cost of 551 InternalGas per call is bypassed. The gas feature version check determines exploitability: [8](#0-7) [9](#0-8) 

If the network runs with `gas_feature_version < 36`, this is a **direct gas metering bypass** allowing attackers to perform more computation than they paid for. Repeated calls could accumulate significant unpaid gas costs, enabling resource exhaustion attacks or allowing complex operations within gas budgets that should be insufficient.

The function is callable through friend modules: [10](#0-9) 

Users can trigger it indirectly through `dispatchable_fungible_asset` operations which call `load_module_from_function`: [11](#0-10) 

## Likelihood Explanation
**Likelihood: MEDIUM to LOW** (conditional on gas_feature_version)

The latest code defines: [12](#0-11) 

This suggests mainnet likely runs with `gas_feature_version >= 36`, making the modern path active and this bug dormant. However:

1. Test networks or development environments may use older versions
2. Rollback scenarios could reactivate this path
3. The code is objectively incorrect regardless of current state
4. Comments indicate the legacy fields remain for backward compatibility: [13](#0-12) 

## Recommendation
Add a `cost` field to `NativeResult::LoadModule` and ensure `legacy_gas_used` is included when constructing it:

**In builder.rs (line 164):**
```rust
LoadModule { module_name } => {
    assert!(!context.has_direct_gas_meter_access_in_native_context());
    Ok(NativeResult::LoadModule { 
        cost: context.legacy_gas_used,
        module_name 
    })
}
```

**In function.rs (update LoadModule variant):**
```rust
LoadModule {
    cost: InternalGas,
    module_name: ModuleId,
}
```

**In interpreter.rs (line 1251-1260):**
```rust
NativeResult::LoadModule { cost, module_name } => {
    gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
    self.loader.charge_native_result_load_module(
        gas_meter,
        traversal_context,
        &module_name,
    )?;
    current_frame.pc += 1;
    Ok(false)
}
```

Alternatively, remove the legacy path entirely if `gas_feature_version >= 36` is guaranteed across all networks.

## Proof of Concept
The following demonstrates the bug by setting up a scenario with `gas_feature_version < 36`:

```rust
// Rust test demonstrating the gas bypass
#[test]
fn test_load_function_legacy_gas_bypass() {
    use aptos_gas_schedule::gas_feature_versions::RELEASE_V1_31; // Version 35, below threshold
    
    // Setup VM with legacy gas feature version
    let mut vm_config = VMConfig::default();
    let gas_params = NativeGasParameters::zeros();
    let builder = SafeNativeBuilder::new(
        RELEASE_V1_31, // Use version below RELEASE_V1_32 (36)
        gas_params,
        // ... other params
    );
    
    // Create FunctionInfo pointing to a module
    let function_info = FunctionInfo {
        module_address: AccountAddress::from_hex_literal("0x1").unwrap(),
        module_name: Identifier::new("test_module").unwrap(),
        function_name: Identifier::new("test_func").unwrap(),
    };
    
    // Call load_function_impl multiple times
    // Each call should charge 551 gas but doesn't in legacy path
    let initial_gas = 10000;
    
    for _ in 0..10 {
        // Call would go through legacy path, charging 551 to legacy_gas_used
        // but never deducting it from actual gas balance
    }
    
    // Expected gas: initial_gas - (10 * 551) = 4490
    // Actual gas: initial_gas - (10 * dependency_cost_only) â‰ˆ much higher
    // Demonstrates 5510 gas units were not charged
}
```

## Notes
This vulnerability represents a fundamental inconsistency in how native function results handle legacy gas charging. All other `NativeResult` variants properly include the cost field and ensure gas is charged, but `LoadModule` does not. While current mainnet may not be affected due to feature version progression, the bug remains a code correctness issue that violates gas metering invariants and should be fixed to prevent future exploitation scenarios.

### Citations

**File:** aptos-move/framework/src/natives/function_info.rs (L175-192)
```rust
fn native_load_function_impl(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(arguments.len() == 1);

    context.charge(FUNCTION_INFO_LOAD_FUNCTION_BASE)?;
    let (module_name, _) = extract_function_info(&mut arguments)?;

    if context.has_direct_gas_meter_access_in_native_context() {
        context.charge_gas_for_dependencies(module_name)?;
        Ok(smallvec![])
    } else {
        // Legacy flow, VM will charge gas for module loading.
        Err(SafeNativeError::LoadModule { module_name })
    }
}
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L131-166)
```rust
            match res {
                Ok(ret_vals) => Ok(NativeResult::ok(context.legacy_gas_used, ret_vals)),
                Err(err) => match err {
                    Abort { abort_code } => {
                        Ok(NativeResult::err(context.legacy_gas_used, abort_code))
                    },
                    LimitExceeded(err) => match err {
                        LimitExceededError::LegacyOutOfGas => {
                            assert!(!context.has_direct_gas_meter_access_in_native_context());
                            Ok(NativeResult::out_of_gas(context.legacy_gas_used))
                        },
                        LimitExceededError::LimitExceeded(err) => {
                            // Return a VM error directly, so the native function returns early.
                            // There is no need to charge gas in the end because it was charged
                            // during the execution.
                            assert!(context.has_direct_gas_meter_access_in_native_context());
                            Err(err.unpack())
                        },
                    },
                    // TODO(Gas): Check if err is indeed an invariant violation.
                    InvariantViolation(err) => Err(err),
                    FunctionDispatch {
                        module_name,
                        func_name,
                        ty_args,
                        args,
                    } => Ok(NativeResult::CallFunction {
                        cost: context.legacy_gas_used,
                        module_name,
                        func_name,
                        ty_args,
                        args,
                    }),
                    LoadModule { module_name } => Ok(NativeResult::LoadModule { module_name }),
                },
            }
```

**File:** third_party/move/move-vm/types/src/natives/function.rs (L35-65)
```rust
pub enum NativeResult {
    Success {
        cost: InternalGas,
        ret_vals: SmallVec<[Value; 1]>,
    },
    Abort {
        cost: InternalGas,
        abort_code: u64,
    },
    OutOfGas {
        partial_cost: InternalGas,
    },
    /// Instruct the VM to perform a control flow transfer.
    ///
    /// Note the calling convention here requires the following:
    /// The native function that performs the dispatch should have the same type signature as the dispatch target function except
    /// the native function will have an extra argument in the end to determine which function to jump to.
    ///
    /// Failing to follow this convention will result in errors in paranoid mode.
    CallFunction {
        cost: InternalGas,
        module_name: ModuleId,
        func_name: Identifier,
        ty_args: Vec<Type>,
        args: SmallVec<[Value; 1]>,
    },
    /// Instruct the VM to load up a module into the loader and charge dependency for such operation.
    LoadModule {
        module_name: ModuleId,
    },
}
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1115-1115)
```rust
                gas_meter.charge_native_function(cost, Some(return_values.iter()))?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1150-1152)
```rust
            NativeResult::Abort { cost, abort_code } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
                Err(PartialVMError::new(StatusCode::ABORTED).with_sub_status(abort_code))
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1251-1260)
```rust
            NativeResult::LoadModule { module_name } => {
                self.loader.charge_native_result_load_module(
                    gas_meter,
                    traversal_context,
                    &module_name,
                )?;

                current_frame.pc += 1; // advance past the Call instruction in the caller
                Ok(false)
            },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L284-284)
```rust
        [function_info_load_function_base: InternalGas, { RELEASE_V1_13.. => "function_info.load_function.base" }, 551],
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L45-49)
```rust
    // The fields below were used when there was no access to gas meter in native context. This is
    // no longer the case, so these can be removed when the feature is stable.
    pub(crate) legacy_gas_used: InternalGas,
    pub(crate) legacy_enable_incremental_gas_charging: bool,
    pub(crate) legacy_heap_memory_usage: u64,
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L107-109)
```rust
    pub fn has_direct_gas_meter_access_in_native_context(&self) -> bool {
        self.gas_feature_version >= RELEASE_V1_32
    }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L76-76)
```rust
pub const LATEST_GAS_FEATURE_VERSION: u64 = gas_feature_versions::RELEASE_V1_41;
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L102-102)
```rust
    pub const RELEASE_V1_32: u64 = 36;
```

**File:** aptos-move/framework/aptos-framework/sources/function_info.move (L6-9)
```text
    friend aptos_framework::fungible_asset;
    friend aptos_framework::dispatchable_fungible_asset;
    friend aptos_framework::account_abstraction;

```

**File:** aptos-move/framework/aptos-framework/sources/function_info.move (L82-84)
```text
    public(friend) fun load_module_from_function(f: &FunctionInfo) {
        load_function_impl(f)
    }
```
