# Audit Report

## Title
Time-of-Check to Time-of-Use (TOCTOU) Race Condition in Optimistic Fetch Response Handling Allows Banned Peers to Receive Responses

## Summary
A timing vulnerability exists in the optimistic fetch response flow where peers banned by the request moderator after validation but before response transmission still receive responses. This allows malicious peers to consume server resources (storage I/O, CPU, network bandwidth) even after being banned for sending too many invalid requests.

## Finding Description

The storage service implements a request moderator that bans peers temporarily after they send too many invalid requests. [1](#0-0) 

When handling optimistic fetch requests, the system follows this sequence:

1. An optimistic fetch request is created and stored when a peer requests new transaction data
2. When new blockchain data arrives, `handle_ready_optimistic_fetches()` processes pending fetches
3. For each ready fetch, a blocking task is spawned that calls `notify_peer_of_new_data()` [2](#0-1) 

Inside `notify_peer_of_new_data()`, the ban status is checked during request processing via `validate_request()`: [3](#0-2) 

This validation calls the request moderator's check: [4](#0-3) [5](#0-4) 

**However**, after validation passes and expensive storage operations complete, the response is sent without re-checking the ban status: [6](#0-5) [7](#0-6) [8](#0-7) 

The `send_response()` and `ResponseSender::send()` methods contain no ban status verification, creating a TOCTOU vulnerability window.

**Attack Scenario:**
1. Malicious peer creates an optimistic fetch request for large transaction data range
2. Server validates request (peer not banned yet) and stores the fetch
3. New blockchain data arrives, triggering optimistic fetch processing
4. Server validates the pending fetch again (peer still not banned)
5. **While server is fetching expensive data from storage**, peer sends many concurrent invalid requests to other request handlers
6. Request moderator marks peer as banned
7. Server completes storage fetch, transforms response, and sends it via `send_response()` without re-checking ban status
8. Banned peer receives full response despite being marked as ignored

The attacker can repeat this pattern by creating new optimistic fetches immediately before they would normally be unblocked, amplifying the resource waste.

## Impact Explanation

This vulnerability qualifies as **Medium severity** per Aptos bug bounty criteria for the following reasons:

1. **Resource Exhaustion**: Banned peers continue consuming server resources (disk I/O for storage reads, CPU for response transformation, network bandwidth for transmission). Each optimistic fetch can request up to `max_transaction_chunk_size` or `max_transaction_output_chunk_size` transactions, which are expensive storage operations.

2. **State Inconsistency**: The peer's ban state in the request moderator is inconsistent with the actual response behavior. The system believes it has blocked a malicious peer, but that peer continues receiving responses for previously-created optimistic fetches.

3. **Security Control Bypass**: The peer banning mechanism—designed to protect the network from misbehaving peers—is partially circumvented. This undermines the effectiveness of the protection mechanism.

4. **No Direct Fund Loss**: This does not cause loss of funds, consensus violations, or permanent network damage, ruling out Critical/High severity.

This fits the Medium severity category: "State inconsistencies requiring intervention" and represents a resource management vulnerability.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly exploitable because:

1. **Easy to Trigger**: Any peer can create optimistic fetch requests without special privileges
2. **Predictable Timing Window**: The attacker can observe when new blockchain data arrives (public information) and time their attack accordingly
3. **Controllable Race Condition**: The attacker controls both the optimistic fetch creation and the timing of invalid requests needed to get banned
4. **Repeatable Attack**: The attacker can create multiple optimistic fetches over time before getting permanently banned
5. **Network Type Restriction**: Only public network peers can be banned per the code logic, making this attack surface limited but still significant for public-facing nodes

The attack requires precise timing but is technically feasible and can be automated.

## Recommendation

Add a ban status check immediately before sending responses in `send_response()` or within `notify_peer_of_new_data()` after data processing but before transmission:

**Option 1: Check in send_response()**

```rust
pub(crate) fn send_response(
    &self,
    request: StorageServiceRequest,
    response: aptos_storage_service_types::Result<StorageServiceResponse>,
    response_sender: ResponseSender,
    peer_network_id: &PeerNetworkId,  // Add parameter
) {
    // Check ban status immediately before sending
    if let Some(peer_state) = self.request_moderator.get_peer_state(peer_network_id) {
        if peer_state.is_ignored() {
            log_storage_response(request, &Err(StorageServiceError::TooManyInvalidRequests(
                "Peer was banned during request processing".to_string()
            )));
            return; // Drop response for banned peer
        }
    }
    
    log_storage_response(request, &response);
    response_sender.send(response);
}
```

**Option 2: Check in notify_peer_of_new_data() before send_response()**

```rust
// After line 187 in utils.rs, before calling send_response:

// Final ban status check before sending response
if let Some(peer_state) = request_moderator.get_peer_state(peer_network_id) {
    if peer_state.is_ignored() {
        return Err(Error::TooManyInvalidRequests(
            "Peer was banned during optimistic fetch processing".into()
        ));
    }
}

handler.send_response(missing_data_request, Ok(storage_response), response_sender);
```

Additionally, add a public method to `RequestModerator` to allow ban status queries:

```rust
// In moderator.rs
pub fn is_peer_ignored(&self, peer_network_id: &PeerNetworkId) -> bool {
    self.unhealthy_peer_states
        .get(peer_network_id)
        .map_or(false, |state| state.is_ignored())
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_banned_peer_receives_optimistic_fetch_response() {
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::{
        DataRequest, NewTransactionsWithProofRequest, StorageServiceRequest
    };
    use aptos_time_service::TimeService;
    
    // Setup
    let config = StorageServiceConfig::default();
    let time_service = TimeService::mock();
    let (response_sender, response_receiver) = oneshot::channel();
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Create request moderator and storage handler
    let request_moderator = Arc::new(RequestModerator::new(
        AptosDataClientConfig::default(),
        cached_storage_server_summary,
        peers_and_metadata,
        config.clone(),
        time_service.clone(),
    ));
    
    let handler = Handler::new(
        cached_storage_server_summary.clone(),
        Arc::new(DashMap::new()),
        Cache::new(100),
        request_moderator.clone(),
        storage.clone(),
        Arc::new(DashMap::new()),
        time_service.clone(),
    );
    
    // Step 1: Create optimistic fetch request (peer not banned)
    let optimistic_fetch_request = StorageServiceRequest::new(
        DataRequest::GetNewTransactionsWithProof(NewTransactionsWithProofRequest {
            known_version: 100,
            known_epoch: 1,
            include_events: false,
        }),
        false,
    );
    
    let optimistic_fetch = OptimisticFetchRequest::new(
        optimistic_fetch_request.clone(),
        response_sender,
        time_service.clone(),
    );
    
    // Step 2: Validation passes (peer not banned yet)
    let validation_result = request_moderator.validate_request(
        &peer_network_id, 
        &optimistic_fetch_request
    );
    assert!(validation_result.is_ok());
    
    // Step 3: Simulate peer getting banned by sending invalid requests
    for _ in 0..config.max_invalid_requests_per_peer {
        let invalid_request = StorageServiceRequest::new(
            DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                proof_version: 0,  // Invalid: version 0 doesn't exist
                start_version: 1,
                end_version: 1000000000,  // Invalid: far future version
                include_events: false,
            }),
            false,
        );
        let _ = request_moderator.validate_request(&peer_network_id, &invalid_request);
    }
    
    // Verify peer is now banned
    let validation_after_ban = request_moderator.validate_request(
        &peer_network_id,
        &optimistic_fetch_request
    );
    assert!(matches!(validation_after_ban, Err(Error::TooManyInvalidRequests(_))));
    
    // Step 4: Process the optimistic fetch (simulating handle_ready_optimistic_fetches)
    // The response is sent even though peer is banned
    let missing_data_request = optimistic_fetch.get_storage_request_for_missing_data(
        config,
        &target_ledger_info,
    ).unwrap();
    
    let result = notify_peer_of_new_data(
        cached_storage_server_summary,
        Arc::new(DashMap::new()),
        Arc::new(DashMap::new()),
        Cache::new(100),
        request_moderator.clone(),
        storage,
        time_service,
        &peer_network_id,
        missing_data_request,
        target_ledger_info,
        optimistic_fetch.take_response_sender(),
    );
    
    // VULNERABILITY: Despite peer being banned, response_receiver can still receive data
    // In fixed version, response_receiver should receive error or no response
    let response = response_receiver.await;
    
    // Current behavior (vulnerable): response is Ok with data
    // Expected behavior (after fix): response should be Err or channel should be closed
    assert!(response.is_ok(), "Vulnerability: Banned peer received response!");
}
```

**Notes:**

The vulnerability represents a classic TOCTOU race condition in distributed systems. While the peer banning mechanism correctly validates requests at the entry point, it fails to re-validate before the expensive operation of sending responses completes. This creates a timing window exploitable by malicious peers to waste server resources even after being identified and banned for misbehavior. The fix requires adding a final ban status check immediately before response transmission to close this timing gap.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L48-69)
```rust
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L141-149)
```rust
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L291-316)
```rust
            // Spawn a blocking task to handle the optimistic fetch
            runtime.spawn_blocking(move || {
                // Get the fetch start time and request
                let optimistic_fetch_start_time = optimistic_fetch.fetch_start_time;
                let optimistic_fetch_request = optimistic_fetch.request.clone();

                // Handle the optimistic fetch request and time the operation
                let handle_request = || {
                    // Get the storage service request for the missing data
                    let missing_data_request = optimistic_fetch
                        .get_storage_request_for_missing_data(config, &target_ledger_info)?;

                    // Notify the peer of the new data
                    utils::notify_peer_of_new_data(
                        cached_storage_server_summary.clone(),
                        optimistic_fetches.clone(),
                        subscriptions.clone(),
                        lru_response_cache.clone(),
                        request_moderator.clone(),
                        storage.clone(),
                        time_service.clone(),
                        &peer_network_id,
                        missing_data_request,
                        target_ledger_info,
                        optimistic_fetch.take_response_sender(),
                    )
```

**File:** state-sync/storage-service/server/src/utils.rs (L113-114)
```rust
    let storage_response =
        handler.process_request(peer_network_id, missing_data_request.clone(), true);
```

**File:** state-sync/storage-service/server/src/utils.rs (L189-190)
```rust
    // Send the response to the peer
    handler.send_response(missing_data_request, Ok(storage_response), response_sender);
```

**File:** state-sync/storage-service/server/src/handler.rs (L211-213)
```rust
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;
```

**File:** state-sync/storage-service/server/src/handler.rs (L232-240)
```rust
    pub(crate) fn send_response(
        &self,
        request: StorageServiceRequest,
        response: aptos_storage_service_types::Result<StorageServiceResponse>,
        response_sender: ResponseSender,
    ) {
        log_storage_response(request, &response);
        response_sender.send(response);
    }
```

**File:** state-sync/storage-service/server/src/network.rs (L106-112)
```rust
    pub fn send(self, response: Result<StorageServiceResponse>) {
        let msg = StorageServiceMessage::Response(response);
        let result = bcs::to_bytes(&msg)
            .map(Bytes::from)
            .map_err(RpcError::BcsError);
        let _ = self.response_tx.send(result);
    }
```
