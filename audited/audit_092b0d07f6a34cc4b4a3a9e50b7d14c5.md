# Audit Report

## Title
Authentication Bypass in Faucet AuthTokenChecker via X-Is-JWT Header Presence Check

## Summary
The `AuthTokenChecker` contains a critical logic flaw that allows complete authentication bypass when any `x-is-jwt` header is present in the request, regardless of its value or whether JWT validation actually occurs. This enables attackers to drain faucet funds in configurations lacking JWT-validation mechanisms.

## Finding Description

The `AuthTokenChecker` is designed to validate authorization tokens before allowing faucet requests. However, it contains a flawed bypass logic that checks only for the **presence** of the `x-is-jwt` header, not its value or whether JWT validation actually happens elsewhere. [1](#0-0) 

This logic uses `contains_key()` which only verifies the header exists, not its value. An attacker can set `x-is-jwt: false` or `x-is-jwt: garbage` and completely bypass authentication.

The vulnerability chain operates as follows:

1. **Checker Execution Flow**: All checkers are evaluated sequentially in `preprocess_request()`, and requests are rejected only if any checker returns non-empty rejection vectors. [2](#0-1) 

2. **No Dedicated JWT Validation Checker Exists**: JWT validation only occurs within `RedisRatelimitChecker` when specifically configured for JWT-based ratelimiting (not IP-based). There is no separate JWT validation checker. [3](#0-2) 

3. **Vulnerable Configuration**: In configurations with `AuthTokenChecker` + IP-based rate limiting (or no JWT-aware checkers), the authentication bypass is complete: [4](#0-3) 

**Attack Scenario:**
- Attacker adds `x-is-jwt: false` header to request
- `AuthTokenChecker` sees the header exists and returns empty rejection vector (passes)
- `MemoryRatelimitChecker` performs IP-based ratelimiting only (no JWT validation)
- Other checkers (`IpBlocklistChecker`, `RefererBlocklistChecker`) are bypassed by using non-blocked IPs and omitting the Referer header
- With high rate limits (e.g., 1000000000), attacker makes unlimited requests
- Faucet funds are drained without any valid authentication token or JWT

## Impact Explanation

This vulnerability falls under **Critical Severity** per Aptos Bug Bounty criteria as it enables **Loss of Funds (theft or minting)**:

- Complete authentication bypass in vulnerable configurations
- Unlimited fund requests within rate limit bounds
- No privileged access required (any HTTP client can exploit)
- Affects all faucet instances configured with `AuthTokenChecker` but without JWT-validation mechanisms

While faucets typically distribute testnet tokens, the security question explicitly identifies this as a "[Fund Drainage] (Critical)" concern, and production faucets may control access to valuable resources or serve as attack vectors for broader ecosystem compromise.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Trivial Exploitation**: Requires only adding a single HTTP header (`x-is-jwt: false`)
2. **No Authentication Required**: Attacker needs no credentials, insider access, or cryptographic capabilities
3. **Wide Configuration Surface**: Any faucet using `AuthTokenChecker` without JWT-aware rate limiting is vulnerable
4. **Observable Behavior**: Test configurations demonstrate the vulnerability pattern
5. **Economic Incentive**: Direct financial benefit from draining faucet funds

The only barriers to exploitation are:
- Captcha requirements (if configured)
- Magic headers with secret values (if configured)
- Sufficiently low rate limits

However, many production configurations may rely primarily on `AuthTokenChecker` for security, making them vulnerable.

## Recommendation

**Immediate Fix**: Modify `AuthTokenChecker` to validate the header value is "true" and verify that JWT validation actually occurs:

```rust
// In crates/aptos-faucet/core/src/checkers/auth_token.rs
async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // Check if JWT header is present AND has value "true"
    let is_jwt = data
        .headers
        .get(X_IS_JWT_HEADER)
        .and_then(|v| v.to_str().ok())
        .map(|v| v.eq_ignore_ascii_case("true"))
        .unwrap_or(false);
    
    if is_jwt {
        // JWT mode: validation should happen in JWT-aware checker
        // Return rejection if no JWT-based ratelimit checker is configured
        return Ok(vec![RejectionReason::new(
            "JWT authentication requires JWT-based rate limiting to be configured".to_string(),
            RejectionReasonCode::AuthTokenInvalid,
        )]);
    }

    // Standard auth token validation
    let auth_token = match data
        .headers
        .get(AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.split_whitespace().nth(1))
    {
        Some(auth_token) => auth_token,
        None => return Ok(vec![RejectionReason::new(
            "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
            RejectionReasonCode::AuthTokenInvalid,
        )]),
    };
    
    if self.manager.contains(auth_token) {
        Ok(vec![])
    } else {
        Ok(vec![RejectionReason::new(
            format!("The given auth token is not allowed by the server: {}", auth_token),
            RejectionReasonCode::AuthTokenInvalid,
        )])
    }
}
```

**Long-term Solution**: Create a dedicated `JwtValidationChecker` that validates JWTs independently of rate limiting, ensuring authentication always occurs when JWT mode is enabled.

## Proof of Concept

```rust
#[tokio::test]
async fn test_auth_token_bypass_via_jwt_header() {
    use aptos_faucet_core::checkers::{AuthTokenChecker, CheckerData, CheckerTrait};
    use aptos_faucet_core::common::ListManagerConfig;
    use poem::http::HeaderMap;
    use std::net::IpAddr;
    use std::sync::Arc;

    // Setup AuthTokenChecker with valid tokens
    let config = ListManagerConfig {
        file: Some("/tmp/valid_tokens.txt".to_string()),
        list: Some(vec!["valid_token_123".to_string()]),
    };
    let checker = AuthTokenChecker::new(config).unwrap();

    // Create request data with x-is-jwt header but NO valid token or JWT
    let mut headers = HeaderMap::new();
    headers.insert("x-is-jwt", "false".parse().unwrap());  // Arbitrary value
    headers.insert("Authorization", "Bearer invalid_token".parse().unwrap());
    
    let checker_data = CheckerData {
        time_request_received_secs: 1234567890,
        receiver: "0x1".parse().unwrap(),
        source_ip: "127.0.0.1".parse::<IpAddr>().unwrap(),
        headers: Arc::new(headers),
    };

    // Check should return EMPTY rejection vector (authentication bypassed)
    let result = checker.check(checker_data, false).await.unwrap();
    
    assert!(
        result.is_empty(),
        "VULNERABILITY: AuthTokenChecker bypassed with x-is-jwt header! \
         Expected rejection for invalid token, got empty vector."
    );
    
    println!("âœ“ Authentication bypass confirmed: invalid token accepted with x-is-jwt header");
}
```

This PoC demonstrates that setting `x-is-jwt` header bypasses authentication even with invalid tokens, enabling fund drainage in vulnerable faucet configurations.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/configs/testing_checkers.yaml (L7-18)
```yaml
checker_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
  - type: "IpBlocklist"
    file: "/tmp/ip_blocklist.txt"
  - type: "RefererBlocklist"
    file: "/tmp/referer_blocklist.txt"
  - type: "MagicHeader"
    magic_header_key: "what_wallet_my_guy"
    magic_header_value: "the_wallet_that_rocks"
  - type: "MemoryRatelimit"
    max_requests_per_day: 1000000000
```
