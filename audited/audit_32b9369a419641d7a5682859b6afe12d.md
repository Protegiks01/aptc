# Audit Report

## Title
Silent Consensus Key Storage Failures During Key Rotation Lead to Validator Crashes at Epoch Boundaries

## Summary
The `storage()` function in `safety_rules_manager.rs` silently ignores errors when storing overriding consensus keys used for validator key rotation. [1](#0-0)  This causes validators to appear healthy during initialization but crash when attempting to load the missing key during epoch transitions, impacting network liveness.

## Finding Description

During validator initialization, the system loads overriding consensus keys for key rotation scenarios. These keys are stored via `storage.internal_store().set()`, but errors are only logged as warnings without propagating failures. [1](#0-0) 

The overriding identity blobs mechanism is specifically designed for consensus key rotation. [2](#0-1)  When validators rotate their consensus keys, they configure multiple identity blobs - the old key and the new key - to ensure seamless transition.

Storage operations can fail with transient errors such as IO failures or network issues when using remote backends like Vault. [3](#0-2) [4](#0-3) 

When a silently-failed key is later needed during epoch initialization, the system attempts to load it via `consensus_sk_by_pk()`. [5](#0-4)  If the key is not found, this function returns an error.

In `EpochManager`, when `load_consensus_key()` fails to retrieve the consensus key, the system panics and crashes the validator node. [6](#0-5) 

Alternatively, in `SafetyRules`, the same failure sets `validator_signer` to `None`, [7](#0-6)  preventing the validator from signing any consensus messages. [8](#0-7) 

**Attack Path:**
1. Validator operator initiates consensus key rotation by configuring overriding identity paths
2. During validator startup, transient storage failure occurs (disk I/O error, network timeout to Vault, temporary permission issue)
3. Error is logged but initialization completes "successfully"
4. Validator appears healthy and operational
5. Epoch boundary occurs, triggering `load_consensus_key()` which expects the new rotated key
6. Key is missing from storage, causing validator panic and crash
7. If multiple validators are rotating keys simultaneously, this impacts network liveness

## Impact Explanation

This qualifies as **HIGH severity** per Aptos bug bounty criteria:

- **Validator node crashes**: The panic in `epoch_manager.rs` directly crashes the validator process at epoch boundaries
- **Consensus availability impact**: Validators cannot participate in consensus when `validator_signer` is None
- **Coordinated failure risk**: Key rotation is often performed during planned maintenance windows when multiple validators may rotate simultaneously, amplifying the impact

The vulnerability violates the **Consensus Safety** invariant that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" by reducing the active validator set, potentially bringing the network closer to liveness failure thresholds.

If sufficient validators are affected during coordinated key rotations, this could escalate to **CRITICAL severity** as "Total loss of liveness/network availability."

## Likelihood Explanation

**Likelihood: Medium-High** during key rotation scenarios:

- Consensus key rotation is a regular operational procedure for security best practices
- Storage backends can experience transient failures (especially remote backends like Vault with network dependencies)
- Production environments often coordinate key rotations during maintenance windows, increasing simultaneous failure probability
- Operators have no mechanism to detect the silent failure until the epoch boundary crash occurs
- The failure is deterministic once the key is missing - every epoch transition will fail

## Recommendation

Propagate storage errors instead of silently logging them. Modify the key storage loop to return an error if any overriding key fails to store:

```rust
// In safety_rules_manager.rs, replace lines 86-97 with:
for blob in config
    .initial_safety_rules_config
    .overriding_identity_blobs()
    .unwrap_or_default()
{
    if let Some(sk) = blob.consensus_private_key {
        let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
        let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        storage.internal_store().set(storage_key.as_str(), sk)
            .map_err(|e| {
                error!("Failed to store overriding consensus key {}: {}", storage_key, e);
                e
            })?;
        info!("Successfully stored overriding consensus key: {}", storage_key);
    }
}
```

Additionally, implement validation after initialization to verify all expected keys are retrievable:

```rust
// Verify stored keys are accessible
for blob in config
    .initial_safety_rules_config
    .overriding_identity_blobs()
    .unwrap_or_default()
{
    if let Some(sk) = blob.consensus_private_key {
        let pk = PublicKey::from(&sk);
        storage.consensus_sk_by_pk(pk)
            .map_err(|e| {
                error!("Failed to verify stored overriding consensus key: {}", e);
                e
            })?;
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_silent_key_storage_failure() {
    use aptos_crypto::bls12381;
    use aptos_secure_storage::{InMemoryStorage, Storage, KVStorage};
    use std::sync::{Arc, Mutex};
    
    // Create a storage backend that fails on specific keys
    struct FailingStorage {
        inner: InMemoryStorage,
        fail_on_key: String,
    }
    
    impl KVStorage for FailingStorage {
        fn set(&mut self, key: &str, value: impl serde::Serialize) -> Result<(), aptos_secure_storage::Error> {
            if key.contains(&self.fail_on_key) {
                return Err(aptos_secure_storage::Error::InternalError(
                    "Simulated transient storage failure".to_string()
                ));
            }
            self.inner.set(key, value)
        }
        
        fn get<T: serde::de::DeserializeOwned>(&self, key: &str) -> Result<aptos_secure_storage::GetResponse<T>, aptos_secure_storage::Error> {
            self.inner.get(key)
        }
        
        // ... implement other required methods
    }
    
    // 1. Configure validator with overriding identity blob for key rotation
    let new_consensus_key = bls12381::PrivateKey::generate(&mut rand::thread_rng());
    let new_pk = bls12381::PublicKey::from(&new_consensus_key);
    let pk_hex = hex::encode(new_pk.to_bytes());
    
    // 2. Initialize with failing storage - this succeeds but key isn't stored
    let config = /* SafetyRulesConfig with overriding_identity_paths */;
    let storage = storage(&config); // Returns successfully despite failure
    
    // 3. Later, during epoch initialization, attempt to load the key
    let result = storage.consensus_sk_by_pk(new_pk);
    
    // 4. Verify the key is missing, which would cause panic in epoch_manager
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::ValidatorKeyNotFound(_)));
    
    // This demonstrates that initialization appears successful
    // but the validator will crash at epoch boundary
}
```

**Notes**

This vulnerability specifically affects validators performing consensus key rotation during periods of storage backend instability. The silent failure mode creates a dangerous operational scenario where validators appear healthy but are guaranteed to fail at the next epoch boundary. The impact is particularly severe because key rotations are often coordinated security operations, potentially affecting multiple validators simultaneously and threatening network liveness.

### Citations

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L89-96)
```rust
                match storage.internal_store().set(storage_key.as_str(), sk) {
                    Ok(_) => {
                        info!("Setting {storage_key} succeeded.");
                    },
                    Err(e) => {
                        warn!("Setting {storage_key} failed with internal store set error: {e}");
                    },
                }
```

**File:** config/src/config/safety_rules_config.rs (L170-187)
```rust
    pub fn overriding_identity_blobs(&self) -> anyhow::Result<Vec<IdentityBlob>> {
        match self {
            InitialSafetyRulesConfig::FromFile {
                overriding_identity_paths,
                ..
            } => {
                let mut blobs = vec![];
                for path in overriding_identity_paths {
                    let blob = IdentityBlob::from_file(path)?;
                    blobs.push(blob);
                }
                Ok(blobs)
            },
            InitialSafetyRulesConfig::None => {
                bail!("loading overriding identity blobs failed with missing initial safety rules config")
            },
        }
    }
```

**File:** secure/storage/src/error.rs (L38-42)
```rust
impl From<io::Error> for Error {
    fn from(error: io::Error) -> Self {
        Self::InternalError(format!("{}", error))
    }
}
```

**File:** secure/storage/src/error.rs (L56-63)
```rust
impl From<aptos_vault_client::Error> for Error {
    fn from(error: aptos_vault_client::Error) -> Self {
        match error {
            aptos_vault_client::Error::NotFound(_, key) => Self::KeyNotSet(key),
            aptos_vault_client::Error::HttpError(403, _, _) => Self::PermissionDenied,
            _ => Self::InternalError(format!("{}", error)),
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```

**File:** consensus/src/epoch_manager.rs (L1228-1233)
```rust
        let loaded_consensus_key = match self.load_consensus_key(&epoch_state.verifier) {
            Ok(k) => Arc::new(k),
            Err(e) => {
                panic!("load_consensus_key failed: {e}");
            },
        };
```

**File:** consensus/safety-rules/src/safety_rules.rs (L123-127)
```rust
    pub(crate) fn signer(&self) -> Result<&ValidatorSigner, Error> {
        self.validator_signer
            .as_ref()
            .ok_or_else(|| Error::NotInitialized("validator_signer".into()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L340-343)
```rust
        initialize_result.inspect_err(|error| {
            info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
            self.validator_signer = None;
        })
```
