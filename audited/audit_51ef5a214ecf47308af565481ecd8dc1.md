# Audit Report

## Title
Critical Consensus Liveness Failure Due to Unhandled Task Spawn Failures in Quorum Store

## Summary
The `spawn_named!` macro used to spawn critical quorum store tasks does not handle spawn failures. When resource exhaustion or runtime issues cause task spawning to fail, the quorum store enters a partially initialized state with no error reporting, leading to inevitable consensus failure and validator node dysfunction.

## Finding Description

The quorum store builder spawns 16 critical consensus tasks (1 coordinator + 1 batch generator + 10 batch coordinators + 1 proof coordinator + 1 proof manager + 1 network listener + 1 batch server) using the `spawn_named!` macro without any error handling. [1](#0-0) 

The `spawn_named!` macro has two compilation modes with catastrophic failure behaviors:

**Non-console mode** (production): Silently discards the `JoinHandle`, causing tasks to fail invisibly: [2](#0-1) 

**Console mode** (debugging): Panics the entire node on spawn failure: [3](#0-2) 

When `tokio::task::Builder::spawn()` fails (returning `Result<JoinHandle<T>, std::io::Error>`), it can occur due to:
- Runtime shutdown during epoch transitions
- Resource exhaustion (thread/task limits, memory pressure)
- OS-level resource constraints

The `spawn_quorum_store()` function returns successfully regardless of spawn failures: [4](#0-3) 

When spawns fail silently, the coordinator attempts to communicate with non-existent tasks, causing cascading panics via `.expect()` calls: [5](#0-4) 

The epoch manager starts the quorum store with no verification that tasks launched successfully: [6](#0-5) 

**Breaking Invariant**: This violates the **Consensus Safety** and **Deterministic Execution** invariants. A partially initialized quorum store cannot participate in consensus correctly, leading to liveness failure.

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This issue causes **"Total loss of liveness/network availability"**:

1. **Single Validator Impact**: The affected validator becomes non-functional but continues running, appearing healthy externally while failing to participate in consensus
2. **Network-Wide Impact**: If multiple validators experience spawn failures simultaneously (e.g., during coordinated epoch transitions or under network-wide load spikes), the network loses quorum capability
3. **Silent Failure Mode**: In production (non-console mode), failures are completely silent with no logs, metrics, or alerts, making diagnosis extremely difficult
4. **No Recovery Path**: The node continues running in a broken state indefinitely, requiring manual intervention to detect and restart

The default configuration spawns 16 tasks per validator: [7](#0-6) 

## Likelihood Explanation

**Likelihood: Medium to High**

Spawn failures can occur in realistic production scenarios:

1. **Epoch Transitions**: During epoch changes when old tasks are shutting down while new ones spawn, timing windows exist for failures
2. **Resource Pressure**: Production validators under sustained high transaction load may hit OS-level thread or memory limits
3. **Runtime Lifecycle**: Tokio runtime shutdown/restart sequences create race conditions
4. **Platform Limits**: Linux systems have `ulimit` restrictions on threads/tasks per process
5. **Container Environments**: Kubernetes/Docker resource limits can trigger spawn failures under load

The runtime creation itself panics on failure, but individual task spawns do not: [8](#0-7) 

## Recommendation

Replace `spawn_named!` with error-handling spawn wrappers that return `Result`:

```rust
// In quorum_store_builder.rs
fn spawn_quorum_store(mut self) -> Result<(
    Sender<CoordinatorCommand>,
    aptos_channel::Sender<AccountAddress, IncomingBatchRetrievalRequest>,
), anyhow::Error> {
    // ... setup code ...

    // Replace spawn_named! calls with checked spawns:
    let coordinator_handle = tokio::spawn(quorum_store_coordinator.start(coordinator_rx));
    if coordinator_handle.is_finished() {
        bail!("Failed to spawn quorum_store_coordinator");
    }

    let batch_generator_handle = tokio::spawn(batch_generator.start(
        self.network_sender.clone(),
        batch_generator_cmd_rx,
        back_pressure_rx,
        interval
    ));
    if batch_generator_handle.is_finished() {
        bail!("Failed to spawn batch_generator");
    }

    // ... repeat for all critical tasks ...

    Ok((self.coordinator_tx, batch_retrieval_tx))
}
```

Update the epoch manager to handle failures:
```rust
// In epoch_manager.rs
fn start_quorum_store(&mut self, quorum_store_builder: QuorumStoreBuilder) -> Result<(), anyhow::Error> {
    if let Some((quorum_store_coordinator_tx, batch_retrieval_rx)) =
        quorum_store_builder.start()?
    {
        self.quorum_store_coordinator_tx = Some(quorum_store_coordinator_tx);
        self.batch_retrieval_tx = Some(batch_retrieval_rx);
    }
    Ok(())
}
```

Add monitoring and metrics for spawn failures to enable proactive detection.

## Proof of Concept

```rust
#[tokio::test]
async fn test_spawn_failure_causes_consensus_failure() {
    use tokio::runtime::Builder;
    
    // Create a runtime with severely limited resources
    let rt = Builder::new_multi_thread()
        .worker_threads(1)
        .max_blocking_threads(1) // Very low limit
        .build()
        .unwrap();
    
    rt.block_on(async {
        // Saturate the runtime with blocking tasks
        let _handles: Vec<_> = (0..100).map(|_| {
            tokio::task::spawn_blocking(|| {
                std::thread::sleep(std::time::Duration::from_secs(10));
            })
        }).collect();
        
        // Attempt to spawn quorum store tasks - will fail silently
        // In production, this results in partial initialization
        spawn_named!("test_task", async {
            // This task may never actually start
            loop {
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
            }
        });
        
        // The spawn appeared to succeed, but the task never runs
        // Channels to this task will cause send failures
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        
        // In the real quorum store, this leads to consensus halt
        assert!(true, "Spawn 'succeeded' but task never started - silent failure");
    });
}
```

To reproduce in a full node environment:
1. Configure a validator with `ulimit -u 1024` (low process limit)
2. Subject the node to high transaction throughput
3. Monitor quorum store task spawning during epoch transitions
4. Observe silent failures and subsequent consensus liveness loss

## Notes

This vulnerability demonstrates a systemic issue with error handling in critical consensus infrastructure. The `spawn_named!` macro prioritizes developer convenience over operational safety, making it unsuitable for mission-critical consensus tasks where spawn failures must be detected and handled explicitly.

The issue is exacerbated by the `.expect()` calls throughout the coordinator code, which convert channel send failures into panics rather than graceful degradation. A defense-in-depth approach would require both spawn error handling AND graceful channel error handling.

### Citations

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L275-280)
```rust
    fn spawn_quorum_store(
        mut self,
    ) -> (
        Sender<CoordinatorCommand>,
        aptos_channel::Sender<AccountAddress, IncomingBatchRetrievalRequest>,
    ) {
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L295-298)
```rust
        spawn_named!(
            "quorum_store_coordinator",
            quorum_store_coordinator.start(coordinator_rx)
        );
```

**File:** crates/aptos-logger/src/macros.rs (L6-14)
```rust
#[macro_export]
macro_rules! spawn_named {
      ($name:expr, $func:expr) => { tokio::spawn($func); };
      ($name:expr, $handler:expr, $func:expr) => { $handler.spawn($func); };
      ($name:expr, $async:ident = async; $clojure:block) => { tokio::spawn( async $clojure); };
      ($name:expr, $handler:expr, $async:ident = async; $clojure:block) => { $handler.spawn( async $clojure); };
      ($name:expr, $async:ident = async ; $move:ident = move; $clojure:block) => { tokio::spawn( async move $clojure); };
      ($name:expr, $handler:expr, $async:ident = async ; $move:ident = move; $clojure:block) => { $handler.spawn( async move $clojure); };
  }
```

**File:** crates/aptos-logger/src/macros.rs (L16-48)
```rust
#[cfg(feature = "tokio-console")]
#[macro_export]
macro_rules! spawn_named {
      ($name:expr, $func:expr) => { tokio::task::Builder::new()
                                          .name($name)
                                          .spawn($func)
                                          .unwrap(); };
      ($name:expr, $handle:expr, $func:expr) => { tokio::task::Builder::new()
                                                      .name($name)
                                                      .spawn_on($func, $handle)
                                                      .unwrap(); };

      ($name:expr, $async:ident = async; $clojure:block) => { tokio::task::Builder::new()
                                                                      .name($name)
                                                                      .spawn(async $clojure)
                                                                      .unwrap(); };

      ($name:expr, $async:ident = async; $move:ident = move; $clojure:block) => { tokio::task::Builder::new()
                                                                      .name($name)
                                                                      .spawn(async move $clojure)
                                                                      .unwrap(); };

      ($name:expr, $handler:expr, $async:ident = async; $clojure:block) => { tokio::task::Builder::new()
                                                                              .name($name)
                                                                              .spawn_on(async $clojure, $handler)
                                                                              .unwrap(); };

      ($name:expr, $handler:expr, $async:ident = async; $move:ident = move; $clojure:block) => { tokio::task::Builder::new()
                                                                                                  .name($name)
                                                                                                  .spawn_on(async move $clojure, $handler)
                                                                                                  .unwrap(); };

}
```

**File:** consensus/src/quorum_store/quorum_store_coordinator.rs (L74-80)
```rust
                        self.batch_generator_cmd_tx
                            .send(BatchGeneratorCommand::CommitNotification(
                                block_timestamp,
                                batches,
                            ))
                            .await
                            .expect("Failed to send to BatchGenerator");
```

**File:** consensus/src/epoch_manager.rs (L1005-1012)
```rust
    fn start_quorum_store(&mut self, quorum_store_builder: QuorumStoreBuilder) {
        if let Some((quorum_store_coordinator_tx, batch_retrieval_rx)) =
            quorum_store_builder.start()
        {
            self.quorum_store_coordinator_tx = Some(quorum_store_coordinator_tx);
            self.batch_retrieval_tx = Some(batch_retrieval_rx);
        }
    }
```

**File:** config/src/config/quorum_store_config.rs (L136-139)
```rust
            back_pressure: QuorumStoreBackPressureConfig::default(),
            // number of batch coordinators to handle QS batch messages, should be >= 1
            num_workers_for_remote_batches: 10,
            batch_buckets: DEFAULT_BUCKETS.to_vec(),
```

**File:** crates/aptos-runtimes/src/lib.rs (L56-63)
```rust
    // Spawn and return the runtime
    builder.build().unwrap_or_else(|error| {
        panic!(
            "Failed to spawn named runtime! Name: {:?}, Error: {:?}",
            thread_name, error
        )
    })
}
```
