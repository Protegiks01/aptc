# Audit Report

## Title
Missing Transaction Version Continuity Validation in Indexer Cache Worker Leads to Data Integrity Violations and Service Unavailability

## Summary
The `process_transactions_from_node_response()` function in the indexer cache worker does not validate that transaction versions within a received batch are continuous and properly ordered. This allows malicious or buggy fullnodes to inject transactions with gaps into the Redis cache, causing persistent data integrity issues and downstream service failures.

## Finding Description

The cache worker's `process_transactions_from_node_response()` function only validates that the transaction list is non-empty, but fails to verify version continuity and ordering within the batch. [1](#0-0) 

The function extracts first and last transaction versions and calculates metrics assuming continuity without actual validation: [2](#0-1) 

This calculation `(last_transaction_version + 1 - first_transaction_version)` assumes all intermediate versions exist, but this is never checked.

The transactions are then stored in Redis via `update_cache_transactions()`: [3](#0-2) 

The storage operation simply iterates through transactions and stores each by its version number: [4](#0-3) 

If a malicious or buggy fullnode sends transactions [100, 102, 105] in a single data frame, the cache worker will:
1. Store these three transactions at their respective version keys
2. Increment `current_version` by 3 (the count)
3. Leave gaps at versions 101, 103, 104

The batch-end validation only checks against the fullnode's declared metadata: [5](#0-4) 

If the fullnode provides consistent (but incorrect) batch metadata, this check passes despite the gaps.

**Downstream Impact:**

When the data service attempts to fetch a range including these gaps, it fails: [6](#0-5) 

This causes persistent fetch failures and service unavailability. The data service's gap detection logic will panic when it detects missing versions: [7](#0-6) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

- **API crashes**: The indexer data service becomes unavailable for transaction ranges containing gaps, affecting all clients querying those ranges
- **Significant protocol violations**: Breaks the fundamental indexer invariant that transaction history must be complete and continuous

While this does not affect core consensus or the main blockchain, it severely impacts the indexer infrastructure that many applications depend on for historical data access.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability requires:
1. A compromised or buggy fullnode serving the gRPC endpoint to the cache worker
2. The fullnode sending non-continuous transaction batches

While the fullnode code attempts to provide continuous transactions through sorting and database fetches, there is no guarantee against:
- Database corruption or bugs causing gaps
- Malicious fullnode operators intentionally sending gapped data
- Software bugs in the transaction fetching logic

Once exploited, the impact is persistent - the gaps remain in cache indefinitely until manual intervention.

## Recommendation

Add validation in `process_transactions_from_node_response()` to ensure transaction version continuity:

```rust
// After extracting first and last transactions (after line 227)
let first_transaction_version = first_transaction.version;
let last_transaction_version = last_transaction.version;

// Validate continuity and ordering
let expected_count = last_transaction_version - first_transaction_version + 1;
if data.transactions.len() as u64 != expected_count {
    bail!(
        "Transaction count mismatch: expected {} transactions from version {} to {}, but got {}",
        expected_count,
        first_transaction_version,
        last_transaction_version,
        data.transactions.len()
    );
}

// Validate each transaction has correct sequential version
for (i, txn) in data.transactions.iter().enumerate() {
    let expected_version = first_transaction_version + i as u64;
    if txn.version != expected_version {
        bail!(
            "Non-continuous transaction versions: expected version {}, got version {}",
            expected_version,
            txn.version
        );
    }
}
```

This ensures the cache worker only accepts properly ordered, continuous transaction batches, preventing data integrity violations.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::transaction::v1::Transaction;
    
    #[tokio::test]
    async fn test_non_continuous_transactions_should_fail() {
        // Create mock transactions with gaps
        let transactions = vec![
            Transaction { version: 100, ..Default::default() },
            Transaction { version: 102, ..Default::default() }, // Gap at 101
            Transaction { version: 105, ..Default::default() }, // Gaps at 103, 104
        ];
        
        let response = TransactionsFromNodeResponse {
            response: Some(Response::Data(TransactionsOutput {
                transactions,
            })),
            chain_id: 1,
        };
        
        // This should fail validation but currently doesn't
        let result = process_transactions_from_node_response(
            response,
            &mut cache_operator,
            std::time::Instant::now(),
        ).await;
        
        // Expected: Error due to non-continuous versions
        // Actual: Succeeds and stores gapped transactions in cache
        assert!(result.is_err(), "Should reject non-continuous transactions");
    }
}
```

## Notes

This vulnerability is scoped to the indexer infrastructure, not core consensus. However, it represents a significant data integrity issue that can cause persistent service unavailability for indexer clients. The lack of input validation violates defense-in-depth principles - the cache worker should not blindly trust fullnode data without verification.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L214-227)
```rust
                let first_transaction = data
                    .transactions
                    .first()
                    .context("There were unexpectedly no transactions in the response")?;
                let first_transaction_version = first_transaction.version;
                let last_transaction = data
                    .transactions
                    .last()
                    .context("There were unexpectedly no transactions in the response")?;
                let last_transaction_version = last_transaction.version;
                let start_version = first_transaction.version;
                let first_transaction_pb_timestamp = first_transaction.timestamp;
                let last_transaction_pb_timestamp = last_transaction.timestamp;

```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L237-239)
```rust
                    Some((last_transaction_version + 1 - first_transaction_version) as i64),
                    None,
                );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L244-246)
```rust
                    // Push to cache.
                    match cache_operator_clone
                        .update_cache_transactions(data.transactions)
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L433-443)
```rust
                    if current_version != start_version + num_of_transactions {
                        error!(
                            current_version = current_version,
                            actual_current_version = start_version + num_of_transactions,
                            "[Indexer Cache] End signal received with wrong version."
                        );
                        ERROR_COUNT
                            .with_label_values(&["data_end_wrong_version"])
                            .inc();
                        break;
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L244-247)
```rust
        ensure!(
            transactions.len() == transaction_count as usize,
            "Failed to get all transactions from cache."
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L264-278)
```rust
        for transaction in transactions {
            let version = transaction.version;
            let cache_key = CacheEntry::build_key(version, self.storage_format).to_string();
            let timestamp_in_seconds = transaction.timestamp.map_or(0, |t| t.seconds as u64);
            let cache_entry: CacheEntry =
                CacheEntry::from_transaction(transaction, self.storage_format);
            let bytes = cache_entry.into_inner();
            size_in_bytes += bytes.len();
            redis_pipeline
                .cmd("SET")
                .arg(cache_key)
                .arg(bytes)
                .arg("EX")
                .arg(get_ttl_in_seconds(timestamp_in_seconds))
                .ignore();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L637-658)
```rust
            if prev_end + 1 != start_version {
                NUM_MULTI_FETCH_OVERLAPPED_VERSIONS
                    .with_label_values(&[SERVICE_TYPE, "gap"])
                    .inc_by(prev_end - start_version + 1);

                tracing::error!(
                    batch_first_version = first_version,
                    batch_last_version = last_version,
                    start_version = start_version,
                    end_version = end_version,
                    prev_start = ?prev_start,
                    prev_end = prev_end,
                    "[Filestore] Gaps or dupes in processing version data"
                );
                panic!("[Filestore] Gaps in processing data batch_first_version: {}, batch_last_version: {}, start_version: {}, end_version: {}, prev_start: {:?}, prev_end: {:?}",
                       first_version,
                       last_version,
                       start_version,
                       end_version,
                       prev_start,
                       prev_end,
                );
```
