# Audit Report

## Title
Genesis Transaction Data Loss in Fast Sync Mode Leading to State Sync Failures and Network Fragmentation

## Summary
The `bootstrap_db()` function in `aptos-node/src/storage.rs` applies genesis to different databases depending on the bootstrap mode, but in fast sync mode, the genesis transaction is only written to a temporary database while the main database receives only the genesis ledger info metadata. After fast sync completes, the main database is used for all operations but lacks the genesis transaction data, preventing the validator from serving genesis transaction requests to peers and causing state synchronization failures.

## Finding Description

The vulnerability exists in the dual-database architecture used during fast sync bootstrap. The code flow creates an inconsistent state:

**Normal Bootstrap Path (Either::Left):** [1](#0-0) 

In this path, `maybe_apply_genesis` is called on the main database, which results in the full genesis transaction being persisted.

**Fast Sync Bootstrap Path (Either::Right):** [2](#0-1) 

In this path, genesis is applied to the temporary database (line 77), but only the genesis ledger info is committed to the main database (line 93), NOT the full genesis transaction data.

The `maybe_apply_genesis` function calls `maybe_bootstrap`, which commits the complete genesis data: [3](#0-2) 

The `maybe_bootstrap` function uses `save_transactions` which persists the full transaction data, outputs, state updates, and ledger state: [4](#0-3) 

However, `commit_genesis_ledger_info` only writes the ledger info metadata: [5](#0-4) 

After fast sync completes, the `FastSyncStorageWrapper` switches read operations from the temporary database to the main database: [6](#0-5) 

This status transition occurs when state snapshot finalization completes: [7](#0-6) 

**The Critical Problem:**
When another validator attempts to sync from a fast-synced validator starting at version 0, the `get_transactions` method will fail because the genesis transaction does not exist in the main database: [8](#0-7) 

This breaks the **State Consistency** invariant because validators have divergent transaction histories depending on their bootstrap mode, and breaks the **Deterministic Execution** invariant as some validators cannot reproduce the full chain from genesis.

## Impact Explanation

This is a **HIGH severity** vulnerability per the Aptos bug bounty criteria due to "Significant protocol violations":

1. **State Sync Failures**: Validators that bootstrapped with fast sync cannot serve genesis transaction requests (version 0) to peers, causing state synchronization to fail for new validators attempting to sync from genesis.

2. **Network Fragmentation**: The network becomes partitioned where some validators have complete transaction history while others lack genesis transaction data, leading to inconsistent views of the blockchain.

3. **Validator Onboarding Failures**: New validators attempting to sync from a fast-synced validator will fail when requesting transactions starting from version 0, preventing them from joining the network.

4. **Data Integrity Violation**: Different validators have fundamentally different databases - some with genesis transaction data, some without - violating the principle that all validators should maintain identical ledger states.

5. **API Inconsistency**: REST API queries for transaction at version 0 (`/transactions/by_version/0`) will succeed on normally bootstrapped validators but fail on fast-synced validators, creating an inconsistent user experience.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability triggers automatically under normal operational conditions:

- Any validator configured with fast sync mode enabled (common for new validators joining an established network) will exhibit this bug
- No attacker action required - it's a natural consequence of the bootstrap code path
- Fast sync is a recommended feature for reducing sync time, making it widely deployed
- The issue persists permanently after the validator completes fast sync
- Every state sync request for genesis transactions from fast-synced validators will fail

## Recommendation

**Solution: Persist Full Genesis Transaction to Main Database**

Modify the fast sync bootstrap path to commit the complete genesis transaction data to the main database, not just the ledger info. The fix should be applied in `aptos-node/src/storage.rs` around lines 86-94:

```rust
// After applying genesis to temporary DB
let temp_db_rw = DbReaderWriter::from_arc(temp_db.clone());
maybe_apply_genesis(&temp_db_rw, node_config)?;

// Get genesis data from temporary DB
let genesis_txn = temp_db.ledger_db.transaction_db().get_transaction(0)?;
let genesis_info = temp_db.ledger_db.transaction_info_db().get_transaction_info(0)?;
let genesis_output = temp_db.ledger_db.transaction_info_db().get_transaction_output(0)?;
let genesis_events = temp_db.ledger_db.event_db().get_events_by_version(0)?;

// Commit full genesis to main fast_sync_db, not just ledger info
if fast_sync_db.get_latest_ledger_info_option()?.is_none() {
    // Create ChunkToCommit with genesis data
    let chunk = ChunkToCommit::new(...); // with full genesis transaction data
    fast_sync_db.save_transactions(&chunk, Some(&ledger_info), true)?;
}
```

**Alternative Solution: Always Serve Genesis from Temporary Database**

Modify `FastSyncStorageWrapper::get_aptos_db_read_ref()` to check if the requested version is 0 and route to temporary database even after fast sync completes, ensuring genesis queries always succeed.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_fast_sync_genesis_transaction_loss() {
    // Setup: Create a validator with fast sync enabled
    let mut node_config = NodeConfig::default();
    node_config.state_sync.state_sync_driver.bootstrapping_mode = 
        BootstrappingMode::DownloadLatestStates;
    
    // Bootstrap the validator with fast sync mode
    let (_db_reader, db_rw, _, _, _) = bootstrap_db(&node_config).unwrap();
    
    // Wait for fast sync to complete (status becomes FINISHED)
    // ... fast sync completion logic ...
    
    // Attempt to read genesis transaction (version 0)
    let result = db_rw.reader.get_transaction_by_version(0, 100, false);
    
    // VULNERABILITY: This will fail because genesis transaction 
    // was never committed to the main database
    assert!(result.is_err(), "Genesis transaction should not exist in main DB");
    
    // Expected behavior: Genesis transaction should be available
    // assert!(result.is_ok(), "Genesis transaction should exist");
}

// Test demonstrating state sync failure
#[tokio::test] 
async fn test_state_sync_fails_from_fast_synced_validator() {
    // Validator A: Fast sync bootstrap
    let validator_a = setup_fast_sync_validator().await;
    complete_fast_sync(validator_a).await;
    
    // Validator B: New validator trying to sync from A starting at version 0
    let validator_b = setup_new_validator().await;
    
    // Validator B requests transactions starting from version 0
    let sync_request = validator_b.request_transactions(0, 100);
    
    // VULNERABILITY: Request fails because validator A cannot serve genesis
    assert!(sync_request.is_err(), "State sync should fail");
    
    // This prevents validator B from joining the network
}
```

## Notes

This vulnerability demonstrates a fundamental architectural flaw in the fast sync implementation where two databases maintain inconsistent data. The temporary database serves as the source of truth for genesis during the fast sync process, but after completion, the main database lacks critical historical data. This violates the blockchain's requirement that all validators maintain complete and identical transaction histories, even if they can optimize initial sync through state snapshots.

The issue is particularly severe because it's not immediately visible - the validator appears to function normally for consensus and execution of new transactions, but silently fails when attempting to serve historical data to peers, creating a subtle but critical network-wide consistency problem.

### Citations

**File:** aptos-node/src/storage.rs (L23-43)
```rust
pub(crate) fn maybe_apply_genesis(
    db_rw: &DbReaderWriter,
    node_config: &NodeConfig,
) -> Result<Option<LedgerInfoWithSignatures>> {
    // We read from the storage genesis waypoint and fallback to the node config one if it is none
    let genesis_waypoint = node_config
        .execution
        .genesis_waypoint
        .as_ref()
        .unwrap_or(&node_config.base.waypoint)
        .genesis_waypoint();
    if let Some(genesis) = get_genesis_txn(node_config) {
        let ledger_info_opt =
            maybe_bootstrap::<AptosVMBlockExecutor>(db_rw, genesis, genesis_waypoint)
                .map_err(|err| anyhow!("DB failed to bootstrap {}", err))?;
        Ok(ledger_info_opt)
    } else {
        info ! ("Genesis txn not provided! This is fine only if you don't expect to apply it. Otherwise, the config is incorrect!");
        Ok(None)
    }
}
```

**File:** aptos-node/src/storage.rs (L68-74)
```rust
        Either::Left(db) => {
            let (db_arc, db_rw) = DbReaderWriter::wrap(db);
            let db_backup_service =
                start_backup_service(node_config.storage.backup_service_address, db_arc.clone());
            maybe_apply_genesis(&db_rw, node_config)?;
            (db_arc as Arc<dyn DbReader>, db_rw, Some(db_backup_service))
        },
```

**File:** aptos-node/src/storage.rs (L75-94)
```rust
        Either::Right(fast_sync_db_wrapper) => {
            let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
            maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
            let (db_arc, db_rw) = DbReaderWriter::wrap(fast_sync_db_wrapper);
            let fast_sync_db = db_arc.get_fast_sync_db();
            // FastSyncDB requires ledger info at epoch 0 to establish provenance to genesis
            let ledger_info = db_arc
                .get_temporary_db_with_genesis()
                .get_epoch_ending_ledger_info(0)
                .expect("Genesis ledger info must exist");

            if fast_sync_db
                .get_latest_ledger_info_option()
                .expect("should returns Ok results")
                .is_none()
            {
                // it means the DB is empty and we need to
                // commit the genesis ledger info to the DB.
                fast_sync_db.commit_genesis_ledger_info(&ledger_info)?;
            }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L48-71)
```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }

    let committer = calculate_genesis::<V>(db, ledger_summary, genesis_txn)?;
    ensure!(
        waypoint == committer.waypoint(),
        "Waypoint verification failed. Expected {:?}, got {:?}.",
        waypoint,
        committer.waypoint(),
    );
    let ledger_info = committer.output.ledger_info_opt.clone();
    committer.commit()?;
    Ok(ledger_info)
}
```

**File:** storage/aptosdb/src/db/mod.rs (L207-219)
```rust
    pub fn commit_genesis_ledger_info(&self, genesis_li: &LedgerInfoWithSignatures) -> Result<()> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let current_epoch = ledger_metadata_db
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            genesis_li.ledger_info().epoch() == current_epoch && current_epoch == 0,
            "Genesis ledger info epoch is not 0"
        );
        let mut ledger_batch = SchemaBatch::new();
        ledger_metadata_db.put_ledger_info(genesis_li, &mut ledger_batch)?;
        ledger_metadata_db.write_schemas(ledger_batch)
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L126-132)
```rust
    pub(crate) fn get_aptos_db_read_ref(&self) -> &AptosDB {
        if self.is_fast_sync_bootstrap_finished() {
            self.db_for_fast_sync.as_ref()
        } else {
            self.temporary_db_with_genesis.as_ref()
        }
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L154-170)
```rust
    fn finalize_state_snapshot(
        &self,
        version: Version,
        output_with_proof: TransactionOutputListWithProofV2,
        ledger_infos: &[LedgerInfoWithSignatures],
    ) -> Result<()> {
        let status = self.get_fast_sync_status();
        assert_eq!(status, FastSyncStatus::STARTED);
        self.get_aptos_db_write_ref().finalize_state_snapshot(
            version,
            output_with_proof,
            ledger_infos,
        )?;
        let mut status = self.fast_sync_status.write();
        *status = FastSyncStatus::FINISHED;
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L267-293)
```rust
    fn get_transactions(
        &self,
        start_version: Version,
        limit: u64,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<TransactionListWithProofV2> {
        gauged_api("get_transactions", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;

            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionListWithProofV2::new_empty());
            }
            self.error_if_ledger_pruned("Transaction", start_version)?;

            let limit = std::cmp::min(limit, ledger_version - start_version + 1);

            let txns = (start_version..start_version + limit)
                .map(|version| self.ledger_db.transaction_db().get_transaction(version))
                .collect::<Result<Vec<_>>>()?;
            let txn_infos = (start_version..start_version + limit)
                .map(|version| {
                    self.ledger_db
                        .transaction_info_db()
                        .get_transaction_info(version)
                })
                .collect::<Result<Vec<_>>>()?;
```
