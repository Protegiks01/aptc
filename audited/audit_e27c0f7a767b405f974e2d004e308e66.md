# Audit Report

## Title
Permanent Session Invalidation Due to Monotonic Nonce in Out-of-Order Message Scenarios

## Summary
The Noise protocol implementation in Aptos permanently invalidates the entire session after any decryption failure, including those caused by out-of-order message delivery. While TCP provides ordering guarantees that prevent out-of-order delivery under normal conditions, this design creates a brittleness that could impact network reliability if the ordering guarantee is violated through implementation bugs, connection handling errors, or sophisticated network manipulation.

## Finding Description

The `NoiseSession::read_message_in_place()` function uses a monotonically incrementing `read_nonce` to decrypt messages. [1](#0-0) 

When decryption fails for any reason, the session is permanently marked as invalid. [2](#0-1) 

Once marked invalid, all subsequent read attempts fail immediately, regardless of whether the data is valid. [3](#0-2) 

**The Out-of-Order Scenario:**

If messages were to arrive out of order:
1. Message encrypted with nonce N arrives and decrypts successfully, `read_nonce` becomes N+1
2. Message encrypted with nonce N+2 arrives next (out of order)
3. Receiver attempts decryption with `read_nonce = N+1`, but ciphertext was encrypted with nonce N+2
4. Decryption fails, session is permanently invalidated (`self.valid = false`)
5. Message encrypted with nonce N+1 arrives (the missing message)
6. Cannot be decrypted because the check at line 668 fails - session is already closed
7. **All subsequent messages fail permanently**, even though they have correct nonces

This behavior is used in the network transport layer. [4](#0-3) 

## Impact Explanation

**Severity Assessment: Medium to High**

While TCP provides ordering guarantees that prevent this under normal operation, [5](#0-4)  this vulnerability could manifest through:

1. **Implementation Bugs**: Connection reuse, connection pooling bugs, or state management errors could cause nonce desynchronization
2. **Network Stack Issues**: Bugs in the TCP implementation or network stack
3. **Sophisticated Attacks**: Network-level manipulation by attackers with privileged network access

**Impact:**
- **Validator Node Slowdowns**: Frequent reconnections due to session failures impact consensus performance
- **Network Availability**: Degraded connectivity between validators affects liveness
- **Denial of Service Vector**: Any condition causing a single decryption failure forces complete session restart

This violates the **liveness requirement** for the Aptos network layer and creates unnecessary brittleness in the validator communication system.

## Likelihood Explanation

**Likelihood: Low to Medium**

Under normal operation with correct TCP implementation, messages arrive in order and this issue does not manifest. However:

- **Network Implementation Complexity**: The interaction between TCP, NoiseStream framing, and AEAD encryption creates multiple failure points
- **Connection Handling**: Any bugs in connection lifecycle management could trigger this
- **Transient Network Issues**: While TCP handles most cases, edge cases in connection recovery could cause issues

The permanent session invalidation on ANY decryption failure (not just out-of-order) means that even transient issues or corrupted data permanently break the connection, requiring expensive reconnection overhead.

## Recommendation

Implement a more resilient error handling strategy:

**Option 1: Limited Retry Window**
Allow a small window of nonce flexibility (e.g., accept nonces N or N+1) to handle transient issues while maintaining security.

**Option 2: Session Reset Without Permanent Invalidation**
Instead of permanently invalidating on first failure, allow the session to attempt recovery or provide clearer separation between fatal and transient errors.

**Option 3: Add Explicit Ordering Checks**
Include sequence numbers in the application protocol layer to detect and handle out-of-order delivery explicitly, rather than relying solely on AEAD nonce matching.

**Recommended Fix (Option 2):**
```rust
// In read_message_in_place():
read_key
    .open_in_place(nonce, aead::Aad::empty(), message)
    .map_err(|_| {
        // Log error but don't permanently invalidate for potential transient issues
        // Consider adding retry logic or explicit sequencing
        NoiseError::Decrypt
    })?;
```

Consider adding application-level sequence numbers separate from cryptographic nonces to provide better error recovery and diagnostics.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use aptos_crypto::{noise::NoiseSession, x25519};
    
    #[test]
    fn test_out_of_order_message_failure() {
        // Create two sessions (after handshake)
        let mut sender = NoiseSession::new_for_testing();
        let mut receiver = NoiseSession::new_for_testing();
        
        // Sender creates three messages
        let mut msg1 = b"message1".to_vec();
        let tag1 = sender.write_message_in_place(&mut msg1).unwrap();
        msg1.extend_from_slice(&tag1);
        
        let mut msg2 = b"message2".to_vec();
        let tag2 = sender.write_message_in_place(&mut msg2).unwrap();
        msg2.extend_from_slice(&tag2);
        
        let mut msg3 = b"message3".to_vec();
        let tag3 = sender.write_message_in_place(&mut msg3).unwrap();
        msg3.extend_from_slice(&tag3);
        
        // Receiver gets msg1 successfully
        let result1 = receiver.read_message_in_place(&mut msg1);
        assert!(result1.is_ok());
        
        // Simulate out-of-order: msg3 arrives before msg2
        let result3 = receiver.read_message_in_place(&mut msg3);
        assert!(result3.is_err()); // Decryption fails - wrong nonce
        
        // Now msg2 arrives, but session is permanently closed
        let result2 = receiver.read_message_in_place(&mut msg2);
        assert!(result2.is_err()); // Fails with SessionClosed
        assert_eq!(result2.unwrap_err().to_string(), "noise: session was closed due to decrypt error");
        
        // All subsequent messages also fail
        let mut msg4 = b"message4".to_vec();
        let tag4 = sender.write_message_in_place(&mut msg4).unwrap();
        msg4.extend_from_slice(&tag4);
        let result4 = receiver.read_message_in_place(&mut msg4);
        assert!(result4.is_err()); // Still fails - session is dead
    }
}
```

## Notes

**Critical Consideration**: While the code behavior matches the security question (monotonic nonce causes permanent failure on out-of-order messages), the practical exploitability is limited because:

1. Aptos uses TCP as the base transport, which provides strong ordering guarantees
2. Each peer-to-peer connection has its own isolated NoiseSession
3. No apparent mechanism for an external attacker to cause out-of-order delivery at the application layer without compromising the TCP stack itself

However, the brittleness of permanent session invalidation on ANY decryption failure (whether from out-of-order messages, corrupted data, or other causes) creates an unnecessary fragility in the validator network that could impact consensus liveness under adverse conditions or implementation bugs. The issue is more about **design robustness** than an immediately exploitable vulnerability.

### Citations

**File:** crates/aptos-crypto/src/noise.rs (L668-670)
```rust
        if !self.valid {
            return Err(NoiseError::SessionClosed);
        }
```

**File:** crates/aptos-crypto/src/noise.rs (L683-688)
```rust
        let mut nonce = [0u8; 4].to_vec();
        nonce.extend_from_slice(&self.read_nonce.to_be_bytes());
        assert_eq!(nonce.len(), 12);
        let nonce = aead::Nonce::assume_unique_for_key(
            nonce.try_into().expect("Wrong AES256-GCM nonce length"),
        );
```

**File:** crates/aptos-crypto/src/noise.rs (L690-695)
```rust
        read_key
            .open_in_place(nonce, aead::Aad::empty(), message)
            .map_err(|_| {
                self.valid = false;
                NoiseError::Decrypt
            })?;
```

**File:** network/framework/src/noise/stream.rs (L145-158)
```rust
                            match self.session.read_message_in_place(
                                &mut self.buffers.read_buffer[..(frame_len as usize)],
                            ) {
                                Ok(decrypted) => {
                                    self.read_state = ReadState::CopyDecryptedFrame {
                                        decrypted_len: decrypted.len(),
                                        offset: 0,
                                    };
                                },
                                Err(e) => {
                                    error!(error = %e, "Decryption Error: {}", e);
                                    self.read_state = ReadState::DecryptionError(e);
                                },
                            }
```

**File:** network/framework/src/transport/mod.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    logging::NetworkSchema,
    noise::{stream::NoiseStream, AntiReplayTimestamps, HandshakeAuthMode, NoiseUpgrader},
    protocols::{
        identity::exchange_handshake,
        wire::handshake::v1::{HandshakeMsg, MessagingProtocolVersion, ProtocolIdSet},
    },
};
use aptos_config::{
    config::{PeerRole, HANDSHAKE_VERSION},
    network_id::{NetworkContext, NetworkId},
};
use aptos_crypto::x25519;
use aptos_id_generator::{IdGenerator, U32IdGenerator};
use aptos_logger::prelude::*;
// Re-exposed for aptos-network-checker
pub use aptos_netcore::transport::tcp::{resolve_and_connect, TCPBufferCfg, TcpSocket};
use aptos_netcore::transport::{proxy_protocol, tcp, ConnectionOrigin, Transport};
use aptos_short_hex_str::AsShortHexStr;
use aptos_time_service::{timeout, TimeService, TimeServiceTrait};
use aptos_types::{
    chain_id::ChainId,
    network_address::{parse_dns_tcp, parse_ip_tcp, parse_memory, NetworkAddress},
    PeerId,
};
use futures::{
    future::{Future, FutureExt},
    io::{AsyncRead, AsyncWrite},
    stream::{Stream, StreamExt, TryStreamExt},
};
use serde::{Deserialize, Serialize};
use std::{collections::BTreeMap, convert::TryFrom, fmt, io, pin::Pin, sync::Arc, time::Duration};

#[cfg(test)]
mod test;

/// A timeout for the connection to open and complete all of the upgrade steps.
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);

/// Currently supported messaging protocol version.
/// TODO: Add ability to support more than one messaging protocol.
pub const SUPPORTED_MESSAGING_PROTOCOL: MessagingProtocolVersion = MessagingProtocolVersion::V1;

/// Global connection-id generator.
static CONNECTION_ID_GENERATOR: ConnectionIdGenerator = ConnectionIdGenerator::new();

/// tcp::Transport with Aptos-specific configuration applied.
```
