# Audit Report

## Title
Stale Feature Flag Cache Allows Use of Disabled Algebra Operations During Epoch Transition

## Summary
The `one_internal()` function and other algebra native functions check feature flags via a cached `AptosEnvironment` that is created once at block start. During epoch transitions, when feature flags are updated mid-block via `reconfiguration_with_dkg::finish()`, subsequent transactions in the same block continue using stale cached feature flags, potentially allowing disabled algebra operations to execute or preventing newly enabled operations from being used. [1](#0-0) 

## Finding Description
The vulnerability stems from a mismatch between when feature flags are updated on-chain and when the execution environment reflects those changes:

1. **Environment Creation at Block Start**: When block execution begins, `AptosEnvironment` is created from the current state view, fetching the `Features` on-chain config. [2](#0-1) 

2. **Features Cached in SafeNativeBuilder**: The environment creates a `SafeNativeBuilder` with features stored in an `Arc<SharedData>` structure that is shared across all native function calls. [3](#0-2) 

3. **Native Context Uses Cached Features**: When native functions execute, they receive a `SafeNativeContext` that references the cached features from the builder, not live state. [4](#0-3) 

4. **Feature Flag Macro Checks Cached State**: The `abort_unless_arithmetics_enabled_for_structure!` macro calls `context.get_feature_flags().is_enabled(flag)` which returns the cached features. [5](#0-4) 

5. **Mid-Block Feature Flag Update**: During epoch transitions, `reconfiguration_with_dkg::finish()` calls `features::on_new_epoch()` which updates the `Features` resource on-chain. [6](#0-5) 

6. **Stale Cache Persists**: The environment is created once per block and never refreshed, so transactions executing after the epoch transition still see the old cached feature flags. [7](#0-6) 

**Attack Scenario**:
1. Governance proposal disables `BLS12_381_STRUCTURES` or `BN254_STRUCTURES` feature flag for next epoch
2. Block execution starts with environment containing enabled flags
3. Validator transaction completes DKG and triggers epoch transition via `reconfiguration_with_dkg::finish()`
4. Feature flags are updated on-chain to disable algebra structures
5. User transactions in the same block continue executing algebra operations (`one_internal()`, etc.) successfully using cached enabled flags
6. The disabled feature flags don't take effect until the next block

## Impact Explanation
**High Severity** - This vulnerability violates critical protocol assumptions and could enable security bypasses:

1. **Feature Flag Bypass**: Security-critical feature flags that should immediately disable vulnerable functionality can be bypassed for an entire block after being disabled.

2. **Governance Integrity Violation**: The system expects feature flag changes to take effect when `on_new_epoch()` is called during reconfiguration, but the cached implementation delays this until the next block.

3. **Unexpected State Transitions**: Transactions that should fail due to disabled features succeed, and transactions that should succeed with newly enabled features fail.

While all validators execute identically (preserving determinism), the behavior violates the expected semantics of epoch transitions and feature flag updates documented in the governance system. [8](#0-7) 

This meets **High Severity** criteria as a "Significant protocol violation" that undermines the feature flag governance mechanism.

## Likelihood Explanation
**High Likelihood** - This vulnerability triggers automatically during every epoch transition that includes feature flag changes:

1. **Frequent Occurrence**: Epoch transitions happen regularly, and feature flag updates are common during network upgrades
2. **No Attacker Action Required**: The vulnerability manifests naturally from the system design, not requiring malicious input
3. **Deterministic Trigger**: Every block containing a DKG completion validator transaction exhibits this behavior
4. **Production Impact**: Affects mainnet during routine governance operations

The environment caching design assumes features are updated per-block, but the validator transaction mechanism allows mid-block updates, creating a fundamental mismatch. [9](#0-8) 

## Recommendation
**Immediate Fix**: Modify the execution flow to prevent mid-block feature flag updates, or refresh the environment when feature flags change.

**Option 1 - Prevent Mid-Block Updates** (Recommended):
Ensure `reconfiguration_with_dkg::finish()` is only called in the block prologue, never as a validator transaction mid-block. Move the DKG completion to a special block epilogue or next block's prologue.

**Option 2 - Refresh Environment on Update**:
Add a mechanism to detect feature flag changes during block execution and signal to the block executor to refresh the environment. This is complex and could impact performance.

**Option 3 - Read Features from State View**:
Modify native functions to read feature flags directly from the resolver/state view instead of cached environment. However, this impacts performance and requires careful synchronization.

**Preferred Solution**: Restructure epoch transitions so that `features::on_new_epoch()` is always called at the boundary between blocks (in block epilogue or next block's prologue), never mid-block. This aligns with the documented assumption that "features or configs are updated only on per-block basis."

## Proof of Concept
```move
#[test(framework = @std, core = @0x1)]
fun test_stale_feature_flag_during_epoch_transition(framework: &signer, core: &signer) {
    use std::features;
    use aptos_framework::aptos_governance;
    use aptos_framework::reconfiguration_with_dkg;
    use std::bls12381_algebra;
    
    // Setup: Enable BLS12381 structures
    features::change_feature_flags_internal(framework, 
        vector[features::get_bls12_381_structures_feature()], 
        vector[]
    );
    
    // Verify we can use BLS12381 algebra
    let _ = bls12381_algebra::one<bls12381_algebra::G1>();
    
    // Governance disables the feature for next epoch
    features::change_feature_flags_for_next_epoch(framework,
        vector[],
        vector[features::get_bls12_381_structures_feature()]
    );
    
    // Trigger epoch transition (this would normally be a validator transaction)
    reconfiguration_with_dkg::finish(framework);
    
    // BUG: Feature should be disabled now, but due to stale cache,
    // the next line succeeds when it should fail
    let _ = bls12381_algebra::one<bls12381_algebra::G1>(); // Should abort but doesn't!
    
    // Feature flag only takes effect in the next block
}
```

**Note**: This PoC demonstrates the conceptual vulnerability. In production, the epoch transition would occur via a validator transaction submitting a DKG result, which calls `finish_with_dkg_result()` internally. The test shows that feature flag changes during `finish()` don't affect subsequent operations in the same execution context due to cached features in the environment.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/constants.rs (L100-106)
```rust
pub fn one_internal(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let structure_opt = structure_from_ty_arg!(context, &ty_args[0]);
    abort_unless_arithmetics_enabled_for_structure!(context, structure_opt);
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L31-34)
```rust
/// A runtime environment which can be used for VM initialization and more. Contains features
/// used by execution, gas parameters, VM configs and global caches. Note that it is the user's
/// responsibility to make sure the environment is consistent, for now it should only be used per
/// block of transactions because all features or configs are updated only on per-block basis.
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L219-220)
```rust
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L50-56)
```rust
            data: Arc::new(SharedData {
                gas_feature_version,
                native_gas_params,
                misc_gas_params,
                timed_features,
                features,
            }),
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L101-115)
```rust
            let mut context = SafeNativeContext {
                inner: context,

                timed_features: &data.timed_features,
                features: &data.features,
                gas_feature_version: data.gas_feature_version,
                native_gas_params: &data.native_gas_params,
                misc_gas_params: &data.misc_gas_params,

                legacy_gas_used: 0.into(),
                legacy_enable_incremental_gas_charging: enable_incremental_gas_charging,
                legacy_heap_memory_usage: 0,

                gas_hook: hook.as_deref(),
            };
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L280-301)
```rust
macro_rules! abort_unless_arithmetics_enabled_for_structure {
    ($context:ident, $structure_opt:expr) => {
        let flag_opt = feature_flag_from_structure($structure_opt);
        abort_unless_feature_flag_enabled!($context, flag_opt);
    };
}

#[macro_export]
macro_rules! abort_unless_feature_flag_enabled {
    ($context:ident, $flag_opt:expr) => {
        match $flag_opt {
            Some(flag) if $context.get_feature_flags().is_enabled(flag) => {
                // Continue.
            },
            _ => {
                return Err(SafeNativeError::Abort {
                    abort_code: MOVE_ABORT_CODE_NOT_IMPLEMENTED,
                });
            },
        }
    };
}
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L539-543)
```rust
        let mut module_cache_manager_guard = module_cache_manager.try_lock(
            &state_view,
            &config.local.module_cache_config,
            transaction_slice_metadata,
        )?;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L680-684)
```text
    ///   - At the end of the calling transaction, we will be in a new epoch.
    /// - If feature `RECONFIGURE_WITH_DKG` is enabled, it starts DKG, and the new epoch will start in a block prologue after DKG finishes.
    ///
    /// This behavior affects when an update of an on-chain config (e.g. `ConsensusConfig`, `Features`) takes effect,
    /// since such updates are applied whenever we enter an new epoch.
```
