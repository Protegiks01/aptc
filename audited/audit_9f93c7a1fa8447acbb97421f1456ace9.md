# Audit Report

## Title
Consensus Observer Sequential Subscription DoS via Unresponsive Peer Flooding

## Summary
The consensus observer's subscription creation mechanism sequentially attempts to connect to all potential peers without early termination, circuit breaking, or parallelization. An attacker can connect up to 100 unresponsive peers to cause subscription creation delays of up to 500 seconds (~8.3 minutes), effectively preventing validators and VFNs from establishing consensus observer subscriptions.

## Finding Description

The vulnerability exists in the `create_single_subscription` function which sequentially iterates through all potential peers attempting to create subscriptions. [1](#0-0) 

The function iterates through every peer in `sorted_potential_peers` without any early termination logic beyond finding a successful subscription. For each peer, it sends an RPC request and waits for a response with a configurable timeout. [2](#0-1) 

The timeout value is controlled by `network_request_timeout_ms` which defaults to 5,000 milliseconds (5 seconds). [3](#0-2) [4](#0-3) 

**Attack Vector:**

1. Attacker connects up to 100 malicious inbound peers to the victim node (within the `MAX_INBOUND_CONNECTIONS` limit of 100). [5](#0-4) 

2. These peers advertise support for ConsensusObserver protocols during the handshake but remain unresponsive to subscription RPC requests.

3. When the victim node attempts to create subscriptions via `create_new_subscriptions`, it sorts all connected peers and passes them to `create_single_subscription`. [6](#0-5) 

4. The function sequentially tries each peer, waiting 5 seconds per unresponsive peer before moving to the next.

5. With 100 unresponsive peers, total delay = 100 × 5 seconds = **500 seconds (~8.3 minutes)** per subscription creation attempt.

6. Failed peers are only removed from the local `sorted_potential_peers` list during that specific invocation. [7](#0-6) 

7. When `check_and_manage_subscriptions` is called again (every 5 seconds via the progress check interval), it receives fresh `connected_peers_and_metadata` containing all the same malicious peers, allowing the attack to repeat indefinitely. [8](#0-7) [9](#0-8) 

The subscription creation task is spawned asynchronously, but a guard prevents multiple concurrent tasks from running. [10](#0-9)  This means subsequent progress checks will wait until the slow subscription creation completes.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria for "Validator node slowdowns."

**Specific Impacts:**

1. **Consensus Observer Degradation**: Validators and VFNs running consensus observer cannot establish subscriptions to receive real-time consensus updates, forcing them to rely on fallback mechanisms.

2. **Extended Startup Delays**: On node startup or subscription reset, the node experiences 8+ minute delays before it can begin observing consensus, during which it falls behind the network.

3. **Persistent Availability Impact**: The attack is sustainable indefinitely as long as malicious peers remain connected, creating a persistent denial of service condition.

4. **Cascading Effects**: Without active subscriptions, nodes may repeatedly enter fallback mode, triggering state sync operations that further degrade performance.

The attack affects critical consensus infrastructure components used by validators and validator fullnodes, which are essential for network operation.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Ability to connect peers to the target node (trivial for public-facing nodes)
- No special privileges or insider access required
- No stake or economic commitment needed
- Minimal technical sophistication

**Attack Feasibility:**
- Establishing peer connections is a standard P2P network operation
- The 100 peer limit is sufficient to cause significant delays
- The attack requires no protocol-level exploits, only connection flooding
- Attack success rate is nearly 100% given the sequential processing design

**Detection Difficulty:**
- Malicious peers appear as legitimate connected peers
- No obvious protocol violations occur (peers simply don't respond to subscription requests)
- Distinguishing slow legitimate peers from malicious unresponsive ones is difficult

## Recommendation

**Immediate Mitigations:**

1. **Implement Early Termination**: Add a maximum retry limit (e.g., try at most 10-20 peers before giving up).

2. **Add Circuit Breaker**: Stop attempting subscriptions after N consecutive failures (e.g., 5 failures in a row).

3. **Parallelize Subscription Attempts**: Try multiple peers concurrently instead of sequentially.

4. **Persistent Peer Reputation**: Track peers that fail subscription attempts and temporarily blacklist them across subscription creation cycles.

**Recommended Code Fix:**

```rust
// In create_single_subscription, add a max attempts counter:
async fn create_single_subscription(
    consensus_observer_config: ConsensusObserverConfig,
    consensus_observer_client: Arc<ConsensusObserverClient<NetworkClient<ConsensusObserverMessage>>>,
    db_reader: Arc<dyn DbReader>,
    sorted_potential_peers: Vec<PeerNetworkId>,
    time_service: TimeService,
) -> (Option<ConsensusObserverSubscription>, Vec<PeerNetworkId>) {
    const MAX_SUBSCRIPTION_ATTEMPTS: usize = 20; // Circuit breaker
    let mut peers_with_failed_attempts = vec![];
    let mut consecutive_failures = 0;
    
    for potential_peer in sorted_potential_peers.iter().take(MAX_SUBSCRIPTION_ATTEMPTS) {
        // ... existing subscription attempt logic ...
        
        match response {
            Ok(ConsensusObserverResponse::SubscribeAck) => {
                // Success - reset failure counter and return
                return (Some(subscription), peers_with_failed_attempts);
            },
            _ => {
                peers_with_failed_attempts.push(*potential_peer);
                consecutive_failures += 1;
                
                // Circuit breaker: stop after too many consecutive failures
                if consecutive_failures >= 5 {
                    warn!(LogSchema::new(LogEntry::ConsensusObserver)
                        .message("Too many consecutive subscription failures, stopping attempts"));
                    break;
                }
            }
        }
    }
    
    (None, peers_with_failed_attempts)
}
```

Additionally, implement persistent peer reputation tracking to remember failed subscription attempts across invocations.

## Proof of Concept

```rust
// Integration test demonstrating the DoS vulnerability
#[tokio::test(flavor = "multi_thread")]
async fn test_subscription_dos_via_unresponsive_peers() {
    use std::time::Instant;
    
    // Create consensus observer config with 1-second timeout for faster testing
    let mut consensus_observer_config = ConsensusObserverConfig::default();
    consensus_observer_config.network_request_timeout_ms = 1000; // 1 second timeout
    
    let network_ids = &[NetworkId::Public];
    let (peers_and_metadata, consensus_observer_client, mut peer_manager_request_receivers) =
        create_consensus_observer_client(network_ids);
    
    // Create 50 unresponsive malicious peers
    const NUM_MALICIOUS_PEERS: usize = 50;
    for _ in 0..NUM_MALICIOUS_PEERS {
        create_peer_and_connection(
            NetworkId::Public,
            peers_and_metadata.clone(),
            0, // Distance from validators
            Some(0.1), // Low latency to appear optimal
            true, // Support consensus observer
        );
    }
    
    // Get connected peers
    let connected_peers_and_metadata = peers_and_metadata
        .get_connected_peers_and_metadata()
        .unwrap();
    
    // Measure time to attempt subscription creation
    let start = Instant::now();
    
    let subscription_handle = tokio::spawn(async move {
        create_new_subscriptions(
            consensus_observer_config,
            consensus_observer_client,
            None,
            Arc::new(MockDatabaseReader::new()),
            TimeService::mock(),
            connected_peers_and_metadata,
            2, // Try to create 2 subscriptions
            vec![],
            vec![],
        )
        .await
    });
    
    // Spawn task to simulate all peers being unresponsive
    tokio::spawn(async move {
        loop {
            if let Ok(Some((_, _, _, _, receiver))) = 
                peer_manager_request_receivers.get_mut(&NetworkId::Public)
                    .unwrap()
                    .select_next_some()
                    .await 
            {
                // Don't respond - simulate unresponsive peer
                // Just drop the response channel
                drop(receiver);
            }
        }
    });
    
    // Wait for subscription creation to complete
    let subscriptions = subscription_handle.await.unwrap();
    let elapsed = start.elapsed();
    
    // Verify the attack succeeded
    assert!(subscriptions.is_empty(), "No subscriptions should be created");
    
    // Expected delay: 50 peers × 1 second timeout = 50 seconds minimum
    // (Actually will try all peers twice due to max_concurrent_subscriptions=2,
    // but second iteration has no peers left after first removes all failed ones)
    assert!(
        elapsed.as_secs() >= 50,
        "Attack should cause at least 50 seconds of delay, got {} seconds",
        elapsed.as_secs()
    );
    
    println!("DoS Attack Success: {} seconds delay with {} unresponsive peers",
             elapsed.as_secs(), NUM_MALICIOUS_PEERS);
}
```

**Expected Output**: The test demonstrates that 50 unresponsive peers cause a minimum 50-second delay (with 1-second timeout). With the default 5-second timeout and 100 peers, this extends to 500 seconds (~8.3 minutes), confirming the vulnerability.

## Notes

This vulnerability affects the consensus observer subsystem specifically, which is enabled by default on validators (publisher mode) and validator fullnodes (observer + publisher mode). [11](#0-10) 

The issue does not directly compromise consensus safety or cause fund loss, but significantly degrades network availability and validator performance, warranting High severity classification under the bug bounty program's criteria for "Validator node slowdowns."

### Citations

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L85-93)
```rust
        // Attempt to create a new subscription
        let (observer_subscription, failed_subscription_peers) = create_single_subscription(
            consensus_observer_config,
            consensus_observer_client.clone(),
            db_reader.clone(),
            sorted_potential_peers.clone(),
            time_service.clone(),
        )
        .await;
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L95-96)
```rust
        // Remove the failed peers from the sorted list
        sorted_potential_peers.retain(|peer| !failed_subscription_peers.contains(peer));
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L116-193)
```rust
async fn create_single_subscription(
    consensus_observer_config: ConsensusObserverConfig,
    consensus_observer_client: Arc<
        ConsensusObserverClient<NetworkClient<ConsensusObserverMessage>>,
    >,
    db_reader: Arc<dyn DbReader>,
    sorted_potential_peers: Vec<PeerNetworkId>,
    time_service: TimeService,
) -> (Option<ConsensusObserverSubscription>, Vec<PeerNetworkId>) {
    let mut peers_with_failed_attempts = vec![];
    for potential_peer in sorted_potential_peers {
        // Log the subscription attempt
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Attempting to subscribe to potential peer: {}!",
                potential_peer
            ))
        );

        // Send a subscription request to the peer and wait for the response
        let subscription_request = ConsensusObserverRequest::Subscribe;
        let request_timeout_ms = consensus_observer_config.network_request_timeout_ms;
        let response = consensus_observer_client
            .send_rpc_request_to_peer(&potential_peer, subscription_request, request_timeout_ms)
            .await;

        // Process the response and update the active subscription
        match response {
            Ok(ConsensusObserverResponse::SubscribeAck) => {
                // Log the successful subscription
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Successfully subscribed to peer: {}!",
                        potential_peer
                    ))
                );

                // Create the new subscription
                let subscription = ConsensusObserverSubscription::new(
                    consensus_observer_config,
                    db_reader.clone(),
                    potential_peer,
                    time_service.clone(),
                );

                // Return the successful subscription
                return (Some(subscription), peers_with_failed_attempts);
            },
            Ok(response) => {
                // We received an invalid response
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Got unexpected response type for subscription request: {:?}",
                        response.get_label()
                    ))
                );

                // Add the peer to the list of failed attempts
                peers_with_failed_attempts.push(potential_peer);
            },
            Err(error) => {
                // We encountered an error while sending the request
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to send subscription request to peer: {}! Error: {:?}",
                        potential_peer, error
                    ))
                );

                // Add the peer to the list of failed attempts
                peers_with_failed_attempts.push(potential_peer);
            },
        }
    }

    // We failed to create a new subscription
    (None, peers_with_failed_attempts)
}
```

**File:** config/src/config/consensus_observer_config.rs (L11-14)
```rust
// Useful constants for enabling consensus observer on different node types
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L32-32)
```rust
    pub network_request_timeout_ms: u64,
```

**File:** config/src/config/consensus_observer_config.rs (L70-70)
```rust
            network_request_timeout_ms: 5_000,                 // 5 seconds
```

**File:** config/src/config/consensus_observer_config.rs (L73-73)
```rust
            progress_check_interval_ms: 5_000, // 5 seconds
```

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1115-1119)
```rust
        // Create a progress check ticker
        let mut progress_check_interval = IntervalStream::new(interval(Duration::from_millis(
            consensus_observer_config.progress_check_interval_ms,
        )))
        .fuse();
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L192-197)
```rust
        // If there is an active subscription creation task, return early
        if let Some(subscription_creation_task) = &*self.active_subscription_creation_task.lock() {
            if !subscription_creation_task.is_finished() {
                return; // The task is still running
            }
        }
```
