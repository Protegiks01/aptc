# Audit Report

## Title
Integer Overflow in Genesis Total Supply Validation Allows Unlimited APT Inflation

## Summary
The genesis validation code in `crates/aptos/src/genesis/mod.rs` uses a u64 sum to validate that account balances equal the declared total supply. This sum can silently overflow, allowing an attacker to bypass the validation and initialize genesis with far more APT than declared, breaking economic invariants and enabling massive inflation.

## Finding Description
The vulnerability exists in the `fetch_mainnet_genesis_info` function where account balances are summed and compared to the declared `total_supply`: [1](#0-0) 

The `.sum()` operation on u64 values performs wrapping addition in Rust. If the sum of all account balances exceeds `u64::MAX` (18,446,744,073,709,551,615), it wraps around modulo 2^64, potentially matching a much smaller declared `total_supply`.

**Attack Scenario:**
1. Attacker creates a malicious `balances.yaml` with accounts whose balances sum to more than u64::MAX
2. The attacker sets `total_supply` in `layout.yaml` to match the wrapped sum (e.g., if sum = u64::MAX + 100, set total_supply = 99)
3. The validation passes: `total_supply (99) == total_balance_supply (99)` due to overflow wrapping
4. During genesis execution, the Move code mints the ACTUAL (unwrapped) balances to each account

The Move VM tracks supply using u128 internally via `OptionalAggregator`: [2](#0-1) 

When each account is funded during genesis via `create_account`, the `aptos_coin::mint` function is called: [3](#0-2) 

Each individual mint operation succeeds (since individual balances are u64), and the u128 supply tracker accumulates the TRUE total - which is far larger than the declared total_supply.

**Concrete Example:**
- Account A: balance = 10,000,000,000,000,000,000 (10^19)
- Account B: balance = 10,000,000,000,000,000,000 (10^19)
- Declared total_supply = 1,553,255,926,290,448,384
- u64 sum wraps: (10^19 + 10^19) % 2^64 = 1,553,255,926,290,448,384
- Validation passes ✓
- Actual on-chain supply after genesis: 20,000,000,000,000,000,000 (2×10^19)

This breaks the fundamental economic invariant that the total APT supply should match the declared amount in the genesis configuration.

## Impact Explanation
This is a **CRITICAL** severity vulnerability under the Aptos bug bounty program category "Loss of Funds (theft or minting)".

**Direct Impact:**
- Unlimited APT can be minted during mainnet genesis initialization
- Complete breakdown of tokenomics and economic parameters
- Massive inflation far exceeding intended supply
- Devaluation of APT tokens for all holders

**Systemic Impact:**
- Loss of trust in the protocol's economic model
- Potential requirement for hard fork to fix
- Violation of representations made to investors/community about total supply
- Could affect staking rewards, governance, and all economic mechanisms

The vulnerability allows creating trillions or quadrillions of APT tokens while declaring a normal supply like 1 billion APT, fundamentally compromising the blockchain's economic integrity from genesis.

## Likelihood Explanation
**Likelihood: HIGH for mainnet genesis (one-time event)**

This vulnerability is exploitable during the one-time mainnet genesis creation process:
- **Attacker Requirements:** Write access to genesis configuration files (layout.yaml, balances.yaml)
- **Complexity:** Low - simple arithmetic to craft overflowing balances
- **Detection:** The validation passes normally, no warnings generated
- **Window:** Only exploitable during genesis file preparation, but this is the CRITICAL moment

For mainnet launch, if the genesis files are prepared by a compromised or malicious actor, this could be trivially exploited. The validation code is designed to prevent such attacks but fails due to the overflow bug.

## Recommendation
Replace the wrapping u64 sum with checked arithmetic that detects overflow:

```rust
// In fetch_mainnet_genesis_info function, replace lines 156-162:
let total_balance_supply: u64 = accounts.iter()
    .try_fold(0u64, |acc, account| {
        acc.checked_add(account.balance)
            .ok_or_else(|| CliError::UnexpectedError(
                format!("Account balance sum overflows u64. This indicates malicious input.")
            ))
    })?;

if total_supply != total_balance_supply {
    return Err(CliError::UnexpectedError(format!(
        "Total supply seen {} doesn't match expected total supply {}",
        total_balance_supply, total_supply
    )));
}
```

Alternatively, perform the sum in u128 to match the Move VM's supply tracking:

```rust
let total_balance_supply: u128 = accounts.iter()
    .map(|inner| inner.balance as u128)
    .sum();

if total_supply as u128 != total_balance_supply {
    return Err(CliError::UnexpectedError(format!(
        "Total supply seen {} doesn't match expected total supply {}",
        total_balance_supply, total_supply
    )));
}
```

## Proof of Concept
```rust
#[test]
fn test_genesis_supply_overflow_vulnerability() {
    // This test demonstrates the overflow vulnerability
    
    // Create two accounts with balances that sum to > u64::MAX
    let account_a_balance: u64 = 10_000_000_000_000_000_000u64; // 10^19
    let account_b_balance: u64 = 10_000_000_000_000_000_000u64; // 10^19
    
    // The true sum (in u128) is 2×10^19
    let true_sum: u128 = account_a_balance as u128 + account_b_balance as u128;
    assert_eq!(true_sum, 20_000_000_000_000_000_000u128);
    
    // But in u64, it wraps around
    let wrapped_sum: u64 = account_a_balance.wrapping_add(account_b_balance);
    assert_eq!(wrapped_sum, 1_553_255_926_290_448_384u64);
    
    // An attacker can set total_supply = wrapped_sum in layout.yaml
    let declared_total_supply: u64 = wrapped_sum;
    
    // The validation would pass (this is the vulnerability)
    let balances = vec![account_a_balance, account_b_balance];
    let computed_sum: u64 = balances.iter().sum(); // Uses wrapping addition
    
    assert_eq!(computed_sum, declared_total_supply); // Validation passes!
    
    // But the actual on-chain supply would be the true_sum (2×10^19)
    // which is approximately 12.8× larger than what was declared
    let inflation_ratio = true_sum as f64 / declared_total_supply as f64;
    assert!(inflation_ratio > 12.0);
    
    println!("Declared supply: {}", declared_total_supply);
    println!("Actual supply: {}", true_sum);
    println!("Inflation ratio: {:.2}x", inflation_ratio);
}
```

**Notes:**
- This vulnerability specifically affects mainnet genesis where the validation occurs at [4](#0-3) 
- The Move code correctly uses u128 for supply tracking [5](#0-4) , so the overflow only affects validation
- Individual account minting succeeds since each balance fits in u64 [6](#0-5) 
- The supply tracking via OptionalAggregator has u128 capacity, allowing the inflated supply to be recorded on-chain

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L148-150)
```rust
    let total_supply = layout.total_supply.ok_or_else(|| {
        CliError::UnexpectedError("Layout file does not have `total_supply`".to_string())
    })?;
```

**File:** crates/aptos/src/genesis/mod.rs (L156-162)
```rust
    let total_balance_supply: u64 = accounts.iter().map(|inner| inner.balance).sum();
    if total_supply != total_balance_supply {
        return Err(CliError::UnexpectedError(format!(
            "Total supply seen {} doesn't match expected total supply {}",
            total_balance_supply, total_supply
        )));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1086-1091)
```text
            supply: if (monitor_supply) {
                option::some(optional_aggregator::new(parallelizable))
            } else {
                option::none()
            }
        };
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1193-1226)
```text
    fun mint_internal<CoinType>(amount: u64): Coin<CoinType> acquires CoinInfo {
        if (amount == 0) {
            return Coin<CoinType> { value: 0 }
        };

        let maybe_supply =
            &mut borrow_global_mut<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;
        if (option::is_some(maybe_supply)) {
            let supply = option::borrow_mut(maybe_supply);
            spec {
                use aptos_framework::optional_aggregator;
                use aptos_framework::aggregator;
                assume optional_aggregator::is_parallelizable(supply) ==>
                    (
                        aggregator::spec_aggregator_get_val(
                            option::borrow(supply.aggregator)
                        ) + amount
                            <= aggregator::spec_get_limit(
                                option::borrow(supply.aggregator)
                            )
                    );
                assume !optional_aggregator::is_parallelizable(supply) ==>
                    (
                        option::borrow(supply.integer).value + amount
                            <= option::borrow(supply.integer).limit
                    );
            };
            optional_aggregator::add(supply, (amount as u128));
        };
        spec {
            update supply<CoinType> = supply<CoinType> + amount;
        };
        Coin<CoinType> { value: amount }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L195-207)
```text
    fun create_account(aptos_framework: &signer, account_address: address, balance: u64): signer {
        let account = if (account::exists_at(account_address)) {
            create_signer(account_address)
        } else {
            account::create_account(account_address)
        };

        if (coin::balance<AptosCoin>(account_address) == 0) {
            coin::register<AptosCoin>(&account);
            aptos_coin::mint(aptos_framework, account_address, balance);
        };
        account
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```
