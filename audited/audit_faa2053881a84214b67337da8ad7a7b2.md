# Audit Report

## Title
Incorrect Maximum Transaction Version Calculation Due to Sort Order Mismatch in Backup Metadata

## Summary
The `max_transaction_version()` function in `MetadataView` incorrectly assumes that the last backup in sorted order (sorted by `first_version`) also has the maximum `last_version`. When backups don't follow the expected continuous pattern—which can occur when merging metadata from multiple sources or due to corrupted/malicious metadata—this function returns an incorrect maximum transaction version, leading to incomplete database restoration.

## Finding Description

The vulnerability exists in the `max_transaction_version()` function: [1](#0-0) 

This function sorts transaction backups and returns the `last_version` of the last backup in sorted order. However, `TransactionBackupMeta` is sorted by fields in declaration order: [2](#0-1) 

The derived `Ord` trait sorts by `first_version` (primary), then `last_version` (secondary), then `manifest` (tertiary). This means a backup with a higher `first_version` will always sort after a backup with a lower `first_version`, regardless of their `last_version` values.

**Breaking Security Guarantee**: The function violates the invariant that `max_transaction_version()` returns the true maximum transaction version across all available backups.

**Attack Scenario**:

1. Legitimate backups exist:
   - Backup A: `first_version=0, last_version=2000`
   - Backup B: `first_version=2001, last_version=3000`

2. Attacker uploads malicious metadata or metadata corruption creates:
   - Backup X: `first_version=5000, last_version=5100`

3. After sorting by `(first_version, last_version, manifest)`: `[A, B, X]`

4. `max_transaction_version()` calls `sorted().next_back()` and returns `X.last_version = 5100`

5. True maximum is `B.last_version = 3000`, but if B were replaced with a backup ending at version 6000:
   - Backup B': `first_version=2001, last_version=6000`
   - Sorted order: `[A, B', X]`
   - Function returns: `5100`
   - True maximum: `6000`
   - **900 transaction versions would not be restored!**

The system merges metadata from multiple sources without strict validation: [3](#0-2) 

The `MetadataView::new()` constructor only performs deduplication but doesn't validate backup continuity: [4](#0-3) 

Notably, the codebase has a **correct implementation** in `get_storage_state()`: [5](#0-4) 

This correctly uses `.map(|t| t.last_version).max()` to find the true maximum, demonstrating the inconsistency.

The broken function is used by the restore coordinator to determine restoration boundaries: [6](#0-5) 

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This qualifies as **"State inconsistencies requiring intervention"** because:

1. **Incomplete Database Restoration**: When restoring from backup, the node will miss transactions that exist in the backup storage but have versions above the incorrectly calculated maximum.

2. **State Divergence**: The restored node will have an incomplete transaction history, causing state inconsistencies with properly restored or live nodes.

3. **Recovery Failures**: During disaster recovery scenarios, operators relying on this function will unknowingly restore incomplete databases, requiring manual intervention to detect and fix.

4. **Data Integrity Violation**: The system violates the guarantee that all backed-up transactions can be restored, breaking the fundamental backup/restore invariant.

The impact is not Critical because:
- It doesn't directly cause consensus violations (offline operation)
- It doesn't result in immediate fund loss
- It requires specific conditions (non-continuous backups)
- It affects recovery operations, not live consensus

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability can be triggered when:

1. **Multiple Backup Sources**: Organizations running multiple backup coordinators or merging backups from different environments may inadvertently create non-continuous backup ranges.

2. **Metadata Corruption**: File system errors, incomplete uploads, or storage system bugs could corrupt metadata files, creating inconsistent backup ranges.

3. **Malicious Metadata Injection**: An attacker with write access to backup storage could upload crafted metadata files to trigger the bug, causing incomplete restorations.

4. **Backup Coordinator Bugs**: Edge cases in the backup coordinator logic could create out-of-order or overlapping backup metadata.

The comment in `select_transaction_backups()` acknowledges this isn't a purely theoretical concern: [7](#0-6) 

The phrase "when we backup from a single backup coordinator" implies the system may handle multiple sources, making this scenario realistic.

## Recommendation

Replace the incorrect implementation with the correct one already used in `get_storage_state()`:

```rust
pub fn max_transaction_version(&self) -> Result<Option<Version>> {
    Ok(self
        .transaction_backups
        .iter()
        .map(|backup| backup.last_version)
        .max())
}
```

This correctly finds the maximum `last_version` across all backups regardless of sort order, ensuring complete restoration even when backups don't follow the expected continuous pattern.

**Additional Hardening**: Add validation in `MetadataView::new()` to detect and warn about non-continuous backup ranges, similar to `select_transaction_backups()`.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::FileHandle;

    #[test]
    fn test_max_transaction_version_bug() {
        // Create backups with non-continuous ranges
        let backup_a = TransactionBackupMeta {
            first_version: 0,
            last_version: 2000,
            manifest: FileHandle::from("backup_a.manifest"),
        };
        
        let backup_b = TransactionBackupMeta {
            first_version: 2001,
            last_version: 6000, // True maximum
            manifest: FileHandle::from("backup_b.manifest"),
        };
        
        let backup_x = TransactionBackupMeta {
            first_version: 10000,
            last_version: 10100, // Higher first_version, lower last_version
            manifest: FileHandle::from("backup_x.manifest"),
        };

        let metadata = vec![
            Metadata::TransactionBackup(backup_a),
            Metadata::TransactionBackup(backup_b),
            Metadata::TransactionBackup(backup_x),
        ];

        let view = MetadataView::new(metadata, vec![]);
        
        // Current buggy implementation
        let max_ver = view.max_transaction_version().unwrap().unwrap();
        assert_eq!(max_ver, 10100); // Returns wrong value
        
        // Expected correct value
        let expected_max = view.transaction_backups
            .iter()
            .map(|t| t.last_version)
            .max()
            .unwrap();
        assert_eq!(expected_max, 6000); // True maximum
        
        // Bug demonstrated: max_ver != expected_max
        assert_ne!(max_ver, expected_max, 
            "Bug: max_transaction_version() returned {} but true maximum is {}", 
            max_ver, expected_max);
    }
}
```

This test demonstrates that when backups exist with a higher `first_version` but lower `last_version`, the function returns an incorrect value, potentially causing incomplete database restoration.

## Notes

The vulnerability is particularly concerning because:

1. **Silent Failure**: The restore operation completes successfully but with incomplete data, making the issue difficult to detect.

2. **Production Risk**: In disaster recovery scenarios where time is critical, operators may not immediately notice the incomplete restoration.

3. **Inconsistency Exists**: The codebase already has the correct implementation in `get_storage_state()`, indicating this is an oversight rather than an intentional design choice.

The fix is straightforward and should be applied immediately to prevent potential data loss during backup restoration operations.

### Citations

**File:** storage/backup/backup-cli/src/metadata/view.rs (L45-50)
```rust
        epoch_ending_backups.sort_unstable();
        epoch_ending_backups.dedup();
        state_snapshot_backups.sort_unstable();
        state_snapshot_backups.dedup();
        transaction_backups.sort_unstable();
        transaction_backups.dedup();
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L89-93)
```rust
        let latest_transaction_version = self
            .transaction_backups
            .iter()
            .map(|t| t.last_version)
            .max();
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L137-139)
```rust
        // This can be more flexible, but for now we assume and check backups are continuous in
        // range (which is always true when we backup from a single backup coordinator)
        let mut next_ver = 0;
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L162-169)
```rust
    pub fn max_transaction_version(&self) -> Result<Option<Version>> {
        Ok(self
            .transaction_backups
            .iter()
            .sorted()
            .next_back()
            .map(|backup| backup.last_version))
    }
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L191-196)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct TransactionBackupMeta {
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L213-214)
```rust
    Ok(MetadataView::new(metadata_vec, remote_file_handles))
}
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L125-132)
```rust
        let max_txn_ver = metadata_view
            .max_transaction_version()?
            .ok_or_else(|| anyhow!("No transaction backup found."))?;
        let target_version = std::cmp::min(self.global_opt.target_version, max_txn_ver);
        info!(
            "User specified target version: {}, max transaction version: {}, Target version is set to {}",
            self.global_opt.target_version, max_txn_ver, target_version
        );
```
