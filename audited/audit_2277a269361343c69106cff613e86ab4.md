# Audit Report

## Title
Mainnet Validator Information Disclosure via Insecure Inspection Service Defaults

## Summary
The `InspectionServiceConfig::default()` implementation sets insecure defaults that expose validator identity, network topology, and system information on a publicly accessible endpoint (0.0.0.0:9101). When mainnet validator operators omit the `inspection_service` section from their configuration file, these insecure defaults are silently applied. The configuration sanitizer only validates `expose_configuration` for mainnet validators but fails to check the other three exposure flags (`expose_identity_information`, `expose_peer_information`, `expose_system_information`), allowing sensitive validator information to be publicly exposed. [1](#0-0) 

## Finding Description

The vulnerability occurs through the following attack path:

1. **Missing Configuration Section**: Validator operators create configuration files following the provided examples, which do not include an `inspection_service` section. [2](#0-1) 

2. **Serde Default Invocation**: During deserialization, the `#[serde(default)]` annotation causes the missing field to use `InspectionServiceConfig::default()`, which sets:
   - `address: "0.0.0.0"` (publicly accessible)
   - `expose_identity_information: true`
   - `expose_peer_information: true`
   - `expose_system_information: true` [3](#0-2) 

3. **Incomplete Sanitizer**: The `ConfigSanitizer` implementation only checks `expose_configuration` for mainnet validators, completely ignoring the other three exposure flags: [4](#0-3) 

4. **Service Exposure**: The inspection service starts on `0.0.0.0:9101` with the following endpoints enabled:
   - `/identity_information` - Exposes validator network peer ID and fullnode network peer IDs
   - `/peer_information` - Exposes complete network topology, trusted peers (validator set), connection metadata, and state sync information
   - `/system_information` - Exposes system and build information [5](#0-4) [6](#0-5) 

5. **Service Binding**: The service binds to the configured address without additional access controls: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program as a "Significant protocol violation." The protocol explicitly intends to prevent mainnet validators from exposing configuration information (as evidenced by the sanitizer check), but the incomplete sanitizer allows three other sensitive information endpoints to remain exposed.

The disclosed information enables attackers to:
- Map the complete validator network topology
- Identify validator peer IDs for targeted attacks
- Discover the active validator set through trusted peer information
- Monitor connection states and network health
- Plan eclipse attacks or targeted DoS against specific validators
- Gather reconnaissance for consensus-level attacks

While not directly causing loss of funds or consensus violations, this represents a significant security control failure that exposes critical network infrastructure information, facilitating subsequent attacks on validator nodes.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to occur because:
1. Official example configuration files do not include an `inspection_service` section
2. Validator operators following documentation will create minimal configs
3. Serde automatically applies defaults for missing fields without warning
4. The sanitizer provides a false sense of security by checking only one of four exposure flags
5. No runtime warnings alert operators to the exposed endpoints

The only mitigation is external infrastructure controls (Docker localhost binding, Kubernetes NetworkPolicies), which are not part of the core node software and may not be deployed consistently across all validator setups.

## Recommendation

**Fix 1: Secure Defaults**
Change `InspectionServiceConfig::default()` to use secure defaults for production:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost by default
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // Changed to false
            expose_peer_information: false,     // Changed to false
            expose_system_information: false,   // Changed to false
        }
    }
}
```

**Fix 2: Complete Sanitizer**
Extend the sanitizer to check all exposure flags for mainnet validators: [4](#0-3) 

Add additional checks:
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                // Check all exposure flags
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_mainnet_validator_insecure_defaults() {
    use aptos_config::config::{NodeConfig, InspectionServiceConfig};
    use aptos_config::config::node_config_loader::NodeType;
    use aptos_types::chain_id::ChainId;
    
    // Create a minimal config without inspection_service section
    // This simulates deserializing a YAML that omits the section
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig::default(),
        ..Default::default()
    };
    
    // Verify insecure defaults are applied
    assert_eq!(node_config.inspection_service.address, "0.0.0.0");
    assert!(node_config.inspection_service.expose_identity_information);
    assert!(node_config.inspection_service.expose_peer_information);
    assert!(node_config.inspection_service.expose_system_information);
    
    // Attempt to sanitize for mainnet validator
    // This should fail but currently passes (demonstrating the vulnerability)
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // Current behavior: sanitizer passes (VULNERABLE)
    assert!(result.is_ok());
    
    // Expected behavior: sanitizer should fail to prevent information disclosure
    // assert!(result.is_err());
}
```

This test demonstrates that a mainnet validator with default inspection service configuration passes sanitization despite exposing sensitive information on a publicly accessible endpoint.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/test_data/validator.yaml (L1-81)
```yaml
base:
    data_dir: "/opt/aptos/data"
    role: "validator"
    waypoint:
        from_storage:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"

consensus:
    safety_rules:
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"

execution:
    genesis_file_location: "relative/path/to/genesis"

# For validator node we setup two networks, validator_network to allow validator connect to each other,
# and full_node_networks to allow fullnode connects to validator.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"

validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
    identity:
        type: "from_storage"
        key_name: "validator_network"
        peer_id_name: "owner_account"
        backend:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"
    network_id: "validator"
    ### Load keys from file
    # identity:
    #     type: "from_file"
    #     path: /full/path/to/private-keys.yml
    #
    ### Load keys from secure storage service like vault:
    #
    # identity:
    #     type: "from_storage"
    #     key_name: "validator_network"
    #     peer_id_name: "owner_account"
    #     backend:
    #         type: "vault"
    #         server: "https://127.0.0.1:8200"
    #         ca_certificate: "/full/path/to/certificate"
    #         token:
    #             from_disk: "/full/path/to/token"
    #
    ### Load keys directly from config
    #
    # identity:
    #     type: "from_config"
    #     key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    #     peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
    mutual_authentication: true
    max_frame_size: 4194304 # 4 MiB
api:
    enabled: true
```

**File:** config/src/config/node_config.rs (L64-65)
```rust
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L28-51)
```rust
/// Returns a simple text formatted string with identity information
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-299)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L55-69)
```rust
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();
```
