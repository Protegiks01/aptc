# Audit Report

## Title
Node Checker Lacks HTTPS Enforcement Allowing Plaintext Transaction Data Transmission

## Summary
The Aptos Node Checker allows HTTP URLs in its configuration for both baseline and target nodes, enabling unencrypted transmission of transaction data. While the `AptosRestClient` properly verifies TLS certificates when HTTPS is used, there is no enforcement mechanism requiring HTTPS, allowing attackers to intercept and manipulate transaction verification data through man-in-the-middle attacks.

## Finding Description

The `TransactionCorrectnessChecker` retrieves transaction data via `get_transaction_by_version()` to compare accumulator root hashes between baseline and target nodes. [1](#0-0) 

The client is constructed from a `NodeAddress` that accepts any URL scheme. [2](#0-1) 

The API client is built without HTTPS enforcement: [3](#0-2) 

The underlying HTTP client uses reqwest with default configuration that DOES verify TLS certificates for HTTPS connections: [4](#0-3) 

However, the official API specification explicitly shows HTTP URL examples: [5](#0-4) 

**Attack Path:**
1. Node operator configures node-checker with HTTP URL (e.g., `http://fullnode.mysite.com`) as documented
2. Attacker positions themselves as MITM on network path
3. When `get_transaction_by_version_bcs()` is called, attacker intercepts plaintext request
4. Attacker serves modified transaction data with altered `accumulator_root_hash`
5. Node-checker compares manipulated data and produces incorrect health assessment

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program:
- Does not directly affect blockchain consensus or validator operations
- Limited to monitoring/diagnostic infrastructure
- Could lead to incorrect node health assessments affecting operator decisions
- Does not enable direct funds loss or state manipulation
- Impact is advisory rather than operational

While the node-checker is an important operational tool, it does not participate in consensus, transaction execution, or state management. Incorrect health assessments could mislead operators but would not compromise blockchain integrity.

## Likelihood Explanation

**Likelihood: Medium to High**
- HTTP URLs are explicitly documented and supported
- No warnings about security implications
- Operators may use HTTP for internal networks assuming safety
- MITM attacks on HTTP are trivial to execute
- No runtime validation prevents HTTP usage

## Recommendation

Enforce HTTPS-only connections with proper validation:

```rust
pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
    // Validate HTTPS is being used
    if self.url.scheme() != "https" {
        return Err(anyhow!(
            "Node checker requires HTTPS URLs for security. Got: {}. \
             HTTP connections are vulnerable to man-in-the-middle attacks.",
            self.url.scheme()
        ));
    }
    
    let client = reqwest::ClientBuilder::new()
        .timeout(timeout)
        .cookie_provider(self.cookie_store.clone())
        .build()
        .unwrap();

    Ok(AptosRestClient::from((client, self.get_api_url()?)))
}
```

Additionally, update documentation to remove HTTP examples and add security warnings.

## Proof of Concept

```rust
// Configuration that enables the vulnerability
// ecosystem/node-checker/config.yaml
baseline_configuration:
  node_address:
    url: "http://baseline.example.com"  // HTTP - vulnerable to MITM
    api_port: 8080

// When TransactionCorrectnessChecker runs:
// 1. Constructs client from HTTP URL
// 2. Calls get_transaction_by_version() 
// 3. Attacker intercepts plaintext HTTP request
// 4. Serves modified transaction with different accumulator_root_hash
// 5. Node-checker reports false mismatch or false match

// Demonstration of missing validation:
use url::Url;
let http_url = Url::parse("http://node.example.com").unwrap();
let https_url = Url::parse("https://node.example.com").unwrap();

// Both are accepted - no scheme validation
let http_addr = NodeAddress::new(http_url, Some(8080), None, None, None);
let https_addr = NodeAddress::new(https_url, Some(8080), None, None, None);

// HTTP client will make plaintext requests
let client = http_addr.get_api_client(Duration::from_secs(10)).unwrap();
// No error thrown - HTTP is allowed
```

**Notes:**

This vulnerability is specific to the Node Checker tool and does not affect the core blockchain protocol. The `AptosRestClient` correctly verifies TLS certificates when HTTPS is used - the issue is lack of HTTPS enforcement at the configuration layer. While categorized as High in the security question, the actual impact aligns more closely with Medium severity given the limited scope to auxiliary tooling rather than consensus-critical components.

### Citations

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L33-52)
```rust
    /// Fetch a transaction by version and return it.
    async fn get_transaction_by_version(
        client: &AptosRestClient,
        version: u64,
        node_name: &str,
    ) -> Result<TransactionData, CheckerError> {
        Ok(client
            .get_transaction_by_version_bcs(version)
            .await
            .map_err(|e| {
                CheckerError::NonRetryableEndpointError(
                    TRANSACTIONS_ENDPOINT,
                    anyhow::Error::from(e).context(format!(
                        "The {} node API failed to return the requested transaction at version: {}",
                        node_name, version
                    )),
                )
            })?
            .into_inner())
    }
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L13-35)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NodeAddress {
    /// Target URL. This should include a scheme (e.g. http://). If there is no
    /// scheme, we will prepend http://.
    pub url: Url,

    /// API port.
    api_port: Option<u16>,

    /// Metrics port.
    metrics_port: Option<u16>,

    /// Validator communication port.
    noise_port: Option<u16>,

    /// Public key for the node. This is used for the HandshakeChecker.
    /// If that Checker is not enabled, this is not necessary.
    public_key: Option<x25519::PublicKey>,

    // Cookie store.
    #[serde(skip)]
    cookie_store: Arc<Jar>,
}
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L107-115)
```rust
    pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
        let client = reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .build()
            .unwrap();

        Ok(AptosRestClient::from((client, self.get_api_url()?)))
    }
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```

**File:** ecosystem/node-checker/doc/spec.yaml (L27-35)
```yaml
      - name: node_url
        schema:
          type: string
          format: url
        in: query
        description: The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        required: true
        deprecated: false
        explode: true
```
