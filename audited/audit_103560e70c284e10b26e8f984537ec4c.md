# Audit Report

## Title
Signature Type Mismatch in ProofOfStore Transformation Causing Verification Failures

## Summary
Lines 199-202 in `proof_manager.rs` unpack `ProofOfStore<BatchInfoExt>` and repack it as `ProofOfStore<BatchInfo>`, creating a type mismatch between the signed data and the verification data. The aggregate signature was created over `BatchInfoExt` but is subsequently verified against `BatchInfo`, which have different cryptographic hashes, causing verification failures.

## Finding Description

The vulnerability exists in two critical code paths where `ProofOfStore<BatchInfoExt>` is transformed to `ProofOfStore<BatchInfo>`: [1](#0-0) [2](#0-1) 

The issue arises because:

1. **Signature Creation**: Aggregate signatures are created over `BatchInfoExt` when proofs are formed: [3](#0-2) 

2. **Type Difference**: `BatchInfoExt` is an enum that wraps `BatchInfo`: [4](#0-3) 

3. **Hash Mismatch**: Both types derive `BCSCryptoHash`, but their BCS serializations differ (enum includes variant discriminator). The transformation extracts the inner `BatchInfo`: [5](#0-4) 

4. **Verification Failure**: When verifying, the signature is checked against the wrong type: [6](#0-5) 

The verification at line 643 checks `validator.verify_multi_signatures(&self.info, &self.multi_signature)` where `self.info` is `BatchInfo`, but the signature was created over `BatchInfoExt`. These have different cryptographic hashes, causing verification to fail.

**Attack Path**:
In non-DAG mode with V1 batches (default configuration): [7](#0-6) [8](#0-7) 

1. ProofCoordinator creates valid `ProofOfStore<BatchInfoExt>` with proper signatures
2. Code transforms to `ProofOfStore<BatchInfo>` (lines 489-492)
3. Broadcasts to all validators
4. Receiving validators attempt verification
5. Cache miss occurs (haven't seen this proof before)
6. Signature verification fails due to type mismatch
7. Legitimate proofs are rejected as invalid

## Impact Explanation

**High Severity** - This causes significant protocol violations:

- **Liveness Impact**: Legitimate transaction batches are rejected due to failed signature verification, preventing them from being included in blocks
- **Network Disagreement**: Nodes with cached proofs accept them; nodes without cache reject them, causing inconsistent views of valid transactions
- **Performance Degradation**: Validators waste resources creating and broadcasting proofs that will fail verification
- **Consensus Disruption**: While not breaking safety (no conflicting state roots), it severely impacts the quorum store's ability to function correctly

This meets the "Significant protocol violations" criteria for High Severity in the Aptos bug bounty program.

## Likelihood Explanation

**High Likelihood** in default configuration:
- Occurs automatically in non-DAG mode with V1 batches (default settings)
- No attacker action required - happens during normal operation
- Affects all nodes receiving broadcast proofs for the first time
- Cache misses are common (new nodes, cache eviction, node restarts)

## Recommendation

Fix the type mismatch by maintaining type consistency throughout the proof lifecycle. Option 1 (Preferred): Always use `BatchInfoExt` in payloads:

```rust
// In proof_manager.rs, lines 197-203, remove the transformation:
let proof_block: Vec<_> = proof_block
    .into_iter()
    .map(|proof| proof) // Keep as ProofOfStore<BatchInfoExt>
    .collect();
```

Option 2: Update Payload types to accept `ProofOfStore<BatchInfoExt>` instead of `ProofOfStore<BatchInfo>`.

Option 3: If backward compatibility requires `BatchInfo` in messages, re-sign the proof after transformation:
```rust
// Create new signature over BatchInfo instead of reusing BatchInfoExt signature
let new_proof = create_proof_with_correct_signature(batch_info);
```

Also fix the same issue in proof_coordinator.rs lines 489-493.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Configure non-DAG mode with enable_batch_v2 = false
// 2. Create a ProofOfStore<BatchInfoExt> with valid signatures
// 3. Transform using proof.unpack() and ProofOfStore::new(info.info().clone(), sig)
// 4. Broadcast to a fresh node (empty cache)
// 5. Node receives and attempts verification
// 6. Observe verification failure at verify_multi_signatures()

use aptos_consensus_types::proof_of_store::{BatchInfo, BatchInfoExt, ProofOfStore};
use aptos_crypto::CryptoHash;

// Demonstrate hash mismatch:
let batch_info = BatchInfo::new(/* ... */);
let batch_info_ext = BatchInfoExt::V1 { info: batch_info.clone() };

// These hashes are DIFFERENT:
let hash1 = batch_info.hash();
let hash2 = batch_info_ext.hash();
assert_ne!(hash1, hash2); // Hash mismatch proves signature won't verify
```

**Notes**

The vulnerability is currently mitigated in production by:
1. Cache hits preventing re-verification in many cases  
2. Potential use of DAG mode or V2 batches in production deployments

However, the code contains a critical flaw that violates cryptographic correctness invariants and causes verification failures when the cache is cold. This breaks the fundamental assumption that correctly formed proofs should always verify successfully.

### Citations

**File:** consensus/src/quorum_store/proof_manager.rs (L197-203)
```rust
        let proof_block: Vec<_> = proof_block
            .into_iter()
            .map(|proof| {
                let (info, sig) = proof.unpack();
                ProofOfStore::new(info.info().clone(), sig)
            })
            .collect();
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L489-493)
```rust
                                        let proofs: Vec<_> = proofs_iter.map(|proof| {
                                            let (info, sig) = proof.unpack();
                                            ProofOfStore::new(info.info().clone(), sig)
                                        }).collect();
                                        network_sender.broadcast_proof_of_store_msg(proofs).await;
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L192-203)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
pub enum BatchInfoExt {
    V1 {
        info: BatchInfo,
    },
    V2 {
        info: BatchInfo,
        extra: ExtraBatchInfo,
    },
}
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L256-262)
```rust
    pub fn info(&self) -> &BatchInfo {
        match self {
            BatchInfoExt::V1 { info } => info,
            BatchInfoExt::V2 { info, .. } => info,
        }
    }

```

**File:** consensus/consensus-types/src/proof_of_store.rs (L635-652)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
        let batch_info_ext: BatchInfoExt = self.info.clone().into();
        if let Some(signature) = cache.get(&batch_info_ext) {
            if signature == self.multi_signature {
                return Ok(());
            }
        }
        let result = validator
            .verify_multi_signatures(&self.info, &self.multi_signature)
            .context(format!(
                "Failed to verify ProofOfStore for batch: {:?}",
                self.info
            ));
        if result.is_ok() {
            cache.insert(batch_info_ext, self.multi_signature.clone());
        }
        result
    }
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```

**File:** consensus/src/epoch_manager.rs (L753-753)
```rust
                !consensus_config.is_dag_enabled(),
```
