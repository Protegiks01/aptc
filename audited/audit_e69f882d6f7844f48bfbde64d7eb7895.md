# Audit Report

## Title
IO Gas Undercharging Due to Authenticator Size Exclusion in Transaction Size Calculation

## Summary
The `charge_io_gas_for_transaction()` function charges IO gas based only on the raw transaction size, excluding the authenticator. However, the full signed transaction (including the authenticator) is stored on-chain, allowing attackers to underpay for IO costs by up to 40x when using large authenticators such as keyless signatures or multi-signature schemes.

## Finding Description
The vulnerability occurs due to a mismatch between what is charged for IO gas and what is actually stored to the blockchain database.

**The Flow:**

1. When a `SignedTransaction` is received, `TransactionMetadata` is created with `transaction_size` set to only the raw transaction bytes: [1](#0-0) 

2. The `raw_txn_bytes_len()` function returns the BCS serialized size of ONLY the `raw_txn` field, explicitly excluding the authenticator: [2](#0-1) 

3. This size is used to charge IO gas: [3](#0-2) 

4. The IO gas calculation uses only this raw transaction size: [4](#0-3) 

5. However, what gets stored to the database is the complete `Transaction::UserTransaction(SignedTransaction)` which includes BOTH the raw transaction AND the authenticator: [5](#0-4) 

6. The authenticator can be extremely large - up to 4000 bytes for keyless signatures: [6](#0-5) 

**Attack Scenario:**
An attacker creates a transaction with:
- Minimal raw transaction payload (e.g., 100 bytes - just a simple transfer)
- Maximum size keyless authenticator (4000 bytes of ZK proof data)
- Pays IO gas for only 100 bytes
- Forces the network to store 4100 bytes on-chain

This represents a 40x undercharge for IO costs.

## Impact Explanation
This vulnerability qualifies as **HIGH severity** based on the Aptos bug bounty criteria:

1. **Significant Protocol Violation**: The gas metering system is a core protocol component. This bug allows systematic violation of the invariant that users must pay for resources consumed.

2. **Resource Exhaustion Attack**: Attackers can spam the blockchain with transactions that consume 40x more storage than they pay for, leading to:
   - Validator disk space exhaustion
   - Increased state sync costs for new validators
   - Network degradation as storage grows faster than economically sustainable

3. **Economic Attack Vector**: The cost of executing these transactions is significantly lower than the actual resource consumption, allowing an economically viable attack on network health.

4. **Breaks Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" - this directly violates the requirement that all operations must be properly metered.

## Likelihood Explanation
**VERY HIGH likelihood** of exploitation:

1. **Zero Prerequisites**: Any user can submit transactions with large authenticators - no special privileges required
2. **Trivial to Execute**: Simply use keyless authentication (already supported) or multi-signature schemes with many signers
3. **Economically Rational**: The attack is profitable - pay 1x cost, consume 40x resources
4. **No Detection Required**: The vulnerability is in the design, not in edge cases
5. **Already in Production**: Keyless transactions are actively supported, meaning the attack vector is already available

The maximum transaction size validation only checks the raw transaction size, not the full signed transaction: [7](#0-6) 

## Recommendation
**Fix**: Charge IO gas based on the full transaction size including the authenticator.

**Implementation:**
1. Modify `TransactionMetadata::new()` to use `txn_bytes_len()` instead of `raw_txn_bytes_len()`:

```rust
// In aptos-move/aptos-vm/src/transaction_metadata.rs, line 63:
// BEFORE:
transaction_size: (txn.raw_txn_bytes_len() as u64).into(),

// AFTER:
transaction_size: (txn.txn_bytes_len() as u64).into(),
```

2. The `txn_bytes_len()` function already correctly calculates the full size: [8](#0-7) 

3. Also update the max transaction size validation to check the full transaction size, not just the raw transaction size.

## Proof of Concept

```rust
// Test demonstrating the size mismatch
#[test]
fn test_io_gas_undercharge_with_large_authenticator() {
    use aptos_types::transaction::{SignedTransaction, RawTransaction, TransactionPayload};
    use aptos_types::account_address::AccountAddress;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    
    // Create a minimal raw transaction (small payload)
    let sender = AccountAddress::random();
    let raw_txn = RawTransaction::new(
        sender,
        0,  // sequence number
        TransactionPayload::Script(Script::new(vec![0x01], vec![], vec![])), // Minimal script
        100_000,  // max gas
        1,  // gas price
        0,  // expiration
        ChainId::test(),
    );
    
    // Sign with a keyless authenticator (can be up to 4000 bytes)
    // or multi-sig with 32 signers (can be ~3000 bytes)
    let txn = SignedTransaction::new(...);
    
    // The raw transaction size
    let raw_size = txn.raw_txn_bytes_len();  // e.g., 100 bytes
    
    // The full transaction size (including authenticator)
    let full_size = txn.txn_bytes_len();  // e.g., 4100 bytes
    
    // Create TransactionMetadata - this uses ONLY raw_size
    let txn_metadata = TransactionMetadata::new(&txn, &auxiliary_info);
    
    assert_eq!(txn_metadata.transaction_size(), raw_size.into());
    // BUG: transaction_size does NOT equal full_size!
    assert_ne!(txn_metadata.transaction_size(), full_size.into());
    
    // IO gas is charged on raw_size only
    // But full_size bytes are stored on-chain
    // Attacker underpays by factor of (full_size / raw_size) = ~40x
}
```

**Notes:**
- The vulnerability affects all transaction types with large authenticators
- Keyless transactions (already in production) are particularly affected
- Multi-signature transactions with many signers also affected  
- Fee payer transactions with multiple authenticators also affected
- The same issue affects intrinsic gas charging and storage fee calculation, both of which also use only the raw transaction size

### Citations

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** types/src/transaction/mod.rs (L1294-1297)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
```

**File:** types/src/transaction/mod.rs (L1300-1306)
```rust
    pub fn txn_bytes_len(&self) -> usize {
        let authenticator_size = *self.authenticator_size.get_or_init(|| {
            bcs::serialized_size(&self.authenticator)
                .expect("Unable to serialize TransactionAuthenticator")
        });
        self.raw_txn_bytes_len() + authenticator_size
    }
```

**File:** types/src/transaction/mod.rs (L2946-2951)
```rust
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1120-1120)
```rust
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L583-589)
```rust
    fn charge_io_gas_for_transaction(&mut self, txn_size: NumBytes) -> VMResult<()> {
        let cost = self.io_pricing().io_gas_per_transaction(txn_size);

        self.algebra
            .charge_io(cost)
            .map_err(|e| e.finish(Location::Undefined))
    }
```

**File:** types/src/keyless/mod.rs (L193-195)
```rust
    /// A reasonable upper bound for the number of bytes we expect in a keyless signature. This is
    /// enforced by our full nodes when they receive TXNs.
    pub const MAX_LEN: usize = 4000;
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-114)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
```
