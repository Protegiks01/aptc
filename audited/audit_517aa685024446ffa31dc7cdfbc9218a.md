# Audit Report

## Title
Lack of Token Rotation Mechanism in Faucet Bypasser Allows Indefinite Use of Compromised Tokens

## Summary
The Aptos faucet's `AuthTokenBypasser` lacks any mechanism to rotate or revoke bypass tokens at runtime. Once a bypass token is compromised (e.g., leaked in logs, stolen from configuration files, or exposed through network interception), it remains valid indefinitely until the faucet service is manually restarted. This allows unauthorized actors to drain faucet funds by bypassing all rate limiting and validation checks.

## Finding Description

The `AuthTokenBypasser` uses a `ListManager` to maintain a static list of valid bypass tokens loaded from a file at server initialization: [1](#0-0) 

The `ListManager` implementation loads tokens once during construction with no mechanism for updates: [2](#0-1) 

The tokens are stored in a static `HashSet<String>` with only two operations available: `contains()` for membership checking and `num_items()` for count. There are no methods to:
- Reload tokens from the file
- Remove specific tokens
- Add new tokens
- Expire tokens based on time-to-live (TTL)

The bypassers are initialized once at server startup and never updated: [3](#0-2) 

When a request contains a valid bypass token in the `Authorization` header, it completely bypasses all checkers and storage mechanisms: [4](#0-3) 

**Attack Scenario:**
1. An authorized bypass token (e.g., `Bearer super_secret_token`) is configured in `/tmp/auth_tokens.txt`
2. The token is inadvertently leaked through:
   - Application logs that record request headers
   - Configuration file committed to version control
   - Man-in-the-middle network interception
   - Compromised server with file access
3. An attacker obtains the token and uses it to make unlimited faucet requests
4. All rate limits, IP checks, and captcha validations are bypassed
5. The faucet's funds are drained
6. The token remains valid until an operator manually restarts the faucet service with an updated token file

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria: "Limited funds loss or manipulation, State inconsistencies requiring intervention."

**Funds Loss:** An attacker with a compromised bypass token can drain the faucet's pre-funded account by making unlimited funding requests without any rate limiting or validation checks.

**Manual Intervention Required:** The only way to revoke a compromised token is to:
1. Update the token file on disk
2. Manually restart the faucet service
3. This creates operational downtime and requires immediate human response

While the faucet is not part of the core consensus mechanism, it is a critical infrastructure component for developer onboarding and testnet operations.

## Likelihood Explanation

**Likelihood: High**

Token leakage is a common security issue:
- **Logging:** Many HTTP frameworks log request headers by default, potentially exposing `Authorization` headers
- **Version Control:** Configuration files with embedded tokens are frequently committed to git repositories
- **Network Monitoring:** Tokens transmitted over unencrypted connections can be intercepted
- **Insider Threats:** Any operator with file system access can copy the token file
- **Backup Exposure:** Backup systems may retain old configuration files with valid tokens

The attack complexity is minimal - an attacker only needs to obtain a single valid token and can immediately begin exploiting it with simple HTTP requests.

## Recommendation

Implement a token rotation and revocation mechanism. Here are the recommended changes:

**Option 1: Add runtime reload capability to ListManager**
```rust
impl ListManager {
    pub fn reload(&mut self, config: &ListManagerConfig) -> Result<()> {
        let file = File::open(&config.file)?;
        let mut new_items = HashSet::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            new_items.insert(line);
        }
        self.items = new_items;
        Ok(())
    }
}
```

**Option 2: Implement time-based token expiration**
```rust
pub struct TokenEntry {
    token: String,
    expires_at: Option<u64>, // Unix timestamp
}

impl ListManager {
    pub fn contains(&self, item: &str) -> bool {
        let now = get_current_time_secs();
        self.items.iter().any(|entry| {
            entry.token == item && 
            entry.expires_at.map_or(true, |exp| exp > now)
        })
    }
}
```

**Option 3: Add admin API endpoint for token management**
```rust
#[oai(path = "/admin/revoke_token", method = "post")]
async fn revoke_token(&self, token: String) -> Result<()> {
    self.components.bypassers.iter_mut()
        .filter_map(|b| b.as_auth_token_mut())
        .for_each(|bypasser| bypasser.manager.remove(&token));
    Ok(())
}
```

Additionally, implement monitoring and alerting:
- Log all bypass token usage with source IP and timestamp
- Alert operators when bypass tokens are used from unexpected locations
- Implement automatic token rotation on a scheduled basis (e.g., weekly)

## Proof of Concept

**Step 1: Setup faucet with bypass token**
```bash
# Create token file
echo "compromised_token_12345" > /tmp/auth_tokens.txt

# Start faucet with bypasser configuration
cat > /tmp/faucet_config.yaml <<EOF
bypasser_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
# ... rest of config
EOF

# Start faucet service
aptos-faucet run --config /tmp/faucet_config.yaml
```

**Step 2: Simulate token compromise and exploitation**
```bash
# Attacker obtains the token (e.g., from leaked logs)
TOKEN="compromised_token_12345"

# Make unlimited requests bypassing all rate limits
for i in {1..1000}; do
  curl -X POST http://faucet:8080/fund \
    -H "Authorization: Bearer $TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"address":"0xABCDEF","amount":100000000}'
  sleep 0.1
done

# All requests succeed, draining the faucet
# Rate limits, IP checks, and captcha are completely bypassed
```

**Step 3: Verify tokens cannot be revoked without restart**
```bash
# Operator updates the token file
echo "new_secure_token_67890" > /tmp/auth_tokens.txt
# Remove the compromised token from the file

# Attacker continues using compromised token - STILL WORKS
curl -X POST http://faucet:8080/fund \
  -H "Authorization: Bearer compromised_token_12345" \
  -H "Content-Type: application/json" \
  -d '{"address":"0xABCDEF","amount":100000000}'
# Returns 200 OK - token is still valid in memory

# Only a service restart revokes the token
kill <faucet_pid>
aptos-faucet run --config /tmp/faucet_config.yaml

# Now the compromised token is invalid
curl -X POST http://faucet:8080/fund \
  -H "Authorization: Bearer compromised_token_12345" \
  -H "Content-Type: application/json" \
  -d '{"address":"0xABCDEF","amount":100000000}'
# Returns 403 Forbidden - request goes through normal checkers
```

## Notes

This vulnerability is specific to the faucet service and does not affect core blockchain consensus, validator operations, or Move VM execution. However, the faucet is critical infrastructure for developer onboarding and testnet operations. The lack of runtime token management creates an operational security gap that requires manual intervention and service downtime to remediate.

The recommended fix should implement at least one of: runtime token reload via signal handling (SIGHUP), time-based expiration, or an admin API for token management. All bypass token usage should be logged with appropriate monitoring and alerting.

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L19-28)
```rust
impl AuthTokenBypasser {
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let manager = ListManager::new(config)?;
        info!(
            "Loaded {} auth tokens into AuthTokenBypasser",
            manager.num_items()
        );
        Ok(Self { manager })
    }
}
```

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L20-42)
```rust
impl ListManager {
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;
        let mut items = HashSet::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            items.insert(line);
        }
        Ok(Self { items })
    }

    pub fn contains(&self, item: &str) -> bool {
        self.items.contains(item)
    }

    pub fn num_items(&self) -> usize {
        self.items.len()
    }
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L114-121)
```rust
        // Build Bypassers.
        let mut bypassers: Vec<Bypasser> = Vec::new();
        for bypasser_config in &self.bypasser_configs {
            let bypasser = bypasser_config.clone().build().with_context(|| {
                format!("Failed to build Bypasser with args: {:?}", bypasser_config)
            })?;
            bypassers.push(bypasser);
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```
