# Audit Report

## Title
Race Conditions in SecurityEvent Logging Leading to Duplicate or Missing Attack Detection Logs

## Summary
The Aptos logger's SecurityEvent logging mechanism suffers from race conditions in concurrent scenarios. When multiple threads detect the same security violation simultaneously, duplicate logs are generated. Additionally, during high-volume attacks, the bounded logging channel can overflow, causing critical SecurityEvent logs to be silently dropped, affecting the accuracy of attack detection and validator monitoring systems.

## Finding Description

The vulnerability exists in the interaction between concurrent message verification and the SecurityEvent logging infrastructure.

**Architecture Flow:**

When consensus messages arrive at a validator node, the `EpochManager` spawns concurrent verification tasks using a `BoundedExecutor` with capacity 16 (default). [1](#0-0) 

Each verification task independently checks message validity. [2](#0-1) 

When verification fails, each task logs a `SecurityEvent` independently. [3](#0-2) 

**Vulnerability #1: Duplicate SecurityEvent Logs**

When an attacker sends the same invalid message multiple times rapidly (e.g., a consensus message with an invalid signature), up to 16 concurrent verification tasks are spawned. Each task:
1. Independently verifies the message
2. Detects the same violation (e.g., invalid signature)
3. Calls the logging macro which creates a separate `LogEntry` with its own timestamp [4](#0-3) 
4. Sends to the logging channel

There is no deduplication mechanism before logging. The `SecurityEvent` enum is simply a marker type with no state tracking. [5](#0-4) 

Result: Up to 16 duplicate log entries for a single security violation.

**Vulnerability #2: Missing SecurityEvent Logs**

The logging infrastructure uses a bounded channel with size 10,000. [6](#0-5) 

When sending log entries, the code uses `try_send()` which is non-blocking. If the channel is full, the log entry is silently dropped and only a counter is incremented. [7](#0-6) 

During a high-volume attack where thousands of invalid messages arrive, the logging channel can fill up, causing subsequent SecurityEvent logs to be dropped. The only indication is the `STRUCT_LOG_QUEUE_ERROR_COUNT` metric. [8](#0-7) 

**Attack Scenarios:**

*Scenario 1 - Duplicate Log Flooding:*
- Attacker sends 16 copies of the same invalid consensus proposal
- EpochManager spawns 16 concurrent verification tasks
- All fail simultaneously and log `SecurityEvent::InvalidConsensusProposal`
- Monitoring systems see 16x the actual attack volume
- Could trigger false positive alerts or exhaust log storage

*Scenario 2 - Log Suppression via Channel Overflow:*
- Attacker floods validator with 15,000 invalid messages rapidly
- First 10,000 SecurityEvent logs fill the channel
- Remaining 5,000 violations are not logged
- Critical attack indicators are lost
- Validator reputation systems may miss malicious behavior

## Impact Explanation

This is a **Medium severity** issue per Aptos bug bounty criteria because it affects attack detection and monitoring accuracy, which are security-critical operational capabilities.

**Why Medium and not Higher:**
- Does NOT directly compromise consensus safety, fund security, or network liveness
- The underlying security mechanisms (signature verification, consensus rules) function correctly
- Attacks are still prevented; only the VISIBILITY of attacks is affected

**Why Medium and not Lower:**
- SecurityEvent logs are critical for detecting Byzantine behavior and malicious validators
- Validator reputation systems rely on accurate attack detection
- Missing logs during coordinated attacks could allow adversaries to evade detection
- Duplicate logs could mask the true attack pattern or cause alert fatigue
- Affects operational security monitoring that's essential for network health

The impact aligns with "state inconsistencies requiring intervention" (Medium) because accurate security monitoring state is compromised and requires manual intervention to reconstruct attack timelines from alternative data sources.

## Likelihood Explanation

**High Likelihood** - This vulnerability will occur naturally during normal malicious activity:

- Any network peer can trigger it by sending invalid messages
- No special privileges or validator collusion required
- Duplicate logs occur whenever same invalid message is sent multiple times (common in network retries or deliberate attacks)
- Channel overflow occurs during any high-volume attack scenario
- The default bounded executor capacity (16) and channel size (10,000) make both scenarios practically exploitable

The race conditions are inherent to the architecture and will manifest whenever concurrent message processing encounters the same violation.

## Recommendation

Implement deduplication and overflow protection for SecurityEvent logging:

**Fix #1: Add SecurityEvent Deduplication**

Create a recent-violations cache in EpochManager that tracks recent security violations by (peer_id, event_type, content_hash) with a time-based expiry (e.g., 60 seconds). Before logging a SecurityEvent, check if the same violation was logged recently. Only log if it's a new violation or the cache entry expired.

**Fix #2: Use Blocking Send for SecurityEvents**

For SecurityEvent logs specifically, use a blocking `send()` instead of `try_send()` to ensure critical security logs are never dropped. Alternatively, implement a separate high-priority channel for SecurityEvents with guaranteed delivery.

**Fix #3: Add Circuit Breaker**

Implement rate limiting per peer: if a peer triggers more than N SecurityEvents within a time window, log once and suppress further logs for that peer temporarily, while still tracking the count.

**Pseudo-code fix for deduplication:**
```rust
// In EpochManager
struct SecurityEventCache {
    recent_events: LruCache<(AccountAddress, SecurityEvent, HashValue), Instant>,
}

impl SecurityEventCache {
    fn should_log(&mut self, peer: AccountAddress, event: SecurityEvent, hash: HashValue) -> bool {
        let key = (peer, event, hash);
        if let Some(last_seen) = self.recent_events.get(&key) {
            if last_seen.elapsed() < Duration::from_secs(60) {
                return false; // Duplicate within window
            }
        }
        self.recent_events.put(key, Instant::now());
        true
    }
}
```

## Proof of Concept

```rust
// Test demonstrating duplicate SecurityEvent logs
#[tokio::test]
async fn test_duplicate_security_event_logs() {
    use aptos_logger::{AptosData, SecurityEvent};
    use std::sync::{Arc, Mutex};
    
    // Setup logger with mock writer to capture logs
    let captured_logs = Arc::new(Mutex::new(Vec::new()));
    let writer = MockWriter::new(captured_logs.clone());
    
    AptosData::builder()
        .is_async(false)
        .printer(Box::new(writer))
        .build();
    
    // Simulate 10 concurrent threads detecting same violation
    let mut handles = vec![];
    for _ in 0..10 {
        let handle = tokio::spawn(async {
            error!(
                SecurityEvent::ConsensusInvalidMessage,
                "same_violation" = "test"
            );
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    // Verify: Should see 10 duplicate log entries
    let logs = captured_logs.lock().unwrap();
    assert_eq!(logs.len(), 10, "Expected 10 duplicate logs");
    
    // All logs should contain same SecurityEvent
    for log in logs.iter() {
        assert!(log.contains("ConsensusInvalidMessage"));
        assert!(log.contains("same_violation"));
    }
}

// Test demonstrating missing logs due to channel overflow
#[tokio::test]
async fn test_missing_security_event_logs_on_overflow() {
    // Setup logger with small channel size
    let logger = AptosData::builder()
        .is_async(true)
        .channel_size(100) // Small channel
        .build();
    
    // Flood with 200 SecurityEvents rapidly
    for i in 0..200 {
        error!(SecurityEvent::ConsensusInvalidMessage, "event" = i);
    }
    
    // Check STRUCT_LOG_QUEUE_ERROR_COUNT metric
    // Should show dropped logs (200 - 100 = ~100 dropped)
    let dropped = STRUCT_LOG_QUEUE_ERROR_COUNT.get();
    assert!(dropped > 0, "Expected some logs to be dropped");
}
```

## Notes

This vulnerability specifically affects the **observability layer** of Aptos security infrastructure, not the core protocol security. The consensus mechanism, signature verification, and Byzantine fault tolerance continue to function correctlyâ€”attackers cannot compromise consensus or steal funds through this issue. However, accurate SecurityEvent logging is essential for:

1. **Validator Reputation Systems**: Detecting and penalizing malicious validators
2. **Network Monitoring**: Identifying coordinated attacks across the network  
3. **Forensic Analysis**: Reconstructing attack timelines after incidents
4. **Early Warning Systems**: Triggering alerts before attacks escalate

The race conditions are inherent to the current concurrent verification architecture and will manifest in production during any high-volume malicious activity or sophisticated attacks designed to evade detection.

### Citations

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** consensus/src/epoch_manager.rs (L1587-1622)
```rust
            self.bounded_executor
                .spawn(async move {
                    match monitor!(
                        "verify_message",
                        unverified_event.clone().verify(
                            peer_id,
                            &epoch_state.verifier,
                            &proof_cache,
                            quorum_store_enabled,
                            peer_id == my_peer_id,
                            max_num_batches,
                            max_batch_expiry_gap_usecs,
                        )
                    ) {
                        Ok(verified_event) => {
                            Self::forward_event(
                                quorum_store_msg_tx,
                                round_manager_tx,
                                buffered_proposal_tx,
                                peer_id,
                                verified_event,
                                payload_manager,
                                pending_blocks,
                            );
                        },
                        Err(e) => {
                            error!(
                                SecurityEvent::ConsensusInvalidMessage,
                                remote_peer = peer_id,
                                error = ?e,
                                unverified_event = unverified_event
                            );
                        },
                    }
                })
                .await;
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L44-44)
```rust
pub const CHANNEL_SIZE: usize = 10000;
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L556-563)
```rust
        if let Some(sender) = &self.sender {
            if sender
                .try_send(LoggerServiceEvent::LogEntry(entry))
                .is_err()
            {
                STRUCT_LOG_QUEUE_ERROR_COUNT.inc();
            }
        }
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L572-579)
```rust
    fn record(&self, event: &Event) {
        let entry = LogEntry::new(
            event,
            ::std::thread::current().name(),
            self.enable_backtrace,
        );

        self.send_entry(entry)
```

**File:** crates/aptos-logger/src/security.rs (L23-82)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```

**File:** crates/aptos-logger/src/counters.rs (L31-37)
```rust
pub static STRUCT_LOG_QUEUE_ERROR_COUNT: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "aptos_struct_log_queue_error_count",
        "Count of all errors during queuing struct logs."
    )
    .unwrap()
});
```
