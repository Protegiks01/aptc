# Audit Report

## Title
Inspection Service JSON Metrics Endpoint Vulnerable to Resource Exhaustion via High-Cardinality Histogram Encoding

## Summary
The `/json_metrics` endpoint in the Aptos inspection service is vulnerable to a resource exhaustion attack. Histogram metrics create multiple entries (_count and _sum) that require string manipulation operations for each label combination. An attacker can repeatedly request this endpoint to consume CPU resources through excessive encoding operations, particularly when high-cardinality histogram metrics are present.

## Finding Description
The vulnerability exists in the JSON metrics encoding process. When a request is made to the `/json_metrics` endpoint, the system gathers all Prometheus metrics and encodes them using `JsonEncoder`. For each histogram metric, the encoder creates two separate HashMap entries (one for `_count` and one for `_sum`). [1](#0-0) 

For metrics with labels, each entry requires calling `flatten_metric_with_labels`, which performs string operations including iteration through all labels, filtering, joining with dots, and string formatting: [2](#0-1) 

The endpoint is publicly accessible without authentication or rate limiting: [3](#0-2) 

The encoding operation is synchronous with no timeout mechanism: [4](#0-3) 

The codebase already includes warnings for metric families with over 2000 dimensions, indicating awareness of high-cardinality issues: [5](#0-4) 

High-cardinality histogram metrics exist in the codebase, such as `BATCH_TRACING` which uses an `author` label (one per validator): [6](#0-5) 

**Attack Path:**
1. Attacker identifies the publicly accessible `/json_metrics` endpoint
2. Sends multiple concurrent GET requests to the endpoint
3. Each request triggers gathering and encoding of all metrics
4. For each histogram metric with N labels:
   - Create 2 HashMap entries (_count and _sum)
   - Execute `flatten_metric_with_labels` twice
   - Perform O(L) string operations where L is the number of labels
5. Serialize the entire HashMap (potentially 10,000+ entries) to JSON
6. With concurrent requests, the inspection service thread becomes saturated

## Impact Explanation
This vulnerability qualifies as **Low Severity** per the Aptos Bug Bounty program criteria. The impact is limited to:

- **Inspection service degradation**: The monitoring endpoint becomes slow or unresponsive
- **CPU resource consumption**: Repeated encoding operations consume CPU cycles
- **Observability disruption**: Health checks and monitoring may fail during the attack

However, this does **NOT** impact:
- Consensus operations (runs in separate thread)
- Transaction execution or validation
- Funds or state integrity
- Core node functionality

The inspection service runs in its own dedicated thread, isolating the impact: [7](#0-6) 

## Likelihood Explanation
**Likelihood: High**

- The `/json_metrics` endpoint is publicly accessible by default
- No authentication is required
- No rate limiting is implemented
- The attack is trivial to execute (simple HTTP GET requests)
- The attacker does not need to create new metrics; existing high-cardinality metrics are sufficient
- Multiple concurrent requests amplify the effect

The configuration shows no timeout or rate limiting protections: [8](#0-7) 

## Recommendation
Implement the following mitigations:

1. **Add rate limiting**: Implement per-IP rate limiting on the inspection service endpoints using a token bucket or similar algorithm

2. **Add request timeout**: Wrap the encoding operation in a timeout to prevent long-running requests

3. **Implement response caching**: Cache the encoded metrics with a TTL (e.g., 5-10 seconds) to avoid re-encoding on every request

4. **Add metric cardinality limits**: Implement hard limits on the number of label combinations per metric family

5. **Consider authentication**: For production deployments, require authentication for metrics endpoints or restrict access to trusted networks

Example fix for adding timeout and caching:

```rust
use std::time::{Duration, Instant};
use once_cell::sync::Lazy;
use parking_lot::RwLock;

static METRICS_CACHE: Lazy<RwLock<Option<(Instant, Vec<u8>)>>> = 
    Lazy::new(|| RwLock::new(None));
const CACHE_TTL: Duration = Duration::from_secs(5);
const ENCODING_TIMEOUT: Duration = Duration::from_secs(10);

pub fn handle_json_metrics_request() -> (StatusCode, Body, String) {
    // Check cache first
    {
        let cache = METRICS_CACHE.read();
        if let Some((timestamp, data)) = &*cache {
            if timestamp.elapsed() < CACHE_TTL {
                return (StatusCode::OK, Body::from(data.clone()), CONTENT_TYPE_JSON.into());
            }
        }
    }
    
    // Encode with timeout
    let buffer = match tokio::time::timeout(
        ENCODING_TIMEOUT,
        tokio::task::spawn_blocking(|| utils::get_encoded_metrics(JsonEncoder))
    ).await {
        Ok(Ok(buf)) => buf,
        _ => return (
            StatusCode::INTERNAL_SERVER_ERROR,
            Body::from("Metrics encoding timeout"),
            CONTENT_TYPE_TEXT.into()
        ),
    };
    
    // Update cache
    {
        let mut cache = METRICS_CACHE.write();
        *cache = Some((Instant::now(), buffer.clone()));
    }
    
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_JSON.into())
}
```

## Proof of Concept

```rust
// DoS attack simulation
use std::thread;
use std::time::Duration;

#[test]
fn test_json_metrics_dos() {
    // Setup: Start an Aptos node with inspection service enabled
    // This assumes the inspection service is running on localhost:9101
    
    let endpoint = "http://localhost:9101/json_metrics";
    let num_threads = 50; // Concurrent requests
    let requests_per_thread = 100;
    
    let mut handles = vec![];
    
    for _ in 0..num_threads {
        let handle = thread::spawn(move || {
            let client = reqwest::blocking::Client::new();
            for _ in 0..requests_per_thread {
                let start = std::time::Instant::now();
                match client.get(endpoint).send() {
                    Ok(response) => {
                        let elapsed = start.elapsed();
                        println!("Request completed in {:?}, status: {}", 
                                elapsed, response.status());
                        // In a DoS scenario, response times increase significantly
                        if elapsed > Duration::from_secs(5) {
                            println!("SLOW RESPONSE DETECTED: {:?}", elapsed);
                        }
                    },
                    Err(e) => println!("Request failed: {}", e),
                }
            }
        });
        handles.push(handle);
    }
    
    // Wait for all threads to complete
    for handle in handles {
        handle.join().unwrap();
    }
    
    // Expected result: Response times increase significantly under load,
    // potentially causing monitoring timeouts
}
```

**Notes**
- This vulnerability is confirmed to exist in the codebase as described
- The severity is appropriately rated as Low because it only affects the inspection service observability layer, not consensus or execution
- The attack is practical and requires no special privileges
- The codebase already shows awareness of high-cardinality issues through warning logs, but lacks protective measures
- Implementing rate limiting and caching would effectively mitigate this issue while maintaining observability functionality

### Citations

**File:** crates/aptos-inspection-service/src/server/json_encoder.rs (L45-56)
```rust
                    MetricType::HISTOGRAM => {
                        // write the sum and counts
                        let h = metric.get_histogram();
                        encoded_metrics.insert(
                            flatten_metric_with_labels(&format!("{}_count", name), metric),
                            h.get_sample_count() as f64,
                        );
                        encoded_metrics.insert(
                            flatten_metric_with_labels(&format!("{}_sum", name), metric),
                            h.get_sample_sum(),
                        );
                    },
```

**File:** crates/aptos-inspection-service/src/server/json_encoder.rs (L97-120)
```rust
fn flatten_metric_with_labels(name: &str, metric: &Metric) -> String {
    // If the metric has no labels, return the name
    let name_string = String::from(name);
    if metric.get_label().is_empty() {
        return name_string;
    }

    // Join the values of the labels with "."
    let values: Vec<&str> = metric
        .get_label()
        .iter()
        .map(LabelPair::get_value)
        .filter(|&x| !x.is_empty())
        .collect();
    let values = values.join(".");

    // If the values are empty, return the name
    if values.is_empty() {
        return name_string;
    }

    // Otherwise, return the name with the values
    format!("{}.{}", name_string, values)
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L72-75)
```rust
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

    // Spawn the inspection service
    thread::spawn(move || {
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L137-141)
```rust
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L66-70)
```rust
/// Handles a new metrics request (with JSON encoding)
pub fn handle_json_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(JsonEncoder);
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_JSON.into())
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L56-68)
```rust
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
        }
```

**File:** consensus/src/quorum_store/counters.rs (L1040-1048)
```rust
pub static BATCH_TRACING: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "quorum_store_batch_tracing",
        "Histogram for different stages of a QS batch",
        &["author", "stage"],
        BATCH_TRACING_BUCKETS.to_vec()
    )
    .unwrap()
});
```

**File:** config/src/config/inspection_service_config.rs (L15-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
}
```
