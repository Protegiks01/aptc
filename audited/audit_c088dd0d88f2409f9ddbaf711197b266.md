# Audit Report

## Title
Silent Receiver Thread Termination Causes Indefinite Transaction Blocking in Sharded Block Executor

## Summary
The `RemoteStateValueReceiver::start()` function lacks error handling for channel disconnection. When the channel fails, the receiver thread exits silently, causing all subsequent transaction executions to block indefinitely while waiting for state values that will never arrive, leading to validator node unavailability.

## Finding Description

The vulnerability exists in the remote state value receiver mechanism used by the sharded block executor when remote addresses are configured. [1](#0-0) 

**Critical Code Defect:**

The receiver thread loops on `recv()` without any error handling. [2](#0-1)  When the channel disconnects (due to `NetworkController` shutdown, network failures, or resource exhaustion), `recv()` returns `Err`, the loop exits, and the thread terminates silently with no logging, panic, or notification mechanism.

The thread handle is stored with an underscore prefix, indicating it's not actively monitored. [3](#0-2)  There is no `Drop` implementation to detect thread termination or restart the receiver.

**Attack Path:**

1. A `RemoteStateViewClient` is created with a background receiver thread for handling state value responses. [4](#0-3) 

2. The sharded executor receives an `ExecuteSubBlocks` command with this state view client. [5](#0-4) 

3. During transaction execution, the VM calls `get_state_value()` which may need to fetch remote state values. [6](#0-5) 

4. State keys are inserted with `RemoteStateValue::waiting()` status. [7](#0-6) 

5. If the receiver thread has died, state value responses never arrive.

6. Threads calling `get_value()` block indefinitely on a condition variable with no timeout. [8](#0-7) 

7. The blocking occurs during transaction execution within the sharded executor. [9](#0-8) 

8. The coordinator waits indefinitely for results with no timeout. [10](#0-9) 

9. The validator node becomes unable to execute blocks, losing liveness.

**Broken Invariants:**
- **Liveness Guarantee**: Validators must be able to execute blocks and participate in consensus
- **Availability**: The node becomes non-functional without automatic recovery
- **Error Visibility**: Silent failures violate operational monitoring requirements

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program (up to $50,000):

**Validator node unavailability**: Once the receiver thread dies, the validator cannot execute blocks using the sharded executor, effectively removing it from the active validator set until manual intervention. The blocking is indefinite with no timeout mechanism, no error logging, and no automatic recovery path.

While this approaches Critical Severity ("Total loss of liveness/network availability"), it affects individual validator nodes rather than the entire network, and requires a triggering condition (channel disconnection) that occurs during operational failures rather than being directly attacker-controlled.

## Likelihood Explanation

**Medium-to-High Likelihood:**

The receiver thread can die when:
- `NetworkController` shuts down during node restarts or crashes
- Network layer experiences internal errors or panics
- Resource exhaustion causes channel infrastructure failure
- Race conditions during shutdown sequences

The severity is amplified because:
- **No timeout mechanism**: Blocking is indefinite, not bounded
- **No error logging**: Failures are completely silent
- **No health monitoring**: The issue is undetectable until blocks stop being processed
- **No automatic recovery**: Requires manual node restart

The vulnerability is triggered by operational conditions (restarts, resource pressure, network instability) rather than direct attacker control, but these conditions occur regularly in distributed systems.

## Recommendation

Add comprehensive error handling to the receiver thread:

```rust
fn start(&self) {
    loop {
        match self.kv_rx.recv() {
            Ok(message) => {
                let state_view = self.state_view.clone();
                let shard_id = self.shard_id;
                self.thread_pool.spawn(move || {
                    Self::handle_message(shard_id, message, state_view);
                });
            },
            Err(e) => {
                error!("RemoteStateValueReceiver for shard {} channel disconnected: {}. Terminating receiver thread.", self.shard_id, e);
                // Notify monitoring systems
                // Consider panic! to ensure the entire service restarts
                panic!("Critical: Remote state value receiver channel disconnected");
            }
        }
    }
}
```

Additionally:
1. Add timeout to `RemoteStateValue::get_value()` using `cvar.wait_timeout()`
2. Implement `Drop` for `RemoteStateViewClient` to detect and log thread termination
3. Add health monitoring to detect receiver thread failures
4. Consider automatic reconnection logic with exponential backoff

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring remote executor addresses to enable remote sharded execution
2. Initiating block execution that uses `RemoteStateViewClient`
3. Triggering `NetworkController` shutdown or channel disconnection
4. Observing that subsequent `get_state_value()` calls block indefinitely
5. Verifying that the validator cannot complete block execution

The blocking occurs because the condition variable in `RemoteStateValue::get_value()` waits indefinitely for `set_value()` to be called, which never happens once the receiver thread has silently terminated.

### Citations

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** execution/executor-service/src/remote_state_view.rs (L51-55)
```rust
    pub fn insert_state_key(&self, state_key: StateKey) {
        self.state_values
            .entry(state_key)
            .or_insert(RemoteStateValue::waiting());
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L75-75)
```rust
    _join_handle: Option<thread::JoinHandle<()>>,
```

**File:** execution/executor-service/src/remote_state_view.rs (L104-107)
```rust
        let join_handle = thread::Builder::new()
            .name(format!("remote-kv-receiver-{}", shard_id))
            .spawn(move || state_value_receiver.start())
            .unwrap();
```

**File:** execution/executor-service/src/remote_state_view.rs (L186-204)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> StateViewResult<Option<StateValue>> {
        let state_view_reader = self.state_view.read().unwrap();
        if state_view_reader.has_state_key(state_key) {
            // If the key is already in the cache then we return it.
            let _timer = REMOTE_EXECUTOR_TIMER
                .with_label_values(&[&self.shard_id.to_string(), "prefetch_wait"])
                .start_timer();
            return state_view_reader.get_state_value(state_key);
        }
        // If the value is not already in the cache then we pre-fetch it and wait for it to arrive.
        let _timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&[&self.shard_id.to_string(), "non_prefetch_wait"])
            .start_timer();
        REMOTE_EXECUTOR_REMOTE_KV_COUNT
            .with_label_values(&[&self.shard_id.to_string(), "non_prefetch_kv"])
            .inc();
        self.pre_fetch_state_values(vec![state_key.clone()], true);
        state_view_reader.get_state_value(state_key)
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L233-241)
```rust
    fn start(&self) {
        while let Ok(message) = self.kv_rx.recv() {
            let state_view = self.state_view.clone();
            let shard_id = self.shard_id;
            self.thread_pool.spawn(move || {
                Self::handle_message(shard_id, message, state_view);
            });
        }
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L102-107)
```rust
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L225-249)
```rust
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```
