# Audit Report

## Title
Panic on Non-Existent Transaction Query in BCS Transaction Decoder

## Summary
The `unwrap()` call at line 55 in `aptos-move/aptos-debugger/src/bcs_txn_decoder.rs` does not properly handle cases where `get_version_by_account_sequence` returns `None`. When using the database interface to query non-existent transactions, the debugger will panic and crash instead of gracefully handling the error.

## Finding Description

The `bcs_txn_decoder.rs` tool decodes BCS-encoded transactions and attempts to retrieve their version from the blockchain. The vulnerable code path occurs when using the database-backed debugger interface (`DBDebuggerInterface`): [1](#0-0) 

The `get_version_by_account_sequence` method returns `Result<Option<Version>>`, where `None` indicates the transaction does not exist in the blockchain state. [2](#0-1) 

When using the `DBDebuggerInterface` implementation, the method properly returns `Ok(None)` for non-existent transactions: [3](#0-2) 

The underlying database method can legitimately return `None`: [4](#0-3) 

**Exploitation Path:**
1. User obtains BCS bytes of a valid transaction (e.g., from a transaction that was constructed but never submitted)
2. User runs the BCS transaction decoder with these bytes
3. Decoder parses the transaction successfully and extracts sender address and sequence number
4. Decoder calls `get_version_by_account_sequence` to find the transaction on-chain
5. Database returns `Ok(None)` because the transaction was never submitted
6. The `await?` unwraps the `Result`, leaving `None`
7. The `.unwrap()` panics with "called `Option::unwrap()` on a `None` value"
8. Debugger process terminates abnormally

## Impact Explanation

This issue qualifies as **Low to Medium** severity:

- **Not Critical/High**: Does not affect consensus, validator nodes, fund security, or core blockchain operations
- **Medium (API crashes)**: The debugger is a developer-facing tool that crashes on legitimate edge case input
- **Low (Non-critical implementation bug)**: More accurately characterized as poor error handling in a debugging utility

The debugger tool is not part of the core blockchain runtime, so the blast radius is limited to developers using the tool for transaction analysis. However, it represents a robustness failure where a development tool cannot gracefully handle a common scenario (querying transactions that haven't been submitted yet).

## Likelihood Explanation

**High likelihood** of occurrence in normal developer workflows:
- Developers frequently construct and test transactions locally before submission
- Common debugging workflow involves examining transaction structure before broadcasting
- No warning or documentation indicates this limitation
- The panic provides no actionable error message to users

## Recommendation

Replace the unsafe `.unwrap()` with proper error handling that provides a user-friendly message:

```rust
let version = debugger
    .get_version_by_account_sequence(txn.sender(), txn.sequence_number())
    .await?
    .ok_or_else(|| {
        anyhow::anyhow!(
            "Transaction not found on-chain for account {} with sequence number {}. \
             This transaction may not have been submitted yet.",
            txn.sender(),
            txn.sequence_number()
        )
    })?;
```

Additionally, there is a related panic in the REST interface implementation that should be fixed: [5](#0-4) 

This should handle empty responses gracefully:

```rust
async fn get_version_by_account_sequence(
    &self,
    account: AccountAddress,
    seq: u64,
) -> Result<Option<Version>> {
    let txns = self.0
        .get_account_ordered_transactions_bcs(account, Some(seq), None)
        .await?
        .into_inner();
    Ok(txns.first().map(|t| t.version))
}
```

## Proof of Concept

```rust
// Add this test to aptos-move/aptos-debugger/src/bcs_txn_decoder.rs
#[tokio::test]
async fn test_nonexistent_transaction_handling() {
    use aptos_types::transaction::{RawTransaction, SignedTransaction};
    use aptos_types::chain_id::ChainId;
    use ed25519_dalek::Keypair;
    use rand::rngs::OsRng;
    
    // Create a valid but unsubmitted transaction
    let mut csprng = OsRng{};
    let keypair = Keypair::generate(&mut csprng);
    
    let sender = AccountAddress::random();
    let raw_txn = RawTransaction::new(
        sender,
        999999, // Very high sequence number unlikely to exist
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        1000000,
        1,
        0,
        ChainId::test(),
    );
    
    let signed_txn = SignedTransaction::new(
        raw_txn,
        keypair.public.into(),
        keypair.sign(&bcs::to_bytes(&raw_txn).unwrap()).into(),
    );
    
    // Attempt to decode - this will panic with the current implementation
    // Expected: Should return a user-friendly error
    // Actual: Panics with "called `Option::unwrap()` on a `None` value"
}
```

**Notes:**

While this is a confirmed bug that causes the debugger to crash on valid input, the security impact is limited because:
1. The affected component is a debugging tool, not core blockchain infrastructure
2. No funds, consensus, or validator operations are at risk
3. The crash only affects the local developer's tool execution

This represents a robustness and user experience issue rather than a critical security vulnerability. The fix is straightforward and would prevent confusion for developers using the debugging tools.

### Citations

**File:** aptos-move/aptos-debugger/src/bcs_txn_decoder.rs (L52-55)
```rust
        let version = debugger
            .get_version_by_account_sequence(txn.sender(), txn.sequence_number())
            .await?
            .unwrap();
```

**File:** aptos-move/aptos-debugger/src/aptos_debugger.rs (L367-375)
```rust
    pub async fn get_version_by_account_sequence(
        &self,
        account: AccountAddress,
        seq: u64,
    ) -> anyhow::Result<Option<Version>> {
        self.debugger
            .get_version_by_account_sequence(account, seq)
            .await
    }
```

**File:** aptos-move/aptos-validator-interface/src/storage_interface.rs (L119-131)
```rust
    async fn get_version_by_account_sequence(
        &self,
        account: AccountAddress,
        seq: u64,
    ) -> Result<Option<Version>> {
        let ledger_version = self.get_latest_ledger_info_version().await?;
        self.0
            .get_account_ordered_transaction(account, seq, false, ledger_version)
            .map_or_else(
                |e| Err(anyhow::Error::from(e)),
                |tp| Ok(tp.map(|e| e.version)),
            )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L143-162)
```rust
    fn get_account_ordered_transaction(
        &self,
        address: AccountAddress,
        seq_num: u64,
        include_events: bool,
        ledger_version: Version,
    ) -> Result<Option<TransactionWithProof>> {
        gauged_api("get_account_transaction", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.transaction_store
                .get_account_ordered_transaction_version(address, seq_num, ledger_version)?
                .map(|txn_version| {
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .transpose()
        })
    }
```

**File:** aptos-move/aptos-validator-interface/src/rest_interface.rs (L357-369)
```rust
    async fn get_version_by_account_sequence(
        &self,
        account: AccountAddress,
        seq: u64,
    ) -> Result<Option<Version>> {
        Ok(Some(
            self.0
                .get_account_ordered_transactions_bcs(account, Some(seq), None)
                .await?
                .into_inner()[0]
                .version,
        ))
    }
```
