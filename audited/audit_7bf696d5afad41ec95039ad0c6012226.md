# Audit Report

## Title
Indexer Event Parsing Incompatibility with Module Event Migration Causes Data Divergence

## Summary
The indexer's `StakeEvent::from_event()` function only recognizes legacy event types with "Event" suffix (e.g., `0x1::delegation_pool::AddStakeEvent`), but when the `MODULE_EVENT_MIGRATION` feature flag is enabled, on-chain delegation pool operations emit new-style events without the suffix (e.g., `0x1::delegation_pool::AddStake`). This causes legitimate delegation activities to return `None` and be skipped from indexing, leading to incomplete indexer data that diverges from actual on-chain state.

## Finding Description
The Aptos framework implements a dual-event emission system to support migration from the legacy event pattern to a new module event system. [1](#0-0)  defines the `MODULE_EVENT_MIGRATION` feature flag that controls this behavior.

When this feature flag is enabled, delegation pool functions emit new-style events. For example, in `add_stake()`: [2](#0-1)  the code checks `features::module_event_migration_enabled()` and emits either `AddStake` (new style, lines 1596-1603) or `AddStakeEvent` (legacy style, lines 1605-1613).

However, the indexer's event parsing logic only matches legacy event types: [3](#0-2)  matches event types like `"0x1::delegation_pool::AddStakeEvent"`, `"0x1::delegation_pool::UnlockStakeEvent"`, etc. (all with "Event" suffix), and returns `None` for unrecognized types.

When `from_transaction()` processes events: [4](#0-3)  if `StakeEvent::from_event()` returns `None`, the code simply continues to the next event without indexing that activity.

This creates a systematic gap: once the feature flag is enabled, ALL delegation pool operations (add_stake, unlock, withdraw, reactivate_stake) emit new-style events that the indexer cannot recognize, causing complete failure to index delegation activities.

## Impact Explanation
This is a **Medium Severity** issue per the bug bounty criteria: "State inconsistencies requiring intervention."

The indexer database would be incomplete and inconsistent with the actual on-chain state. Specifically:
- All delegation pool activities (stakes, unlocks, withdrawals, reactivations) after feature flag enablement would be missing from the `delegated_staking_activities` table
- API queries for delegation history would return incomplete or empty results
- Users and applications relying on indexer data would have incorrect views of delegation state
- Manual database intervention would be required to backfill missed events

While this doesn't affect on-chain consensus or security directly (the indexer is a read-only off-chain component), it breaks the critical guarantee that indexer data accurately reflects blockchain state, impacting all services and applications that depend on it.

## Likelihood Explanation
**High likelihood** of occurrence:

1. The `MODULE_EVENT_MIGRATION` feature flag is designed to be enabled as part of the framework's evolution strategy
2. Once enabled through governance, the issue would affect 100% of delegation pool operations
3. The bug would persist until the indexer code is updated, causing continuous data loss
4. No attacker action is required - normal user operations trigger the issue

The question's framing about "attackers crafting events" is somewhat misleading. Users cannot craft arbitrary events - events are emitted by framework code. However, the vulnerability is real: legitimate delegation operations would fail to be indexed.

## Recommendation
Update the indexer's `StakeEvent::from_event()` function to recognize both legacy and new-style event types:

```rust
pub fn from_event(
    data_type: &str,
    data: &serde_json::Value,
    txn_version: i64,
) -> Result<Option<Self>> {
    match data_type {
        // Legacy event types (with Event suffix)
        "0x1::delegation_pool::AddStakeEvent" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::AddStakeEvent(inner))),
        "0x1::delegation_pool::UnlockStakeEvent" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::UnlockStakeEvent(inner))),
        "0x1::delegation_pool::WithdrawStakeEvent" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::WithdrawStakeEvent(inner))),
        "0x1::delegation_pool::ReactivateStakeEvent" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::ReactivateStakeEvent(inner))),
        
        // New module event types (without Event suffix)
        "0x1::delegation_pool::AddStake" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::AddStakeEvent(inner))),
        "0x1::delegation_pool::UnlockStake" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::UnlockStakeEvent(inner))),
        "0x1::delegation_pool::WithdrawStake" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::WithdrawStakeEvent(inner))),
        "0x1::delegation_pool::ReactivateStake" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::ReactivateStakeEvent(inner))),
            
        // Keep existing stake and governance events
        "0x1::aptos_governance::VoteEvent" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::GovernanceVoteEvent(inner))),
        "0x1::stake::DistributeRewardsEvent" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::DistributeRewardsEvent(inner))),
        "0x1::stake::DistributeRewards" => serde_json::from_value(data.clone())
            .map(|inner| Some(StakeEvent::DistributeRewardsEvent(inner))),
            
        _ => Ok(None),
    }
    .context(format!(
        "version {} failed! failed to parse type {}, data {:?}",
        txn_version, data_type, data
    ))
}
```

## Proof of Concept

1. **Setup**: Enable the MODULE_EVENT_MIGRATION feature flag on a test network
2. **Execute**: Have a user call `delegation_pool::add_stake(pool_address, amount)` 
3. **Observe**: The transaction emits an event with type `0x1::delegation_pool::AddStake` (without "Event" suffix)
4. **Verify**: Check the indexer's `delegated_staking_activities` table - the activity is NOT present
5. **Confirm**: Query the on-chain `DelegationPool` resource - the stake WAS added correctly

This demonstrates that on-chain state changes successfully, but the indexer fails to record the activity, causing divergence between indexer data and actual chain state.

## Notes

While the security question frames this as an "attacker crafting events," the actual vulnerability is a compatibility bug between the framework's event migration and the indexer's parsing logic. Users cannot craft arbitrary events - events are emitted by framework code during normal operations. However, the impact is real: once the feature flag is enabled, the indexer systematically fails to record legitimate delegation activities, requiring manual intervention to fix.

### Citations

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L465-474)
```text
    /// Whether aptos_framwork enables the behavior of module event migration.
    ///
    /// Lifetime: transient
    const MODULE_EVENT_MIGRATION: u64 = 57;

    public fun get_module_event_migration_feature(): u64 { MODULE_EVENT_MIGRATION }

    public fun module_event_migration_enabled(): bool acquires Features {
        is_enabled(MODULE_EVENT_MIGRATION)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L1595-1614)
```text
        if (features::module_event_migration_enabled()) {
            event::emit(
                AddStake {
                    pool_address,
                    delegator_address,
                    amount_added: amount,
                    add_stake_fee,
                },
            );
        } else {
            event::emit_event(
                &mut pool.add_stake_events,
                AddStakeEvent {
                    pool_address,
                    delegator_address,
                    amount_added: amount,
                    add_stake_fee,
                },
            );
        };
```

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L189-202)
```rust
        match data_type {
            "0x1::aptos_governance::VoteEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::GovernanceVoteEvent(inner))),
            "0x1::stake::DistributeRewardsEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::DistributeRewardsEvent(inner))),
            "0x1::delegation_pool::AddStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::AddStakeEvent(inner))),
            "0x1::delegation_pool::UnlockStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::UnlockStakeEvent(inner))),
            "0x1::delegation_pool::WithdrawStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::WithdrawStakeEvent(inner))),
            "0x1::delegation_pool::ReactivateStakeEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeEvent::ReactivateStakeEvent(inner))),
            _ => Ok(None),
```

**File:** crates/indexer/src/models/stake_models/delegator_activities.rs (L43-45)
```rust
            if let Some(staking_event) =
                StakeEvent::from_event(event_type.as_str(), &event.data, txn_version)?
            {
```
