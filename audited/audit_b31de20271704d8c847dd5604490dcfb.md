# Audit Report

## Title
Block Stuffing Attack via Missing Block Gas Limit Enforcement Causes Chain Liveness Failure

## Summary
When the on-chain execution configuration is Missing, V1, or improperly configured V2/V3, the block gas limit defaults to NoLimit, allowing attackers to fill blocks with transactions consuming MAX_GAS_AMOUNT (2,000,000 gas units each). This can cause extreme block execution times (potentially hours), leading to consensus timeouts and chain stalling.

## Finding Description

The vulnerability exists in the block gas limit enforcement mechanism with the following attack path:

**1. Configuration Weakness:** [1](#0-0) 

When `OnChainExecutionConfig` is `Missing` or `V1`, the `block_gas_limit_type()` method returns `BlockGasLimitType::NoLimit`, completely disabling block gas limit enforcement.

**2. Fallback to Unsafe Defaults:** [2](#0-1) 

During epoch transitions, if reading the on-chain execution config fails, the system falls back to `OnChainExecutionConfig::Missing`, which has no gas limit. [3](#0-2) 

**3. Transaction Selection Ignores Gas:** [4](#0-3) 

The mempool's `get_batch()` method selects transactions based only on count (`max_txns`) and size (`max_bytes`), with no consideration for cumulative `max_gas_amount`. It can select up to 1,800 transactions (MAX_SENDING_BLOCK_TXNS_AFTER_FILTERING). [5](#0-4) 

**4. No Enforcement During Execution:** [6](#0-5) 

The `should_end_block()` method only halts execution if `block_gas_limit()` returns `Some(limit)`. With `NoLimit`, execution continues unrestricted.

**Attack Scenario:**

1. Attacker identifies a chain running with `OnChainExecutionConfig::Missing` or V1
2. Attacker submits 1,800 transactions to mempool, each with:
   - `max_gas_amount = 2,000,000` (MAX_GAS_AMOUNT) [7](#0-6) 
   - Crafted to consume 500,000+ gas units in actual execution
3. Block proposer selects all 1,800 transactions (no gas-based filtering)
4. During execution, with no block gas limit:
   - Total gas consumed: 1,800 × 500,000 = 900,000,000 gas units
   - Execution time: ~900M × 5 microseconds/gas = 4,500 seconds = **75 minutes per block** [8](#0-7) 
5. Validators cannot complete execution within consensus timeout (1000ms initial) [9](#0-8) 
6. Chain stalls as validators repeatedly timeout

## Impact Explanation

**Severity: HIGH** - This vulnerability causes **total loss of liveness/network availability**, which qualifies as Critical severity per Aptos bug bounty criteria. However, it requires specific preconditions (Missing/V1 config or config read failure), reducing it to High severity.

**Broken Invariants:**
- **Resource Limits**: Operations fail to respect gas and computational limits (Invariant #9)
- **Consensus Safety**: Chain liveness is destroyed, violating consensus requirements (Invariant #2)

**Impact Quantification:**
- Affects ALL validators simultaneously
- Chain completely halted until manual intervention
- Requires governance action or hard fork to recover
- Users cannot submit transactions during outage
- Potential economic damage from prolonged downtime

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability is exploitable under these conditions:

1. **Legacy Networks**: Any chain still running V1 or Missing config (backwards compatibility mode)
2. **Config Read Failures**: Transient storage errors during epoch transitions trigger fallback to Missing
3. **Misconfigured Networks**: V2/V3 deployments without explicit block_gas_limit set

**Attacker Requirements:**
- Sufficient funds to submit 1,800 transactions (standard gas fees)
- Ability to craft transactions consuming significant gas
- No special privileges required

**Complexity:** LOW - Standard transaction submission, no sophisticated attack required

## Recommendation

**Immediate Mitigations:**

1. **Eliminate Unsafe Fallback:**
```rust
// In consensus/src/epoch_manager.rs
let execution_config = onchain_execution_config
    .expect("OnChainExecutionConfig must be initialized");
```

2. **Add Gas-Based Transaction Selection:**
```rust
// In mempool/src/core_mempool/mempool.rs get_batch()
let mut cumulative_gas_amount = 0u64;
const MAX_BLOCK_CUMULATIVE_GAS: u64 = 100_000_000; // Conservative limit

for txn in self.transactions.iter_queue() {
    let txn_max_gas = txn.max_gas_amount();
    if cumulative_gas_amount + txn_max_gas > MAX_BLOCK_CUMULATIVE_GAS {
        break; // Stop adding transactions
    }
    cumulative_gas_amount += txn_max_gas;
    // ... existing selection logic
}
```

3. **Enforce Minimum Config Version:** [10](#0-9) 

Add validation to reject Missing/V1/V2/V3 configs in production:
```rust
pub fn validate_for_production(&self) -> Result<(), String> {
    match self {
        OnChainExecutionConfig::Missing | 
        OnChainExecutionConfig::V1(_) => {
            Err("Legacy config without block gas limits not allowed".to_string())
        },
        OnChainExecutionConfig::V2(cfg) | 
        OnChainExecutionConfig::V3(cfg) => {
            if cfg.block_gas_limit.is_none() {
                Err("Block gas limit must be configured".to_string())
            } else {
                Ok(())
            }
        },
        _ => Ok(())
    }
}
```

4. **Upgrade All Networks:** Execute governance proposals to upgrade all chains to V7 with proper ComplexLimitV1: [11](#0-10) 

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_block_stuffing_without_gas_limit() {
    use aptos_types::on_chain_config::{OnChainExecutionConfig, BlockGasLimitType};
    use aptos_types::transaction::SignedTransaction;
    
    // Setup: Create execution config with NoLimit
    let config = OnChainExecutionConfig::Missing;
    assert_eq!(config.block_gas_limit_type(), BlockGasLimitType::NoLimit);
    
    // Attack: Create 1800 transactions with MAX_GAS_AMOUNT
    let mut transactions = Vec::new();
    for i in 0..1800 {
        let txn = create_transaction_with_max_gas(
            account_address(i),
            2_000_000, // MAX_GAS_AMOUNT
        );
        transactions.push(txn);
    }
    
    // Block proposal selects all transactions (no gas filtering)
    let selected = mempool.get_batch(
        5000,  // max_txns
        3 * 1024 * 1024,  // max_bytes
        true,  // return_non_full
        BTreeMap::new()  // exclude_transactions
    );
    assert_eq!(selected.len(), 1800);
    
    // Execution: With NoLimit, all transactions execute
    let start = Instant::now();
    let result = execute_block(&selected, &config);
    let elapsed = start.elapsed();
    
    // Verify: Execution time exceeds consensus timeout
    assert!(elapsed > Duration::from_secs(60), 
        "Block execution took {} seconds, exceeding timeout",
        elapsed.as_secs());
    
    // Impact: Validators cannot reach consensus
    assert!(elapsed > Duration::from_millis(1000),
        "Execution time {} exceeds round_initial_timeout_ms",
        elapsed.as_millis());
}
```

**Notes:**
- This vulnerability has existed since the introduction of OnChainExecutionConfig with backwards compatibility
- Modern networks with V7 config and ComplexLimitV1 are protected with proper block gas limits
- The fallback mechanism in epoch_manager creates a dangerous failure mode
- Cumulative gas-based transaction selection would provide defense in depth

### Citations

**File:** types/src/on_chain_config/execution_config.rs (L42-58)
```rust
    /// The per-block gas limit being used.
    pub fn block_gas_limit_type(&self) -> BlockGasLimitType {
        match &self {
            OnChainExecutionConfig::Missing => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V1(_config) => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V2(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V3(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V4(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V5(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V6(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V7(config) => config.block_gas_limit_type.clone(),
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L135-139)
```rust
    /// The default values to use when on-chain config is not initialized.
    /// This value should not be changed, for replay purposes.
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L143-155)
```rust
    pub fn default_for_genesis() -> Self {
        BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 20000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 9,
            use_granular_resource_group_conflicts: false,
            use_module_publishing_block_conflict: true,
            block_output_limit: Some(4 * 1024 * 1024),
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: true,
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L1202-1203)
```rust
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** mempool/src/core_mempool/mempool.rs (L425-538)
```rust
    pub(crate) fn get_batch(
        &self,
        max_txns: u64,
        max_bytes: u64,
        return_non_full: bool,
        exclude_transactions: BTreeMap<TransactionSummary, TransactionInProgress>,
    ) -> Vec<SignedTransaction> {
        let start_time = Instant::now();
        let exclude_size = exclude_transactions.len();
        let mut inserted = HashSet::new();

        let gas_end_time = start_time.elapsed();

        let mut result = vec![];
        // Helper DS. Helps to mitigate scenarios where account submits several transactions
        // with increasing gas price (e.g. user submits transactions with sequence number 1, 2
        // and gas_price 1, 10 respectively)
        // Later txn has higher gas price and will be observed first in priority index iterator,
        // but can't be executed before first txn. Once observed, such txn will be saved in
        // `skipped` DS and rechecked once it's ancestor becomes available
        let mut skipped = HashSet::new();
        let mut total_bytes = 0;
        let mut txn_walked = 0usize;
        // iterate over the queue of transactions based on gas price
        'main: for txn in self.transactions.iter_queue() {
            txn_walked += 1;
            let txn_ptr = TxnPointer::from(txn);

            // TODO: removed gas upgraded logic. double check if it's needed
            if exclude_transactions.contains_key(&txn_ptr) {
                continue;
            }
            let txn_replay_protector = txn.replay_protector;
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(txn_seq) => {
                    let txn_in_sequence = txn_seq > 0
                        && Self::txn_was_chosen(
                            txn.address,
                            txn_seq - 1,
                            &inserted,
                            &exclude_transactions,
                        );
                    let account_sequence_number =
                        self.transactions.get_account_sequence_number(&txn.address);
                    // include transaction if it's "next" for given account or
                    // we've already sent its ancestor to Consensus.
                    if txn_in_sequence || account_sequence_number == Some(&txn_seq) {
                        inserted.insert((txn.address, txn_replay_protector));
                        result.push((txn.address, txn_replay_protector));
                        if (result.len() as u64) == max_txns {
                            break;
                        }
                        // check if we can now include some transactions
                        // that were skipped before for given account
                        let (skipped_txn_sender, mut skipped_txn_seq_num) =
                            (txn.address, txn_seq + 1);
                        while skipped.remove(&(skipped_txn_sender, skipped_txn_seq_num)) {
                            inserted.insert((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            result.push((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            if (result.len() as u64) == max_txns {
                                break 'main;
                            }
                            skipped_txn_seq_num += 1;
                        }
                    } else {
                        skipped.insert((txn.address, txn_seq));
                    }
                },
                ReplayProtector::Nonce(_) => {
                    inserted.insert((txn.address, txn_replay_protector));
                    result.push((txn.address, txn_replay_protector));
                    if (result.len() as u64) == max_txns {
                        break;
                    }
                },
            };
        }
        let result_size = result.len();
        let result_end_time = start_time.elapsed();
        let result_time = result_end_time.saturating_sub(gas_end_time);

        let mut block = Vec::with_capacity(result_size);
        let mut full_bytes = false;
        for (sender, replay_protector) in result {
            if let Some((txn, ranking_score)) = self
                .transactions
                .get_with_ranking_score(&sender, replay_protector)
            {
                let txn_size = txn.txn_bytes_len() as u64;
                if total_bytes + txn_size > max_bytes {
                    full_bytes = true;
                    break;
                }
                total_bytes += txn_size;
                block.push(txn);
                if total_bytes == max_bytes {
                    full_bytes = true;
                }
                counters::core_mempool_txn_ranking_score(
                    counters::CONSENSUS_PULLED_LABEL,
                    counters::CONSENSUS_PULLED_LABEL,
                    self.transactions
                        .get_bucket(ranking_score, &sender)
                        .as_str(),
                    ranking_score,
                );
            }
        }
```

**File:** config/src/config/consensus_config.rs (L20-21)
```rust
const MAX_SENDING_BLOCK_TXNS_AFTER_FILTERING: u64 = 1800;
const MAX_SENDING_OPT_BLOCK_TXNS_AFTER_FILTERING: u64 = 1000;
```

**File:** config/src/config/consensus_config.rs (L235-239)
```rust
            round_initial_timeout_ms: 1000,
            // 1.2^6 ~= 3
            // Timeout goes from initial_timeout to initial_timeout*3 in 6 steps
            round_timeout_backoff_exponent_base: 1.2,
            round_timeout_backoff_max_exponent: 6,
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L127-140)
```rust
    fn should_end_block(&mut self, mode: &str) -> bool {
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L50-58)
```rust
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
        // computational time of any given transaction at roughly 20 seconds. We want this number and
        // `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
        [
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
```
