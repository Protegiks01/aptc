# Audit Report

## Title
Missing Cryptographic Validation of PeerId Derivation from Network Identity Key Enables Identity Confusion and Accountability Bypass

## Summary
The Aptos Core codebase lacks validation that a validator's PeerId (account address) is cryptographically derived from their network identity key (x25519 public key). This allows validators to register with arbitrary account addresses unbound to their cryptographic identity, breaking the accountability model and enabling identity confusion attacks.

## Finding Description

The security question asks whether PeerId is cryptographically derived from the node's private key. After thorough investigation, I discovered that **no such validation exists at any layer of the system**.

**Vulnerability Chain:**

1. **At Configuration Loading**: The `aptos_node_identity::init()` function accepts an arbitrary `PeerId` without validating it matches the cryptographic derivation from the private key. [1](#0-0) 

2. **At Config Deserialization**: The `Identity::FromConfig` variant stores `peer_id` and the x25519 private key as separate fields with no cryptographic binding enforcement. [2](#0-1) 

The constructor allows arbitrary peer_id values: [3](#0-2) 

3. **At Network Configuration**: When retrieving the peer_id, the system directly returns the stored value without validation: [4](#0-3) 

Note that only `Identity::FromFile` with missing `account_address` properly derives the peer_id (lines 262-264), while other paths accept arbitrary values.

4. **At On-Chain Registration**: Validators can register with arbitrary network addresses that are not cryptographically bound to their account address. The `stake::initialize_validator()` function accepts `network_addresses` as raw bytes without validation: [5](#0-4) 

Only the consensus key undergoes proof-of-possession validation (lines 679-683). The network addresses containing the x25519 public key have **zero validation** against the account address.

5. **At Validator Set Population**: When other validators build their trusted peer sets from on-chain data, they extract the account address as peer_id directly without validating it's derived from the network public key: [6](#0-5) 

Line 118 uses `*info.account_address()` as the peer_id with no cryptographic verification.

6. **At Handshake Authentication**: During mutual authentication, the system verifies that the public key matches what's in the trusted peer set, but **does NOT** verify the peer_id is derived from that public key: [7](#0-6) 

In `HandshakeAuthMode::Mutual` (lines 369-383), the system looks up the `remote_peer_id` in `trusted_peers` and then calls `authenticate_inbound` which only checks if the public key is in the peer's key set: [8](#0-7) 

Critically, in `MaybeMutual` mode (lines 391-404), the system DOES validate peer_id derivation for untrusted peers using `from_identity_public_key`, but this validation is **missing** for trusted peers in Mutual mode!

7. **No Config Sanitization**: The config sanitizer performs various checks but **never validates** that peer_id matches the cryptographic derivation: [9](#0-8) 

**Correct Derivation Function Exists But Is Not Used**: The proper derivation function `from_identity_public_key` exists and correctly derives a PeerId from an x25519 public key: [10](#0-9) 

However, this function is **only used** in the `MaybeMutual` handshake path for untrusted peers, not for validators in the trusted peer set.

**Attack Scenario:**

A Byzantine validator can:
1. Create account address A (arbitrary value, not derived from any key)
2. Generate x25519 keypair (k, K) where K is the public key
3. Register on-chain via `stake::initialize_validator()` with account_address=A and network_addresses containing K
4. Configure local node with peer_id=A and private_key=k
5. When connecting to other validators:
   - Other validators populate trusted_peers with entry (A, K)
   - During handshake, validator advertises peer_id A
   - Handshake succeeds because A is in trusted_peers AND K matches
   - **No validation that A == from_identity_public_key(K)**

This breaks the fundamental cryptographic binding between identity and keys.

## Impact Explanation

**Severity: High** 

This vulnerability breaks critical security invariants:

1. **Accountability Breakdown**: Network-layer actions authenticated by the x25519 key cannot be reliably attributed to the on-chain account address because there's no cryptographic binding between them.

2. **Identity Confusion**: The peer_id (account address) and cryptographic identity (public key) are decoupled, enabling sophisticated attacks where a validator's on-chain identity doesn't match their network identity.

3. **Governance/Staking Confusion**: Stake is tied to account addresses, but network authentication uses public keys. Without binding, attribution of network behavior to staked accounts is unreliable.

4. **Configuration Attacks**: Malicious or compromised operators can configure nodes with mismatched identities that pass all validation checks, creating operational confusion and potential attack vectors.

While this doesn't directly enable consensus safety violations or fund theft, it violates the **Cryptographic Correctness** invariant (#10 from the specification) and creates a foundational security weakness that could be combined with other vulnerabilities for sophisticated attacks.

This qualifies as **High Severity** under Aptos bug bounty criteria as it represents a "Significant protocol violation" affecting the integrity of the validator identity system.

## Likelihood Explanation

**Likelihood: Medium-High**

While exploiting this requires:
- Governance approval to become a validator (gated)
- No immediate financial gain

The likelihood of occurrence is significant because:

1. **No Detection**: Misconfigured nodes with mismatched peer_id/key pairs will pass all validation checks and operate normally
2. **Operational Errors**: Legitimate operators could accidentally create this misconfiguration without detection
3. **No Monitoring**: There are no runtime checks or metrics to detect this inconsistency
4. **Persistent**: Once registered on-chain, the mismatch persists indefinitely

The vulnerability is always present for any validator who chooses (intentionally or accidentally) to use a non-derived peer_id.

## Recommendation

Implement validation at multiple layers:

**1. At Configuration Loading:**
```rust
pub fn init(peer_id: Option<PeerId>, identity_key: Option<x25519::PrivateKey>) -> Result<()> {
    // Validate peer_id matches key derivation if both provided
    if let (Some(peer_id), Some(key)) = (peer_id, identity_key) {
        let derived_peer_id = aptos_types::account_address::from_identity_public_key(
            key.public_key()
        );
        if peer_id != derived_peer_id {
            return Err(format_err!(
                "PeerId mismatch: configured={}, derived={}", 
                peer_id, derived_peer_id
            ));
        }
    }
    
    let identity = AptosNodeIdentity {
        chain_id: OnceCell::new(),
        peer_id,
        peer_id_str: peer_id.map(|id| id.to_string()),
    };
    
    APTOS_NODE_IDENTITY
        .set(Arc::new(identity))
        .map_err(|_| format_err!("APTOS_NODE_IDENTITY was already set"))
}
```

**2. At Config Deserialization:**
Add validation in `NetworkConfig::peer_id()` to verify derivation for all Identity variants.

**3. At On-Chain Registration:**
Add Move validation in `stake::initialize_validator()`:
```move
// Verify network_addresses contain a public key that derives to signer's address
let decoded_addrs = decode_network_addresses(network_addresses);
let network_pubkey = extract_x25519_pubkey(decoded_addrs);
let derived_address = derive_address_from_pubkey(network_pubkey);
assert!(derived_address == signer::address_of(account), EINVALID_NETWORK_KEY_BINDING);
```

**4. At Handshake (Defense in Depth):**
Add validation in `authenticate_inbound` even for trusted peers:
```rust
fn authenticate_inbound(
    remote_peer_short: ShortHexStr,
    peer_id: PeerId,
    peer: &Peer,
    remote_public_key: &x25519::PublicKey,
) -> Result<PeerRole, NoiseHandshakeError> {
    // Existing key set check
    if !peer.keys.contains(remote_public_key) {
        return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(/*...*/));
    }
    
    // NEW: Validate peer_id derivation
    let derived_peer_id = aptos_types::account_address::from_identity_public_key(
        *remote_public_key
    );
    if derived_peer_id != peer_id {
        return Err(NoiseHandshakeError::ClientPeerIdMismatch(
            remote_peer_short,
            peer_id,
            derived_peer_id,
        ));
    }
    
    Ok(peer.role)
}
```

## Proof of Concept

**Configuration-Based PoC:**

1. Create a validator config with mismatched identity:
```yaml
base:
  role: "validator"

validator_network:
  identity:
    type: "from_config"
    key: "0x1234..." # x25519 private key
    peer_id: "0xDEADBEEF..." # Arbitrary address NOT derived from key
  mutual_authentication: true
```

2. The node will start successfully despite the mismatch
3. The `aptos_node_identity::init()` will accept the arbitrary peer_id
4. No error or warning is generated
5. The node operates with mismatched cryptographic identity

**On-Chain Registration PoC:**

```move
// On-chain validator registration with mismatched identity
script {
    fun register_with_mismatched_identity(validator: &signer) {
        let arbitrary_account = @0xDEADBEEF;
        let network_pubkey = x"CAFE..."; // x25519 public key
        let network_addr = encode_network_address(network_pubkey);
        
        // This succeeds even though arbitrary_account != derive(network_pubkey)
        stake::initialize_validator(
            validator,
            consensus_pubkey,
            proof_of_possession,
            network_addr, // Contains network_pubkey
            fullnode_addr
        );
        
        // No validation that signer::address_of(validator) 
        // should equal from_identity_public_key(network_pubkey)
    }
}
```

**Verification Steps:**

1. Deploy the misconfigured validator
2. Check that `aptos_node_identity::peer_id()` returns the arbitrary peer_id
3. Check that network handshakes succeed with other validators
4. Verify no errors are logged about identity mismatch
5. Confirm the cryptographic binding is not enforced anywhere in the codebase

This demonstrates that the PeerId is NOT cryptographically derived from the private key and can be set to arbitrary values, violating the expected security invariant.

### Citations

**File:** crates/aptos-node-identity/src/lib.rs (L22-32)
```rust
pub fn init(peer_id: Option<PeerId>) -> Result<()> {
    let identity = AptosNodeIdentity {
        chain_id: OnceCell::new(),
        peer_id,
        peer_id_str: peer_id.map(|id| id.to_string()),
    };

    APTOS_NODE_IDENTITY
        .set(Arc::new(identity))
        .map_err(|_| format_err!("APTOS_NODE_IDENTITY was already set"))
}
```

**File:** config/src/config/identity_config.rs (L75-82)
```rust
    pub fn from_config(key: x25519::PrivateKey, peer_id: PeerId) -> Self {
        let key = ConfigKey::new(key);
        Identity::FromConfig(IdentityFromConfig {
            key,
            peer_id,
            source: IdentitySource::UserProvided,
        })
    }
```

**File:** config/src/config/identity_config.rs (L130-139)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** config/src/config/network_config.rs (L244-270)
```rust
    pub fn peer_id(&self) -> PeerId {
        match &self.identity {
            Identity::FromConfig(config) => Some(config.peer_id),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let peer_id = storage
                    .get::<PeerId>(&config.peer_id_name)
                    .expect("Unable to read peer id")
                    .value;
                Some(peer_id)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();

                // If account is not specified, generate peer id from public key
                if let Some(address) = identity_blob.account_address {
                    Some(address)
                } else {
                    Some(from_identity_public_key(
                        identity_blob.network_private_key.public_key(),
                    ))
                }
            },
            Identity::None => None,
        }
        .expect("peer id should be present")
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L670-692)
```text
    public entry fun initialize_validator(
        account: &signer,
        consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
        network_addresses: vector<u8>,
        fullnode_addresses: vector<u8>,
    ) acquires AllowedValidators {
        check_stake_permission(account);
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));

        initialize_owner(account);
        move_to(account, ValidatorConfig {
            consensus_pubkey,
            network_addresses,
            fullnode_addresses,
            validator_index: 0,
        });
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/framework/src/noise/handshake.rs (L368-427)
```rust
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
        }?;
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** config/src/config/config_sanitizer.rs (L39-71)
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

        Ok(()) // All configs passed validation
    }
}
```

**File:** types/src/account_address.rs (L135-146)
```rust
// Note: This is inconsistent with current types because AccountAddress is derived
// from consensus key which is of type Ed25519PublicKey. Since AccountAddress does
// not mean anything in a setting without remote authentication, we use the network
// public key to generate a peer_id for the peer.
// See this issue for potential improvements: https://github.com/aptos-labs/aptos-core/issues/3960
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```
