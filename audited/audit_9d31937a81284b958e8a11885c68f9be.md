# Audit Report

## Title
Consensus Observer Payload Type Mismatch Enables Targeted Denial of Service and Observer Divergence

## Summary
The `verify_against_ordered_payload()` function in `consensus/src/consensus_observer/network/observer_message.rs` fails to enforce strict type matching between `BlockTransactionPayload` variants and `Payload` variants. This asymmetric verification allows a malicious publisher to send different `BlockTransactionPayload` types to different observers, causing some observers to accept an `OrderedBlock` while others reject it, leading to observer divergence and potential consensus safety violations.

## Finding Description
The consensus observer system separates block payload delivery into two messages: `BlockPayload` (containing `BlockTransactionPayload` with actual transaction data) and `OrderedBlock` (containing `Payload` specification). The `verify_against_ordered_payload()` function is supposed to ensure these match. [1](#0-0) 

The vulnerability exists because the verification function matches on the `Payload` type from the ordered block but does not enforce that the `BlockTransactionPayload` variant is compatible. Specifically:

**Asymmetric Verification Behavior:**
1. When `Payload` is `InQuorumStore`, only `verify_batches()` is called, not checking for absent inline batches
2. When `Payload` is `QuorumStoreInlineHybrid`, both `verify_batches()` and `verify_inline_batches()` are called [2](#0-1) 

The `verify_inline_batches()` function explicitly rejects `BlockTransactionPayload` variants that don't contain inline batches: [3](#0-2) 

**Attack Scenario:**
1. Malicious publisher creates a valid `OrderedBlock` with `Payload::QuorumStoreInlineHybrid` (properly signed by consensus)
2. Publisher sends `BlockPayload` with `BlockTransactionPayload::DeprecatedInQuorumStore` to Observer A (no inline batches)
3. Publisher sends `BlockPayload` with `BlockTransactionPayload::QuorumStoreInlineHybrid` to Observer B (with inline batches)
4. Both observers verify and store their respective payloads
5. Publisher broadcasts the `OrderedBlock` with `QuorumStoreInlineHybrid` payload
6. Observer A's verification calls `verify_inline_batches()` on `DeprecatedInQuorumStore` → **fails with "Transaction payload does not contain inline batches!"**
7. Observer B's verification matches correctly → **succeeds**
8. Observer A rejects the block, Observer B accepts it → **observers diverge**

The verification is called here during ordered block processing: [4](#0-3) 

When verification fails, the ordered block is rejected: [5](#0-4) 

The DirectMempool rejection at lines 653-657 is part of this same pattern - the function attempts to reject incompatible payload types but fails to enforce complete type matching, allowing the asymmetric behavior described above.

## Impact Explanation
**Severity: Medium to High**

This vulnerability enables:

1. **Targeted Denial of Service**: A malicious publisher can selectively prevent specific observers from processing blocks by sending them incompatible `BlockTransactionPayload` types, causing targeted rejection of valid `OrderedBlock` messages.

2. **Observer Divergence**: Different observers will have different views of the blockchain state when they accept/reject different ordered blocks, violating the **Deterministic Execution** invariant that requires all validators/observers to produce identical state for identical blocks.

3. **Consensus Disruption**: While consensus observers don't directly participate in voting, their divergence can cause issues with state sync, block payload distribution, and overall network reliability. Observers that fall behind due to repeated rejections may require manual intervention.

This qualifies as **Medium Severity** per the bug bounty criteria: "State inconsistencies requiring intervention" - observers will diverge and may need to be reset or resynced.

## Likelihood Explanation
**Likelihood: Medium**

**Attacker Requirements:**
- Must be a block publisher (validator or node with publishing capability)
- Can send different `BlockPayload` messages to different observers (network-level capability)
- Can craft `OrderedBlock` messages with specific `Payload` types

**Exploitation Complexity:**
- Moderate - requires understanding of the payload type system
- Requires ability to send differentiated messages to different observers
- The asymmetric verification behavior makes exploitation straightforward once understood

**Realistic Scenario:**
A malicious or compromised validator node could easily exploit this by:
1. Observing which observers are connected
2. Sending tailored `BlockPayload` messages to subsets of observers
3. Broadcasting standard `OrderedBlock` messages
4. Causing predictable divergence based on payload type combinations

## Recommendation
Add strict type matching validation to ensure `BlockTransactionPayload` variant is compatible with `Payload` variant:

```rust
pub fn verify_against_ordered_payload(
    &self,
    ordered_block_payload: &Payload,
) -> Result<(), Error> {
    // First, enforce type compatibility between BlockTransactionPayload and Payload
    match (self, ordered_block_payload) {
        (BlockTransactionPayload::DeprecatedInQuorumStore(_), Payload::InQuorumStore(_)) |
        (BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(_), Payload::InQuorumStoreWithLimit(_)) |
        (BlockTransactionPayload::QuorumStoreInlineHybrid(_, _), Payload::QuorumStoreInlineHybrid(_, _, _)) |
        (BlockTransactionPayload::QuorumStoreInlineHybridV2(_, _), Payload::QuorumStoreInlineHybridV2(_, _, _)) |
        (BlockTransactionPayload::OptQuorumStore(_, _), Payload::OptQuorumStore(_)) => {
            // Types match, proceed with verification
        },
        (_, Payload::DirectMempool(_)) => {
            return Err(Error::InvalidMessageError(
                "Direct mempool payloads are not supported for consensus observer!".into(),
            ));
        },
        _ => {
            return Err(Error::InvalidMessageError(format!(
                "Payload type mismatch! BlockTransactionPayload variant does not match Payload variant. BlockTransactionPayload: {:?}, Payload: {:?}",
                std::mem::discriminant(self),
                std::mem::discriminant(ordered_block_payload)
            )));
        }
    }
    
    // Then proceed with existing verification logic
    match ordered_block_payload {
        Payload::DirectMempool(_) => unreachable!(), // Already handled above
        Payload::InQuorumStore(proof_with_data) => {
            self.verify_batches(&proof_with_data.proofs)?;
        },
        // ... rest of the existing verification logic
    }
    
    Ok(())
}
```

## Proof of Concept
```rust
#[test]
fn test_payload_type_mismatch_asymmetric_verification() {
    // Create a QuorumStoreInlineHybrid BlockTransactionPayload with inline batches
    let inline_batches = vec![create_batch_info()];
    let block_payload_hybrid = BlockTransactionPayload::new_quorum_store_inline_hybrid(
        vec![],
        vec![],
        Some(100),
        None,
        inline_batches.clone(),
        true,
    );
    
    // Create an InQuorumStore BlockTransactionPayload without inline batches
    let block_payload_in_qs = BlockTransactionPayload::new_in_quorum_store(vec![], vec![]);
    
    // Create an OrderedBlock with QuorumStoreInlineHybrid Payload
    let ordered_payload_hybrid = Payload::QuorumStoreInlineHybrid(
        vec![(create_batch_info(), vec![])],
        ProofWithData::new(vec![]),
        Some(100),
    );
    
    // Scenario A: QuorumStoreInlineHybrid BlockTransactionPayload vs InQuorumStore Payload
    // This should fail but currently passes due to incomplete verification
    let ordered_payload_in_qs = Payload::InQuorumStore(ProofWithData::new(vec![]));
    let result_a = block_payload_hybrid.verify_against_ordered_payload(&ordered_payload_in_qs);
    // BUG: This incorrectly passes! Should detect type mismatch.
    assert!(result_a.is_ok()); // Current buggy behavior
    
    // Scenario B: InQuorumStore BlockTransactionPayload vs QuorumStoreInlineHybrid Payload  
    // This correctly fails because verify_inline_batches() detects missing inline batches
    let result_b = block_payload_in_qs.verify_against_ordered_payload(&ordered_payload_hybrid);
    assert!(result_b.is_err()); // Correctly rejects
    assert!(result_b.unwrap_err().to_string().contains("does not contain inline batches"));
    
    // Asymmetric verification behavior demonstrated:
    // - Scenario A passes (incorrect due to missing type check)
    // - Scenario B fails (correct due to inline batch check)
    // This allows malicious publishers to cause observer divergence by sending
    // different BlockTransactionPayload types to different observers.
}
```

## Notes
The DirectMempool rejection mentioned in the security question is symptomatic of the broader issue: the verification function attempts to reject certain incompatible payload types but fails to comprehensively enforce type compatibility. The asymmetric verification behavior creates an exploitable attack surface where observers can be forced to diverge based on which `BlockTransactionPayload` variant they receive, even when processing the same valid `OrderedBlock`.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L648-717)
```rust
    pub fn verify_against_ordered_payload(
        &self,
        ordered_block_payload: &Payload,
    ) -> Result<(), Error> {
        match ordered_block_payload {
            Payload::DirectMempool(_) => {
                return Err(Error::InvalidMessageError(
                    "Direct mempool payloads are not supported for consensus observer!".into(),
                ));
            },
            Payload::InQuorumStore(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;
            },
            Payload::InQuorumStoreWithLimit(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proof_with_data.proofs)?;

                // Verify the transaction limit
                self.verify_transaction_limit(proof_with_data.max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(*max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                // Verify the batches in the requested block
                self.verify_batches(p.proof_with_data())?;

                // Verify optQS and inline batches
                self.verify_optqs_and_inline_batches(p.opt_batches(), p.inline_batches())?;

                // Verify the transaction limit
                self.verify_transaction_limit(p.max_txns_to_execute())?;
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L756-760)
```rust
            _ => {
                return Err(Error::InvalidMessageError(
                    "Transaction payload does not contain inline batches!".to_string(),
                ))
            },
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L198-199)
```rust
                    // Verify the transaction payload against the ordered block payload
                    transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L754-771)
```rust
        // Verify the block payloads against the ordered block
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```
