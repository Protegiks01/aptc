# Audit Report

## Title
Faucet Service Denial-of-Service via Transaction Expiration When wait_for_transactions=false

## Summary
When the faucet is configured with `wait_for_transactions=false`, an attacker can cause temporary denial-of-service by triggering transaction expirations that desynchronize the faucet's local sequence number from the on-chain sequence number, blocking new requests for up to 30 seconds.

## Finding Description
The vulnerability exists in the faucet's transaction submission mechanism when `wait_for_transactions` is disabled. The attack exploits a sequence number desynchronization issue: [1](#0-0) 

When `wait_for_transactions=false`, the faucet calls `submit_bcs()` which returns immediately after the mempool accepts the transaction, without waiting for execution. The local sequence number is incremented upon successful submission: [2](#0-1) 

If submission succeeds but the transaction later expires in the mempool (default 25-second expiration), the sequence number is NOT decremented: [3](#0-2) 

The faucet enforces a maximum of 15 outstanding transactions: [4](#0-3) 

When the local sequence number exceeds the on-chain sequence number by 15, subsequent requests are blocked: [5](#0-4) 

The faucet waits up to 30 seconds for the on-chain sequence number to catch up before resetting: [6](#0-5) 

**Attack Path:**
1. Attacker sends 15+ requests to the faucet (within rate limits)
2. Faucet submits transactions to mempool with incremented local sequence numbers
3. If network congestion or delays prevent transaction inclusion within 25 seconds, transactions expire
4. Mempool garbage collects expired transactions, on-chain sequence number doesn't advance
5. Local sequence number is now 15+ ahead of on-chain sequence number
6. All subsequent faucet requests are blocked for up to 30 seconds
7. Attack can be repeated after sequence number reset

While rate limiting exists to prevent spam: [7](#0-6) 

The vulnerability is exploitable if rate limits allow 15+ requests, or through coordinated multi-IP attacks.

## Impact Explanation
**Severity: Medium (service availability issue)**

This issue causes temporary denial-of-service of the faucet service for up to 30 seconds per occurrence. According to Aptos bug bounty criteria, this falls under **Medium severity** as it causes state inconsistencies requiring automated intervention (sequence number reset).

**Impact scope:**
- Faucet service becomes unresponsive for legitimate users
- Can be repeated to cause sustained availability degradation
- Self-recovering after 30 seconds
- Does NOT affect blockchain consensus, validator operations, or user funds
- Limited to faucet auxiliary service, not core protocol

The faucet is an important developer tool for testnet/devnet, and its unavailability impacts ecosystem development workflows.

## Likelihood Explanation
**Likelihood: Medium to High** (depending on configuration)

The attack is realistic under these conditions:
1. Faucet configured with `wait_for_transactions=false` (configuration-dependent)
2. Rate limits allow 15+ requests per IP or attacker has multiple IPs
3. Network conditions cause transaction expiration (congestion, slow consensus)

Network congestion naturally occurs during high load periods. With Aptos consensus defaulting to 1-second round timeouts: [8](#0-7) 

Under normal conditions, 25-second transaction expiration should be sufficient. However, during pipeline backpressure or chain health issues (which Aptos explicitly handles), transaction processing can exceed 25 seconds, triggering the vulnerability.

## Recommendation
**Fix: Always wait for transactions or implement async sequence number tracking**

**Option 1 (Recommended): Force wait_for_transactions=true**
```rust
// In TransactionSubmissionConfig, remove the option to disable waiting
pub struct TransactionSubmissionConfig {
    // Remove this field or force it to true
    #[serde(default = "default_wait_for_transactions")]
    pub wait_for_transactions: bool,
}

fn default_wait_for_transactions() -> bool {
    true // Always wait
}
```

**Option 2: Implement async sequence number reconciliation**
Monitor submitted transaction hashes and query their status periodically. Decrement local sequence number if transactions expire before execution.

**Option 3: Increase transaction expiration time**
Set expiration significantly higher (e.g., 300 seconds) when `wait_for_transactions=false` to reduce expiration probability.

**Option 4: Tighter outstanding transaction limit**
Reduce `MAX_NUM_OUTSTANDING_TRANSACTIONS` from 15 to 3-5 to minimize DoS window.

## Proof of Concept
```rust
// Pseudo-code demonstrating the vulnerability
// This would require a testnet deployment with wait_for_transactions=false

#[tokio::test]
async fn test_faucet_dos_via_transaction_expiration() {
    // Setup: Configure faucet with wait_for_transactions=false
    let faucet_config = TransferFunderConfig {
        transaction_submission_config: TransactionSubmissionConfig {
            wait_for_transactions: false,
            transaction_expiration_secs: 25,
            ..Default::default()
        },
        ..Default::default()
    };
    
    // Step 1: Send 15 rapid requests
    let mut handles = vec![];
    for i in 0..15 {
        let handle = tokio::spawn(async move {
            faucet_client.fund(FundRequest {
                address: format!("0x{:064x}", i),
                amount: Some(100_000),
                ..Default::default()
            }).await
        });
        handles.push(handle);
    }
    
    // All 15 should succeed immediately (not waiting for execution)
    for handle in handles {
        assert!(handle.await.is_ok());
    }
    
    // Step 2: Simulate network congestion - wait for transactions to expire
    tokio::time::sleep(Duration::from_secs(26)).await;
    
    // Step 3: Attempt 16th request - should block/timeout
    let start = Instant::now();
    let result = faucet_client.fund(FundRequest {
        address: "0x16",
        ..Default::default()
    }).await;
    
    let elapsed = start.elapsed();
    
    // Verify the request was blocked for ~30 seconds
    assert!(elapsed >= Duration::from_secs(28));
    assert!(elapsed <= Duration::from_secs(32));
}
```

## Notes
- This is a **service availability issue**, not a core blockchain protocol vulnerability
- The impact is limited to faucet service; it does NOT affect consensus, validators, or user funds
- The issue is self-recovering after 30 seconds
- Mitigation already exists through rate limiting, but the underlying synchronization issue remains
- Production deployments should use `wait_for_transactions=true` to prevent this issue
- The categorization as "Medium" severity in the security question is appropriate for a faucet service DoS, though it would not qualify for higher severity categories that require consensus or funds impact

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L39-39)
```rust
const MAX_NUM_OUTSTANDING_TRANSACTIONS: u64 = 15;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L161-162)
```rust
    fn default_transaction_expiration_secs() -> u64 {
        25
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L232-268)
```rust
    for _ in 0..(wait_for_outstanding_txns_secs * 2) {
        if our_funder_seq < funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            // Enforce a stronger ordering of priorities based upon the MintParams that arrived
            // first. Then put the other folks to sleep to try again until the queue fills up.
            if !set_outstanding {
                let mut requests_map = outstanding_requests.write().await;
                let queue = requests_map
                    .entry(asset_name.to_string())
                    .or_insert_with(Vec::new);
                queue.push(request_key);
                set_outstanding = true;
            }

            // Check if this request is at the front of the queue for this asset
            let requests_map = outstanding_requests.read().await;
            let is_at_front = if let Some(queue) = requests_map.get(asset_name) {
                queue.first() == Some(&request_key)
            } else {
                false
            };

            if is_at_front {
                // There might have been two requests with the same parameters, so we ensure that
                // we only pop off one of them. We do a read lock first since that is cheap,
                // followed by a write lock.
                drop(requests_map);
                let mut requests_map = outstanding_requests.write().await;
                if let Some(queue) = requests_map.get_mut(asset_name) {
                    if queue.first() == Some(&request_key) {
                        queue.remove(0);
                    }
                }
                break;
            }
            tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;
            continue;
        }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L288-296)
```rust
    if our_funder_seq >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
        error!("We are unhealthy, transactions have likely expired.");
        let funder_account = funder_account.write().await;
        if funder_account.sequence_number() >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            info!("Resetting the sequence number counter.");
            funder_account.set_sequence_number(funder_seq);
        } else {
            info!("Someone else reset the sequence number counter ahead of us.");
        }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L349-375)
```rust
    let (result, event_on_success) = if wait_for_transactions {
        // If this fails, we assume it is the user's fault, e.g. because the
        // account already exists, but it is possible that the transaction
        // timed out. It's hard to tell because this function returns an opaque
        // anyhow error. https://github.com/aptos-labs/aptos-tap/issues/60.
        (
            client
                .submit_and_wait_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_success",
        )
    } else {
        (
            client
                .submit_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_submitted",
        )
    };
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L377-399)
```rust
    // If there was an issue submitting a transaction we should just reset
    // our sequence numbers to what it was before.
    match result {
        Ok(_) => {
            info!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = event_on_success,
            );
            Ok(signed_transaction)
        },
        Err(e) => {
            faucet_account.write().await.decrement_sequence_number();
            warn!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = "transaction_failure",
                error_message = format!("{:#}", e)
            );
            Err(e)
        },
    }
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** config/src/config/consensus_config.rs (L235-235)
```rust
            round_initial_timeout_ms: 1000,
```
