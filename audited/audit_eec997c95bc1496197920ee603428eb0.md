# Audit Report

## Title
Validator Node Panic Due to Partial OnceCell Initialization in PartialStateComputeResult During Ledger Update Retry

## Summary
The `PartialStateComputeResult` structure uses `OnceCell` fields that can be left in a partially initialized state when `ledger_update` fails between setting `state_checkpoint_output` and `ledger_update_output`. On retry, the code attempts to set the already-initialized `state_checkpoint_output` again, triggering a panic that crashes the validator node.

## Finding Description

The `PartialStateComputeResult` struct contains two `OnceCell` fields that must be initialized together for atomicity: [1](#0-0) 

Both setter methods use `.expect()` which panics if the cell is already set: [2](#0-1) [3](#0-2) 

In the `ledger_update` method of `BlockExecutor`, there are two code paths where partial initialization can occur:

**Path 1 (Reconfiguration Suffix):** [4](#0-3) 

If `output.set_state_checkpoint_output()` succeeds at lines 301-305, but then `parent_out.ensure_ledger_update_output()?` fails at line 307, the error propagates before `output.set_ledger_update_output()` is called. The block's output is left with `state_checkpoint_output` SET but `ledger_update_output` UNSET.

**Path 2 (Normal Execution):** [5](#0-4) 

If `output.set_state_checkpoint_output()` succeeds at lines 315-320, but then `DoLedgerUpdate::run()` fails or `parent_out.ensure_ledger_update_output()` fails (lines 321-328), the error propagates before `output.set_ledger_update_output()` is called, leaving partial state.

**Retry Scenario:**

The retry check at line 291 only returns early if the result is complete: [6](#0-5) 

Since `get_complete_result()` checks if `ledger_update_output` is set: [7](#0-6) 

If `ledger_update_output` is not set, it returns `None`, so the early return doesn't trigger. Execution continues and attempts to call `set_state_checkpoint_output()` again on the already-initialized field, causing a panic.

This violates the **State Consistency** invariant: state transitions must be atomic. The partial initialization creates an inconsistent state that cannot be recovered through retry.

## Impact Explanation

**High Severity** - This issue causes validator node crashes through panic, which falls under "Validator node slowdowns" and "API crashes" in the Aptos bug bounty High Severity category (up to $50,000).

**Specific impacts:**
1. **Validator Availability**: Affected validators crash and stop participating in consensus
2. **Liveness Risk**: If multiple validators encounter this issue during network instability or database errors, it could impact network liveness
3. **Cascading Failures**: Since the bug can be triggered by parent block issues, it could cascade to child blocks
4. **Recovery Complexity**: The panic prevents normal error recovery, requiring node restart

The issue affects consensus availability rather than safety, as it causes nodes to halt rather than produce incorrect state.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Triggering Conditions**: The bug is triggered by transient failures during ledger update, which can occur due to:
   - Database errors (disk I/O failures, corruption)
   - Parent block state inconsistencies
   - Resource exhaustion
   - Network timing issues during state synchronization

2. **Retry Logic**: The codebase includes retry mechanisms for ledger updates, as evidenced by the check at line 291 and the TODO comment at line 311: "no known strategy to recover from this failure" [8](#0-7) 

3. **Production Scenarios**: During high load, network partitions, or hardware failures, validators may experience transient errors that trigger this code path

4. **No Direct Attacker Control**: While an unprivileged attacker cannot directly trigger this, the conditions arise naturally during normal network operation under stress

## Recommendation

**Solution: Use atomic initialization or proper cleanup on error**

**Option 1: Atomic Initialization Pattern**
Modify `PartialStateComputeResult` to ensure both OnceCells are initialized together or neither:

```rust
pub fn try_set_outputs(
    &self,
    state_checkpoint_output: StateCheckpointOutput,
    ledger_update_output: LedgerUpdateOutput,
) -> Result<()> {
    // Check both are unset before setting either
    ensure!(
        self.state_checkpoint_output.get().is_none(),
        "StateCheckpointOutput already set"
    );
    ensure!(
        self.ledger_update_output.get().is_none(),
        "LedgerUpdateOutput already set"
    );
    
    self.state_checkpoint_output
        .set(state_checkpoint_output)
        .map_err(|_| anyhow!("Failed to set state_checkpoint_output"))?;
    self.ledger_update_output
        .set(ledger_update_output)
        .map_err(|_| anyhow!("Failed to set ledger_update_output"))?;
    
    Ok(())
}
```

**Option 2: Allow Idempotent Retry**
Modify setters to allow re-setting with the same value or clearing on retry:

```rust
pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
    // Allow idempotent retry
    if self.state_checkpoint_output.get().is_some() {
        warn!("StateCheckpointOutput already set, skipping");
        return;
    }
    self.state_checkpoint_output
        .set(state_checkpoint_output)
        .expect("StateCheckpointOutput set race");
}
```

**Option 3: Early Return in ledger_update**
Check for partial state before attempting to set:

```rust
// At the beginning of ledger_update, after line 290
if output.state_checkpoint_output.get().is_some() 
    && output.ledger_update_output.get().is_none() {
    // Partial state detected, clear and retry
    warn!("Partial state detected for block {}, creating new output", block_id);
    return Err(anyhow!("Partial state detected, requires full retry").into());
}
```

**Recommended: Option 1** provides the strongest atomicity guarantee and prevents partial state from occurring in the first place.

## Proof of Concept

```rust
#[cfg(test)]
mod test_partial_oncecell {
    use super::*;
    use aptos_executor_types::execution_output::ExecutionOutput;
    use aptos_storage_interface::LedgerSummary;
    
    #[test]
    #[should_panic(expected = "StateCheckpointOutput already set")]
    fn test_partial_initialization_panic() {
        // Create a PartialStateComputeResult with empty OnceCells
        let execution_output = ExecutionOutput::new_empty(/* ... */);
        let output = PartialStateComputeResult::new(execution_output);
        
        // Simulate first ledger_update attempt
        let state_checkpoint = StateCheckpointOutput::new_empty(/* ... */);
        output.set_state_checkpoint_output(state_checkpoint.clone());
        
        // Simulate error before setting ledger_update_output
        // (parent_out.ensure_ledger_update_output() fails)
        
        // Simulate retry - this will panic
        output.set_state_checkpoint_output(state_checkpoint); // PANIC!
    }
    
    #[test]
    fn test_get_complete_result_with_partial_state() {
        let execution_output = ExecutionOutput::new_empty(/* ... */);
        let output = PartialStateComputeResult::new(execution_output);
        
        // Set only state_checkpoint_output
        let state_checkpoint = StateCheckpointOutput::new_empty(/* ... */);
        output.set_state_checkpoint_output(state_checkpoint);
        
        // get_complete_result should return None
        assert!(output.get_complete_result().is_none());
        
        // But state_checkpoint_output is set
        assert!(output.state_checkpoint_output.get().is_some());
        assert!(output.ledger_update_output.get().is_none());
        
        // This demonstrates the partial state inconsistency
    }
}
```

## Notes

This vulnerability demonstrates a failure in error handling atomicity. The use of `OnceCell` for lazy initialization combined with multi-step initialization creates a window where partial state can persist across retry attempts. The `.expect()` panics are appropriate for detecting programming errors, but the code structure allows those errors to occur during legitimate retry scenarios.

The issue is exacerbated by the fact that the `get_complete_result()` check doesn't detect partial stateâ€”it only checks if `ledger_update_output` is set, not whether `state_checkpoint_output` is set without `ledger_update_output`.

The vulnerability requires specific failure conditions (partial parent block state or transient errors) but these are realistic in production environments, particularly during network stress, database issues, or validator failures.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L17-22)
```rust
#[derive(Clone, Debug)]
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-80)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L88-92)
```rust
    pub fn set_ledger_update_output(&self, ledger_update_output: LedgerUpdateOutput) {
        self.ledger_update_output
            .set(ledger_update_output)
            .expect("LedgerUpdateOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L94-105)
```rust
    pub fn get_complete_result(&self) -> Option<StateComputeResult> {
        self.ledger_update_output.get().map(|ledger_update_output| {
            StateComputeResult::new(
                self.execution_output.clone(),
                // ledger_update_output is set in a later stage, so it's safe to `expect` here.
                self.ensure_state_checkpoint_output()
                    .expect("StateCheckpointOutput missing.")
                    .clone(),
                ledger_update_output.clone(),
            )
        })
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L290-294)
```rust
        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L296-308)
```rust
        if parent_block_id != committed_block_id && parent_out.has_reconfiguration() {
            info!(block_id = block_id, "ledger_update for reconfig suffix.");

            // Parent must have done all state checkpoint and ledger update since this method
            // is being called.
            output.set_state_checkpoint_output(
                parent_out
                    .ensure_state_checkpoint_output()?
                    .reconfig_suffix(),
            );
            output.set_ledger_update_output(
                parent_out.ensure_ledger_update_output()?.reconfig_suffix(),
            );
```

**File:** execution/executor/src/block_executor/mod.rs (L310-330)
```rust
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
```
