# Audit Report

## Title
Configuration-Dependent Input Validation Vulnerability in `pad_and_hash_bytes_with_len()` Allows Scalar Array Overflow

## Summary
The wrapper function `pad_and_hash_bytes_with_len()` contains insufficient input validation that fails to account for the additional length scalar appended during byte-to-scalar packing. This allows configuration values between 466-496 bytes to produce 17 scalars, exceeding the 16-scalar limit enforced by `hash_scalars()`, resulting in deterministic transaction failures and denial of service for keyless authentication.

## Finding Description

The `pad_and_hash_bytes_with_len()` function at lines 225-228 is a thin wrapper that validates `max_bytes <= MAX_NUM_INPUT_BYTES (496)`, but fails to account for the length scalar appended by `pad_and_pack_bytes_to_scalars_with_len()`. [1](#0-0) 

The validation gap exists in `pad_and_pack_bytes_to_scalars_with_len()`: [2](#0-1) 

The constant definitions show the mathematical relationship: [3](#0-2) 

When `max_bytes = 496` (the maximum allowed):
- Packing produces: `496 / 31 = 16` scalars
- Length scalar adds: `+1` scalar  
- Total: `17` scalars

But `hash_scalars()` only accepts 1-16 scalars: [4](#0-3) 

**Attack Vector**: Via governance proposal, any of these configuration fields could be set to values > 465 bytes: [5](#0-4) 

The configuration update function lacks validation: [6](#0-5) 

Note the explicit warning acknowledging this risk: [7](#0-6) 

## Impact Explanation

**Severity: Medium** - This qualifies as "State inconsistencies requiring intervention" per bug bounty criteria.

**Denial of Service Impact:**
- Keyless authentication transactions fail deterministically
- Users cannot access keyless accounts until governance fixes configuration
- All validators affected identically (no consensus split)
- No direct fund loss, but effective account lockout

**Scope of Impact:**
- Affects any keyless transaction using fields with misconfigured byte limits
- Examples: `max_extra_field_bytes`, `max_jwt_header_b64_bytes`, `max_iss_val_bytes`
- Recovery requires another governance proposal (slow)

## Likelihood Explanation

**Likelihood: Low to Medium**

**Requires:**
- Governance proposal to set configuration value > 465 bytes (privileged action)
- Could occur accidentally during legitimate configuration updates
- No automated validation prevents this misconfiguration

**Mitigating Factors:**
- Current circuit constants are all safely below threshold (93-350 bytes)
- Governance process includes review (but lacks technical validation)
- Deterministic failure prevents consensus issues

**Aggravating Factors:**
- Comment at lines 24-28 incorrectly suggests 496 bytes is safe for length-preserving hash
- No runtime or compile-time checks prevent misconfiguration
- Developers may not understand the `+1 scalar` constraint

## Recommendation

Add validation in `pad_and_pack_bytes_to_scalars_with_len()` to reserve space for the length scalar:

```rust
pub fn pad_and_pack_bytes_to_scalars_with_len(
    bytes: &[u8],
    max_bytes: usize,
) -> anyhow::Result<Vec<ark_bn254::Fr>> {
    let len = bytes.len();
    
    // FIXED: Reserve 1 scalar for length field
    const MAX_BYTES_WITH_LEN: usize = (MAX_NUM_INPUT_SCALARS - 1) * BYTES_PACKED_PER_SCALAR; // 465 bytes
    
    if max_bytes > MAX_BYTES_WITH_LEN {
        bail!(
            "Cannot hash more than {} bytes with length encoding. Was given max_bytes={}.",
            MAX_BYTES_WITH_LEN,
            max_bytes
        );
    }
    // ... rest of function unchanged
}
```

Additionally, add Move-side validation in `set_configuration_for_next_epoch()`:

```move
public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {
    system_addresses::assert_aptos_framework(fx);
    
    // Validate configuration byte limits (15 * 31 = 465 max for length-preserving hash)
    assert!(config.max_commited_epk_bytes <= 465, E_CONFIG_EXCEEDS_HASH_LIMIT);
    assert!(config.max_iss_val_bytes <= 465, E_CONFIG_EXCEEDS_HASH_LIMIT);
    assert!(config.max_extra_field_bytes <= 465, E_CONFIG_EXCEEDS_HASH_LIMIT);
    assert!(config.max_jwt_header_b64_bytes <= 465, E_CONFIG_EXCEEDS_HASH_LIMIT);
    
    config_buffer::upsert<Configuration>(config);
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_vulnerability {
    use super::*;
    use crate::poseidon_bn254::keyless::pad_and_hash_bytes_with_len;
    
    #[test]
    #[should_panic(expected = "called with 17 inputs")]
    fn test_max_bytes_overflow() {
        // Create exactly 496 bytes (the maximum allowed by current validation)
        let bytes = vec![0x42u8; 496];
        
        // This passes validation in pad_and_pack_bytes_to_scalars_with_len()
        // but fails in hash_scalars() with 17 scalars
        let result = pad_and_hash_bytes_with_len(&bytes, 496);
        
        // Expected: Error about 17 inputs > 16 max
        result.unwrap();
    }
    
    #[test]
    fn test_safe_threshold() {
        // 465 bytes = 15 scalars + 1 length scalar = 16 total (SAFE)
        let bytes = vec![0x42u8; 465];
        let result = pad_and_hash_bytes_with_len(&bytes, 465);
        assert!(result.is_ok());
    }
    
    #[test]
    #[should_panic]
    fn test_unsafe_threshold() {
        // 466 bytes = 16 scalars + 1 length scalar = 17 total (UNSAFE)
        let bytes = vec![0x42u8; 466];
        let result = pad_and_hash_bytes_with_len(&bytes, 466);
        result.unwrap(); // This will panic
    }
}
```

**Notes:**
- The wrapper adds validation checking `max_bytes <= 496`, but this is **insufficient**
- The correct threshold is `max_bytes <= 465` to reserve space for the length scalar
- Bypassing the wrapper and calling `hash_scalars()` directly doesn't worsen securityâ€”`hash_scalars()` enforces its own 16-scalar limit
- The vulnerability is exploitable only through governance configuration changes, which are trusted roles
- Current production configurations (93-350 bytes) are safe, but lack of validation creates future risk

### Citations

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L13-29)
```rust
/// A BN254 scalar is 254 bits which means it can only store up to 31 bytes of data. We could use a
/// more complicated packing to take advantage of the unused 6 bits, but we do not since it allows
/// us to keep our SNARK circuits simpler.
pub const BYTES_PACKED_PER_SCALAR: usize = 31;

/// `BYTES_PACKED_PER_SCALAR` but for u64s.
pub const LIMBS_PACKED_PER_SCALAR: usize = 3;

/// The maximum number of bytes that can be given as input to the byte-oriented variant of the
/// Poseidon-BN254 hash function exposed in `pad_and_hash_bytes`.
///
/// Note: The first scalar is used to encode the length of the byte array. The max. # of bytes that
/// can be stored in 16 scalars is 16 * 31 = 496 bytes. So the size can be encoded into
/// `ceil(log_2(496)) = 9` bits of a scalar. That would leave 254 - 9 = 245 bits > 30 bytes for
/// storing data in that scalar. We do not plan on exploiting this extra free space (since our
/// SNARK circuits would have to implement this more complicated packing).
pub const MAX_NUM_INPUT_BYTES: usize = MAX_NUM_INPUT_SCALARS * BYTES_PACKED_PER_SCALAR;
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L85-111)
```rust
pub fn pad_and_pack_bytes_to_scalars_with_len(
    bytes: &[u8],
    max_bytes: usize,
) -> anyhow::Result<Vec<ark_bn254::Fr>> {
    let len = bytes.len();
    if max_bytes > MAX_NUM_INPUT_BYTES {
        bail!(
            "Cannot hash more than {} bytes. Was given {} bytes.",
            MAX_NUM_INPUT_BYTES,
            len
        );
    }
    if len > max_bytes {
        bail!(
            "Byte array length of {} is NOT <= max length of {} bytes.",
            bytes.len(),
            max_bytes
        );
    }

    let len_scalar = pack_bytes_to_one_scalar(&len.to_le_bytes())?;
    let scalars = pad_and_pack_bytes_to_scalars_no_len(bytes, max_bytes)?
        .into_iter()
        .chain([len_scalar])
        .collect::<Vec<ark_bn254::Fr>>();
    Ok(scalars)
}
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L225-228)
```rust
pub fn pad_and_hash_bytes_with_len(bytes: &[u8], max_bytes: usize) -> anyhow::Result<Fr> {
    let scalars = pad_and_pack_bytes_to_scalars_with_len(bytes, max_bytes)?;
    hash_scalars(scalars)
}
```

**File:** crates/aptos-crypto/src/poseidon_bn254/mod.rs (L37-44)
```rust
pub fn hash_scalars(inputs: Vec<ark_bn254::Fr>) -> anyhow::Result<ark_bn254::Fr> {
    if inputs.is_empty() || inputs.len() > MAX_NUM_INPUT_SCALARS {
        bail!(
            "Poseidon-BN254 needs > 0 and <= {} inputs, but was called with {} inputs",
            MAX_NUM_INPUT_SCALARS,
            inputs.len()
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L111-135)
```text
        max_commited_epk_bytes: u16,

        /// The max length of the value of the JWT's `iss` field supported in our circuit (e.g., `"https://accounts.google.com"`)
        ///
        /// If changed: Requires a circuit change because the `iss` field value is hashed inside the circuit as
        ///   `HashBytesToFieldWithLen(MAX_ISS_VALUE_LEN)(iss_value, iss_value_len)` where `MAX_ISS_VALUE_LEN` is a
        ///   circuit constant hard-coded to `max_iss_val_bytes` (i.e., to 120) => prover service redeployment..
        max_iss_val_bytes: u16,

        /// The max length of the JWT field name and value (e.g., `"max_age":"18"`) supported in our circuit
        ///
        /// If changed: Requires a circuit change because the extra field key-value pair is hashed inside the circuit as
        ///   `HashBytesToFieldWithLen(MAX_EXTRA_FIELD_KV_PAIR_LEN)(extra_field, extra_field_len)` where
        ///   `MAX_EXTRA_FIELD_KV_PAIR_LEN` is a circuit constant hard-coded to `max_extra_field_bytes` (i.e., to 350)
        ///    => prover service redeployment.
        max_extra_field_bytes: u16,

        /// The max length of the base64url-encoded JWT header in bytes supported in our circuit.
        ///
        /// If changed: Requires a circuit change because the JWT header is hashed inside the circuit as
        ///   `HashBytesToFieldWithLen(MAX_B64U_JWT_HEADER_W_DOT_LEN)(b64u_jwt_header_w_dot, b64u_jwt_header_w_dot_len)`
        ///   where `MAX_B64U_JWT_HEADER_W_DOT_LEN` is a circuit constant hard-coded to `max_jwt_header_b64_bytes`
        ///   (i.e., to 350) => prover service redeployment.
        max_jwt_header_b64_bytes: u32,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L269-277)
```text
    /// Queues up a change to the keyless configuration. The change will only be effective after reconfiguration. Only
    /// callable via governance proposal.
    ///
    /// WARNING: A malicious `Configuration` could lead to DoS attacks, create liveness issues, or enable a malicious
    /// recovery service provider to phish users' accounts.
    public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Configuration>(config);
    }
```
