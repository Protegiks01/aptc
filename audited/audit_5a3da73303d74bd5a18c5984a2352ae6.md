# Audit Report

## Title
Resource Group Partial Initialization Allows Transactions to Proceed with Incorrect Empty State

## Summary
The `set_raw_base_values` function in `VersionedGroupData` creates a group_sizes entry before validating tag serialization, allowing a partial initialization state that causes subsequent transactions to read empty values instead of actual storage data, violating deterministic execution invariants.

## Finding Description
The vulnerability exists in the parallel execution path's resource group initialization logic. When `set_raw_base_values` is called, it creates an entry in the `group_sizes` DashMap before performing tag serialization validation. [1](#0-0) 

If tag serialization fails during `group_size_as_sum` calculation, the function returns an error: [2](#0-1) 

However, the `group_sizes` entry created at line 155 remains in the DashMap with default (empty) state. This breaks the initialization check used in `fetch_tagged_data_no_record`: [3](#0-2) 

The check returns `true` even though no actual data was initialized. This causes `convert_tagged_data` to return `MVGroupError::TagNotFound` instead of `MVGroupError::Uninitialized`: [4](#0-3) 

When `TagNotFound` is returned, the handler assumes the group is properly initialized and writes an empty value: [5](#0-4) 

This allows the transaction to proceed with empty resource values instead of failing or loading the correct storage values, violating the **Deterministic Execution** and **State Consistency** invariants.

## Impact Explanation
This is a **High Severity** issue per Aptos bug bounty criteria because it causes:

1. **State Inconsistency**: Different nodes may observe different resource group states depending on whether they encountered the initialization failure
2. **Consensus Violations**: Validators executing the same transaction may produce different state roots if some hit the error path while others don't
3. **Protocol Violation**: Transactions proceed with incorrect (empty) state instead of actual storage values

The impact is limited to scenarios where tag serialization fails (BCS size limits, malformed tags, or BCS library edge cases), but when triggered, it breaks fundamental blockchain invariants.

## Likelihood Explanation
The likelihood is **Medium** because:

1. **Trigger Condition**: Requires tag serialization failure via `bcs::serialized_size`, which the code explicitly handles as a possible error with `UNEXPECTED_DESERIALIZATION_ERROR` status
2. **Attack Surface**: Any transaction accessing resource groups with edge-case tags (deeply nested type parameters, maximum-length identifiers, or BCS limit violations) could trigger this
3. **Persistence**: Once triggered, the corrupted state persists in the MVHashMap for all subsequent accesses within that block
4. **No Cleanup**: There is no error recovery or cleanup mechanism to remove the partially-initialized entry

## Recommendation
Implement atomic initialization by deferring the `group_sizes` entry creation until after all validation succeeds:

```rust
pub fn set_raw_base_values(
    &self,
    group_key: K,
    base_values: Vec<(T, V)>,
) -> anyhow::Result<()> {
    // Calculate size FIRST before modifying any state
    let group_size = group_size_as_sum::<T>(
        base_values
            .iter()
            .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
    )
    .map_err(|e| {
        anyhow!(
            "Tag serialization error in resource group at {:?}: {:?}",
            group_key.clone(),
            e
        )
    })?;
    
    // Only create entry after validation succeeds
    let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();
    
    if let Vacant(entry) = group_sizes.size_entries.entry(ShiftedTxnIndex::zero_idx()) {
        entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));
        
        let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
        for (tag, value) in base_values.into_iter() {
            superset_tags.insert(tag.clone());
            self.values.set_base_value(
                (group_key.clone(), tag),
                ValueWithLayout::RawFromStorage(Arc::new(value)),
            );
        }
    }
    
    Ok(())
}
```

Note: The sequential execution path (UnsyncMap) does not have this vulnerability as it performs validation before state modification. [6](#0-5) 

## Proof of Concept

```rust
#[test]
fn test_partial_initialization_state_corruption() {
    use aptos_move::mvhashmap::VersionedGroupData;
    use move_core_types::account_address::AccountAddress;
    
    // Create a VersionedGroupData instance
    let group_data = VersionedGroupData::<StateKey, StructTag, TestValue>::empty();
    let group_key = StateKey::access_path(/* resource group key */);
    
    // Create base values with a tag that will cause serialization failure
    // (e.g., extremely nested type parameters exceeding BCS limits)
    let malicious_tag = create_deeply_nested_struct_tag(1000); // Exceeds BCS nesting
    let base_values = vec![(malicious_tag, TestValue::new())];
    
    // First transaction: attempt initialization (will fail at tag serialization)
    let init_result = group_data.set_raw_base_values(group_key.clone(), base_values);
    assert!(init_result.is_err()); // Serialization fails
    
    // Verify partial state: group_sizes entry exists but is empty
    assert!(group_data.group_sizes.contains_key(&group_key)); // TRUE - entry exists
    assert!(group_data.group_tags.get(&group_key).is_none()); // No tags initialized
    
    // Second transaction: read from the group
    let read_result = group_data.fetch_tagged_data_no_record(
        &group_key,
        &valid_tag,
        0, // txn_idx
    );
    
    // Expected: MVGroupError::Uninitialized (because group isn't actually initialized)
    // Actual: MVGroupError::TagNotFound (because group_sizes entry exists)
    assert_eq!(read_result.unwrap_err(), MVGroupError::TagNotFound);
    
    // This triggers the TagNotFound handler which writes empty values
    // Transaction proceeds with incorrect state instead of actual storage values
    // CONSENSUS VIOLATION: Different nodes may see different states
}
```

**Notes**

While the security question specifically referenced `unsync_map.rs:127`, the actual vulnerability exists in the parallel execution path (`versioned_group_data.rs:150-186`). The UnsyncMap implementation correctly validates before state modification and does not exhibit this vulnerability. However, since parallel execution is the primary mode for block processing in Aptos, the VersionedGroupData vulnerability has broader impact on consensus and state consistency.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L155-155)
```rust
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L160-171)
```rust
            let group_size = group_size_as_sum::<T>(
                base_values
                    .iter()
                    .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
            )
            .map_err(|e| {
                anyhow!(
                    "Tag serialization error in resource group at {:?}: {:?}",
                    group_key.clone(),
                    e
                )
            })?;
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L429-429)
```rust
        let initialized = self.group_sizes.contains_key(group_key);
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L683-684)
```rust
            Err(MVDataError::Uninitialized) => Err(if initialized {
                MVGroupError::TagNotFound
```

**File:** aptos-move/block-executor/src/view.rs (L815-827)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
```

**File:** aptos-move/mvhashmap/src/unsync_map.rs (L128-143)
```rust
        let base_map: HashMap<T, ValueWithLayout<V>> = base_values
            .into_iter()
            .map(|(t, v)| (t, ValueWithLayout::RawFromStorage(TriompheArc::new(v))))
            .collect();
        let base_size = group_size_as_sum(
            base_map
                .iter()
                .flat_map(|(t, v)| v.bytes_len().map(|s| (t, s))),
        )
        .map_err(|e| {
            anyhow!(
                "Tag serialization error in resource group at {:?}: {:?}",
                group_key.clone(),
                e
            )
        })?;
```
