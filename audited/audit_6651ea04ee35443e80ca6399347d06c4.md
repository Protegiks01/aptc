# Audit Report

## Title
Atomic Operation Race Condition in DataManager Causes Premature Cache Eviction and Data Loss

## Summary
A race condition exists in the `DataManager` where concurrent modifications to the `file_store_version` atomic variable through `fetch_add` and `fetch_max` operations can cause the version counter to become incorrectly inflated. This leads to premature garbage collection of cached transactions that have not yet been persisted to the file store, resulting in data unavailability for indexer clients.

## Finding Description
The vulnerability stems from two concurrent atomic operations on `Cache.file_store_version` that execute while holding only READ locks on the cache:

1. **Operation A**: The `cache.get_transactions()` method increments `file_store_version` using `fetch_add()` when transactions are retrieved by the FileStoreUploader [1](#0-0) 

2. **Operation B**: The `update_file_store_version_in_cache()` method updates `file_store_version` to match the actual file store using `fetch_max()` [2](#0-1) 

Both operations are called while holding only a read lock [3](#0-2)  and [4](#0-3) , which allows them to execute concurrently since RwLock permits multiple concurrent readers.

**Attack Scenario:**
1. Cache contains transactions [100-200], `start_version=100`, `file_store_version=100`
2. Actual file store has transactions up to version 180
3. **Thread A** (FileStoreUploader): Calls `get_transactions_from_cache(100, ..., true)`, acquires read lock, retrieves transactions [100-150], prepares to execute `fetch_add(50)`
4. **Thread B** (DataManager.start loop): Calls `update_file_store_version_in_cache()`, acquires concurrent read lock, reads actual file store version = 180, prepares to execute `fetch_max(180)`
5. Operations execute in this order:
   - `fetch_max(180)`: 100 → 180
   - `fetch_add(50)`: 180 → 230
6. Result: `file_store_version = 230`, but actual persisted data only reaches version 180
7. **Thread C** (next GC cycle): Calls `maybe_gc()` with write lock [5](#0-4) 
8. GC logic sees `start_version=100 < file_store_version=230` and removes transactions [100-200] from cache
9. Transactions [180-200] are now lost (not in cache, not in file store)
10. Client requests for versions [180-200] fail, causing indexer service degradation

The `file_store_version` atomic is accessed from multiple code paths [6](#0-5) , and the GC logic relies on it being accurate [7](#0-6) .

## Impact Explanation
This qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category. The indexer loses transaction data that cannot be recovered from either cache or file store, requiring manual intervention to restore service. While this doesn't affect blockchain consensus or fund security, it causes:

- **Data Loss**: Transactions in the gap between actual file store version and inflated `file_store_version` are permanently lost from the indexer
- **Service Degradation**: Clients requesting transactions in the lost range receive empty responses, breaking indexer functionality
- **Cascading Failures**: Downstream services depending on complete transaction history may malfunction

The vulnerability is in production code serving real indexer traffic, affecting indexer availability which is critical infrastructure for ecosystem tools, wallets, and explorers.

## Likelihood Explanation
**Likelihood: High**

The race window is narrow but the conditions occur naturally during normal operation:
- The FileStoreUploader continuously fetches transactions from cache (lines 147-177 in file_store_uploader.rs) [8](#0-7) 
- The DataManager.start() loop periodically updates file store version [9](#0-8) 
- Both paths execute continuously in high-throughput scenarios
- No special conditions or attacker involvement required - this is a natural race during concurrent normal operation

## Recommendation
The root cause is modifying `file_store_version` while holding only a read lock. The fix requires either:

**Option 1 (Recommended)**: Move `file_store_version` updates to write-lock-protected sections:
```rust
// In get_transactions_from_cache for update_file_store_version=true path:
pub(crate) async fn get_transactions_from_cache(
    &self,
    start_version: u64,
    max_size: usize,
    update_file_store_version: bool,
) -> Vec<Transaction> {
    if update_file_store_version {
        // Use write lock when updating file_store_version
        let mut cache = self.cache.write().await;
        let transactions = cache.get_transactions(start_version, max_size, false);
        if !transactions.is_empty() {
            cache.file_store_version.fetch_add(transactions.len() as u64, Ordering::SeqCst);
        }
        transactions
    } else {
        self.cache.read().await.get_transactions(start_version, max_size, false)
    }
}
```

**Option 2**: Use a separate mutex specifically for `file_store_version` updates to serialize the `fetch_add` and `fetch_max` operations.

**Option 3**: Remove the `fetch_add` mechanism entirely and only update `file_store_version` from the actual file store reader, eliminating the race.

## Proof of Concept
```rust
// Reproduction test (add to data_manager.rs test module)
#[tokio::test]
async fn test_file_store_version_race() {
    use std::sync::{Arc, atomic::{AtomicU64, Ordering}};
    use tokio::sync::RwLock;
    
    let file_store_version = Arc::new(AtomicU64::new(100));
    let cache = Arc::new(RwLock::new(()));
    
    // Simulate FileStoreUploader fetch_add
    let fsv1 = file_store_version.clone();
    let cache1 = cache.clone();
    let handle1 = tokio::spawn(async move {
        let _lock = cache1.read().await;
        // Simulate work
        tokio::time::sleep(std::time::Duration::from_millis(1)).await;
        fsv1.fetch_add(50, Ordering::SeqCst)
    });
    
    // Simulate update_file_store_version_in_cache fetch_max
    let fsv2 = file_store_version.clone();
    let cache2 = cache.clone();
    let handle2 = tokio::spawn(async move {
        let _lock = cache2.read().await;
        // Simulate work
        tokio::time::sleep(std::time::Duration::from_millis(1)).await;
        fsv2.fetch_max(180, Ordering::SeqCst)
    });
    
    handle1.await.unwrap();
    handle2.await.unwrap();
    
    let final_version = file_store_version.load(Ordering::SeqCst);
    // Expected: 180 (from fetch_max)
    // Actual: Could be 230 (if fetch_max then fetch_add)
    println!("Final version: {}", final_version);
    assert!(final_version == 180 || final_version == 230, 
            "Race condition demonstrated: version = {}", final_version);
}
```

To observe in production: Enable debug logging and monitor for cases where `file_store_version` exceeds the actual file store version returned by `file_store_reader.get_latest_version()`, followed by cache GC removing transactions that haven't been persisted.

## Notes
This vulnerability is specific to the indexer-grpc infrastructure and does not affect core blockchain consensus, validator operations, or on-chain fund security. However, it represents a significant reliability issue for the indexer service which is critical infrastructure for ecosystem applications.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L35-43)
```rust
struct Cache {
    start_version: u64,
    file_store_version: AtomicU64,
    transactions: VecDeque<Transaction>,
    cache_size: usize,

    max_cache_size: usize,
    target_cache_size: usize,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L63-80)
```rust
    fn maybe_gc(&mut self) -> bool {
        if self.cache_size <= self.max_cache_size {
            return true;
        }

        while self.start_version < self.file_store_version.load(Ordering::SeqCst)
            && self.cache_size > self.target_cache_size
        {
            let transaction = self.transactions.pop_front().unwrap();
            self.cache_size -= transaction.encoded_len();
            self.start_version += 1;
        }

        CACHE_SIZE.set(self.cache_size as i64);
        CACHE_START_VERSION.set(self.start_version as i64);

        self.cache_size <= self.max_cache_size
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L127-135)
```rust
        if update_file_store_version {
            if !transactions.is_empty() {
                let old_version = self
                    .file_store_version
                    .fetch_add(transactions.len() as u64, Ordering::SeqCst);
                let new_version = old_version + transactions.len() as u64;
                FILE_STORE_VERSION_IN_CACHE.set(new_version as i64);
                info!("Updated file_store_version in cache to {new_version}.");
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L201-205)
```rust
            if watch_file_store_version {
                self.update_file_store_version_in_cache(
                    &cache, /*version_can_go_backward=*/ false,
                )
                .await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L380-383)
```rust
        self.cache
            .read()
            .await
            .get_transactions(start_version, max_size, update_file_store_version)
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L403-406)
```rust
    async fn update_file_store_version_in_cache(
        &self,
        cache: &RwLockReadGuard<'_, Cache>,
        version_can_go_backward: bool,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L410-413)
```rust
            let file_store_version_before_update = cache
                .file_store_version
                .fetch_max(file_store_version, Ordering::SeqCst);
            FILE_STORE_VERSION_IN_CACHE.set(file_store_version as i64);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L157-163)
```rust
                        data_manager
                            .get_transactions_from_cache(
                                next_version,
                                MAX_SIZE_PER_FILE,
                                /*update_file_store_version=*/ true,
                            )
                            .await
```
