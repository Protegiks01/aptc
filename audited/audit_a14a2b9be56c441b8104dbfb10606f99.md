# Audit Report

## Title
Stack Overflow DoS via Deeply Nested Transaction Arguments in Entry Function Validation

## Summary
The transaction argument validation code in `recursively_construct_arg` lacks depth limits for nested vectors, allowing attackers to crash validator nodes by submitting transactions with extremely deep nesting levels (e.g., `vector<vector<vector<...>>>` with thousands of levels). This vulnerability exists independently of the `max_value_nest_depth()` configuration and affects all Aptos deployments. [1](#0-0) 

## Finding Description

While investigating the `max_value_nest_depth()` function's None handling, I discovered a more critical vulnerability in the transaction validation code path. The `recursively_construct_arg` function validates and constructs transaction arguments during entry function validation but only enforces a limit on struct constructor invocations (`max_invocations = 10`), not on general nesting depth for vectors or other recursive structures. [2](#0-1) 

**Attack Vector:**
1. Attacker crafts a transaction calling an entry function that accepts `vector<vector<...>>` arguments
2. The attacker nests the vectors to extreme depth (e.g., 10,000+ levels)
3. During `validate_signed_transaction`, the VM calls `construct_args` → `construct_arg` → `recursively_construct_arg`
4. The function recurses at lines 350-362 for each vector nesting level without checking total depth
5. Stack overflow occurs, crashing the validator process [3](#0-2) 

**Additional Context - Original Question:**

The `max_value_nest_depth()` function returns None when `enable_depth_checks` is false or `max_value_nest_depth` is None: [4](#0-3) 

However, this configuration-dependent issue is overshadowed by the transaction validation vulnerability, which exists regardless of configuration. Furthermore, I found that deserialization does not track depth even when `max_value_nested_depth` is set—the `DeserializationSeed` struct lacks a depth field entirely: [5](#0-4) 

In contrast, serialization properly tracks and checks depth: [6](#0-5) 

## Impact Explanation

This is a **High Severity** DoS vulnerability per Aptos bug bounty criteria:
- **Validator node crashes**: Attackers can crash any validator node by submitting malicious transactions
- **Network disruption**: If multiple validators process the same malicious transaction, multiple nodes crash simultaneously  
- **No authentication required**: Any transaction sender can exploit this
- **Pre-execution crash**: Occurs during validation phase, before gas payment or execution

This violates the **Move VM Safety** invariant: "Bytecode execution must respect gas limits and memory constraints" - the validation code exhausts stack memory before execution even begins.

## Likelihood Explanation

**Likelihood: High**
- Trivial to exploit - only requires crafting deeply nested BCS-encoded vectors
- No special permissions required - any transaction sender can attempt
- Affects transaction validation path, executed by all validators
- No rate limiting or protection mechanisms in place
- Works against all Aptos configurations regardless of feature flags

## Recommendation

Add explicit depth tracking and validation to `recursively_construct_arg`:

```rust
pub(crate) fn recursively_construct_arg(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    ty: &Type,
    allowed_structs: &ConstructorMap,
    cursor: &mut Cursor<&[u8]>,
    initial_cursor_len: usize,
    max_invocations: &mut u64,
    arg: &mut Vec<u8>,
    depth: u64,  // ADD THIS PARAMETER
    max_depth: u64,  // ADD THIS PARAMETER
) -> Result<(), VMStatus> {
    // ADD DEPTH CHECK
    if depth > max_depth {
        return Err(VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            Some("Transaction argument nesting depth exceeds limit".to_string()),
        ));
    }
    
    use move_vm_types::loaded_data::runtime_types::Type::*;
    match ty {
        Vector(inner) => {
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session, loader, gas_meter, traversal_context,
                    inner, allowed_structs, cursor, initial_cursor_len,
                    max_invocations, arg,
                    depth + 1, max_depth,  // INCREMENT DEPTH
                )?;
                len -= 1;
            }
        },
        // ... rest of match arms with depth + 1 for recursive calls
    }
    Ok(())
}
```

Initialize with `depth = 0` and `max_depth = DEFAULT_MAX_VM_VALUE_NESTED_DEPTH` (128) at the entry point.

## Proof of Concept

```rust
// PoC: Create a deeply nested vector argument to crash validator during validation
use move_core_types::account_address::AccountAddress;
use aptos_types::transaction::{EntryFunction, TransactionPayload, Script, TransactionArgument};

fn create_deeply_nested_vector(depth: usize) -> Vec<u8> {
    let mut result = vec![1u8]; // innermost vector with one element
    
    for _ in 0..depth {
        let mut outer = Vec::new();
        // BCS encoding: vector length (1) + inner content
        outer.push(1u8); // length = 1
        outer.extend_from_slice(&result);
        result = outer;
    }
    result
}

#[test]
fn test_stack_overflow_via_nested_vectors() {
    // Create transaction with 10,000-level nested vector argument
    let deeply_nested_arg = create_deeply_nested_vector(10000);
    
    let payload = TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(AccountAddress::ONE, Identifier::new("test").unwrap()),
        Identifier::new("entry_fn_with_vector_arg").unwrap(),
        vec![],
        vec![deeply_nested_arg], // This will cause stack overflow during validation
    ));
    
    // When this transaction is validated via validate_signed_transaction,
    // recursively_construct_arg will recurse 10,000 times and crash with stack overflow
}
```

**Notes:**
- The vulnerability exists in the transaction argument validation path, not the main VM execution path
- The original security question about `max_value_nest_depth()` returning None is a valid concern for misconfigured deployments, but this transaction validation issue is more critical as it affects all configurations
- Production Aptos has `enable_depth_checks = true` when function values are enabled, so the None scenario shouldn't occur in production [7](#0-6) 
- However, deserialization lacks depth checks entirely, which is a separate latent vulnerability

### Citations

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L289-289)
```rust
            let mut max_invocations = 10; // Read from config in the future
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L327-404)
```rust
// A Cursor is used to recursively walk the serialized arg manually and correctly. In effect we
// are parsing the BCS serialized implicit constructor invocation tree, while serializing the
// constructed types into the output parameter arg.
pub(crate) fn recursively_construct_arg(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    ty: &Type,
    allowed_structs: &ConstructorMap,
    cursor: &mut Cursor<&[u8]>,
    initial_cursor_len: usize,
    max_invocations: &mut u64,
    arg: &mut Vec<u8>,
) -> Result<(), VMStatus> {
    use move_vm_types::loaded_data::runtime_types::Type::*;

    match ty {
        Vector(inner) => {
            // get the vector length and iterate over each element
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                )?;
                len -= 1;
            }
        },
        Struct { .. } | StructInstantiation { .. } => {
            let (module_id, identifier) = loader
                .runtime_environment()
                .get_struct_name(ty)
                .map_err(|_| {
                    // Note: The original behaviour was to map all errors to an invalid signature
                    //       error, here we want to preserve it for now.
                    invalid_signature()
                })?
                .ok_or_else(invalid_signature)?;
            let full_name = format!("{}::{}", module_id.short_str_lossless(), identifier);
            let constructor = allowed_structs
                .get(&full_name)
                .ok_or_else(invalid_signature)?;
            // By appending the BCS to the output parameter we construct the correct BCS format
            // of the argument.
            arg.append(&mut validate_and_construct(
                session,
                loader,
                gas_meter,
                traversal_context,
                ty,
                constructor,
                allowed_structs,
                cursor,
                initial_cursor_len,
                max_invocations,
            )?);
        },
        Bool | U8 | I8 => read_n_bytes(1, cursor, arg)?,
        U16 | I16 => read_n_bytes(2, cursor, arg)?,
        U32 | I32 => read_n_bytes(4, cursor, arg)?,
        U64 | I64 => read_n_bytes(8, cursor, arg)?,
        U128 | I128 => read_n_bytes(16, cursor, arg)?,
        U256 | I256 | Address => read_n_bytes(32, cursor, arg)?,
        Signer | Reference(_) | MutableReference(_) | TyParam(_) | Function { .. } => {
            return Err(invalid_signature())
        },
    };
    Ok(())
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L581-587)
```rust
    fn max_value_nest_depth(&self) -> Option<u64> {
        let vm_config = self.module_storage.runtime_environment().vm_config();
        vm_config
            .enable_depth_checks
            .then_some(vm_config.max_value_nest_depth)
            .flatten()
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4838-4838)
```rust
        self.ctx.check_depth(self.depth).map_err(S::Error::custom)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5085-5090)
```rust
pub(crate) struct DeserializationSeed<'c, L> {
    // Holds extensions external to the deserializer.
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    // Layout to guide deserialization.
    pub(crate) layout: L,
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L227-227)
```rust
    let enable_depth_checks = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
```
