# Audit Report

## Title
Module Publishing Race Condition Causes Non-Deterministic Execution Across Validators

## Summary
A race condition exists between module publishing and transaction validation in the BlockSTM parallel executor. The two-step module publishing process (insert into per-block cache, then mark as overridden in global cache) is not atomic relative to concurrent validations. This allows different validators to observe different interleavings of these operations, leading to different validation outcomes and ultimately different execution results for the same block, violating consensus safety.

## Finding Description

The vulnerability exists in the module publishing mechanism during parallel block execution. When a transaction publishes a module, the operation consists of two non-atomic steps: [1](#0-0) 

Step 1 inserts the module into the per-block cache, and Step 2 marks the module as overridden in the global cache. These steps are not atomic relative to concurrent validation operations running on other worker threads.

During parallel execution, when a transaction commits and publishes modules: [2](#0-1) 

The validation of other transactions can execute concurrently on different worker threads: [3](#0-2) 

Module validation checks if a module is still not overridden: [4](#0-3) 

**Attack Scenario:**
1. Transaction T1 (index 1) executes and reads module M from global cache (not overridden)
2. T1 captures this read and finishes execution
3. Transaction T0 (index 0) commits on Worker A and begins publishing module M
4. Worker A inserts M into per-block cache with version 0
5. **Worker B concurrently validates T1** and checks if M is overridden
6. Worker B loads the atomic `overridden` flag with Acquire ordering - sees `false` (not yet marked)
7. **T1's validation incorrectly PASSES** - T1 proceeds with old module M
8. Worker A marks M as overridden in global cache
9. T1 is committed with output based on old module M

Due to thread scheduling non-determinism, different validators may observe different interleavings:
- **Validator A**: T1 validates between steps 4-8 → validation passes → T1 uses old M
- **Validator B**: T1 validates after step 8 → validation fails → T1 re-executes with new M

This produces different execution results (different state roots) across validators for the same ordered block.

## Impact Explanation

**Severity: Critical** (Consensus/Safety Violation)

This violates the fundamental **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks." Different validators will compute different state roots for the same block, causing:

1. **Consensus Failure**: Validators cannot reach agreement on block state
2. **Chain Split**: Network partitions into validators with different state roots
3. **Non-Recoverable**: Requires manual intervention or hardfork to resolve
4. **Affects All Nodes**: All validators executing blocks with module publications are vulnerable

The vulnerability requires no special privileges - any user publishing a module can trigger the race condition through normal transaction execution.

## Likelihood Explanation

**Likelihood: High**

- Module publications are common operations in Aptos
- Parallel execution is enabled by default for performance
- The race window occurs on every module publication during parallel execution
- Thread scheduling is inherently non-deterministic across different validator hardware
- No special timing or coordination required from attacker
- Happens naturally during normal block processing with concurrent transactions

The race becomes more likely with:
- Higher transaction throughput (more concurrent workers)
- Blocks containing module publications and dependent transactions
- Validators with different CPU counts or loads

## Recommendation

Make module publishing atomic relative to validations by ensuring the per-block cache insert and global cache override marking happen under the same critical section that validations must synchronize with.

**Option 1: Extend validation synchronization**
Ensure validations acquire proper synchronization before checking module override status, or ensure publishing completes atomically before any validation can observe the intermediate state.

**Option 2: Atomic combined operation**
Combine the per-block cache insertion and override marking into a single atomic operation that validations observe as indivisible.

**Option 3: Validation barriers**
Introduce a memory barrier or synchronization point that ensures all module publishing operations complete before any validation can check override status.

The fix should ensure that if a validation observes a module in the per-block cache, it must also observe the overridden flag set in the global cache, preventing the race condition.

## Proof of Concept

A PoC would require a Rust test that:

1. Creates a block with two transactions:
   - T0: Publishes module M
   - T1: Uses module M
2. Executes the block in parallel with multiple workers
3. Instruments the code to introduce artificial delays between per-block cache insertion and override marking
4. Observes that T1's validation can pass or fail depending on timing
5. Demonstrates different execution results on different runs

The test would need to be written in Rust with thread synchronization primitives to reliably reproduce the race window, as the natural occurrence depends on thread scheduling timing.

## Notes

The vulnerability stems from the design decision to split module publishing into two steps for performance, without ensuring atomicity relative to concurrent validations. The atomic boolean operations (Release/Acquire ordering) provide correct memory ordering but do not prevent the race - a validation can correctly observe the old value if it executes before the store completes.

This is particularly critical because validators may have different hardware configurations (CPU counts, speeds), leading to systematically different interleavings and consistently divergent execution results rather than occasional random failures.

### Citations

**File:** aptos-move/block-executor/src/code_cache_global.rs (L300-318)
```rust
    per_block_module_cache
        .insert_deserialized_module(
            write.module_id().clone(),
            compiled_module,
            extension,
            Some(txn_idx),
        )
        .map_err(|err| {
            let msg = format!(
                "Failed to insert code for module {}::{} at version {} to module cache: {:?}",
                write.module_address(),
                write.module_name(),
                txn_idx,
                err
            );
            PanicError::CodeInvariantError(msg)
        })?;
    global_module_cache.mark_overridden(write.module_id());
    Ok(())
```

**File:** aptos-move/block-executor/src/executor.rs (L1043-1057)
```rust
        // Publish modules before we decrease validation index (in V1) so that validations observe
        // the new module writes as well.
        if last_input_output.publish_module_write_set(
            txn_idx,
            global_module_cache,
            versioned_cache,
            runtime_environment,
            &scheduler,
        )? {
            side_effect_at_commit = true;
        }

        if side_effect_at_commit {
            scheduler.wake_dependencies_and_decrease_validation_idx(txn_idx)?;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1365-1373)
```rust
            scheduler_task = match scheduler_task {
                SchedulerTask::ValidationTask(txn_idx, incarnation, wave) => {
                    let valid = Self::validate(
                        txn_idx,
                        last_input_output,
                        global_module_cache,
                        versioned_cache,
                        skip_module_reads_validation.load(Ordering::Relaxed),
                    );
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1067)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };
```
