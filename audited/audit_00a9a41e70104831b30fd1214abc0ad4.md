# Audit Report

## Title
Race Condition in Asynchronous OIDC Provider Removal During DKG Reconfiguration

## Summary
A race condition exists during DKG-based epoch transitions where a governance proposal to remove a compromised OIDC provider is undermined. The provider removal is buffered (asynchronous) while JWKs are immediately removed, but validators continue watching the provider during the DKG window and can re-add malicious JWKs before the provider is fully removed.

## Finding Description

The vulnerability stems from inconsistent timing models for OIDC provider removal during DKG reconfiguration. The system uses two different approaches:

**Asynchronous Provider Removal**: The `remove_oidc_provider_for_next_epoch()` function uses a config buffer pattern where changes are staged but only applied when `on_new_epoch()` is called. [1](#0-0) 

**Synchronous JWK Removal**: The `remove_issuer_from_observed_jwks()` function immediately removes JWKs from the global `ObservedJWKs` resource and regenerates `PatchedJWKs`. [2](#0-1) 

**DKG Timing Issue**: When DKG is enabled, `aptos_governance::reconfigure()` calls `reconfiguration_with_dkg::try_start()` which starts DKG but does NOT immediately trigger the epoch change. [3](#0-2)  The epoch only changes when `finish()` is called after DKG completes. [4](#0-3) 

**Validator Behavior**: Validators read `SupportedOIDCProviders` from on-chain state at epoch start and spawn JWK observers for each provider. [5](#0-4)  These observers continue watching throughout the epoch. [6](#0-5) 

**Missing Validation**: The `upsert_into_observed_jwks()` function has no check to prevent updates during DKG or for providers being removed. [7](#0-6)  Validator transaction verification also lacks such checks. [8](#0-7) 

**Authentication Impact**: Updated JWKs immediately flow to `PatchedJWKs` (line 504 in jwks.move), which is used for transaction authentication. [9](#0-8) 

**Attack Flow**:
1. Governance executes removal proposal: buffers provider removal, immediately removes JWKs, starts DKG
2. During DKG window (minutes): validators still in old epoch, continue watching based on old provider list
3. Attacker publishes malicious JWKs at compromised provider
4. Validators observe, reach consensus, call `upsert_into_observed_jwks()`
5. Malicious JWKs re-added to `ObservedJWKs` and `PatchedJWKs`
6. Transactions authenticated using malicious JWKs until DKG completes

## Impact Explanation

This constitutes a **MEDIUM to HIGH severity** vulnerability representing a **Limited Protocol Violation**:

- **Authentication Bypass Window**: During the DKG window (potentially several minutes), a compromised OIDC provider that governance explicitly tried to remove can have its JWKs re-introduced, allowing unauthorized transaction authentication
- **Governance Intent Violation**: The system fails to enforce governance's security decision during the transition period
- **State Consistency Violation**: The system enters an inconsistent state where `SupportedOIDCProviders` (what validators watch) and `ObservedJWKs` (what authenticates transactions) diverge from governance intent

While this doesn't directly enable fund theft or consensus violations (Critical severity), it creates a time-bounded window where the authentication system's security posture is compromised, violating transaction validation invariants.

## Likelihood Explanation

**Likelihood: MODERATE**

The attack is feasible but requires specific timing:

1. **Triggering condition**: OIDC provider compromises requiring rapid governance response (realistic but not common)
2. **Attack window**: DKG duration provides minutes for exploitation (substantial)
3. **No special privileges**: Only requires control of the compromised OIDC provider
4. **Automatic execution**: Validators automatically watch and propose updates
5. **Timing requirement**: Requires provider removal during an active DKG reconfiguration (reduces likelihood from HIGH to MODERATE)

## Recommendation

Add validation to prevent JWK updates for providers during removal:

1. **In `upsert_into_observed_jwks()`**: Check if the provider exists in the current `SupportedOIDCProviders` or if a removal is buffered in `config_buffer`
2. **In validator transaction processing**: Verify the issuer is in the active provider list before accepting updates
3. **Alternative**: Synchronize provider removal with JWK removal by applying both changes in `on_new_epoch()`, or add a flag to mark providers as "removal pending" during the DKG window

## Proof of Concept

A complete PoC would require:
1. Setting up a testnet with DKG enabled
2. Deploying a test OIDC provider
3. Submitting a governance proposal to remove it
4. Publishing new JWKs during the DKG window
5. Verifying the JWKs are re-added to `PatchedJWKs`

The vulnerability can be validated by code inspection tracing the execution paths documented above through the confirmed file citations.

**Notes**

This vulnerability arises from the asynchronous nature of DKG reconfiguration creating a temporal inconsistency between governance intent and system state. The issue is specific to the DKG reconfiguration path and does not affect synchronous reconfigurations. The impact is time-bounded (limited to the DKG duration) but allows authentication bypass that governance explicitly tried to prevent.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L352-363)
```text
    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };
        let ret = remove_oidc_provider_internal(&mut provider_set, name);
        config_buffer::upsert(provider_set);
        ret
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-195)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
        };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-179)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;

        // All verification passed. Apply the `observed`.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            vec![observed].as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;

        let output = get_system_transaction_output(
            session,
            module_storage,
            &self
                .storage_gas_params(log_context)
                .map_err(Unexpected)?
                .change_set_configs,
        )
        .map_err(Unexpected)?;

        Ok((VMStatus::Executed, output))
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-237)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;

    let training_wheels_pk = match &config.training_wheels_pubkey {
        None => None,
        // This takes ~4.4 microseconds, so we are not too concerned about speed here.
        // (Run `cargo bench -- ed25519/pk_deserialize` in `crates/aptos-crypto`.)
        Some(bytes) => Some(EphemeralPublicKey::ed25519(
            Ed25519PublicKey::try_from(bytes.as_slice()).map_err(|_| {
                // println!("[aptos-vm][groth16] On chain TW PK is invalid");

                invalid_signature!("The training wheels PK set on chain is not a valid PK")
            })?,
        )),
    };

    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
```
