# Audit Report

## Title
Version Mismatch Vulnerability Between Client Code and On-Chain large_packages Module

## Summary
The Rust client code in `chunked_publish.rs` hardcodes function names and signatures for the on-chain `large_packages` Move module without any version checking or compatibility verification. If the on-chain module is upgraded with modified function signatures, old clients will experience transaction failures, gas loss, and potential state inconsistencies.

## Finding Description
The chunked package publishing system lacks a version negotiation mechanism between client code and the on-chain `large_packages` module. The client hardcodes function calls with fixed signatures: [1](#0-0) [2](#0-1) [3](#0-2) 

When transactions are submitted, the VM validates entry function signatures at runtime: [4](#0-3) 

If the on-chain module is upgraded with different function signatures (e.g., adding/removing parameters, changing types, or renaming functions), old clients will fail with errors like `NUMBER_OF_ARGUMENTS_MISMATCH`, `INVALID_MAIN_FUNCTION_SIGNATURE`, or function-not-found errors.

**Exploitation Path:**
1. The `large_packages` module gets upgraded via governance or by the module owner
2. The upgrade modifies function signatures (e.g., adds a new parameter for enhanced functionality)
3. Users running old client software attempt chunked publishing
4. Early staging transactions may succeed, but later ones fail with signature mismatch errors
5. The `StagingArea` resource is left in a partial state with incomplete data
6. Users lose gas fees on failed transactions and must manually clean up via `cleanup_staging_area` [5](#0-4) 

The system warns about non-empty staging areas but cannot prevent failures from signature mismatches. Additionally, there's an address discrepancy that could exacerbate issues - the code uses one address while documentation references another: [6](#0-5) [7](#0-6) 

## Impact Explanation
This qualifies as **Medium severity** per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: The `StagingArea` resource can be left in a partial state, requiring manual cleanup
- **Limited funds loss**: Users lose gas fees on failed transactions
- **User availability impact**: Chunked publishing becomes unavailable for old clients until they upgrade

The impact is limited because:
- No fund theft or minting occurs
- Consensus remains unaffected
- The issue is recoverable through client upgrades and manual cleanup

## Likelihood Explanation
**Medium likelihood** because:

1. **Module upgrades are possible**: The aptos-experimental framework at `0x7` is explicitly designed to be upgraded on devnet: [8](#0-7) 

2. **No version checking exists**: There is no mechanism to verify compatibility: [9](#0-8) 

3. **Old clients persist**: Users don't immediately upgrade client software, especially CLI tools

4. **Reduced on mainnet/testnet**: The production deployment is more stable, but the discrepancy between documented and actual addresses suggests deployment issues could still occur

## Recommendation
Implement a version negotiation system:

1. **Add version field to the Move module:**
```move
struct ModuleVersion has key {
    major: u64,
    minor: u64,
}
```

2. **Client-side version checking before creating payloads:**
```rust
async fn verify_module_compatibility(
    client: &Client,
    module_address: AccountAddress,
    required_major: u64,
    required_minor: u64,
) -> Result<(), CliError> {
    // Query on-chain version
    let version_resource = client.get_account_resource(
        module_address,
        "large_packages::ModuleVersion"
    ).await?;
    
    // Check compatibility (major version must match, minor can be higher)
    let (actual_major, actual_minor) = parse_version(version_resource)?;
    if actual_major != required_major {
        return Err(CliError::UnexpectedError(
            format!("Incompatible large_packages module version. Client expects {}.x, module is {}.{}", 
                required_major, actual_major, actual_minor)
        ));
    }
    Ok(())
}
```

3. **Defensive error handling in transaction submission:**
```rust
// Validate before creating payloads
verify_module_compatibility(&client, module_address, 1, 0).await?;

// Add retry logic with automatic cleanup on failure
match submit_chunked_publish_transactions(payloads, txn_options, module_address).await {
    Err(e) if is_signature_mismatch(&e) => {
        // Auto-cleanup on signature mismatch
        let cleanup_payload = large_packages_cleanup_staging_area(module_address);
        dispatch_transaction(cleanup_payload, txn_options).await?;
        Err(CliError::CommandArgumentError(
            "Module signature mismatch. Please upgrade your client.".to_string()
        ))
    },
    result => result,
}
```

## Proof of Concept

```move
// Move test demonstrating the vulnerability
#[test_only]
module 0x7::large_packages_upgrade_test {
    use std::signer;
    use 0x7::large_packages;
    use 0x1::vector;

    #[test(owner = @0x123)]
    #[expected_failure(abort_code = 0x10004, location = aptos_framework::transaction_validation)]
    fun test_version_mismatch_causes_failure(owner: &signer) {
        // Simulate: Old client creates transaction with 3 arguments
        // but upgraded module expects 4 arguments
        
        let metadata = vector[1u8, 2u8, 3u8];
        let indices = vector[0u16];
        let chunks = vector[vector[4u8, 5u8]];
        
        // This would succeed with current module
        large_packages::stage_code_chunk(owner, metadata, indices, chunks);
        
        // After module upgrade adds a new parameter, this call format fails
        // The client still sends 3 args, but module expects 4
        // Results in NUMBER_OF_ARGUMENTS_MISMATCH (0x10004)
    }
}
```

**Notes:**
- The address discrepancy between code (`0x0e1ca...`) and documentation (`0xa29df...`) should be investigated and resolved
- Version checking should be mandatory before any chunked publish operation
- Consider implementing graceful degradation or automatic client updates for critical infrastructure dependencies

### Citations

**File:** aptos-move/framework/src/chunked_publish.rs (L12-13)
```rust
pub const LARGE_PACKAGES_PROD_MODULE_ADDRESS: &str =
    "0x0e1ca3011bdd07246d4d16d909dbb2d6953a86c4735d5acf5865d962c630cce7";
```

**File:** aptos-move/framework/src/chunked_publish.rs (L120-139)
```rust
fn large_packages_stage_code_chunk(
    metadata_chunk: Vec<u8>,
    code_indices: Vec<u16>,
    code_chunks: Vec<Vec<u8>>,
    large_packages_module_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            large_packages_module_address,
            ident_str!("large_packages").to_owned(),
        ),
        ident_str!("stage_code_chunk").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_chunk).unwrap(),
            bcs::to_bytes(&code_indices).unwrap(),
            bcs::to_bytes(&code_chunks).unwrap(),
        ],
    ))
}
```

**File:** aptos-move/framework/src/chunked_publish.rs (L142-162)
```rust
fn large_packages_stage_code_chunk_and_publish_to_account(
    metadata_chunk: Vec<u8>,
    code_indices: Vec<u16>,
    code_chunks: Vec<Vec<u8>>,
    large_packages_module_address: AccountAddress,
) -> TransactionPayload {
    // TODO[Orderless]: Change this to payload v2 format.
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            large_packages_module_address,
            ident_str!("large_packages").to_owned(),
        ),
        ident_str!("stage_code_chunk_and_publish_to_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_chunk).unwrap(),
            bcs::to_bytes(&code_indices).unwrap(),
            bcs::to_bytes(&code_chunks).unwrap(),
        ],
    ))
}
```

**File:** aptos-move/framework/src/chunked_publish.rs (L187-208)
```rust
fn large_packages_stage_code_chunk_and_upgrade_object_code(
    metadata_chunk: Vec<u8>,
    code_indices: Vec<u16>,
    code_chunks: Vec<Vec<u8>>,
    code_object: AccountAddress,
    large_packages_module_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            large_packages_module_address,
            ident_str!("large_packages").to_owned(),
        ),
        ident_str!("stage_code_chunk_and_upgrade_object_code").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_chunk).unwrap(),
            bcs::to_bytes(&code_indices).unwrap(),
            bcs::to_bytes(&code_chunks).unwrap(),
            bcs::to_bytes(&code_object).unwrap(),
        ],
    ))
}
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L151-156)
```rust
    if (signer_param_cnt + args.len()) != func.param_tys().len() {
        return Err(VMStatus::error(
            StatusCode::NUMBER_OF_ARGUMENTS_MISMATCH,
            None,
        ));
    }
```

**File:** crates/aptos/src/move_tool/mod.rs (L1704-1714)
```rust
    if !is_staging_area_empty(txn_options, large_packages_module_address).await? {
        let message = format!(
            "The resource {}::large_packages::StagingArea under account {} is not empty.\
        \nThis may cause package publishing to fail if the data is unexpected. \
        \nUse the `aptos move clear-staging-area` command to clean up the `StagingArea` resource under the account.",
            large_packages_module_address, account_address,
        )
            .bold();
        println!("{}", message);
        prompt_yes_with_override("Do you want to proceed?", txn_options.prompt_options)?;
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/large_packages.move (L37-39)
```text
/// * Make sure LargePackages is deployed to your network of choice, you can currently find it both on
///   mainnet and testnet at `0xa29df848eebfe5d981f708c2a5b06d31af2be53bbd8ddc94c8523f4b903f7adb`, and
///   in 0x7 (aptos-experimental) on devnet/localnet.
```

**File:** aptos-move/aptos-release-builder/src/components/framework.rs (L35-37)
```rust
    // NOTE: This is skipping 0x7 (aptos-experimental package) which is only meant to be released
    // to devnet (or local testnet) via the genesis process and never released/upgraded in testnet
    // or mainnet.
```

**File:** crates/aptos/src/common/types.rs (L2683-2706)
```rust
impl LargePackagesModuleOption {
    pub(crate) async fn large_packages_module_address(
        &self,
        txn_options: &TransactionOptions,
    ) -> Result<AccountAddress, CliError> {
        if let Some(address) = self.large_packages_module_address {
            return Ok(address);
        }

        let chain_id = match &txn_options.session {
            None => {
                let client = txn_options.rest_client()?;
                ChainId::new(client.get_ledger_information().await?.inner().chain_id)
            },
            Some(session_path) => {
                let sess = Session::load(session_path)?;
                sess.state_store().get_chain_id()?
            },
        };

        AccountAddress::from_str_strict(default_large_packages_module_address(&chain_id)).map_err(
            |err| CliError::UnableToParse("Default Large Package Module Address", err.to_string()),
        )
    }
```
