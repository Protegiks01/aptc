# Audit Report

## Title
Container Resource Size Limit Causes Permanent Resource Account Creation Failure

## Summary
The `Container` resource in the `resource_account` module uses a `SimpleMap` to store signer capabilities for created resource accounts. This map grows unbounded and will eventually exceed the 1MB per-resource storage limit enforced by the VM, causing permanent failure of resource account creation for users with approximately 13,000+ resource accounts.

## Finding Description

The resource account system stores signer capabilities in a `Container` resource at the origin account's address: [1](#0-0) 

When creating a resource account, the system adds an entry to this `SimpleMap`: [2](#0-1) 

The `SimpleMap` is implemented as a vector with no explicit size limits: [3](#0-2) [4](#0-3) 

However, the VM enforces a strict **1MB limit per write operation** (per-resource storage limit): [5](#0-4) [6](#0-5) 

Each `SimpleMap` entry stores an `address` (32 bytes) and a `SignerCapability` containing an `address` (32 bytes): [7](#0-6) 

With approximately 64 bytes per entry plus BCS encoding overhead (~80 bytes total), the `Container` can hold roughly **13,000 resource accounts** before exceeding 1MB. Once this limit is reached, any subsequent `create_resource_account()` call will fail with `STORAGE_WRITE_LIMIT_REACHED`.

**Attack/Failure Scenario:**
1. User or protocol creates resource accounts over time (e.g., one per user, per liquidity pool, etc.)
2. After ~13,000 creations, the `Container` resource approaches 1MB
3. Next `create_resource_account()` transaction attempts to modify the `Container`
4. VM enforces the 1MB limit during `check_change_set()`
5. Transaction fails with `STORAGE_WRITE_LIMIT_REACHED`
6. User permanently cannot create more resource accounts from this origin address

The formal specifications make no mention of capacity limits: [8](#0-7) 

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Once the limit is hit, the user cannot create new resource accounts without manual intervention (using a different origin account)
- **Limited operational DoS**: Protocols relying on programmatic resource account creation will permanently fail after ~13,000 accounts
- No direct fund loss, but operational availability is compromised
- The only mitigation is to use a different origin account, which breaks protocol designs expecting a single origin

This breaks **Invariant #9 (Resource Limits)**: The system should gracefully handle or prevent resource exhaustion, but instead allows silent accumulation until catastrophic failure.

## Likelihood Explanation

**Likelihood: Medium to High**

While 13,000 resource accounts seems like a large number, it's entirely feasible for:
- **DeFi protocols** creating one resource account per user vault or liquidity position
- **NFT platforms** creating resource accounts for collections or marketplaces
- **Multi-sig wallets** using resource accounts for sub-accounts
- **Long-running protocols** accumulating accounts over months/years

The issue will occur organically without malicious intent. A protocol successfully operating for extended periods will inevitably hit this limit with no warning or graceful degradation.

## Recommendation

Implement one of the following mitigations:

**Option 1: Add Size Check Before Insertion**
```move
const MAX_CONTAINER_SIZE: u64 = 10000; // Conservative limit well below 1MB

fun rotate_account_authentication_key_and_store_capability(
    origin: &signer,
    resource: signer,
    resource_signer_cap: account::SignerCapability,
    optional_auth_key: vector<u8>
) acquires Container {
    let origin_addr = signer::address_of(origin);
    if (!exists<Container>(origin_addr)) {
        move_to(origin, Container { store: simple_map::create() })
    };

    let container = borrow_global_mut<Container>(origin_addr);
    assert!(
        simple_map::length(&container.store) < MAX_CONTAINER_SIZE,
        error::resource_exhausted(ECONTAINER_CAPACITY_EXCEEDED)
    );
    
    let resource_addr = signer::address_of(&resource);
    simple_map::add(&mut container.store, resource_addr, resource_signer_cap);
    // ... rest of function
}
```

**Option 2: Use Alternative Storage Pattern**
Migrate to storing capabilities in separate resources or using `Table` instead of `SimpleMap` for unbounded storage.

**Option 3: Auto-cleanup Pattern**
Automatically remove retrieved capabilities from the map during `retrieve_resource_account_cap()` (already implemented) and document that users should retrieve capabilities to prevent accumulation.

## Proof of Concept

```move
#[test_only]
module test_addr::container_capacity_test {
    use aptos_framework::resource_account;
    use aptos_framework::account;
    use std::signer;
    use std::vector;

    #[test(origin = @0xcafe)]
    #[expected_failure(abort_code = 0x40fb, location = aptos_framework)] // STORAGE_WRITE_LIMIT_REACHED
    fun test_container_exceeds_storage_limit(origin: signer) {
        let origin_addr = signer::address_of(&origin);
        account::create_account(origin_addr);

        // Create approximately 13,100 resource accounts to exceed 1MB limit
        // Each entry is ~80 bytes, so 13,100 * 80 = 1,048,000 bytes > 1MB
        let i = 0;
        while (i < 13100) {
            let seed = vector::empty<u8>();
            vector::push_back(&mut seed, ((i / 256) as u8));
            vector::push_back(&mut seed, ((i % 256) as u8));
            
            resource_account::create_resource_account(
                &origin,
                seed,
                vector::empty()
            );
            i = i + 1;
        };
        
        // This next creation should fail with STORAGE_WRITE_LIMIT_REACHED
        // because the Container resource now exceeds 1MB
        resource_account::create_resource_account(
            &origin,
            b"final_seed",
            vector::empty()
        );
    }
}
```

**Notes:**
- The exact number of accounts before failure depends on BCS encoding overhead and may vary slightly
- The `0x40fb` abort code corresponds to `STORAGE_WRITE_LIMIT_REACHED` (status code 4027 from the VM)
- This test demonstrates the vulnerability is inherent to the unbounded growth of the `Container` resource
- The issue affects deterministic execution since all validators will experience the same limit enforcement

### Citations

**File:** aptos-move/framework/aptos-framework/sources/resource_account.move (L79-81)
```text
    struct Container has key {
        store: SimpleMap<address, account::SignerCapability>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/resource_account.move (L141-163)
```text
    fun rotate_account_authentication_key_and_store_capability(
        origin: &signer,
        resource: signer,
        resource_signer_cap: account::SignerCapability,
        optional_auth_key: vector<u8>
    ) acquires Container {
        let origin_addr = signer::address_of(origin);
        if (!exists<Container>(origin_addr)) {
            move_to(origin, Container { store: simple_map::create() })
        };

        let container = borrow_global_mut<Container>(origin_addr);
        let resource_addr = signer::address_of(&resource);
        simple_map::add(&mut container.store, resource_addr, resource_signer_cap);

        let auth_key =
            if (vector::is_empty(&optional_auth_key)) {
                account::get_authentication_key(origin_addr)
            } else {
                optional_auth_key
            };
        account::rotate_authentication_key_internal(&resource, auth_key);
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L22-24)
```text
    struct SimpleMap<Key, Value> has copy, drop, store {
        data: vector<Element<Key, Value>>,
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L92-102)
```text
    /// Add a key/value pair to the map. The key must not already exist.
    public fun add<Key: store, Value: store>(
        self: &mut SimpleMap<Key, Value>,
        key: Key,
        value: Value,
    ) {
        let maybe_idx = self.find(&key);
        assert!(maybe_idx.is_none(), error::invalid_argument(EKEY_ALREADY_EXISTS));

        self.data.push_back(Element { key, value });
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L102-107)
```rust
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L90-90)
```text
    struct SignerCapability has drop, store { account: address }
```

**File:** aptos-move/framework/aptos-framework/sources/resource_account.spec.move (L26-30)
```text
    /// Requirement: It is not possible to store two capabilities for the same resource address.
    /// Criticality: Medium
    /// Implementation: The rotate_account_authentication_key_and_store_capability will abort if the resource signer
    /// capability for the given resource address already exists in container.store.
    /// Enforcement: Formally verified via [high-level-req-4](rotate_account_authentication_key_and_store_capability).
```
