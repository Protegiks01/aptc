# Audit Report

## Title
Lack of Cryptographic Verification of Advertised Data Ranges Enables State Sync DoS Attacks

## Summary
Peers advertise their data availability through `StorageServerSummary` without cryptographic proof of actual data possession. Malicious peers can advertise false data ranges, causing syncing nodes to waste resources on failed requests, leading to denial of service and network degradation.

## Finding Description

The Aptos state-sync system allows peers to advertise data availability ranges (transactions, states, transaction outputs, epoch ending ledger infos) through `StorageServerSummary`. The critical vulnerability is that these advertised ranges are accepted **without any cryptographic verification** that the peer actually possesses the claimed data.

**Vulnerable Flow:**

1. **Polling Without Verification**: When the data client polls peers for their storage summaries, it receives a `StorageServerSummary` containing advertised data ranges. [1](#0-0) 

The storage summary is directly stored without validation: [2](#0-1) 

2. **Range Selection Without Proof**: When determining if a peer can service a request, only range containment is checked—no cryptographic proof is required: [3](#0-2) 

3. **Data Ranges Not Bound to Signatures**: While `StorageServerSummary` contains a `synced_ledger_info` (which has BLS signatures proving the highest synced version), the advertised data ranges are **not cryptographically bound** to this ledger info: [4](#0-3) 

**Attack Scenario:**

A malicious peer can:
1. Obtain a legitimate `synced_ledger_info` from the network (e.g., version 1,000,000)
2. Advertise false data ranges claiming full historical data:
   - `transactions: CompleteDataRange(0, 1000000)`  
   - `states: CompleteDataRange(0, 1000000)`
3. But actually only possess recent data (e.g., versions 995,000-1,000,000)
4. When honest nodes request historical data (e.g., versions 0-10,000), the malicious peer fails to respond
5. The requesting node wastes time waiting, then must retry with another peer
6. Multiple malicious peers can coordinate to severely degrade network state sync performance

The `synced_ledger_info` signatures prove the peer knows about version 1,000,000, but provide **no proof** that the peer possesses intermediate historical data. The advertised ranges are completely unconstrained.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Syncing nodes experience significant delays due to wasted requests to malicious peers
- **Significant protocol violations**: Breaks the trust model of the state-sync protocol by allowing unprovable data availability claims
- **Network availability degradation**: A coordinated attack with multiple malicious peers can severely slow down or halt state synchronization across the network

The attack does not directly cause loss of funds or consensus violations, but it can:
- Prevent new nodes from syncing to the network
- Slow down existing nodes recovering from downtime
- Degrade network resilience and availability
- Enable targeted DoS against specific nodes by advertising false data

## Likelihood Explanation

**High Likelihood:**

- **Low attacker requirements**: Any network peer can advertise false ranges
- **No insider access needed**: Does not require validator status or privileged access
- **Simple exploitation**: Attacker only needs to run a modified storage service that advertises false ranges
- **Difficult to detect**: The malicious peer appears legitimate until actual data requests fail
- **Scoring mitigation insufficient**: While peer scores decrease after failed requests, the initial damage is already done, and attackers can rotate through multiple peer identities

The only cost to the attacker is running network peers, which is relatively cheap compared to the impact.

## Recommendation

Implement cryptographic proof of data possession before accepting advertised ranges:

**Option 1: Range Commitments**
- Extend `StorageServerSummary` to include Merkle proofs or range commitments
- Peers must prove they possess data at sampled random points within advertised ranges
- Verify these proofs before trusting advertised ranges

**Option 2: Reputation-Based Filtering**
- Only accept data ranges from peers with established reputation
- Require peers to successfully serve sample data requests before advertising full ranges
- Implement stricter penalties for false advertising (temporary bans)

**Option 3: Ledger Info Chain Validation**
- Require peers to provide intermediate `LedgerInfoWithSignatures` at regular intervals within advertised ranges
- This proves the peer at least has checkpoints throughout the claimed range
- Verify these intermediate ledger infos have valid quorum signatures

**Recommended Fix** (Option 3 - most practical):

```rust
// In StorageServerSummary
pub struct DataSummary {
    pub synced_ledger_info: Option<LedgerInfoWithSignatures>,
    pub epoch_ending_ledger_infos: Option<CompleteDataRange<Epoch>>,
    pub states: Option<CompleteDataRange<Version>>,
    pub transactions: Option<CompleteDataRange<Version>>,
    pub transaction_outputs: Option<CompleteDataRange<Version>>,
    
    // NEW: Checkpoint ledger infos proving data possession
    pub checkpoint_ledger_infos: Vec<LedgerInfoWithSignatures>,
}

// In peer_states.rs update_summary
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // NEW: Validate checkpoint ledger infos before accepting ranges
    if let Err(e) = validate_data_range_proofs(&storage_summary) {
        warn!("Rejecting storage summary from peer {:?}: {:?}", peer, e);
        return;
    }
    
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}

fn validate_data_range_proofs(summary: &StorageServerSummary) -> Result<(), Error> {
    // Verify checkpoint ledger infos cover the advertised ranges
    // Verify signatures on checkpoint ledger infos
    // Ensure sufficient coverage (e.g., one checkpoint per 100k versions)
    // ...
}
```

## Proof of Concept

```rust
// Malicious Storage Service PoC
// This demonstrates how a malicious peer can advertise false data ranges

use aptos_storage_service_types::{
    responses::{DataSummary, StorageServerSummary, ProtocolMetadata, CompleteDataRange},
};

fn create_malicious_storage_summary() -> StorageServerSummary {
    // Obtain a legitimate synced_ledger_info from network (version 1,000,000)
    let legitimate_synced_ledger_info = get_legitimate_ledger_info_from_network();
    
    // Advertise FALSE data ranges claiming full history
    let malicious_data_summary = DataSummary {
        synced_ledger_info: Some(legitimate_synced_ledger_info),
        
        // LIE: Claim to have all transactions from genesis
        transactions: Some(CompleteDataRange::new(0, 1_000_000).unwrap()),
        
        // LIE: Claim to have all states from genesis  
        states: Some(CompleteDataRange::new(0, 1_000_000).unwrap()),
        
        // LIE: Claim to have all transaction outputs from genesis
        transaction_outputs: Some(CompleteDataRange::new(0, 1_000_000).unwrap()),
        
        epoch_ending_ledger_infos: Some(CompleteDataRange::new(0, 100).unwrap()),
    };
    
    StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: malicious_data_summary,
    }
}

// When honest nodes request data from versions 0-10,000:
// 1. They select this malicious peer based on advertised ranges
// 2. Send request to malicious peer
// 3. Malicious peer fails to respond (doesn't have the data)
// 4. Honest node times out after waiting request_timeout_ms
// 5. Honest node retries with different peer
// Result: Wasted time = request_timeout_ms * number_of_malicious_peers_selected
```

To reproduce:
1. Run a modified storage service that returns `create_malicious_storage_summary()`
2. Connect it to an Aptos network as a regular peer
3. Observe honest nodes selecting this peer for historical data requests
4. Observe request timeouts and retries
5. Measure the state sync slowdown on honest nodes

**Notes**

The vulnerability exists because the state-sync protocol was designed with an implicit trust assumption that peers accurately advertise their data availability. While the `synced_ledger_info` contains valid BLS signatures from a quorum of validators, these signatures only attest to the highest version the peer has synced to—they provide no cryptographic proof about intermediate historical data ranges.

The current peer scoring mechanism provides limited protection, as malicious peers can cause significant disruption before their scores drop below the ignore threshold. Additionally, attackers can operate multiple peer identities to evade reputation systems.

This vulnerability is particularly concerning for:
- New nodes bootstrapping from genesis
- Nodes recovering from extended downtime
- Archive nodes serving historical data queries

The fix should maintain backward compatibility while adding optional cryptographic proofs that can be gradually adopted across the network.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L406-439)
```rust
        let data_request = DataRequest::GetStorageServerSummary;
        let use_compression = data_summary_poller.data_client_config.use_compression;
        let storage_request = StorageServiceRequest::new(data_request, use_compression);

        // Fetch the storage summary for the peer and stop the timer
        let request_timeout = data_summary_poller.data_client_config.response_timeout_ms;
        let result: crate::error::Result<StorageServerSummary> = data_summary_poller
            .data_client
            .send_request_to_peer_and_decode(peer, storage_request, request_timeout)
            .await
            .map(Response::into_payload);

        // Mark the in-flight poll as now complete
        data_summary_poller.in_flight_request_complete(&peer);

        // Check the storage summary response
        let storage_summary = match result {
            Ok(storage_summary) => storage_summary,
            Err(error) => {
                warn!(
                    (LogSchema::new(LogEntry::StorageSummaryResponse)
                        .event(LogEvent::PeerPollingError)
                        .message("Error encountered when polling peer!")
                        .error(&error)
                        .peer(&peer))
                );
                return;
            },
        };

        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/client.rs (L213-214)
```rust
    pub fn update_peer_storage_summary(&self, peer: PeerNetworkId, summary: StorageServerSummary) {
        self.peer_states.update_summary(peer, summary)
```

**File:** state-sync/storage-service/types/src/responses.rs (L665-686)
```rust
/// A summary of the data actually held by the storage service instance.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DataSummary {
    /// The ledger info corresponding to the highest synced version in storage.
    /// This indicates the highest version and epoch that storage can prove.
    pub synced_ledger_info: Option<LedgerInfoWithSignatures>,
    /// The range of epoch ending ledger infos in storage, e.g., if the range
    /// is [(X,Y)], it means all epoch ending ledger infos for epochs X->Y
    /// (inclusive) are held.
    pub epoch_ending_ledger_infos: Option<CompleteDataRange<Epoch>>,
    /// The range of states held in storage, e.g., if the range is
    /// [(X,Y)], it means all states are held for every version X->Y
    /// (inclusive).
    pub states: Option<CompleteDataRange<Version>>,
    /// The range of transactions held in storage, e.g., if the range is
    /// [(X,Y)], it means all transactions for versions X->Y (inclusive) are held.
    pub transactions: Option<CompleteDataRange<Version>>,
    /// The range of transaction outputs held in storage, e.g., if the range
    /// is [(X,Y)], it means all transaction outputs for versions X->Y
    /// (inclusive) are held.
    pub transaction_outputs: Option<CompleteDataRange<Version>>,
}
```

**File:** state-sync/storage-service/types/src/responses.rs (L688-807)
```rust
impl DataSummary {
    /// Returns true iff the request can be serviced
    pub fn can_service(
        &self,
        aptos_data_client_config: &AptosDataClientConfig,
        time_service: TimeService,
        request: &StorageServiceRequest,
    ) -> bool {
        match &request.data_request {
            GetServerProtocolVersion | GetStorageServerSummary => true,
            GetEpochEndingLedgerInfos(request) => {
                let desired_range =
                    match CompleteDataRange::new(request.start_epoch, request.expected_end_epoch) {
                        Ok(desired_range) => desired_range,
                        Err(_) => return false,
                    };
                self.epoch_ending_ledger_infos
                    .map(|range| range.superset_of(&desired_range))
                    .unwrap_or(false)
            },
            GetNewTransactionOutputsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNewTransactionsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNewTransactionsOrOutputsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNumberOfStatesAtVersion(version) => self
                .states
                .map(|range| range.contains(*version))
                .unwrap_or(false),
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
            GetTransactionOutputsWithProof(request) => self
                .can_service_transaction_outputs_with_proof(
                    request.start_version,
                    request.end_version,
                    request.proof_version,
                ),
            GetTransactionsWithProof(request) => self.can_service_transactions_with_proof(
                request.start_version,
                request.end_version,
                request.proof_version,
            ),
            GetTransactionsOrOutputsWithProof(request) => self
                .can_service_transactions_or_outputs_with_proof(
                    request.start_version,
                    request.end_version,
                    request.proof_version,
                ),
            SubscribeTransactionOutputsWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            SubscribeTransactionsOrOutputsWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            SubscribeTransactionsWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),

            // Transaction data v2 requests (transactions with auxiliary data)
            GetTransactionDataWithProof(request) => match request.transaction_data_request_type {
                TransactionDataRequestType::TransactionData(_) => self
                    .can_service_transactions_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
                TransactionDataRequestType::TransactionOutputData => self
                    .can_service_transaction_outputs_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
                TransactionDataRequestType::TransactionOrOutputData(_) => self
                    .can_service_transactions_or_outputs_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
            },
            GetNewTransactionDataWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            SubscribeTransactionDataWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
        }
```
