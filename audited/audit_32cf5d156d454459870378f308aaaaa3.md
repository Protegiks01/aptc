# Audit Report

## Title
Aptos Rosetta API Does Not Distinguish Between Legitimate and Malicious Fungible Assets in Balance Reporting

## Summary
The Aptos Rosetta implementation fails to distinguish between legitimate and malicious fungible asset stores when reporting account balances. Any fungible asset added to the operator's currency configuration file will be reported with equal legitimacy, regardless of whether it's an official asset or a scam token, potentially leading to user deception and financial loss.

## Finding Description

The Aptos Rosetta API uses a whitelist-based approach for reporting fungible asset balances, where supported currencies are loaded from a configuration file. [1](#0-0) 

When querying account balances, Rosetta iterates through all currencies in this whitelist and calls the `primary_fungible_store::balance` view function for each fungible asset address. [2](#0-1) 

The critical issue is that the `primary_fungible_store::balance` function returns balances for ANY fungible asset without validation. [3](#0-2) 

Furthermore, the Move framework allows anyone to create a fungible asset with primary store support enabled. [4](#0-3) 

The Currency metadata structure provides no indication of asset legitimacy or verification status. [5](#0-4) 

**Attack Path:**
1. Attacker creates a malicious fungible asset with attractive symbol/name (e.g., "USDC2", "APT+")
2. Attacker airdrops tokens to many addresses
3. Through social engineering or operator error, the malicious FA address gets added to a Rosetta operator's currency_config_file
4. Rosetta begins reporting balances for the scam token with no distinction from legitimate assets
5. Users/exchanges see balances and may trade or accept the worthless tokens as if they were legitimate
6. Users suffer financial losses

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "Limited funds loss or manipulation."

The vulnerability can lead to:
- **Financial Loss**: Users deceived into trading scam tokens for real assets
- **Ecosystem Trust Damage**: Undermines confidence in Rosetta API reliability  
- **Exchange Risk**: Exchanges relying on Rosetta may accidentally list malicious tokens
- **Indirect Theft Vector**: Attackers can exploit user confusion to steal legitimate assets in trades

While the attack requires operator misconfiguration, the lack of any validation or warning mechanisms makes this a realistic threat, especially as the ecosystem grows and more operators deploy Rosetta instances.

## Likelihood Explanation

**Likelihood: Medium**

The attack is feasible because:
- Creating fungible assets is permissionless on Aptos
- Rosetta operators may add currencies based on community requests without thorough verification
- No built-in verification or warning system exists
- The configuration file format accepts arbitrary addresses with minimal validation [6](#0-5) 

Mitigating factors:
- Requires operator action to add malicious FA to config
- Sophisticated users may recognize scam tokens
- Established exchanges likely have internal verification processes

However, the ease of creating convincing scam tokens and the absence of any protective measures make this a realistic threat vector.

## Recommendation

Implement a multi-layered approach to distinguish legitimate from malicious fungible assets:

**1. Add Asset Verification Metadata to Currency Structure:**
```rust
pub struct CurrencyMetadata {
    pub move_type: Option<String>,
    pub fa_address: Option<String>,
    pub verified: bool,  // NEW: Indicates if asset is verified
    pub verification_source: Option<String>,  // NEW: Source of verification
}
```

**2. Implement On-Chain Asset Registry Query:**
Query the on-chain metadata for fungible assets and include creator address, supply, and other identifying information in balance responses.

**3. Separate Verified and Unverified Asset Balance Responses:**
Return verified assets in the standard balance array and unverified assets in a separate field with warnings.

**4. Add Configuration Validation:**
Warn operators during startup if unverified assets are in the currency config file.

**5. Implement Default Whitelist:**
Ship Rosetta with a curated list of verified assets (APT, official USDC, etc.) and require explicit opt-in for additional assets.

## Proof of Concept

**Step 1: Create Malicious Fungible Asset (Move)**
```move
// Create a scam token that mimics USDC
public entry fun create_scam_token(creator: &signer) {
    let constructor_ref = object::create_named_object(creator, b"SCAM_USDC");
    primary_fungible_store::create_primary_store_enabled_fungible_asset(
        &constructor_ref,
        option::some(1000000000000),
        string::utf8(b"USD Coin"),  // Deceptive name
        string::utf8(b"USDC"),      // Deceptive symbol
        6,                          // Same decimals as real USDC
        string::utf8(b""),
        string::utf8(b""),
    );
}
```

**Step 2: Add to Rosetta Config**
```json
[
  {
    "symbol": "USDC",
    "decimals": 6,
    "metadata": {
      "fa_address": "<SCAM_TOKEN_ADDRESS>"
    }
  }
]
```

**Step 3: Query Balance via Rosetta**
The Rosetta `/account/balance` endpoint will return the scam token balance with no indication it's not the legitimate USDC, as the implementation simply queries the primary_fungible_store::balance view function for any fa_address in the config. [7](#0-6) 

**Notes**

This vulnerability exists at the API layer rather than the blockchain consensus layer, but still poses significant risk to users and ecosystem integrity. The permissionless nature of fungible asset creation combined with Rosetta's lack of verification creates a trust problem that could be exploited at scale.

The issue is particularly concerning because Rosetta is designed as a standardized API for blockchain integration, meaning many services and exchanges rely on it for accurate balance information. A compromised or misconfigured Rosetta instance could propagate incorrect information to dependent systems.

### Citations

**File:** crates/aptos-rosetta/src/main.rs (L241-273)
```rust
    fn supported_currencies(&self) -> HashSet<Currency> {
        let mut supported_currencies = HashSet::new();
        supported_currencies.insert(native_coin());

        if let Some(ref filepath) = self.currency_config_file {
            let file = File::open(filepath).unwrap();
            let currencies: Vec<Currency> = serde_json::from_reader(file).unwrap();
            for item in currencies.into_iter() {
                // Do a safety check on possible currencies on startup
                if item.symbol.as_str() == "" {
                    warn!(
                        "Currency {:?} has an empty symbol, and is being skipped",
                        item
                    );
                } else if let Some(metadata) = item.metadata.as_ref() {
                    if let Some(move_type) = metadata.move_type.as_ref() {
                        if StructTag::from_str(move_type).is_ok() {
                            supported_currencies.insert(item);
                            continue;
                        }
                    }
                    warn!(
                        "Currency {:?} has an invalid metadata coin type, and is being skipped",
                        item
                    );
                } else {
                    supported_currencies.insert(item);
                }
            }
        }

        supported_currencies
    }
```

**File:** crates/aptos-rosetta/src/account.rs (L310-344)
```rust
    for currency in currencies_to_lookup.iter() {
        match *currency {
            // FA only
            Currency {
                metadata:
                    Some(CurrencyMetadata {
                        move_type: None,
                        fa_address: Some(ref fa_address),
                    }),
                ..
            } => {
                let response = view::<Vec<u64>>(
                    rest_client,
                    version,
                    AccountAddress::ONE,
                    ident_str!(PRIMARY_FUNGIBLE_STORE_MODULE),
                    ident_str!(BALANCE_FUNCTION),
                    vec![TypeTag::Struct(Box::new(StructTag {
                        address: AccountAddress::ONE,
                        module: ident_str!(OBJECT_MODULE).into(),
                        name: ident_str!(OBJECT_CORE_RESOURCE).into(),
                        type_args: vec![],
                    }))],
                    vec![
                        bcs::to_bytes(&owner_address).unwrap(),
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
                    ],
                )
                .await?;
                let fa_balance = response.first().copied().unwrap_or(0);
                balances.push(Amount {
                    value: fa_balance.to_string(),
                    currency: currency.clone(),
                })
            },
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L37-59)
```text
    public fun create_primary_store_enabled_fungible_asset(
        constructor_ref: &ConstructorRef,
        maximum_supply: Option<u128>,
        name: String,
        symbol: String,
        decimals: u8,
        icon_uri: String,
        project_uri: String,
    ) {
        fungible_asset::add_fungibility(
            constructor_ref,
            maximum_supply,
            name,
            symbol,
            decimals,
            icon_uri,
            project_uri,
        );
        let metadata_obj = &constructor_ref.generate_signer();
        move_to(metadata_obj, DeriveRefPod {
            metadata_derive_ref: constructor_ref.generate_derive_ref(),
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L158-165)
```text
    /// Get the balance of `account`'s primary store.
    public fun balance<T: key>(account: address, metadata: Object<T>): u64 {
        if (primary_store_exists(account, metadata)) {
            dispatchable_fungible_asset::derived_balance(primary_store(account, metadata))
        } else {
            0
        }
    }
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L177-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```
