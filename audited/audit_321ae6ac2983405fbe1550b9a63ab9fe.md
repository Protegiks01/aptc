# Audit Report

## Title
State Transition Overflow Check Bypass in Aggregator V1 Add Operation

## Summary
The `add()` operation in Aggregator V1 contains a critical validation gap when transitioning from `NegativeDelta` to `PositiveDelta` state. This allows an attacker to bypass overflow checks through a specific sequence of sub/add operations, creating an invalid aggregator state where the tracked positive delta exceeds `max_value`, causing permanent aggregator malfunction and denial-of-service for critical state tracking such as coin supply.

## Finding Description

The vulnerability exists in the aggregator state transition logic within the `add()` method. [1](#0-0) 

When an aggregator is in `NegativeDelta` state and receives an `add()` operation with a value larger than the current negative delta, the code transitions to `PositiveDelta` state by calculating the new positive delta as `value - self.value`. [2](#0-1) 

The critical flaw is that this calculation uses `unsigned_subtract`, which only validates against underflow but does NOT enforce that the result stays within `max_value` bounds. [3](#0-2) 

**Exploitation Path:**

1. Attacker targets an aggregator with `max_value = 100`
2. Execute `sub(50)`: Creates `NegativeDelta` state with `value = 50`
3. Execute `add(200)`: Since `50 <= 200`, the code computes `200 - 50 = 150` without checking that `150 > 100`
4. Result: `PositiveDelta` with `value = 150`, violating the invariant `max_achieved_positive_delta <= max_value`

The aggregator's history tracking then records this invalid state. [4](#0-3) 

**Consequences:**

Any subsequent `add()` operation will fail because `unsigned_add` checks if `max_value < base`, which becomes `100 < 150`, causing incorrect transaction aborts. [5](#0-4) 

Materialization (reading the aggregator value) will always fail validation because it requires `base_value + 150 <= 100`, which is impossible for any valid `base_value >= 0`. [6](#0-5) 

**Contrast with Correct Implementation:**

The `sub()` operation correctly validates during the state transition from `PositiveDelta` to `NegativeDelta` by checking that the subtraction amount doesn't exceed bounds. [7](#0-6) 

This same validation is missing from the `add()` operation's state transition logic.

**Critical Usage Context:**

Aggregators are used extensively for coin supply tracking in the Aptos Framework. The execution path flows from coin operations through optional aggregators to the native aggregator implementation. [8](#0-7) [9](#0-8) [10](#0-9) 

An attacker can render coin supply aggregators unusable, preventing critical minting and burning operations across the ecosystem.

## Impact Explanation

**Severity: Medium**

This vulnerability creates **state inconsistencies requiring intervention**, aligning with Medium severity in the Aptos bug bounty program.

**Impact:**
1. **Denial of Service**: Aggregators become permanently unusable after exploitation, blocking operations that depend on them
2. **State Corruption**: Creates invalid internal state that violates the fundamental invariant `max_achieved_positive_delta <= max_value`
3. **Ecosystem Disruption**: If coin supply aggregators are affected, this blocks mint/burn operations for affected tokens

**Impact Limitations:**
- No direct fund theft (transactions abort rather than completing with incorrect values)
- No consensus disagreement (all validators execute identically and reach the same invalid state)
- Recovery possible through governance intervention or manual aggregator recreation
- Limited to specific aggregator instances, not a network-wide issue

The deterministic nature ensures all validators see the same invalid state, preventing consensus splits but creating a protocol invariant violation that requires intervention to resolve.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be discovered and exploited:

1. **Simple Attack**: Requires only two sequential operations (`sub`, then `add`) in a single transaction
2. **No Special Permissions**: Any transaction sender can exploit this without special capabilities
3. **Predictable Targets**: Coin supply aggregators are well-known and their addresses are publicly documented
4. **Easy Discovery**: The missing validation is evident through straightforward code inspection
5. **High Value Targets**: Aggregators tracking coin supply for major tokens represent lucrative DoS targets

The attack complexity is minimal - an attacker simply needs to identify aggregators using the V1 implementation (determinable through on-chain inspection) and submit a transaction with the exploit sequence.

## Recommendation

Add overflow validation to the `add()` method's state transition from `NegativeDelta` to `PositiveDelta`, mirroring the validation present in the `sub()` method:

```rust
AggregatorState::NegativeDelta => {
    if self.value <= value {
        // Validate that the resulting positive delta doesn't exceed max_value
        math.unsigned_subtract(self.max_value, value)
            .map_err(addition_v1_error)?;
        
        self.value = expect_ok(math.unsigned_subtract(value, self.value))?;
        self.state = AggregatorState::PositiveDelta;
    } else {
        self.value = expect_ok(math.unsigned_subtract(self.value, value))?;
    }
}
```

This ensures the new positive delta respects the `max_value` constraint before transitioning state.

## Proof of Concept

```rust
#[test]
fn test_add_overflow_via_state_transition() {
    let mut aggregator_data = AggregatorData::default();
    
    // Create aggregator with max_value = 100
    let aggregator = aggregator_data
        .get_aggregator(aggregator_v1_id_for_test(100), 100)
        .expect("Get aggregator failed");
    
    // Step 1: sub(50) - transitions to NegativeDelta(50)
    assert_ok!(aggregator.sub(50));
    assert_eq!(aggregator.state, AggregatorState::NegativeDelta);
    assert_eq!(aggregator.value, 50);
    
    // Step 2: add(200) - should fail but doesn't, creates invalid state
    // This SHOULD fail because 200-50=150 > 100 (max_value)
    // But currently it succeeds, creating invalid state
    assert_ok!(aggregator.add(200)); // BUG: This should return an error!
    
    // Now in invalid state: PositiveDelta(150) with max_value=100
    assert_eq!(aggregator.state, AggregatorState::PositiveDelta);
    assert_eq!(aggregator.value, 150); // 150 > 100 violates invariant!
    
    // Step 3: Any subsequent add() will fail
    assert_err!(aggregator.add(1)); // Fails because 150 > 100
    
    // Step 4: Materialization will fail
    let resolver = FakeAggregatorView::default();
    assert_err!(aggregator.read_and_materialize(&resolver, &aggregator_v1_id_for_test(100)));
}
```

### Citations

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L75-89)
```rust
    fn record(&mut self) {
        if let Some(history) = self.history.as_mut() {
            match self.state {
                AggregatorState::PositiveDelta => {
                    history.record_success(SignedU128::Positive(self.value))
                },
                AggregatorState::NegativeDelta => {
                    history.record_success(SignedU128::Negative(self.value))
                },
                AggregatorState::Data => {
                    unreachable!("history is not tracked when aggregator knows its value")
                },
            }
        }
    }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L144-156)
```rust
            AggregatorState::NegativeDelta => {
                // Negative delta is a special case, since the state might
                // change depending on how big the `value` is. Suppose
                // aggregator has -X and want to do +Y. Then, there are two
                // cases:
                //     1. X <= Y: then the result is +(Y-X)
                //     2. X  > Y: then the result is -(X-Y)
                if self.value <= value {
                    self.value = expect_ok(math.unsigned_subtract(value, self.value))?;
                    self.state = AggregatorState::PositiveDelta;
                } else {
                    self.value = expect_ok(math.unsigned_subtract(self.value, value))?;
                }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L189-194)
```rust
                } else {
                    // Check that we can subtract in general: we don't want to
                    // allow -10000 when max_value is 10.
                    // TODO: maybe `subtraction` should also know about the max_value?
                    math.unsigned_subtract(self.max_value, value)
                        .map_err(subtraction_v1_error)?;
```

**File:** aptos-move/aptos-aggregator/src/bounded_math.rs (L50-56)
```rust
    pub fn unsigned_add(&self, base: u128, value: u128) -> BoundedMathResult<u128> {
        if self.max_value < base || value > (self.max_value - base) {
            Err(BoundedMathError::Overflow)
        } else {
            Ok(base + value)
        }
    }
```

**File:** aptos-move/aptos-aggregator/src/bounded_math.rs (L58-64)
```rust
    pub fn unsigned_subtract(&self, base: u128, value: u128) -> BoundedMathResult<u128> {
        if value > base {
            Err(BoundedMathError::Underflow)
        } else {
            Ok(base - value)
        }
    }
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L148-165)
```rust
    pub fn validate_against_base_value(
        &self,
        base_value: u128,
        max_value: u128,
    ) -> Result<(), DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);
        // We need to make sure the following 4 conditions are satisified.
        //     base_value + max_achieved_positive_delta <= self.max_value
        //     base_value >= min_achieved_negative_delta
        //     base_value + min_overflow_positive_delta > self.max_value
        //     base_value < max_underflow_negative_delta
        math.unsigned_add(base_value, self.max_achieved_positive_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(self.max_achieved_positive_delta),
                reason: DeltaApplicationFailureReason::Overflow,
            })?;
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1220-1220)
```text
            optional_aggregator::add(supply, (amount as u128));
```

**File:** aptos-move/framework/aptos-framework/sources/aggregator/optional_aggregator.move (L124-132)
```text
    public fun add(optional_aggregator: &mut OptionalAggregator, value: u128) {
        if (option::is_some(&optional_aggregator.aggregator)) {
            let aggregator = option::borrow_mut(&mut optional_aggregator.aggregator);
            aggregator::add(aggregator, value);
        } else {
            let integer = option::borrow_mut(&mut optional_aggregator.integer);
            add_integer(integer, value);
        }
    }
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator.rs (L27-48)
```rust
fn native_add(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 2);

    context.charge(AGGREGATOR_ADD_BASE)?;

    // Get aggregator information and a value to add.
    let input = safely_pop_arg!(args, u128);
    let (id, max_value) = aggregator_info(&safely_pop_arg!(args, StructRef))?;

    // Get aggregator.
    let aggregator_context = context.extensions().get::<NativeAggregatorContext>();
    let mut aggregator_data = aggregator_context.aggregator_v1_data.borrow_mut();
    let aggregator = aggregator_data.get_aggregator(id, max_value)?;

    aggregator.add(input)?;

    Ok(smallvec![])
}
```
