# Audit Report

## Title
Unbounded Type Argument Parsing Enables API Denial of Service

## Summary
The Aptos API layer allows transaction submissions with an unbounded number of type arguments in the `type_arguments` field of `EntryFunctionPayload`. Each type argument string is parsed during JSON deserialization before any count validation occurs, enabling attackers to submit transactions with millions of type arguments that consume excessive CPU resources and cause API node denial of service.

## Finding Description

The vulnerability exists in the transaction submission flow where type arguments are processed. The `EntryFunctionPayload` structure contains a `type_arguments: Vec<MoveType>` field with no length restriction. [1](#0-0) 

When a JSON transaction is submitted, each type argument string undergoes expensive parsing via the `parse_type_tag()` function during serde deserialization. [2](#0-1) 

The parsing happens through the `FromStr` implementation which calls `parse_type_tag(s)` for every type argument string. [3](#0-2) 

**Critical Issue**: The type argument count is only validated AFTER all parsing is complete, during the conversion to `EntryFunction` when the code checks if the count matches the function's generic parameters. [4](#0-3) 

The `VerifyInput` trait implementation for `EntryFunctionPayload` only validates the recursion depth of each type (limited to 8), not the total count of type arguments. [5](#0-4) 

**Attack Vector**: Within the 8 MB API request size limit, an attacker can include approximately 1-2 million type argument strings. [6](#0-5) 

Each type argument string is parsed individually before rejection, causing:
- Excessive CPU consumption from string parsing
- Memory allocation for millions of parsed `MoveType` objects  
- Repeated attacks can exhaust API node resources

The production verifier config limits functions to 32 generic type parameters, but this validation occurs after parsing. [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "API crashes" and "Validator node slowdowns."

**Concrete Impact**:
- **API Node Degradation**: Repeated malicious transactions consume CPU resources, slowing down legitimate transaction processing
- **Resource Exhaustion**: Parsing millions of type tags can exhaust memory and CPU, potentially crashing API nodes
- **Service Availability**: Public API endpoints become unresponsive under sustained attack
- **Validator Impact**: If validator nodes run API services, they may experience performance degradation affecting consensus participation

The attack does not directly affect consensus safety or cause fund loss, but significantly degrades network availability and user experience.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- No special privileges required (any user can submit transactions)
- Simple HTTP POST with crafted JSON payload
- No cryptographic operations needed
- Within standard API limits (8 MB)
- Can be automated and repeated

**Attacker Requirements**:
- Network access to API endpoints
- Ability to craft JSON payloads
- No authentication or stake required

**Detection Difficulty**: 
- Appears as legitimate transaction submissions
- May be difficult to distinguish from genuine traffic until resource exhaustion occurs

## Recommendation

**Immediate Fix**: Add early validation of type argument count before parsing strings.

In `api/types/src/transaction.rs`, modify the `VerifyInput` implementation for `EntryFunctionPayload`:

```rust
impl VerifyInput for EntryFunctionPayload {
    fn verify(&self) -> anyhow::Result<()> {
        // Add early bound check on type argument count
        const MAX_TYPE_ARGS_FOR_PARSING: usize = 128;
        ensure!(
            self.type_arguments.len() <= MAX_TYPE_ARGS_FOR_PARSING,
            "type_arguments length {} exceeds maximum allowed {}",
            self.type_arguments.len(),
            MAX_TYPE_ARGS_FOR_PARSING
        );
        
        self.function.verify()?;
        for type_arg in self.type_arguments.iter() {
            type_arg.verify(0)?;
        }
        Ok(())
    }
}
```

**Additional Mitigations**:
1. Add rate limiting specifically for transactions with large type argument counts
2. Implement early deserialization bounds in serde for Vec lengths
3. Add monitoring/alerting for transactions with unusual type argument counts
4. Consider rejecting transactions where `type_arguments.len()` exceeds a reasonable threshold even before full parsing

## Proof of Concept

```rust
// PoC: Generate malicious transaction JSON
use serde_json::json;

fn generate_dos_transaction() -> serde_json::Value {
    // Generate 1 million type arguments within 8 MB limit
    let type_args: Vec<&str> = vec!["u8"; 1_000_000];
    
    json!({
        "sender": "0x1",
        "sequence_number": "0",
        "max_gas_amount": "1000000",
        "gas_unit_price": "100",
        "expiration_timestamp_secs": "9999999999",
        "payload": {
            "type": "entry_function_payload",
            "function": "0x1::coin::transfer",
            "type_arguments": type_args,
            "arguments": []
        }
    })
}

// Submit via HTTP POST to /transactions
// POST https://fullnode.mainnet.aptoslabs.com/v1/transactions
// Content-Type: application/json
// Body: output of generate_dos_transaction()
//
// Expected Result: API node spends significant CPU time parsing 
// 1 million "u8" strings before rejecting the transaction with
// "expect 1 type arguments for entry function, but got 1000000"
//
// Impact: Repeated submissions exhaust API node resources
```

**Notes**

This vulnerability represents a failure to enforce resource limits at the correct layer. While type nesting depth is properly validated, the count of type arguments is checked too late in the processing pipeline. The fix requires moving the count validation to occur before expensive parsing operations, aligning with the "Resource Limits" invariant that all operations must respect computational constraints.

### Citations

**File:** api/types/src/transaction.rs (L975-981)
```rust
pub struct EntryFunctionPayload {
    pub function: EntryFunctionId,
    /// Type arguments of the function
    pub type_arguments: Vec<MoveType>,
    /// Arguments of the function
    pub arguments: Vec<serde_json::Value>,
}
```

**File:** api/types/src/transaction.rs (L983-991)
```rust
impl VerifyInput for EntryFunctionPayload {
    fn verify(&self) -> anyhow::Result<()> {
        self.function.verify()?;
        for type_arg in self.type_arguments.iter() {
            type_arg.verify(0)?;
        }
        Ok(())
    }
}
```

**File:** api/types/src/move_types.rs (L813-842)
```rust
impl FromStr for MoveType {
    type Err = anyhow::Error;

    fn from_str(mut s: &str) -> Result<Self, Self::Err> {
        let mut is_ref = false;
        let mut is_mut = false;
        if s.starts_with('&') {
            s = &s[1..];
            is_ref = true;
        }
        if is_ref && s.starts_with("mut ") {
            s = &s[4..];
            is_mut = true;
        }
        // Previously this would just crap out, but this meant the API could
        // return a serialized version of an object and not be able to
        // deserialize it using that same object.
        let inner = match parse_type_tag(s) {
            Ok(inner) => (&inner).into(),
            Err(_e) => MoveType::Unparsable(s.to_string()),
        };
        if is_ref {
            Ok(MoveType::Reference {
                mutable: is_mut,
                to: Box::new(inner),
            })
        } else {
            Ok(inner)
        }
    }
```

**File:** api/types/src/move_types.rs (L852-860)
```rust
impl<'de> Deserialize<'de> for MoveType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let data = <String>::deserialize(deserializer)
            .map_err(|e| D::Error::custom(format_err!("deserialize Move type failed, {}", e)))?;
        data.parse().map_err(D::Error::custom)
    }
```

**File:** api/types/src/convert.rs (L704-710)
```rust
                ensure!(
                    func.generic_type_params.len() == type_arguments.len(),
                    "expect {} type arguments for entry function {}, but got {}",
                    func.generic_type_params.len(),
                    function,
                    type_arguments.len()
                );
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L158-158)
```rust
        max_generic_instantiation_length: Some(32),
```
