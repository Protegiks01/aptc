# Audit Report

## Title
Insufficient Signature Verification in Backup Restore Path Allows Storage of Unsigned Ledger Infos

## Summary
The backup/restore code path stores `LedgerInfoWithSignatures` to `LEDGER_INFO_CF_NAME` without cryptographic signature verification when ledger infos match trusted waypoints. This violates the storage layer's integrity assumption that all persisted ledger infos have been properly authenticated.

## Finding Description

The storage layer accepts `LedgerInfoWithSignatures` objects and stores them to the `LEDGER_INFO_CF_NAME` column family through multiple code paths. While the consensus path performs signature verification via `SignatureAggregator::aggregate_and_verify()` [1](#0-0) , and the state sync path verifies through `EpochState::verify()` [2](#0-1) , the backup/restore path has a critical gap.

In the backup restore flow, when a ledger info matches a trusted waypoint, the code skips signature verification during both preheat and execution phases:

**Preheat Phase:** [3](#0-2) 

**Run Phase:** [4](#0-3) 

**Storage to Database:** [5](#0-4) 

The waypoint verification only validates version and hash matches, but does NOT verify the BLS signatures: [6](#0-5) 

The storage functions themselves perform no signature verification: [7](#0-6)  and [8](#0-7) 

Once stored, these unsigned ledger infos can be retrieved without verification through standard database reader interfaces: [9](#0-8) 

## Impact Explanation

**Severity Assessment: Medium**

This issue does NOT meet Critical severity because:
1. Network peers perform signature verification when receiving ledger infos via `EpochChangeProof::verify()` [10](#0-9) , limiting propagation of unsigned data
2. Trusted waypoints are externally verified and not arbitrary values controllable by typical attackers
3. Normal consensus operations create ledger infos through signature aggregation [11](#0-10) 

However, this represents a **defense-in-depth violation** where the storage layer trusts upstream verification rather than enforcing its own invariants. A malicious backup file matching trusted waypoints could cause state inconsistencies requiring manual intervention, meeting Medium severity criteria.

## Likelihood Explanation

**Likelihood: Low**

Exploitation requires:
1. Compromising backup files or convincing operators to restore from malicious backups
2. Crafting ledger infos that match trusted waypoints (waypoints are typically hardcoded/externally verified)
3. The unsigned ledger infos causing observable harm before being replaced by network sync

The attack surface is limited to node operators performing backup/restore operations with compromised backup sources.

## Recommendation

Add signature verification in the backup restore path even when waypoints are trusted. Modify the preheat logic to always verify signatures:

```rust
// In restore.rs preheat_impl, after waypoint check:
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(
        *wp_trusted == wp_li,
        "Waypoints don't match. In backup: {}, trusted: {}",
        wp_li,
        wp_trusted,
    );
    // ADD: Verify signatures even for trusted waypoints
    if let Some(pre_li) = previous_li {
        pre_li
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| anyhow!("Next epoch state not found"))?
            .verify(&li)?;
    }
} else if let Some(pre_li) = previous_li {
    // Existing verification path
    pre_li.ledger_info().next_epoch_state()...
}
```

Alternatively, add verification in the storage layer's `put_ledger_info()` function to enforce invariants at the database boundary.

## Proof of Concept

```rust
// This demonstrates the gap - a ledger info can be stored without signature verification
// if it matches a trusted waypoint during backup restore.

use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    aggregate_signature::AggregateSignature,
    waypoint::Waypoint,
};

// Create ledger info with empty/invalid signatures
let ledger_info = LedgerInfo::new(...);
let waypoint = Waypoint::new_epoch_boundary(&ledger_info)?;

// This ledger info has NO valid signatures
let unsigned_li = LedgerInfoWithSignatures::new(
    ledger_info,
    AggregateSignature::empty()
);

// Waypoint verification passes (only checks version + hash)
assert!(waypoint.verify(unsigned_li.ledger_info()).is_ok());

// But signature verification would fail
assert!(unsigned_li.verify_signatures(&validator_verifier).is_err());

// Yet during backup restore with trusted waypoint, this gets stored to DB
// without signature verification, violating storage integrity assumptions.
```

## Notes

While this finding demonstrates a gap in signature verification, the practical exploitability is limited by network-level re-verification and the difficulty of compromising trusted waypoint-matching backups. This represents a **defense-in-depth issue** rather than a direct consensus corruption vulnerability. The storage layer should enforce its own invariants rather than relying solely on upstream verification to maintain robustness against compromised backup sources and operational errors.

### Citations

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L228-239)
```rust
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L247-253)
```rust
        match self.controller.run_mode.as_ref() {
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;

                EPOCH_ENDING_EPOCH.set(last_li.epoch() as i64);
                EPOCH_ENDING_VERSION.set(last_li.version() as i64);
            },
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L179-189)
```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L93-110)
```rust
    /// Returns the latest ledger info, or None if it doesn't exist.
    pub(crate) fn get_latest_ledger_info_option(&self) -> Option<LedgerInfoWithSignatures> {
        let ledger_info_ptr = self.latest_ledger_info.load();
        let ledger_info: &Option<_> = ledger_info_ptr.deref();
        ledger_info.clone()
    }

    pub(crate) fn get_committed_version(&self) -> Option<Version> {
        let ledger_info_ptr = self.latest_ledger_info.load();
        let ledger_info: &Option<_> = ledger_info_ptr.deref();
        ledger_info.as_ref().map(|li| li.ledger_info().version())
    }

    /// Returns the latest ledger info, or NOT_FOUND if it doesn't exist.
    pub(crate) fn get_latest_ledger_info(&self) -> Result<LedgerInfoWithSignatures> {
        self.get_latest_ledger_info_option()
            .ok_or_else(|| AptosDbError::NotFound(String::from("Genesis LedgerInfo")))
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L186-198)
```rust
    pub(crate) fn put_ledger_info(
        &self,
        ledger_info_with_sigs: &LedgerInfoWithSignatures,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let ledger_info = ledger_info_with_sigs.ledger_info();

        if ledger_info.ends_epoch() {
            // This is the last version of the current epoch, update the epoch by version index.
            batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
        }
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
    }
```

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L167-172)
```rust
                    if let Ok(commit_proof) = partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
```
