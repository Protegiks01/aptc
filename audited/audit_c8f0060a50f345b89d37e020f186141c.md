# Audit Report

## Title
Transaction Filter Service Crash on Unknown Transaction Types During Protocol Upgrades

## Summary
The transaction filter in `transaction_root.rs` uses `.expect()` when converting transaction types, causing the indexer-grpc service to panic and crash when encountering new transaction types added during protocol upgrades. This leads to service unavailability until the service is recompiled with updated protobuf definitions.

## Finding Description

The `matches()` function in the `TransactionRootFilter` implementation contains a critical forward compatibility issue that breaks service availability during protocol upgrades. [1](#0-0) 

The current TransactionType enum has 7 variants defined in the protobuf schema: [2](#0-1) 

When the Aptos protocol is upgraded to add new transaction types (e.g., `TRANSACTION_TYPE_ZK_PROOF = 22`), the following chain of events occurs:

1. New fullnode software is deployed with the updated protobuf definitions
2. The blockchain begins producing transactions with the new type value (22)
3. Existing indexer-grpc services running old binaries still only know about the original 7 transaction type variants
4. When a transaction with the new type is processed, `TransactionType::try_from(22)` fails because 22 is not a recognized variant in the old enum
5. The `.expect("Invalid transaction type")` call panics, crashing the indexer service

The prost-generated enum uses `from_i32()` which returns `None` for unknown values, as shown in the serde deserialization implementation: [3](#0-2) 

This is the only location in the codebase that uses this unsafe pattern with `.expect()`: [4](#0-3) 

## Impact Explanation

This issue qualifies as **High Severity** under the Aptos bug bounty program criteria: "API crashes" and "Significant protocol violations."

**Service Availability Impact:**
- All indexer-grpc services using transaction filters crash immediately upon encountering new transaction types
- Services remain unavailable until recompiled and redeployed with updated protobuf definitions
- Data indexing stops, affecting downstream applications relying on indexed blockchain data
- Multiple indexer instances fail simultaneously, creating a systemic availability problem

**Operational Impact:**
- Forces emergency redeployment of all indexer services during protocol upgrades
- Creates a mandatory coordination window where indexers cannot operate
- Breaks the expectation that auxiliary services can handle unknown transaction types gracefully

While this does not affect consensus nodes or core blockchain operation, the indexer-grpc infrastructure is a critical API component of the Aptos ecosystem.

## Likelihood Explanation

**Likelihood: High**

This issue will definitely occur during protocol evolution:

1. **Protocol upgrades are expected**: Aptos is an actively developed blockchain that will add new transaction types over time (the proto comment even notes "values 5-19 skipped for no reason", suggesting future expansion)

2. **Deployment timing mismatches**: It's operationally difficult to synchronize updates across all indexer deployments simultaneously with protocol upgrades

3. **No graceful degradation**: The code uses `.expect()` which guarantees a panic - there is no fallback path

4. **Systemic impact**: All indexer services using filters will fail identically

The vulnerability activates automatically during normal protocol evolution, requiring no attacker involvement.

## Recommendation

Replace the `.expect()` call with proper error handling that allows unknown transaction types. The filter should either:

1. **Skip unknown types** (filter them out as non-matching):
```rust
if let Some(txn_type) = &self.txn_type {
    match TransactionType::try_from(item.r#type) {
        Ok(actual_type) => {
            if txn_type != &actual_type {
                return false;
            }
        }
        Err(_) => {
            // Unknown transaction type - treat as non-matching
            return false;
        }
    }
}
```

2. **Allow unknown types** (pass them through):
```rust
if let Some(txn_type) = &self.txn_type {
    if let Ok(actual_type) = TransactionType::try_from(item.r#type) {
        if txn_type != &actual_type {
            return false;
        }
    }
    // Unknown types pass through if not explicitly filtered
}
```

The choice depends on desired filter semantics. Option 1 is safer (unknown = filtered out), while Option 2 provides better forward compatibility.

Additionally, add validation in the filter builder to warn about unknown transaction types:

```rust
fn validate_state(&self) -> Result<(), FilterError> {
    if self.success.is_none() && self.txn_type.is_none() {
        return Err(Error::msg("At least one of success or txn_types must be set").into());
    }
    Ok(())
}
```

## Proof of Concept

**Rust Test demonstrating the panic:**

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Transaction, TransactionInfo};
    
    #[test]
    #[should_panic(expected = "Invalid transaction type")]
    fn test_unknown_transaction_type_panics() {
        // Create a filter that checks for user transactions
        let filter = TransactionRootFilterBuilder::default()
            .txn_type(Some(transaction::transaction::TransactionType::User))
            .build()
            .unwrap();
        
        // Create a transaction with an unknown type value (99)
        // This simulates a new transaction type added in a protocol upgrade
        let transaction = Transaction {
            version: 1000,
            r#type: 99, // Unknown transaction type
            info: Some(TransactionInfo {
                success: true,
                ..Default::default()
            }),
            ..Default::default()
        };
        
        // This will panic with "Invalid transaction type"
        filter.matches(&transaction);
    }
    
    #[test]
    fn test_known_transaction_type_works() {
        let filter = TransactionRootFilterBuilder::default()
            .txn_type(Some(transaction::transaction::TransactionType::User))
            .build()
            .unwrap();
        
        let transaction = Transaction {
            version: 1000,
            r#type: 4, // USER transaction type
            info: Some(TransactionInfo {
                success: true,
                ..Default::default()
            }),
            ..Default::default()
        };
        
        // This works fine with known types
        assert!(filter.matches(&transaction));
    }
}
```

**Reproduction Steps:**

1. Deploy an indexer-grpc service with the current transaction-filter code
2. Simulate a protocol upgrade by manually injecting a Transaction protobuf message with `type = 99` (an unknown value)
3. Call the filter's `matches()` function
4. Observe the service panic and crash

**Note:** This vulnerability requires access to the transaction stream, but does not require any malicious action - it occurs naturally during protocol upgrades when new transaction types are introduced.

## Notes

While this is a service availability issue rather than a traditional security exploit, it meets the bug bounty criteria for "API crashes" (High Severity). The vulnerability is deterministic and will definitely occur during protocol evolution, making it a critical operational security concern for the Aptos indexer infrastructure.

The fix is straightforward and should be applied before any protocol upgrades that introduce new transaction types. The indexer infrastructure should handle unknown transaction types gracefully to maintain forward compatibility with protocol evolution.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L59-76)
```rust
    fn matches(&self, item: &Transaction) -> bool {
        if !self
            .success
            .matches_opt(&item.info.as_ref().map(|i| i.success))
        {
            return false;
        }

        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }

        true
    }
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L47-56)
```text
  enum TransactionType {
    TRANSACTION_TYPE_UNSPECIFIED = 0;
    TRANSACTION_TYPE_GENESIS = 1;
    TRANSACTION_TYPE_BLOCK_METADATA = 2;
    TRANSACTION_TYPE_STATE_CHECKPOINT = 3;
    TRANSACTION_TYPE_USER = 4;
    // values 5-19 skipped for no reason
    TRANSACTION_TYPE_VALIDATOR = 20;
    TRANSACTION_TYPE_BLOCK_EPILOGUE = 21;
  }
```

**File:** protos/rust/src/pb/aptos.transaction.v1.serde.rs (L7376-7387)
```rust
            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                use std::convert::TryFrom;
                i32::try_from(v)
                    .ok()
                    .and_then(transaction::TransactionType::from_i32)
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }
```
