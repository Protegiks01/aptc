# Audit Report

## Title
WebAuthn Authenticator Data Validation Missing: User Presence and Verification Flags Not Enforced

## Summary
The WebAuthn signature verification implementation in Aptos Core fails to validate critical authenticator data fields, specifically the User Present (UP) and User Verified (UV) flags mandated by the W3C WebAuthn specification. This allows transactions to be accepted without enforcing user presence or verification, violating the core security guarantees of WebAuthn authentication.

## Finding Description
The WebAuthn verification logic treats authenticator data as an opaque byte array without parsing or validating its internal structure. According to the W3C WebAuthn specification (Section 7.2), verification must include checking that the User Present (UP) bit in the flags byte is set, and optionally that the User Verified (UV) bit is set. [1](#0-0) 

The `verify` function only performs three checks:
1. Challenge matches the transaction hash ✓
2. Verification data construction ✓  
3. Signature verification ✓

However, it completely omits:
- Parsing the authenticator data structure
- Validating the RP ID hash (bytes 0-31)
- Checking the User Present flag (byte 32, bit 0)
- Checking the User Verified flag (byte 32, bit 2)
- Validating the signature counter (bytes 33-36) [2](#0-1) 

The `generate_verification_data` function simply concatenates raw authenticator data bytes without inspecting their contents.

**Attack Scenario:**
1. Attacker uses malicious client software or non-compliant software authenticator
2. Creates authenticator data with UP=0 (user not present) or UV=0 (user not verified)
3. Signs transaction with private key over (authenticator_data || SHA256(client_data_json))
4. Submits transaction to blockchain
5. Transaction is accepted despite lacking user presence/verification

The test data shows proper flags (byte 32 = 0x1D = UP=1, UV=1), but the production code never validates this: [3](#0-2) 

## Impact Explanation
**Medium Severity** - This vulnerability constitutes a significant protocol violation:

1. **Security Guarantee Bypass**: Users who choose WebAuthn for its user presence requirement receive no enforcement of this critical security property
2. **Specification Violation**: Direct violation of W3C WebAuthn specification Section 7.2 verification requirements
3. **Malware Attack Surface**: Malware with system access could submit transactions without user interaction by bypassing user presence checks
4. **Trust Model Violation**: Breaks the "Transaction Validation" invariant (#7) that authentication must enforce all security properties

While not resulting in direct fund theft, this weakens the authentication model and allows automated transaction signing in scenarios where user interaction should be mandatory. This impacts Medium severity per the bug bounty criteria as it creates state inconsistencies (transactions authorized without proper user presence) and represents a significant protocol violation.

## Likelihood Explanation
**Moderate Likelihood:**
- Requires attacker to use malicious client software or non-compliant authenticator
- Hardware authenticators (YubiKey, etc.) correctly set flags, but blockchain cannot verify
- Software-based authenticators more susceptible to manipulation
- Any user can exploit by modifying client code to submit UP=0 transactions
- No special privileges or validator access required
- Violates documented WebAuthn specification that users expect to be followed

## Recommendation
Implement proper authenticator data parsing and validation according to W3C WebAuthn specification:

```rust
fn parse_and_validate_authenticator_data(
    authenticator_data: &[u8],
    require_user_verification: bool,
) -> Result<()> {
    if authenticator_data.len() < 37 {
        return Err(anyhow!("Authenticator data too short"));
    }
    
    // Extract flags byte (byte 32)
    let flags = authenticator_data[32];
    
    // Bit 0: User Present (UP)
    const UP_FLAG: u8 = 0b00000001;
    if (flags & UP_FLAG) == 0 {
        return Err(anyhow!("User Present flag not set in authenticator data"));
    }
    
    // Bit 2: User Verified (UV) - if required
    if require_user_verification {
        const UV_FLAG: u8 = 0b00000100;
        if (flags & UV_FLAG) == 0 {
            return Err(anyhow!("User Verified flag not set in authenticator data"));
        }
    }
    
    Ok(())
}
```

Then add validation call in the `verify` function: [4](#0-3) 

Insert after line 145:
```rust
// Validate authenticator data flags per WebAuthn spec
parse_and_validate_authenticator_data(
    self.authenticator_data.as_slice(),
    false, // Set true if UV required
)?;
```

## Proof of Concept

```rust
#[test]
fn test_webauthn_accepts_invalid_user_present_flag() {
    use crate::transaction::webauthn::{AssertionSignature, PartialAuthenticatorAssertionResponse};
    use aptos_crypto::{secp256r1_ecdsa::PrivateKey, signing_message, HashValue};
    
    // Create authenticator data with UP=0 (invalid)
    let mut invalid_authenticator_data = vec![
        73, 150, 13, 229, 136, 14, 140, 104, 116, 52, 23, 15, 100, 118, 96, 91, 
        143, 228, 174, 185, 162, 134, 50, 199, 153, 92, 243, 186, 131, 29, 151, 99,
        0x1C, // Byte 32: flags with UP=0 (bit 0 clear), UV=1 (bit 2 set) = 0b00011100
        0, 0, 0, 0
    ];
    
    let raw_txn = get_test_raw_transaction(sender_address, 0, None, None, None, None);
    let signing_message = signing_message(&raw_txn).unwrap();
    let challenge = HashValue::sha3_256_of(signing_message.as_slice());
    
    // Create client data with correct challenge
    let client_data = CollectedClientData {
        ty: ClientDataType::Get,
        challenge: String::from(Bytes::from(challenge.to_vec())),
        origin: "http://localhost:5173".to_string(),
        cross_origin: None,
        unknown_keys: Default::default(),
    };
    let client_data_json = serde_json::to_vec(&client_data).unwrap();
    
    // Sign with the invalid authenticator data
    let verification_data = [
        &invalid_authenticator_data[..],
        &sha256(&client_data_json)
    ].concat();
    
    let private_key = PrivateKey::generate_for_testing();
    let signature = private_key.sign_arbitrary_message(&verification_data);
    
    let paar = PartialAuthenticatorAssertionResponse::new(
        AssertionSignature::Secp256r1Ecdsa { signature },
        invalid_authenticator_data,
        client_data_json,
    );
    
    // This should FAIL but currently PASSES
    let result = paar.verify(&raw_txn, &AnyPublicKey::secp256r1_ecdsa(private_key.public_key()));
    assert!(result.is_err(), "Transaction with UP=0 should be rejected but was accepted!");
}
```

## Notes

The referenced test transaction file only loads JSON data and does not constitute the vulnerability itself. The actual vulnerability exists in the production verification code. While hardware authenticators will set flags correctly, the blockchain must still validate them to:
1. Enforce the security properties users expect
2. Detect non-compliant or malicious authenticators  
3. Comply with WebAuthn specification requirements
4. Prevent malware-based automated signing attacks

### Citations

**File:** types/src/transaction/webauthn.rs (L14-29)
```rust
/// Returns the binary concatenation of
/// 1. [`authenticator_data_bytes`](PartialAuthenticatorAssertionResponse) and
/// 2. SHA-256 hash of [`client_data_json`](PartialAuthenticatorAssertionResponse),
///
/// See <https://www.w3.org/TR/webauthn-3/#sctn-verifying-assertion>
fn generate_verification_data(authenticator_data_bytes: &[u8], client_data_json: &[u8]) -> Vec<u8> {
    // Let hash be the result of computing a hash over the clientData using SHA-256.
    let client_data_json_hash = sha256(client_data_json);
    // Binary concatenation of authData and hash.
    // Note: This is compatible with signatures generated by FIDO U2F
    // authenticators. See §6.1.2 FIDO U2F Signature Format Compatibility
    // See <https://www.w3.org/TR/webauthn-3/#sctn-fido-u2f-sig-format-compat>
    [authenticator_data_bytes, &client_data_json_hash]
        .concat()
        .to_vec()
}
```

**File:** types/src/transaction/webauthn.rs (L134-165)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        message: &T,
        public_key: &AnyPublicKey,
    ) -> Result<()> {
        let collected_client_data: CollectedClientData =
            serde_json::from_slice(self.client_data_json.as_slice())?;
        let challenge_bytes = Bytes::try_from(collected_client_data.challenge.as_str())
            .map_err(|e| anyhow!("Failed to decode challenge bytes {:?}", e))?;

        // Check if expected challenge and actual challenge match. If there's no match, throw error
        verify_expected_challenge_from_message_matches_actual(message, challenge_bytes.as_slice())?;

        // Generates binary concatenation of authenticator_data and hash(client_data_json)
        let verification_data = generate_verification_data(
            self.authenticator_data.as_slice(),
            self.client_data_json.as_slice(),
        );

        // Note: We must call verify_arbitrary_msg instead of verify here. We do NOT want to
        // use verify because it BCS serializes and prefixes the message with a hash
        // via the signing_message function invocation
        match (&public_key, &self.signature) {
            (
                AnyPublicKey::Secp256r1Ecdsa { public_key },
                AssertionSignature::Secp256r1Ecdsa { signature },
            ) => signature.verify_arbitrary_msg(&verification_data, public_key),
            _ => Err(anyhow!(
                "WebAuthn verification failure, invalid key, signature pairing"
            )),
        }
    }
```

**File:** types/src/transaction/webauthn.rs (L320-323)
```rust
    static AUTHENTICATOR_DATA: &[u8] = &[
        73, 150, 13, 229, 136, 14, 140, 104, 116, 52, 23, 15, 100, 118, 96, 91, 143, 228, 174, 185,
        162, 134, 50, 199, 153, 92, 243, 186, 131, 29, 151, 99, 29, 0, 0, 0, 0,
    ];
```
