# Audit Report

## Title
Consensus Liveness Failure: SecretShareManager Panics on Blocks Without Encrypted Transactions

## Summary
When secret sharing is enabled at the epoch level, the `SecretShareManager` unconditionally expects all blocks to have encrypted transactions requiring secret share derivation. However, blocks without encrypted transactions cause the decryption pipeline to drop the secret share channel sender without sending, resulting in a panic when `SecretShareManager` awaits the future. This causes validator node crashes and consensus liveness failure.

## Finding Description

The vulnerability occurs through a critical interaction between the decryption pipeline and the secret share management system when secret sharing is enabled.

**1. Decryption Pipeline Early Exit**

When a block contains no encrypted transactions, `decrypt_encrypted_txns` returns early without sending through the `derived_self_key_share_tx` channel, causing the oneshot sender to be dropped. [1](#0-0) 

**2. Channel Receiver Awaiting Dropped Sender**

The `secret_sharing_derive_self_fut` is created to await the receiver end of the channel. When the sender is dropped without sending, the receiver returns `Err(RecvError)`, which is mapped to a `TaskError`. [2](#0-1) 

**3. Unchecked Panic in SecretShareManager**

The `process_incoming_block` method uses two consecutive `.expect()` calls on the future result. The first `.expect()` panics when the future returns a `TaskError` from the dropped channel, with the message "Decryption share computation is expected to succeed". [3](#0-2) 

**4. Unconditional Block Processing**

All blocks received by `SecretShareManager` are processed through `process_incoming_blocks` and `process_incoming_block` without checking whether they contain encrypted transactions. Every block's round is added to `pending_secret_key_rounds` regardless of content. [4](#0-3) 

**5. SecretShareManager Instantiation**

When secret sharing is enabled via `SecretShareConfig`, the `make_secret_sharing_manager` method creates and spawns a `SecretShareManager` instance that receives all ordered blocks. [5](#0-4) 

**6. Coordinator Routing**

When both rand and secret sharing are enabled, the coordinator routes all blocks to both managers unconditionally, sending every block to the secret share manager input channel. [6](#0-5) 

**Attack Scenario:**

1. Secret sharing is enabled at the epoch level (legitimate configuration)
2. `SecretShareManager` is instantiated and running, receiving all consensus blocks
3. A block proposer creates a block containing only regular transactions (no encrypted transactions)
4. All validators receive this block through consensus
5. Each validator's execution pipeline processes the block:
   - `decrypt_encrypted_txns` detects no encrypted transactions and returns early without sending
   - The `derived_self_key_share_tx` sender is dropped
   - `secret_sharing_derive_self_fut` awaits the receiver and gets `RecvError` mapped to `TaskError`
6. `SecretShareManager` awaits this future in `process_incoming_block`
7. The first `.expect()` fails and the validator node **panics** with "Decryption share computation is expected to succeed"
8. All validators crash simultaneously, causing **total consensus liveness failure**

## Impact Explanation

This is a **Critical Severity** vulnerability meeting the Aptos bug bounty criteria for "Total Loss of Liveness/Network Availability":

- **Network Halt**: All validators running with secret sharing enabled will panic and crash when processing any block without encrypted transactions
- **Complete Consensus Failure**: No blocks can be committed as all validators are unable to progress
- **Non-recoverable Without Intervention**: The network cannot make progress until nodes are restarted and the configuration is changed or code is patched

The vulnerability requires **no Byzantine behavior** - it's triggered by a legitimate block that happens to contain no encrypted transactions, making it an operational hazard rather than a deliberate attack vector. Any honest validator proposing a normal block will trigger the crash across all validators.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will occur with certainty under the following conditions:

1. **Secret sharing is enabled** (a legitimate feature configuration for encrypted transaction support)
2. **Any block without encrypted transactions is proposed** (the normal case - most blocks contain only regular transactions, not encrypted ones)

The issue requires:
- No special privileges (any validator can propose such a block during their turn)
- No Byzantine collusion or malicious behavior
- No complex timing or state manipulation
- Just normal consensus operation with standard block proposals

The issue is **deterministic** - every validator will crash when processing such a block. This makes it a severe operational risk that would manifest immediately upon enabling secret sharing if any blocks lack encrypted transactions.

## Recommendation

Modify the decryption pipeline to always send through the channel, even when no encrypted transactions are present:

In `consensus/src/pipeline/decryption_pipeline_builder.rs`, change the early return to send `None` through the channel:

```rust
if encrypted_txns.is_empty() {
    derived_self_key_share_tx
        .send(None)
        .expect("must send properly");
    return Ok((
        unencrypted_txns,
        max_txns_from_block_to_execute,
        block_gas_limit,
    ));
}
```

Then modify `SecretShareManager::process_incoming_block` to handle the `None` case gracefully:

```rust
async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
    let futures = block.pipeline_futs().expect("pipeline must exist");
    let maybe_self_secret_share = futures
        .secret_sharing_derive_self_fut
        .await
        .expect("Decryption share computation is expected to succeed");
    
    // If no encrypted transactions, skip secret sharing for this block
    let Some(self_secret_share) = maybe_self_secret_share else {
        return DropGuard::new(AbortHandle::new_pair().0);
    };
    
    let metadata = self_secret_share.metadata().clone();
    // ... rest of the method
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring an Aptos testnet with secret sharing enabled via `SecretShareConfig`
2. Proposing a block containing only regular transactions (no encrypted transactions)
3. Observing that all validators panic with "Decryption share computation is expected to succeed"
4. Confirming consensus halts as all validators crash

The code paths are deterministic and evident from the static analysis above. A formal Rust test would require mocking the consensus environment but the bug is directly observable from the channel semantics and panic handling.

### Citations

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L49-55)
```rust
        if encrypted_txns.is_empty() {
            return Ok((
                unencrypted_txns,
                max_txns_from_block_to_execute,
                block_gas_limit,
            ));
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L447-455)
```rust
        let (derived_self_key_share_tx, derived_self_key_share_rx) = oneshot::channel();
        let secret_sharing_derive_self_fut = spawn_shared_fut(
            async move {
                derived_self_key_share_rx
                    .await
                    .map_err(|_| TaskError::from(anyhow!("commit proof tx cancelled")))
            },
            Some(&mut abort_handles),
        );
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L112-122)
```rust
    async fn process_incoming_blocks(&mut self, blocks: OrderedBlocks) {
        let rounds: Vec<u64> = blocks.ordered_blocks.iter().map(|b| b.round()).collect();
        info!(rounds = rounds, "Processing incoming blocks.");

        let mut share_requester_handles = Vec::new();
        let mut pending_secret_key_rounds = HashSet::new();
        for block in blocks.ordered_blocks.iter() {
            let handle = self.process_incoming_block(block).await;
            share_requester_handles.push(handle);
            pending_secret_key_rounds.insert(block.round());
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L132-138)
```rust
    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
```

**File:** consensus/src/pipeline/execution_client.rs (L268-309)
```rust
    fn make_secret_sharing_manager(
        &self,
        epoch_state: &Arc<EpochState>,
        config: SecretShareConfig,
        secret_sharing_msg_rx: aptos_channel::Receiver<AccountAddress, IncomingSecretShareRequest>,
        highest_committed_round: u64,
        network_sender: &Arc<NetworkSender>,
    ) -> (
        UnboundedSender<OrderedBlocks>,
        futures_channel::mpsc::UnboundedReceiver<OrderedBlocks>,
        UnboundedSender<ResetRequest>,
    ) {
        let (ordered_block_tx, ordered_block_rx) = unbounded::<OrderedBlocks>();
        let (secret_ready_block_tx, secret_ready_block_rx) = unbounded::<OrderedBlocks>();

        let (reset_tx_to_secret_share_manager, reset_secret_share_manager_rx) =
            unbounded::<ResetRequest>();

        let secret_share_manager = SecretShareManager::new(
            self.author,
            epoch_state.clone(),
            config,
            secret_ready_block_tx,
            network_sender.clone(),
            self.bounded_executor.clone(),
            &self.consensus_config.rand_rb_config,
        );

        tokio::spawn(secret_share_manager.start(
            ordered_block_rx,
            secret_sharing_msg_rx,
            reset_secret_share_manager_rx,
            self.bounded_executor.clone(),
            highest_committed_round,
        ));

        (
            ordered_block_tx,
            secret_ready_block_rx,
            reset_tx_to_secret_share_manager,
        )
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L333-339)
```rust
                let entry = select! {
                    Some(ordered_blocks) = ordered_block_rx.next() => {
                        let _ = rand_manager_input_tx.send(ordered_blocks.clone()).await;
                        let _ = secret_share_manager_input_tx.send(ordered_blocks.clone()).await;
                        let first_block_id = ordered_blocks.ordered_blocks.first().expect("Cannot be empty").id();
                        inflight_block_tracker.insert(first_block_id, (ordered_blocks, false, false));
                        inflight_block_tracker.entry(first_block_id)
```
