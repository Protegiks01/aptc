# Audit Report

## Title
Missing Request Origin Validation in Remote State View Service Enables Message Spoofing and Response Misdirection

## Summary
The `RemoteStateViewService::handle_message()` function lacks any validation to verify that incoming state value requests originate from the shard they claim to represent. An attacker with network access to the coordinator can craft malicious `RemoteKVRequest` messages with arbitrary `shard_id` values, causing the coordinator to route responses to unintended shards. This enables message spoofing, execution corruption, and denial of service attacks in the distributed execution system.

## Finding Description

The `RemoteStateViewService` is responsible for processing state value requests from executor shards in Aptos's distributed execution architecture. When a request is received, the service deserializes the message payload and extracts a `shard_id` field that determines where the response should be sent. [1](#0-0) 

The `shard_id` is extracted directly from the deserialized request without any validation: [2](#0-1) 

The response is then routed to the channel corresponding to this untrusted `shard_id`: [3](#0-2) 

The `RemoteKVRequest` structure contains a `shard_id` field that is entirely controlled by the sender: [4](#0-3) 

The gRPC server implementation obtains the `remote_addr` from incoming requests but never uses it for validation: [5](#0-4) 

**Attack Scenario:**

1. Attacker gains network access to the coordinator's gRPC endpoint (e.g., through compromised shard node or internal network access)
2. Attacker crafts a malicious `RemoteKVRequest` with:
   - `shard_id`: 2 (targeting legitimate shard 2)
   - `keys`: Arbitrary state keys or malicious query patterns
3. Coordinator processes the request, queries its state view, and serializes the response
4. Coordinator sends response to `kv_tx[2]`, polluting shard 2's response channel
5. Shard 2 receives unexpected state values, potentially using them in execution
6. Execution results become incorrect, potentially causing consensus divergence

**Broken Invariants:**

1. **Message Authenticity**: No validation that messages originate from claimed sources
2. **Deterministic Execution**: If shards receive incorrect state values, execution results diverge
3. **Access Control**: Unauthenticated access to state querying functionality

## Impact Explanation

This vulnerability qualifies as **HIGH SEVERITY** under Aptos bug bounty criteria for the following reasons:

**Validator Node Disruption:**
- Flooding a shard's response channel with spoofed messages causes legitimate requests to timeout
- Execution delays and failures disrupt validator node operations
- Recovery requires manual intervention to clear channels and restart services

**Significant Protocol Violations:**
- Complete absence of message authentication violates fundamental security principles
- Defense-in-depth failure - even trusted networks should authenticate messages
- Violates the principle that all validators must produce identical execution results

**Potential for Execution Corruption:**
- If a shard receives spoofed state values before legitimate ones arrive, it may use incorrect data
- Incorrect state values lead to incorrect transaction execution
- Different shards may compute different results, risking consensus safety

**Information Disclosure:**
- Attacker can query arbitrary state keys from the coordinator's state view
- State values are routed to attacker-controlled or observable shard channels
- Enables reconnaissance of validator state and internal data structures

The impact exceeds simple DoS because it enables execution corruption and violates the message authenticity invariant critical to distributed systems security.

## Likelihood Explanation

**Attacker Prerequisites:**
- Network access to the coordinator's gRPC endpoint
- Knowledge of the gRPC protocol and message format
- Ability to craft BCS-serialized `RemoteKVRequest` messages

**Likelihood Assessment: MEDIUM-HIGH**

While the executor-service is designed for internal deployment, several factors increase likelihood:

1. **No Authentication Barrier**: Zero technical obstacles once network access is obtained
2. **Compromised Node Scenario**: If any shard node is compromised, attacker has network access
3. **Internal Threat**: Malicious insider with access to internal network
4. **Configuration Errors**: Accidental exposure of coordinator endpoint
5. **Adjacent Vulnerabilities**: Network segmentation bypass or firewall misconfiguration

The attack is trivial to execute once access is obtained - simply send a crafted gRPC message. No cryptographic operations or complex exploitation is required.

## Recommendation

Implement request origin validation by verifying that incoming messages originate from the expected source. Two approaches are recommended:

**Approach 1: Source IP Validation**

Maintain a mapping of shard IDs to their expected socket addresses and validate that requests originate from the correct source:

```rust
pub fn handle_message(
    message: Message,
    expected_shard_addresses: Arc<Vec<SocketAddr>>, // New parameter
    actual_sender: SocketAddr, // New parameter from gRPC layer
    state_view: Arc<RwLock<Option<Arc<S>>>>,
    kv_tx: Arc<Vec<Sender<Message>>>,
) {
    let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
    let (shard_id, state_keys) = req.into();
    
    // Validate request origin
    if shard_id >= expected_shard_addresses.len() {
        error!("Invalid shard_id {} from {}", shard_id, actual_sender);
        return;
    }
    
    let expected_addr = expected_shard_addresses[shard_id];
    if actual_sender.ip() != expected_addr.ip() {
        error!(
            "Origin validation failed: shard {} expected from {} but received from {}",
            shard_id, expected_addr, actual_sender
        );
        return;
    }
    
    // Continue with validated request...
}
```

**Approach 2: Mutual TLS Authentication (Preferred)**

Implement TLS with client certificates for mutual authentication:

1. Each shard obtains a signed certificate identifying its shard_id
2. Coordinator validates client certificates during TLS handshake
3. Extract authenticated shard_id from certificate and compare with message payload
4. Reject mismatches

This provides cryptographic authentication and is the industry standard for distributed systems security.

## Proof of Concept

```rust
#[cfg(test)]
mod security_tests {
    use super::*;
    use aptos_types::state_store::state_key::StateKey;
    use crossbeam_channel::unbounded;
    
    #[test]
    fn test_message_spoofing_vulnerability() {
        // Setup: Create channels for 3 shards
        let (tx0, rx0) = unbounded();
        let (tx1, rx1) = unbounded();
        let (tx2, rx2) = unbounded();
        let kv_tx = Arc::new(vec![tx0, tx1, tx2]);
        
        // Create a mock state view
        let state_view = Arc::new(RwLock::new(Some(create_mock_state_view())));
        
        // Attack: Craft a request claiming to be from shard 0 but targeting shard 2
        let malicious_request = RemoteKVRequest::new(
            2, // Target shard 2's response channel
            vec![StateKey::raw(b"test_key".to_vec())]
        );
        
        let malicious_message = Message::new(
            bcs::to_bytes(&malicious_request).unwrap()
        );
        
        // Execute the vulnerable handler
        RemoteStateViewService::<MockStateView>::handle_message(
            malicious_message,
            state_view,
            kv_tx,
        );
        
        // Verify: Response was delivered to shard 2 (victim)
        assert!(rx2.try_recv().is_ok(), "Shard 2 received spoofed response");
        assert!(rx0.try_recv().is_err(), "Shard 0 (claimed sender) received nothing");
        
        println!("VULNERABILITY CONFIRMED: Message spoofing successful!");
        println!("Attacker claimed to be shard 0 but routed response to shard 2");
    }
}
```

**Steps to Reproduce:**

1. Deploy the executor-service with coordinator and 3 shards
2. From any network-accessible location, send a gRPC request to the coordinator:
   ```
   grpcurl -d '{
     "message": "<base64_encoded_spoofed_RemoteKVRequest>",
     "message_type": "remote_kv_request"
   }' coordinator_address:port aptos.remote_executor.v1.NetworkMessageService/SimpleMsgExchange
   ```
3. Observe that the coordinator processes the request and routes the response to the shard_id specified in the message payload, regardless of the actual sender
4. Target shard receives unexpected response, potentially disrupting its execution

**Notes**

This vulnerability represents a fundamental security design flaw in the remote executor service. The complete absence of message origin validation violates basic distributed systems security principles. While the service may be intended for deployment in trusted networks, defense-in-depth requires authentication even in such environments.

The issue is particularly concerning because:
1. The infrastructure exists to perform validation (remote_addr is obtained)
2. The system architecture includes shard address configuration (remote_shard_addresses)
3. The validation is simply never performed

This suggests an implementation oversight rather than an intentional design decision. Production deployments should implement mutual TLS authentication or equivalent cryptographic authentication mechanisms before exposing this service in any network environment.

### Citations

**File:** execution/executor-service/src/remote_state_view_service.rs (L86-86)
```rust
        let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L89-89)
```rust
        let (shard_id, state_keys) = req.into();
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L121-121)
```rust
        kv_tx[shard_id].send(message).unwrap();
```

**File:** execution/executor-service/src/lib.rs (L68-71)
```rust
pub struct RemoteKVRequest {
    pub(crate) shard_id: ShardId,
    pub(crate) keys: Vec<StateKey>,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L100-107)
```rust
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
```
