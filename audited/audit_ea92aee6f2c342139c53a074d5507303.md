# Audit Report

## Title
Unvalidated OIDC Provider URLs Enable Server-Side Request Forgery (SSRF) and Keyless Account Compromise

## Summary
The Aptos blockchain's JWK consensus system allows arbitrary URLs to be configured as OIDC provider endpoints through governance proposals without any validation. This enables SSRF attacks against all validator nodes and potential compromise of keyless accounts through malicious JWK injection.

## Finding Description

The JWK consensus configuration system accepts OIDC provider URLs through on-chain governance without performing any validation on the URLs. The vulnerability spans multiple layers:

**Move Layer (Configuration Entry Point):**
The `upsert_oidc_provider_for_next_epoch` function accepts arbitrary byte vectors as OIDC provider URLs with no validation. [1](#0-0) 

The `new_oidc_provider` function in the JWK consensus config module similarly creates providers without any URL validation. [2](#0-1) 

**Rust Layer (Type Definitions):**
The Rust type definitions provide no validation - `OIDCProvider` is simply two String fields with no constraints. [3](#0-2) 

**Consensus Layer (URL Usage):**
When JWK consensus runs, validators spawn `JWKObserver` instances for each configured provider, passing the `config_url` directly without validation. [4](#0-3) 

**Network Layer (HTTP Requests):**
The observers make periodic HTTP requests to the configured URLs using the `reqwest` client with no URL filtering or validation. [5](#0-4) [6](#0-5) 

**Attack Path:**
1. Attacker submits a governance proposal to add a malicious OIDC provider with URL pointing to:
   - Internal services (e.g., `http://127.0.0.1:6060`, `http://10.0.0.1/admin`)
   - Cloud metadata services (e.g., `http://169.254.169.254/latest/meta-data/`)
   - Attacker-controlled server serving malicious JWKs
2. Governance proposal passes and the configuration is applied on the next epoch
3. All validators spawn `JWKObserver` instances for the malicious URL
4. Validators make periodic HTTP requests (every 10 seconds) to the malicious URL
5. Attacker achieves SSRF and/or serves malicious JWKs that enter the consensus system

**Security Invariants Broken:**
- **Access Control**: Validators communicate with untrusted, potentially malicious endpoints
- **Trust Model Violation**: System assumes OIDC providers are legitimate trusted entities
- **Validator Security**: Exposes validator infrastructure to SSRF attacks
- **Keyless Authentication Integrity**: Malicious JWKs can compromise keyless accounts

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty Program for multiple reasons:

1. **SSRF Against All Validators**: Every validator node in the network becomes an SSRF bot making requests to attacker-controlled URLs. This can:
   - Expose cloud instance metadata containing credentials (AWS, GCP, Azure IAM keys)
   - Probe and access internal services behind firewalls
   - Leak validator infrastructure topology and IP addresses
   - Enable pivoting attacks into validator private networks

2. **Keyless Account Compromise (Loss of Funds)**: Malicious JWKs served by the attacker's endpoint will be:
   - Observed by validators
   - Passed through JWK consensus
   - Committed to on-chain state via `ObservedJWKs`
   - Used by the authenticator to verify keyless account signatures
   
   This allows attackers to forge signatures for keyless accounts, leading to **direct loss of funds**.

3. **Validator Resource Exhaustion**: URLs pointing to slow/unresponsive servers cause:
   - Tied-up network connections and goroutines
   - Delayed consensus operations if JWK fetching blocks critical paths
   - Potential validator slowdowns affecting network liveness

4. **Network-Wide Impact**: Unlike vulnerabilities affecting individual nodes, this compromises the entire validator set simultaneously since all validators use the same on-chain configuration.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to influence governance (requires stake or social engineering of governance voters)
- Control over a web server to host malicious responses
- No validator collusion or insider access needed

**Complexity: Low**
- Attack is straightforward once governance access is obtained
- No complex cryptographic or consensus manipulation required
- Standard SSRF techniques apply

**Detection Difficulty: High**
- Malicious URLs may appear legitimate (e.g., `https://auth.example.com/.well-known/openid-configuration`)
- No validation logic exists to flag suspicious URLs
- Governance proposals are trusted by design

The main barrier is governance access, but given the high impact (potential loss of all keyless account funds), even a medium likelihood justifies critical severity.

## Recommendation

Implement multi-layered URL validation:

**1. Move Layer Validation:**
Add URL validation in `upsert_oidc_provider_for_next_epoch`:
- Enforce HTTPS-only URLs (reject HTTP)
- Validate URL format and structure
- Maintain an explicit allowlist of trusted OIDC provider domains
- Reject private IP ranges and localhost addresses

**2. Rust Layer Validation:**
Add validation in `OIDCProvider` type construction:
- Parse and validate URLs using the `url` crate
- Check against allowlist of trusted domains
- Reject non-routable addresses (RFC 1918, loopback, link-local)
- Implement domain verification (e.g., require `.well-known/openid-configuration` path)

**3. Network Layer Protection:**
Implement safeguards in the HTTP fetching logic:
- Use timeouts to prevent hanging on slow servers
- Implement rate limiting per provider
- Add circuit breakers for failing providers
- Log all outbound requests for monitoring

**Example Fix (Move Layer):**

```move
public fun upsert_oidc_provider_for_next_epoch(
    fx: &signer, 
    name: vector<u8>, 
    config_url: vector<u8>
): Option<vector<u8>> acquires SupportedOIDCProviders {
    system_addresses::assert_aptos_framework(fx);
    
    // Validate URL format and security
    validate_oidc_provider_url(&config_url);
    
    // Continue with existing logic...
}

fun validate_oidc_provider_url(url: &vector<u8>) {
    // Check HTTPS prefix
    assert!(
        vector::length(url) > 8 && 
        *vector::borrow(url, 0) == 104 && // 'h'
        *vector::borrow(url, 4) == 115,   // 's' in "https"
        error::invalid_argument(EINVALID_PROVIDER_URL)
    );
    
    // Verify against allowlist
    let is_allowed = is_allowed_oidc_provider(url);
    assert!(is_allowed, error::invalid_argument(EUNTRUSTED_PROVIDER));
}

fun is_allowed_oidc_provider(url: &vector<u8>): bool {
    // Maintain allowlist of trusted domains
    // For example: accounts.google.com, facebook.com, etc.
    // This should be governance-configurable but with strict controls
}
```

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
fun test_ssrf_vulnerability(framework: signer) acquires SupportedOIDCProviders {
    // Initialize the system
    initialize(&framework);
    config_buffer::initialize(&framework);
    
    // Attacker submits governance proposal with malicious URL
    // targeting cloud metadata service
    let malicious_issuer = b"https://evil.com";
    let ssrf_url = b"http://169.254.169.254/latest/meta-data/iam/security-credentials/";
    
    // This should be rejected but currently succeeds
    upsert_oidc_provider_for_next_epoch(
        &framework,
        malicious_issuer,
        ssrf_url
    );
    
    // After next epoch, all validators will make requests to this URL
    on_new_epoch(&framework);
    
    // Verify the malicious provider was added
    let providers = borrow_global<SupportedOIDCProviders>(@aptos_framework);
    assert!(vector::length(&providers.providers) == 1, 1);
    
    // In production, this would cause all validators to make HTTP requests
    // to the cloud metadata service, potentially exposing IAM credentials
}

#[test(framework = @aptos_framework)]
fun test_localhost_ssrf(framework: signer) acquires SupportedOIDCProviders {
    initialize(&framework);
    config_buffer::initialize(&framework);
    
    // Attacker targets validator's localhost services
    let malicious_issuer = b"https://evil.com";
    let localhost_url = b"http://127.0.0.1:6060/debug/pprof/";
    
    // This should be rejected but currently succeeds
    upsert_oidc_provider_for_next_epoch(
        &framework,
        malicious_issuer,
        localhost_url
    );
    
    on_new_epoch(&framework);
    
    // Validators would expose their internal debug endpoints
}
```

**Notes:**
- The vulnerability exists across the entire JWK consensus configuration pipeline
- No validation is performed at any layer (Move, Rust types, consensus logic, or network layer)
- All validators are simultaneously affected when malicious URLs are added via governance
- The attack can target internal networks, cloud metadata, or serve malicious JWKs
- Malicious JWKs entering the consensus system can compromise all keyless accounts
- Current implementation trusts governance completely without defense-in-depth
- Fix requires validation at multiple layers with explicit allowlisting of trusted OIDC providers

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L105-107)
```text
    public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {
        OIDCProvider { name, config_url }
    }
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L21-25)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct OIDCProvider {
    pub name: String,
    pub config_url: String,
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```
