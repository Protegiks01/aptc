# Audit Report

## Title
Critical Validator Set Verification Bypass in Backup Verification with skip_epoch_endings Flag

## Summary
The backup verification process contains a critical vulnerability where setting `skip_epoch_endings=true` completely bypasses validator set transition verification, allowing malicious backups signed by arbitrary validator sets to pass verification and potentially be restored into production databases.

## Finding Description

The vulnerability exists in the backup verification coordinator's `run_impl()` function. When the `skip_epoch_endings` flag is set to true, the verifier skips loading epoch ending ledger infos, which contain the authoritative chain of validator set transitions. [1](#0-0) 

When `epoch_history` is `None`, two critical validation points are bypassed:

**In State Snapshot Verification:** [2](#0-1) 

**In Transaction Verification:** [3](#0-2) 

The skipped `verify_ledger_info()` function performs the critical validator set verification: [4](#0-3) 

This verification ensures that each epoch's ledger info is signed by the validator set from the previous epoch, establishing a cryptographic chain of trust from genesis. Specifically, line 306-309 calls the previous epoch's validator set to verify the current ledger info's signatures.

The underlying signature verification happens through `EpochState::verify()`: [5](#0-4) 

**Attack Scenario:**

1. Attacker creates a malicious backup with fabricated state (e.g., inflated balances, modified contracts)
2. Attacker generates their own validator key set (not the legitimate Aptos validators)
3. Attacker signs all ledger infos in the backup with their fake validator keys
4. Attacker runs verification with `--skip-epoch-endings` flag
5. Verification passes because validator set transitions are never checked
6. Malicious backup can be restored into a node's database

This completely undermines the fundamental security invariant that only authorized validators can sign ledger infos that attest to blockchain state.

## Impact Explanation

This vulnerability is **CRITICAL** severity under Aptos Bug Bounty criteria because it enables:

1. **Consensus/Safety Violations**: Different nodes could restore different states from malicious backups, breaking the fundamental consensus invariant that all honest nodes have identical state roots. This violates the "Consensus Safety" invariant.

2. **Loss of Funds**: An attacker could create a backup showing they own tokens they don't actually own, then restore this state to create funds from thin air or steal existing funds.

3. **Non-recoverable Network Partition**: If multiple nodes restore different malicious states, the network could fork permanently, requiring a hard fork to recover.

4. **Validator Set Manipulation**: Attackers could create backups with arbitrary validator sets, potentially bootstrapping malicious validator nodes with fabricated authority.

The vulnerability breaks two critical invariants:
- **Consensus Safety**: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"
- **Cryptographic Correctness**: "BLS signatures, VRF, and hash operations must be secure"

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploitable because:

1. **No Special Access Required**: Any user can create backups and use the `--skip-epoch-endings` flag, which is exposed as a documented command-line option with help text "Skip restoring epoch ending info, used for debugging." [6](#0-5) 

2. **Simple Attack Path**: No complex cryptographic attacks or race conditions are required - just create a malicious backup and use the provided flag.

3. **Operational Temptation**: The flag is designed for "debugging" which means operators might legitimately use it in scenarios where they want faster verification, inadvertently accepting malicious data.

4. **No Runtime Protection**: There are no additional checks or warnings when this flag is used - the verification simply passes silently.

## Recommendation

**Immediate Fix**: Remove the `skip_epoch_endings` flag entirely, or make it only usable in development/test builds with clear warnings.

**Better Fix**: Implement a multi-tier approach:

```rust
async fn run_impl(self) -> Result<()> {
    // ... existing code ...
    
    let epoch_history = if self.skip_epoch_endings {
        // Only allow skipping in non-production environments
        #[cfg(not(debug_assertions))]
        {
            bail!("skip_epoch_endings is not allowed in production builds. \
                   This flag bypasses critical validator set verification and \
                   must only be used in development environments.");
        }
        
        #[cfg(debug_assertions)]
        {
            warn!("WARNING: Skipping epoch ending verification. This bypasses \
                   critical security checks and should NEVER be used with \
                   untrusted backup data.");
            None
        }
    } else {
        Some(Arc::new(
            EpochHistoryRestoreController::new(
                epoch_endings
                    .into_iter()
                    .map(|backup| backup.manifest)
                    .collect(),
                global_opt.clone(),
                self.storage.clone(),
            )
            .run()
            .await?,
        ))
    };
    
    // ... rest of existing code ...
}
```

**Alternative**: If the flag must remain for debugging, add an explicit "trusted backup source" verification mechanism that requires cryptographic proof that the backup comes from a trusted source before allowing epoch ending verification to be skipped.

## Proof of Concept

```rust
// PoC: Demonstrating the vulnerability
// This test shows that a malicious backup with invalid validator signatures
// passes verification when skip_epoch_endings=true

#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519PublicKey};
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo},
        aggregate_signature::AggregateSignature,
    };
    
    #[tokio::test]
    async fn test_malicious_backup_passes_with_skip_epoch_endings() {
        // Step 1: Create a fake validator set (attacker-controlled)
        let attacker_private_key = Ed25519PrivateKey::generate_for_testing();
        let attacker_public_key = Ed25519PublicKey::from(&attacker_private_key);
        
        // Step 2: Create a malicious ledger info with fake state
        let malicious_state_root = HashValue::random(); // Fabricated state
        let ledger_info = LedgerInfo::new(
            BlockInfo::new(
                1, // epoch
                0, // round
                HashValue::zero(),
                malicious_state_root, // MALICIOUS STATE ROOT
                100, // version
                0, // timestamp
                None, // no next epoch state needed for attack
            ),
            HashValue::zero(),
        );
        
        // Step 3: Sign with attacker's key (NOT legitimate validators)
        let malicious_signature = attacker_private_key.sign(&ledger_info).unwrap();
        let aggregated_sig = AggregateSignature::empty(); // Invalid signature
        let li_with_sigs = LedgerInfoWithSignatures::new(
            ledger_info,
            aggregated_sig,
        );
        
        // Step 4: Create backup with malicious ledger info
        // (Implementation details omitted for brevity, but would involve
        //  creating TransactionBackup and StateSnapshotBackup with the
        //  malicious ledger info)
        
        // Step 5: Run verification with skip_epoch_endings=true
        let coordinator = VerifyCoordinator::new(
            storage,
            metadata_cache_opt,
            trusted_waypoints_opt,
            concurrent_downloads,
            0, // start_version
            100, // end_version  
            0, // state_snapshot_before_version
            true, // skip_epoch_endings=true â† THE VULNERABILITY
            false, // validate_modules
            None, // output_transaction_analysis
        ).unwrap();
        
        // Step 6: Verification PASSES even though signatures are invalid!
        let result = coordinator.run().await;
        
        // In a secure system, this should FAIL due to invalid validator signatures
        // But with skip_epoch_endings=true, it PASSES
        assert!(result.is_ok(), "Malicious backup passed verification!");
        
        // Step 7: Now the malicious state with fabricated balances/contracts
        // could be restored into a production database, completely compromising
        // consensus and potentially enabling theft of funds
    }
}
```

**Steps to Reproduce in Practice:**

1. Generate malicious backup files with fabricated state and invalid validator signatures
2. Run: `aptos-db-tool backup verify --skip-epoch-endings --storage-path /path/to/malicious/backup`
3. Observe that verification passes despite invalid signatures
4. Restore the backup: `aptos-db-tool backup restore --skip-epoch-endings --storage-path /path/to/malicious/backup`
5. Node now has completely fabricated state that was never signed by legitimate validators

**Notes**

The `skip_epoch_endings` flag was clearly intended as a debugging aid to speed up verification during development, as indicated by its help text. However, its presence in production builds creates a critical security vulnerability that completely undermines the validator set verification mechanism - the cornerstone of Aptos consensus security. This is particularly dangerous because operators might use this flag in production thinking it's just a performance optimization, without realizing they're accepting potentially malicious data.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L106-121)
```rust
        let epoch_history = if self.skip_epoch_endings {
            None
        } else {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_endings
                        .into_iter()
                        .map(|backup| backup.manifest)
                        .collect(),
                    global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        };
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```
