# Audit Report

## Title
Event Storage Accumulation Without Storage Rent in V2 Pricing Model

## Summary
In Aptos blockchain's V2 storage pricing model (enabled by default with the REFUNDABLE_BYTES feature flag), events incur zero storage fees while still being persisted indefinitely in the database. If node operators disable event pruning or configure very large pruning windows, this creates an economic imbalance where attackers can cause unbounded database growth at minimal cost (only IO gas), without any recurring storage rent mechanism.

## Finding Description

The Aptos blockchain implements two storage pricing models for events:

**V1 Pricing (legacy):** Events are charged `legacy_storage_fee_per_event_byte` (20 octas/byte) as a one-time storage fee at emission time.

**V2 Pricing (default):** With gas feature version â‰¥ 13 and the REFUNDABLE_BYTES feature flag enabled (which is in the default features list), events incur **zero storage fees**. [1](#0-0) [2](#0-1) 

The V2 pricing model's storage fee calculation explicitly returns zero for events: [3](#0-2) 

Events are persisted permanently in the EventStore/RocksDB database. While event pruning is available through the EventStorePruner component, it can be disabled via configuration: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. The network runs with V2 pricing (default configuration with REFUNDABLE_BYTES enabled)
2. A node operator disables event pruning (`enable: false`) or sets a very large `prune_window`
3. An attacker repeatedly emits large events (up to 10MB per transaction via the `max_bytes_all_events_per_transaction` limit)
4. Events accumulate in the database with zero storage fees
5. The attacker only pays IO gas (`STORAGE_IO_PER_EVENT_BYTE_WRITE * event_size`), which is a one-time transaction cost
6. Over time, the database grows unbounded, potentially causing disk exhaustion on affected nodes [6](#0-5) [7](#0-6) 

## Impact Explanation

This is a **Low severity** economic issue as indicated by the question's classification. The impact includes:

- **Node-level resource exhaustion:** Nodes with disabled or misconfigured pruning will experience unbounded database growth, potentially leading to disk space exhaustion
- **Economic imbalance:** Attackers can impose long-term storage costs on node operators while paying only minimal one-time IO gas costs
- **No consensus impact:** This does not affect network consensus, validator operations, or state consistency across properly configured nodes
- **Limited scope:** Only affects individual nodes with non-default configurations

The issue falls under "Non-critical implementation bugs" in the Low Severity category, as it represents an economic model gap where events lack a recurring storage rent mechanism in V2 pricing, allowing indefinite accumulation without ongoing costs.

## Likelihood Explanation

**Likelihood: Medium-Low**

For this issue to manifest:
- The network must use V2 pricing (currently default with REFUNDABLE_BYTES feature)
- Node operators must **explicitly disable** event pruning or configure very large pruning windows (default is enabled with 90M version window)
- Attackers must submit numerous transactions with large event payloads

The default configuration (pruning enabled with 90M version window) mitigates this issue for most nodes. However, node operators who disable pruning for historical data retention or debugging purposes become vulnerable. The attack requires sustained transaction submission but has minimal cost barriers in V2 pricing.

## Recommendation

Implement one or more of the following mitigations:

**1. Enforce Minimum Pruning Window:**
Add configuration validation that prevents complete disabling of event pruning, enforcing a reasonable minimum prune window (e.g., 50M versions):

```rust
// In config/src/config/storage_config.rs
impl ConfigSanitizer for StorageConfig {
    fn sanitize(...) -> Result<(), Error> {
        if config.storage_pruner_config.ledger_pruner_config.enable {
            if config.storage_pruner_config.ledger_pruner_config.prune_window < 50_000_000 {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Ledger prune_window must be at least 50M versions for security".to_string(),
                ));
            }
        } else {
            // Warn operators about the risk of disabling pruning
            warn!("Event pruning is DISABLED - this may cause unbounded database growth");
        }
        // ... existing checks
    }
}
```

**2. Reintroduce Minimal Storage Fees for Events in V2:**
Even in V2 pricing, consider charging a minimal storage fee for events to create economic disincentives for spam:

```rust
// In aptos-move/aptos-vm-types/src/storage/space_pricing.rs
pub fn legacy_storage_fee_per_event(
    &self,
    params: &TransactionGasParameters,
    event: &ContractEvent,
) -> Fee {
    match self {
        Self::V1 => {
            NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
        },
        Self::V2 => {
            // Instead of 0, charge a minimal fee (e.g., 1 octa/byte)
            NumBytes::new(event.size() as u64) * FeePerByte::new(1)
        },
    }
}
```

**3. Add Event Size/Count Monitoring:**
Implement runtime monitoring and alerting for excessive event accumulation rates to detect potential attacks early.

## Proof of Concept

While a full Move test demonstrating disk exhaustion would require actual disk space consumption over time, here's a conceptual demonstration:

```rust
// Conceptual PoC - demonstrates zero storage fees for events in V2
#[test]
fn test_v2_pricing_zero_event_storage_fees() {
    use aptos_types::on_chain_config::Features;
    
    let mut features = Features::default(); // REFUNDABLE_BYTES enabled by default
    let gas_feature_version = 14; // V2 pricing active
    
    let pricing = DiskSpacePricing::new(gas_feature_version, &features);
    
    // Create a large event (1MB)
    let large_event = create_test_event(1024 * 1024);
    
    let params = TransactionGasParameters::default();
    let storage_fee = pricing.legacy_storage_fee_per_event(&params, &large_event);
    
    // Assert that storage fee is ZERO in V2 pricing
    assert_eq!(storage_fee, Fee::new(0));
    
    // With pruning disabled, this event persists forever with zero storage cost
    // Only IO gas (one-time) is charged, not recurring storage rent
}
```

**Attack Script (Conceptual):**
```rust
// Attacker submits transactions that emit maximum allowed events
for _ in 0..10000 {
    // Each transaction emits 10MB of events (the maximum)
    let txn = create_transaction_with_max_events();
    submit_transaction(txn);
    // Cost: Only IO gas per transaction
    // Result: 100GB of event data accumulated
    // Storage cost to attacker: ZERO (in V2 pricing)
    // Storage cost to node operators: Significant disk space
}
```

## Notes

This finding directly addresses the security question: "Are events subject to storage rent, or can historical TokenClaimEvent data accumulate indefinitely?"

**Answer:** In V2 pricing (current default), events are **NOT** subject to storage rent (zero storage fees), and historical event data **CAN** accumulate indefinitely if pruning is disabled or misconfigured. While IO gas provides some economic friction, it is a one-time transaction cost, not a recurring storage rent mechanism that would normally prevent unbounded accumulation of historical data.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L57-69)
```rust
    /// Calculates the storage fee for an event.
    pub fn legacy_storage_fee_per_event(
        &self,
        params: &TransactionGasParameters,
        event: &ContractEvent,
    ) -> Fee {
        match self {
            Self::V1 => {
                NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
            },
            Self::V2 => 0.into(),
        }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L222-222)
```rust
            FeatureFlag::REFUNDABLE_BYTES,
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L195-202)
```rust
        // Events (no event fee in v2)
        let event_fee = change_set.events_iter().fold(Fee::new(0), |acc, event| {
            acc + pricing.legacy_storage_fee_per_event(params, event)
        });
        let event_discount = pricing.legacy_storage_discount_for_events(params, event_fee);
        let event_net_fee = event_fee
            .checked_sub(event_discount)
            .expect("event discount should always be less than or equal to total amount");
```

**File:** config/src/config/storage_config.rs (L327-341)
```rust
pub struct LedgerPrunerConfig {
    /// Boolean to enable/disable the ledger pruner. The ledger pruner is responsible for pruning
    /// everything else except for states (e.g. transactions, events etc.)
    pub enable: bool,
    /// This is the default pruning window for any other store except for state store. State store
    /// being big in size, we might want to configure a smaller window for state store vs other
    /// store.
    pub prune_window: u64,
    /// Batch size of the versions to be sent to the ledger pruner - this is to avoid slowdown due to
    /// issuing too many DB calls and batch prune instead. For ledger pruner, this means the number
    /// of versions to prune a time.
    pub batch_size: usize,
    /// The offset for user pruning window to adjust
    pub user_pruning_window_offset: u64,
}
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L192-222)
```rust
    pub(crate) fn prune_event_indices(
        &self,
        start: Version,
        end: Version,
        mut indices_batch: Option<&mut SchemaBatch>,
    ) -> Result<Vec<usize>> {
        let mut ret = Vec::new();

        let mut current_version = start;

        for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
            let events = events?;
            ret.push(events.len());

            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
            current_version += 1;
        }

        Ok(ret)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L169-172)
```rust
            max_bytes_all_events_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_events_per_transaction"},
            10 << 20, // all events from a single transaction are 10MB max
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L296-301)
```rust
    pub fn io_gas_per_event(
        &self,
        event: &ContractEvent,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_EVENT_BYTE_WRITE * NumBytes::new(event.size() as u64)
    }
```
