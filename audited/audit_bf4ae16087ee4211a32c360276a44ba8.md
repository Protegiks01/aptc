# Audit Report

## Title
Unmitigated Error Response Size Leading to Resource Exhaustion via Logging

## Summary
Malicious peers can send arbitrarily large error responses (up to 64 MiB) that bypass the `max_num_response_bytes` validation and trigger unrate-limited warning logs, potentially causing disk space exhaustion on victim nodes through the peer monitoring service client.

## Finding Description
The peer monitoring service client implements a size check for successful responses but fails to apply the same validation to error responses from peers. [1](#0-0) 

When a peer sends back a `PeerMonitoringServiceError` (either `InternalError(String)` or `InvalidRequest(String)`), the client deserializes this error without checking its size against `max_num_response_bytes` (default 100 KB). [2](#0-1) 

These errors are then logged using `warn!` with the full error object included, which writes the entire error string to disk: [3](#0-2) 

The error struct uses `#[schema(debug)]` annotation, causing the full Debug representation (including the complete error string) to be logged: [4](#0-3) 

**Attack Path:**
1. Attacker operates multiple malicious peer nodes that connect to victim validators
2. When victim sends monitoring requests (NodeInfo every 15s, LatencyPing every 30s, NetworkInfo every 60s), malicious peers respond with `PeerMonitoringServiceError::InternalError()` containing strings up to the network limit (64 MiB) [5](#0-4) 
3. Each error response triggers a warning log that writes the entire 64 MiB string to disk
4. With N malicious peers and ~4 requests/minute/peer, disk usage grows at approximately N × 4 × 64 MiB per minute

The `get_label()` function itself is not the vulnerability—it returns bounded static strings—but the logging of the full error object that includes `get_label()` calls is the issue: [6](#0-5) 

## Impact Explanation
**Low Severity** - This meets the criteria for resource exhaustion attacks. While it doesn't directly compromise consensus safety or cause fund loss, sustained disk space exhaustion could eventually impact node availability if logs fill the disk. The impact is limited because:
- Client controls request rate (not the malicious peer)
- Requires multiple coordinated malicious peers for significant impact  
- Attack speed is bounded by request intervals (15-60 seconds)
- Does not affect consensus, execution, or state integrity

## Likelihood Explanation
**Medium Likelihood** - The attack is feasible for any network peer to execute:
- No special privileges required
- Trivial to implement (send large error strings in responses)
- Client will continue querying malicious peers unless manually disconnected
- No per-peer banning mechanism exists in the peer monitoring service (unlike the storage service moderator)

However, real-world impact is limited by:
- Modern validators typically have ample disk space (hundreds of GB to TB)
- Log rotation systems would mitigate sustained attacks
- Network operators can manually disconnect malicious peers

## Recommendation
**Solution 1: Apply size validation to error responses**
Add a size check before deserializing/processing peer monitoring service error responses: [7](#0-6) 

Modify to validate the serialized size of error responses before logging.

**Solution 2: Add rate-limited logging for errors**
Use the `sample!` macro with `SampleRate::Duration` to rate-limit error logging per peer, similar to other components: [8](#0-7) 

**Solution 3: Implement peer scoring/banning**
Add an unhealthy peer tracking mechanism similar to the storage service moderator to temporarily ignore peers sending oversized or frequent error responses.

## Proof of Concept
```rust
// Malicious peer server response handler
use aptos_peer_monitoring_service_types::{
    PeerMonitoringServiceError, PeerMonitoringServiceMessage,
};

// In malicious server's request handler:
fn handle_request(request: PeerMonitoringServiceRequest) 
    -> Result<PeerMonitoringServiceResponse, PeerMonitoringServiceError> {
    // Create a 64 MiB error string
    let large_error_string = "A".repeat(64 * 1024 * 1024);
    
    // Return as internal error
    Err(PeerMonitoringServiceError::InternalError(large_error_string))
}

// This response will:
// 1. Pass network deserialization (under 64 MiB limit)
// 2. Bypass max_num_response_bytes check (only applies to Ok responses)
// 3. Get logged in full by the warn! macro
// 4. Write 64 MiB to disk per request
```

**Notes**
- The vulnerability exists because error responses are exempt from the `max_num_response_bytes` validation applied to successful responses
- The `get_label()` function itself is secure (returns static strings with bounded cardinality)
- The metrics collection using `get_label()` is also safe (no cardinality explosion)
- The core issue is the unrate-limited logging of potentially large error payloads from untrusted peers
- While marked as Low severity in the original question, sustained exploitation across many peers could impact node operations

### Citations

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L134-142)
```rust
            // Verify the response respects the message size limits
            if let Err(error) =
                sanity_check_response_size(max_num_response_bytes, &monitoring_service_response)
            {
                peer_state_value
                    .write()
                    .handle_monitoring_service_response_error(&peer_network_id, error);
                return;
            }
```

**File:** peer-monitoring-service/client/src/network.rs (L41-59)
```rust
        let response = self
            .network_client
            .send_to_peer_rpc(
                PeerMonitoringServiceMessage::Request(request),
                timeout,
                recipient,
            )
            .await
            .map_err(|error| Error::NetworkError(error.to_string()))?;
        match response {
            PeerMonitoringServiceMessage::Response(Ok(response)) => Ok(response),
            PeerMonitoringServiceMessage::Response(Err(err)) => {
                Err(Error::PeerMonitoringServiceError(err))
            },
            PeerMonitoringServiceMessage::Request(request) => Err(Error::NetworkError(format!(
                "Got peer monitoring request instead of response! Request: {:?}",
                request
            ))),
        }
```

**File:** peer-monitoring-service/client/src/network.rs (L116-124)
```rust
        Err(error) => {
            warn!(
                (LogSchema::new(LogEntry::SendRequest)
                    .event(LogEvent::ResponseError)
                    .request_type(request.get_label())
                    .request_id(request_id)
                    .peer(peer_network_id)
                    .error(&error))
            );
```

**File:** peer-monitoring-service/client/src/logging.rs (L10-14)
```rust
#[derive(Schema)]
pub struct LogSchema<'a> {
    name: LogEntry,
    #[schema(debug)]
    error: Option<&'a Error>,
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** peer-monitoring-service/client/src/error.rs (L25-35)
```rust
impl Error {
    /// Returns a summary label for the error
    pub fn get_label(&self) -> &'static str {
        match self {
            Self::NetworkError(_) => "network_error",
            Self::PeerMonitoringServiceError(_) => "peer_monitoring_service_error",
            Self::RpcError(_) => "rpc_error",
            Self::UnexpectedError(_) => "unexpected_error",
        }
    }
}
```

**File:** peer-monitoring-service/client/src/peer_states/mod.rs (L76-79)
```rust
    sample!(
        SampleRate::Duration(Duration::from_secs(METRICS_FREQUENCY_SECS)),
        update_peer_state_metrics(&peer_monitor_state, &connected_peers_and_metadata)?;
    );
```
