# Audit Report

## Title
Indexer Fails to Detect Partial Object Deletion When Resource Group Members Remain

## Summary
The Aptos indexer's object deletion detection logic only checks for deletion of the entire `ObjectGroup` resource group, but fails to detect when an object is effectively deleted by removing its `ObjectCore` while leaving other resource group members behind. This creates a state inconsistency where the indexer shows objects as existing when they are actually deleted on-chain.

## Finding Description

The vulnerability exists in the indexer's `from_delete_resource()` function, which only detects object deletions when the entire `ObjectGroup` is deleted: [1](#0-0) 

This check is insufficient because the Move object framework's `delete()` function only removes `ObjectCore` and optionally `Untransferable`: [2](#0-1) 

The codebase explicitly acknowledges this limitation with a TODO comment: [3](#0-2) 

**How the vulnerability manifests:**

1. Multiple resource types can be members of `ObjectGroup`, including custom user-defined resources marked with `#[resource_group_member(group = aptos_framework::object::ObjectGroup)]`

2. When an object has multiple resources in its `ObjectGroup` and `object::delete()` is called, only `ObjectCore` is removed. Other resources remain in the group.

3. The resource group deletion logic determines that if `post_group_size > 0`, the group is modified rather than deleted: [4](#0-3) 

4. The write set will contain a `WriteResource` (modification) for `ObjectGroup`, not a `DeleteResource`.

5. The indexer's check for `"0x1::object::ObjectGroup"` deletion fails, and the object is not marked as deleted in the database.

**Exploitation scenario:**

A user can create an object with `ObjectCore` plus additional custom resources that are members of `ObjectGroup`. When they call `object::delete()` without properly removing all custom resources first, the indexer will fail to detect the deletion, causing the database to show the object as still existing when on-chain it has no `ObjectCore` and is effectively deleted.

## Impact Explanation

This is a **Medium severity** vulnerability per the Aptos bug bounty criteria for "State inconsistencies requiring intervention":

- **Data Inconsistency**: The indexer database incorrectly shows objects as existing when they're actually deleted (no `ObjectCore` means they cannot be accessed or transferred)
- **Query Inaccuracy**: REST API and GraphQL queries return incorrect data about object ownership and existence
- **Integration Failures**: Wallets, DApps, block explorers, and other off-chain systems relying on indexed data will display phantom objects
- **Manual Intervention Required**: Fixing requires database corrections or full reindexing
- **No Fund Loss**: This is an off-chain indexer issue, not an on-chain vulnerability affecting funds or consensus

The impact is limited to off-chain data consistency and does not affect on-chain state, consensus, or fund security, placing it firmly in the Medium category.

## Likelihood Explanation

**High likelihood** of occurrence:

- The vulnerability exists in production code with an acknowledged TODO
- Any developer creating objects with custom resources who doesn't carefully manage cleanup can trigger it
- The framework provides many examples of resources that are `ObjectGroup` members (fungible assets, tokens, custom game assets)
- No runtime checks prevent partial deletion
- Testing in `resource_groups.rs` confirms partial deletion is supported by the VM [5](#0-4) 

## Recommendation

Implement object deletion detection based on `ObjectCore` removal rather than (or in addition to) `ObjectGroup` deletion:

```rust
pub fn from_delete_resource(
    delete_resource: &DeleteResource,
    txn_version: i64,
    write_set_change_index: i64,
    object_mapping: &HashMap<CurrentObjectPK, CurrentObject>,
    conn: &mut PgPoolConnection,
) -> anyhow::Result<Option<(Self, CurrentObject)>> {
    let resource_type = delete_resource.resource.to_string();
    
    // Check for either ObjectGroup deletion (full) or ObjectCore deletion (partial)
    if resource_type == "0x1::object::ObjectGroup" || 
       resource_type == "0x1::object::ObjectCore" {
        // ... existing logic to mark object as deleted
    } else {
        Ok(None)
    }
}
```

Alternatively, track modifications to `ObjectGroup` and check if `ObjectCore` is still present within the group's remaining resources.

## Proof of Concept

```move
module attacker::partial_deletion_exploit {
    use aptos_framework::object::{Self, DeleteRef, ExtendRef};
    use std::signer;

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct CustomData has key {
        value: u64,
    }

    /// Creates an object and partially deletes it, bypassing indexer detection
    public entry fun exploit(creator: &signer) {
        // Step 1: Create a new object (adds ObjectCore to ObjectGroup)
        let constructor_ref = object::create_object(signer::address_of(creator));
        let delete_ref = object::generate_delete_ref(&constructor_ref);
        let extend_ref = object::generate_extend_ref(&constructor_ref);
        
        // Step 2: Add CustomData to the same ObjectGroup
        let obj_signer = object::generate_signer_for_extending(&extend_ref);
        move_to(&obj_signer, CustomData { value: 42 });
        
        // Step 3: Call object::delete() which removes ObjectCore but leaves CustomData
        object::delete(delete_ref);
        
        // Result: 
        // - On-chain: ObjectCore is gone, object is effectively deleted
        // - ObjectGroup still exists (contains CustomData)
        // - Indexer: Sees WriteResource for ObjectGroup (modification), not DeleteResource
        // - Indexer database: Still shows object as existing with is_deleted=false
    }
}
```

**Expected behavior**: The indexer should mark the object as deleted when `ObjectCore` is removed, regardless of whether other resources remain in the `ObjectGroup`.

**Actual behavior**: The indexer only marks objects as deleted when the entire `ObjectGroup` is removed, missing partial deletions where `ObjectCore` is gone but other resources remain.

### Citations

**File:** crates/indexer/src/models/v2_objects.rs (L108-118)
```rust
    /// This handles the case where the entire object is deleted
    /// TODO: We need to detect if an object is only partially deleted
    /// using KV store
    pub fn from_delete_resource(
        delete_resource: &DeleteResource,
        txn_version: i64,
        write_set_change_index: i64,
        object_mapping: &HashMap<CurrentObjectPK, CurrentObject>,
        conn: &mut PgPoolConnection,
    ) -> anyhow::Result<Option<(Self, CurrentObject)>> {
        if delete_resource.resource.to_string() == "0x1::object::ObjectGroup" {
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L413-428)
```text
    /// Removes from the specified Object from global storage.
    public fun delete(self: DeleteRef) acquires Untransferable, ObjectCore {
        let object_core = move_from<ObjectCore>(self.self);
        let ObjectCore {
            guid_creation_num: _,
            owner: _,
            allow_ungated_transfer: _,
            transfer_events,
        } = object_core;

        if (exists<Untransferable>(self.self)) {
            let Untransferable {} = move_from<Untransferable>(self.self);
        };

        event::destroy_handle(transfer_events);
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L207-214)
```rust
        // Create an op to encode the proper kind for resource group operation.
        let metadata_op = if post_group_size.get() == 0 {
            MoveStorageOp::Delete
        } else if pre_group_size.get() == 0 {
            MoveStorageOp::New(Bytes::new())
        } else {
            MoveStorageOp::Modify(Bytes::new())
        };
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L335-358)
```rust
    // Delete the first and verify the second remains
    let result = h.run_entry_function(
        &user_account,
        str::parse(&format!("0x{}::primary::remove", primary_addr.to_hex())).unwrap(),
        vec![],
        vec![],
    );
    assert_success!(result);

    let secondary = h
        .read_resource_from_resource_group::<Secondary>(
            &user_addr,
            group_tag.clone(),
            secondary_tag.clone(),
        )
        .unwrap();
    assert_eq!(secondary.value, 5);
    let primary = h.read_resource_from_resource_group::<Primary>(
        &user_addr,
        group_tag.clone(),
        primary_tag.clone(),
    );
    assert!(primary.is_none());
    assert!(h.read_resource_raw(&user_addr, group_tag.clone()).is_none());
```
