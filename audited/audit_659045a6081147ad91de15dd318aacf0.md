# Audit Report

## Title
Missing Validator Set Consistency Validation in DKG Transcript Aggregation

## Summary
The `TranscriptAggregationState::new()` function does not validate that `dkg_pub_params` and `epoch_state` contain consistent validator sets, allowing mismatched verifiers to be used during transcript aggregation. This causes verification to check against different validator sets, potentially leading to signature verification failures and invalid transcript aggregation.

## Finding Description

The vulnerability exists in the initialization of `TranscriptAggregationState` where two separate validator verifiers are stored without consistency validation: [1](#0-0) 

During transcript aggregation, these verifiers are used for different verification steps: [2](#0-1) 

The `verify_transcript_extra` function maps dealer indices to validator addresses using `epoch_state.verifier`: [3](#0-2) 

While `verify_transcript` maps dealer indices using `dkg_pub_params.verifier` and retrieves public keys for signature verification: [4](#0-3) 

If the validator sets differ in membership or ordering, dealer index 'N' could map to validator A in `epoch_state.verifier` but validator B in `dkg_pub_params.verifier`, causing signature verification to use incorrect public keys.

The only existing validation checks epoch equality but not validator set consistency: [5](#0-4) 

The `dkg_pub_params` is constructed from `DKGSessionMetadata` received via on-chain events: [6](#0-5) 

While `epoch_state` comes from on-chain config payloads: [7](#0-6) 

Although both sources should read from the same on-chain stake module, state inconsistencies, race conditions, or Move implementation bugs could cause mismatches.

## Impact Explanation

**Severity: High** (Validator node slowdowns / Significant protocol violations)

If triggered, this vulnerability causes:
- **DKG Protocol Failure**: Legitimate transcripts are rejected due to signature verification failures, preventing DKG completion
- **Randomness Generation Failure**: Without successful DKG, on-chain randomness cannot be generated
- **Denial of Service**: All validators in the network experience the same failure, causing system-wide DKG unavailability

This meets High severity criteria as it causes significant protocol violations and affects validator node operations, though it does not directly cause consensus safety violations or fund loss.

## Likelihood Explanation

**Likelihood: Low to Medium**

This vulnerability requires validator set inconsistencies between two on-chain data sources. While unlikely in normal operation since both sources read from the stake module, it could be triggered by:

1. **Implementation bugs** in Move contracts that manage validator sets
2. **State inconsistencies** during epoch transitions
3. **Race conditions** if validator set updates occur between reading config payload and processing DKG events
4. **Event replay scenarios** where old events are delivered with current epoch state

The defense-in-depth principle dictates that Rust validation should not trust on-chain data consistency without verification, making this a valid concern even if primary cause is elsewhere.

## Recommendation

Add validator set consistency validation in `TranscriptAggregationState::new()`:

```rust
pub fn new(
    start_time: Duration,
    my_addr: AccountAddress,
    dkg_pub_params: DKG::PublicParams,
    epoch_state: Arc<EpochState>,
) -> anyhow::Result<Self> {
    // Validate epoch consistency
    ensure!(
        dkg_pub_params.pvss_config.epoch == epoch_state.epoch,
        "DKG public params epoch {} does not match epoch state epoch {}",
        dkg_pub_params.pvss_config.epoch,
        epoch_state.epoch
    );
    
    // Validate validator set consistency
    let dkg_validators = dkg_pub_params.verifier.get_ordered_account_addresses();
    let epoch_validators = epoch_state.verifier.get_ordered_account_addresses();
    ensure!(
        dkg_validators == epoch_validators,
        "DKG public params validator set does not match epoch state validator set"
    );
    
    Ok(Self {
        start_time,
        my_addr,
        valid_peer_transcript_seen: false,
        trx_aggregator: Mutex::new(TranscriptAggregator::default()),
        dkg_pub_params,
        epoch_state,
    })
}
```

Update the call site to handle the Result: [8](#0-7) 

Change to propagate validation errors properly.

## Proof of Concept

```rust
#[test]
fn test_mismatched_validator_sets_detection() {
    use aptos_types::dkg::dummy_dkg::DummyDKG;
    
    // Create epoch state with validators [V1, V2, V3]
    let validators_v1 = vec![
        validator_consensus_info(addr1, pk1, 100),
        validator_consensus_info(addr2, pk2, 100),
        validator_consensus_info(addr3, pk3, 100),
    ];
    let verifier_v1 = ValidatorVerifier::new(validators_v1.clone());
    let epoch_state = Arc::new(EpochState::new(10, verifier_v1));
    
    // Create DKG metadata with different ordering [V1, V3, V2]
    let validators_v2 = vec![
        validator_consensus_info(addr1, pk1, 100),
        validator_consensus_info(addr3, pk3, 100), // Swapped
        validator_consensus_info(addr2, pk2, 100), // Swapped
    ];
    let metadata = DKGSessionMetadata {
        dealer_epoch: 10,
        randomness_config: RandomnessConfigMoveStruct::default(),
        dealer_validator_set: validators_v2.clone(),
        target_validator_set: validators_v2,
    };
    
    let pub_params = DummyDKG::new_public_params(&metadata);
    
    // This should FAIL with current implementation (no validation)
    // With recommended fix, this should return an error
    let result = TranscriptAggregationState::<DummyDKG>::new(
        Duration::from_secs(0),
        addr1,
        pub_params,
        epoch_state,
    );
    
    // Expected: Err("validator set does not match")
    // Actual (current): Ok(...) - vulnerability present
    assert!(result.is_err(), "Should detect validator set mismatch");
}
```

## Notes

This is a defense-in-depth issue where the Rust layer assumes on-chain data consistency without validation. While the Move layer should ensure consistency, the Rust implementation should not trust external data sources implicitly. The vulnerability is exploitable only if upstream components (Move contracts, state management) have bugs, but those bugs could exist and remain undetected without this validation layer.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L42-57)
```rust
    pub fn new(
        start_time: Duration,
        my_addr: AccountAddress,
        dkg_pub_params: DKG::PublicParams,
        epoch_state: Arc<EpochState>,
    ) -> Self {
        //TODO(zjma): take DKG threshold as a parameter.
        Self {
            start_time,
            my_addr,
            valid_peer_transcript_seen: false,
            trx_aggregator: Mutex::new(TranscriptAggregator::default()),
            dkg_pub_params,
            epoch_state,
        }
    }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L301-309)
```rust
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
```

**File:** types/src/dkg/real_dkg/mod.rs (L351-361)
```rust
        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();
```

**File:** dkg/src/dkg_manager/mod.rs (L314-314)
```rust
        let public_params = DKG::new_public_params(dkg_session_metadata);
```

**File:** dkg/src/dkg_manager/mod.rs (L442-448)
```rust
        if self.epoch_state.epoch != session_metadata.dealer_epoch {
            warn!(
                "[DKG] event (from epoch {}) not for current epoch ({}), ignoring",
                session_metadata.dealer_epoch, self.epoch_state.epoch
            );
            return Ok(());
        }
```

**File:** dkg/src/epoch_manager.rs (L158-162)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");

        let epoch_state = Arc::new(EpochState::new(payload.epoch(), (&validator_set).into()));
```

**File:** dkg/src/agg_trx_producer.rs (L57-62)
```rust
        let agg_state = Arc::new(TranscriptAggregationState::<DKG>::new(
            start_time,
            my_addr,
            params,
            epoch_state,
        ));
```
