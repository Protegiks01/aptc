# Audit Report

## Title
Indexer Ownership History Corruption: Multiple TransferEvents for Same Token Lost in Single Transaction

## Summary
The Aptos indexer fails to correctly process multiple `TransferEvent` occurrences for the same token within a single transaction. When a token is transferred multiple times in one transaction (e.g., A→B→C), only the final transfer event is recorded, causing complete loss of intermediate ownership history and creating incorrect provenance data in the indexer database.

## Finding Description

The vulnerability exists in the token event processing logic where the indexer aggregates token metadata from transaction events. [1](#0-0) 

When processing events from a transaction, the code iterates through all events and uses **assignment** to store `TransferEvent` data in the aggregated metadata mapping. If multiple `TransferEvent` instances reference the same object address within a single transaction, each subsequent event **overwrites** the previous one, rather than collecting all events.

The data structure only supports storing a single transfer event per token: [2](#0-1) 

When ownership records are created from this metadata, only the last transfer is processed: [3](#0-2) 

**Attack Scenario:**

A transaction contains multiple object transfers for the same token:
1. User writes a Move script executing: `object::transfer(signer_A, token, addr_B)` followed by `object::transfer(signer_B, token, addr_C)`
2. Both calls emit `TransferEvent`: Event[0] = `{object: token, from: A, to: B}`, Event[1] = `{object: token, from: B, to: C}`
3. The Move framework emits both events correctly: [4](#0-3) 
4. Indexer processes Event[0], stores it in `aggregated_data.transfer_event`
5. Indexer processes Event[1], **overwrites** the previous event with the same assignment
6. Only Event[1] (B→C) survives in the aggregated data
7. Ownership processing creates records showing B as previous owner and C as current owner
8. **The A→B transfer is completely lost** from the indexer database

The blockchain state correctly shows C as the final owner, but the indexer's historical ownership records are corrupted, showing an incomplete ownership chain that never included A's ownership.

## Impact Explanation

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention" because:

1. **Data Integrity Violation**: The indexer database contains incorrect historical ownership records that do not match the actual sequence of on-chain events
2. **Provenance Corruption**: NFT provenance chains are incomplete, missing intermediate ownership transfers
3. **Intervention Required**: Fixing the incorrect data requires either re-indexing from genesis or complex database corrections
4. **Application Reliability**: Third-party applications (marketplaces, analytics platforms, wallets) relying on indexer data for ownership history will display incorrect information
5. **Trust Erosion**: Users verifying ownership history through indexer APIs receive misleading data, potentially affecting trading decisions

While this does not directly cause fund loss or consensus violations, it creates persistent state inconsistencies in critical infrastructure that Aptos ecosystem participants depend on for accurate historical data.

## Likelihood Explanation

**Likelihood: High**

This issue occurs automatically whenever:
- A Move script or transaction performs multiple transfers of the same token
- Marketplace contracts transfer tokens through escrow before final delivery (listing→escrow→buyer)
- Atomic swap mechanisms involve intermediate token holders
- Token lockup contracts transfer during unlock and subsequent operations

The Move framework explicitly supports and encourages multi-step token operations: [5](#0-4) 

No special privileges are required - any user can submit transactions with multiple transfer calls. The vulnerability is deterministic and affects all such transactions.

## Recommendation

Replace the single `transfer_event` field with a vector to collect all transfer events per token:

```rust
// In v2_token_utils.rs
pub struct TokenV2AggregatedData {
    // ... other fields ...
    pub transfer_events: Vec<(EventIndex, TransferEvent)>, // Changed from Option to Vec
    // ... other fields ...
}

// In token_processor.rs (lines 1172-1184)
if let Some(transfer_event) = TransferEvent::from_event(event, txn_version).unwrap() {
    if let Some(aggregated_data) = 
        token_v2_metadata_helper.get_mut(&transfer_event.get_object_address())
    {
        let index = if index == 0 {
            user_txn.events.len()
        } else {
            index
        };
        // Push instead of assign
        aggregated_data.transfer_events.push((index as i64, transfer_event));
    }
}

// In v2_token_ownerships.rs (get_nft_v2_from_token_data)
// Process ALL transfer events, creating ownership records for each transfer in the chain
for (event_index, transfer_event) in &metadata.transfer_events {
    // Create ownership records for both from and to addresses
    // Ensure chronological ordering is preserved
}
```

This ensures complete ownership history is captured regardless of how many transfers occur in a single transaction.

## Proof of Concept

```move
// PoC Move script demonstrating the vulnerability
script {
    use std::signer;
    use aptos_framework::object;
    
    fun multi_hop_transfer<T: key>(
        account_a: &signer,
        account_b: &signer,
        token: object::Object<T>,
        addr_c: address,
    ) {
        // Transfer 1: A -> B
        // This emits TransferEvent { object: token, from: A, to: B }
        object::transfer(account_a, token, signer::address_of(account_b));
        
        // Transfer 2: B -> C (in same transaction)
        // This emits TransferEvent { object: token, from: B, to: C }
        object::transfer(account_b, token, addr_c);
        
        // Result: Indexer only records B->C transfer
        // The A->B transfer is lost from indexer history
    }
}
```

**Expected Indexer State:** Two ownership records showing A→B→C chain

**Actual Indexer State:** One ownership record showing B→C, missing A entirely

**Blockchain State:** Correct (C is owner), but indexer historical data is incomplete

---

## Notes

This vulnerability affects the **indexer component** specifically, not the core blockchain consensus or Move VM execution. The on-chain state remains correct at all times. However, given that the Aptos indexer is critical infrastructure that applications throughout the ecosystem depend on for historical data queries, and the issue creates persistent database inconsistencies requiring manual intervention to correct, it merits attention as a Medium severity data integrity vulnerability.

### Citations

**File:** crates/indexer/src/processors/token_processor.rs (L1172-1184)
```rust
                if let Some(transfer_event) = TransferEvent::from_event(event, txn_version).unwrap()
                {
                    if let Some(aggregated_data) =
                        token_v2_metadata_helper.get_mut(&transfer_event.get_object_address())
                    {
                        // we don't want index to be 0 otherwise we might have collision with write set change index
                        let index = if index == 0 {
                            user_txn.events.len()
                        } else {
                            index
                        };
                        aggregated_data.transfer_event = Some((index as i64, transfer_event));
                    }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L38-49)
```rust
pub struct TokenV2AggregatedData {
    pub aptos_collection: Option<AptosCollection>,
    pub fixed_supply: Option<FixedSupply>,
    pub fungible_asset_metadata: Option<FungibleAssetMetadata>,
    pub fungible_asset_supply: Option<FungibleAssetSupply>,
    pub fungible_asset_store: Option<FungibleAssetStore>,
    pub object: ObjectWithMetadata,
    pub property_map: Option<PropertyMap>,
    pub token: Option<TokenV2>,
    pub transfer_event: Option<(EventIndex, TransferEvent)>,
    pub unlimited_supply: Option<UnlimitedSupply>,
}
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L166-210)
```rust
        if let Some((event_index, transfer_event)) = &metadata.transfer_event {
            // If it's a self transfer then skip
            if transfer_event.get_to_address() == transfer_event.get_from_address() {
                return Ok(Some((ownership, current_ownership, None, None)));
            }
            Ok(Some((
                ownership,
                current_ownership,
                Some(Self {
                    transaction_version: token_data.transaction_version,
                    // set to negative of event index to avoid collison with write set index
                    write_set_change_index: -1 * event_index,
                    token_data_id: token_data_id.clone(),
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: Some(transfer_event.get_from_address()),
                    storage_id: storage_id.clone(),
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
                Some(CurrentTokenOwnershipV2 {
                    token_data_id,
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: transfer_event.get_from_address(),
                    storage_id,
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    last_transaction_version: token_data.transaction_version,
                    last_transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
            )))
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L548-571)
```text
    inline fun transfer_raw_inner(object: address, to: address) {
        let object_core = borrow_global_mut<ObjectCore>(object);
        if (object_core.owner != to) {
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Transfer {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            } else {
                event::emit_event(
                    &mut object_core.transfer_events,
                    TransferEvent {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            };
            object_core.owner = to;
        };
    }
```

**File:** aptos-move/move-examples/token_objects/token_lockup/sources/token_lockup.move (L60-61)
```text
      // transfer the token to the receiving account before we permanently disable ungated transfer
      object::transfer(creator, token_object, to);
```
