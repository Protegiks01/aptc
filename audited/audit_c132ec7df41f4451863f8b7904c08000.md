# Audit Report

## Title
Consensus Split Risk: No Validator Software Version Validation Before Bytecode Version Activation

## Summary
When new bytecode versions are activated through governance via feature flags (e.g., `VM_BINARY_FORMAT_V10`), there is no mechanism to validate that all active validators have upgraded their software to support the new version. This can cause validators running different software versions to disagree on transaction validity, leading to consensus failure and network partition.

## Finding Description

The Aptos governance system allows activation of new bytecode versions through feature flags without validating that all validators support the new version. This breaks the **Deterministic Execution** invariant, which requires all validators to produce identical state roots for identical blocks.

**The Vulnerability Chain:**

1. **Feature Flag Activation**: Governance proposals enable bytecode version flags (e.g., `VM_BINARY_FORMAT_V10`) via `change_feature_flags_for_next_epoch()`, which are applied immediately at epoch boundaries through `features::on_new_epoch()`. [1](#0-0) 

2. **No Version Tracking**: The `ValidatorInfo` structure tracks only validator addresses, voting power, and network configuration—with no field for software version or feature support capabilities. [2](#0-1) 

3. **Deserializer Configuration**: All validators fetch the `Features` on-chain config and configure their deserializer to accept the maximum enabled bytecode version via `get_max_binary_format_version()`. [3](#0-2) [4](#0-3) 

4. **Consensus Divergence**: When bytecode using new version features is submitted:
   - Validators with upgraded software successfully deserialize and execute the bytecode
   - Validators with old software fail during deserialization because their `Opcodes` enum doesn't include new opcodes (e.g., `ABORT_MSG` for VERSION_10)
   - Old validators reject the transaction with `UNKNOWN_OPCODE` or `MALFORMED` errors
   - Validators disagree on block validity, causing consensus to stall or fork [5](#0-4) 

**Example Scenario:**
- Governance enables `VM_BINARY_FORMAT_V10` (flag 106)
- 60% of validators have upgraded software with VERSION_10 support
- 40% still run old software supporting only up to VERSION_9
- A transaction contains the `ABORT_MSG` opcode (VERSION_10 feature)
- The 60% upgraded validators execute successfully
- The 40% old validators fail with `MALFORMED` or `UNKNOWN_OPCODE`
- Consensus cannot reach 2/3 quorum agreement on the block

## Impact Explanation

**Severity: CRITICAL** (per Aptos Bug Bounty criteria)

This vulnerability causes:

1. **Consensus Safety Violation**: Validators disagree on transaction validity, violating the core safety property that all honest validators must agree on the ledger state.

2. **Network Partition**: The blockchain halts or forks when validators cannot reach consensus. Recovery requires emergency intervention, likely a hardfork to either:
   - Roll back the feature flag activation, or
   - Force all validators to upgrade immediately

3. **Loss of Liveness**: Transaction processing stops during the consensus failure, preventing all blockchain operations including fund transfers, governance actions, and validator rewards.

4. **Non-Recoverable State**: If different validator groups commit different blocks before the split is detected, reconciling the divergent states requires manual intervention and potentially invalidating committed transactions.

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can occur through:

1. **Honest Coordination Failures**: Governance participants may approve version upgrades underestimating the time needed for all validators to upgrade, especially if some validators are geographically distributed or managed by different operators.

2. **Upgrade Timing Windows**: The time between governance proposal passage and epoch boundary activation may be insufficient for all validators to coordinate upgrades, particularly in a decentralized network.

3. **No Pre-Flight Checks**: The system provides no warnings or validation before activation, making it easy to accidentally trigger consensus failures.

4. **Regular Occurrence**: New bytecode versions are a normal part of blockchain evolution, making this a recurring risk with each major upgrade.

The attack requires only a governance proposal (legitimate process) and incomplete validator upgrades (common operational scenario), making it highly likely to occur without additional safeguards.

## Recommendation

Implement a **validator capability reporting and validation system** before feature activation:

### Solution 1: Validator Version Signaling (Recommended)

1. **Add Version Field to ValidatorConfig**:
```move
// In stake.move
struct ValidatorConfig has key, copy, store, drop {
    consensus_pubkey: vector<u8>,
    network_addresses: vector<u8>,
    fullnode_addresses: vector<u8>,
    validator_index: u64,
    // NEW: Software version and supported features
    software_version: u64,
    supported_bytecode_versions: vector<u64>,
}
```

2. **Add Pre-Activation Validation**:
```move
// In features.move
public fun change_feature_flags_for_next_epoch(
    framework: &signer,
    enable: vector<u64>,
    disable: vector<u64>
) acquires PendingFeatures, Features {
    // ... existing code ...
    
    // NEW: Validate all validators support new features
    validate_validator_feature_support(&enable);
    
    // ... rest of function ...
}

fun validate_validator_feature_support(new_features: &vector<u64>) {
    let validator_set = stake::get_validator_set();
    let required_version = get_required_version_for_features(new_features);
    
    new_features.for_each_ref(|feature| {
        validator_set.active_validators.for_each_ref(|validator| {
            assert!(
                validator.config.software_version >= required_version,
                error::invalid_state(EVALIDATORS_NOT_UPGRADED)
            );
        });
    });
}
```

3. **Add Heartbeat Mechanism**: Validators periodically report their software version through consensus messages, and this information is verified before feature activation.

### Solution 2: Grace Period with Quorum Requirement

Add a two-epoch activation process:
1. **Epoch N**: Feature flag is marked "pending", validators signal readiness
2. **Epoch N+1**: If ≥95% of validators signal support, activate; otherwise, abort

### Solution 3: Backward Compatibility Requirement

Enforce that new bytecode versions must be backward compatible for at least one epoch, ensuring old validators can still process transactions during the transition period.

## Proof of Concept

This PoC demonstrates the conceptual vulnerability (actual reproduction requires multi-node setup):

```rust
// Conceptual PoC - demonstrates the issue at the deserialization level
use move_binary_format::deserializer::DeserializerConfig;
use move_binary_format::file_format_common::{VERSION_9, VERSION_10};

fn test_consensus_split_on_version_mismatch() {
    // Simulate two validators with different software versions
    
    // Old validator: Software only supports up to VERSION_9
    let old_validator_config = DeserializerConfig::new(VERSION_9, IDENTIFIER_SIZE_MAX);
    
    // New validator: Software supports VERSION_10 (from on-chain feature flag)
    let new_validator_config = DeserializerConfig::new(VERSION_10, IDENTIFIER_SIZE_MAX);
    
    // Bytecode containing VERSION_10 opcode (ABORT_MSG)
    let bytecode_with_v10_features = create_bytecode_with_abort_msg();
    
    // New validator: Succeeds
    let new_result = CompiledModule::deserialize_with_config(
        &bytecode_with_v10_features,
        &new_validator_config
    );
    assert!(new_result.is_ok());
    
    // Old validator: Fails with UNKNOWN_OPCODE or MALFORMED
    let old_result = CompiledModule::deserialize_with_config(
        &bytecode_with_v10_features,
        &old_validator_config
    );
    assert!(old_result.is_err());
    
    // Validators disagree on transaction validity → CONSENSUS SPLIT
    println!("Consensus split: New validator accepts, old validator rejects");
}
```

**Full reproduction requires**:
1. Set up testnet with mixed validator versions (some supporting V10, some only V9)
2. Submit governance proposal to enable `VM_BINARY_FORMAT_V10`
3. Wait for epoch transition
4. Submit transaction with VERSION_10 bytecode
5. Observe consensus failure when validators disagree

## Notes

This vulnerability is particularly dangerous because:
- It can occur through legitimate governance processes without malicious intent
- The on-chain feature flag system provides no safety checks against premature activation
- Recovery requires emergency coordination and potentially a hardfork
- The issue becomes more likely as the validator set becomes more decentralized with independent operators

The fix requires adding validator capability tracking and validation logic before allowing feature activations that could break consensus.

### Citations

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L804-828)
```text
    /// Enable and disable features for the next epoch.
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L171-175)
```text
    struct ValidatorInfo has copy, store, drop {
        addr: address,
        voting_power: u64,
        config: ValidatorConfig,
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L137-142)
```rust
pub fn aptos_prod_deserializer_config(features: &Features) -> DeserializerConfig {
    DeserializerConfig::new(
        features.get_max_binary_format_version(),
        features.get_max_identifier_size(),
    )
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L1834-1841)
```rust
            Opcodes::ABORT_MSG if cursor.version() < VERSION_10 => {
                return Err(
                    PartialVMError::new(StatusCode::MALFORMED).with_message(format!(
                        "aborting with message not available before bytecode version {}",
                        VERSION_10
                    )),
                );
            },
```
