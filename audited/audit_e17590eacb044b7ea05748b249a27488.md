# Audit Report

## Title
Validator Startup Failure Due to Unhandled Panic in choose_leader() with Empty Validator Set

## Summary
The `choose_leader()` function in the consensus layer panics when given an empty peers vector, and this can occur during critical validator initialization when the on-chain validator set becomes empty after epoch transition. This causes validators configured with `FixedProposer` election type to fail to start, resulting in complete loss of liveness for affected nodes.

## Finding Description

The vulnerability exists in the consensus proposer election mechanism and validator set management:

**Panic Location:** [1](#0-0) 

The `choose_leader()` function uses `.min().expect("No trusted peers found!")` which panics when the input `peers` vector is empty.

**Call Path During Critical Initialization:**

1. The EpochManager is spawned as a tokio task: [2](#0-1) 

2. During startup, before entering the event loop, `await_reconfig_notification()` is called: [3](#0-2) 

3. This triggers `start_new_epoch()` which creates the ValidatorVerifier: [4](#0-3) 

4. For FixedProposer configuration, `choose_leader()` is called with proposers from the verifier: [5](#0-4) 

**Empty Validator Set Can Occur:**

The on-chain `on_new_epoch()` function in the staking module filters validators based on minimum stake without any safeguard against an empty result: [6](#0-5) 

This filtering loop can result in an empty `next_epoch_validators` vector if all validators have `voting_power < minimum_stake`. The empty vector is then assigned to `validator_set.active_validators` without validation.

**Why Existing Safeguards Don't Apply:**

The assertion preventing the last validator from leaving only applies to manual departures: [7](#0-6) 

This check is in `leave_validator_set()` and does NOT protect against automatic filtering during `on_new_epoch()`.

**Attack Path:**

1. A governance proposal raises `minimum_stake` to an extremely high value, OR all validators are slashed below minimum in the same epoch
2. During epoch transition, `on_new_epoch()` filters out all validators
3. All nodes receive the empty `ValidatorSet` in the reconfiguration event
4. Validators configured with `ProposerElectionType::FixedProposer` call `choose_leader(vec![])`
5. Panic: "No trusted peers found!"
6. EpochManager task crashes before entering event loop
7. Affected validators cannot participate in consensus—complete loss of liveness

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

- **Validator node failures**: Affected validators completely fail to start consensus, not just experiencing slowdowns
- **Significant protocol violation**: Violates the availability guarantee that validators should be able to recover from epoch transitions
- **Scope**: While not network-wide (only affects nodes using FixedProposer), this is a complete failure mode for affected validators
- **Unhandled panic**: The panic occurs in a tokio spawned task during initialization with no recovery mechanism

This does not qualify as Critical severity because:
- Not all validators are affected (depends on configuration)
- No funds loss or consensus safety violations
- Network can continue with remaining validators

## Likelihood Explanation

**Medium to Low Likelihood in Production:**

- FixedProposer is marked as "tmp hack" in comments, suggesting limited production use
- However, it remains a valid configuration option in the `ProposerElectionType` enum
- Empty validator sets are theoretically possible through:
  - Governance misconfiguration (raising minimum_stake too high)
  - Widespread slashing events
  - Testnet/devnet misconfigurations
- The vulnerability is latent until triggered by the specific combination of: empty validator set + FixedProposer configuration

**Higher Likelihood in:**
- Development/testing environments where FixedProposer might be used
- Misconfigured private deployments
- Edge cases during governance parameter changes

## Recommendation

**Immediate Fix:**

Add defensive validation in `choose_leader()`:

```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    assert!(!peers.is_empty(), "Cannot choose leader from empty peer set");
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**Comprehensive Fix:**

Add on-chain validation in `stake.move` to prevent empty validator sets:

```move
// After line 1401 in on_new_epoch()
validator_set.active_validators = next_epoch_validators;
assert!(
    vector::length(&validator_set.active_validators) > 0, 
    error::invalid_state(EEMPTY_VALIDATOR_SET)
);
```

**Defense in Depth:**

Add validation in `create_proposer_election()`:

```rust
let proposers = epoch_state
    .verifier
    .get_ordered_account_addresses_iter()
    .collect::<Vec<_>>();
    
ensure!(
    !proposers.is_empty(),
    "Cannot create proposer election with empty validator set"
);
```

## Proof of Concept

**Move Test Scenario:**

```move
#[test(aptos_framework = @0x1, validator1 = @0x123, validator2 = @0x456)]
fun test_empty_validator_set_after_epoch_transition(
    aptos_framework: &signer,
    validator1: &signer,
    validator2: &signer,
) {
    // Setup: Create validators with stake just above minimum
    initialize_test_validator_set(aptos_framework, 1000000); // min stake = 1M
    add_validator(validator1, 1000001);
    add_validator(validator2, 1000002);
    
    // Attack: Governance raises minimum stake dramatically
    staking_config::update_required_stake(aptos_framework, 10000000, 100000000);
    
    // Trigger: Epoch transition
    stake::on_new_epoch();
    
    // Verify: Validator set is now empty
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    assert!(vector::is_empty(&validator_set.active_validators), 0);
    
    // Impact: Subsequent validator startup with FixedProposer will panic
}
```

**Rust Reproduction:**

1. Configure consensus with `ProposerElectionType::FixedProposer(1)`
2. Start node with on-chain config containing empty ValidatorSet
3. Observe panic during `EpochManager::start()` → `await_reconfig_notification()` → `create_proposer_election()` → `choose_leader()`
4. Validator consensus task terminates, node cannot participate in consensus

## Notes

- The vulnerability is in production code but may have limited real-world exposure due to FixedProposer's "temporary" nature
- However, it represents a critical gap in defensive programming where input validation is missing
- The on-chain logic in `stake.move` should be the primary fix point to prevent empty validator sets from ever being created
- Defense-in-depth requires validation at multiple layers: on-chain, consensus initialization, and proposer election

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L20-23)
```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** consensus/src/consensus_provider.rs (L120-120)
```rust
    runtime.spawn(epoch_mgr.start(timeout_receiver, network_receiver));
```

**File:** consensus/src/epoch_manager.rs (L296-303)
```rust
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
```

**File:** consensus/src/epoch_manager.rs (L1165-1168)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
```

**File:** consensus/src/epoch_manager.rs (L1928-1928)
```rust
        self.await_reconfig_notification().await;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```
