# Audit Report

## Title
TOCTOU Race Condition in Block Insertion Allows Consensus DoS via Assertion Failure

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition in `BlockStore::insert_block()` allows a Byzantine validator to insert a block at the same round as `ordered_root`, violating the round ordering invariant. When a descendant of this block is later committed, the `path_from_ordered_root()` traversal fails, triggering an assertion panic that crashes validator nodes and causes network-wide denial of service.

## Finding Description

The vulnerability exists in the round validation logic of `BlockStore::insert_block()`. The function uses a read lock to check that `ordered_root().round() < block.round()` [1](#0-0) , but between this check and the actual block insertion, the `ordered_root` can be updated by another thread calling `send_for_execution()` [2](#0-1) .

**Attack Scenario:**

1. **Race Condition Trigger**: 
   - Thread A (inserting block B with round R): Acquires read lock, checks `ordered_root().round() (R-1) < block.round() (R)` ✓ PASSES
   - Thread A releases read lock
   - Thread B (committing): Acquires write lock, calls `update_ordered_root()` advancing root to round R
   - Thread A continues and inserts block B at round R via `insert_block_inner()`
   - **Result**: Block B with round R exists in tree alongside ordered_root at round R (different block IDs)

2. **Consensus Participation**:
   - Byzantine validator proposes block C at round R+1 with parent = block B
   - Honest validators who have block B in their tree accept block C (passes `insert_block` check since R < R+1)
   - Block C gets window from parent B successfully [3](#0-2) 
   - SafetyRules validates: `C.round (R+1) == C.qc.round (R) + 1` ✓ PASSES [4](#0-3) 
   - Honest validators vote on block C, accumulating 2f+1 votes for a valid QC

3. **Assertion Failure**:
   - When committing block C, `send_for_execution()` calls `path_from_ordered_root(C.id())`
   - The path traversal walks back: C (R+1) → B (R) → stops at B since `B.round() (R) <= root_round (R)` [5](#0-4) 
   - Check fails: `B.id() != ordered_root.id()` since they're different blocks [6](#0-5) 
   - Returns `None`, `unwrap_or_default()` gives empty vector
   - **PANIC**: `assert!(!blocks_to_commit.is_empty())` fails [7](#0-6) 

This breaks the invariant that all non-root blocks in the tree must have `round > ordered_root.round()`, causing a crash when the invalid state is detected during commit path traversal.

## Impact Explanation

**Severity: HIGH (up to $50,000)**

This vulnerability causes **validator node crashes** and **significant protocol violations**, meeting the High severity criteria from the Aptos bug bounty:
- **API crashes**: The assertion panic terminates the validator process
- **Significant protocol violations**: Breaks the consensus round ordering invariant
- **Network liveness impact**: Multiple validators crash simultaneously if they experienced the race, potentially causing temporary loss of consensus if enough validators are affected (approaching the f Byzantine threshold)

While not quite reaching Critical severity (which requires total network partition or permanent liveness loss), this can cause significant disruption requiring validator restarts and potentially delaying block production if a substantial fraction of the validator set is affected.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

The attack requires:
1. **Precise timing**: Byzantine validator must broadcast block B when validators are between the check and commit of competing block A
2. **Network propagation**: Multiple honest validators must receive and process B during the narrow race window
3. **Vote accumulation**: Enough validators (2f+1) must have block B to vote on descendant block C
4. **Natural triggering**: The race can also occur naturally during periods of high consensus activity without malicious intent

While technically difficult to orchestrate reliably across multiple validators, the race window exists during every block commit, making it possible for a determined attacker with network visibility to exploit. Natural occurrence is also possible under heavy load or network delays.

## Recommendation

**Fix: Add atomic check-and-insert with consistent locking**

The round validation must be re-verified under write lock immediately before insertion:

```rust
pub async fn insert_block(&self, block: Block) -> anyhow::Result<Arc<PipelinedBlock>> {
    if let Some(existing_block) = self.get_block(block.id()) {
        return Ok(existing_block);
    }
    
    // Initial check with read lock (fast path)
    ensure!(
        self.inner.read().ordered_root().round() < block.round(),
        "Block with old round"
    );

    let block_window = self
        .inner
        .read()
        .get_ordered_block_window(&block, self.window_size)?;
    
    // Prefetch payloads...
    
    let pipelined_block = PipelinedBlock::new_ordered(block, block_window);
    
    // RE-VERIFY under write lock before insertion
    {
        let mut inner = self.inner.write();
        ensure!(
            inner.ordered_root().round() < pipelined_block.round(),
            "Block with old round (race detected)"
        );
        // Continue with insert_block_inner logic under same write lock
        // or move the check inside insert_block_inner before BlockTree::insert_block
    }
    
    self.insert_block_inner(pipelined_block).await
}
```

Alternatively, move the validation inside `insert_block_inner()` immediately before calling `BlockTree::insert_block()` while holding the write lock.

## Proof of Concept

```rust
// Reproduction test for consensus/src/block_storage/block_store_test.rs

#[tokio::test]
async fn test_race_condition_same_round_as_ordered_root() {
    let (mut playground, block_store) = prepare_playground();
    
    // Setup: Create block A at round 1 that will become ordered root
    let block_a = playground.new_block(1, vec![], vec![]);
    block_store.insert_block(block_a.clone()).await.unwrap();
    block_store.insert_single_quorum_cert(block_a.quorum_cert().clone()).unwrap();
    
    // Prepare block B at round 1 (will be inserted via race)
    let block_b = playground.new_block_with_custom_parent(
        1, 
        block_a.parent_id(), // Same parent as A
        vec![],
        vec![]
    );
    
    // Prepare block C at round 2 with parent B
    let block_c = playground.new_block_with_custom_parent(
        2,
        block_b.id(),
        vec![],
        vec![]
    );
    
    // Simulate race condition:
    // 1. Commit block A (advances ordered_root to round 1)
    block_store.send_for_execution(
        block_a.quorum_cert().into_wrapped_ledger_info()
    ).await.unwrap();
    
    assert_eq!(block_store.ordered_root().round(), 1);
    
    // 2. Forcefully insert block B at round 1 (simulating race)
    // In real scenario, this happens when check passes before commit
    block_store.inner.write().insert_block(
        PipelinedBlock::new_ordered(block_b.clone(), OrderedBlockWindow::empty())
    ).unwrap();
    
    // 3. Insert block C at round 2 (depends on B)
    block_store.insert_block(block_c.clone()).await.unwrap();
    block_store.insert_single_quorum_cert(block_c.quorum_cert().clone()).unwrap();
    
    // 4. Attempt to commit block C - THIS SHOULD PANIC
    let result = block_store.send_for_execution(
        block_c.quorum_cert().into_wrapped_ledger_info()
    ).await;
    
    // Test expects panic from assertion failure
    assert!(result.is_err() || panic::catch_unwind(|| {
        block_store.send_for_execution(/* ... */)
    }).is_err());
}
```

**Notes**
- The TOCTOU race condition is a classic concurrency bug where the check and use are separated by lock release
- The vulnerability manifests when honest validators vote on and commit descendants of the race-inserted block
- Multiple blocks at the same round are technically allowed in the tree (equivocation tracking) [8](#0-7) , but having a non-root block at `ordered_root.round()` violates the implicit invariant that drives path traversal logic
- The fix requires either (1) atomic check-and-insert under write lock, or (2) re-validation after acquiring write lock in `insert_block_inner`

### Citations

**File:** consensus/src/block_storage/block_store.rs (L331-331)
```rust
        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/block_store.rs (L338-338)
```rust
        self.inner.write().update_ordered_root(block_to_commit.id());
```

**File:** consensus/src/block_storage/block_store.rs (L416-419)
```rust
        ensure!(
            self.inner.read().ordered_root().round() < block.round(),
            "Block with old round"
        );
```

**File:** consensus/src/block_storage/block_tree.rs (L290-298)
```rust
        while !current_block.is_genesis_block()
            && current_block.quorum_cert().certified_block().round() >= window_start_round
        {
            if let Some(current_pipelined_block) = self.get_block(&current_block.parent_id()) {
                current_block = current_pipelined_block.block().clone();
                window.push(current_pipelined_block);
            } else {
                bail!("Parent block not found for block {}", current_block.id());
            }
```

**File:** consensus/src/block_storage/block_tree.rs (L327-335)
```rust
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
            } else {
                self.round_to_ids.insert(arc_block.round(), block_id);
            }
```

**File:** consensus/src/block_storage/block_tree.rs (L529-531)
```rust
                Some(ref block) if block.round() <= root_round => {
                    break;
                },
```

**File:** consensus/src/block_storage/block_tree.rs (L540-542)
```rust
        if cur_block_id != root_id {
            return None;
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L159-161)
```rust
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
```
