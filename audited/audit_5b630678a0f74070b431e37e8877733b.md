# Audit Report

## Title
Redis Credentials Exposure in Indexer GRPC Structured JSON Logs

## Summary
The indexer-grpc components log Redis connection URLs directly in error messages without masking embedded credentials. When Redis connections fail, passwords contained in URLs (format: `redis://username:password@host:port/db`) are exposed in structured JSON logs, violating credential confidentiality and enabling potential lateral movement attacks.

## Finding Description

The `RedisUrl` type used throughout the indexer-grpc system derives the `Debug` trait without implementing password masking: [1](#0-0) 

Multiple components log this URL directly in error contexts when Redis connections fail:

**File Store Processor:** [2](#0-1) 

**Cache Worker:** [3](#0-2) 

**Data Service:** [4](#0-3) 

The configuration structure containing these Redis URLs also derives Debug without password protection: [5](#0-4) 

All indexer-grpc services use structured JSON logging: [6](#0-5) 

This contrasts with the secure pattern already established in the codebase for PostgreSQL URLs, which masks passwords in the Debug implementation: [7](#0-6) 

**Attack Path:**
1. Attacker triggers Redis connection failures (network disruption, service attack, or waits for natural failures)
2. Error messages containing full Redis URLs (with passwords) are logged via `with_context()` error chains
3. Logs are captured by monitoring systems, log aggregation platforms, or written to disk
4. Attacker with log access (compromised monitoring, insider threat, or log file access) extracts credentials
5. Attacker uses credentials for lateral movement to Redis or other systems sharing credentials

## Impact Explanation

**Severity: Medium**

This vulnerability constitutes an **information disclosure** issue that falls under the Medium severity category per Aptos bug bounty criteria. While it does not directly cause:
- Consensus violations
- Fund loss or theft
- Network partitioning
- Direct protocol violations

It does enable:
- **Credential exposure**: Redis passwords leak into structured logs that may be stored, transmitted, and aggregated across multiple systems
- **Lateral movement**: Compromised credentials could provide access to sensitive cached blockchain data, enable cache poisoning attacks, or facilitate attacks on other systems if credentials are reused
- **Compliance violations**: Logging credentials violates security best practices (OWASP, PCI-DSS, SOC 2) and could impact audit certifications
- **Log poisoning potential**: Malicious Redis URLs in configurations could inject crafted content into JSON logs, breaking log parsers

The codebase already recognizes this pattern as a security issue, as evidenced by custom Debug implementations for PostgreSQL URLs that mask passwords. The inconsistent application of this protection to Redis URLs represents a security gap.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has high likelihood of occurrence because:

1. **Natural failure scenarios**: Redis connection failures occur regularly due to network issues, service restarts, configuration changes, or infrastructure problems
2. **Triggered by attackers**: Adversaries can deliberately cause Redis connection failures through network attacks or service disruption
3. **Production credential usage**: Production Redis instances typically require authentication, meaning password-containing URLs are standard in real deployments
4. **Wide log distribution**: JSON logs are typically aggregated across multiple systems (Elasticsearch, Splunk, CloudWatch, etc.), increasing exposure surface
5. **Existing pattern**: The codebase already experienced this issue with PostgreSQL credentials, demonstrating real-world applicability

The vulnerability is present in three separate indexer-grpc components, multiplying the exposure points.

## Recommendation

Implement custom `Debug` and `Display` traits for `RedisUrl` that mask passwords before logging, following the established pattern used for PostgreSQL URLs:

**Step 1**: Implement custom Debug for RedisUrl in `ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs`:

```rust
impl fmt::Debug for RedisUrl {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut masked_url = self.0.clone();
        if masked_url.password().is_some() {
            masked_url.set_password(Some("***")).unwrap();
        }
        write!(f, "RedisUrl({})", masked_url)
    }
}

impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let mut masked_url = self.0.clone();
        if masked_url.password().is_some() {
            masked_url.set_password(Some("***")).unwrap();
        }
        write!(f, "{}", masked_url)
    }
}
```

**Step 2**: Remove `Debug` from the derive macro since we're implementing it manually:

```rust
#[derive(Clone, Eq, PartialEq, Serialize)]  // Remove Debug from here
pub struct RedisUrl(pub Url);
```

**Step 3**: Update error messages to avoid direct URL interpolation, or ensure Display trait is used which will mask the password.

**Step 4**: Consider implementing custom Debug for configuration structs containing RedisUrl to ensure nested password masking.

## Proof of Concept

**Scenario**: Simulate Redis connection failure to observe credential leakage in logs.

**Setup**:
1. Create a config file with Redis credentials:
```yaml
health_check_port: 8082
server_config:
  file_store_config:
    file_store_type: LocalFileStore
    local_file_store_path: /tmp/test
  redis_main_instance_address: redis://admin:MySecretP@ssw0rd!@invalid-redis-host:6379
  chain_id: 1
  enable_cache_compression: false
```

2. Run the file store worker:
```bash
cargo run --bin aptos-indexer-grpc-file-store -- --config-path config.yaml
```

**Expected vulnerable output** (JSON log showing password):
```json
{
  "timestamp": "2024-01-15T10:30:45.123Z",
  "level": "ERROR",
  "message": "Create redis client for redis://admin:MySecretP@ssw0rd!@invalid-redis-host:6379 failed",
  "target": "indexer_grpc_file_store::processor"
}
```

**After fix** (password masked):
```json
{
  "timestamp": "2024-01-15T10:30:45.123Z",
  "level": "ERROR", 
  "message": "Create redis client for redis://admin:***@invalid-redis-host:6379 failed",
  "target": "indexer_grpc_file_store::processor"
}
```

**Test validation**:
```rust
#[test]
fn test_redis_url_masks_password_in_debug() {
    let url_with_password = RedisUrl::from_str("redis://user:secret123@localhost:6379").unwrap();
    let debug_output = format!("{:?}", url_with_password);
    assert!(!debug_output.contains("secret123"));
    assert!(debug_output.contains("***"));
}
```

## Notes

This vulnerability demonstrates a **consistency gap** in security practices within the codebase. The PostgreSQL credential masking pattern exists but was not applied uniformly to Redis URLs, suggesting the need for:

1. Security review of all credential-bearing types for proper Debug implementations
2. Linting rules to detect credential types with derived Debug traits
3. Security guidelines requiring password masking in all loggable types containing credentials

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L13-14)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct RedisUrl(pub Url);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L44-58)
```rust
        let conn = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "Create redis client for {} failed",
                    redis_main_instance_address.0
                )
            })?
            .get_tokio_connection_manager()
            .await
            .with_context(|| {
                format!(
                    "Create redis connection to {} failed.",
                    redis_main_instance_address.0
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L84-90)
```rust
        let redis_client = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "[Indexer Cache] Failed to create redis client for {}",
                    redis_main_instance_address
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L109-114)
```rust
        Ok(Self {
            redis_client: Arc::new(
                redis::Client::open(redis_address.0.clone()).with_context(|| {
                    format!("Failed to create redis client for {}", redis_address)
                })?,
            ),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/lib.rs (L13-22)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcFileStoreWorkerConfig {
    pub file_store_config: IndexerGrpcFileStoreConfig,
    pub redis_main_instance_address: RedisUrl,
    pub enable_expensive_logging: Option<bool>,
    pub chain_id: u64,
    #[serde(default = "default_enable_cache_compression")]
    pub enable_cache_compression: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L174-193)
```rust
pub fn setup_logging(make_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write> + Send + Sync>>) {
    let env_filter = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new("info"))
        .unwrap();

    let subscriber = tracing_subscriber::fmt()
        .json()
        .flatten_event(true)
        .with_file(true)
        .with_line_number(true)
        .with_thread_ids(true)
        .with_target(false)
        .with_thread_names(true)
        .with_env_filter(env_filter);

    match make_writer {
        Some(w) => subscriber.with_writer(w).init(),
        None => subscriber.init(),
    }
}
```

**File:** config/src/config/indexer_config.rs (L92-117)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
        f.debug_struct("IndexerConfig")
            .field("enabled", &self.enabled)
            .field("postgres_uri", &postgres_uri)
            .field("processor", &self.processor)
            .field("starting_version", &self.starting_version)
            .field("skip_migrations", &self.skip_migrations)
            .field("check_chain_id", &self.check_chain_id)
            .field("batch_size", &self.batch_size)
            .field("fetch_tasks", &self.fetch_tasks)
            .field("processor_tasks", &self.processor_tasks)
            .field("emit_every", &self.emit_every)
            .field("gap_lookback_versions", &self.gap_lookback_versions)
            .field("ans_contract_address", &self.ans_contract_address)
            .field("nft_points_contract", &self.nft_points_contract)
            .finish()
    }
}
```
