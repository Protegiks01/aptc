# Audit Report

## Title
Memory Exhaustion in Consensus Transaction Deduplication via Large Authenticator Cloning

## Summary
The transaction deduplication logic in the consensus layer clones entire `TransactionAuthenticator` objects for all possible duplicate transactions instead of using references. An attacker can exploit this by sending many transactions with identical (sender, sequence_number) pairs and large multi-signature authenticators, causing up to 1.35 GB of memory allocation per block and validator node slowdowns.

## Finding Description

The vulnerability exists in the `dedup()` function where authenticators are cloned unnecessarily: [1](#0-0) 

The `authenticator()` method returns a **clone** of the entire TransactionAuthenticator, not a reference: [2](#0-1) 

This breaks the **Resource Limits** invariant that "all operations must respect gas, storage, and computational limits."

**Attack Path:**

1. An attacker crafts 10,000 transactions with:
   - Same (sender, sequence_number) pair → all marked as "possible duplicates"
   - Maximum-size authenticators using FeePayer transactions with multiple keyless signers
   - Up to 32 keyless signatures (MAX_NUM_OF_SIGS limit)
   - Each KeylessSignature up to 4,000 bytes [3](#0-2) [4](#0-3) 

2. The deduplication algorithm marks all 10,000 as "possible duplicates": [5](#0-4) 

3. For each possible duplicate, the authenticator is cloned in parallel: [6](#0-5) 

4. Memory calculation:
   - Per transaction: 32 signatures × (4,000 + 232) bytes ≈ 135 KB
   - Total: 10,000 × 135 KB = **1.35 GB** of cloned authenticators

5. This happens **before** signature verification (as documented in code comments), so invalid signatures still trigger the memory allocation: [7](#0-6) 

6. The deduplication is called from BlockPreparer for every block: [8](#0-7) 

## Impact Explanation

**High Severity** - This meets the "Validator node slowdowns" criterion for High severity vulnerabilities (up to $50,000).

The vulnerability allows an attacker to:
- Cause significant memory allocation (1.35 GB) on all validator nodes processing the block
- Trigger parallel cloning via rayon, multiplying memory pressure across CPU cores
- Repeat the attack every block, causing sustained resource exhaustion
- Impact all validators simultaneously as they process the same malicious block

The block size limit allows up to 10,000 transactions: [9](#0-8) 

This directly affects consensus performance and validator node stability, though it does not directly cause consensus safety violations or fund loss.

## Likelihood Explanation

**High Likelihood:**

1. **Low attack complexity**: Attacker simply needs to submit many transactions with the same (sender, sequence_number)
2. **No special permissions required**: Any transaction sender can exploit this
3. **Pre-validation exploitation**: Attack succeeds before signature verification, so even invalid signatures trigger the issue
4. **Guaranteed execution path**: Deduplication runs on every block in consensus
5. **Amplification**: Parallel processing via rayon multiplies the impact

The attacker doesn't need valid signatures or any special blockchain state.

## Recommendation

Replace the cloning `authenticator()` call with the reference-returning `authenticator_ref()` method:

**Current vulnerable code:** [10](#0-9) 

**Fixed code:**
```rust
true => Some((txn.committed_hash(), txn.authenticator_ref())),
```

**Additional changes needed:**

1. Update the type signature to use references:
```rust
let hash_and_authenticators: Vec<Option<(HashValue, &TransactionAuthenticator)>> = ...
```

2. Update the HashSet to use references:
```rust
let mut seen_hashes: HashSet<(HashValue, &TransactionAuthenticator)> = HashSet::new();
```

The `TransactionAuthenticator` type already implements `Hash`, `Eq`, and `PartialEq`: [11](#0-10) 

This makes it safe to use references in a HashSet. The reference-based approach avoids all unnecessary cloning while maintaining identical deduplication semantics.

## Proof of Concept

```rust
#[test]
fn test_memory_exhaustion_via_authenticator_cloning() {
    use crate::txn_hash_and_authenticator_deduper::TxnHashAndAuthenticatorDeduper;
    use crate::transaction_deduper::TransactionDeduper;
    use aptos_types::transaction::{SignedTransaction, RawTransaction, ReplayProtector};
    use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519PublicKey};
    use aptos_keygen::KeyGen;
    
    let deduper = TxnHashAndAuthenticatorDeduper::new();
    
    // Create sender account
    let (privkey, pubkey) = KeyGen::from_os_rng().generate_ed25519_keypair();
    let sender = aptos_types::account_address::from_public_key(&pubkey);
    
    // Create 10,000 transactions with SAME (sender, sequence_number)
    // All will be marked as possible duplicates
    let mut txns = Vec::new();
    for _ in 0..10000 {
        let raw_txn = RawTransaction::new_txn(
            sender,
            ReplayProtector::SequenceNumber(0), // Same sequence number
            aptos_types::transaction::TransactionExecutable::Script(
                aptos_types::transaction::Script::new(vec![0u8; 1000], vec![], vec![])
            ),
            None,
            500_000,
            100,
            0,
            aptos_types::chain_id::ChainId::new(1),
        );
        
        let signed = raw_txn.sign(&privkey, pubkey.clone()).unwrap().into_inner();
        txns.push(signed);
    }
    
    // Measure memory before
    let start_memory = get_current_memory_usage();
    
    // This will clone authenticators for all 10,000 transactions
    let _deduped = deduper.dedup(txns);
    
    // Measure memory after
    let end_memory = get_current_memory_usage();
    
    // With large authenticators, this could be > 1 GB
    let memory_used = end_memory - start_memory;
    println!("Memory used during dedup: {} MB", memory_used / (1024 * 1024));
    
    // Assert demonstrates the vulnerability
    assert!(memory_used > 100_000_000, "Should use significant memory");
}
```

**Notes:**
- The actual PoC requires implementing `get_current_memory_usage()` or using a memory profiler
- With maximum-size keyless authenticators (not shown in simplified PoC), the memory usage would reach 1.35 GB
- The test demonstrates that all 10,000 transactions are processed as duplicates due to identical (sender, seq_no)

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L14-17)
```rust
/// (raw_txn.hash(), authenticator). Both the hash and signature are required because dedup
/// happens before signatures are verified and transaction prologue is checked. (So, e.g., a bad
/// transaction could contain a txn and signature that are unrelated.) If the checks are done
/// beforehand only one of the txn hash or signature would be required.
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L44-55)
```rust
        for (i, txn) in transactions.iter().enumerate() {
            match seen.get(&(txn.sender(), txn.replay_protector())) {
                None => {
                    seen.insert((txn.sender(), txn.replay_protector()), i);
                },
                Some(first_index) => {
                    is_possible_duplicate = true;
                    possible_duplicates[*first_index] = true;
                    possible_duplicates[i] = true;
                },
            }
        }
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L63-71)
```rust
        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();
```

**File:** types/src/transaction/mod.rs (L1234-1236)
```rust
    pub fn authenticator(&self) -> TransactionAuthenticator {
        self.authenticator.clone()
    }
```

**File:** types/src/transaction/authenticator.rs (L32-34)
```rust
/// Maximum number of signatures supported in `TransactionAuthenticator`,
/// across all `AccountAuthenticator`s included.
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/transaction/authenticator.rs (L73-73)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
```

**File:** types/src/keyless/mod.rs (L194-195)
```rust
    /// enforced by our full nodes when they receive TXNs.
    pub const MAX_LEN: usize = 4000;
```

**File:** consensus/src/block_preparer.rs (L99-99)
```rust
            let deduped_txns = txn_deduper.dedup(filtered_txns);
```

**File:** config/src/config/consensus_config.rs (L23-24)
```rust
pub(crate) static MAX_RECEIVING_BLOCK_TXNS: Lazy<u64> =
    Lazy::new(|| 10000.max(2 * MAX_SENDING_BLOCK_TXNS));
```
