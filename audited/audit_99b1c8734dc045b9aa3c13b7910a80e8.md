# Audit Report

## Title
Cryptographic Private Keys Not Securely Erased From Memory and Storage After Use

## Summary
The Aptos secure storage system lacks mechanisms to securely erase cryptographic private keys from memory and persistent storage when they should be permanently deleted. Private keys persist in memory without zeroization, remain in storage files indefinitely, and are not purged from backups, violating the project's own secure coding guidelines.

## Finding Description

The secure storage system used for validator consensus keys has multiple key lifecycle issues:

**1. No Key Deletion API**

The `CryptoStorage` trait provides no method to delete keys. [1](#0-0) 

The `KVStorage` trait only provides `reset_and_clear()` which is test-only and clears ALL data, not individual keys. [2](#0-1) 

**2. No Secure Memory Erasure**

The project's secure coding guidelines explicitly require: "Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys." [3](#0-2) 

However, `Ed25519PrivateKey` does NOT implement the `Drop` trait with zeroization: [4](#0-3) 

Similarly, `bls12381::PrivateKey` (used for consensus keys) also lacks secure erasure: [5](#0-4) 

The `zeroize` crate is not even a dependency of `aptos-crypto`: [6](#0-5) 

**3. Keys Persist in OnDiskStorage**

`OnDiskStorage` writes all keys to an unencrypted JSON file with no deletion mechanism: [7](#0-6) 

The documentation explicitly warns this is insecure: [8](#0-7) 

**4. Consensus Key Storage**

Validator consensus keys are stored via `PersistentSafetyStorage` with no deletion capability: [9](#0-8) 

When keys are rotated, old keys are stored with suffixed names but never deleted: [10](#0-9) 

**5. VaultStorage Deletion is Test-Only**

Even in the production `VaultStorage` backend, key deletion methods are only available for testing: [11](#0-10) 

## Impact Explanation

This constitutes **Medium severity** per the bug bounty criteria: "State inconsistencies requiring intervention."

An attacker who gains access to:
- File system backups containing `OnDiskStorage` files
- Memory dumps or core dumps from validator processes  
- Swap files where key material may have been paged out
- Cloud storage containing backup snapshots

Could recover consensus private keys that should have been permanently deleted. This violates **Cryptographic Correctness** (invariant #10) as keys remain accessible after their intended lifecycle end.

While the attack requires privileged file system or memory access as a prerequisite, defense-in-depth principles mandate that cryptographic material be securely erased to prevent recovery even if such access is obtained. This is especially critical for validator consensus keys where compromise could enable Byzantine behavior.

## Likelihood Explanation

**Likelihood: Medium**

Real-world scenarios where this vulnerability materializes:
1. **Backup Compromise**: Validators perform routine backups. If backup storage is compromised, all historical keys are exposed
2. **Key Rotation**: When validators rotate keys due to suspected compromise, old keys remain in storage/memory, defeating the purpose of rotation
3. **Decommissioning**: When validator nodes are decommissioned, storage media may be disposed without secure erasure
4. **Memory Forensics**: Crash dumps or debugging artifacts may contain private keys

## Recommendation

**Immediate Actions:**

1. Add `zeroize` as a dependency to `aptos-crypto`
2. Implement `Drop` trait with zeroization for all private key types:

```rust
// In crates/aptos-crypto/Cargo.toml
[dependencies]
zeroize = { version = "1.7", features = ["derive"] }

// In ed25519_keys.rs and bls12381_keys.rs
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(ZeroizeOnDrop)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);

#[derive(ZeroizeOnDrop)]
pub struct PrivateKey {
    pub(crate) privkey: blst::min_pk::SecretKey,
}
```

3. Add key deletion methods to the `CryptoStorage` trait:

```rust
pub trait CryptoStorage {
    // Existing methods...
    
    /// Securely deletes a named key from storage
    fn delete_key(&mut self, name: &str) -> Result<(), Error>;
}
```

4. Implement secure deletion in all storage backends
5. Document that `OnDiskStorage` must never be used in production environments

## Proof of Concept

```rust
use aptos_crypto::{ed25519::Ed25519PrivateKey, Uniform};
use aptos_secure_storage::{CryptoStorage, OnDiskStorage, Storage};
use rand::rngs::OsRng;
use std::fs;

fn main() {
    // Create OnDiskStorage
    let storage_path = std::env::temp_dir().join("test_key_persistence.json");
    let mut storage = Storage::from(OnDiskStorage::new(storage_path.clone()));
    
    // Create a private key
    let key = Ed25519PrivateKey::generate(&mut OsRng);
    storage.create_key("test_consensus_key").unwrap();
    
    // Read the storage file - key is present
    let contents = fs::read_to_string(&storage_path).unwrap();
    assert!(contents.contains("test_consensus_key"));
    println!("Key stored: {}", contents);
    
    // Attempt to "delete" by dropping storage
    drop(storage);
    
    // Key STILL persists in file
    let contents_after = fs::read_to_string(&storage_path).unwrap();
    assert!(contents_after.contains("test_consensus_key"));
    println!("Key STILL present after drop: {}", contents_after);
    
    // Key also persists in any backups of this file
    // No API exists to securely erase it
    
    fs::remove_file(storage_path).unwrap();
}
```

## Notes

While `OnDiskStorage` is documented as test-only, the fundamental issues apply across all storage backends:
- VaultStorage has no production API for key deletion
- Private key types lack secure memory erasure
- The secure coding guidelines are violated in production code

This defense-in-depth gap should be addressed even though direct network exploitation is not possible.

### Citations

**File:** secure/storage/src/crypto_storage.rs (L11-65)
```rust
pub trait CryptoStorage {
    /// Securely generates a new named Ed25519 private key. The behavior for calling this interface
    /// multiple times with the same name is implementation specific.
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error>;

    /// Returns the Ed25519 private key stored at 'name'.
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error>;

    /// An optional API that allows importing private keys and storing them at the provided name.
    /// This is not intended to be used in production and the API may throw unimplemented if
    /// not used correctly. As this is purely a testing API, there is no defined behavior for
    /// importing a key for a given name if that name already exists.  It only exists to allow
    /// running in test environments where a set of deterministic keys must be generated.
    fn import_private_key(&mut self, name: &str, key: Ed25519PrivateKey) -> Result<(), Error>;

    /// Returns the Ed25519 private key stored at 'name' and identified by 'version', which is the
    /// corresponding public key. This may fail even if the 'named' key exists but the version is
    /// not present.
    fn export_private_key_for_version(
        &self,
        name: &str,
        version: Ed25519PublicKey,
    ) -> Result<Ed25519PrivateKey, Error>;

    /// Returns the Ed25519 public key stored at 'name'.
    fn get_public_key(&self, name: &str) -> Result<PublicKeyResponse, Error>;

    /// Returns the previous version of the Ed25519 public key stored at 'name'. For the most recent
    /// version, see 'get_public_key(..)' above.
    fn get_public_key_previous_version(&self, name: &str) -> Result<Ed25519PublicKey, Error>;

    /// Rotates an Ed25519 private key. Future calls without version to this 'named' key will
    /// return the rotated key instance. The previous key is retained and can be accessed via
    /// the version. At most two versions are expected to be retained.
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error>;

    /// Signs the provided securely-hashable struct, using the 'named' private
    /// key.
    // The FQDNs on the next line help macros don't remove them
    fn sign<T: aptos_crypto::hash::CryptoHash + serde::Serialize>(
        &self,
        name: &str,
        message: &T,
    ) -> Result<Ed25519Signature, Error>;

    /// Signs the provided securely-hashable struct, using the 'named' and 'versioned' private key. This may fail
    /// even if the 'named' key exists but the version is not present.
    // The FQDNs on the next line help macros, don't remove them
    fn sign_using_version<T: aptos_crypto::hash::CryptoHash + serde::Serialize>(
        &self,
        name: &str,
        version: Ed25519PublicKey,
        message: &T,
    ) -> Result<Ed25519Signature, Error>;
}
```

**File:** secure/storage/src/kv_storage.rs (L25-29)
```rust
    /// Resets and clears all data held in the storage engine.
    /// Note: this should only be exposed and used for testing. Resetting the storage engine is not
    /// something that should be supported in production.
    #[cfg(any(test, feature = "testing"))]
    fn reset_and_clear(&mut self) -> Result<(), Error>;
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L22-24)
```rust
/// An Ed25519 private key
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L41-45)
```rust
#[derive(SerializeKey, DeserializeKey, SilentDebug, SilentDisplay)]
/// A BLS12381 private key
pub struct PrivateKey {
    pub(crate) privkey: blst::min_pk::SecretKey,
}
```

**File:** crates/aptos-crypto/Cargo.toml (L15-76)
```text
[dependencies]
aes-gcm = { workspace = true }
anyhow = { workspace = true }
aptos-crypto-derive = { workspace = true }
arbitrary = { workspace = true, features = ["derive"], optional = true }
ark-bls12-381 = { workspace = true }
ark-bn254 = { workspace = true }
ark-ec = { workspace = true }
ark-ff = { workspace = true }
ark-groth16 = { workspace = true }
ark-poly = { workspace = true }
ark-relations = { workspace = true }
ark-serialize = { workspace = true }
ark-snark = { workspace = true }
ark-std = { workspace = true }
base64 = { workspace = true }
bcs = { workspace = true }
bls12_381 = { workspace = true }
blst = { workspace = true }
blstrs = { workspace = true }
bulletproofs = { workspace = true }
bytes = { workspace = true }
curve25519-dalek = { workspace = true }
curve25519-dalek-ng = { workspace = true }
digest = { workspace = true }
dudect-bencher = { workspace = true }
ed25519-dalek = { workspace = true }
ff = { workspace = true }
group = { workspace = true }
hex = { workspace = true }
hkdf = { workspace = true }
itertools = { workspace = true }
libsecp256k1 = { workspace = true }
merlin = { workspace = true }
more-asserts = { workspace = true }
neptune = { workspace = true }
num-bigint = { workspace = true }
num-integer = { workspace = true }
num-traits = { workspace = true }
once_cell = { workspace = true }
p256 = { workspace = true }
pairing = { workspace = true }
proptest = { workspace = true, optional = true }
proptest-derive = { workspace = true, optional = true }
rand = { workspace = true }
rand_core = { workspace = true }
rayon = { workspace = true }
ring = { workspace = true }
serde = { workspace = true }
serde-name = { workspace = true }
serde_bytes = { workspace = true }
sha2 = { workspace = true }
sha2_0_10_6 = { workspace = true }
sha3 = { workspace = true }
signature = { workspace = true }
slh-dsa = { workspace = true }
static_assertions = { workspace = true }
thiserror = { workspace = true }
tiny-keccak = { workspace = true }
typenum = { workspace = true }
x25519-dalek = { workspace = true }

```

**File:** secure/storage/src/on_disk.rs (L16-27)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
pub struct OnDiskStorage {
    file_path: PathBuf,
    temp_path: TempPath,
    time_service: TimeService,
}
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```

**File:** secure/storage/src/vault.rs (L100-112)
```rust
    #[cfg(any(test, feature = "testing"))]
    fn reset_crypto(&self) -> Result<(), Error> {
        let keys = match self.client().list_keys() {
            Ok(keys) => keys,
            // No keys were found, so there's no need to reset.
            Err(aptos_vault_client::Error::NotFound(_, _)) => return Ok(()),
            Err(e) => return Err(e.into()),
        };
        for key in keys {
            self.client().delete_key(&key)?;
        }
        Ok(())
    }
```
