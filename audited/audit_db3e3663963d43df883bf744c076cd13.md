# Audit Report

## Title
BoundedExecutor Permit Exhaustion Enables Single Validator to Cause Consensus Liveness Failures

## Summary
A malicious validator can monopolize all BoundedExecutor permits by flooding RandGenMessage requests, preventing critical consensus operations like commit message verification from executing. This blocks the consensus pipeline and can cause missed block proposals, violating Aptos' Byzantine fault tolerance guarantees.

## Finding Description

The Aptos consensus system uses a shared `BoundedExecutor` with a default capacity of only 16 concurrent task permits [1](#0-0) . This executor is shared across multiple critical consensus components:

1. **RandManager** - Spawns verification tasks for every incoming RandGenMessage [2](#0-1) 
2. **SecretShareManager** - Spawns verification tasks for secret sharing messages [3](#0-2) 
3. **BufferManager** - Spawns verification tasks for commit messages [4](#0-3) 
4. **ReliableBroadcast** - Spawns aggregation tasks for broadcast responses [5](#0-4) 

The vulnerability exists because the RandManager's verification task spawns a task on the BoundedExecutor for EVERY incoming RandGenMessage BEFORE verification occurs [2](#0-1) . The `spawn()` method blocks when the executor is at capacity [6](#0-5) .

**Attack Path:**
1. Malicious validator sends continuous stream of RandGenMessages (valid or invalid)
2. Messages are queued in channel with KLAST policy (10 per sender) [7](#0-6) 
3. Verification task processes messages sequentially, spawning task for each
4. Each verification involves expensive BLS signature verification [8](#0-7)  taking milliseconds
5. Messages arrive faster than verifications complete, accumulating permits
6. All 16 permits become occupied by attacker's verification tasks
7. When BufferManager attempts to verify critical commit messages during block proposal, it blocks waiting for permits [4](#0-3) 
8. Commit message processing is delayed beyond timeout thresholds
9. Block proposal fails to complete, causing consensus round to timeout

The attack succeeds because there is no rate limiting on RandGenMessage processing beyond the channel buffer [9](#0-8) , and verification happens INSIDE the spawned task rather than before permit acquisition.

## Impact Explanation

**Critical Severity** - This vulnerability enables a single malicious validator (< 1/3 Byzantine threshold) to cause **total loss of liveness** in the consensus protocol:

- **Consensus Blocking**: Prevents BufferManager from processing commit messages during critical phases
- **Missed Proposals**: Block proposals timeout when commit verification is delayed
- **Network Degradation**: Sustained attack causes repeated round failures and significantly reduced throughput
- **Byzantine Tolerance Violation**: Single validator should not be able to impact liveness under < 1/3 Byzantine assumption

This maps to the Critical Severity category: "Total loss of liveness/network availability" per the Aptos bug bounty program. While not permanent (the attack must be sustained), it effectively halts consensus progress during the attack.

## Likelihood Explanation

**High Likelihood** - The attack is straightforward to execute:

**Attacker Requirements:**
- Single validator seat (within Byzantine tolerance)
- Ability to send consensus messages (standard validator capability)
- No special permissions or compromised keys required

**Attack Complexity:** 
- Low - Simply flood RandGenMessages at high rate
- No timing precision required - sustained attack gradually exhausts permits
- Works even with invalid messages (they still consume permits during verification)

**Feasibility:**
- Cryptographic verification (WVUF::verify_share) takes 1-10ms per message
- With 16 permits and continuous message stream, saturation is achievable
- Attack is most effective during high consensus activity when other components also need permits

## Recommendation

Implement separate BoundedExecutors for different priority levels, or add pre-spawn validation with rate limiting:

**Option 1: Separate Executors**
```rust
// In ConsensusConfig
pub struct ConsensusConfig {
    pub num_bounded_executor_tasks_critical: u64,  // For BufferManager commits
    pub num_bounded_executor_tasks_normal: u64,    // For RandManager/SecretShare
    // ...
}

// In ExecutionProxyClient
let critical_executor = BoundedExecutor::new(
    config.num_bounded_executor_tasks_critical, 
    executor.clone()
);
let normal_executor = BoundedExecutor::new(
    config.num_bounded_executor_tasks_normal,
    executor.clone()
);
// Pass critical_executor to BufferManager
// Pass normal_executor to RandManager/SecretShareManager
```

**Option 2: Pre-Spawn Validation with Rate Limiting**
```rust
// In RandManager::verification_task
async fn verification_task(...) {
    let mut rate_limiter = RateLimiter::new(100, Duration::from_secs(1)); // 100 msg/sec
    
    while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
        // Rate limit per sender
        if !rate_limiter.check_and_update(rand_gen_msg.sender) {
            warn!("Rate limit exceeded for sender {}", rand_gen_msg.sender);
            continue;
        }
        
        // Quick pre-validation before spawning
        match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
            Ok(msg) if msg.epoch() == epoch_state.epoch => {
                // Only spawn if basic checks pass
                bounded_executor.spawn(async move {
                    if msg.verify(...).is_ok() {
                        let _ = tx.unbounded_send(...);
                    }
                }).await;
            },
            _ => continue, // Drop invalid messages without spawning
        }
    }
}
```

**Option 3: Use try_spawn for non-critical operations**
```rust
// In RandManager::verification_task  
match bounded_executor.try_spawn(async move { ... }) {
    Ok(handle) => { /* verification scheduled */ },
    Err(_) => {
        // Executor at capacity, drop this message
        warn!("BoundedExecutor at capacity, dropping rand message");
    }
}
```

## Proof of Concept

```rust
// Test demonstrating permit exhaustion
#[tokio::test]
async fn test_bounded_executor_exhaustion_blocks_critical_path() {
    use tokio::time::{timeout, Duration};
    use aptos_bounded_executor::BoundedExecutor;
    use std::sync::{Arc, atomic::{AtomicU64, Ordering}};
    
    let runtime = tokio::runtime::Handle::current();
    let executor = BoundedExecutor::new(16, runtime);
    
    let processed = Arc::new(AtomicU64::new(0));
    
    // Simulate malicious validator flooding with slow verification tasks
    for _ in 0..20 {
        let executor_clone = executor.clone();
        let processed_clone = processed.clone();
        tokio::spawn(async move {
            executor_clone.spawn(async move {
                // Simulate slow BLS verification (5ms)
                tokio::time::sleep(Duration::from_millis(5)).await;
                processed_clone.fetch_add(1, Ordering::Relaxed);
            }).await;
        });
    }
    
    // Give time for executor to saturate
    tokio::time::sleep(Duration::from_millis(10)).await;
    
    // Now try to spawn critical consensus operation
    let critical_task = executor.spawn(async {
        "critical_commit_verification"
    });
    
    // This should timeout because executor is saturated with attacker tasks
    let result = timeout(Duration::from_millis(50), critical_task).await;
    
    assert!(result.is_err(), "Critical task should timeout due to executor saturation");
    println!("Processed tasks: {}", processed.load(Ordering::Relaxed));
}
```

**Notes**

The vulnerability fundamentally stems from resource sharing without priority differentiation. The BoundedExecutor capacity of 16 is insufficient when multiple consensus components compete for permits during high activity periods. The lack of pre-spawn validation means invalid or malicious messages consume resources before being rejected. This violates the expected property that Aptos consensus should maintain liveness under < 1/3 Byzantine validators, as a single malicious validator can effectively DoS the critical commit verification path.

### Citations

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L234-259)
```rust
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
```

**File:** consensus/src/pipeline/execution_client.rs (L292-292)
```rust
            self.bounded_executor.clone(),
```

**File:** consensus/src/pipeline/buffer_manager.rs (L923-932)
```rust
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
```

**File:** crates/reliable-broadcast/src/lib.rs (L171-180)
```rust
                        let future = executor.spawn(async move {
                            (
                                    receiver,
                                    result
                                        .and_then(|msg| {
                                            msg.try_into().map_err(|e| anyhow::anyhow!("{:?}", e))
                                        })
                                        .and_then(|ack| aggregating.add(receiver, ack)),
                            )
                        }).await;
```

**File:** crates/bounded-executor/src/executor.rs (L45-52)
```rust
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```

**File:** consensus/src/epoch_manager.rs (L1276-1280)
```rust
        let (rand_msg_tx, rand_msg_rx) = aptos_channel::new::<AccountAddress, IncomingRandGenRequest>(
            QueueStyle::KLAST,
            self.config.internal_per_key_channel_size,
            None,
        );
```

**File:** consensus/src/epoch_manager.rs (L1872-1877)
```rust
            IncomingRpcRequest::RandGenRequest(request) => {
                if let Some(tx) = &self.rand_manager_msg_tx {
                    tx.push(peer_id, request)
                } else {
                    bail!("Rand manager not started");
                }
```

**File:** consensus/src/rand/rand_gen/types.rs (L65-72)
```rust
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
```
