# Audit Report

## Title
Missing Input Validation in ReleaseFriendlyRandomnessConfig Deserialization Enables Governance Parameter Bypass

## Summary
The `ReleaseFriendlyRandomnessConfig` enum lacks input validation during deserialization, allowing percentage values outside the valid range (0-100) to be processed. While this doesn't cause immediate security failures due to downstream safety mechanisms, it results in silent governance bypasses where approved threshold configurations are ignored in favor of fallback parameters.

## Finding Description

The `ReleaseFriendlyRandomnessConfig` enum uses derived serde deserialization without validation on its percentage fields: [1](#0-0) 

These unconstrained u64 percentage values flow through the system as follows:

1. **Deserialization Stage**: YAML configs are parsed without validation, accepting any u64 value including those >100: [2](#0-1) 

2. **Conversion to OnChainRandomnessConfig**: The `From` trait implementation directly converts percentages without bounds checking: [3](#0-2) 

3. **OnChainRandomnessConfig Construction**: The `new_v1` and `new_v2` functions create FixedPoint64 values by dividing by 100, but don't validate the input is ≤100: [4](#0-3) 

4. **Move Framework Storage**: The Move module's `new_v1` and `new_v2` functions lack validation assertions for threshold ranges: [5](#0-4) 

5. **DKG Validation and Fallback**: When DKG initializes, it validates thresholds with strict constraints. Invalid configs trigger fallback to "infallible" mode: [6](#0-5) 

When validation fails, the infallible fallback is invoked, which clamps values but doesn't enforce the >1/3 constraint: [7](#0-6) 

The rounding error is only logged, not rejected: [8](#0-7) 

## Impact Explanation

This issue qualifies as **Low to Medium** severity based on the following assessment:

**Why not Critical:**
- No consensus safety violations occur (DKG fallback maintains determinism)
- No loss of funds or network partition
- No liveness failures (system continues operating)

**Why not High:**
- No validator node crashes or API failures
- The protocol continues operating safely due to defense-in-depth

**Why Low-Medium:**
- **Governance Integrity Violation**: Approved threshold parameters are silently replaced with different values, undermining the governance process
- **Security Property Degradation**: Infallible mode can accept configs with `secrecy_threshold < 1/3`, which may not provide intended security guarantees
- **Silent Failures**: No error is surfaced to governance participants, making the bypass invisible

The impact is limited because the DKG fallback mechanism prevents catastrophic failures, but the silent parameter substitution represents a governance bypass that could lead to unexpected security properties.

## Likelihood Explanation

**Likelihood: Medium**

This issue is moderately likely to occur because:

1. **Human Error**: Legitimate governance participants could accidentally specify values >100 (e.g., confusing percentage with basis points)
2. **No Tooling Feedback**: The release-builder generates valid Move scripts even for invalid configs, providing no warning
3. **Requires Governance Access**: Exploitation requires the ability to propose governance changes, limiting the attacker pool

The issue is more likely to manifest as accidental misconfiguration rather than malicious exploitation, but the lack of validation creates an attack surface for social engineering (convincing governance to approve seemingly valid but actually invalid configs).

## Recommendation

Implement custom deserialization with validation for `ReleaseFriendlyRandomnessConfig`:

```rust
// Add validation during deserialization
impl<'de> Deserialize<'de> for ReleaseFriendlyRandomnessConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(rename = "ReleaseFriendlyRandomnessConfig")]
        enum Helper {
            Off,
            V1 {
                secrecy_threshold_in_percentage: u64,
                reconstruct_threshold_in_percentage: u64,
            },
            V2 {
                secrecy_threshold_in_percentage: u64,
                reconstruct_threshold_in_percentage: u64,
                fast_path_secrecy_threshold_in_percentage: u64,
            },
        }

        let helper = Helper::deserialize(deserializer)?;
        match helper {
            Helper::Off => Ok(ReleaseFriendlyRandomnessConfig::Off),
            Helper::V1 {
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
            } => {
                // Validate constraints
                if secrecy_threshold_in_percentage > 100 {
                    return Err(serde::de::Error::custom(
                        format!("secrecy_threshold_in_percentage must be ≤100, got {}", secrecy_threshold_in_percentage)
                    ));
                }
                if reconstruct_threshold_in_percentage > 100 {
                    return Err(serde::de::Error::custom(
                        format!("reconstruct_threshold_in_percentage must be ≤100, got {}", reconstruct_threshold_in_percentage)
                    ));
                }
                // Ensure secrecy > 1/3 (33.33%)
                if secrecy_threshold_in_percentage <= 33 {
                    return Err(serde::de::Error::custom(
                        format!("secrecy_threshold_in_percentage must be >33 for security, got {}", secrecy_threshold_in_percentage)
                    ));
                }
                // Ensure secrecy < reconstruct
                if secrecy_threshold_in_percentage >= reconstruct_threshold_in_percentage {
                    return Err(serde::de::Error::custom(
                        "secrecy_threshold must be < reconstruct_threshold"
                    ));
                }
                // Ensure reconstruct ≤ 2/3 (66.67%)
                if reconstruct_threshold_in_percentage > 67 {
                    return Err(serde::de::Error::custom(
                        format!("reconstruct_threshold_in_percentage must be ≤67 for security, got {}", reconstruct_threshold_in_percentage)
                    ));
                }
                
                Ok(ReleaseFriendlyRandomnessConfig::V1 {
                    secrecy_threshold_in_percentage,
                    reconstruct_threshold_in_percentage,
                })
            },
            Helper::V2 {
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
                fast_path_secrecy_threshold_in_percentage,
            } => {
                // Similar validation for V2...
                // [validation code omitted for brevity]
                
                Ok(ReleaseFriendlyRandomnessConfig::V2 {
                    secrecy_threshold_in_percentage,
                    reconstruct_threshold_in_percentage,
                    fast_path_secrecy_threshold_in_percentage,
                })
            },
        }
    }
}
```

Additionally, add validation to the Move framework constructors to provide defense-in-depth.

## Proof of Concept

Create a malicious config file `malicious_randomness.yaml`:

```yaml
proposals:
  - name: "invalid_randomness"
    execution_mode: MultiStep
    metadata:
      title: "Update Randomness Config"
      description: "Setting thresholds"
    update_sequence:
      - Randomness:
          V1:
            secrecy_threshold_in_percentage: 200
            reconstruct_threshold_in_percentage: 300
```

Steps to reproduce:
1. Parse the config using `ReleaseConfig::load_config()`
2. Generate proposal scripts - no error is raised
3. The generated Move script would call `create_from_rational(200, 100)` creating FixedPoint64 = 2.0
4. On-chain execution succeeds (no Move validation)
5. When DKG runs at next epoch, validation fails at line 199 of `rounding/mod.rs`
6. Falls back to infallible mode, clamping to 1.0
7. Governance-approved threshold of 200% is silently changed to 100%

The PoC demonstrates that invalid configs bypass all validation layers until DKG runtime, where they trigger silent fallback behavior that contradicts governance decisions.

## Notes

While this issue represents a governance integrity concern, the Aptos system's defense-in-depth approach (DKG validation + infallible fallback) prevents it from escalating to a critical security vulnerability. The primary harm is the silent substitution of governance-approved parameters, which could lead to unexpected security properties and undermine trust in the governance process. The lack of early validation also creates an opportunity for social engineering attacks where malicious actors could convince governance to approve seemingly valid but technically invalid configurations.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/randomness_config.rs (L10-22)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]
pub enum ReleaseFriendlyRandomnessConfig {
    Off,
    V1 {
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
    },
    V2 {
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
        fast_path_secrecy_threshold_in_percentage: u64,
    },
}
```

**File:** aptos-move/aptos-release-builder/src/components/randomness_config.rs (L24-46)
```rust
impl From<ReleaseFriendlyRandomnessConfig> for OnChainRandomnessConfig {
    fn from(value: ReleaseFriendlyRandomnessConfig) -> Self {
        match value {
            ReleaseFriendlyRandomnessConfig::Off => OnChainRandomnessConfig::Off,
            ReleaseFriendlyRandomnessConfig::V1 {
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
            } => OnChainRandomnessConfig::new_v1(
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
            ),
            ReleaseFriendlyRandomnessConfig::V2 {
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
                fast_path_secrecy_threshold_in_percentage,
            } => OnChainRandomnessConfig::new_v2(
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
                fast_path_secrecy_threshold_in_percentage,
            ),
        }
    }
}
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L751-752)
```rust
    pub fn parse(serialized: &str) -> Result<Self> {
        serde_yaml::from_str(serialized).map_err(|e| anyhow!("Failed to parse the config: {:?}", e))
```

**File:** types/src/on_chain_config/randomness_config.rs (L101-136)
```rust
    pub fn new_v1(
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
    ) -> Self {
        let secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        let reconstruction_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(reconstruct_threshold_in_percentage) / U64F64::from_num(100),
        );
        Self::V1(ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold,
        })
    }

    pub fn new_v2(
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
        fast_path_secrecy_threshold_in_percentage: u64,
    ) -> Self {
        let secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        let reconstruction_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(reconstruct_threshold_in_percentage) / U64F64::from_num(100),
        );
        let fast_path_secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(fast_path_secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        Self::V2(ConfigV2 {
            secrecy_threshold,
            reconstruction_threshold,
            fast_path_secrecy_threshold,
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L92-115)
```text
    /// Create a `ConfigV1` variant.
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
    }

    /// Create a `ConfigV2` variant.
    public fun new_v2(
        secrecy_threshold: FixedPoint64,
        reconstruction_threshold: FixedPoint64,
        fast_path_secrecy_threshold: FixedPoint64,
    ): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV2 {
                secrecy_threshold,
                reconstruction_threshold,
                fast_path_secrecy_threshold,
            } )
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L187-199)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        total_weight_min: usize,
        total_weight_max: usize,
        secrecy_threshold_in_stake_ratio: U64F64,
        reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> anyhow::Result<Self> {
        ensure!(total_weight_min >= validator_stakes.len());
        ensure!(total_weight_max >= total_weight_min);
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```

**File:** dkg/src/dkg_manager/mod.rs (L315-319)
```rust
        if let Some(summary) = public_params.rounding_summary() {
            info!(
                epoch = self.epoch_state.epoch,
                "Rounding summary: {:?}", summary
            );
```
