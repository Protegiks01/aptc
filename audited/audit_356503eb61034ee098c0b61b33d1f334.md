# Audit Report

## Title
Module Metadata Excluded from Complexity Metering Allows Bypassing Complexity Limits

## Summary
The Move binary format complexity checker does not meter module metadata when validating module complexity, while the budget calculation includes the full serialized blob size (including metadata). This mismatch allows attackers to inflate complexity budgets by including large metadata, enabling publication of modules with more complex code structures than intended by the security limits.

## Finding Description

The complexity metering system is designed to prevent publishing overly complex modules that could cause performance issues or DoS during verification and execution. However, this protection contains a fundamental inconsistency between budget calculation and complexity metering.

**Budget Calculation Includes Metadata:**
The budget is calculated based on the full serialized module size, including metadata: [1](#0-0) 

**Metadata Is Serialized Into Binary:**
Module metadata is serialized into the binary blob when bytecode version >= 5: [2](#0-1) 

**Complexity Checker Excludes Metadata:**
The `check_module_complexity()` function meters signatures, handles, instantiations, and definitions, but completely ignores the `metadata` field: [3](#0-2) 

**Metadata Can Contain Large Strings:**
Module metadata includes error descriptions with arbitrary-length strings generated from documentation comments: [4](#0-3) 

**Attack Path:**
1. Attacker creates a module with 40KB of verbose error descriptions in metadata
2. Actual code structures total 10KB
3. Total serialized blob = 50KB
4. Budget calculated = 2,048 + 50,000 Ã— 20 = 1,002,048 units
5. Complexity meter only charges for 10KB of code structures (~200,000 units)
6. ~800,000 units of budget remain unused
7. Attacker uses remaining budget for highly complex code structures that would normally exceed limits

When complexity is exceeded, the meter returns an error: [5](#0-4) 

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:

**Why Medium (not High/Critical):**
- Does not directly enable fund theft or loss
- Does not cause consensus violations or network partitions  
- Requires gas payment, providing economic deterrent
- Other validation limits (max_type_nodes, max_struct_definitions) remain in effect

**Why Security Issue (not just a bug):**
- Bypasses a documented security control designed to prevent DoS
- Allows publishing modules exceeding intended complexity thresholds
- Could enable validator performance degradation during module verification
- Violates the resource limits security invariant
- The complexity limit exists specifically to prevent "overly complex modules that could cause performance issues"

This qualifies as a "Limited Protocol Violation" under the Medium severity category, as it bypasses a security control without directly compromising funds or consensus.

## Likelihood Explanation

**High Likelihood:**
- Trivial to exploit: simply add verbose documentation comments that generate large error descriptions
- No special permissions required: any account can publish modules
- Economically feasible: gas costs are standard for module publishing
- Easily discoverable through code inspection
- No race conditions or complex timing requirements

The SAFER_METADATA feature flag is enabled by default but does not address this issue: [6](#0-5) 

Even with SAFER_METADATA enabled, the alternate complexity checker also excludes metadata: [7](#0-6) 

## Recommendation

**Option 1 (Recommended):** Exclude metadata from budget calculation:
```rust
// In aptos_vm.rs
let code_size = blob.code().len() - get_metadata_size(module);
let budget = 2048 + code_size as u64 * 20;
```

**Option 2:** Add metadata metering to complexity checker:
```rust
// In check_complexity.rs, add to check_module_complexity():
fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    // ... existing metering ...
    
    // Meter metadata
    for metadata in &module.metadata {
        self.charge(metadata.key.len() as u64 * COST_PER_IDENT_BYTE)?;
        self.charge(metadata.value.len() as u64 * COST_PER_IDENT_BYTE)?;
    }
    
    // ... rest of function ...
}
```

**Option 3:** Add explicit metadata size limit independent of complexity budget.

## Proof of Concept

```move
module publisher::bloated_metadata {
    const ERROR_CODE: u64 = 1;
    
    /// This is an extremely verbose error description that spans many lines
    /// and contains detailed information about the error condition, including
    /// extensive documentation about when this error occurs, what causes it,
    /// how to handle it, examples of usage, related errors, historical context,
    /// implementation details, performance considerations, security implications,
    /// and much more verbose text to inflate the metadata size...
    /// [repeat pattern 1000+ times to create 40KB+ of error description]
    const VERBOSE_ERROR: u64 = ERROR_CODE;
    
    // Now use remaining budget for complex type structures
    // that would normally be rejected
    struct Complex<T1, T2, T3, T4, T5> {
        // ... deeply nested generic types ...
    }
}
```

The module will pass complexity checking despite exceeding intended limits because the large metadata inflates the budget while consuming zero complexity units.

## Notes

The serialized blob returned by `blob.code()` includes all module components: [8](#0-7) 

The `CompiledModule` structure contains the metadata field that gets serialized: [9](#0-8)

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1556-1556)
```rust
            let budget = 2048 + blob.code().len() as u64 * 20;
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L1483-1490)
```rust
        if self.major_version >= VERSION_5 {
            self.metadata = serialize_table(
                &mut table_count,
                binary,
                tables.get_metadata(),
                serialize_metadata_entry,
            )?;
        }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L38-50)
```rust
    fn charge(&self, amount: u64) -> PartialVMResult<()> {
        let mut balance = self.balance.borrow_mut();
        match balance.checked_sub(amount) {
            Some(new_balance) => {
                *balance = new_balance;
                Ok(())
            },
            None => {
                *balance = 0;
                Err(PartialVMError::new(StatusCode::PROGRAM_TOO_COMPLEX))
            },
        }
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-core/types/src/errmap.rs (L15-20)
```rust
pub struct ErrorDescription {
    /// The constant name of error e.g., ECANT_PAY_DEPOSIT
    pub code_name: String,
    /// The code description. This is generated from the doc comments on the constant.
    pub code_description: String,
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L206-206)
```rust
            FeatureFlag::SAFER_METADATA,
```

**File:** types/src/vm/module_metadata.rs (L560-607)
```rust
fn check_module_complexity(module: &CompiledModule) -> Result<(), MetaDataValidationError> {
    let mut meter: usize = 0;
    for sig in module.signatures() {
        for tok in &sig.0 {
            check_sigtok_complexity(module, &mut meter, tok)?
        }
    }
    for handle in module.function_handles() {
        check_ident_complexity(module, &mut meter, handle.name)?;
        for tok in &safe_get_table(module.signatures(), handle.parameters.0)?.0 {
            check_sigtok_complexity(module, &mut meter, tok)?
        }
        for tok in &safe_get_table(module.signatures(), handle.return_.0)?.0 {
            check_sigtok_complexity(module, &mut meter, tok)?
        }
    }
    for handle in module.struct_handles() {
        check_ident_complexity(module, &mut meter, handle.name)?;
    }
    for def in module.struct_defs() {
        match &def.field_information {
            StructFieldInformation::Native => {},
            StructFieldInformation::Declared(fields) => {
                for field in fields {
                    check_ident_complexity(module, &mut meter, field.name)?;
                    check_sigtok_complexity(module, &mut meter, &field.signature.0)?
                }
            },
            StructFieldInformation::DeclaredVariants(variants) => {
                for variant in variants {
                    check_ident_complexity(module, &mut meter, variant.name)?;
                    for field in &variant.fields {
                        check_ident_complexity(module, &mut meter, field.name)?;
                        check_sigtok_complexity(module, &mut meter, &field.signature.0)?
                    }
                }
            },
        }
    }
    for def in module.function_defs() {
        if let Some(unit) = &def.code {
            for tok in &safe_get_table(module.signatures(), unit.locals.0)?.0 {
                check_sigtok_complexity(module, &mut meter, tok)?
            }
        }
    }
    Ok(())
}
```

**File:** types/src/transaction/module.rs (L19-21)
```rust
    pub fn code(&self) -> &[u8] {
        &self.code
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3467-3467)
```rust
    pub metadata: Vec<Metadata>,
```
