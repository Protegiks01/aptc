# Audit Report

## Title
Genesis QC Signature Verification Bypass in OrderVoteMsg Processing

## Summary
When `skip_sig_verify` is false, a malicious QC with round 0 can bypass signature verification in `verify_qc()`, allowing invalid quorum certificates to pass verification during OrderVoteMsg processing at network genesis.

## Finding Description

The `QuorumCert::verify()` function contains a special case for genesis blocks (round 0) that bypasses signature verification entirely: [1](#0-0) 

This bypass is also present when `SafetyRules::verify_qc()` is called with `skip_sig_verify = false`: [2](#0-1) 

The vulnerability manifests when processing `OrderVoteMsg` from the network. In `RoundManager::process_order_vote_msg()`, the QC is verified directly without subsequent block validation: [3](#0-2) 

**Attack Path:**
1. Malicious validator crafts an `OrderVoteMsg` containing:
   - A valid `OrderVote` (properly signed) with `ledger_info.round() == 0`
   - A malicious round 0 `QuorumCert` with `get_num_voters() == 0` (no signatures)
2. At network genesis when `highest_ordered_round == 0`, the round range check passes: [4](#0-3) 
3. The QC verification at line 1581 invokes the genesis bypass, skipping signature validation
4. The malicious QC is inserted into `pending_order_votes` without cryptographic verification

While VoteProposal processing has defense-in-depth protections that reject genesis blocks: [5](#0-4) 

The OrderVoteMsg path lacks equivalent block-level validation, relying solely on QC verification.

## Impact Explanation

**Severity Assessment: Medium (borderline Low)**

This vulnerability has limited impact due to multiple constraints:

1. **Requires Validator Privileges**: The attacker must be a validator to sign valid OrderVotes
2. **Narrow Attack Window**: Only exploitable when `highest_ordered_round == 0` (network genesis)
3. **Limited Scope**: Does not directly compromise consensus safety as the fake QC still needs to reference valid block IDs that match the OrderVote's commit_info

The impact is primarily that an unverified QC could influence consensus state during the critical network genesis phase, potentially affecting one_chain_round and preferred_round tracking. However, it does not enable direct fund theft or consensus forks.

Per Aptos bug bounty criteria, this represents a protocol violation requiring validator compromise, placing it at **Medium severity** at best.

## Likelihood Explanation

**Likelihood: Low**

The attack requires:
- Malicious validator (insider threat)
- Network at genesis state (`highest_ordered_round == 0`)
- Coordination to inject the malicious message before other validators advance rounds
- Knowledge of the genesis bypass implementation detail

These constraints make exploitation extremely unlikely in production environments. The genesis phase is typically controlled and monitored, reducing practical attack feasibility.

## Recommendation

Remove the genesis bypass from network-received QC verification or add explicit validation that genesis QCs are only accepted during local initialization, never from network peers.

**Proposed Fix:**

Add a parameter to `QuorumCert::verify()` indicating whether the QC originates from network input:

```rust
pub fn verify(&self, validator: &ValidatorVerifier, allow_genesis: bool) -> anyhow::Result<()> {
    let vote_hash = self.vote_data.hash();
    ensure!(
        self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
        "Quorum Cert's hash mismatch LedgerInfo"
    );
    
    if self.certified_block().round() == 0 {
        ensure!(allow_genesis, "Genesis QC not permitted from network");
        // ... existing genesis validation
        return Ok(());
    }
    
    self.ledger_info().verify_signatures(validator)
        .context("Fail to verify QuorumCert")?;
    self.vote_data.verify()?;
    Ok(())
}
```

Update network QC verification to pass `allow_genesis: false`: [3](#0-2) 

## Proof of Concept

Due to the requirement for validator privileges and genesis state conditions, a full PoC requires modifying the test framework. However, the core vulnerability can be demonstrated by examining the code flow:

```rust
// Malicious validator creates fake round 0 QC
let fake_genesis_qc = QuorumCert::new(
    VoteData::new(genesis_block_info.clone(), genesis_block_info.clone()),
    LedgerInfoWithSignatures::new(
        LedgerInfo::new(genesis_block_info, vote_hash),
        AggregateSignature::new(BitVec::with_num_bits(0), None)  // No signatures!
    )
);

// Create valid OrderVote (signed by malicious validator)
let order_vote = safety_rules.construct_and_sign_order_vote(...);

// Send OrderVoteMsg with fake QC
let msg = OrderVoteMsg::new(order_vote, fake_genesis_qc);

// At network genesis, this passes verification at line 1581
// because QuorumCert::verify() skips signature checks for round 0
```

**Note**: This PoC demonstrates the bypass mechanism but cannot be executed without validator access and genesis state conditions, confirming the limited practical exploitability.

---

**Validation Result**: This vulnerability is **valid but limited in scope**. It represents a genuine signature verification bypass when `skip_sig_verify = false`, but requires privileged access (validator) and specific network conditions (genesis). The impact is mitigated by defense-in-depth mechanisms in other code paths and narrow exploitability windows.

### Citations

**File:** consensus/consensus-types/src/quorum_cert.rs (L128-141)
```rust
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
```

**File:** consensus/safety-rules/src/safety_rules.rs (L235-243)
```rust
    pub(crate) fn verify_qc(&self, qc: &QuorumCert) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            qc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidQuorumCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L1571-1573)
```rust
            if order_vote_round > highest_ordered_round
                && order_vote_round < highest_ordered_round + 100
            {
```

**File:** consensus/src/round_manager.rs (L1579-1582)
```rust
                    order_vote_msg
                        .quorum_cert()
                        .verify(&self.epoch_state.verifier)
                        .context("[OrderVoteMsg QuorumCert verification failed")?;
```

**File:** consensus/consensus-types/src/block.rs (L470-473)
```rust
        ensure!(
            !self.is_genesis_block(),
            "We must not accept genesis from others"
        );
```
