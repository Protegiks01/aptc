# Audit Report

## Title
Distance Manipulation Vulnerability in Peer Monitoring Service Enables Malicious Peer Prioritization

## Summary
Malicious nodes can falsely report their `distance_from_validators` metric in `GetNetworkInformation` responses to appear closer to the validator set than they actually are. This false distance information is trusted by other nodes and used for peer prioritization in critical systems (mempool, consensus observer, state sync), allowing attackers to gain preferential treatment and potentially disrupt network operations.

## Finding Description

The peer monitoring service implements a distance metric (`distance_from_validators`) to measure how many network hops a node is from the validator set. This metric is calculated server-side and returned in `NetworkInformationResponse`. [1](#0-0) 

The server-side calculation in `get_distance_from_validators` relies entirely on self-reported distance values from connected peers. [2](#0-1) 

The critical flaw is that the calculation at lines 322-333 reads `latest_network_info_response.distance_from_validators` from connected peers without any cryptographic verification or proof mechanism. A malicious node can modify its server code to return an arbitrary low distance value, bypassing the honest calculation logic.

The client-side validation has a critical gap for distances ≥ 2. [3](#0-2) 

While distances 0 and 1 are strictly validated against peer roles (validator/VFN), distances 2-100 only check the upper bound with no verification of peer role or actual network position (lines 137-140). This allows any node to claim distance = 2 and have it accepted.

This false distance propagates through the system and is used for peer prioritization in:

1. **Mempool Priority**: [4](#0-3) 
   The `compare_validator_distance` function prioritizes peers with lower distance for transaction broadcasting.

2. **Consensus Observer Subscriptions**: [5](#0-4) 
   The `sort_peers_by_subscription_optimality` function groups peers by distance (line 286-312), prioritizing lower distances for subscription selection.

3. **State Sync Peer Selection**: [6](#0-5) 
   The `choose_random_peers_by_distance_and_latency` function groups peers by distance in a BTreeMap (sorted ascending), selecting from lower distances first.

**Attack Scenario:**
1. Attacker runs a Public Full Node (PFN) with modified server code returning `distance_from_validators = 2`
2. Honest PFNs connect to the attacker and receive this false distance in `NetworkInformationResponse`
3. The validation passes (2 ≤ 100) and the false distance is stored in `latest_network_info_response`
4. Honest nodes calculate their own distance as `min(2, other_distances) + 1 = 3`
5. The attacker appears closer to validators than honest PFNs (which might actually be at distance 5+)
6. The attacker gets prioritized in mempool, consensus observer, and state sync operations

## Impact Explanation

**Medium Severity** - This vulnerability enables several attack vectors:

1. **Mempool Manipulation**: Attacker receives transaction broadcasts before other nodes, enabling front-running opportunities and selective transaction censorship
2. **Consensus Observer Disruption**: Attacker gets selected as subscription target, can refuse service or provide delayed consensus updates
3. **State Sync Resource Exhaustion**: Attacker gets prioritized for state requests, can refuse service causing sync delays
4. **Network Partition Potential**: Multiple malicious nodes claiming low distance can dominate peer selection, effectively partitioning honest nodes from optimal peers

While the attacker cannot directly steal funds or break consensus safety (data provided is still validated), they can disrupt network operations and gain information advantages. This constitutes "Significant protocol violations" and "State inconsistencies requiring intervention" per the Medium severity criteria.

## Likelihood Explanation

**High Likelihood** - The attack is trivial to execute:
- Requires only running a modified node (single line code change)
- No special network position or permissions required
- No cryptographic keys or validator access needed
- Works against any node that connects to the attacker
- Detection is difficult as the false values appear valid

The attack cost is minimal (running a single node), while the potential disruption is significant, especially if multiple colluding nodes execute this attack simultaneously.

## Recommendation

Implement cryptographic verification for distance claims using a distance attestation mechanism:

1. **Add Distance Attestation Chain**: Nodes should include signed attestations from their immediate peers proving their distance claims
2. **Strengthen Validation**: Extend client-side validation to verify distance claims against peer roles for ALL distances, not just 0 and 1
3. **Add Rate Limiting**: Implement penalties for nodes that consistently report suspicious distance values
4. **Implement Distance Proofs**: Require nodes to provide a chain of signatures from validators down to their position

Immediate mitigation:
```rust
// In network_info.rs, strengthen validation for all distances
let is_valid_depth = match network_info_response.distance_from_validators {
    0 => {
        // Existing validation for validators
        peer_is_validator && peer_has_correct_network
    },
    1 => {
        // Existing validation for VFNs
        peer_is_vfn && peer_has_correct_network
    },
    distance_from_validators => {
        // NEW: Validate that PFNs don't claim unreasonably low distances
        // and verify against peer connection metadata
        let peer_role = peer_metadata.get_connection_metadata().role;
        let is_reasonable_distance = match peer_role {
            PeerRole::Validator => distance_from_validators <= 1, // Disconnected validator
            PeerRole::ValidatorFullNode => distance_from_validators <= 2,
            _ => distance_from_validators >= 2, // PFNs should be at least distance 2
        };
        is_reasonable_distance && distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
    },
};
```

## Proof of Concept

```rust
// Proof of Concept: Demonstrate distance manipulation vulnerability
#[tokio::test]
async fn test_distance_manipulation_attack() {
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_network::application::storage::PeersAndMetadata;
    use aptos_peer_monitoring_service_types::response::NetworkInformationResponse;
    use std::collections::BTreeMap;
    
    // 1. Setup: Create a malicious node that reports false distance
    let malicious_distance = 2u64; // Claiming to be close to validators
    let actual_distance = 10u64; // Actually far from validators
    
    // 2. Malicious node creates false response
    let false_response = NetworkInformationResponse {
        connected_peers: BTreeMap::new(),
        distance_from_validators: malicious_distance, // LIE: claiming distance 2
    };
    
    // 3. Honest node receives this response and validates it
    // The validation in network_info.rs will PASS because:
    // - For distance >= 2, only checks if distance <= MAX_DISTANCE_FROM_VALIDATORS
    // - No verification of actual network position
    assert!(malicious_distance <= MAX_DISTANCE_FROM_VALIDATORS); // Passes validation
    
    // 4. Honest node stores this false distance in peer metadata
    // and uses it to calculate its own distance
    let honest_node_distance = malicious_distance + 1; // 3
    
    // 5. Demonstrate prioritization impact
    // In mempool/consensus/state-sync, the malicious node will be prioritized
    // over honest nodes at actual distance (e.g., 10+1=11)
    assert!(honest_node_distance < actual_distance + 1);
    
    // 6. Attack succeeds: Malicious node appears at distance 2,
    // gets prioritized over honest nodes at real distances
    println!("Attack successful: Malicious node claims distance {}, honest nodes believe it", 
             malicious_distance);
    println!("Malicious node gets prioritized in mempool/consensus/state-sync");
}
```

**Steps to reproduce in live environment:**
1. Run modified Aptos node with hardcoded `distance_from_validators = 2` in `get_network_information()` response
2. Connect honest nodes to this malicious node
3. Monitor peer prioritization metrics - observe malicious node receiving preferential treatment
4. Verify malicious node is selected first for mempool broadcasts, consensus subscriptions, and state sync requests

## Notes

This vulnerability exists because the peer monitoring service treats distance claims as trusted information without cryptographic proof. The system assumes honest calculation but provides no mechanism to verify claims. The `MAX_DISTANCE_FROM_VALIDATORS` constant is 100, providing a wide range for manipulation. [7](#0-6)

### Citations

**File:** peer-monitoring-service/types/src/response.rs (L50-55)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L296-340)
```rust
/// Returns the distance from the validators using the given base config
/// and the peers and metadata information.
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-312)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** state-sync/aptos-data-client/src/utils.rs (L23-64)
```rust
/// Chooses peers weighted by distance from the validator set
/// and latency. We prioritize distance over latency as we want
/// to avoid close but not up-to-date peers.
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** peer-monitoring-service/types/src/lib.rs (L22-22)
```rust
pub const MAX_DISTANCE_FROM_VALIDATORS: u64 = 100; // Nodes that aren't connected to the network
```
