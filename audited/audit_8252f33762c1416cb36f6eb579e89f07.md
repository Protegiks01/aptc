# Audit Report

## Title
Missing HTTP Request Timeout in JWK Fetching Allows Malicious OIDC Provider to DoS Validator Nodes

## Summary
The JWK fetching mechanism in validator nodes lacks HTTP request timeouts, allowing a malicious OpenID Connect (OIDC) provider to cause denial of service by hanging connections indefinitely. This can lead to resource exhaustion and validator node slowdowns.

## Finding Description

The `fetch_jwks_from_jwks_uri()` and `fetch_jwks_uri_from_openid_config()` functions create HTTP clients without configuring request timeouts. [1](#0-0) [2](#0-1) 

When a validator node starts, it spawns `JWKObserver` instances for each configured OIDC provider. These observers periodically fetch JWKs every 10 seconds. [3](#0-2) 

The observers run in the validator's JWK consensus manager: [4](#0-3) 

Each fetch operation calls the vulnerable functions without timeout protection: [5](#0-4) 

**Attack Scenario:**
1. An OIDC provider (added via governance) is controlled or compromised by an attacker
2. The provider's server accepts HTTP connections but never responds or sends data extremely slowly
3. Every 10 seconds, each validator spawns a new HTTP request that hangs indefinitely
4. Over time (minutes to hours), multiple hanging connections accumulate per validator
5. This consumes file descriptors, memory buffers, and tokio task resources
6. Eventually causes validator node slowdowns and potential resource exhaustion

In contrast, the codebase consistently sets timeouts elsewhere. For example, the standard pattern uses explicit timeout configuration: [6](#0-5) [7](#0-6) 

The reqwest library has no default timeout - requests will hang indefinitely without explicit configuration.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program: "Validator node slowdowns."

**Specific Impacts:**
- **Resource Exhaustion**: Each hanging connection consumes memory, file descriptors, and tokio task slots
- **Validator Performance Degradation**: As resources are exhausted, validator nodes become slower and less responsive
- **Multiplied Effect**: If multiple OIDC providers are compromised, or if a single provider is attacked, the impact scales linearly with the number of validators in the network
- **Persistent DoS**: The attack repeats every 10 seconds until the epoch ends or the malicious provider is removed via governance

While this does not directly break consensus safety, it degrades validator availability and performance, which can impact network liveness and block production efficiency.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attack Prerequisites:**
- An OIDC provider must be configured on-chain (requires governance approval)
- The attacker must control or compromise the OIDC provider's infrastructure

**Feasibility:**
- Once an OIDC provider is added (e.g., Google, Facebook, or other major identity providers), the provider operator has complete control over response behavior
- A compromised or malicious OIDC provider can trivially implement a slowloris-style attack
- The attack is passive and difficult to detect initially
- No special cryptographic or protocol knowledge required

**Mitigation Factors:**
- Requires governance to add OIDC providers initially
- Reputable OIDC providers (Google, Facebook) are unlikely to be malicious
- However, smaller/newer OIDC providers or compromised infrastructure remain risk vectors

## Recommendation

Configure explicit timeouts for all HTTP requests in the JWK fetching utilities. The timeout should be reasonable for OIDC provider response times but prevent indefinite hangs.

**Recommended Fix:**

```rust
// In crates/jwk-utils/src/lib.rs
use std::time::Duration;

const JWK_FETCH_TIMEOUT_SECS: u64 = 30; // 30 seconds timeout

pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(JWK_FETCH_TIMEOUT_SECS))
        .build()?;
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}

pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(JWK_FETCH_TIMEOUT_SECS))
        .build()?;
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

A 30-second timeout aligns with typical OIDC provider response times while preventing indefinite hangs. This is more conservative than the standard 10-15 second timeouts used elsewhere, accounting for potential network latency when fetching from global OIDC providers.

## Proof of Concept

The following Rust test demonstrates the vulnerability:

```rust
#[tokio::test]
async fn test_jwk_fetch_timeout_vulnerability() {
    use std::time::Duration;
    use tokio::time::timeout;
    
    // Simulate a malicious OIDC provider that never responds
    let server = tokio::spawn(async {
        let listener = tokio::net::TcpListener::bind("127.0.0.1:0")
            .await
            .unwrap();
        let addr = listener.local_addr().unwrap();
        
        // Accept connection but never send response
        tokio::spawn(async move {
            loop {
                if let Ok((mut socket, _)) = listener.accept().await {
                    // Keep connection alive but never respond
                    tokio::spawn(async move {
                        let _ = tokio::time::sleep(Duration::from_secs(3600)).await;
                        drop(socket);
                    });
                }
            }
        });
        
        addr
    });
    
    let malicious_server_addr = server.await.unwrap();
    let malicious_url = format!("http://{}/jwks", malicious_server_addr);
    
    // Attempt to fetch JWKs - this will hang indefinitely without timeout
    let fetch_future = fetch_jwks_from_jwks_uri(None, &malicious_url);
    
    // Wrap in timeout to demonstrate the hang
    let result = timeout(Duration::from_secs(5), fetch_future).await;
    
    // This will timeout, proving the vulnerability
    assert!(result.is_err(), "Request should timeout but hangs indefinitely");
}
```

To reproduce in a live environment:
1. Deploy a test HTTP server that accepts connections but never responds
2. Configure it as an OIDC provider via governance (in testnet)
3. Observe validator logs showing accumulating hanging connections
4. Monitor validator resource usage (file descriptors, memory) increasing over time

## Notes

This vulnerability specifically affects the JWK consensus subsystem used for keyless account authentication. While not directly compromising consensus safety, it represents a significant availability vulnerability that can be exploited by malicious or compromised OIDC providers to degrade validator node performance across the entire network.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L197-254)
```rust
        if jwk_manager_should_run && my_index.is_some() {
            info!(epoch = epoch_state.epoch, "JWKManager starting.");
            let network_sender = NetworkSender::new(
                self.my_addr,
                self.network_sender.clone(),
                self.self_sender.clone(),
            );
            let rb = ReliableBroadcast::new(
                self.my_addr,
                epoch_state.verifier.get_ordered_account_addresses(),
                Arc::new(network_sender),
                ExponentialBackoff::from_millis(5),
                aptos_time_service::TimeService::real(),
                Duration::from_millis(1000),
                BoundedExecutor::new(8, tokio::runtime::Handle::current()),
            );
            let my_pk = epoch_state
                .verifier
                .get_public_key(&self.my_addr)
                .ok_or_else(|| anyhow!("my pk not found in validator set"))?;
            let my_sk = self.key_storage.consensus_sk_by_pk(my_pk).map_err(|e| {
                anyhow!("jwk-consensus new epoch handling failed with consensus sk lookup err: {e}")
            })?;
            let (jwk_event_tx, jwk_event_rx) = aptos_channel::new(QueueStyle::KLAST, 1, None);
            self.jwk_updated_event_txs = Some(jwk_event_tx);
            let (jwk_rpc_msg_tx, jwk_rpc_msg_rx) = aptos_channel::new(QueueStyle::FIFO, 100, None);

            let (jwk_manager_close_tx, jwk_manager_close_rx) = oneshot::channel();
            self.jwk_rpc_msg_tx = Some(jwk_rpc_msg_tx);
            self.jwk_manager_close_tx = Some(jwk_manager_close_tx);
            let jwk_consensus_manager: Box<dyn TConsensusManager> =
                if features.is_enabled(FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE) {
                    Box::new(KeyLevelConsensusManager::new(
                        Arc::new(my_sk),
                        self.my_addr,
                        epoch_state.clone(),
                        rb,
                        self.vtxn_pool.clone(),
                    ))
                } else {
                    //TODO: move this into IssuerLevelConsensusManager construction?
                    let update_certifier = UpdateCertifier::new(rb);
                    Box::new(IssuerLevelConsensusManager::new(
                        Arc::new(my_sk),
                        self.my_addr,
                        epoch_state.clone(),
                        Arc::new(update_certifier),
                        self.vtxn_pool.clone(),
                    ))
                };
            tokio::spawn(jwk_consensus_manager.run(
                oidc_providers,
                onchain_observed_jwks,
                jwk_event_rx,
                jwk_rpc_msg_rx,
                jwk_manager_close_rx,
            ));
            info!(epoch = epoch_state.epoch, "JWKManager spawned.",);
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L54-54)
```rust
            timeout: Duration::from_secs(10), // Default to 10 seconds
```

**File:** keyless/pepper/service/src/utils.rs (L10-22)
```rust
const CLIENT_REQUEST_TIMEOUT_SECS: u64 = 15;

// Origin header constants
const MISSING_ORIGIN_STRING: &str = ""; // Default to empty string if origin header is missing
const ORIGIN_HEADER: &str = "origin";

/// Creates and returns a reqwest HTTP client with a timeout
pub fn create_request_client() -> Client {
    Client::builder()
        .timeout(Duration::from_secs(CLIENT_REQUEST_TIMEOUT_SECS))
        .build()
        .expect("Failed to build the request client!")
}
```
