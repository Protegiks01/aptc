# Audit Report

## Title
Unprotected `skip_epoch_endings` Flag Enables Cryptographic Verification Bypass in Database Restore Operations

## Summary

The `--skip-epoch-endings` flag in the Aptos db-tool allows any operator with server access to restore blockchain state from backups without cryptographic verification of validator signatures. This bypasses critical epoch-ending ledger info verification, enabling malicious operators to inject unverified state into validator nodes, breaking consensus safety guarantees. [1](#0-0) 

## Finding Description

The `skip_epoch_endings` flag is a boolean CLI option that completely disables epoch history restoration and verification during database restore operations. When enabled, it causes the `RestoreCoordinator` to set `epoch_history` to `None`: [2](#0-1) 

This `None` value propagates to both `StateSnapshotRestoreController` and `TransactionRestoreBatchController`, causing them to skip critical signature verification:

**In StateSnapshotRestoreController:** [3](#0-2) 

**In TransactionRestoreController:** [4](#0-3) 

The `verify_ledger_info` function performs the critical cryptographic check that ensures LedgerInfoWithSignatures were validly signed by the correct validator set for each epoch: [5](#0-4) 

For non-genesis, non-waypointed epochs, this function uses `next_epoch_state().verify()` to cryptographically verify BLS aggregate signatures (lines 306-310). **Skipping this verification means accepting arbitrary, unverified state.**

Furthermore, trusted waypoints are optional and can be an empty list: [6](#0-5) 

**Attack Scenario:**

1. Malicious operator creates fraudulent backup with modified state/transactions
2. Operator restores with: `aptos-db restore bootstrap-db --skip-epoch-endings --target-db-dir /validator/db --command-adapter-config malicious-backup.yaml`
3. All cryptographic verification is bypassed (no signature checks, no epoch validation)
4. When validator node starts, `maybe_bootstrap` skips genesis verification because DB version > 0: [7](#0-6) 

5. Validator operates with completely unverified state, producing different state roots than honest validators

**Why Runtime Checks Don't Prevent This:**

The `check_and_put_ledger_info` function only validates NEW ledger infos during runtime commits, not existing data in a restored database: [8](#0-7) 

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability breaks **Invariant #1** ("All validators must produce identical state roots for identical blocks") and **Invariant #2** ("Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine").

**Concrete Impact:**
- **Consensus Split**: If multiple validators restore from different malicious backups, they will have different state and cannot reach consensus
- **Double-Spending**: Malicious state could include fraudulent transactions that were never properly validated
- **State Root Divergence**: Validators with compromised state will produce different state roots, causing deterministic execution failures
- **Chain Fork Risk**: Network partition if subset of validators operate on invalid state

According to Aptos bug bounty criteria, "Consensus/Safety violations" qualify as **Critical Severity** (up to $1,000,000).

## Likelihood Explanation

**Likelihood: HIGH**

**Attack Requirements:**
- Operator access to validator server (standard operational requirement)
- Ability to run db-tool CLI commands (no authentication required)
- Access to create/modify backup files

**No Security Controls:**
- No authentication/authorization on db-tool: [9](#0-8) 

- No runtime warnings when flag is used
- Help text says "used for debugging" but provides no safeguards against production misuse: [10](#0-9) 

**Real-World Scenarios:**
1. Compromised operator credentials
2. Malicious insider with legitimate server access  
3. Social engineering (operator told to restore from "official" but malicious backup)
4. Accidental misuse in production (flag intended for testing used in production restore)

## Recommendation

**Immediate Mitigations:**

1. **Remove the flag entirely** for production builds. Epoch verification is fundamental to security and should never be skippable.

2. **If the flag must exist for debugging**, add multiple layers of protection:

```rust
#[derive(Parser)]
pub struct RestoreCoordinatorOpt {
    // ... existing fields ...
    
    #[clap(
        long, 
        help = "⚠️  DANGEROUS: Skip restoring epoch ending info. NEVER use in production! \
        This bypasses cryptographic signature verification and can lead to consensus failures. \
        Only for development/testing with synthetic data.",
        env = "APTOS_ALLOW_DANGEROUS_RESTORE_FLAGS"
    )]
    #[cfg(feature = "dangerous-restore-flags")]
    pub skip_epoch_endings: bool,
}
```

3. **Add runtime validation**:

```rust
let epoch_history = if !self.skip_epoch_endings {
    Some(Arc::new(
        EpochHistoryRestoreController::new(/* ... */).run().await?,
    ))
} else {
    // Add explicit warning
    warn!(
        "⚠️  DANGEROUS: Skipping epoch ending verification! \
        This bypasses cryptographic validation and WILL cause consensus failures \
        if used with production data. This should ONLY be used for testing \
        with synthetic data."
    );
    
    // Require explicit confirmation
    if std::env::var("APTOS_ALLOW_DANGEROUS_RESTORE_FLAGS").is_err() {
        bail!(
            "Refusing to skip epoch verification without explicit authorization. \
            Set APTOS_ALLOW_DANGEROUS_RESTORE_FLAGS=1 environment variable \
            to acknowledge the risks."
        );
    }
    
    None
};
```

4. **Add post-restore validation**: Before allowing a restored DB to start, verify at least one trusted waypoint matches:

```rust
// In maybe_bootstrap or initialize_database_and_checkpoints
if restored_db && !waypoint_verified {
    bail!("Restored database must have at least one verified waypoint");
}
```

## Proof of Concept

```bash
#!/bin/bash
# PoC: Restore malicious backup without verification

# Step 1: Create malicious backup (attacker-controlled)
# Backup contains fraudulent state with modified balances/transactions

# Step 2: Restore without any cryptographic verification
aptos-db restore bootstrap-db \
  --skip-epoch-endings \
  --target-db-dir /tmp/malicious_validator_db \
  --target-version 1000000 \
  --concurrent-downloads 8 \
  --metadata-cache-dir ./cache \
  --command-adapter-config config.yaml

# Step 3: Start validator node with malicious state
# Node starts successfully (maybe_bootstrap skips verification because DB version > 0)
# Validator now operates with unverified state, producing different roots than honest validators

# Expected outcome: 
# - No cryptographic verification performed
# - No warnings or errors
# - Node starts and participates in consensus with invalid state
# - Consensus safety violated
```

**Verification Steps:**
1. Create two backups with different state at same version
2. Restore both using `--skip-epoch-endings`
3. Verify both restore successfully without errors
4. Compare state roots - they differ but both DBs are accepted
5. Start validator nodes - both start without validation errors
6. Consensus fails due to state root divergence

## Notes

The test file `testsuite/module_verify.py` shows this flag is used for module verification testing, confirming it's intended for debugging: [11](#0-10) 

However, the lack of safeguards means this debugging feature can be misused to compromise production validators. This represents a fundamental access control failure where privileged operations lack sufficient protection mechanisms.

### Citations

**File:** storage/db-tool/src/backup.rs (L153-154)
```rust
    #[clap(long, help = "Skip verifying epoch ending info.")]
    skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L56-59)
```rust
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-601)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
    }
```

**File:** storage/db-tool/src/lib.rs (L22-63)
```rust
#[derive(Parser)]
#[clap(name = "Aptos db tool", author, disable_version_flag = true)]
pub enum DBTool {
    #[clap(subcommand)]
    Backup(backup::Command),

    #[clap(subcommand)]
    BackupMaintenance(backup_maintenance::Command),

    Bootstrap(bootstrap::Command),

    #[clap(subcommand)]
    Debug(db_debugger::Cmd),

    ReplayVerify(replay_verify::Opt),

    GenReplayVerifyJobs(gen_replay_verify_jobs::Opt),

    #[clap(subcommand)]
    Restore(restore::Command),

    ReplayOnArchive(replay_on_archive::Opt),
}

impl DBTool {
    pub async fn run(self) -> Result<()> {
        match self {
            DBTool::Backup(cmd) => cmd.run().await,
            DBTool::BackupMaintenance(cmd) => cmd.run().await,
            DBTool::Bootstrap(cmd) => cmd.run(),
            DBTool::Debug(cmd) => Ok(cmd.run()?),
            DBTool::ReplayVerify(cmd) => {
                let ret = cmd.run().await;
                info!("Replay verify result: {:?}", ret);
                ret
            },
            DBTool::GenReplayVerifyJobs(cmd) => cmd.run().await,
            DBTool::Restore(cmd) => cmd.run().await,
            DBTool::ReplayOnArchive(cmd) => cmd.run().await,
        }
    }
}
```

**File:** testsuite/module_verify.py (L50-50)
```python
            "--skip-epoch-endings",
```
