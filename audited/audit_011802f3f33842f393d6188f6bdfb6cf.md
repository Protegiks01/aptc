# Audit Report

## Title
Case-Insensitive Git URL Canonicalization Enables Dependency Confusion in Move Package Resolver

## Summary
The `PackageLock` and `PackageCache` components use case-insensitive canonicalization of git repository URLs, converting all paths to lowercase. This allows different git repositories with case-variant URLs (e.g., `gitlab.com/victim/Package` vs `gitlab.com/victim/package`) to map to identical BTreeMap keys and cache directories, enabling dependency confusion attacks on case-sensitive git hosting platforms.

## Finding Description

The vulnerability exists in the URL canonicalization logic used by the Move package dependency resolver. When processing git dependencies, the system creates canonical identities by converting repository paths to lowercase. [1](#0-0) 

This canonicalization is used in two critical locations:

1. **Package Lock Keys**: Git dependencies are stored in a BTreeMap using the canonical identity as the key. [2](#0-1) 

The lock key is constructed by combining the canonical identity with the revision: [3](#0-2) 

2. **Package Cache Directories**: The cache uses the canonical identity to determine directory names. [4](#0-3) 

**Attack Scenario on Case-Sensitive Git Servers (GitLab, Self-Hosted):**

On case-sensitive git hosting platforms, `https://gitlab.com/victim/package` and `https://gitlab.com/victim/Package` can be two completely different repositories controlled by different owners. However, both URLs canonicalize to the same string: `gitlab.com/victim/package`.

When multiple packages in a dependency tree reference these case-variant URLs:

1. An attacker creates a malicious repository at `https://gitlab.com/victim/Package` (note capital 'P')
2. The attacker publishes a Move package depending on this malicious repo
3. A victim's legitimate package depends on `https://gitlab.com/victim/package` (lowercase)
4. A third package depends on both

During dependency resolution:
- If the attacker's dependency is resolved first, the lock file stores: `gitlab.com/victim/package@main` â†’ `commit_hash_from_attackers_repo`
- The cache directory `gitlab.com%2Fvictim%2Fpackage` is cloned from the attacker's URL
- When the legitimate dependency is resolved, it uses the same canonical key and returns the cached malicious commit [5](#0-4) 

The actual git clone operation uses the original URL, but once a repository is cached, subsequent operations on the same canonical directory will fetch from the originally-cloned remote: [6](#0-5) 

## Impact Explanation

This is a **High severity** supply chain vulnerability. While it doesn't directly compromise consensus or execution layers, it enables attackers to inject malicious code into Move packages during the build process. Developers could unknowingly compile and deploy compromised packages to the Aptos blockchain, which would then execute malicious code when users interact with these on-chain contracts.

The attack is particularly insidious because:
- The malicious code gets included at build time, before deployment
- Standard code review may miss the substitution if reviewers don't verify git commit hashes
- The lock file will contain the wrong commit hash, making the build non-reproducible from the intended sources
- Multiple packages in the ecosystem could be affected if they share the same case-variant dependency

This could lead to loss of funds when malicious contracts are deployed and invoked on-chain.

## Likelihood Explanation

**Likelihood: Medium**

Requirements for exploitation:
1. Target package must use git dependencies from case-sensitive hosting (GitLab, self-hosted git servers) - **Common**: Many open-source projects use GitLab
2. Attacker must create a repository with a case-variant URL - **Easy**: Any user can create repositories
3. Attacker must publish a package that gets included in the same dependency tree - **Moderate**: Requires the attacker's package to be depended upon
4. Resolution order must favor the attacker's dependency - **Variable**: Depends on dependency graph structure

The attack doesn't require validator access or protocol-level exploitation, making it accessible to any malicious actor in the Move package ecosystem.

## Recommendation

Implement strict case-sensitive URL handling to prevent collisions:

1. **Store Original URLs**: Preserve the original URL casing in the canonical identity instead of converting to lowercase
2. **Validate Cache Consistency**: Before reusing a cached repository, verify the origin URL matches exactly
3. **Add Integrity Checks**: Include URL checksums in lock files to detect substitutions

**Code Fix for canonical.rs**:
```rust
// Remove the to_ascii_lowercase() call
let path = git_url.path(); // Keep original casing
let path = path.trim_end_matches("/").trim_end_matches(".git");
```

**Additional Validation in package_cache.rs**:
```rust
// Before reusing cached repo, verify origin URL matches
if repo_path.exists() {
    let repo = Repository::open_bare(&repo_path)?;
    let remote = repo.find_remote("origin")?;
    let origin_url = remote.url().ok_or_else(|| anyhow!("no origin URL"))?;
    
    if origin_url != git_url.as_str() {
        bail!("Cached repo origin mismatch: expected {}, got {}", git_url, origin_url);
    }
    // ... continue with fetch
}
```

## Proof of Concept

**Setup Requirements:**
- GitLab account or self-hosted case-sensitive git server
- Two repositories: `victim/package` and `victim/Package`

**Step 1**: Create two git repositories:
```bash
# Legitimate repository
git clone https://gitlab.com/victim/package
cd package
# Create legitimate Move.toml and sources
git add . && git commit -m "legit" && git push

# Malicious repository  
git clone https://gitlab.com/victim/Package
cd Package
# Create malicious Move.toml with backdoor code
git add . && git commit -m "malicious" && git push
```

**Step 2**: Create Package A (victim, uses legitimate repo):
```toml
# Move.toml
[dependencies]
TargetDep = { git = "https://gitlab.com/victim/package", rev = "main" }
```

**Step 3**: Create Package B (attacker, uses malicious repo):
```toml
# Move.toml
[dependencies]
TargetDep = { git = "https://gitlab.com/victim/Package", rev = "main" }
```

**Step 4**: Create Package C (depends on both):
```toml
# Move.toml
[dependencies]
PackageA = { local = "../package-a" }
PackageB = { local = "../package-b" }
```

**Step 5**: Build Package C:
```bash
cd package-c
aptos move compile
```

**Expected Result**: If Package B's dependency is resolved first, the lock file will contain a commit hash from the malicious `Package` repository, and Package A will unknowingly use the malicious code due to the case-collision in the canonical key `gitlab.com/victim/package@main`.

**Verification**: Check the generated `Move.lock` file - both dependencies will have the same canonical key but potentially different (wrong) commit hashes, and inspect the cached directory to confirm it was cloned from the first-resolved URL.

## Notes

This vulnerability specifically affects Move package dependency resolution during build time. While it doesn't directly compromise the Aptos blockchain consensus or execution layers, it represents a critical supply chain attack vector that could result in malicious contracts being deployed on-chain. The impact is amplified in ecosystems where developers rely on git dependencies from case-sensitive hosting platforms like GitLab.

GitHub is case-insensitive and would redirect case-variant URLs to the canonical repository, mitigating this specific attack vector on that platform. However, the broader Move ecosystem includes packages from various git hosting solutions, including self-hosted servers that may be case-sensitive.

### Citations

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L34-34)
```rust
        let path = git_url.path().to_ascii_lowercase();
```

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L21-25)
```rust
    // git_identity (stringified) -> commit_id
    git: BTreeMap<String, String>,

    // node_identity (stringified) -> version
    on_chain: BTreeMap<String, u64>,
```

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L71-73)
```rust
        let git_identity = CanonicalGitIdentity::new(git_url)?;

        let repo_loc_and_rev = format!("{}@{}", git_identity, rev);
```

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L75-81)
```rust
        let res = match self.git.entry(repo_loc_and_rev) {
            btree_map::Entry::Occupied(entry) => entry.get().clone(),
            btree_map::Entry::Vacant(entry) => {
                let oid = package_cache.resolve_git_revision(git_url, rev).await?;
                entry.insert(oid.to_string()).clone()
            },
        };
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L97-99)
```rust
        let repo_dir_name = percent_encode_for_filename(&CanonicalGitIdentity::new(git_url)?);
        let repos_path = self.root.join("git").join("repos");
        let repo_path = repos_path.join(&repo_dir_name);
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L167-168)
```rust
                .clone(git_url.as_str(), &repo_path)
                .map_err(|err| anyhow!("Failed to clone git repo at {}: {}", git_url, err))?;
```
