# Audit Report

## Title
Unvalidated Author Field in SecretShare Verification Causes Validator Node Crash via Panic

## Summary
The `SecretShareConfig::get_id()` function uses `.expect()` when looking up validator indices, causing a panic when an invalid author is provided. A malicious network peer can send a `SecretShareMessage` with an arbitrary author field not in the current validator set, triggering an unrecoverable panic that crashes the entire validator node process. [1](#0-0) 

## Finding Description
When a validator receives a `SecretShareMessage::Share` from the network, it processes the message through a verification task that eventually calls `SecretShare::verify()`. This verification function retrieves the validator index by calling `config.get_id(self.author())`, where `self.author()` is a field from the deserialized message that can contain any arbitrary `AccountAddress`. [2](#0-1) 

The `get_id()` implementation uses `.expect("Peer should be in the index!")`, which panics if the author address is not found in the validator set. There is even a TODO comment acknowledging the missing bounds check.

The attack flow is:
1. Attacker crafts a `SecretShareMessage::Share` containing a `SecretShare` with the `author` field set to an address **not** in the current validator set
2. Attacker sends this message to a target validator via the consensus network
3. The message is received and routed to `SecretShareManager::verification_task()`
4. The verification task deserializes the message and calls `msg.verify()` [3](#0-2) 

5. During verification, `get_id()` is called with the malicious author, causing a panic
6. The panic is caught by the global panic handler, which exits the process with code 12 [4](#0-3) 

The verification happens in a `BoundedExecutor` spawned task, and while the JoinHandle is obtained, it is not awaited for completion. This means panics in the verification task trigger the global panic handler rather than being caught locally. The global panic handler unconditionally exits the process (unless the panic occurs in Move verifier/deserializer contexts), resulting in complete validator node termination. [5](#0-4) 

There is no validation that the claimed `author` in the message matches the network `sender` (peer_id), nor is there any check that the author exists in the validator set before calling `get_id()`.

## Impact Explanation
This vulnerability constitutes **HIGH severity** under the Aptos Bug Bounty criteria, specifically "Validator node slowdowns" and "API crashes". However, it could potentially escalate to **CRITICAL severity** as "Total loss of liveness/network availability" because:

1. **Complete Node Termination**: The validator process exits entirely, not just a single thread or task
2. **Trivial Attack Complexity**: Requires only network access and the ability to send a single malformed message
3. **No Authentication Required**: Any peer with network connectivity can exploit this
4. **Coordinated Attack Potential**: Attacker could crash multiple validators simultaneously, causing network-wide liveness failure
5. **Rapid Re-exploitation**: Even after restart, the node remains vulnerable to the same attack

The vulnerability directly violates the **Consensus Safety** invariant by enabling denial-of-service attacks that can halt block production across the network.

## Likelihood Explanation
**Likelihood: HIGH**

This vulnerability has high likelihood of exploitation because:

1. **Low Attacker Requirements**: Only requires network peer capability, no validator privileges needed
2. **Simple Exploitation**: Single malformed message triggers the crash
3. **Wide Attack Surface**: All validators running secret sharing are vulnerable
4. **No Rate Limiting**: The verification task will process any incoming message
5. **Observable Behavior**: Attacker can confirm success by observing validator disconnection

The attack can be executed repeatedly and at scale, potentially targeting the entire validator set to cause network-wide outages.

## Recommendation
Replace the `.expect()` call with proper error handling that returns a `Result`:

**File: `types/src/secret_sharing.rs`**

```rust
impl SecretShareConfig {
    pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
        self.validator
            .address_to_validator_index()
            .get(peer)
            .copied()
            .ok_or_else(|| anyhow!("Author {} not found in validator set", peer))
    }
}
```

**File: `types/src/secret_sharing.rs` (SecretShare::verify)**

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author())?;
    let decryption_key_share = self.share().clone();
    ensure!(
        index < config.verification_keys.len(),
        "Index {} out of bounds for verification keys", 
        index
    );
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

Apply the same pattern to `RandConfig::get_id()` and `SecretSharingConfig::get_id()` for consistency: [6](#0-5) [7](#0-6) 

Additionally, consider adding validation that the message author matches the network sender to prevent spoofing.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    
    #[test]
    #[should_panic(expected = "Peer should be in the index!")]
    fn test_get_id_panic_on_invalid_author() {
        // Setup: Create a SecretShareConfig with a specific validator set
        let valid_validators = vec![
            AccountAddress::from_hex_literal("0x1").unwrap(),
            AccountAddress::from_hex_literal("0x2").unwrap(),
        ];
        
        let validator_verifier = create_test_validator_verifier(valid_validators);
        let config = SecretShareConfig::new(
            AccountAddress::from_hex_literal("0x1").unwrap(),
            1,
            Arc::new(validator_verifier),
            // ... other params
        );
        
        // Attack: Create a SecretShare with an author NOT in the validator set
        let malicious_author = AccountAddress::from_hex_literal("0xDEADBEEF").unwrap();
        let malicious_share = SecretShare::new(
            malicious_author,
            SecretShareMetadata::default(),
            create_dummy_share(),
        );
        
        // This will panic and crash the process
        let _ = malicious_share.verify(&config);
    }
}
```

To demonstrate the full attack path, an integration test would:
1. Start a validator node with secret sharing enabled
2. Connect as a network peer
3. Send a `SecretShareMessage::Share` with invalid author
4. Observe the validator process exit with code 12

**Notes**

The vulnerability exists in three parallel implementations (`SecretShareConfig`, `RandConfig`, `SecretSharingConfig`), though the attack path analysis focused on the `SecretShareConfig` variant as it's directly reachable from network message processing. The other implementations should be fixed as well to prevent similar issues. The codebase shows inconsistent error handling patterns - some functions like `Share::verify` in `rand_gen/types.rs` properly use `ok_or_else()`, while others use `.expect()`, indicating this is a systemic issue requiring a broader code review.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L217-226)
```rust
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L27-38)
```rust
impl SecretShareMessage {
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L630-636)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/types.rs (L75-81)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```
