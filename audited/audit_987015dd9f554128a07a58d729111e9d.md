# Audit Report

## Title
REST Discovery Trust Injection Vulnerability Enabling Malicious Peer Authentication

## Summary
The REST-based peer discovery mechanism lacks cryptographic validation of ValidatorSet data, allowing a compromised REST endpoint to inject malicious validator public keys that are merged into the trusted peer set. While this does NOT enable consensus takeover (due to separate ValidatorVerifier protection), it allows unauthorized peers to authenticate at the network layer, enabling information leakage, DoS attacks, and potential eclipse attacks.

## Finding Description

The vulnerability exists in how REST-discovered validator information is trusted and merged into the network's trusted peer set. The attack flow is:

**Step 1: Unauthenticated REST Data Fetching** [1](#0-0) 

The `poll_next()` function fetches ValidatorSet data from a REST endpoint via `get_account_resource_bcs()` with no cryptographic validation beyond BCS deserialization.

**Step 2: No Cryptographic Verification in REST Client** [2](#0-1) 

The REST client only checks HTTP status codes and deserializes BCS data - no signature verification, no Merkle proof validation, no attestation of authenticity. [3](#0-2) 

**Step 3: Malicious Keys Merged via Union** [4](#0-3) 

The `extract_validator_set_updates()` function blindly trusts the REST-provided ValidatorSet and extracts peer addresses and public keys. [5](#0-4) 

When the ConnectivityManager receives the update, it merges the keys from the REST source with keys from other sources.

**Step 4: Non-Prioritized Key Union** [6](#0-5) 

The critical flaw: `PublicKeys::union()` creates a flat union of ALL public keys from ALL sources without prioritizing higher-trust sources (OnChainValidatorSet) over lower-trust sources (REST). [7](#0-6) 

When converting to eligible peers, the union of all keys is used.

**Step 5: Malicious Keys Installed as Trusted** [8](#0-7) 

The merged keys (including malicious ones from REST) are installed as the `trusted_peers` set used for Noise handshake authentication.

**Step 6: Successful Malicious Peer Authentication** [9](#0-8) 

During mutual authentication, the malicious peer's public key is validated against `trusted_peers` - and succeeds because the REST-injected key is present.

**Attack Scenario:**
1. Attacker compromises a REST API endpoint (or performs MITM)
2. Endpoint returns crafted ValidatorSet with attacker-controlled public keys and addresses
3. Victim node running REST discovery accepts this data without validation
4. Malicious keys are merged into `trusted_peers` via `union()`
5. Attacker's nodes successfully authenticate via Noise handshake
6. Malicious peers can now:
   - Receive all consensus gossip (information leakage about proposals, votes, network topology)
   - Send malformed messages to consume victim resources (DoS)
   - Monopolize victim's connections (eclipse attack)

**Important Limitation:**
This vulnerability does NOT enable consensus takeover because consensus message validation uses a separate `ValidatorVerifier` derived from on-chain state, not from discovered peers. Malicious peers cannot forge consensus votes or blocks regardless of network-layer authentication. [10](#0-9) 

Despite the comment claiming priority ordering, the `union()` implementation ignores this priority.

## Impact Explanation

**Severity: HIGH** (Not Critical despite the question's framing)

While this vulnerability does NOT allow "network takeover through validator set manipulation" as the question suggests, it breaks critical network-layer security guarantees:

1. **Information Leakage**: Malicious authenticated peers receive all consensus messages, learning about proposals, votes, validator set changes, and network topology. This violates the confidentiality assumption of the validator network.

2. **Denial of Service**: Authenticated malicious peers can flood victims with invalid consensus messages, consume CPU/bandwidth processing them, and degrade network performance.

3. **Eclipse Attack Potential**: If multiple nodes use compromised REST endpoints, malicious peers could monopolize connections and isolate legitimate validators from each other.

4. **Trust Model Violation**: The architecture assumes `trusted_peers` contains only legitimate validators. This assumption is violated, breaking downstream security properties.

This does NOT qualify as Critical severity because:
- No consensus safety violation (ValidatorVerifier prevents malicious block/vote creation)
- No direct fund loss or theft
- Requires nodes to be configured with REST discovery (not default for validators) [11](#0-10) 

However, it qualifies as HIGH severity per the bug bounty criteria:
- Enables "significant protocol violations" (network-layer trust breach)
- Can cause "validator node slowdowns" (DoS from malicious peers)
- Affects network availability and security posture

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH** (depending on deployment)

**Factors increasing likelihood:**
1. REST endpoints are external services that can be compromised or MITM'd
2. No cryptographic validation means any compromised REST endpoint is exploitable
3. The `union()` merging strategy makes the attack trivial once a REST endpoint is compromised
4. Nodes configured with REST discovery are immediately vulnerable

**Factors decreasing likelihood:**
1. Validator nodes typically use `discovery_method: "onchain"` not REST
2. REST discovery appears intended for light clients/VFNs that cannot query chain state
3. Requires attacker to compromise specific REST endpoints used by target nodes

**Realistic exploitation scenario:**
- Attacker compromises a public REST API service
- VFNs or misconfigured validators using this endpoint become vulnerable
- Attacker injects malicious validator keys
- Malicious peers authenticate and begin receiving consensus gossip

The attack is **highly realistic if REST discovery is configured** and requires only:
- Compromising a web service (well-known attack vector)
- Basic knowledge of ValidatorSet structure and BCS serialization

## Recommendation

**Fix 1: Add Cryptographic Validation to REST Discovery**

The REST client should verify ValidatorSet data against on-chain state or cryptographic proofs. Options:
- Require signed attestations from known authorities
- Verify state proofs for the ValidatorSet resource
- Cross-validate REST data against multiple independent sources

**Fix 2: Implement Proper Source Prioritization in PublicKeys::union()**

Modify the `union()` method to prioritize higher-trust sources:

```rust
// In network/framework/src/connectivity_manager/mod.rs
impl PublicKeys {
    fn union(&self) -> HashSet<x25519::PublicKey> {
        // Prioritize by discovery source order: OnChain > File > Rest > Config
        // Only use lower-priority sources if higher-priority sources are empty
        for src_idx in 0..DiscoverySource::NUM_VARIANTS {
            if !self.0[src_idx].is_empty() {
                return self.0[src_idx].clone();
            }
        }
        HashSet::new()
    }
}
```

This ensures OnChainValidatorSet keys always take precedence over REST-discovered keys.

**Fix 3: Deprecate or Restrict REST Discovery**

Consider:
- Deprecating REST discovery entirely for production networks
- Adding explicit warnings when REST discovery is configured
- Requiring additional authentication/authorization for REST endpoints
- Making REST discovery opt-in with security disclaimers

**Fix 4: Add Cross-Validation Between Discovery Sources**

When multiple discovery sources are active, validate that they agree on the validator set. Flag discrepancies for investigation rather than silently merging.

## Proof of Concept

```rust
// Exploit demonstration (conceptual - would need full environment)

use aptos_rest_client::Client;
use aptos_types::on_chain_config::ValidatorSet;
use aptos_types::validator_info::ValidatorInfo;
use aptos_types::validator_config::ValidatorConfig;
use aptos_crypto::{bls12381, x25519};

// 1. Attacker compromises REST endpoint or performs MITM
// 2. Attacker creates malicious ValidatorSet

fn create_malicious_validator_set() -> ValidatorSet {
    let attacker_consensus_key = bls12381::PrivateKey::generate_for_testing().public_key();
    let attacker_network_key = x25519::PrivateKey::generate_for_testing().public_key();
    let attacker_account = aptos_types::account_address::AccountAddress::random();
    
    // Create malicious validator config with attacker's keys
    let addresses = vec![/* attacker's network addresses */];
    let validator_config = ValidatorConfig::new(
        attacker_consensus_key,
        bcs::to_bytes(&addresses).unwrap(),
        bcs::to_bytes(&addresses).unwrap(),
        0,
    );
    
    let malicious_validator = ValidatorInfo::new(
        attacker_account,
        0,
        validator_config,
    );
    
    ValidatorSet::new(vec![malicious_validator])
}

// 3. REST endpoint returns this malicious ValidatorSet
// 4. RestStream.poll_next() accepts it without validation
// 5. extract_validator_set_updates() extracts attacker's keys
// 6. ConnectivityManager adds to trusted_peers via union()
// 7. Attacker's node authenticates successfully
// 8. Attacker receives all consensus messages and can send malformed data
```

**Steps to reproduce:**
1. Configure a node with `discovery_method: rest` pointing to a controlled endpoint
2. Endpoint returns malicious ValidatorSet with attacker's x25519 public keys
3. Observe that attacker's node successfully completes Noise handshake
4. Verify attacker receives consensus gossip messages
5. Demonstrate DoS by flooding victim with invalid consensus messages

## Notes

**Critical Clarification:** This vulnerability does NOT enable the "network takeover" claimed in the security question. The separation between network-layer trust (`trusted_peers`) and consensus-layer trust (`ValidatorVerifier`) prevents malicious peers from forging consensus messages or participating in quorum.

The consensus layer remains secure through: [12](#0-11) 

However, the vulnerability is still significant because it violates network-layer security assumptions and enables DoS, information leakage, and eclipse attacks against nodes using REST discovery.

### Citations

**File:** network/discovery/src/rest.rs (L42-68)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
            Err(err) => {
                info!(
                    "Failed to retrieve validator set by REST discovery {:?}",
                    err
                );
                Some(Err(DiscoveryError::Rest(err)))
            },
        })
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1221)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L135-144)
```rust
/// Different sources for peer addresses, ordered by priority (Onchain=highest,
/// Config=lowest).
#[repr(u8)]
#[derive(Copy, Clone, Eq, Hash, PartialEq, Ord, PartialOrd, NumVariants, Serialize)]
pub enum DiscoverySource {
    OnChainValidatorSet,
    File,
    Rest,
    Config,
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L305-309)
```rust
impl From<&DiscoveredPeer> for Peer {
    fn from(peer: &DiscoveredPeer) -> Self {
        Peer::new(peer.addrs.union(), peer.keys.union(), peer.role)
    }
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L884-1001)
```rust
    /// Handles an update for newly discovered peers. This typically
    /// occurs at node startup, and on epoch changes.
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .discovery_source(&src),
                    "{} pubkey sets updated for peer: {}, pubkeys: {}",
                    self.network_context,
                    peer_id.short_str(),
                    peer.keys
                );
                keys_updated = true;
                peer_updated = true;
            }

            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }

            // If we're currently trying to dial this peer, we reset their
            // dial state. As a result, we will begin our next dial attempt
            // from the first address (which might have changed) and from a
            // fresh backoff (since the current backoff delay might be maxed
            // out if we can't reach any of their previous addresses).
            if peer_updated {
                if let Some(dial_state) = self.dial_states.get_mut(&peer_id) {
                    *dial_state = DialState::new(self.backoff_strategy.clone());
                }
            }
        }

        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1320-1322)
```rust
    fn union(&self) -> HashSet<x25519::PublicKey> {
        self.0.iter().flatten().copied().collect()
    }
```

**File:** network/framework/src/noise/handshake.rs (L76-99)
```rust
/// Noise handshake authentication mode.
pub enum HandshakeAuthMode {
    /// In `Mutual` mode, both sides will authenticate each other with their
    /// `trusted_peers` set. We also include replay attack mitigation in this mode.
    ///
    /// For example, in the Aptos validator network, validator peers will only
    /// allow connections from other validator peers. They will use this mode to
    /// check that inbound connections authenticate to a network public key
    /// actually contained in the current validator set.
    Mutual {
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
        peers_and_metadata: Arc<PeersAndMetadata>,
    },
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
}
```

**File:** config/src/config/test_data/validator.yaml (L40-41)
```yaml
validator_network:
    discovery_method: "onchain"
```

**File:** types/src/validator_verifier.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#[cfg(any(test, feature = "fuzzing"))]
use crate::validator_signer::ValidatorSigner;
use crate::{
    account_address::AccountAddress, aggregate_signature::AggregateSignature,
    ledger_info::SignatureWithStatus, on_chain_config::ValidatorSet,
};
use anyhow::{ensure, Result};
use aptos_bitvec::BitVec;
use aptos_crypto::{
    bls12381,
    bls12381::{bls12381_keys, PublicKey},
    hash::CryptoHash,
    Signature, VerifyingKey,
};
use dashmap::DashSet;
use derivative::Derivative;
use itertools::Itertools;
#[cfg(any(test, feature = "fuzzing"))]
use proptest_derive::Arbitrary;
use rayon::iter::{IndexedParallelIterator, IntoParallelIterator, ParallelIterator};
use serde::{Deserialize, Deserializer, Serialize};
use std::{
    collections::{BTreeMap, HashMap},
    fmt,
};
use thiserror::Error;

/// Errors possible during signature verification.
#[derive(Debug, Error, PartialEq, Eq)]
pub enum VerifyError {
    #[error("Author is unknown")]
    /// The author for this signature is unknown by this validator.
    UnknownAuthor,
    #[error(
        "The voting power ({}) is less than expected voting power ({})",
        voting_power,
        expected_voting_power
    )]
    TooLittleVotingPower {
        voting_power: u128,
        expected_voting_power: u128,
    },
    #[error("Signature is empty")]
    /// The signature is empty
    EmptySignature,
    #[error("Multi signature is invalid")]
    /// The multi signature is invalid
```
