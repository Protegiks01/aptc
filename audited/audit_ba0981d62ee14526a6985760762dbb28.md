# Audit Report

## Title
Path Traversal in Move Package Dependency Resolution - Limited Information Disclosure

## Summary
The Move package system accepts dependency paths without validation, allowing path traversal sequences like `../../../`. However, contrary to the "Critical" severity claim, this vulnerability **cannot** read arbitrary files like private keys or `/etc/passwd`. It is limited to reading Move package structures (Move.toml and .move source files) and requires manual compilation by a validator operator.

## Finding Description

The vulnerability exists in the manifest parsing and dependency resolution system: [1](#0-0) 

When parsing a local dependency from Move.toml, the code extracts the path string and converts it directly to a `PathBuf` without any validation or sanitization of path traversal sequences.

During dependency resolution, this path is used without canonicalization: [2](#0-1) 

The `root_path.push(&dep.local)` operation allows traversal to arbitrary directories on the filesystem.

**Critical Constraint**: The system only attempts to read `Move.toml` from the traversed path: [3](#0-2) 

This means an attacker **cannot** directly read `/etc/passwd` or private keys. The system will only read files that:
1. Are named `Move.toml` and are valid TOML with package metadata
2. Are `.move` source files in standard directories (`sources/`, `tests/`, etc.)

The production Aptos CLI uses this vulnerable system: [4](#0-3) 

**Note**: A newer package resolver system exists with proper protections against path traversal: [5](#0-4) 

However, this newer system is not used by the production package compilation pipeline.

## Impact Explanation

**Actual Impact: LOW to MEDIUM** (not Critical as claimed)

The vulnerability **cannot** achieve what the security question claims:
- ❌ Cannot read `/etc/passwd` (wrong filename, wrong format)
- ❌ Cannot read private keys from `~/.aptos/config.yaml` or `/root/.ssh/id_rsa` (wrong filename/format)
- ❌ Cannot read arbitrary configuration files
- ✓ Can probe filesystem structure for existence of directories
- ✓ Can read Move source files from other packages if paths are known
- ✓ Can read Move.toml files which might contain metadata

This is an **information disclosure** vulnerability limited to the Move package ecosystem, not arbitrary file read. It does not affect consensus, validator operation, or fund security.

## Likelihood Explanation

**Likelihood: LOW**

Attack prerequisites:
1. Attacker must craft a malicious Move.toml manifest
2. Validator operator or developer must manually compile the malicious package
3. Target system must contain Move packages at predictable paths
4. Sensitive information must be stored in Move source files (bad practice)

This is **not** an automatic remote exploit. It requires social engineering or misconfiguration. Validators do not automatically compile untrusted packages during normal operation.

## Recommendation

Implement path validation in the manifest parser to reject path traversal sequences:

```rust
// In parse_dependency function
let local_str = local
    .as_str()
    .ok_or_else(|| format_err!("Local source path not a string"))?;

// Validate path doesn't contain traversal sequences
if local_str.contains("..") {
    bail!("Local dependency path cannot contain '..' (path traversal)");
}

let local_path = PathBuf::from(local_str);
```

**Better solution**: Migrate to the newer `move-package-resolver` system which already has proper path canonicalization: [6](#0-5) 

## Proof of Concept

Create a malicious `Move.toml`:
```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
# Attempt to traverse to another package
TargetPackage = { local = "../../../some/other/move/package" }
```

When a validator compiles this package using `aptos move compile`, the system will:
1. Accept the path traversal sequence without validation
2. Attempt to read `Move.toml` from the traversed path
3. If valid, read `.move` source files from that package
4. Include those files in compilation, potentially exposing them through error messages

**However**: This only works if the target directory contains a valid Move package structure, not for reading arbitrary files.

---

## Notes

**This is NOT a Critical vulnerability** despite the security question's claim. The path traversal exists but cannot expose private keys or configuration files as asserted. The vulnerability is constrained to reading Move package contents and requires manual compilation by trusted operators. 

The actual severity is **LOW to MEDIUM** - it's a development tool security issue with limited information disclosure potential, not a validator/consensus security issue warranting Critical classification.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L342-354)
```rust
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L504-504)
```rust
        root_path.push(&dep.local);
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L505-516)
```rust
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L217-218)
```rust
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        let resolution_graph = ResolutionGraph::new(manifest, path, self, writer)?;
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L334-340)
```rust
                let canonical_path = CanonicalPath::new(&dep_manitest_path).map_err(|err| {
                    anyhow!(
                        "failed to find package at {}: {}",
                        dep_manitest_path.display(),
                        err
                    )
                })?;
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L367-372)
```rust
                let normalized_new_subdir = NormalizedPath::new(&new_subdir);
                if let Some(std::path::Component::ParentDir) =
                    normalized_new_subdir.components().next()
                {
                    bail!("subdir outside of repo root: {}", new_subdir.display());
                }
```
