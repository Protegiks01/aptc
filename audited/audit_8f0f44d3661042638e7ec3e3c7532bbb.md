# Audit Report

## Title
Authentication Bypass via Header Injection in Aptos Faucet AuthTokenChecker

## Summary
A logic flaw in the `AuthTokenChecker` allows attackers to bypass authentication by injecting the `x-is-jwt` header with an invalid value. The checker validates only the header's presence, not its value, creating a bypass window where requests are neither authenticated via auth tokens nor validated via JWT.

## Finding Description

The Aptos faucet's authentication system contains a critical mismatch between the bypass condition and validation condition for JWT-based requests.

**The Vulnerability Location:**

The `AuthTokenChecker` implementation contains a conditional bypass that checks only for the header key's existence: [1](#0-0) 

This code returns an empty rejection list (allowing the request) whenever the `X_IS_JWT_HEADER` key exists, **regardless of its value**.

However, JWT validation in the system requires the header value to be specifically `"true"` (case-insensitive): [2](#0-1) 

**The Mismatch:**
- **Bypass condition** (AuthTokenChecker): Header key `x-is-jwt` exists (any value)
- **Validation condition** (JWT verification): Header value must equal `"true"`

This creates an authentication gap where an attacker can:
1. Set header: `x-is-jwt: false` (or any non-`"true"` value)
2. Bypass `AuthTokenChecker` (header key exists → returns empty rejection list)
3. Avoid JWT validation (value is not `"true"` → JWT verification never executes)
4. Proceed without authentication if no other auth checkers are configured

**Attack Path:**

The request processing flow shows how unsanitized headers are passed directly into `CheckerData`: [3](#0-2) 

The headers from the HTTP request are cloned directly into `CheckerData` with **no sanitization**, allowing arbitrary header injection: [4](#0-3) 

The checkers then run in sequence, and if all return empty rejection lists, the request is approved: [5](#0-4) 

**Exploitation Scenario:**

Consider a faucet configured with:
- `AuthTokenChecker` (requires valid API key in Authorization header)
- `MemoryRatelimitChecker` or IP-based `RedisRatelimitChecker` (no JWT validation)
- No other authentication mechanisms

An attacker sends:
```http
POST /fund HTTP/1.1
x-is-jwt: false
Content-Type: application/json

{"address": "0xAttackerAddress"}
```

Result:
1. `AuthTokenChecker.check()` sees `x-is-jwt` header exists → returns `Ok(vec![])` (bypass)
2. No JWT validation occurs (value is not `"true"`)
3. `MemoryRatelimitChecker` only checks IP, no authentication
4. Request approved **without any authentication**

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability breaks the **Access Control** invariant for the faucet service, allowing:

1. **Unauthorized Fund Access**: Attackers can drain faucet funds without valid authentication credentials
2. **Authentication Bypass**: Complete circumvention of the intended auth token protection mechanism
3. **Service Abuse**: Attackers can exhaust test token supplies, impacting legitimate developers

While this affects the faucet service (not core consensus), it represents a **significant protocol violation** and enables **limited funds loss** through unauthorized minting/transfer of test tokens.

The impact is classified as **High** because:
- It's a complete authentication bypass (not just a weakness)
- Exploitable by any external attacker with network access
- Can cause service disruption and fund depletion
- Affects faucet availability for legitimate users

This does not reach Critical severity because:
- Only affects testnet faucet funds, not mainnet or user funds
- Does not compromise validator nodes or consensus
- Requires specific faucet configuration (AuthTokenChecker without JWT-based rate limiting)

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is highly likely to be exploitable in practice because:

1. **Simple Attack Vector**: Requires only adding a single HTTP header (`x-is-jwt: false`)
2. **No Prerequisites**: No special credentials, insider access, or complex setup needed
3. **Realistic Configuration**: Faucets commonly use API key authentication with IP-based rate limiting
4. **Production Code**: The vulnerable code is in the main codebase, not test-only paths

The likelihood is not "Certain" because:
- It requires the faucet to be configured with `AuthTokenChecker` but NOT JWT-based rate limiting
- Some deployments may use JWT-based `RedisRatelimitChecker`, which would catch this attack
- The issue may not exist if no `AuthTokenChecker` is configured

However, the documentation and code structure suggest `AuthTokenChecker` is a common configuration option for production faucets, making this a realistic threat.

## Recommendation

**Fix the logic mismatch** by validating both the presence AND value of the `X_IS_JWT_HEADER` in `AuthTokenChecker`:

```rust
// In crates/aptos-faucet/core/src/checkers/auth_token.rs

async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // Don't check if the request has X_IS_JWT_HEADER set to "true"
    // (indicating JWT-based authentication is being used)
    if let Some(header_value) = data.headers.get(X_IS_JWT_HEADER) {
        if let Ok(value_str) = header_value.to_str() {
            if value_str.eq_ignore_ascii_case("true") {
                return Ok(vec![]);
            }
        }
    }

    let auth_token = match data
        .headers
        .get(AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.split_whitespace().nth(1))
    {
        Some(auth_token) => auth_token,
        None => return Ok(vec![RejectionReason::new(
            "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
            RejectionReasonCode::AuthTokenInvalid,
        )]),
    };
    
    // ... rest of the function
}
```

**Alternative Fix**: Apply the same validation logic consistently in both `AuthTokenChecker` and `AuthTokenBypasser` by creating a shared helper function:

```rust
fn should_use_jwt_auth(headers: &HeaderMap) -> bool {
    headers
        .get(X_IS_JWT_HEADER)
        .and_then(|v| v.to_str().ok())
        .map(|v| v.eq_ignore_ascii_case("true"))
        .unwrap_or(false)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_auth_bypass {
    use super::*;
    use poem::http::HeaderMap;
    use std::sync::Arc;
    use std::net::IpAddr;
    use aptos_sdk::types::account_address::AccountAddress;

    #[tokio::test]
    async fn test_header_injection_bypass() {
        // Setup: Create AuthTokenChecker with a valid token
        let config = ListManagerConfig {
            list: vec!["valid_token_123".to_string()],
        };
        let checker = AuthTokenChecker::new(config).unwrap();

        // Attack: Inject x-is-jwt header with invalid value
        let mut headers = HeaderMap::new();
        headers.insert("x-is-jwt", "false".parse().unwrap());
        // Note: NOT providing Authorization header

        let checker_data = CheckerData {
            time_request_received_secs: 1234567890,
            receiver: AccountAddress::from_hex_literal("0x1").unwrap(),
            source_ip: "127.0.0.1".parse::<IpAddr>().unwrap(),
            headers: Arc::new(headers),
        };

        // Execute check
        let result = checker.check(checker_data, false).await.unwrap();

        // Verify: Should bypass authentication (empty rejection list)
        assert!(result.is_empty(), 
            "VULNERABILITY: Authentication bypassed with x-is-jwt: false header!");
    }

    #[tokio::test]
    async fn test_correct_behavior_without_header() {
        // Setup
        let config = ListManagerConfig {
            list: vec!["valid_token_123".to_string()],
        };
        let checker = AuthTokenChecker::new(config).unwrap();

        // Normal request without x-is-jwt header
        let headers = HeaderMap::new();

        let checker_data = CheckerData {
            time_request_received_secs: 1234567890,
            receiver: AccountAddress::from_hex_literal("0x1").unwrap(),
            source_ip: "127.0.0.1".parse::<IpAddr>().unwrap(),
            headers: Arc::new(headers),
        };

        // Execute check
        let result = checker.check(checker_data, false).await.unwrap();

        // Verify: Should reject (no Authorization header provided)
        assert!(!result.is_empty(), "Should reject when no auth token provided");
    }
}
```

**To reproduce:**
1. Configure a faucet with `AuthTokenChecker` and IP-based rate limiting
2. Send a fund request with header `x-is-jwt: false` (or any non-"true" value)
3. Observe that the request bypasses authentication and succeeds without a valid API key

## Notes

The root cause is a **semantic mismatch** between two related checks: the bypass condition checks for header key existence while the validation condition checks for a specific header value. This is a classic TOCTOU-style vulnerability where the decision to bypass happens before the decision to validate would occur, creating a gap that attackers can exploit through careful header manipulation.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L70-89)
```rust
    let is_jwt = headers
        .get(X_IS_JWT_HEADER)
        .and_then(|v| v.to_str().ok())
        .map(|v| v.eq_ignore_ascii_case("true"))
        .ok_or_else(|| {
            AptosTapError::new(
                format!(
                    "The {} header must be present and set to 'true'",
                    X_IS_JWT_HEADER
                ),
                AptosTapErrorCode::AuthTokenInvalid,
            )
        })?;

    if !is_jwt {
        return Err(AptosTapError::new(
            format!("The {} header must be set to 'true'", X_IS_JWT_HEADER),
            AptosTapErrorCode::AuthTokenInvalid,
        ));
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L147-153)
```rust
#[derive(Clone, Debug)]
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```
