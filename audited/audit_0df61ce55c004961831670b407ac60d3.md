# Audit Report

## Title
Race Condition in Module Read Validation Allows Consensus Safety Violation in BlockSTMv2

## Summary
A critical TOCTOU (Time-Of-Check-Time-Of-Use) race condition in `SchedulerV2::record_validation_requirements` allows transactions to escape module read validation when modules are published, leading to non-deterministic execution across validators and consensus safety violations.

## Finding Description

BlockSTMv2's module validation system contains a race condition that allows transactions to bypass required module read validation when modules are published during transaction commit. The vulnerability exists in the interaction between the commit coordinator thread and worker threads processing the execution queue.

When a transaction publishes modules, the commit coordinator calls `record_validation_requirements` to schedule validation for transactions that may have read old module versions. The method reads `min_never_scheduled_idx` from the execution queue manager [1](#0-0) , checks it for validity [2](#0-1) , then passes this value to `cold_validation_requirements.record_requirements` [3](#0-2) .

However, between reading `min_never_scheduled_idx` and using it, worker threads can concurrently call `next_task()` which invokes `pop_next()` on the execution queue [4](#0-3) . The `pop_next()` method pops a transaction from the queue and atomically updates `min_never_scheduled_idx` [5](#0-4) .

**Critical Race Window:**

The commit coordinator executes `prepare_and_queue_commit_ready_txn` while holding the `queueing_commits_lock` [6](#0-5) . However, worker threads call `next_task()` immediately after the lock is released [7](#0-6) , creating the race window.

When `record_requirements` receives the stale `min_never_scheduled_idx` value, it creates a pending requirement with range `[calling_txn_idx + 1, min_never_scheduled_idx)` [8](#0-7) . A transaction that was popped during the race window falls outside this exclusive upper bound and is excluded from validation requirements.

The transaction will not be blocked from committing because after all requirements are processed, `min_idx_with_unprocessed_validation_requirement` is set to `u32::MAX` when the active requirements become empty [9](#0-8) . The commit blocking check `min_idx_with_unprocessed_validation_requirement <= txn_idx` [10](#0-9)  will evaluate to false, allowing the transaction to commit without module read validation.

Module read validation cannot be performed later because it is explicitly skipped in post-commit validation [11](#0-10) , making cold validation the only mechanism to validate module reads after publishing.

## Impact Explanation

**Severity: Critical** - Consensus/Safety Violations

This vulnerability breaks the fundamental deterministic execution invariant of the Aptos blockchain: all validators must produce identical state roots for identical blocks. The race condition causes non-deterministic validation behavior across validators.

**Consensus Safety Violation:**
Different validators executing the same block can experience different interleavings of this race condition. Some validators may include a transaction in module validation requirements (if they read `min_never_scheduled_idx` before the concurrent pop), while others exclude it (if they read after the pop). This leads to:

1. **State Root Divergence**: Validators that validate the transaction may abort it if module reads are invalid, while others commit it, producing different state roots
2. **Chain Split**: Validators cannot reach consensus on the block's state commitment, causing a permanent fork
3. **Non-Recoverable Failure**: The blockchain cannot automatically recover without manual coordinator intervention or a hard fork

This meets the "Consensus/Safety violations" criterion for Critical severity in the Aptos bug bounty program, which covers scenarios where different validators commit different blocks or produce different state roots for the same block.

## Likelihood Explanation

**Likelihood: High** in production environments.

The race condition occurs naturally during normal network operation without requiring:
- Malicious actors or coordinated attacks
- Privileged access or compromised validators  
- Special network conditions or timing manipulation
- Economic incentives or attack profitability analysis

**Triggering Conditions (all common):**
1. A transaction publishes Move modules (occurs during smart contract deployments and upgrades)
2. Multiple worker threads are processing transactions (always true with parallel execution)
3. The execution queue has pending transactions when publishing occurs (very common under normal load)

With 32+ worker threads operating concurrently and microsecond-level race windows, the probability of this race occurring increases significantly under high transaction throughput. The non-deterministic nature makes it particularly dangerous as validators cannot easily detect or coordinate recovery from the resulting consensus divergence.

## Recommendation

**Fix: Atomic Snapshot of min_never_scheduled_idx**

The `record_validation_requirements` method should read `min_never_scheduled_idx` atomically and ensure no transactions can be popped from the execution queue between the read and the recording of requirements. 

**Option 1: Extend the queueing_commits_lock scope** to prevent `next_task()` calls during module publishing validation requirement recording.

**Option 2: Use a dedicated lock** for the execution queue that protects both `pop_next()` and the reading of `min_never_scheduled_idx` in `record_validation_requirements`.

**Option 3: Record requirements based on a snapshot** taken under the appropriate lock before allowing any worker threads to proceed.

The fix should ensure that the value of `min_never_scheduled_idx` used in `record_requirements` accurately reflects which transactions have been scheduled at the point of recording, with no concurrent modifications possible.

## Proof of Concept

A full proof of concept would require:
1. Concurrent execution with multiple worker threads
2. A transaction that publishes Move modules
3. Precise timing to trigger the race between reading `min_never_scheduled_idx` and recording requirements
4. Verification that the affected transaction commits without module read validation
5. Demonstration that different validators produce different outcomes

Due to the timing-dependent nature of the race and the complexity of the BlockSTMv2 execution environment, a complete PoC requires integration with the Aptos test framework and careful thread orchestration. However, the code analysis clearly demonstrates the race window exists in the current implementation and is not protected by any synchronization mechanism.

## Notes

This vulnerability is specific to BlockSTMv2's cold validation system for module publishing. The race occurs because:
1. Module publishing happens sequentially during commit under `queueing_commits_lock`
2. Transaction scheduling via `next_task()` happens concurrently without this lock
3. The `min_never_scheduled_idx` value is not protected by any lock that spans both operations
4. Cold validation is the only mechanism to validate module reads after publishing

The deterministic execution guarantee is broken because the race creates non-determinism in which transactions receive validation requirements, leading to different validation outcomes across validators executing identical blocks.

### Citations

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L391-397)
```rust
    fn pop_next(&self) -> Option<TxnIndex> {
        let ret = self.execution_queue.lock().pop_first();
        if let Some(idx) = ret {
            self.min_never_scheduled_idx
                .fetch_max(idx + 1, Ordering::Relaxed);
        }
        ret
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L818-818)
```rust
        if let Some(txn_idx) = self.txn_statuses.get_execution_queue_manager().pop_next() {
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1037-1037)
```rust
        let min_never_scheduled_idx = self.min_never_scheduled_idx()?;
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1038-1043)
```rust
        if txn_idx >= min_never_scheduled_idx {
            return Err(code_invariant_error(format!(
                "Calling txn idx {} must be less than min_never_scheduled_idx {}",
                txn_idx, min_never_scheduled_idx
            )));
        }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1044-1049)
```rust
        self.cold_validation_requirements.record_requirements(
            worker_id,
            txn_idx,
            min_never_scheduled_idx,
            module_ids,
        )
```

**File:** aptos-move/block-executor/src/executor.rs (L1147-1153)
```rust
            // Module cache is not versioned (published at commit), so validation after
            // commit might observe later publishes (higher txn index) and be incorrect.
            // Hence, we skip the paranoid module validation after commit.
            // TODO(BlockSTMv2): Do the additional checking in sequential commit hook,
            // when modules have been published. Update the comment here as skipping
            // in V2 is needed for a different, code cache implementation related reason.
            true,
```

**File:** aptos-move/block-executor/src/executor.rs (L1455-1472)
```rust
            while scheduler.commit_hooks_try_lock() {
                // Perform sequential commit hooks.
                while let Some((txn_idx, incarnation)) = scheduler.start_commit()? {
                    self.prepare_and_queue_commit_ready_txn(
                        txn_idx,
                        incarnation,
                        num_txns,
                        executor,
                        block,
                        num_workers as usize,
                        runtime_environment,
                        scheduler_wrapper,
                        shared_sync_params,
                    )?;
                }

                scheduler.commit_hooks_unlock();
            }
```

**File:** aptos-move/block-executor/src/executor.rs (L1474-1474)
```rust
            match scheduler.next_task(worker_id)? {
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L235-239)
```rust
        pending_reqs.push(PendingRequirement {
            requirements,
            from_idx: calling_txn_idx + 1,
            to_idx: min_never_scheduled_idx,
        });
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L391-397)
```rust
            if active_reqs_is_empty {
                active_reqs.requirements.clear();
                self.min_idx_with_unprocessed_validation_requirement
                    .store(u32::MAX, Ordering::Relaxed);
                // Since we are holding the lock and pending requirements is empty, it
                // is safe to reset the dedicated worker id.
                self.dedicated_worker_id.store(u32::MAX, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L421-431)
```rust
    pub(crate) fn is_commit_blocked(&self, txn_idx: TxnIndex, incarnation: Incarnation) -> bool {
        // The order of checks is important to avoid a concurrency bugs (since recording
        // happens in the opposite order). We first check that there are no unscheduled
        // requirements below (incl.) the given index, and then that there are no scheduled
        // but yet unfulfilled (validated) requirements for the index.
        self.min_idx_with_unprocessed_validation_requirement
            .load(Ordering::Relaxed)
            <= txn_idx
            || self.deferred_requirements_status[txn_idx as usize].load(Ordering::Relaxed)
                == blocked_incarnation_status(incarnation)
    }
```
