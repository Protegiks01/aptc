# Audit Report

## Title
Memory Undercharging for Variant Names Due to Identifier Duplication in Module Loader

## Summary
Very long variant names in Move enum types consume approximately 2x the memory relative to the complexity charge due to identifier duplication between the module's `IdentifierPool` and the runtime `StructType` layout. This violates the Resource Limits invariant that "all operations must respect gas, storage, and computational limits."

## Finding Description

When a Move module with enum types (structs with `DeclaredVariants`) is loaded into the VM, the complexity checker charges based on variant name length: [1](#0-0) 

The charge is calculated as `ident.len() * COST_PER_IDENT_BYTE` where `COST_PER_IDENT_BYTE = 1`: [2](#0-1) 

However, during module loading, variant names are **duplicated** in memory. First, they exist in the module's `IdentifierPool` as `Identifier` objects (which are `Box<str>`): [3](#0-2) 

Second, when creating the runtime `StructType`, the identifiers are **cloned** via `.to_owned()`: [4](#0-3) 

This results in each variant name being stored twice:
1. Once in `CompiledModule.identifiers` pool
2. Once in `StructType.layout` (StructLayout::Variants)

**Memory Calculation:**
- Each `Identifier` consumes: 16 bytes (Box<str> fat pointer) + `ident.len()` bytes (heap string)
- Total memory per variant name: `2 * (16 + ident.len()) = 32 + 2 * ident.len()` bytes
- Complexity charge: `ident.len()` units
- **Ratio: ~2x for long identifiers**

**Maximum Exploitation:**
- Maximum variants: 127 (`VARIANT_COUNT_MAX`) [5](#0-4) 

- Maximum identifier size: 255 bytes (or 65535 with legacy limit) [6](#0-5) 

- With 255-byte limit: 127 variants Ã— 542 bytes = 68,834 bytes actual memory vs 32,385 charged = **36 KB uncharged overhead**
- With 65535-byte legacy limit: **~8.3 MB uncharged overhead**

## Impact Explanation

This finding constitutes a **Low Severity** issue per the Aptos bug bounty criteria. While it represents a resource accounting discrepancy, the absolute impact is limited:

1. **Not Critical/High:** No loss of funds, consensus violations, or network partitions
2. **Low Severity:** Minor implementation bug with modest resource consumption overhead (max 8.3MB per module)
3. The overhead is bounded by `VARIANT_COUNT_MAX` and identifier size limits
4. Memory consumption is one-time per module load, not per-transaction
5. The complexity budget formula (`2048 + blob.code().len() * 20`) provides substantial headroom [7](#0-6) 

## Likelihood Explanation

**Likelihood: High** - Any module publisher can exploit this by creating enums with many long variant names. However, the practical impact is limited because:

1. The duplication appears intentional for performance (avoiding repeated identifier pool lookups)
2. The absolute memory overhead is modest relative to typical module sizes
3. The complexity budget already provides overhead margins
4. Field names and other identifiers exhibit the same pattern, suggesting this is an accepted design tradeoff

## Recommendation

**Option 1: Accept as Design Tradeoff** (Recommended)
The current implementation prioritizes runtime performance over exact memory accounting. The 2x overhead is bounded and relatively small. Consider documenting this behavior and ensuring complexity budgets account for it.

**Option 2: Adjust Complexity Charging**
Modify `meter_identifier` to charge `2 * ident.len()` to reflect actual memory consumption:

```rust
fn meter_identifier(&self, idx: IdentifierIndex) -> PartialVMResult<()> {
    let ident = safe_get_table(self.resolver.identifiers(), idx.0)?;
    // Account for duplication in StructType layout
    self.charge(ident.len() as u64 * COST_PER_IDENT_BYTE * 2)
}
```

**Option 3: Use Arc<Identifier> in StructType**
Modify `StructLayout` to use `Arc<Identifier>` instead of owned `Identifier` to avoid duplication, though this adds reference counting overhead.

## Proof of Concept

```move
module 0x1::MaxVariantNames {
    // Create enum with max variants (127) each with max name length (255 bytes)
    public enum ExploitEnum has drop {
        // Each variant name is exactly 255 bytes
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1,
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2,
        // ... repeat for 127 variants total
        
        // Memory consumed: 127 * (32 + 2*255) = 68,834 bytes
        // Complexity charged: 127 * 255 = 32,385 units
        // Uncharged overhead: 36,449 bytes (~53% undercharge)
    }
}
```

**Notes:**
- With legacy 65535-byte identifier limit, overhead increases to ~8.3MB
- The duplication also affects field names and other identifiers throughout the module
- This is a systemic design pattern, not variant-specific
- The complexity budget provides sufficient margin for typical modules, making this a minor concern in practice

### Citations

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L79-82)
```rust
    fn meter_identifier(&self, idx: IdentifierIndex) -> PartialVMResult<()> {
        let ident = safe_get_table(self.resolver.identifiers(), idx.0)?;
        self.charge(ident.len() as u64 * COST_PER_IDENT_BYTE)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L246-253)
```rust
                StructFieldInformation::DeclaredVariants(variants) => {
                    for variant in variants {
                        self.meter_identifier(variant.name)?;
                        for field in &variant.fields {
                            self.charge(field.signature.0.num_nodes() as u64)?;
                        }
                    }
                },
```

**File:** third_party/move/move-core/types/src/identifier.rs (L114-114)
```rust
pub struct Identifier(Box<str>);
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L461-475)
```rust
            StructFieldInformation::DeclaredVariants(variants) => {
                let variants: PartialVMResult<Vec<(Identifier, Vec<(Identifier, Type)>)>> =
                    variants
                        .iter()
                        .map(|v| {
                            let fields: PartialVMResult<Vec<(Identifier, Type)>> = v
                                .fields
                                .iter()
                                .map(|f| Self::make_field(module, f, struct_name_table))
                                .collect();
                            fields.map(|fields| (module.identifier_at(v.name).to_owned(), fields))
                        })
                        .collect();
                StructLayout::Variants(variants?)
            },
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L66-67)
```rust
pub const LEGACY_IDENTIFIER_SIZE_MAX: u64 = 65535;
pub const IDENTIFIER_SIZE_MAX: u64 = 255;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L80-80)
```rust
pub const VARIANT_COUNT_MAX: u64 = value::VARIANT_COUNT_MAX;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1556-1558)
```rust
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
```
