# Audit Report

## Title
Access Control Bypass: Identity Information Leakage via Configuration Endpoint

## Summary
The `expose_identity_information` flag can be bypassed to extract node peer IDs through the `/configuration` endpoint when `expose_configuration` is enabled. This allows attackers to obtain identity information that operators intended to protect, enabling targeted network reconnaissance and attacks.

## Finding Description

The inspection service provides two separate endpoints for exposing node information:
1. `/identity_information` - Protected by the `expose_identity_information` flag
2. `/configuration` - Protected by the `expose_configuration` flag

When an operator sets `expose_identity_information: false` to hide node peer IDs but keeps `expose_configuration: true` for debugging, the identity information protection is bypassed. [1](#0-0) 

The identity information handler correctly checks the flag and returns FORBIDDEN when disabled. [2](#0-1) 

However, the configuration handler uses Debug formatting to serialize the entire `NodeConfig`, which includes the `validator_network` and `full_node_networks` fields containing `NetworkConfig` structures. [3](#0-2) 

The `NetworkConfig` struct derives Debug and contains an `identity` field. [4](#0-3) 

The `IdentityFromConfig` struct contains a public `peer_id: PeerId` field that is included in Debug output. [5](#0-4) 

`PeerId` (which is `AccountAddress`) implements Debug to output the full hex address, causing peer IDs to leak through the configuration endpoint's debug formatting.

**Attack Path:**
1. Operator configures: `expose_identity_information: false`, `expose_configuration: true`
2. Attacker sends HTTP GET request to `http://NODE_IP:9101/configuration`
3. Response contains debug-formatted NodeConfig including `validator_network: Some(NetworkConfig { ... identity: FromConfig(IdentityFromConfig { peer_id: 0x1234... }) ... })`
4. Attacker extracts peer_id from the debug output
5. Access control bypass complete - attacker has node identity despite the protection flag

## Impact Explanation

This is a **Medium Severity** information disclosure vulnerability per the Aptos bug bounty criteria. While it doesn't directly cause loss of funds or consensus violations, it breaks the access control guarantees operators expect from the `expose_identity_information` flag.

The leaked peer IDs enable:
- Network reconnaissance to map validator and fullnode topology
- Targeted network-layer attacks against specific peer IDs
- Social engineering attacks using node identity information
- Bypassing operator security policies intended to hide node identities

The default configuration sets `expose_configuration: false` and `expose_identity_information: true`, but operators who enable configuration for debugging while disabling identity information for security are vulnerable. [6](#0-5) 

## Likelihood Explanation

**Likelihood: High**

This is a realistic misconfiguration scenario. Operators commonly:
1. Enable configuration endpoint for debugging and monitoring
2. Disable identity information endpoint believing it provides adequate protection
3. Assume the two flags provide independent access control

The inspection service binds to `0.0.0.0` by default (all network interfaces), making it accessible if firewall rules are misconfigured. [7](#0-6) 

The code comment in the configuration handler even warns about secret key leakage via SilentDebug/SilentDisplay, but doesn't address peer ID exposure. [8](#0-7) 

## Recommendation

Implement one of the following fixes:

**Option 1: Filter sensitive fields from configuration output**
Modify the configuration handler to explicitly redact identity information when `expose_identity_information` is false:

```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        let mut sanitized_config = node_config.clone();
        
        // Redact identity information if not exposed
        if !node_config.inspection_service.expose_identity_information {
            if let Some(validator_network) = &mut sanitized_config.validator_network {
                validator_network.identity = Identity::None;
            }
            for fullnode_network in &mut sanitized_config.full_node_networks {
                fullnode_network.identity = Identity::None;
            }
        }
        
        let encoded_configuration = format!("{:?}", sanitized_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (StatusCode::FORBIDDEN, Body::from(CONFIGURATION_DISABLED_MESSAGE))
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**Option 2: Implement SilentDebug for peer_id**
Make `IdentityFromConfig` use custom Debug formatting that elides peer_id unless explicitly needed.

**Option 3: Documentation and warnings**
Add clear warnings in documentation and configuration comments that `/configuration` exposes peer IDs and operators must secure both endpoints.

## Proof of Concept

```rust
#[cfg(test)]
mod test_access_control_bypass {
    use aptos_config::config::NodeConfig;
    use crate::server::{serve_requests, CONFIGURATION_PATH, IDENTITY_INFORMATION_PATH};
    use hyper::{Body, Method, Request, StatusCode};
    
    #[tokio::test]
    async fn test_identity_bypass_via_configuration() {
        // Create a validator config with identity
        let mut config = NodeConfig::get_default_validator_config();
        
        // Configure as if operator wants to hide identity but expose config
        config.inspection_service.expose_identity_information = false;
        config.inspection_service.expose_configuration = true;
        
        // Setup network identity
        if let Some(network) = config.validator_network.as_mut() {
            network.identity = Identity::None;
            network.set_listen_address_and_prepare_identity().unwrap();
        }
        
        let expected_peer_id = config.validator_network.as_ref().unwrap().peer_id();
        
        // Query identity endpoint - should be FORBIDDEN
        let identity_response = send_request(&config, IDENTITY_INFORMATION_PATH).await;
        assert_eq!(identity_response.status(), StatusCode::FORBIDDEN);
        
        // Query configuration endpoint - should expose peer_id
        let mut config_response = send_request(&config, CONFIGURATION_PATH).await;
        assert_eq!(config_response.status(), StatusCode::OK);
        
        let body_bytes = hyper::body::to_bytes(config_response.body_mut()).await.unwrap();
        let body_string = String::from_utf8(body_bytes.to_vec()).unwrap();
        
        // Verify peer_id is leaked in configuration output
        let peer_id_hex = format!("{:x}", expected_peer_id);
        assert!(
            body_string.contains(&peer_id_hex),
            "Expected peer_id {} to be present in configuration output despite expose_identity_information being false",
            peer_id_hex
        );
    }
    
    async fn send_request(config: &NodeConfig, path: &str) -> hyper::Response<Body> {
        let uri = format!("http://127.0.0.1:9101{}", path);
        let peers_and_metadata = PeersAndMetadata::new(&[]);
        let data_client = create_test_data_client();
        
        serve_requests(
            Request::builder()
                .uri(uri)
                .method(Method::GET)
                .body(Body::empty())
                .unwrap(),
            config.clone(),
            data_client,
            peers_and_metadata,
        )
        .await
        .unwrap()
    }
}
```

## Notes

While the inspection service sanitizer prevents mainnet validators from exposing configuration, this doesn't protect non-mainnet nodes or fullnodes from this bypass. The vulnerability demonstrates an access control design flaw where separate flags don't provide true isolation of sensitive data. [9](#0-8) 

Operators should implement defense-in-depth by using network-level access controls (firewalls, VPNs) in addition to application-level flags, but the application should honor the stated security guarantees of its configuration flags.

### Citations

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/network_config.rs (L55-73)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
```

**File:** config/src/config/identity_config.rs (L129-139)
```rust
/// The identity is stored within the config.
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** third_party/move/move-core/types/src/account_address.rs (L273-277)
```rust
impl fmt::Debug for AccountAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:x}", self)
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L54-64)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L55-70)
```rust
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();

```
