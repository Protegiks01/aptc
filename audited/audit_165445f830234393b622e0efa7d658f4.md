# Audit Report

## Title
Block Epilogue Failure Silently Skips Fee Distribution While Keeping Blocks

## Summary
The `process_block_epilogue()` function in `aptos_vm.rs` catches epilogue execution failures and returns success status with an empty output instead of propagating the error. This allows blocks to be committed without distributing transaction fees to validators, breaking the economic invariant that successful blocks must properly compensate validators. [1](#0-0) 

## Finding Description
The vulnerability exists in the block epilogue error handling logic. When the block epilogue executes, it calls the Move function `block::block_epilogue()` which in turn calls `stake::record_fee()` to distribute transaction fees to validators based on their indices. [2](#0-1) 

The `record_fee` function records fees by looking up each validator's index in the `PendingTransactionFee` map and adding fees to their aggregator: [3](#0-2) 

This operation will abort if a validator_index doesn't exist in the map. The `borrow_mut` function on `BigOrderedMap` aborts with `EKEY_NOT_FOUND` when the key is not present: [4](#0-3) 

The critical issue is in the error handling. When epilogue execution fails, the code catches the error and returns success status with an empty VMOutput: [5](#0-4) 

This means:
1. The block is kept and marked as successful (TransactionStatus::Keep(ExecutionStatus::Success))
2. All user transactions in the block are committed
3. BUT the fee recording never happens (empty output = no state changes from epilogue)
4. Validators don't receive fees for this block's transactions

**Trigger Scenarios:**

1. **Invalid Validator Index**: If the fee distribution contains a validator_index not in the active validator set (due to bugs in consensus, fee calculation, or epoch transition race conditions), `borrow_mut` will abort.

2. **Aggregator Overflow**: If a validator's fee aggregator overflows u64 during the epoch, the `add(fee_octa)` call will abort.

3. **Uninitialized State**: If `PendingTransactionFee` resource doesn't exist, `borrow_global_mut` will abort.

The fee distribution is constructed from block metadata and proposer indices: [6](#0-5) 

## Impact Explanation
**Medium Severity** - This qualifies as "Limited funds loss or manipulation" and "State inconsistencies requiring intervention":

1. **Economic Loss**: Validators lose transaction fee rewards for affected blocks, violating the staking security invariant.

2. **Economic Model Breakdown**: If this occurs systematically, validators are not compensated fairly for their work, potentially leading to validator churn or network instability.

3. **State Inconsistency**: The blockchain state shows successful blocks, but the economic distribution is incorrect. The `PendingTransactionFee` map won't reflect fees that should have been recorded.

4. **Silent Failure**: The error is only logged but not surfaced to consensus or monitoring systems, making detection difficult.

The impact is limited to fee distribution and doesn't affect consensus safety or cause total fund loss, placing it in the Medium severity category per Aptos bug bounty guidelines.

## Likelihood Explanation
**Medium Likelihood** - While specific trigger conditions require implementation bugs or race conditions, the error handling guarantees that any epilogue failure will be silently accepted:

1. **Defensive but Flawed**: The code appears intentionally designed to never fail blocks due to epilogue errors (possibly for consensus stability), but this creates economic vulnerabilities.

2. **Multiple Failure Paths**: Any abort in the epilogue execution chain (invalid indices, overflow, resource errors) triggers the vulnerability.

3. **Epoch Transitions**: The validator index map is rebuilt during epoch transitions, creating potential windows for index mismatches: [7](#0-6) 

4. **No Validation**: Fee distribution indices are not validated before being passed to the epilogue, allowing invalid data to propagate.

## Recommendation
The block epilogue failure should not be silently accepted. Consider these fixes:

**Option 1 - Propagate Error (Preferred)**:
```rust
let output = match session
    .execute_function_bypass_visibility(...)
    .map(|_return_vals| ())
    .or_else(|e| expect_only_successful_execution(e, BLOCK_EPILOGUE.as_str(), log_context))
{
    Ok(_) => get_system_transaction_output(...)?,
    Err(e) => {
        // Critical: block epilogue must succeed for fee distribution
        alert!(*log_context, "CRITICAL: BlockEpilogue execution failed: {e:?}");
        return Err(e);
    },
};
```

**Option 2 - Validate Before Execution**:
Add validation in `process_block_epilogue` to ensure all validator indices in the fee distribution exist in the active set before calling the epilogue.

**Option 3 - Retry with Empty Distribution**:
If epilogue fails, retry with an empty fee distribution to at least commit the block state, but emit a critical alert for manual intervention.

Additionally, add validation in `gen_block_epilogue` to ensure proposer indices are valid before including them in fee distribution.

## Proof of Concept
The following demonstrates the vulnerability by showing that an epilogue failure is silently accepted:

```rust
// Minimal PoC showing the error path
use aptos_types::transaction::{BlockEpiloguePayload, FeeDistribution};
use std::collections::BTreeMap;

#[test]
fn test_block_epilogue_failure_silently_accepted() {
    // Setup: Create a block epilogue with invalid validator index
    let mut invalid_fees = BTreeMap::new();
    invalid_fees.insert(9999, 1000); // Validator index 9999 doesn't exist
    
    let epilogue = BlockEpiloguePayload::V1 {
        block_id: HashValue::random(),
        block_end_info: BlockEndInfoExt::new_empty(),
        fee_distribution: FeeDistribution::new(invalid_fees),
    };
    
    // Execute: Process the epilogue
    // Expected: Should fail with validator not found
    // Actual: Returns success with empty output (fees not distributed)
    let (status, output) = vm.process_block_epilogue(
        &resolver,
        &module_storage,
        epilogue,
        &log_context
    ).unwrap();
    
    // Vulnerability: Block is kept as successful despite fee distribution failure
    assert_eq!(status, VMStatus::Executed);
    assert!(matches!(
        output.status(),
        TransactionStatus::Keep(ExecutionStatus::Success)
    ));
    
    // Impact: Output is empty, so no fees were recorded
    assert!(output.change_set().is_empty());
}
```

**Notes**

This vulnerability violates the **Staking Security** invariant: "Validator rewards and penalties must be calculated correctly." The error handling prioritizes block acceptance over economic correctness, creating a path for fee distribution to be silently skipped. While the specific triggers require implementation bugs or edge cases, the error handling guarantees that any epilogue failure results in validators losing their rightful fees without any indication of the problem beyond a log entry.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2593-2618)
```rust
        let output = match session
            .execute_function_bypass_visibility(
                &BLOCK_MODULE,
                BLOCK_EPILOGUE,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut traversal_context,
                module_storage,
            )
            .map(|_return_vals| ())
            .or_else(|e| expect_only_successful_execution(e, BLOCK_EPILOGUE.as_str(), log_context))
        {
            Ok(_) => get_system_transaction_output(
                session,
                module_storage,
                &self.storage_gas_params(log_context)?.change_set_configs,
            )?,
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
        };
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L249-255)
```text
    fun block_epilogue(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) {
        stake::record_fee(vm, fee_distribution_validator_indices, fee_amounts_octa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L616-635)
```text
    public(friend) fun record_fee(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) acquires PendingTransactionFee {
        // Operational constraint: can only be invoked by the VM.
        system_addresses::assert_vm(vm);

        assert!(fee_distribution_validator_indices.length() == fee_amounts_octa.length());

        let num_validators_to_distribute = fee_distribution_validator_indices.length();
        let pending_fee = borrow_global_mut<PendingTransactionFee>(@aptos_framework);
        let i = 0;
        while (i < num_validators_to_distribute) {
            let validator_index = fee_distribution_validator_indices[i];
            let fee_octa = fee_amounts_octa[i];
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
            i = i + 1;
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1454-1458)
```text
        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            assert!(pending_fee_by_validator.is_empty(), error::internal(ETRANSACTION_FEE_NOT_FULLY_DISTRIBUTED));
            validator_set.active_validators.for_each_ref(|v| pending_fee_by_validator.add(v.config.validator_index, aggregator_v2::create_unbounded_aggregator<u64>()));
        };
```

**File:** aptos-move/framework/aptos-framework/sources/datastructures/big_ordered_map.move (L597-601)
```text
    public fun borrow_mut<K: drop + copy + store, V: store>(self: &mut BigOrderedMap<K, V>, key: &K): &mut V {
        let iter = self.internal_find(key);
        assert!(!iter.iter_is_end(self), error::invalid_argument(EKEY_NOT_FOUND));
        iter.iter_borrow_mut(self)
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2030-2083)
```rust
        let mut amount = BTreeMap::new();

        // TODO(HotState): there are three possible paths where the block epilogue
        // output is passed to the DB:
        //   1. a block from consensus is executed: the VM outputs the block end info
        //      and the block epilogue transaction and output are generated here.
        //   2. a chunk re-executed: The VM will see the block epilogue transaction and
        //      should output the transaction output by looking at the block end info
        //      embedded in the epilogue transaction (and maybe the state view).
        //   3. a chunk replayed by transaction output: we get the transaction output
        //      directly.

        for (i, output) in outputs.enumerate().take(epilogue_txn_idx as usize) {
            // TODO(grao): Also include other transactions that is "Keep" if we are confident
            // that we successfully charge enough gas amount as it appears in the FeeStatement
            // for every corner cases.
            if !output.is_materialized_and_success() {
                continue;
            }
            let output_after_guard = output.after_materialization()?;
            let fee_statement = output_after_guard.fee_statement();

            let txn = signature_verified_block.get_txn(i as TxnIndex);
            if let Some(user_txn) = txn.try_as_signed_user_txn() {
                let auxiliary_info = signature_verified_block.get_auxiliary_info(i as TxnIndex);
                if let Some(proposer_index) = auxiliary_info.proposer_index() {
                    let gas_price = user_txn.gas_unit_price();
                    let total_gas_unit = fee_statement.gas_used();
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
                        }
                    }
                }
            }
        }
        Ok(T::block_epilogue_v1(
            block_id,
            block_end_info,
            FeeDistribution::new(amount),
        ))
```
