# Audit Report

## Title
Unchecked Cache Key Absence Causes Indexer File Store Processor Crash

## Summary
The file store processor's main loop uses `unwrap()` on an `Option<u64>` returned from Redis cache without handling the `None` case. If Redis is restarted, experiences a failover, or the `latest_version` key is deleted during operation, the processor panics and terminates, halting all blockchain indexing operations. [1](#0-0) 

## Finding Description

The vulnerability exists in the `Processor::run()` method's main processing loop. The method calls `get_latest_version()` which returns `Result<Option<u64>>`, then immediately unwraps the Option without checking for `None`: [2](#0-1) 

The `get_latest_version()` method internally calls `get_config_by_key()` which returns `Ok(None)` when the Redis GET command returns an empty result (i.e., when the key doesn't exist): [3](#0-2) [4](#0-3) 

While `Processor::new()` initializes the cache key during startup via `cache_setup_if_needed()`, this initialization only occurs once. If Redis undergoes any of the following events during the processor's runtime, the key will be missing: [5](#0-4) [6](#0-5) 

**Attack/Failure Scenarios:**

1. **Redis Restart**: Administrator restarts Redis for maintenance → all keys cleared → next loop iteration panics
2. **Redis Failover**: High-availability setup promotes empty replica to primary → keys missing → panic
3. **Manual Key Deletion**: Operator accidentally runs `DEL latest_version` → panic
4. **Redis FLUSHDB**: Database cleared during operation → all keys gone → panic

The panic propagates through the service entry point which uses `.expect()`, causing the entire indexing service to terminate: [7](#0-6) 

This breaks the **Resource Limits** and **Service Availability** invariants - the indexing infrastructure must remain operational to support blockchain data access.

## Impact Explanation

**Severity: HIGH** per Aptos Bug Bounty program ("API crashes").

This vulnerability causes:
- **Complete indexing service termination** - all blockchain transaction indexing halts
- **Ecosystem-wide impact** - dApps, explorers, and tooling relying on indexed data lose access
- **No automatic recovery** - requires manual service restart
- **Data availability loss** - historical transaction queries fail until service is restored

While this doesn't affect consensus or validator operations directly, the indexer is critical infrastructure that the entire Aptos ecosystem depends on for historical data access. A crash of this service has significant operational impact.

## Likelihood Explanation

**Likelihood: HIGH**

This is highly likely to occur because:
- **Common operational events trigger it**: Redis restarts for maintenance, upgrades, or configuration changes are routine operations in production environments
- **No attacker action required**: Natural operational events cause the crash
- **Automatic occurrence**: Once Redis loses the key, the crash happens on the very next loop iteration
- **No mitigation in place**: No retry logic, error handling, or graceful degradation exists

Redis ConnectionManager handles reconnection automatically, but doesn't restore lost keys, making this a guaranteed crash after any Redis data loss event.

## Recommendation

Replace the `unwrap()` with proper error handling that re-initializes the cache key or gracefully handles the missing key:

**Option 1 - Re-initialize on missing key:**
```rust
let cache_worker_latest = match self.cache_operator.get_latest_version().await? {
    Some(version) => version,
    None => {
        tracing::warn!("Cache latest_version key missing, reinitializing cache");
        self.cache_operator.cache_setup_if_needed().await?;
        self.cache_operator
            .update_file_store_latest_version(batch_start_version)
            .await?;
        // Retry after initialization
        self.cache_operator.get_latest_version().await?
            .ok_or_else(|| anyhow::anyhow!("Failed to initialize cache after retry"))?
    }
};
```

**Option 2 - Graceful degradation with retry:**
```rust
let cache_worker_latest = loop {
    match self.cache_operator.get_latest_version().await? {
        Some(version) => break version,
        None => {
            tracing::error!("Cache latest_version key missing, waiting for cache worker");
            tokio::time::sleep(Duration::from_millis(AHEAD_OF_CACHE_SLEEP_DURATION_IN_MILLIS)).await;
        }
    }
};
```

Both approaches prevent the panic and allow the processor to continue operating or recover gracefully.

## Proof of Concept

**Reproduction Steps:**

1. Start the indexer-grpc-file-store processor with Redis connection
2. Verify processor is running and indexing transactions
3. Connect to Redis and execute: `DEL latest_version`
4. Observe processor crash on next loop iteration with panic:
   ```
   thread 'main' panicked at 'called `Option::unwrap()` on a `None` value'
   ```

**Rust Test Demonstration:**

```rust
#[tokio::test]
async fn test_missing_cache_key_causes_panic() {
    use redis_test::{MockCmd, MockRedisConnection};
    
    // Simulate Redis returning empty result (key doesn't exist)
    let cmds = vec![
        MockCmd::new(
            redis::cmd("GET").arg("latest_version"),
            Ok(Vec::<u8>::new()), // Empty result = key doesn't exist
        )
    ];
    let mock_connection = MockRedisConnection::new(cmds);
    let mut cache_operator = CacheOperator::new(
        mock_connection, 
        StorageFormat::Base64UncompressedProto
    );
    
    // This returns Ok(None)
    let result = cache_operator.get_latest_version().await.unwrap();
    assert_eq!(result, None);
    
    // In processor.rs line 128, this would panic:
    // let version = result.unwrap(); // PANIC!
}
```

**Notes**

This vulnerability is specific to the indexer-grpc infrastructure component, not the core consensus or execution layer. However, it represents a significant availability issue for the Aptos ecosystem since the indexer provides critical data access services for dApps, explorers, and tooling. The crash is deterministic and occurs immediately upon the next loop iteration after Redis loses the key, with no automatic recovery mechanism in place.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L86-87)
```rust
        // Cache config in the cache
        cache_operator.cache_setup_if_needed().await?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L126-128)
```rust
        loop {
            let latest_loop_time = std::time::Instant::now();
            let cache_worker_latest = self.cache_operator.get_latest_version().await?.unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L114-129)
```rust
    // Set up the cache if needed.
    pub async fn cache_setup_if_needed(&mut self) -> anyhow::Result<bool> {
        let version_inserted: bool = redis::cmd("SET")
            .arg(CACHE_KEY_LATEST_VERSION)
            .arg(CACHE_DEFAULT_LATEST_VERSION_NUMBER)
            .arg("NX")
            .query_async(&mut self.conn)
            .await
            .context("Redis latest_version check failed.")?;
        if version_inserted {
            tracing::info!(
                initialized_latest_version = CACHE_DEFAULT_LATEST_VERSION_NUMBER,
                "Cache latest version is initialized."
            );
        }
        Ok(version_inserted)
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L145-147)
```rust
    pub async fn get_latest_version(&mut self) -> anyhow::Result<Option<u64>> {
        self.get_config_by_key(CACHE_KEY_LATEST_VERSION).await
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L169-179)
```rust
    async fn get_config_by_key(&mut self, key: &str) -> anyhow::Result<Option<u64>> {
        let result = self.conn.get::<&str, Vec<u8>>(key).await?;
        if result.is_empty() {
            Ok(None)
        } else {
            let result_string = String::from_utf8(result).unwrap();
            Ok(Some(result_string.parse::<u64>().with_context(|| {
                format!("Redis key {} is not a number.", key)
            })?))
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/lib.rs (L48-61)
```rust
    async fn run(&self) -> Result<()> {
        let mut processor = Processor::new(
            self.redis_main_instance_address.clone(),
            self.file_store_config.clone(),
            self.chain_id,
            self.enable_cache_compression,
        )
        .await
        .expect("Failed to create file store processor");
        processor
            .run()
            .await
            .expect("File store processor exited unexpectedly");
        Ok(())
```
