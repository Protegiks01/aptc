# Audit Report

## Title
HealthChecker Liveness Detection Bypass via Inbound Ping Manipulation

## Summary
The HealthChecker protocol unconditionally resets peer failure counters when receiving incoming ping requests, allowing unresponsive or slow nodes to avoid disconnection by periodically sending pings while failing to respond to health checks from other peers. This breaks the liveness detection guarantee and can degrade consensus performance.

## Finding Description

The HealthChecker protocol is responsible for ensuring peer liveness by periodically sending ping requests and disconnecting from peers that fail to respond. However, the implementation contains a critical flaw in how it handles incoming ping requests. [1](#0-0) 

When a node receives an incoming `Ping` request from a peer, the `handle_ping_request` method responds with a `Pong` and unconditionally resets that peer's failure counter to zero via `reset_peer_failures(peer_id)`. [2](#0-1) 

This creates an exploitable asymmetry: a node can fail to respond to health check pings from its peers (accumulating failures) while simultaneously sending its own ping requests to those same peers. Each incoming ping resets the failure counter, preventing disconnection.

**Attack Scenario:**

1. Node A monitors Node B's health by sending periodic pings (every 10 seconds by default)
2. Node B is slow/unresponsive and fails to respond to A's pings within the 20-second timeout
3. Node A increments the failure counter for Node B
4. Before reaching `ping_failures_tolerated` (default: 3 failures), Node B sends a single ping request to Node A
5. Node A receives the ping, responds with a pong, and **resets Node B's failure counter to 0**
6. Node B can repeat this indefinitely, avoiding disconnection despite being unresponsive to health checks

**Configuration Context:** [3](#0-2) 

With default values, a malicious node only needs to send one ping every `(ping_failures_tolerated + 1) * ping_interval_ms = 4 * 10 seconds = 40 seconds` to maintain the appearance of liveness while being completely unresponsive to actual health checks.

The vulnerability violates the health checker's core invariant: **unresponsive nodes should be detected and disconnected**. The flawed assumption is that a node capable of sending pings must be healthy, but this ignores the possibility of asymmetric network conditions, resource constraints, or malicious behavior where a node can send requests but not process responses in a timely manner.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: A slow validator can exploit this to remain connected to the network despite being unresponsive. Other validators waiting for consensus messages from this node will experience timeouts, degrading overall consensus performance.

2. **Significant Protocol Violations**: The health checker protocol's liveness guarantee is fundamentally broken. Nodes that should be marked unhealthy and disconnected can maintain peer connections indefinitely.

3. **State Inconsistencies Requiring Intervention**: If multiple validators exploit this to remain connected while being slow/unresponsive, the network could experience degraded liveness requiring manual intervention to identify and remove problematic nodes.

While this does not directly cause fund loss or consensus safety violations, it impacts network availability and performance, which are critical for blockchain operation. The vulnerability allows malicious actors to degrade network quality without being detected and removed by the health checking mechanism.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Any connected peer can send ping requests. The attack requires only periodic transmission of ping messages, which is trivial to implement.

2. **No Special Privileges Required**: The attacker does not need validator status, stake, or any privileged access. Any peer in the network can exploit this.

3. **Difficult to Detect**: The attack appears as normal health checker activity. Logs will show the malicious node sending pings and receiving pongs, which looks like healthy behavior.

4. **Natural Occurrence**: This can happen unintentionally with nodes experiencing asymmetric network conditions or resource constraints, where outbound requests succeed but inbound request processing is slow.

5. **Incentive for Malicious Validators**: A validator experiencing performance issues has a strong incentive to exploit this to avoid being disconnected and losing participation rewards.

The combination of ease of exploitation, lack of detection mechanisms, and potential for both malicious and unintentional occurrence makes this a high-likelihood issue.

## Recommendation

The health checker should distinguish between inbound and outbound health checks. Receiving an incoming ping from a peer should not reset the failure counter for our outbound health checks to that peer.

**Recommended Fix:**

Modify `handle_ping_request` to remove or conditionally apply the `reset_peer_failures` call:

```rust
fn handle_ping_request(
    &mut self,
    peer_id: PeerId,
    ping: Ping,
    protocol: ProtocolId,
    res_tx: oneshot::Sender<Result<Bytes, RpcError>>,
) {
    let message = match protocol.to_bytes(&HealthCheckerMsg::Pong(Pong(ping.0))) {
        Ok(msg) => msg,
        Err(e) => {
            warn!(
                NetworkSchema::new(&self.network_context),
                error = ?e,
                "{} Unable to serialize pong response: {}", self.network_context, e
            );
            return;
        },
    };
    trace!(
        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
        "{} Sending Pong response to peer: {} with nonce: {}",
        self.network_context,
        peer_id.short_str(),
        ping.0,
    );
    
    // REMOVED: Do not reset failures for incoming pings
    // Only successful responses to our outbound pings should reset failures
    // self.network_interface.reset_peer_failures(peer_id);

    let _ = res_tx.send(Ok(message.into()));
}
```

Alternatively, implement separate tracking for inbound and outbound health checks, allowing bidirectional liveness monitoring without the vulnerability.

## Proof of Concept

Add the following test to `network/framework/src/protocols/health_checker/test.rs`:

```rust
#[tokio::test]
async fn inbound_ping_should_not_reset_outbound_failures() {
    let ping_failures_tolerated = 3;
    let (mut harness, health_checker) = TestHarness::new_permissive(ping_failures_tolerated);

    let test = async move {
        // Setup: Add peer
        let peer_id = PeerId::new([0x42; PeerId::LENGTH]);
        harness.send_new_peer_notification(peer_id).await;

        // Step 1: Accumulate failures from outbound pings
        for _ in 0..ping_failures_tolerated {
            harness.trigger_ping().await;
            harness.expect_ping_send_not_ok().await;
        }

        // Step 2: Peer sends us an inbound ping (malicious behavior)
        let _res_rx = harness.send_inbound_ping(peer_id, 123).await;

        // Step 3: One more failed outbound ping should trigger disconnect
        // because inbound ping should NOT have reset the failure counter
        harness.trigger_ping().await;
        harness.expect_ping_send_not_ok().await;

        // Expected: Peer should be disconnected due to accumulated failures
        // Actual (current buggy behavior): Peer is NOT disconnected because
        // the inbound ping reset the failure counter
        harness.expect_disconnect(peer_id).await;
    };
    future::join(health_checker.start(), test).await;
}
```

**Expected Result (after fix)**: Test passes - peer is disconnected after `ping_failures_tolerated + 1` failed outbound pings, regardless of inbound pings received.

**Actual Result (current code)**: Test fails - peer is NOT disconnected because the inbound ping reset the failure counter, demonstrating the vulnerability.

---

**Notes:**

This vulnerability demonstrates a fundamental design flaw where bidirectional health checking interferes with unidirectional failure detection. The current implementation assumes that if a peer can send pings, it must be healthy, but this conflates the ability to send requests with the ability to respond to requests in a timely manner. This asymmetry enables the bypass attack and can occur naturally in networks with asymmetric routing, congestion, or resource constraints.

### Citations

**File:** network/framework/src/protocols/health_checker/mod.rs (L277-306)
```rust
    fn handle_ping_request(
        &mut self,
        peer_id: PeerId,
        ping: Ping,
        protocol: ProtocolId,
        res_tx: oneshot::Sender<Result<Bytes, RpcError>>,
    ) {
        let message = match protocol.to_bytes(&HealthCheckerMsg::Pong(Pong(ping.0))) {
            Ok(msg) => msg,
            Err(e) => {
                warn!(
                    NetworkSchema::new(&self.network_context),
                    error = ?e,
                    "{} Unable to serialize pong response: {}", self.network_context, e
                );
                return;
            },
        };
        trace!(
            NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
            "{} Sending Pong response to peer: {} with nonce: {}",
            self.network_context,
            peer_id.short_str(),
            ping.0,
        );
        // Record Ingress HC here and reset failures.
        self.network_interface.reset_peer_failures(peer_id);

        let _ = res_tx.send(Ok(message.into()));
    }
```

**File:** network/framework/src/protocols/health_checker/interface.rs (L118-124)
```rust
    /// Resets the number of peer failures for the given peer.
    /// If the peer is not found, nothing is done.
    pub fn reset_peer_failures(&mut self, peer_id: PeerId) {
        if let Some(health_check_data) = self.health_check_data.write().get_mut(&peer_id) {
            health_check_data.failures = 0;
        }
    }
```

**File:** config/src/config/network_config.rs (L38-40)
```rust
pub const PING_INTERVAL_MS: u64 = 10_000;
pub const PING_TIMEOUT_MS: u64 = 20_000;
pub const PING_FAILURES_TOLERATED: u64 = 3;
```
