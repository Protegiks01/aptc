# Audit Report

## Title
DAG Node Timestamp Manipulation Bypasses Time-Based Consensus Rules

## Summary
Byzantine validators can create and broadcast DAG nodes with arbitrary future timestamps that bypass validation, get certified by honest validators, and propagate into committed blocks. This allows manipulation of the on-chain global timestamp, breaking time-based consensus rules and enabling exploitation of time-dependent smart contracts.

## Finding Description

The DAG consensus implementation contains a critical timestamp validation gap that allows Byzantine validators to inject nodes with arbitrary timestamps into the consensus protocol.

**Root Cause:**

The `Node::verify()` function explicitly does NOT validate timestamps. [1](#0-0)  The verification process checks sender authenticity, digest validity, round constraints, and parent voting power, but completely skips timestamp validation as indicated by the TODO comment.

**Attack Path:**

1. **Node Creation with Manipulated Timestamp:** A Byzantine validator creates a DAG node with an arbitrary future timestamp (e.g., current_time + 1 year). The timestamp is included in the node's digest calculation. [2](#0-1) 

2. **Storage and Broadcasting:** The node is saved to local storage and broadcast to other validators. [3](#0-2) 

3. **Validation Bypass at Receiving Validators:** When honest validators receive the node via RPC, it undergoes verification through `NodeBroadcastHandler::validate()` [4](#0-3)  which performs extensive validation but omits timestamp checking. Subsequently, `Node::verify()` is called [5](#0-4)  which checks the digest, round constraints, and parent voting power, but skips timestamp validation entirely due to the unimplemented validation at line 342.

4. **Vote Collection:** Honest validators vote on the node because it passes all validation checks except the unimplemented timestamp validation. The signature builder aggregates votes. [6](#0-5) 

5. **Block Creation with Manipulated Timestamp:** When the certified node is ordered and converted to a block, the manipulated timestamp propagates through the block creation process. [7](#0-6)  The block timestamp calculation uses `max(anchor_timestamp, parent_timestamp + 1)`. For a future timestamp that exceeds `parent_timestamp + 1`, the manipulated timestamp is used directly.

6. **Validation Bypass for DAG Blocks:** Unlike regular BFT blocks, DAG blocks explicitly bypass `verify_well_formed()` validation which would normally reject timestamps more than 5 minutes in the future. [8](#0-7)  This means DAG blocks never undergo the timestamp bounds checking that exists at [9](#0-8) 

7. **On-Chain Timestamp Update:** During block execution, the Move framework's `update_global_time()` validates only that the new timestamp is greater than the current on-chain time. [10](#0-9)  A manipulated future timestamp satisfies `now < timestamp`, so it gets accepted and updates the global on-chain time to the far-future value. The function is called during block execution at [11](#0-10) 

## Impact Explanation

**Severity: High**

This vulnerability constitutes a **significant protocol violation** under the Aptos Bug Bounty program criteria:

- **Time-Dependent Contract Exploitation**: Any Move smart contracts using `aptos_framework::timestamp::now_microseconds()` for time-based logic (vesting schedules, auction deadlines, time-locks, bond maturation) can be exploited by fast-forwarding blockchain time. Smart contracts query the timestamp via [12](#0-11)  which returns the manipulated value.

- **Consensus Rule Bypass**: The attack violates the implicit assumption that timestamps should advance naturally with real-world time, aligned with the `time_service` measurements used for normal node creation at [13](#0-12) 

- **Network-Wide Persistent Impact**: Once a block with manipulated timestamp is committed, ALL subsequent blocks must have timestamps greater than the manipulated value due to the monotonicity check at [10](#0-9) , effectively "locking" the blockchain into the future timeline.

The attack requires only a single Byzantine validator to create the malicious node and obtain 2f+1 votes from honest validators, which will occur due to the missing validation.

## Likelihood Explanation

**Likelihood: High**

Required conditions:
1. **Single Byzantine validator**: Only one malicious validator is needed
2. **Standard validator capabilities**: The validator can create nodes with arbitrary timestamps
3. **2f+1 votes from honest validators**: The manipulated node will collect votes because all validation checks pass

The attack is highly feasible because:
- Honest validators WILL vote on nodes with manipulated future timestamps due to the explicitly missing validation at [1](#0-0) 
- No collusion with other validators is required
- The technical complexity is low (create node with desired timestamp, broadcast normally)
- DAG blocks bypass the 5-minute future timestamp bound check that regular blocks undergo

Mitigating factors:
- Requires being an active validator (requires stake)
- The attack leaves evidence in the blockchain (abnormal timestamp jump)

## Recommendation

Implement timestamp validation in the `Node::verify()` method to enforce reasonable timestamp bounds:

```rust
// In consensus/src/dag/types.rs, replace the TODO at line 342 with:

// Validate timestamp bounds
let highest_parent_timestamp = self.parents()
    .iter()
    .map(|parent| parent.metadata().timestamp())
    .max()
    .unwrap_or(0);

// Timestamp must be greater than parent timestamps
ensure!(
    self.timestamp() > highest_parent_timestamp,
    "Node timestamp must be greater than parent timestamps"
);

// Timestamp must not be too far in the future (5 minutes bound)
let current_ts = duration_since_epoch();
const TIMEBOUND: u64 = 300_000_000; // 5 minutes in microseconds
ensure!(
    self.timestamp() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
    "Node timestamp must not be more than 5 minutes in the future"
);
```

Additionally, add timestamp validation in `NodeBroadcastHandler::validate()` to reject nodes early before voting.

## Proof of Concept

A complete proof of concept would require:
1. Setting up a local Aptos testnet with multiple validators
2. Modifying one validator to create a node with `timestamp = current_time + 1_year`
3. Broadcasting the node and observing honest validators voting on it
4. Confirming the manipulated timestamp propagates to the committed block
5. Verifying that `timestamp::now_microseconds()` returns the manipulated future time

The vulnerability is evident from the code structure: [5](#0-4)  shows complete absence of timestamp validation, and [8](#0-7)  confirms DAG blocks bypass the timestamp bounds checking that would normally prevent this attack.

### Citations

**File:** consensus/src/dag/types.rs (L217-237)
```rust
    fn calculate_digest_internal(
        epoch: u64,
        round: Round,
        author: Author,
        timestamp: u64,
        validator_txns: &Vec<ValidatorTransaction>,
        payload: &Payload,
        parents: &Vec<NodeCertificate>,
        extensions: &Extensions,
    ) -> HashValue {
        let node_with_out_digest = NodeWithoutDigest {
            epoch,
            round,
            author,
            timestamp,
            validator_txns,
            payload,
            parents,
            extensions,
        };
        node_with_out_digest.hash()
```

**File:** consensus/src/dag/types.rs (L301-345)
```rust
    pub fn verify(&self, sender: Author, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            sender == *self.author(),
            "Author {} doesn't match sender {}",
            self.author(),
            sender
        );
        // TODO: move this check to rpc process logic to delay it as much as possible for performance
        ensure!(self.digest() == self.calculate_digest(), "invalid digest");

        let node_round = self.metadata().round();

        ensure!(node_round > 0, "current round cannot be zero");

        if node_round == 1 {
            ensure!(self.parents().is_empty(), "invalid parents for round 1");
            return Ok(());
        }

        let prev_round = node_round - 1;
        // check if the parents' round is the node's round - 1
        ensure!(
            self.parents()
                .iter()
                .all(|parent| parent.metadata().round() == prev_round),
            "invalid parent round"
        );

        // Verification of the certificate is delayed until we need to fetch it
        ensure!(
            verifier
                .check_voting_power(
                    self.parents()
                        .iter()
                        .map(|parent| parent.metadata().author()),
                    true,
                )
                .is_ok(),
            "not enough parents to satisfy voting power"
        );

        // TODO: validate timestamp

        Ok(())
    }
```

**File:** consensus/src/dag/types.rs (L565-605)
```rust
    fn add(&self, peer: Author, ack: Self::Response) -> anyhow::Result<Option<Self::Aggregated>> {
        ensure!(self.metadata == ack.metadata, "Digest mismatch");
        ack.verify(peer, &self.epoch_state.verifier)?;
        debug!(LogSchema::new(LogEvent::ReceiveVote)
            .remote_peer(peer)
            .round(self.metadata.round()));
        let mut guard = self.inner.lock();
        let (partial_signatures, tx) = guard.deref_mut();
        partial_signatures.add_signature(peer, ack.signature);

        if tx.is_some()
            && self
                .epoch_state
                .verifier
                .check_voting_power(partial_signatures.signatures().keys(), true)
                .is_ok()
        {
            let aggregated_signature = match self
                .epoch_state
                .verifier
                .aggregate_signatures(partial_signatures.signatures_iter())
            {
                Ok(signature) => signature,
                Err(_) => return Err(anyhow::anyhow!("Signature aggregation failed")),
            };
            observe_node(self.metadata.timestamp(), NodeStage::CertAggregated);
            let certificate = NodeCertificate::new(self.metadata.clone(), aggregated_signature);

            // Invariant Violation: The one-shot channel sender must exist to send the NodeCertificate
            _ = tx
                .take()
                .expect("The one-shot channel sender must exist to send the NodeCertificate")
                .send(certificate);
        }

        if partial_signatures.signatures().len() == self.epoch_state.verifier.len() {
            Ok(Some(()))
        } else {
            Ok(None)
        }
    }
```

**File:** consensus/src/dag/dag_driver.rs (L300-303)
```rust
        let timestamp = std::cmp::max(
            self.time_service.now_unix_time().as_micros() as u64,
            highest_parent_timestamp + 1,
        );
```

**File:** consensus/src/dag/dag_driver.rs (L314-317)
```rust
        self.storage
            .save_pending_node(&new_node)
            .expect("node must be saved");
        self.broadcast_node(new_node);
```

**File:** consensus/src/dag/rb_handler.rs (L112-185)
```rust
    fn validate(&self, node: Node) -> anyhow::Result<Node> {
        ensure!(
            node.epoch() == self.epoch_state.epoch,
            "different epoch {}, current {}",
            node.epoch(),
            self.epoch_state.epoch
        );

        let num_vtxns = node.validator_txns().len() as u64;
        ensure!(num_vtxns <= self.vtxn_config.per_block_limit_txn_count());
        for vtxn in node.validator_txns() {
            let vtxn_type_name = vtxn.type_name();
            ensure!(
                is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                "unexpected validator transaction: {:?}",
                vtxn_type_name
            );
            vtxn.verify(self.epoch_state.verifier.as_ref())
                .context(format!("{} verification failed", vtxn_type_name))?;
        }
        let vtxn_total_bytes = node
            .validator_txns()
            .iter()
            .map(ValidatorTransaction::size_in_bytes)
            .sum::<usize>() as u64;
        ensure!(vtxn_total_bytes <= self.vtxn_config.per_block_limit_total_bytes());

        let num_txns = num_vtxns + node.payload().len() as u64;
        let txn_bytes = vtxn_total_bytes + node.payload().size() as u64;
        ensure!(num_txns <= self.payload_config.max_receiving_txns_per_round);
        ensure!(txn_bytes <= self.payload_config.max_receiving_size_per_round_bytes);

        let current_round = node.metadata().round();

        let dag_reader = self.dag.read();
        let lowest_round = dag_reader.lowest_round();

        ensure!(
            current_round >= lowest_round,
            NodeBroadcastHandleError::StaleRound(current_round)
        );

        // check which parents are missing in the DAG
        let missing_parents: Vec<NodeCertificate> = node
            .parents()
            .iter()
            .filter(|parent| !dag_reader.exists(parent.metadata()))
            .cloned()
            .collect();
        drop(dag_reader); // Drop the DAG store early as it is no longer required

        if !missing_parents.is_empty() {
            // For each missing parent, verify their signatures and voting power.
            // Otherwise, a malicious node can send bad nodes with fake parents
            // and cause this peer to issue unnecessary fetch requests.
            ensure!(
                missing_parents
                    .iter()
                    .all(|parent| { parent.verify(&self.epoch_state.verifier).is_ok() }),
                NodeBroadcastHandleError::InvalidParent
            );

            // Don't issue fetch requests for parents of the lowest round in the DAG
            // because they are already GC'ed
            if current_round > lowest_round {
                if let Err(err) = self.fetch_requester.request_for_node(node) {
                    error!("request to fetch failed: {}", err);
                }
                bail!(NodeBroadcastHandleError::MissingParents);
            }
        }

        Ok(node)
    }
```

**File:** consensus/src/dag/adapter.rs (L174-175)
```rust
        let parent_timestamp = self.parent_block_info.read().timestamp_usecs();
        let block_timestamp = timestamp.max(parent_timestamp.checked_add(1).expect("must add"));
```

**File:** consensus/consensus-types/src/block.rs (L462-462)
```rust
            BlockType::DAGBlock { .. } => bail!("We should not accept DAG block from others"),
```

**File:** consensus/consensus-types/src/block.rs (L536-538)
```rust
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L47-48)
```text
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L61-63)
```text
    public fun now_microseconds(): u64 acquires CurrentTimeMicroseconds {
        borrow_global<CurrentTimeMicroseconds>(@aptos_framework).microseconds
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L281-281)
```text
        timestamp::update_global_time(vm, new_block_event.proposer, new_block_event.time_microseconds);
```
