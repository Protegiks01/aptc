# Audit Report

## Title
Magic Header Information Disclosure Through TLS Termination at Reverse Proxy

## Summary
The MagicHeaderChecker authentication mechanism uses a static secret header that is transmitted in plaintext when TLS is terminated at a reverse proxy, allowing the secret to be intercepted through network sniffing or proxy access logs. This enables authentication bypass of the faucet's magic header protection.

## Finding Description
The MagicHeaderChecker [1](#0-0)  implements a simple authentication mechanism that verifies the presence of a configured HTTP header with a specific secret value.

In production Aptos deployments, the faucet service runs behind Kubernetes Ingress controllers with TLS termination. The infrastructure shows:

1. **AWS ALB with TLS termination**: [2](#0-1) 

2. **HAProxy reverse proxy with HTTP logging enabled**: [3](#0-2) 

3. **Header forwarding in plaintext**: [4](#0-3) 

When TLS terminates at the ALB/Ingress layer, the connection from the proxy to the faucet backend uses plaintext HTTP. This creates multiple exposure vectors:

**Attack Path:**
1. Legitimate user makes request to `https://faucet.aptos.dev/fund` with magic header
2. TLS terminates at AWS ALB, which decrypts the request
3. ALB forwards request to backend HAProxy/faucet service over **plaintext HTTP**
4. Magic header value is visible in transit and potentially logged in:
   - ALB access logs (if enabled)
   - HAProxy HTTP logs [5](#0-4) 
   - Network monitoring tools
   - Error logs and debugging output
5. Attacker with log access or network visibility obtains the magic header value
6. Attacker includes the magic header in their requests to bypass this authentication check

The CheckerData structure passes headers through the request pipeline: [6](#0-5) 

## Impact Explanation
This qualifies as **Medium Severity** based on:

**Authentication Bypass**: Once the magic header is leaked, attackers can bypass this authentication layer entirely, though other defenses (rate limiting, CAPTCHA) remain [7](#0-6) 

**Limited Scope**: The faucet distributes testnet tokens for development purposes [8](#0-7) , not mainnet funds with real economic value.

**Defense-in-Depth Violation**: While not catastrophic alone, breaking one security layer increases overall risk and enables easier resource exhaustion attacks.

This does not constitute Critical or High severity as it doesn't affect consensus, validator operations, or real fund security.

## Likelihood Explanation
**High Likelihood** of exposure:
- TLS termination at load balancers is standard practice in Kubernetes deployments
- ALB access logging is commonly enabled for compliance/debugging
- HAProxy HTTP logging is explicitly configured [9](#0-8) 
- Network monitoring tools routinely capture HTTP traffic for troubleshooting

**Medium Likelihood** of exploitation:
- Requires attacker to gain access to logs or network traffic
- In cloud environments, this may require compromising log aggregation systems or gaining network access
- Once obtained, exploitation is trivial (include header in requests)

## Recommendation

**Immediate Mitigation:**
1. Use HMAC-based authentication instead of static headers:
```rust
// Replace static header check with HMAC verification
pub struct HmacHeaderChecker {
    secret_key: Vec<u8>,
    timestamp_tolerance_secs: u64,
}

impl HmacHeaderChecker {
    fn verify_request(&self, timestamp: u64, signature: &str, data: &str) -> bool {
        // Verify timestamp is recent
        // Verify HMAC(secret_key, timestamp + data) == signature
        // Prevents replay attacks and doesn't expose secret
    }
}
```

2. Enable end-to-end TLS between proxy and backend, or require mutual TLS (mTLS)

3. Document security implications in configuration files [10](#0-9) 

4. Implement header sanitization in logging middleware to prevent accidental exposure [11](#0-10) 

## Proof of Concept

**Step 1: Deploy faucet with magic header behind ALB (production scenario)**
```yaml
# configs/production.yaml
checker_configs:
  - type: MagicHeader
    magic_header_key: "X-Faucet-Auth"
    magic_header_value: "super-secret-token-12345"
```

**Step 2: Capture traffic between ALB and backend**
```bash
# On network with access to ALB->backend traffic
tcpdump -i eth0 -A 'tcp port 8080' | grep "X-Faucet-Auth"
# Output: X-Faucet-Auth: super-secret-token-12345
```

**Step 3: Extract from HAProxy logs**
```bash
# HAProxy logs HTTP requests with all headers
kubectl logs haproxy-pod | grep "X-Faucet-Auth"
# Logs contain: "X-Faucet-Auth: super-secret-token-12345"
```

**Step 4: Use captured header to bypass authentication**
```bash
curl -H "X-Faucet-Auth: super-secret-token-12345" \
     -H "Content-Type: application/json" \
     -X POST \
     -d '{"address": "0x123..."}' \
     https://faucet.aptos.dev/fund
# Request succeeds despite attacker not being authorized
```

## Notes
This vulnerability specifically affects deployments with TLS termination at the reverse proxy/load balancer level, which is the standard production pattern shown in the Kubernetes Ingress configurations. While the faucet is not a consensus-critical component, proper authentication is essential for preventing resource abuse and maintaining service availability.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L10-14)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    pub magic_header_value: String,
}
```

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L26-52)
```rust
#[async_trait]
impl CheckerTrait for MagicHeaderChecker {
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        let header_value = match data.headers.get(&self.config.magic_header_key) {
            Some(header_value) => header_value,
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Magic header {} not found", self.config.magic_header_key),
                    RejectionReasonCode::MagicHeaderIncorrect,
                )])
            },
        };
        if header_value != &self.config.magic_header_value {
            return Ok(vec![RejectionReason::new(
                format!(
                    "Magic header value wrong {} not found",
                    self.config.magic_header_key
                ),
                RejectionReasonCode::MagicHeaderIncorrect,
            )]);
        }
        Ok(vec![])
    }
```

**File:** terraform/helm/testnet-addons/templates/ingress.yaml (L19-24)
```yaml
    {{- if .Values.ingress.acm_certificate }}
    alb.ingress.kubernetes.io/certificate-arn: {{ .Values.ingress.acm_certificate }}
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
    # ensure ALB ingress controller is version > 1.4.4
    alb.ingress.kubernetes.io/ssl-redirect: '443'
    {{- end }}
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L25-25)
```text
    log-format "%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq"
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L94-108)
```text
    mode http
    option httplog
    bind :9102
    default_backend validator-metrics

    # Deny requests from blocked IPs
    tcp-request connection reject if { src -n -f /usr/local/etc/haproxy/blocked.ips }

    ## Add the forwarded header
    http-request add-header Forwarded "for=%ci"

## Specify the validator metrics backend
backend validator-metrics
    mode http
    server {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator:9101
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L139-145)
```text
    ## Add the forwarded header
    http-request add-header Forwarded "for=%ci"

## Specify the validator API backend
backend validator-api
    mode http
    server {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator:8080
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L147-153)
```rust
#[derive(Clone, Debug)]
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-278)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/README.md (L1-3)
```markdown
# Aptos Faucet

The Aptos Faucet is a service that runs alongside a test network and mints coins for users to test and develop on Aptos.
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L30-46)
```rust
    let request_log = HttpRequestLog {
        source_ip,
        method: request.method().to_string(),
        path: request.uri().path().to_string(),
        referer: request
            .headers()
            .get(header::REFERER)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        user_agent: request
            .headers()
            .get(header::USER_AGENT)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        forwarded: request
            .headers()
            .get(header::FORWARDED)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
    };
```
