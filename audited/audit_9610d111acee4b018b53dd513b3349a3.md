# Audit Report

## Title
SKIP_BAILOUT_ON_EXTENDED_CHECKS Bypasses Critical Security Validations Allowing Malicious Package Deployment

## Summary
The `SKIP_BAILOUT_ON_EXTENDED_CHECKS` compiler experiment flag, intended "for testing only", is accessible via CLI and allows bypassing critical extended security checks during package compilation. When enabled, packages with security-critical errors (unsafe randomness exposure, invalid entry function signatures, view function violations) can be successfully built and deployed to the blockchain, as on-chain validation does not re-run these checks. [1](#0-0) 

## Finding Description

The `build_with_external_checks()` function runs extended security checks via `extended_checks::run_extended_checks(model)`. These checks validate critical security properties including:

1. **Randomness Safety**: Prevents public functions from exposing randomness features (bias attacks)
2. **Entry Function Validation**: Ensures entry functions only accept valid transaction parameter types
3. **View Function Constraints**: Enforces that view functions cannot use signers and must return values
4. **Resource Group Validation**: Validates proper resource group structure
5. **Init Module Checks**: Ensures init_module functions follow strict signature requirements [2](#0-1) 

The vulnerability occurs in the error handling logic. When `SKIP_BAILOUT_ON_EXTENDED_CHECKS` is enabled, the conditional block that reports diagnostics and bails on errors is completely bypassed: [3](#0-2) 

The experiment flag is defined as "for testing only" but remains accessible via CLI: [4](#0-3) [5](#0-4) 

**Attack Path Example - Randomness Safety Bypass**:

Extended checks explicitly error on public functions exposing randomness: [6](#0-5) 

However, on-chain validation does NOT re-validate randomness safety. The validation only checks bytecode stability, natives, metadata, resource groups, and events: [7](#0-6) 

This creates a critical gap: compile-time security checks can be bypassed, and on-chain validation assumes they passed.

**Exploitation Steps**:

1. Attacker creates a Move module with a public function that calls `randomness::u64_range()`
2. Compiles with: `aptos move publish --experiments skip-bailout-on-extended-checks`
3. Extended checks detect the violation but don't bail due to the flag
4. Package builds successfully with the security violation embedded
5. On-chain deployment succeeds (no randomness re-validation)
6. Malicious contract is now deployed with exploitable randomness exposure

## Impact Explanation

**High Severity** - This qualifies as a "Significant protocol violation" per Aptos bug bounty criteria:

1. **Randomness Bias Attacks**: Public randomness exposure allows attackers to manipulate outcomes in games, lotteries, or any randomness-dependent logic, potentially stealing funds or breaking fairness guarantees

2. **Transaction Validation Failures**: Entry functions with invalid parameter types can be deployed but fail at transaction execution time, causing unpredictable behavior and potential DoS

3. **Protocol Invariant Violations**: Multiple critical invariants can be broken:
   - Move VM Safety: Bytecode doesn't respect security constraints
   - Transaction Validation: Entry functions bypass type validation
   - Deterministic Execution: Different error paths on different nodes if validation inconsistencies occur

4. **Widespread Impact**: Any user can exploit this via standard CLI tools without requiring validator privileges or special access

## Likelihood Explanation

**High Likelihood**:

1. **Easy to Execute**: Requires only adding a single CLI flag that is documented in the codebase
2. **No Privilege Required**: Any developer can use this flag when building packages
3. **Hidden but Accessible**: The flag is marked `hide(true)` in the CLI but still functional
4. **Accidental Misuse**: Developers testing locally with this flag might accidentally deploy to production
5. **Intentional Abuse**: Malicious actors can deliberately use this to bypass security checks

The main barrier is knowledge of the flag's existence, but it's present in public source code.

## Recommendation

**Immediate Fix**: Remove the ability to set this experiment flag outside of test environments.

```rust
// In build_with_external_checks(), add an explicit check:
if model.diag_count(Severity::Warning) > 0
    && !model
        .get_extension::<Options>()
        .is_some_and(|model_options| {
            model_options.experiment_on(Experiment::SKIP_BAILOUT_ON_EXTENDED_CHECKS)
        })
{
    let mut error_writer = StandardStream::stderr(ColorChoice::Auto);
    model.report_diag(&mut error_writer, Severity::Warning);
    if model.has_errors() {
        bail!("extended checks failed")
    }
}

// Add AFTER the above block:
// Ensure this flag cannot bypass errors in non-test builds
if model.has_errors() {
    bail!("compilation failed with errors")
}
```

**Better Solution**: Make the experiment flag only accessible in test configuration:

```rust
// In experiments.rs, mark it as test-only at the type level
#[cfg(not(test))]
pub const SKIP_BAILOUT_ON_EXTENDED_CHECKS: &'static str = ""; // Disable in production

#[cfg(test)]
pub const SKIP_BAILOUT_ON_EXTENDED_CHECKS: &'static str = "skip-bailout-on-extended-checks";
```

**Additional Hardening**: Add on-chain re-validation of critical properties like randomness safety during module publishing.

## Proof of Concept

```move
// malicious_randomness.move
module attacker::exploit {
    use std::signer;
    use aptos_framework::randomness;
    
    // This public function exposes randomness, which is UNSAFE
    // Extended checks should ERROR on this, but with skip flag it passes
    public fun exploitable_random(account: &signer): u64 {
        // Public exposure of randomness allows bias attacks
        randomness::u64_range(1, 100)
    }
    
    public entry fun steal_funds(victim: &signer) {
        // Attacker can manipulate randomness outcomes
        let rigged_value = exploitable_random(victim);
        // Use rigged value for unfair advantage in games/lotteries
    }
}
```

**Build Command** (bypasses security check):
```bash
aptos move publish --experiments skip-bailout-on-extended-checks
```

**Expected Behavior**: Should fail with error:
```
error: public function exposes functionality of the `randomness` module which can be unsafe
```

**Actual Behavior with Flag**: Builds successfully, deploys to blockchain with security violation.

**Verification Steps**:
1. Create the above module in a Move package
2. Try normal publish: `aptos move publish` → Should fail with randomness error
3. Try with bypass flag: `aptos move publish --experiments skip-bailout-on-extended-checks` → Succeeds
4. Module is now on-chain with exploitable randomness exposure

### Citations

**File:** aptos-move/framework/src/built_package.rs (L310-323)
```rust
            let runtime_metadata = extended_checks::run_extended_checks(model);
            if model.diag_count(Severity::Warning) > 0
                && !model
                    .get_extension::<Options>()
                    .is_some_and(|model_options| {
                        model_options.experiment_on(Experiment::SKIP_BAILOUT_ON_EXTENDED_CHECKS)
                    })
            {
                let mut error_writer = StandardStream::stderr(ColorChoice::Auto);
                model.report_diag(&mut error_writer, Severity::Warning);
                if model.has_errors() {
                    bail!("extended checks failed")
                }
            }
```

**File:** aptos-move/framework/src/extended_checks.rs (L87-131)
```rust
pub fn run_extended_checks(env: &GlobalEnv) -> BTreeMap<ModuleId, RuntimeModuleMetadataV1> {
    let mut checker = ExtendedChecker::new(env);
    checker.run();
    checker.output
}

#[derive(Debug)]
struct ExtendedChecker<'a> {
    env: &'a GlobalEnv,
    /// Computed runtime metadata
    output: BTreeMap<ModuleId, RuntimeModuleMetadataV1>,
    /// The id of the module defining error categories
    error_category_module: ModuleId,
    /// A cache for functions which are known to call or not call randomness features
    randomness_caller_cache: BTreeMap<QualifiedId<FunId>, bool>,
}

impl<'a> ExtendedChecker<'a> {
    fn new(env: &'a GlobalEnv) -> Self {
        Self {
            env,
            output: BTreeMap::default(),
            error_category_module: ModuleId::new(
                AccountAddress::ONE,
                Identifier::new("error").unwrap(),
            ),
            randomness_caller_cache: BTreeMap::new(),
        }
    }

    fn run(&mut self) {
        for ref module in self.env.get_modules() {
            if module.is_primary_target() {
                self.check_and_record_resource_groups(module);
                self.check_and_record_resource_group_members(module);
                self.check_and_record_view_functions(module);
                self.check_entry_functions(module);
                self.check_and_record_unbiasabale_entry_functions(module);
                self.check_unsafe_randomness_usage(module);
                self.check_and_record_events(module);
                self.check_init_module(module);
                self.build_error_map(module)
            }
        }
    }
```

**File:** aptos-move/framework/src/extended_checks.rs (L634-645)
```rust
            if self.calls_randomness(fun_id) {
                self.env.error(
                    &fun.get_id_loc(),
                    &format!(
                        "public function exposes functionality of the `randomness` module \
                    which can be unsafe. Consult the randomness documentation for an explanation \
                    of this error. To skip this check, add \
                    attribute `#[{}]`.",
                        ALLOW_UNSAFE_RANDOMNESS_ATTRIBUTE
                    ),
                )
            }
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L283-286)
```rust
            name: Experiment::SKIP_BAILOUT_ON_EXTENDED_CHECKS.to_string(),
            description: "Skip errors originating from extended checks, for testing only"
                .to_string(),
            default: Given(false),
```

**File:** crates/aptos/src/common/types.rs (L1250-1252)
```rust
    /// Experiments
    #[clap(long, hide(true), num_args = 1.., value_delimiter = ',')]
    pub experiments: Vec<String>,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1738)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
```
