# Audit Report

## Title
JWK Consensus Missing Cross-Session Equivocation Detection for Validator Observations

## Summary
The JWK consensus message processing does not detect when a validator signs and sends multiple conflicting `ObservedUpdate` proposals for the same issuer and epoch across different aggregation sessions. A malicious validator can equivocate by sending different signed observations to different peers without detection or penalty, weakening the Byzantine fault tolerance guarantees of the system.

## Finding Description

The JWK consensus protocol uses a reliable broadcast mechanism where validators observe OIDC provider JWK sets and reach quorum agreement. When a validator observes a JWK set, it signs a `ProviderJWKs` structure containing the issuer, version, and JWKs, then responds to observation requests from peers.

The vulnerability exists in the observation aggregation logic. Each validator that wants to certify an update creates a separate `ObservationAggregationState` instance and broadcasts `ObservationRequest` messages to all validators. When peers respond with their signed `ObservedUpdate`, the aggregation logic only checks if that peer has already responded **within the current aggregation session**: [1](#0-0) 

This check uses `partial_sigs.contains_voter(&sender)` which only tracks voters in the current session's `inner_state`. There is no global or persistent tracking of what validators have signed across different aggregation sessions.

**Attack Scenario:**

1. Validator V1 observes and starts aggregating for `ProviderJWKs{issuer: "Alice", version: 1, jwks: X}`
2. Validator V2 observes and starts aggregating for `ProviderJWKs{issuer: "Alice", version: 1, jwks: Y}` where X â‰  Y (possibly due to timing or the OIDC provider changing)
3. Malicious validator M receives both requests
4. M responds to V1 with `ObservedUpdate{author: M, observed: X, signature: sig_M_X}`
5. M responds to V2 with `ObservedUpdate{author: M, observed: Y, signature: sig_M_Y}`
6. Both V1 and V2 accept M's response as valid - each session only checks if M hasn't voted in THEIR session
7. M has now signed two conflicting values for the same (issuer, version) tuple without detection

The message processing in `NetworkTask::start()` simply forwards all RPC requests without any equivocation checking: [2](#0-1) 

When responses are processed, the signature verification only confirms the signature is valid for the specific observation, not that the validator hasn't signed conflicting observations elsewhere: [3](#0-2) 

## Impact Explanation

This constitutes a **Medium Severity** vulnerability under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: Byzantine Fault Tolerant consensus protocols must detect equivocation to maintain security guarantees. The inability to detect validator double-signing weakens the system's resilience against Byzantine actors.

2. **State Inconsistencies**: While the >2/3 quorum threshold prevents both conflicting views from simultaneously reaching consensus, malicious validators can influence which value reaches quorum and waste network resources by signing multiple incompatible proposals.

3. **No Accountability**: Without equivocation detection, malicious validators face no consequences for provably dishonest behavior (signing conflicting data). This violates the fundamental security property that Byzantine behavior should be detectable and punishable.

4. **Consensus Safety Weakening**: Though not an immediate consensus failure with <1/3 Byzantine nodes, the lack of detection means the safety margin is effectively reduced as malicious behavior goes unpunished.

This does not reach **Critical Severity** because:
- No direct fund loss or theft
- With <1/3 Byzantine validators, safety is maintained (both conflicting values cannot reach quorum)
- Does not cause permanent network partition or total liveness loss

This exceeds **Low Severity** because it's a fundamental consensus protocol violation, not merely an information leak or minor implementation bug.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attacker Requirements**: Requires control of validator node(s), which is non-trivial but not extremely rare given the permissionless nature of validator participation (subject to stake requirements)
- **Complexity**: Attack is straightforward - simply modify the response logic to send different observations to different requesters
- **Detection Difficulty**: The attack is completely undetectable with current code, leaving no evidence
- **Motivation**: Rational for attackers who want to manipulate JWK consensus without being caught, influence OIDC provider updates, or simply disrupt the system

The attack is more likely during periods of:
- OIDC provider instability (when different validators might legitimately observe different values)
- Network partitions or timing issues
- Validator set changes or epoch transitions

## Recommendation

Implement cross-session equivocation detection by maintaining a persistent record of what each validator has signed for each (issuer, epoch, version) tuple. This can be done by:

1. **Add Equivocation Tracking Storage**: Maintain a map of `(Author, Issuer, Epoch, Version) -> (ProviderJWKs, Signature)` that persists across aggregation sessions

2. **Check for Conflicting Signatures**: Before accepting an observation in `ObservationAggregationState::add()`, verify that if this author has previously signed for this (issuer, epoch, version), the observation matches

3. **Evidence Collection**: When equivocation is detected, store the conflicting signed observations as evidence that can be:
   - Submitted to the chain for slashing
   - Broadcast to other validators
   - Used to blacklist the malicious validator

**Suggested code fix** (pseudocode for illustration):

```rust
// In ObservationAggregationState or a shared equivocation detector
fn check_equivocation(
    &self,
    author: &Author,
    observed: &ProviderJWKs,
    signature: &Signature,
) -> Result<(), EquivocationEvidence> {
    let key = (author.clone(), observed.issuer.clone(), self.epoch_state.epoch, observed.version);
    
    if let Some((previous_observed, previous_sig)) = self.signed_observations.get(&key) {
        if previous_observed != observed {
            // Equivocation detected!
            return Err(EquivocationEvidence {
                author: author.clone(),
                observation_1: (previous_observed.clone(), previous_sig.clone()),
                observation_2: (observed.clone(), signature.clone()),
            });
        }
    } else {
        self.signed_observations.insert(key, (observed.clone(), signature.clone()));
    }
    Ok(())
}
```

The check should be added before signature verification in the `add()` function: [4](#0-3) 

## Proof of Concept

**Setup**: Deploy a test network with 4 validators (V1, V2, V3, M) where M is malicious.

**Step 1 - Modify Malicious Validator Code**:
```rust
// In malicious validator's process_peer_request handler
pub fn process_peer_request(&mut self, rpc_req: IncomingRpcRequest) -> Result<()> {
    let IncomingRpcRequest { msg, mut response_sender, sender, .. } = rpc_req;
    
    match msg {
        JWKConsensusMsg::ObservationRequest(request) => {
            let state = self.states_by_issuer.entry(request.issuer.clone()).or_default();
            
            // MALICIOUS: Send different observations based on requester
            let my_proposal = if sender == V1_ADDRESS {
                create_observation_for_jwks_X()  // Observation X
            } else {
                create_observation_for_jwks_Y()  // Observation Y (conflicting)
            };
            
            let response = Ok(JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                epoch: self.epoch_state.epoch,
                update: my_proposal,
            }));
            response_sender.send(response);
            Ok(())
        },
        _ => bail!("unexpected rpc"),
    }
}
```

**Step 2 - Trigger Scenario**:
1. Configure OIDC provider to return JWK set X consistently
2. V1 observes X and starts aggregation
3. Simultaneously, have V2 also start aggregation for X
4. Malicious M responds to V1 with signed observation for X
5. Malicious M responds to V2 with signed observation for Y (different JWKs, same issuer/version)

**Expected Result**: Both aggregation sessions accept M's signature without detecting equivocation.

**Evidence of Vulnerability**: Check logs - no equivocation warnings or errors, both sessions proceed normally accepting M's conflicting signatures.

## Notes

This vulnerability is distinct from OIDC provider equivocation (tested in existing test suites). The test at [5](#0-4)  tests provider-side equivocation, not validator equivocation.

The DAG consensus implementation does implement equivocation detection for block proposals, showing that the Aptos team understands the importance of this security property in consensus protocols. The JWK consensus should have similar protections.

### Citations

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L76-79)
```rust
        let mut partial_sigs = self.inner_state.lock();
        if partial_sigs.contains_voter(&sender) {
            return Ok(None);
        }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-89)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );

        // Verify peer signature.
        self.epoch_state
            .verifier
            .verify(sender, &peer_view, &signature)?;
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L188-210)
```rust
    pub async fn start(mut self) {
        while let Some(message) = self.all_events.next().await {
            match message {
                Event::RpcRequest(peer_id, msg, protocol, response_sender) => {
                    let req = IncomingRpcRequest {
                        msg,
                        sender: peer_id,
                        response_sender: Box::new(RealRpcResponseSender {
                            inner: Some(response_sender),
                            protocol,
                        }),
                    };

                    if let Err(e) = self.rpc_tx.push(peer_id, (peer_id, req)) {
                        warn!(error = ?e, "aptos channel closed");
                    };
                },
                _ => {
                    // Ignore
                },
            }
        }
    }
```

**File:** testsuite/smoke-test/src/jwks/jwk_consensus_per_issuer.rs (L60-90)
```rust
    info!("Adding some providers, one seriously equivocating, the other well behaving.");
    let (alice_config_server, alice_jwks_server, bob_config_server, bob_jwks_server) = tokio::join!(
        DummyHttpServer::spawn(),
        DummyHttpServer::spawn(),
        DummyHttpServer::spawn(),
        DummyHttpServer::spawn()
    );
    let alice_issuer_id = "https://alice.io";
    let bob_issuer_id = "https://bob.dev";
    alice_config_server.update_request_handler(Some(Arc::new(StaticContentServer::new_str(
        format!(
            r#"{{"issuer": "{}", "jwks_uri": "{}"}}"#,
            alice_issuer_id,
            alice_jwks_server.url()
        )
        .as_str(),
    ))));
    bob_config_server.update_request_handler(Some(Arc::new(StaticContentServer::new_str(
        format!(
            r#"{{"issuer": "{}", "jwks_uri": "{}"}}"#,
            bob_issuer_id,
            bob_jwks_server.url()
        )
        .as_str(),
    ))));

    alice_jwks_server.update_request_handler(Some(Arc::new(EquivocatingServer::new(
        r#"{"keys": ["ALICE_JWK_V1A"]}"#.as_bytes().to_vec(),
        r#"{"keys": ["ALICE_JWK_V1B"]}"#.as_bytes().to_vec(),
        2,
    ))));
```
