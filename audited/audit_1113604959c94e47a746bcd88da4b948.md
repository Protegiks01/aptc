# Audit Report

## Title
Denial of Service via Unauthenticated Byzantine Epoch Advertisement in State Sync Bootstrapper

## Summary
Byzantine peers can advertise fake, non-existent epoch ending ledger infos in their storage summaries, causing bootstrapping nodes to waste resources attempting to fetch data that doesn't exist. This creates an infinite retry loop that prevents nodes from completing the bootstrap process and joining the network.

## Finding Description

The vulnerability exists in the state sync bootstrapping flow where nodes fetch epoch ending ledger infos from the network. The attack exploits a lack of cryptographic verification of advertised data before stream creation:

1. **Unauthenticated Advertisement Aggregation**: The global data summary aggregates epoch ranges from all connected peers without verification. [1](#0-0) 

2. **Maximum Epoch Selection**: The system selects the maximum advertised epoch across all peers, allowing a single Byzantine peer to influence the target. [2](#0-1) 

3. **Unverified Stream Creation**: The bootstrapper creates a stream to fetch epochs from `next_epoch_end` to the advertised maximum without verifying these epochs exist. [3](#0-2) 

4. **Stream Engine Trust**: The stream engine uses advertised data to set the target epoch without verification. [4](#0-3) 

**Attack Scenario:**
- Honest network is at epoch 10
- Byzantine peer advertises epoch range (0, 1000) in their `StorageServerSummary`
- Node calculates `highest_advertised_epoch_end = 1000`
- Node creates stream to fetch epochs 11-1000
- All requests fail (epochs 11-1000 don't exist)
- Stream retries each request up to 5 times [5](#0-4) 
- After failures, stream terminates but `fetched_epoch_ending_ledger_infos` flag remains false [6](#0-5) 
- Bootstrapper loops back and repeats indefinitely [7](#0-6) 

Cryptographic verification only occurs AFTER data is fetched, in `process_epoch_ending_payload()`. [8](#0-7) [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria:

- **Validator node slowdowns**: Bootstrapping nodes (both validators and fullnodes) experience complete inability to join the network, which is more severe than a slowdown.
- **Significant protocol violations**: The protocol assumption that nodes can reliably bootstrap from the network is violated.
- **Liveness Failure**: Affected nodes cannot participate in consensus or serve data, representing a total loss of node liveness.
- **Resource Exhaustion**: Nodes waste CPU, memory, and bandwidth repeatedly requesting non-existent data.

The impact affects:
- New validators attempting to join the network
- Existing nodes recovering from failures
- Fullnodes syncing from genesis or after being offline
- Any node in bootstrapping mode

## Likelihood Explanation

The attack is **highly likely** to occur:

**Attacker Requirements:**
- Minimal: Only requires peer connectivity to the target node
- No validator status, stake, or cryptographic keys needed
- Low computational cost (just advertise fake storage summaries)

**Attack Complexity:**
- Low: The attacker simply advertises a `StorageServerSummary` with a fake epoch range
- No need to forge signatures or break cryptographic primitives
- Can be executed by any malicious peer

**Defenses:**
- Peer scoring provides partial mitigation but not prevention
- Byzantine peer's score drops after failures, but damage occurs before score drops below threshold
- Multiple Byzantine peers or peer rotation can sustain the attack
- No authentication or verification of advertised data before use

## Recommendation

Implement cryptographic verification of advertised epoch data before creating data streams:

```rust
// In fetch_epoch_ending_ledger_infos() after line 829:
// Verify the advertised epoch is reasonable by checking if we can verify 
// a path from our current epoch to the advertised epoch
let highest_advertised_epoch_end = global_data_summary
    .advertised_data
    .highest_epoch_ending_ledger_info()
    .ok_or_else(|| {
        Error::AdvertisedDataError(
            "No highest advertised epoch end found in the network!".into(),
        )
    })?;

// Add safety bound: Don't trust advertised epochs too far ahead
let max_epochs_ahead = self.driver_configuration.config.max_epochs_ahead_for_bootstrap;
let highest_safe_epoch = highest_local_epoch_end
    .checked_add(max_epochs_ahead)
    .unwrap_or(highest_local_epoch_end);

let target_epoch_end = std::cmp::min(highest_advertised_epoch_end, highest_safe_epoch);

// If we're limiting the target, log a warning
if target_epoch_end < highest_advertised_epoch_end {
    warn!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
        "Limiting epoch fetch target from {} to {} for safety",
        highest_advertised_epoch_end, target_epoch_end
    )));
}
```

Additionally:
1. Add a configuration parameter `max_epochs_ahead_for_bootstrap` (e.g., 100 epochs)
2. Implement proof-of-existence checks: require peers to provide at least one signed epoch ending ledger info as proof before trusting their advertised ranges
3. Add circuit breaker: if stream creation fails repeatedly with the same advertised data, temporarily ignore those advertisements

## Proof of Concept

```rust
// Reproduction steps for testing:

// 1. Setup a bootstrapping node at epoch 10
// 2. Configure a malicious peer that advertises fake storage summary:

use aptos_storage_service_types::responses::{
    CompleteDataRange, DataSummary, ProtocolMetadata, StorageServerSummary,
};

// Malicious peer sends this to the bootstrapping node:
let fake_storage_summary = StorageServerSummary {
    protocol_metadata: ProtocolMetadata::default(),
    data_summary: DataSummary {
        epoch_ending_ledger_infos: Some(CompleteDataRange::new(0, 1000)), // FAKE!
        synced_ledger_info: None,
        states: None,
        transactions: None,
        transaction_outputs: None,
    },
};

// 3. The bootstrapping node will:
//    - Aggregate this into global_data_summary
//    - Calculate highest_epoch_ending_ledger_info() = 1000
//    - Create stream for epochs 11-1000
//    - Waste resources trying to fetch non-existent epochs 11-1000
//    - Retry 5 times per epoch
//    - Never complete bootstrapping

// Expected behavior: Node should either:
// - Reject advertisements without proof
// - Limit target epoch to reasonable bounds
// - Verify advertised data before use
```

To observe this in a test environment:
1. Start a network with honest nodes at epoch 10
2. Start a bootstrapping node that needs to sync from epoch 0
3. Connect a malicious peer that advertises epochs 0-1000
4. Monitor the bootstrapping node's logs showing repeated failed requests for epochs 11-1000
5. Observe the node never completes bootstrapping due to the infinite retry loop

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L339-408)
```rust
    pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();

        // If we have no peers, return an empty global summary
        if storage_summaries.is_empty() {
            return GlobalDataSummary::empty();
        }

        // Calculate the global data summary using the advertised peer data
        let mut advertised_data = AdvertisedData::empty();
        let mut max_epoch_chunk_sizes = vec![];
        let mut max_state_chunk_sizes = vec![];
        let mut max_transaction_chunk_sizes = vec![];
        let mut max_transaction_output_chunk_sizes = vec![];
        for summary in storage_summaries {
            // Collect aggregate data advertisements
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
            }
            if let Some(states) = summary.data_summary.states {
                advertised_data.states.push(states);
            }
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
            if let Some(transactions) = summary.data_summary.transactions {
                advertised_data.transactions.push(transactions);
            }
            if let Some(transaction_outputs) = summary.data_summary.transaction_outputs {
                advertised_data
                    .transaction_outputs
                    .push(transaction_outputs);
            }

            // Collect preferred max chunk sizes
            max_epoch_chunk_sizes.push(summary.protocol_metadata.max_epoch_chunk_size);
            max_state_chunk_sizes.push(summary.protocol_metadata.max_state_chunk_size);
            max_transaction_chunk_sizes.push(summary.protocol_metadata.max_transaction_chunk_size);
            max_transaction_output_chunk_sizes
                .push(summary.protocol_metadata.max_transaction_output_chunk_size);
        }

        // Calculate optimal chunk sizes based on the advertised data
        let optimal_chunk_sizes = calculate_optimal_chunk_sizes(
            &self.data_client_config,
            max_epoch_chunk_sizes,
            max_state_chunk_sizes,
            max_transaction_chunk_sizes,
            max_transaction_output_chunk_sizes,
        );
        GlobalDataSummary {
            advertised_data,
            optimal_chunk_sizes,
        }
    }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L176-181)
```rust
    pub fn highest_epoch_ending_ledger_info(&self) -> Option<Epoch> {
        self.epoch_ending_ledger_infos
            .iter()
            .map(|epoch_range| epoch_range.highest())
            .max()
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L98-129)
```rust
    pub fn update_verified_epoch_states(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;

        // Update the latest epoch state with the next epoch
        if let Some(next_epoch_state) = epoch_ending_ledger_info.ledger_info().next_epoch_state() {
            self.highest_fetched_epoch_ending_version =
                epoch_ending_ledger_info.ledger_info().version();
            self.latest_epoch_state = next_epoch_state.clone();
            self.insert_new_epoch_ending_ledger_info(epoch_ending_ledger_info.clone())?;

            trace!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Updated the latest epoch state to epoch: {:?}",
                self.latest_epoch_state.epoch
            )));
        } else {
            return Err(Error::VerificationError(
                "The ledger info was not epoch ending!".into(),
            ));
        }

        // Check if the ledger info corresponds to the trusted waypoint
        self.verify_waypoint(epoch_ending_ledger_info, waypoint)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L413-441)
```rust
    /// Checks if the bootstrapper is able to make progress
    pub async fn drive_progress(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        if self.is_bootstrapped() {
            return Err(Error::AlreadyBootstrapped(
                "The bootstrapper should not attempt to make progress!".into(),
            ));
        }

        if self.active_data_stream.is_some() {
            // We have an active data stream. Process any notifications!
            self.process_active_stream_notifications().await?;
        } else if self.storage_synchronizer.pending_storage_data() {
            // Wait for any pending data to be processed
            sample!(
                SampleRate::Duration(Duration::from_secs(PENDING_DATA_LOG_FREQ_SECS)),
                info!("Waiting for the storage synchronizer to handle pending data!")
            );
        } else {
            // Fetch a new data stream to start streaming data
            self.initialize_active_data_stream(global_data_summary)
                .await?;
        }

        // Check if we've now bootstrapped
        self.notify_listeners_if_bootstrapped().await
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L443-450)
```rust
    /// Returns true iff the bootstrapper should continue to fetch epoch ending
    /// ledger infos (in order to make progress).
    fn should_fetch_epoch_ending_ledger_infos(&self) -> bool {
        !self
            .verified_epoch_states
            .fetched_epoch_ending_ledger_infos()
            || !self.verified_epoch_states.verified_waypoint()
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L848-860)
```rust
        if highest_local_epoch_end < highest_advertised_epoch_end {
            info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Found higher epoch ending ledger infos in the network! Local: {:?}, advertised: {:?}",
                   highest_local_epoch_end, highest_advertised_epoch_end
            )));
            let next_epoch_end = highest_local_epoch_end.checked_add(1).ok_or_else(|| {
                Error::IntegerOverflow("The next epoch end has overflown!".into())
            })?;
            let epoch_ending_stream = self
                .streaming_client
                .get_all_epoch_ending_ledger_infos(next_epoch_end)
                .await?;
            self.active_data_stream = Some(epoch_ending_stream);
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1062-1112)
```rust
    /// Process a single epoch ending payload
    async fn process_epoch_ending_payload(
        &mut self,
        notification_id: NotificationId,
        epoch_ending_ledger_infos: Vec<LedgerInfoWithSignatures>,
    ) -> Result<(), Error> {
        // Verify that we're expecting epoch ending ledger info payloads
        if !self.should_fetch_epoch_ending_ledger_infos() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::InvalidPayloadData,
            )))
            .await?;
            return Err(Error::InvalidPayload(
                "Received an unexpected epoch ending payload!".into(),
            ));
        }

        // Verify the payload isn't empty
        if epoch_ending_ledger_infos.is_empty() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(
                "The epoch ending payload was empty!".into(),
            ));
        }

        // Verify the epoch change proofs, update our latest epoch state and
        // verify our waypoint.
        for epoch_ending_ledger_info in epoch_ending_ledger_infos {
            if let Err(error) = self.verified_epoch_states.update_verified_epoch_states(
                &epoch_ending_ledger_info,
                &self.driver_configuration.waypoint,
            ) {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
        }

        // TODO(joshlind): do we want to preemptively notify certain components
        // of the new reconfigurations?

        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1482-1518)
```rust
impl EpochEndingStreamEngine {
    fn new(
        request: &GetAllEpochEndingLedgerInfosRequest,
        advertised_data: &AdvertisedData,
    ) -> Result<Self, Error> {
        let end_epoch = advertised_data
            .highest_epoch_ending_ledger_info()
            .ok_or_else(|| {
                Error::DataIsUnavailable(format!(
                    "Unable to find any epoch ending ledger info in the network: {:?}",
                    advertised_data
                ))
            })?;

        if end_epoch < request.start_epoch {
            return Err(Error::DataIsUnavailable(format!(
                "The epoch to start syncing from is higher than the highest epoch ending ledger info! Highest: {:?}, start: {:?}",
                end_epoch, request.start_epoch
            )));
        }
        info!(
            (LogSchema::new(LogEntry::ReceivedDataResponse)
                .event(LogEvent::Success)
                .message(&format!(
                    "Setting the highest epoch ending ledger info for the stream at: {:?}",
                    end_epoch
                )))
        );

        Ok(EpochEndingStreamEngine {
            request: request.clone(),
            end_epoch,
            next_stream_epoch: request.start_epoch,
            next_request_epoch: request.start_epoch,
            stream_is_complete: false,
        })
    }
```

**File:** config/src/config/state_sync_config.rs (L254-277)
```rust
    /// Maximum number of retries for a single client request before a data
    /// stream will terminate.
    pub max_request_retry: u64,

    /// Maximum lag (in seconds) we'll tolerate when sending subscription requests
    pub max_subscription_stream_lag_secs: u64,

    /// The interval (milliseconds) at which to check the progress of each stream.
    pub progress_check_interval_ms: u64,
}

impl Default for DataStreamingServiceConfig {
    fn default() -> Self {
        Self {
            dynamic_prefetching: DynamicPrefetchingConfig::default(),
            enable_subscription_streaming: false,
            global_summary_refresh_interval_ms: 50,
            max_concurrent_requests: MAX_CONCURRENT_REQUESTS,
            max_concurrent_state_requests: MAX_CONCURRENT_STATE_REQUESTS,
            max_data_stream_channel_sizes: 50,
            max_notification_id_mappings: 300,
            max_num_consecutive_subscriptions: 45, // At ~3 blocks per second, this should last ~15 seconds
            max_pending_requests: 50,
            max_request_retry: 5,
```

**File:** types/src/epoch_state.rs (L40-59)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }

    fn epoch_change_verification_required(&self, epoch: u64) -> bool {
        self.epoch < epoch
    }

    fn is_ledger_info_stale(&self, ledger_info: &LedgerInfo) -> bool {
        ledger_info.epoch() < self.epoch
    }
}
```
