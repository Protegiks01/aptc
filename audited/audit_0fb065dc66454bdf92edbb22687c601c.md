# Audit Report

## Title
Unauthenticated Cross-Shard Message Injection Enables Premature Receiver Termination and Validator Liveness Failure

## Summary
The sharded block executor's cross-shard messaging system lacks sender authentication and message type validation. An attacker controlling one shard or with network access can send a malicious `StopMsg` to another shard's receiver, causing premature termination before all cross-shard dependencies are received. This results in the executor thread hanging indefinitely while waiting for state updates that will never arrive, leading to validator node unavailability and consensus liveness issues.

## Finding Description

The `CrossShardMsg` enum defines two variants for inter-shard communication: [1](#0-0) 

The `CrossShardCommitReceiver` runs in a loop receiving these messages and processes them without validating the sender or message context: [2](#0-1) 

The receiver immediately terminates when it receives a `StopMsg`, which is intended to be sent only by the shard to itself after execution completes: [3](#0-2) 

However, in remote execution mode, messages are transmitted over an unauthenticated network using BCS serialization: [4](#0-3) 

The GRPC network layer uses plain HTTP without authentication or sender validation: [5](#0-4) 

**Attack Path:**

1. Attacker controls a malicious shard process or can inject network traffic between shards
2. Attacker serializes a `CrossShardMsg::StopMsg` using BCS and sends it to victim shard's network endpoint
3. Victim shard's `CrossShardCommitReceiver` deserializes the message and matches on `StopMsg`, breaking from the loop
4. The receiver thread terminates prematurely before receiving all expected `RemoteTxnWriteMsg` messages
5. Meanwhile, the executor thread is blocked waiting for cross-shard dependencies via `RemoteStateValue::get_value()`: [6](#0-5) 

6. Since the receiver is dead, the condition variable never gets signaled, causing indefinite blocking
7. The validator node becomes unresponsive, unable to complete block execution

This breaks the **Deterministic Execution** invariant (all validators must produce identical outputs) and the **validator availability** guarantee.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos bug bounty)

This vulnerability causes:
- **Validator node slowdowns/unavailability**: The affected shard's execution hangs indefinitely, preventing the validator from participating in consensus
- **Liveness impact**: If multiple validators experience this attack, consensus could stall
- **Protocol violation**: Validators fail to produce block outputs, violating execution guarantees

While this doesn't directly cause loss of funds or consensus safety violations (which would be Critical), it significantly impacts network availability and validator operations, meeting the High severity criteria for "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**Likelihood: Medium-High** in distributed execution deployments

**Attack Requirements:**
- Sharded block execution deployed in remote/distributed mode (not local in-process mode)
- Either: (a) network access to inter-shard communication channels, OR (b) compromise of one shard process
- Knowledge of the target shard's network address and round ID
- Ability to craft BCS-serialized messages

**Complexity: Low**
- Simple message serialization and network injection
- No cryptographic bypasses required
- Deterministic effect (receiver always stops on StopMsg)

The vulnerability is exploitable in any distributed sharded execution deployment where network traffic between shards is not properly isolated or authenticated. Given that the network layer uses plain HTTP without TLS or authentication, this is a realistic threat in production environments.

## Recommendation

Implement multi-layered defenses:

**1. Message Authentication**: Add cryptographic signatures to cross-shard messages
```rust
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    StopMsg,
}

// Add authenticated wrapper
pub struct AuthenticatedCrossShardMsg {
    msg: CrossShardMsg,
    sender_shard_id: ShardId,
    signature: Signature,
}
```

**2. Sender Validation**: Verify that StopMsg only comes from the shard itself
```rust
impl CrossShardCommitReceiver {
    pub fn start<S: StateView + Sync + Send>(
        own_shard_id: ShardId,  // Add this parameter
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let (msg, sender_shard_id) = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => { /* process */ },
                CrossShardMsg::StopMsg => {
                    // Validate sender
                    if sender_shard_id != own_shard_id {
                        warn!("Ignoring StopMsg from shard {}", sender_shard_id);
                        continue;
                    }
                    break;
                },
            }
        }
    }
}
```

**3. TLS/Mutual Authentication**: Use HTTPS with mutual TLS for inter-shard communication
```rust
// In grpc_network_service/mod.rs
async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
    let tls_config = ClientTlsConfig::new()
        .ca_certificate(Certificate::from_pem(CA_CERT))
        .identity(Identity::from_pem(CLIENT_CERT, CLIENT_KEY));
    
    let conn = tonic::transport::Endpoint::new(remote_addr)
        .unwrap()
        .tls_config(tls_config)
        .unwrap()
        .connect_lazy();
    NetworkMessageServiceClient::new(conn)
}
```

**4. Expected Message Tracking**: Track expected cross-shard dependencies and only accept StopMsg after all are received

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
#[test]
fn test_premature_stopmsg_causes_hang() {
    use std::sync::Arc;
    use std::thread;
    use std::time::Duration;
    
    // Setup: Create a shard with expected cross-shard dependency
    let state_key = StateKey::raw(b"test_key");
    let mut cross_shard_keys = HashSet::new();
    cross_shard_keys.insert(state_key.clone());
    
    let cross_shard_state_view = Arc::new(
        CrossShardStateView::new(cross_shard_keys, &EmptyStateView)
    );
    
    let (cross_shard_tx, cross_shard_rx) = unbounded();
    let cross_shard_client = Arc::new(TestCrossShardClient::new(
        cross_shard_tx.clone(),
        cross_shard_rx,
    ));
    
    let state_view_clone = cross_shard_state_view.clone();
    let client_clone = cross_shard_client.clone();
    
    // Start receiver thread
    let receiver_handle = thread::spawn(move || {
        CrossShardCommitReceiver::start(
            state_view_clone,
            client_clone,
            0, // round 0
        );
    });
    
    // Executor thread tries to read cross-shard value
    let executor_handle = thread::spawn(move || {
        // This will block indefinitely
        let value = cross_shard_state_view.get_state_value(&state_key);
        value
    });
    
    // ATTACK: Send premature StopMsg before sending the expected data
    thread::sleep(Duration::from_millis(100));
    cross_shard_tx.send(CrossShardMsg::StopMsg).unwrap();
    
    // Receiver stops immediately
    receiver_handle.join().unwrap();
    
    // Executor is now permanently blocked - this will timeout
    let result = thread::Builder::new()
        .spawn(move || {
            executor_handle.join().unwrap()
        })
        .unwrap()
        .join_timeout(Duration::from_secs(2));
    
    // Assertion: executor thread should hang
    assert!(result.is_err(), "Executor should be blocked waiting for cross-shard data");
}
```

## Notes

This vulnerability specifically affects the **remote/distributed sharded execution mode** where shards communicate over a network. The local in-process mode using channels is not directly vulnerable since it doesn't involve network deserialization, though logical issues could still occur if one shard maliciously sends StopMsg to another.

The root causes are:
1. Lack of message authentication in the network layer
2. Missing sender validation in the message processing logic
3. No tracking of expected messages before accepting termination signals
4. Absence of TLS/encryption for inter-shard communication

The fix requires both network-level security (TLS, authentication) and application-level validation (sender checks, message sequencing).

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L7-11)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    StopMsg,
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L163-168)
```rust
                    // Send a self message to stop the cross-shard commit receiver.
                    cross_shard_client_clone.send_cross_shard_msg(
                        shard_id,
                        round,
                        CrossShardMsg::StopMsg,
                    );
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-66)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L91-115)
```rust
#[tonic::async_trait]
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```
