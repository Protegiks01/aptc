# Audit Report

## Title
Infinite Loop DoS in Indexer Data Service Cache Eviction Due to Missing Termination Guarantee

## Summary
The eviction loop in `DataManager::update_data()` lacks a termination guarantee and can run indefinitely if size accounting becomes inconsistent, causing a denial-of-service on the indexer-grpc-data-service-v2.

## Finding Description

The cache eviction logic in the indexer data service contains a while loop that attempts to reduce `total_size` below `eviction_target` by removing old transactions. However, this loop has no bounds on the number of iterations and no check for whether all available slots have been processed. [1](#0-0) 

The critical issue is at line 115: `self.start_version += 1` executes unconditionally on every iteration, even when the slot at `self.data[self.start_version as usize % self.num_slots]` is `None`. This means:

1. Once all slots have been evicted (all become `None`), the loop continues incrementing `start_version`
2. The `if let Some(transaction)` block at lines 109-114 never executes, so `total_size` is never decremented
3. If `total_size >= eviction_target` remains true, the loop continues forever

This can occur if size accounting becomes inconsistent through:
- **Integer underflow in release mode**: If `size_decreased > total_size` at line 105, the subtraction wraps to a very large value (`usize::MAX - (size_decreased - total_size)`), making it impossible to evict enough to reach the target
- **Accumulated rounding errors** or **protobuf encoding inconsistencies**: If `encoded_len()` returns slightly different values for the same transaction data across fetches
- **Race conditions**: Although the code uses `RwLock`, bugs in concurrent access patterns could corrupt accounting

The size accounting logic uses unchecked arithmetic: [2](#0-1) 

In Rust release builds, integer overflow and underflow wrap silently rather than panicking, allowing `total_size` to become corrupted without detection.

The transactions originate from blockchain data fetched via gRPC: [3](#0-2) [4](#0-3) 

When the infinite loop occurs, it blocks the write lock acquisition, preventing all future cache updates and causing the indexer service to become unresponsive.

## Impact Explanation

This vulnerability causes **API service unavailability**, qualifying as **High Severity** under the Aptos bug bounty criteria ("API crashes" - up to $50,000). 

The indexer-grpc-data-service-v2 is a critical infrastructure component that serves transaction data to indexers, wallets, and applications. When the infinite loop blocks `update_data()`, the entire service hangs because:

1. The write lock on `DataManager` is held indefinitely
2. All subsequent `fetch_and_update_cache` calls block waiting for the lock
3. The service cannot process new transactions or serve queries effectively

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The eviction operation consumes unbounded CPU time.

While this doesn't affect consensus (the indexer is separate from validator nodes), it severely degrades ecosystem functionality for users relying on transaction history and query services.

## Likelihood Explanation

The likelihood is **Medium** because it requires size accounting to become corrupted, which could occur through:

1. **Software bugs**: Edge cases in the accounting logic that aren't immediately apparent
2. **Concurrent access bugs**: Despite RwLock protection, subtle race conditions in the larger system
3. **Integer overflow** (low probability): On 64-bit systems, requires processing exabytes of data
4. **Protobuf encoding variations**: Different `encoded_len()` values for semantically identical transactions

Once accounting corruption occurs, the infinite loop is guaranteed due to the missing termination check.

## Recommendation

Add defensive termination guarantees to the eviction loop:

```rust
if self.total_size >= self.size_limit_bytes {
    let max_evictions = self.num_slots * 2; // Allow checking all slots twice
    let mut eviction_count = 0;
    
    while self.total_size >= self.eviction_target {
        // Termination guarantee: prevent infinite loop
        if eviction_count >= max_evictions {
            error!(
                "Eviction loop exceeded maximum iterations. total_size: {}, eviction_target: {}, start_version: {}, end_version: {}",
                self.total_size, self.eviction_target, self.start_version, self.end_version
            );
            // Force reset accounting to prevent infinite hang
            self.total_size = self.data.iter()
                .filter_map(|slot| slot.as_ref())
                .map(|txn| txn.encoded_len())
                .sum();
            break;
        }
        
        // Also check if we've gone past all valid data
        if self.start_version >= self.end_version + self.num_slots as u64 {
            warn!("Eviction exhausted all slots but total_size still high. Recalculating...");
            self.total_size = self.data.iter()
                .filter_map(|slot| slot.as_ref())
                .map(|txn| txn.encoded_len())
                .sum();
            break;
        }
        
        if let Some(transaction) =
            self.data[self.start_version as usize % self.num_slots].take()
        {
            self.total_size = self.total_size.saturating_sub(transaction.encoded_len());
            drop(transaction);
        }
        self.start_version += 1;
        eviction_count += 1;
    }
}
```

Additionally, use checked or saturating arithmetic for size accounting:

```rust
self.total_size = self.total_size.saturating_add(size_increased);
self.total_size = self.total_size.saturating_sub(size_decreased);
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_eviction_loop_termination_with_broken_accounting() {
        let mut dm = DataManager::new(100, 10, 1000);
        
        // Simulate broken accounting: set total_size artificially high
        dm.total_size = 10000;
        dm.eviction_target = 1000;
        
        // Insert a few small transactions
        let small_txn = Transaction {
            version: 95,
            ..Default::default()
        };
        
        let transactions = vec![small_txn; 5];
        
        // This should not hang with the fix, but would hang without it
        let start = std::time::Instant::now();
        dm.update_data(95, transactions);
        let elapsed = start.elapsed();
        
        // Should complete within reasonable time (< 1 second)
        assert!(elapsed.as_secs() < 1, "Eviction loop took too long: {:?}", elapsed);
        
        // Accounting should be corrected
        assert!(dm.total_size < 10000, "total_size should be recalculated");
    }
}
```

## Notes

While the indexer-grpc service is not part of the critical consensus path, it represents essential infrastructure for the Aptos ecosystem. The lack of termination guarantees in the eviction loop is a defensive programming failure that could lead to production outages. The fix is straightforward and adds minimal overhead while providing critical reliability guarantees.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L104-105)
```rust
        self.total_size += size_increased;
        self.total_size -= size_decreased;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L107-117)
```rust
        if self.total_size >= self.size_limit_bytes {
            while self.total_size >= self.eviction_target {
                if let Some(transaction) =
                    self.data[self.start_version as usize % self.num_slots].take()
                {
                    self.total_size -= transaction.encoded_len();
                    drop(transaction);
                }
                self.start_version += 1;
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_client.rs (L18-43)
```rust
    pub(super) async fn fetch_transactions(&self, starting_version: u64) -> Vec<Transaction> {
        trace!("Fetching transactions from GrpcManager, start_version: {starting_version}.");

        let request = GetTransactionsRequest {
            starting_version: Some(starting_version),
            transactions_count: None,
            batch_size: None,
            transaction_filter: None,
        };
        loop {
            let mut client = self
                .connection_manager
                .get_grpc_manager_client_for_request();
            let response = client.get_transactions(request.clone()).await;
            if let Ok(response) = response {
                let transactions = response.into_inner().transactions;
                if transactions.is_empty() {
                    return vec![];
                }
                if transactions.first().unwrap().version == starting_version {
                    return transactions;
                }
            }
            // TODO(grao): Error handling.
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/fetch_manager.rs (L48-64)
```rust
    async fn fetch_and_update_cache(
        data_client: Arc<DataClient>,
        data_manager: Arc<RwLock<DataManager>>,
        version: u64,
    ) -> usize {
        let transactions = data_client.fetch_transactions(version).await;
        let len = transactions.len();

        if len > 0 {
            data_manager
                .write()
                .await
                .update_data(version, transactions);
        }

        len
    }
```
