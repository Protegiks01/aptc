# Audit Report

## Title
Eclipse Attack Enables Indefinite Validator Liveness Failure Through DataIsUnavailable Error Handling

## Summary
When a validator is eclipsed and all its connected peers repeatedly return `DataIsUnavailable` errors, the error handling logic causes the validator to enter an indefinite non-syncing state, resulting in complete loss of liveness. While the validator cannot be made to accept an invalid forked chain due to cryptographic protections, it becomes permanently unable to sync or participate in consensus.

## Finding Description

The vulnerability exists in the interaction between the data streaming service's retry logic and the state sync driver's handling of empty global data summaries.

**Attack Flow:**

1. **Eclipse Setup**: Attacker controls all peers connected to the victim validator [1](#0-0) 

2. **Repeated Failures**: All peers return `DataIsUnavailable` errors when the validator requests transaction data [2](#0-1) 

3. **Stream Termination**: After reaching `max_request_retry` (default 5), the stream terminates with `EndOfStream` [3](#0-2) 

4. **Peer Banning**: Repeated failures cause peers to be banned/ignored, eventually making the global data summary empty [1](#0-0) 

5. **Sync Halt**: With an empty global data summary, the driver returns early without invoking the bootstrapper, effectively stopping all sync attempts [4](#0-3) 

6. **Indefinite Loop**: The validator loops in `drive_progress()` doing nothing, never attempting to sync, and cannot participate in consensus

The validator does NOT give up permanently in the sense of crashing, but it stops making any sync attempts. Errors from failed bootstrapping are only logged and counted, not propagated: [5](#0-4) 

**Why Forked Chain Cannot Be Fed:**

Even if the attacker later provides advertised data to resume syncing, the validator still enforces:
- BLS signature verification on epoch ending ledger infos [6](#0-5) 
- Waypoint verification during bootstrapping [7](#0-6) 

These cryptographic protections prevent accepting an invalid forked chain without >2/3 validator stake.

## Impact Explanation

**Critical Severity** - Total Loss of Liveness/Network Availability

Per Aptos bug bounty criteria, this qualifies as Critical severity because:
1. The validator becomes completely non-functional and cannot participate in consensus
2. The attack causes indefinite liveness failure requiring manual intervention
3. Multiple validators could be targeted simultaneously, affecting network health
4. The validator remains stuck until honest peers connect or manual recovery occurs

While the validator cannot be made to accept an invalid fork (safety is preserved), it suffers complete liveness failure, which is explicitly listed as a Critical severity impact.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attacker Requirements**: Must eclipse the victim validator by controlling all its peer connections
- **Attack Complexity**: Moderate - requires network positioning but exploits standard peer behavior
- **Detection Difficulty**: Low - appears as normal peer failures, difficult to distinguish from legitimate network issues
- **Persistence**: Attack persists indefinitely until honest peers connect
- **Scale**: Can target multiple validators simultaneously

Eclipse attacks on individual nodes are feasible for motivated attackers with network resources, especially against validators with limited peer diversity.

## Recommendation

Implement multiple layers of defense:

1. **Bounded Retry with Peer Discovery**: After N failed stream attempts with empty global data summary, trigger aggressive peer discovery or connection rotation
2. **Eclipse Detection**: Monitor for patterns indicating eclipse (all peers consistently failing)
3. **Fallback Mechanisms**: Allow validators to connect to seed nodes or bootstrap from trusted checkpoint services when stuck
4. **Alert System**: Emit critical alerts when a validator has made no sync progress for extended periods

**Example Code Fix** (in `driver.rs`):

```rust
// Track consecutive empty summary checks
consecutive_empty_summaries: u64,
const MAX_EMPTY_SUMMARIES_BEFORE_PEER_ROTATION: u64 = 100; // ~10 seconds at 100ms intervals

async fn drive_progress(&mut self) {
    let global_data_summary = self.aptos_data_client.get_global_data_summary();
    if global_data_summary.is_empty() {
        self.consecutive_empty_summaries += 1;
        
        if self.consecutive_empty_summaries >= MAX_EMPTY_SUMMARIES_BEFORE_PEER_ROTATION {
            // Trigger peer rotation / seed node connection
            warn!("Potential eclipse attack detected: {} consecutive empty summaries", 
                  self.consecutive_empty_summaries);
            // Force connection to seed nodes or rotate peer set
            self.attempt_emergency_peer_rotation().await;
            self.consecutive_empty_summaries = 0;
        }
        
        return self.check_auto_bootstrapping().await;
    }
    self.consecutive_empty_summaries = 0;
    // ... rest of function
}
```

## Proof of Concept

**Setup:**
1. Deploy a validator node V with network connections controlled by the attacker
2. Configure attacker to control all peer connections to V

**Attack Steps:**

```rust
// Attacker's malicious peer behavior:
impl MockMaliciousPeer {
    async fn handle_storage_request(&self, request: StorageServiceRequest) -> Result<StorageServiceResponse> {
        // Always return errors to trigger DataIsUnavailable
        Err(StorageServiceError::InternalError("Data unavailable".to_string()))
    }
}

// Expected behavior on victim validator:
// 1. Stream attempts to fetch data from peers
// 2. All peers return errors
// 3. After 5 retries (max_request_retry), stream terminates with EndOfStream
// 4. Bootstrapper resets and creates new stream
// 5. Cycle repeats, but peers get banned
// 6. Eventually global_data_summary becomes empty
// 7. Validator stops attempting to sync
// 8. Validator cannot participate in consensus
// 9. Validator remains stuck indefinitely
```

**Verification:**
- Monitor validator metrics: `BOOTSTRAPPER_ERRORS` counter keeps incrementing
- Check logs: Repeated "Error found when checking the bootstrapper progress" warnings
- Observe: Validator's synced version stops advancing
- Confirm: Validator does not participate in consensus rounds

This demonstrates a complete liveness failure exploiting the `DataIsUnavailable` error handling under eclipse attack conditions.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L340-355)
```rust
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();

        // If we have no peers, return an empty global summary
        if storage_summaries.is_empty() {
            return GlobalDataSummary::empty();
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L697-701)
```rust
        // Otherwise, all requests failed and we should return an error
        Err(Error::DataIsUnavailable(format!(
            "All {} attempts failed for the given request: {:?}. Errors: {:?}",
            num_sent_requests, request, sent_request_errors
        )))
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L446-454)
```rust
        if self.stream_engine.is_stream_complete()
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L671-678)
```rust
        // Fetch the global data summary and verify we have active peers
        let global_data_summary = self.aptos_data_client.get_global_data_summary();
        if global_data_summary.is_empty() {
            trace!(LogSchema::new(LogEntry::Driver).message(
                "The global data summary is empty! It's likely that we have no active peers."
            ));
            return self.check_auto_bootstrapping().await;
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L711-719)
```rust
        } else if let Err(error) = self.bootstrapper.drive_progress(&global_data_summary).await {
            sample!(
                    SampleRate::Duration(Duration::from_secs(DRIVER_ERROR_LOG_FREQ_SECS)),
                    warn!(LogSchema::new(LogEntry::Driver)
                        .error(&error)
                        .message("Error found when checking the bootstrapper progress!"));
            );
            metrics::increment_counter(&metrics::BOOTSTRAPPER_ERRORS, error.get_label());
        };
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L98-129)
```rust
    pub fn update_verified_epoch_states(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;

        // Update the latest epoch state with the next epoch
        if let Some(next_epoch_state) = epoch_ending_ledger_info.ledger_info().next_epoch_state() {
            self.highest_fetched_epoch_ending_version =
                epoch_ending_ledger_info.ledger_info().version();
            self.latest_epoch_state = next_epoch_state.clone();
            self.insert_new_epoch_ending_ledger_info(epoch_ending_ledger_info.clone())?;

            trace!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Updated the latest epoch state to epoch: {:?}",
                self.latest_epoch_state.epoch
            )));
        } else {
            return Err(Error::VerificationError(
                "The ledger info was not epoch ending!".into(),
            ));
        }

        // Check if the ledger info corresponds to the trusted waypoint
        self.verify_waypoint(epoch_ending_ledger_info, waypoint)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L878-915)
```rust
    /// Verifies that connected peers have advertised data beyond our waypoint
    /// or that our waypoint is trivially satisfiable.
    fn verify_waypoint_is_satisfiable(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }

        // Get the highest advertised synced ledger info version
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();

        // Compare the highest advertised version with our waypoint
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
    }
```
