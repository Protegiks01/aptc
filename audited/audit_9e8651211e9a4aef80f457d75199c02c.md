# Audit Report

## Title
Missing Event Key Validation in Event Lookup Enables Silent Data Corruption

## Summary
The `lookup_event_at_or_after_version()` function validates the event key in the index entry but fails to validate that the actual event retrieved from storage matches the requested event key. If the EventByVersionSchema index value is corrupted, queries can return events from wrong event streams without detection.

## Finding Description

The vulnerability exists in the event lookup flow across multiple storage layers. [1](#0-0) 

The function queries EventByVersionSchema (which maps `(EventKey, Version, SeqNum) -> Index`) and validates that the returned key matches the requested event key. However, it never validates that the actual event fetched from EventSchema has the same event key.

The storage architecture uses separate schemas:
- EventByVersionSchema: Index pointing to events [2](#0-1) 
- EventSchema: Actual event data [3](#0-2) 

Consumer code only validates sequence numbers, not event keys: [4](#0-3) 

**Attack Scenario:**
1. Transaction at version 100 emits events at indices 0 and 1 with EventKeys A and B, both with sequence number 5
2. Index corruption changes `(EventKey A, 100, 5) -> 0` to `(EventKey A, 100, 5) -> 1`
3. Query for EventKey A returns EventKey B's event
4. Sequence validation passes (5 == 5)
5. Wrong event stream data is returned

## Impact Explanation

This breaks the **State Consistency** and **Deterministic Execution** invariants. If validators experience different database corruption patterns, they will return different events for the same queries, leading to:

- **State divergence**: Different validators compute different state roots
- **Consensus failure**: Validators cannot agree on block validity
- **Data integrity violation**: Critical operations using events (e.g., NewBlockEvent for block info) receive wrong data [5](#0-4) 

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention" criteria, as it would require manual database inspection and potentially node restarts to resolve divergence.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

The vulnerability requires database corruption to trigger, which can occur through:
- Hardware failures (bit flips, disk errors)  
- Power loss during writes
- RocksDB bugs (though rare)
- Storage media degradation

While direct attacker exploitation is not feasible without database access, the complete absence of validation means corruption goes **undetected and uncorrected**, allowing it to persist and spread through state sync or snapshots.

The write path uses atomic batches [6](#0-5) , making concurrent write corruption unlikely, but this doesn't prevent storage-level corruption.

## Recommendation

Add end-to-end event key validation after fetching events:

```rust
pub fn get_event_by_key(
    &self,
    event_key: &EventKey,
    seq_num: u64,
    ledger_version: Version,
) -> Result<(Version, ContractEvent)> {
    let (version, index) = self.lookup_event_by_key(event_key, seq_num, ledger_version)?;
    let event = self.get_event_by_version_and_index(version, index)?;
    
    // ADD VALIDATION HERE
    if let Some(actual_key) = event.event_key() {
        ensure!(
            actual_key == event_key,
            "Event key mismatch: index corruption detected. Expected {:?}, got {:?}",
            event_key,
            actual_key
        );
    }
    
    Ok((version, event))
}
```

Apply similar validation in `get_events_by_event_key` and all event lookup paths. This enables early detection of corruption before it affects consensus.

## Proof of Concept

Cannot provide executable PoC as this requires inducing database corruption, which cannot be done through normal transaction submission or API calls. However, the vulnerability can be demonstrated through:

1. Direct database manipulation (requires test environment with DB access)
2. Fault injection testing with storage layer corruption
3. Manual corruption of RocksDB SST files followed by query execution

The lack of validation is evident from code inspection across all event lookup paths, where only sequence numbers are checked, never event keys.

---

## Notes

While this vulnerability is not directly exploitable by unprivileged attackers through the transaction submission interface, it represents a critical gap in data integrity validation. The security question specifically asks whether "database corruption or concurrent writes can cause wrong event streams to match" - the answer is **YES for corruption, NO for concurrent writes**. 

The missing validation violates defense-in-depth principles and means corruption, if it occurs, will propagate silently through the system until manifesting as consensus failures. For production blockchain systems, corruption detection at every layer is essential for maintaining network reliability.

### Citations

**File:** storage/aptosdb/src/event_store/mod.rs (L189-213)
```rust
    pub fn lookup_event_at_or_after_version(
        &self,
        event_key: &EventKey,
        version: Version,
    ) -> Result<
        Option<(
            Version, // version
            u64,     // index
            u64,     // sequence number
        )>,
    > {
        let mut iter = self.event_db.iter::<EventByVersionSchema>()?;
        iter.seek(&(*event_key, version, 0))?;

        match iter.next().transpose()? {
            None => Ok(None),
            Some(((key, ver, seq_num), idx)) => {
                if key == *event_key {
                    Ok(Some((ver, idx, seq_num)))
                } else {
                    Ok(None)
                }
            },
        }
    }
```

**File:** storage/indexer_schemas/src/schema/event_by_version/mod.rs (L23-29)
```rust
define_pub_schema!(EventByVersionSchema, Key, Value, EVENT_BY_VERSION_CF_NAME);

type SeqNum = u64;
type Key = (EventKey, Version, SeqNum);

type Index = u64;
type Value = Index;
```

**File:** storage/aptosdb/src/schema/event/mod.rs (L23-26)
```rust
define_schema!(EventSchema, Key, ContractEvent, EVENT_CF_NAME);

type Index = u64;
type Key = (Version, Index);
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L340-352)
```rust
                let (block_version, index, _seq_num) = self
                    .event_store
                    .lookup_event_at_or_after_version(&new_block_event_key(), min_version)?
                    .ok_or_else(|| {
                        AptosDbError::NotFound(format!(
                            "NewBlockEvent at or after version {}",
                            min_version
                        ))
                    })?;
                let event = self
                    .event_store
                    .get_event_by_version_and_index(block_version, index)?;
                return Ok((block_version, event.expect_new_block_event()?.height()));
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1156-1166)
```rust
                let event = self.event_store.get_event_by_version_and_index(ver, idx)?;
                let v0 = match &event {
                    ContractEvent::V1(event) => event,
                    ContractEvent::V2(_) => bail!("Unexpected module event"),
                };
                ensure!(
                    seq == v0.sequence_number(),
                    "Index broken, expected seq:{}, actual:{}",
                    seq,
                    v0.sequence_number()
                );
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L152-170)
```rust
        // Event table and indices updates
        events
            .iter()
            .enumerate()
            .try_for_each::<_, Result<_>>(|(idx, event)| {
                if let ContractEvent::V1(v1) = event {
                    if !skip_index {
                        batch.put::<EventByKeySchema>(
                            &(*v1.key(), v1.sequence_number()),
                            &(version, idx as u64),
                        )?;
                        batch.put::<EventByVersionSchema>(
                            &(*v1.key(), version, v1.sequence_number()),
                            &(idx as u64),
                        )?;
                    }
                }
                batch.put::<EventSchema>(&(version, idx as u64), event)
            })?;
```
