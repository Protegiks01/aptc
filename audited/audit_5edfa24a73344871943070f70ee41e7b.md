# Audit Report

## Title
Critical Node Crash Due to Uninitialized Weights HashMap in Secret Share Processing

## Summary
The `SecretShareConfig` initializes its `weights` HashMap as empty and never populates it, causing all validator nodes to panic when processing blocks with secret sharing enabled. This results in complete network liveness failure.

## Finding Description

The secret sharing system in Aptos consensus contains a critical initialization bug that causes deterministic node crashes. The vulnerability occurs in the interaction between `SecretShareConfig` and `SecretShareStore` when processing secret shares.

**Root Cause:**

The `SecretShareConfig` struct maintains a `weights: HashMap<Author, u64>` field that is initialized as empty in the constructor and never populated: [1](#0-0) 

This empty HashMap is then retrieved by `SecretShareStore::add_self_share()`: [2](#0-1) 

When `add_share_with_metadata()` is called, it attempts to look up the author's weight from this empty HashMap: [3](#0-2) 

**Execution Flow to Crash:**

1. Block processing begins with secret sharing enabled
2. Node computes its self-share asynchronously
3. `SecretShareStore::add_self_share()` is called with the computed share
4. The function retrieves `peer_weights` (empty HashMap) from config
5. `add_share_with_metadata()` is invoked
6. At line 162-164, code attempts: `share_weights.get(share.author()).expect("Author must exist in weights")`
7. HashMap lookup returns `None` (empty map)
8. `.expect()` triggers panic with message "Author must exist in weights"
9. **Node crashes**

Additionally, if any shares exist in the aggregator when transitioning states, the `retain()` function will also panic when attempting to recalculate weights from the empty HashMap: [4](#0-3) 

**Breaking Consensus Invariants:**

This vulnerability violates multiple critical invariants:
- **Total loss of liveness/network availability**: All validators crash deterministically
- **Deterministic Execution**: All nodes fail at the same point when processing blocks with secret sharing
- **Consensus Safety**: Network cannot make progress, no new blocks can be committed

## Impact Explanation

This is a **CRITICAL severity** vulnerability (up to $1,000,000 per Aptos Bug Bounty) because it causes:

**Total Loss of Liveness/Network Availability**: When secret sharing is enabled in the consensus protocol, every validator node will crash when attempting to process the first block requiring secret share aggregation. This results in complete network halt requiring emergency intervention.

**Non-recoverable without intervention**: The bug is deterministic - all nodes will crash at the same point. Recovery requires:
- Emergency hotfix deployment across all validators
- Coordinated network restart
- Potentially requires rolling back to a state before secret sharing activation

**Affects all validators**: Unlike targeted attacks affecting specific nodes, this bug crashes 100% of validator nodes deterministically when they process blocks with secret sharing enabled.

## Likelihood Explanation

**Likelihood: HIGH** (if secret sharing is enabled)

The vulnerability will trigger **automatically and deterministically** under these conditions:

1. **Secret sharing feature is enabled** in consensus configuration
2. **Any block requires secret share processing** (which happens for randomness generation)
3. **Node attempts to add its self-share** after computing it

No malicious actor is required - this is a latent implementation bug that activates as soon as the feature is used in production.

**Current Impact:**
- If secret sharing is currently disabled: Latent bug, no immediate impact
- If secret sharing is enabled: **Immediate network-wide crash**

The bug is **guaranteed to trigger** on every node processing blocks with secret sharing, making it extremely high likelihood once the feature is active.

## Recommendation

**Immediate Fix: Populate the weights HashMap during SecretShareConfig initialization**

The `SecretShareConfig::new()` constructor must populate the `weights` HashMap with actual validator weights from the `ValidatorVerifier`:

```rust
impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        // Populate weights HashMap from validator verifier
        let mut weights = HashMap::new();
        for (author, info) in validator.address_to_validator_info() {
            weights.insert(*author, info.voting_power());
        }
        
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights,  // Now properly initialized
        }
    }
}
```

**Alternative Fix: Remove dependency on weights HashMap**

If weighted secret sharing is not yet required, modify `add_share_with_metadata()` to call `get_peer_weight()` instead of looking up from the HashMap:

```rust
fn add_share_with_metadata(
    &mut self,
    share: SecretShare,
    config: &SecretShareConfig,  // Pass full config instead of just weights
) -> anyhow::Result<()> {
    let item = std::mem::replace(self, Self::new(Author::ONE));
    let share_weight = config.get_peer_weight(share.author());  // Use method instead of HashMap
    // ... rest of function
}
```

**Testing Requirements:**
- Add integration test that enables secret sharing and processes blocks
- Verify weights are correctly populated for all validators
- Test state transitions (PendingMetadata → PendingDecision) with multiple validators

## Proof of Concept

**Rust reproduction demonstrating the crash:**

```rust
#[test]
#[should_panic(expected = "Author must exist in weights")]
fn test_secret_share_store_weights_panic() {
    use std::sync::Arc;
    use aptos_types::{
        account_address::AccountAddress,
        validator_verifier::ValidatorVerifier,
        secret_sharing::{SecretShareConfig, SecretShare, SecretShareMetadata},
    };
    use consensus::rand::secret_sharing::secret_share_store::SecretShareStore;
    
    // Create minimal SecretShareConfig with empty weights HashMap
    let author = AccountAddress::random();
    let epoch = 1;
    let validator = Arc::new(ValidatorVerifier::new(vec![]));
    
    // Note: Actual config creation would use real DKG parameters
    // This simplified version demonstrates the weights HashMap is empty
    let config = SecretShareConfig::new(
        author,
        epoch,
        validator,
        // ... other parameters would be real cryptographic material
    );
    
    // Create SecretShareStore
    let (tx, _rx) = futures_channel::mpsc::unbounded();
    let mut store = SecretShareStore::new(epoch, author, config, tx);
    
    // Create a self share (simulating block processing)
    let metadata = SecretShareMetadata {
        epoch,
        round: 1,
        timestamp: 0,
        block_id: HashValue::zero(),
        digest: vec![],  // Simplified
    };
    
    let self_share = SecretShare::new(
        author,
        metadata,
        // ... actual share data
    );
    
    store.update_highest_known_round(1);
    
    // This will panic with "Author must exist in weights"
    // because config.weights is empty
    store.add_self_share(self_share).unwrap();
}
```

**Triggering in Production:**

1. Enable secret sharing in consensus configuration
2. Start validator node
3. Node begins processing blocks requiring secret shares
4. When first block with secret sharing is processed:
   - Node computes self-share
   - Calls `add_self_share()`
   - **Panic occurs: "Author must exist in weights"**
   - **Node crashes**
5. All validators crash at same point → **Network halt**

**Notes:**

This vulnerability demonstrates that the duplicate handling logic has a critical initialization bug that was likely missed because:
- Secret sharing may not be enabled by default
- The weights HashMap appears to be a placeholder for future weighted secret sharing
- The `get_peer_weight()` method returns a hardcoded `1`, suggesting equal weights were intended
- Integration testing may not have covered secret sharing activation

The bug affects consensus liveness and requires immediate remediation before enabling secret sharing in production.

### Citations

**File:** types/src/secret_sharing.rs (L159-169)
```rust
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L156-169)
```rust
    fn add_share_with_metadata(
        &mut self,
        share: SecretShare,
        share_weights: &HashMap<Author, u64>,
    ) -> anyhow::Result<()> {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
        let new_item = match item {
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L237-254)
```rust
    pub fn add_self_share(&mut self, share: SecretShare) -> anyhow::Result<()> {
        assert!(
            self.self_author == share.author,
            "Only self shares can be added with metadata"
        );
        let peer_weights = self.secret_share_config.get_peer_weights();
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share_with_metadata(share, peer_weights)?;
```
