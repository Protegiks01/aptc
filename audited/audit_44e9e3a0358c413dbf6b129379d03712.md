# Audit Report

## Title
State Corruption via Unverified KV Restoration - Merkle Proof Verification Bypass in KvOnly Mode

## Summary
The `StateSnapshotReceiver::finish()` implementation in KvOnly mode skips both Merkle proof verification during chunk ingestion and tree finalization, allowing an attacker who compromises backup storage to inject arbitrary state values that bypass cryptographic verification. This breaks the fundamental security invariant that all restored state must be verifiable via Merkle proofs.

## Finding Description

The vulnerability exists in the two-phase state restoration process used by Aptos nodes to bootstrap from backups:

**Phase 1 - KvOnly Mode (Unverified):** [1](#0-0) 

When `add_chunk()` is called in KvOnly mode, only the `kv_fn()` closure executes, which writes state values directly to storage. The `tree_fn()` closure, which performs Merkle proof verification via `add_chunk_impl()`, is completely bypassed. [2](#0-1) 

The `tree_fn()` calls `add_chunk_impl()` which internally verifies each chunk against the expected Merkle root hash: [3](#0-2) 

This critical verification is never executed in KvOnly mode.

**Phase 2 - TreeOnly Mode (Doesn't Validate Phase 1):** [4](#0-3) 

In Phase 2, TreeOnly mode builds the Merkle tree structure from backup chunks (which ARE verified), but it does not validate that the KV data written in Phase 1 matches the tree structure. The tree and KV store are separate database layers.

**Tree Finalization Skipped:** [5](#0-4) 

The `finish()` method in KvOnly mode only finalizes the KV layer, skipping `tree_restore.finish_impl()` which would compute and verify the final Merkle root hash.

**Real-World Usage:** [6](#0-5) 

KvOnly mode is actively used in production during two-phase restoration.

**Attack Flow:**
1. Attacker compromises backup storage (S3, GCS, etc.)
2. Attacker modifies state snapshot chunks to contain malicious state values
3. Node initiates restoration with KvOnly mode in Phase 1
4. Chunks pass manifest-level root hash validation (line 131-136 of restore.rs)
5. Individual chunks bypass Merkle proof verification (KvOnly mode skips `tree_fn()`)
6. Corrupted state is written to KV storage
7. Phase 2 TreeOnly mode builds correct tree structure but doesn't validate KV data
8. Transaction replay proceeds from corrupted base state
9. Node ends up with internally inconsistent state: correct Merkle tree structure but wrong KV values

**Security Invariant Violation:**
This breaks the critical invariant: "State Consistency: State transitions must be atomic and verifiable via Merkle proofs." The design assumes backup storage is untrusted, requiring cryptographic verification via Merkle proofs. KvOnly mode completely bypasses this security mechanism.

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability enables multiple critical impacts:

1. **Consensus/Safety Violations:** If multiple validator nodes restore from compromised backups, they will have divergent state. When processing identical blocks, they will compute different state roots, causing consensus failures and potential chain splits. This directly violates the "Deterministic Execution" invariant.

2. **State Corruption:** The Merkle tree structure (used for proofs) will be correct, but actual state values will be corrupted. Queries will return incorrect data:
   - Account balances could be wrong
   - Smart contract storage could be manipulated  
   - Validator stake amounts could be falsified

3. **Undetectable Corruption:** Since the Merkle tree structure appears valid, the corruption is not immediately detectable. The node will appear to function normally while serving incorrect data.

4. **Propagation Through Transaction Replay:** After KvOnly restore, transaction replay builds on the corrupted state base, propagating corruption forward to all subsequent versions.

This meets the Critical severity criteria for "Consensus/Safety violations" and "State inconsistencies" that are fundamental to blockchain integrity.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Compromise of backup storage infrastructure (S3/GCS bucket, backup server, or network path)
- Knowledge of snapshot manifest format
- Ability to modify chunk files while maintaining valid BCS encoding

**Factors Increasing Likelihood:**
- Backup storage is often cloud-based (AWS S3, Google Cloud Storage) with potential misconfigurations
- Many organizations use third-party backup services
- The vulnerability is in production code actively used during node bootstrapping
- No secondary validation catches this corruption
- Supply chain attacks on cloud infrastructure are increasingly common

**Factors Decreasing Likelihood:**
- Requires persistent access to backup storage, not just transient compromise
- Attacker must understand Aptos state format and BCS encoding
- Organizations may have additional security layers (encryption, IAM policies)

However, given that the entire security model assumes backup storage is untrusted (hence cryptographic proofs), any scenario requiring backup storage trust represents a fundamental design flaw.

## Recommendation

**Fix 1: Always Verify Proofs During add_chunk()**

Remove KvOnly mode's bypass of proof verification. Modify the implementation to always verify proofs:

```rust
fn add_chunk(&mut self, chunk: Vec<(K, V)>, proof: SparseMerkleRangeProof) -> Result<()> {
    // ALWAYS verify proofs first, regardless of mode
    let tree_fn = || {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["jmt_add_chunk"]);
        self.tree_restore
            .lock()
            .as_mut()
            .unwrap()
            .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)
    };
    
    // Verify BEFORE writing to KV store
    tree_fn()?;
    
    // Only write to KV store if verification succeeds
    match self.restore_mode {
        StateSnapshotRestoreMode::KvOnly | StateSnapshotRestoreMode::Default => {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_value_add_chunk"]);
            self.kv_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk(chunk.clone())?;
        },
        StateSnapshotRestoreMode::TreeOnly => {
            // Tree already added above
        },
    }
    
    Ok(())
}
```

**Fix 2: Require Tree Finalization for Root Hash Verification**

Ensure `finish()` always computes and verifies the Merkle root:

```rust
fn finish(self) -> Result<()> {
    match self.restore_mode {
        StateSnapshotRestoreMode::KvOnly => {
            self.kv_restore.lock().take().unwrap().finish()?;
            // MUST verify tree root even in KvOnly mode
            let tree = self.tree_restore.lock().take().unwrap();
            tree.finish_impl()?;
        },
        // ... other modes remain the same
    }
    Ok(())
}
```

**Fix 3: Post-Restore Consistency Check**

Add a verification step after KvOnly restore that reads KV values and verifies they hash to the expected Merkle root.

## Proof of Concept

**Setup:**
1. Create a backup with a valid state snapshot at version V
2. Modify chunk files in backup storage to contain incorrect state values
3. Keep manifest and proof files unchanged (so manifest root hash validation passes)

**Exploitation Steps:**

```rust
// Pseudocode demonstrating the vulnerability
async fn exploit_kvonly_restore() -> Result<()> {
    // 1. Attacker compromises backup storage
    let backup_storage = BackupStorage::new("s3://compromised-bucket");
    
    // 2. Load legitimate manifest (passes root hash check)
    let manifest = backup_storage.load("snapshot_v100_manifest.json")?;
    // manifest.root_hash = <legitimate_hash_verified_by_ledger_info>
    
    // 3. Attacker replaces chunk files with malicious data
    let malicious_chunk = vec![
        (StateKey::new(...), StateValue::new(b"WRONG_VALUE_1")),
        (StateKey::new(...), StateValue::new(b"WRONG_VALUE_2")),
        // These values don't match the manifest root hash!
    ];
    backup_storage.write("chunk_0.bcs", serialize(&malicious_chunk))?;
    
    // 4. Node initiates KvOnly restore (Phase 1 of two-phase restore)
    let mut receiver = StateSnapshotRestore::new(
        tree_store,
        value_store, 
        version,
        manifest.root_hash, // Expected root hash from manifest
        false,
        StateSnapshotRestoreMode::KvOnly, // VULNERABLE MODE
    )?;
    
    // 5. Malicious chunk is added WITHOUT proof verification
    receiver.add_chunk(malicious_chunk, proof)?;
    // ^ In KvOnly mode, tree_fn() is NOT called
    // ^ Proof verification is SKIPPED
    // ^ Malicious values written directly to KV store
    
    // 6. Finish WITHOUT tree finalization
    receiver.finish()?;
    // ^ Tree finalization SKIPPED
    // ^ No root hash computation or verification
    
    // 7. Result: Database contains unverified, malicious state
    // 8. Transaction replay builds on corrupted state
    // 9. Node diverges from honest nodes
    
    Ok(())
}
```

**Verification:**
Run this test on a node doing two-phase restore. After Phase 1 completes, query the KV store directly and compare values against expected Merkle root. The values will not hash to the expected root, confirming unverified state was accepted.

**Notes:**
- This exploit requires no validator privileges
- Attack surface is any node performing backup restoration
- Particularly dangerous during network bootstrapping when many nodes restore simultaneously
- No existing detection mechanism catches this corruption until consensus failures occur

### Citations

**File:** storage/aptosdb/src/state_restore/mod.rs (L238-245)
```rust
        let tree_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["jmt_add_chunk"]);
            self.tree_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)
        };
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L246-247)
```rust
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L260-262)
```rust
    fn finish(self) -> Result<()> {
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => self.kv_restore.lock().take().unwrap().finish()?,
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L690-696)
```rust
        proof
            .verify(
                self.expected_root_hash,
                SparseMerkleLeafNode::new(*previous_key, previous_leaf.value_hash()),
                left_siblings,
            )
            .map_err(Into::into)
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L243-259)
```rust
            if kv_snapshot.is_some() {
                let kv_snapshot = kv_snapshot.clone().unwrap();
                info!("Start restoring KV snapshot at {}", kv_snapshot.version);

                StateSnapshotRestoreController::new(
                    StateSnapshotRestoreOpt {
                        manifest_handle: kv_snapshot.manifest,
                        version: kv_snapshot.version,
                        validate_modules: false,
                        restore_mode: StateSnapshotRestoreMode::KvOnly,
                    },
                    self.global_opt.clone(),
                    Arc::clone(&self.storage),
                    epoch_history.clone(),
                )
                .run()
                .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L318-325)
```rust
                let restore_mode_opt = if db_next_version > 0 {
                    if replay_all_mode {
                        None // the restore should already been done in the replay_all mode
                    } else {
                        Some(StateSnapshotRestoreMode::TreeOnly)
                    }
                } else {
                    Some(StateSnapshotRestoreMode::Default)
```
