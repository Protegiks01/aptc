# Audit Report

## Title
Gas Metering Bypass in Type Layout Construction via Uncharged Struct Name Index Map Lookups

## Summary
The `struct_to_type_layout()` function charges gas for module loading but fails to charge for multiple `idx_to_struct_name_ref` lookups performed during layout construction. When processing types with many structs from the same module, this creates a gas metering bypass where uncharged CPU work can exceed charged work by 10-15x, enabling resource exhaustion attacks against validators.

## Finding Description

The vulnerability exists in the Move VM's type layout converter. When converting struct types to layouts, the system charges gas for module loading but performs multiple uncharged struct name index map lookups per struct. [1](#0-0) 

The `load_struct_definition` call on line 379-383 charges gas for module loading, but then the same `idx_to_struct_name_ref` lookup is performed again at line 384-388 without any gas charge.

Additionally, the `load_struct_definition` function internally performs another uncharged lookup: [2](#0-1) 

A third uncharged lookup occurs when checking for delayed fields: [3](#0-2) 

The `idx_to_struct_name_ref` operation itself performs no gas metering: [4](#0-3) 

The module charging mechanism only charges once per module via traversal context tracking: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a type containing 512 structs (maximum allowed by `layout_max_size`) all from the same module
2. Triggers layout construction via event emission, table creation, or function arguments
3. Only 1 module load is charged (first struct from that module)
4. ~1,536 `idx_to_struct_name_ref` calls occur (3× per struct) with zero gas charged
5. The uncharged CPU work becomes comparable to or exceeds the charged module load cost

A developer TODO comment acknowledges this gap: [6](#0-5) 

## Impact Explanation

This is a **Medium Severity** gas metering bypass vulnerability according to Aptos bug bounty criteria:

- **Validator Node Slowdowns**: Attackers can consume disproportionate validator CPU resources relative to gas paid, causing performance degradation
- **Resource Exhaustion**: Multiple transactions exploiting this can amplify the effect, potentially impacting block processing times
- **Gas Metering Integrity**: Violates the critical invariant that "all operations must respect gas limits and computational limits"

The vulnerability breaks the Move VM Safety invariant: "Bytecode execution must respect gas limits and memory constraints." While individual lookups are cheap (~100-500 CPU cycles), 1,536 uncharged lookups (~150,000-750,000 total cycles) become comparable to a charged module load operation, creating a 10-15× amplification factor between paid and consumed resources.

## Likelihood Explanation

**Likelihood: High**

- **Easy to Trigger**: Any transaction can trigger layout construction through event emissions, table operations, function arguments, or resource loading
- **No Special Privileges Required**: Standard transaction senders can exploit this
- **Reproducible**: The behavior is deterministic and consistent across all validators
- **Practical Limits**: Layout cache reduces repeated exploitation of the same type, but attackers can use many different type instantiations
- **Existing Infrastructure**: The `layout_max_size` of 512 nodes provides sufficient amplification [7](#0-6) 

## Recommendation

Introduce gas metering for struct name index map lookups during layout construction. The charge should be proportional to the number of lookups performed:

```rust
fn struct_to_type_layout<const ANNOTATED: bool>(
    &self,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext,
    modules: &mut DefiningModules,
    idx: &StructNameIndex,
    ty_args: &[Type],
    count: &mut u64,
    depth: u64,
    check_option_type: bool,
) -> PartialVMResult<(MoveTypeLayout, bool)> {
    // Charge gas for struct name lookup BEFORE performing it
    gas_meter.charge_struct_name_lookup()?;
    
    let struct_definition = self.struct_definition_loader.load_struct_definition(
        gas_meter,
        traversal_context,
        idx,
    )?;
    
    // Avoid redundant lookup - reuse struct name from load_struct_definition
    // or cache it to prevent duplicate lookups
    let struct_identifier = self
        .struct_definition_loader
        .runtime_environment()
        .struct_name_index_map()
        .idx_to_struct_name_ref(*idx)?;
    // ...
}
```

Alternatively, eliminate redundant lookups by having `load_struct_definition` return both the struct definition and struct identifier, avoiding the duplicate external lookup.

## Proof of Concept

```move
// Module with many struct definitions
module 0xCAFE::exploit {
    struct S0 { value: u64 }
    struct S1 { s0: S0, value: u64 }
    struct S2 { s1: S1, value: u64 }
    // ... continue defining S3 through S511
    // Each struct contains the previous one
    
    struct ComplexType {
        s0: S0, s1: S1, s2: S2, // ... s511: S511
    }
    
    public entry fun trigger_layout_construction() {
        // Emit event that triggers layout construction
        0x1::event::emit(ComplexType { 
            s0: S0 { value: 0 },
            s1: S1 { s0: S0 { value: 0 }, value: 0 },
            // ... initialize all 512 fields
        });
    }
}
```

**Expected Behavior:**
- Gas charged: 1 module load for `0xCAFE::exploit`
- Actual CPU work: 1 module load + ~1,536 uncharged struct name lookups
- Amplification: 10-15× uncharged work vs charged work

**Notes**

The vulnerability is mitigated by:
1. Layout caching preventing repeated construction of identical types within a session
2. The `layout_max_size` limit of 512 nodes caps the maximum amplification per type
3. Transaction gas limits cap total resource consumption per transaction

However, an attacker can still exploit this by:
- Using many different type instantiations to bypass cache
- Submitting multiple transactions to amplify the effect
- Targeting validators during high-load periods to maximize impact

The TODO comment at line 367 suggests developers were aware that "proper charges here for layout construction" were needed but not yet implemented, confirming this is an unaddressed gas metering gap.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L187-187)
```rust
        let struct_name = self.get_struct_name(idx)?;
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L363-367)
```rust
    // TODO(lazy-loading):
    //   We do not add struct cyclic checks here because it can be rather expensive to check. In
    //   general, because we have depth / count checks and charges for modules this will eventually
    //   terminate in any case. In the future, layouts should be revisited anyway.
    //   Consider adding proper charges here for layout construction (before rollout).
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L379-389)
```rust
        let struct_definition = self.struct_definition_loader.load_struct_definition(
            gas_meter,
            traversal_context,
            idx,
        )?;
        let struct_identifier = self
            .struct_definition_loader
            .runtime_environment()
            .struct_name_index_map()
            .idx_to_struct_name_ref(*idx)?;
        modules.insert(struct_identifier.module());
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L61-76)
```rust
        if traversal_context.visit_if_not_special_module_id(module_id) {
            let addr = module_id.address();
            let name = module_id.name();

            let size = self
                .module_storage
                .unmetered_get_existing_module_size(addr, name)
                .map_err(|err| err.to_partial())?;
            gas_meter.charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )?;
        }
        Ok(())
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L193-196)
```rust
        let struct_name = self
            .runtime_environment()
            .struct_name_index_map()
            .idx_to_struct_name_ref(*idx)?;
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L118-124)
```rust
    pub fn idx_to_struct_name_ref(
        &self,
        idx: StructNameIndex,
    ) -> PartialVMResult<Arc<StructIdentifier>> {
        let index_map = self.0.read();
        Ok(Self::idx_to_struct_name_helper(&index_map, idx)?.clone())
    }
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L89-89)
```rust
    }
```
