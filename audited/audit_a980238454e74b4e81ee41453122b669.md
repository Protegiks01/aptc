# Audit Report

## Title
Indexer File Store Validation Gap: Missing Transaction Detection Failure Due to Fixed 1000-Version Increment

## Summary
The `validate()` function in the indexer-grpc-file-store-backfiller increments the version allocator by a fixed 1000 at each iteration, but only validates that transactions present in the file have sequential version numbers. It fails to verify that each file contains the expected number of transactions, allowing validation to pass even when transactions are missing from the middle of the data range. [1](#0-0) 

## Finding Description

The validation logic contains a critical flaw that breaks the data integrity guarantee. The system enforces that each uploaded batch must contain exactly 1000 transactions (except the last batch), as seen in the upload validation: [2](#0-1) 

However, the validation function only checks that transactions present in a file have sequential version numbers, without verifying the count matches expectations: [3](#0-2) 

**Attack Scenario:**

If a file at version 90000 contains only 900 transactions (versions 90000-90899) instead of the expected 1000:

1. A validation task allocates version 90000
2. Increments the allocator to 91000 (fixed increment)
3. Fetches transactions from the file (returns 900 transactions: 90000-90899)
4. Validates each transaction has sequential versions: `t.version == 90000 + idx` âœ“
5. Marks version 90000 as validated
6. Next task validates version 91000 onwards
7. **Transactions 90900-90999 are missing, but validation passes!**

The root cause is that the validation loop only verifies sequential numbering of present transactions, not that all expected transactions exist. The fixed 1000-version increment combined with missing transaction count validation creates a gap detection blind spot.

## Impact Explanation

**Medium Severity** - This vulnerability causes state inconsistencies requiring intervention:

1. **Data Integrity Violation**: The indexer's file store is intended to be a complete, verifiable archive of blockchain transactions. Missing transactions violate this fundamental guarantee.

2. **Downstream Impact**: Applications and services querying the indexer for transaction history would receive incomplete or missing data for the affected version ranges, leading to:
   - Failed queries for missing transactions
   - Incorrect account history
   - Incomplete event logs
   - Broken application logic depending on complete transaction data

3. **Silent Failure**: The validation passes despite data corruption, providing false confidence in data integrity. Operators would not detect the issue through normal validation procedures.

4. **Intervention Required**: Recovery requires re-backfilling from the source blockchain data, causing operational disruption.

While this does not affect consensus or funds directly (the indexer is off-chain infrastructure), it compromises a critical data availability service that the Aptos ecosystem depends on.

## Likelihood Explanation

**Medium-High Likelihood**:

The vulnerability can manifest through multiple realistic scenarios:

1. **File System Corruption**: Storage medium failures or filesystem issues could corrupt files, resulting in truncated batches
2. **Manual File Manipulation**: Accidental or malicious deletion/modification of files in the storage bucket
3. **Concurrent Write Race Conditions**: If multiple processes write to the same file simultaneously
4. **Bugs in Alternative Tools**: Other tools or scripts that write to the file store might not enforce the 1000-transaction constraint
5. **Partial Upload Failures**: Network interruptions during file uploads could result in incomplete files being stored

The backfill process does enforce the constraint during normal operation, but the validation mode exists precisely to detect such anomalies. Its failure to do so undermines the entire purpose of having a validation mode.

## Recommendation

Add explicit transaction count validation before marking a version as validated:

```rust
let task = tokio::spawn(async move {
    loop {
        let version = {
            let mut version_allocator = version_allocator.lock().await;
            let version = *version_allocator;
            if version >= expected_end_version {
                return Ok(());
            }
            *version_allocator += 1000;
            version
        };
        let transactions = file_operator.get_transactions(version, 1).await.unwrap();
        
        // NEW: Validate transaction count
        let expected_count = if version + 1000 >= expected_end_version {
            // Last batch may have fewer than 1000 transactions
            (expected_end_version - version) as usize
        } else {
            // All other batches must have exactly 1000 transactions
            1000
        };
        ensure!(
            transactions.len() == expected_count,
            "Expected {} transactions at version {}, but found {}",
            expected_count,
            version,
            transactions.len()
        );
        
        for (idx, t) in transactions.iter().enumerate() {
            ensure!(t.version == version + idx as u64, "Unexpected version");
        }

        let mut gap_detector = gap_detector.lock().await;
        gap_detector.insert(version);
    }
});
```

This ensures:
- Non-final batches contain exactly 1000 transactions
- The final batch contains exactly `expected_end_version - version` transactions
- Any deviation causes validation to fail immediately with a clear error message

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
#[tokio::test]
async fn test_validation_gap_detection() {
    use tempfile::tempdir;
    use std::fs;
    
    // Setup: Create a file store with a gap
    let temp_dir = tempdir().unwrap();
    let file_store_path = temp_dir.path();
    
    // Create files with proper batches
    create_transaction_file(file_store_path, 0, 1000);     // versions 0-999
    create_transaction_file(file_store_path, 1000, 1000);  // versions 1000-1999
    
    // Create corrupted file with only 900 transactions (GAP: missing 2900-2999)
    create_transaction_file(file_store_path, 2000, 900);   // versions 2000-2899
    
    create_transaction_file(file_store_path, 3000, 1000);  // versions 3000-3999
    
    // Run validation
    let result = run_validation(
        file_store_path,
        0,           // starting_version
        4000,        // ending_version
    ).await;
    
    // Expected: Validation should FAIL detecting missing transactions 2900-2999
    // Actual: Validation PASSES (vulnerability)
    assert!(result.is_err(), "Validation should fail for incomplete batches");
    assert!(
        result.unwrap_err().to_string().contains("Expected 1000 transactions"),
        "Error should indicate missing transactions"
    );
}

fn create_transaction_file(base_path: &Path, start_version: u64, count: usize) {
    // Create a file with specified number of transactions
    let transactions: Vec<Transaction> = (0..count)
        .map(|i| Transaction {
            version: start_version + i as u64,
            ..Transaction::default()
        })
        .collect();
    
    let file_entry = FileEntry::from_transactions(
        transactions,
        StorageFormat::Lz4CompressedProto
    );
    
    let file_path = base_path.join(format!("{}.bin", start_version));
    fs::write(file_path, file_entry.into_inner()).unwrap();
}
```

The PoC creates a file store with a corrupted batch containing only 900 transactions instead of 1000, then runs validation. The current implementation would pass validation despite the gap, while the fixed version would correctly fail.

---

**Notes**

This vulnerability specifically affects the indexer-grpc-file-store-backfiller validation mode, which is critical infrastructure for ensuring data integrity in the Aptos indexer system. While it does not directly impact consensus or on-chain operations, it represents a significant data availability and integrity issue that undermines trust in the indexer service.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L340-340)
```rust
                        *version_allocator += 1000;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L343-346)
```rust
                    let transactions = file_operator.get_transactions(version, 1).await.unwrap();
                    for (idx, t) in transactions.iter().enumerate() {
                        ensure!(t.version == version + idx as u64, "Unexpected version");
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/gcs.rs (L219-222)
```rust
        anyhow::ensure!(
            batch_size == FILE_ENTRY_TRANSACTION_COUNT as usize,
            "The number of transactions to upload has to be multiplier of BLOB_STORAGE_SIZE."
        );
```
