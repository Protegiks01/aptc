# Audit Report

## Title
Out-of-Bounds Panic in Cross-Shard Message Reception Due to Unchecked Partitioning Round Configuration

## Summary
The `RemoteCrossShardClient` and `LocalCrossShardClient` implementations create a fixed number of inbound channels (`MAX_ALLOWED_PARTITIONING_ROUNDS = 8`) but do not validate that the configured `max_partitioning_rounds` stays within this limit. When `max_partitioning_rounds` exceeds 8, the system attempts to access non-existent channel indices, causing an out-of-bounds panic that crashes the executor service.

## Finding Description

The vulnerability exists in the initialization mismatch between channel allocation and runtime access:

**Channel Allocation (Fixed at 8):** [1](#0-0) [2](#0-1) 

The constant `MAX_ALLOWED_PARTITIONING_ROUNDS` is hardcoded to 8: [3](#0-2) 

**Unchecked Configuration:** [4](#0-3) [5](#0-4) 

**Runtime Access Without Bounds Checking:** [6](#0-5) [7](#0-6) 

**Execution Flow:**
When executing a sharded block, the system enumerates sub-blocks: [8](#0-7) 

This round index is passed to `CrossShardCommitReceiver::start`: [9](#0-8) 

Which then calls `receive_cross_shard_msg` with potentially out-of-bounds indices: [10](#0-9) 

## Impact Explanation

**Severity: High** - This qualifies as a High severity issue per Aptos bug bounty criteria because it causes "Validator node slowdowns" and "API crashes". 

When triggered, this vulnerability causes:
1. **Immediate executor service crash** via Rust panic on out-of-bounds array access
2. **Block execution failure** preventing the validator from processing transactions
3. **Potential liveness impact** if multiple validators are misconfigured

The crash breaks the **Resource Limits** invariant - the system should gracefully handle configuration errors rather than panicking.

## Likelihood Explanation

**Likelihood: Low to Medium**

While the vulnerability exists in production code, triggering it requires:
- **Privileged access**: Ability to configure validator/executor command-line parameters
- **Misconfiguration**: Explicitly setting `--max_partitioning_rounds` > 8

This is primarily a **misconfiguration vulnerability** rather than an external attack vector. However:
- The lack of validation makes it easy to accidentally trigger
- No runtime warnings exist about the misconfiguration
- The default value (4) is safe, but operators might increase it for performance testing

## Recommendation

Add validation to ensure `max_partitioning_rounds` never exceeds `MAX_ALLOWED_PARTITIONING_ROUNDS`:

**Fix for PartitionerV2Config:**
```rust
// In execution/block-partitioner/src/v2/config.rs
pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
    assert!(
        val <= MAX_ALLOWED_PARTITIONING_ROUNDS,
        "max_partitioning_rounds ({}) must not exceed MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
        val,
        MAX_ALLOWED_PARTITIONING_ROUNDS
    );
    self.max_partitioning_rounds = val;
    self
}
```

**Fix for PartitionerV1Config:**
```rust
// In execution/block-partitioner/src/sharded_block_partitioner/config.rs
pub fn max_partitioning_rounds(mut self, max_partitioning_rounds: RoundId) -> Self {
    assert!(
        max_partitioning_rounds <= MAX_ALLOWED_PARTITIONING_ROUNDS,
        "max_partitioning_rounds ({}) must not exceed MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
        max_partitioning_rounds,
        MAX_ALLOWED_PARTITIONING_ROUNDS
    );
    self.max_partitioning_rounds = max_partitioning_rounds;
    self
}
```

Additionally, add runtime bounds checking in `receive_cross_shard_msg`:
```rust
fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
    assert!(
        current_round < self.message_rxs.len(),
        "Round {} exceeds maximum allowed rounds {}",
        current_round,
        self.message_rxs.len()
    );
    let rx = self.message_rxs[current_round].lock().unwrap();
    // ... rest of implementation
}
```

## Proof of Concept

```bash
# Run executor-benchmark with invalid configuration
cargo run --bin executor-benchmark -- \
  --num-executor-shards 4 \
  --max-partitioning-rounds 9 \
  --partitioner-version v2 \
  # ... other required parameters

# Expected result: Panic with message similar to:
# thread 'sharded-executor-shard-0-1' panicked at 'index out of bounds: 
# the len is 8 but the index is 8'
```

The panic occurs when the 9th round (index 8) attempts to receive messages from a channel array sized for only 8 elements (indices 0-7).

## Notes

- This vulnerability affects **both** `RemoteCrossShardClient` (distributed execution) and `LocalCrossShardClient` (local sharded execution)
- The issue is in production code paths, not just benchmark/test utilities
- While the executor-benchmark tool is the most obvious entry point, any deployment using custom partitioner configurations could trigger this
- The fix should be applied at configuration validation time to fail fast rather than during execution

### Citations

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L37-41)
```rust
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
        }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L100-103)
```rust
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L335-337)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        self.message_rxs[current_round].recv().unwrap()
    }
```

**File:** types/src/block_executor/partitioner.rs (L20-20)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
```

**File:** execution/executor-benchmark/src/main.rs (L217-217)
```rust
    max_partitioning_rounds: usize,
```

**File:** execution/block-partitioner/src/v2/config.rs (L58-58)
```rust
            max_partitioning_rounds: 4,
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L136-140)
```rust
                CrossShardCommitReceiver::start(
                    cross_shard_state_view_clone,
                    cross_shard_client,
                    round,
                );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L192-205)
```rust
        for (round, sub_block) in transactions.into_sub_blocks().into_iter().enumerate() {
            let _timer = SHARDED_BLOCK_EXECUTION_BY_ROUNDS_SECONDS
                .timer_with(&[&self.shard_id.to_string(), &round.to_string()]);
            SHARDED_BLOCK_EXECUTOR_TXN_COUNT.observe_with(
                &[&self.shard_id.to_string(), &round.to_string()],
                sub_block.transactions.len() as f64,
            );
            info!(
                "executing sub block for shard {} and round {}, number of txns {}",
                self.shard_id,
                round,
                sub_block.transactions.len()
            );
            result.push(self.execute_sub_block(sub_block, round, state_view, config.clone())?);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L31-32)
```rust
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
```
