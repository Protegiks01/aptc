# Audit Report

## Title
Information Disclosure in AdminService Consensus Database Error Handling

## Summary
The `handle_dump_consensus_db_request()` function exposes detailed internal error messages including database file paths, RocksDB error details, and consensus state information through unfiltered `error.to_string()` calls in HTTP 500 responses.

## Finding Description
The AdminService provides debugging endpoints for dumping consensus database contents. When errors occur during database operations, the error handling code returns raw error messages to HTTP clients without sanitization. [1](#0-0) 

The error flow traces through multiple layers:
1. `dump_consensus_db()` calls `consensus_db.consensus_db().get_data()` which can fail with database errors [2](#0-1) 

2. Database errors are wrapped as `DbError` containing `anyhow::Error` which wraps `AptosDbError` [3](#0-2) 

3. `AptosDbError` variants include file paths and detailed RocksDB error messages [4](#0-3) 

4. RocksDB errors are converted with full error strings including IOError details [5](#0-4) 

**Information Disclosed:**
- Database file system paths (e.g., `/var/lib/aptos/consensus_db/...`)
- RocksDB internal error messages revealing database structure
- Column family names and database configuration details
- Block IDs, QC IDs, and other internal identifiers from `NotFound` errors
- Database corruption details that reveal internal consensus state

The same vulnerability exists in related endpoints: [6](#0-5) [7](#0-6) 

## Impact Explanation
This constitutes an **information disclosure vulnerability** that aids attacker reconnaissance. While the AdminService requires authentication on mainnet, the vulnerability still exposes sensitive implementation details: [8](#0-7) 

According to Aptos bug bounty categories, information leaks fall under **Low Severity**. However, the exposed information includes:
- File system layout revealing node deployment configuration
- Database structure details useful for planning storage-based attacks  
- Internal state information that could assist in timing or state manipulation attacks
- Validator node configuration details

The codebase demonstrates proper error sanitization patterns elsewhere that should be followed: [9](#0-8) 

## Likelihood Explanation
**Moderate likelihood** of exploitation:
- AdminService is disabled by default on mainnet but enabled on testnet [10](#0-9) 

- On mainnet: Requires authentication via passcode, but passcode compromise or testnet deployment without authentication increases risk
- On testnet/devnet: May be accessible without authentication if `authentication_configs` is empty [11](#0-10) 

- Triggering requires database error conditions (corruption, IO failures, etc.)
- Multiple endpoints affected: `/debug/consensus/consensusdb`, `/debug/consensus/quorumstoredb`, `/debug/consensus/block`

## Recommendation
Implement error message sanitization following the pattern used in the pepper service. Replace detailed error exposure with generic messages while logging full details server-side:

```rust
match spawn_blocking(move || dump_consensus_db(consensus_db.as_ref())).await {
    Ok(result) => {
        info!("Finished dumping consensus db.");
        let headers: Vec<(_, HeaderValue)> =
            vec![(CONTENT_LENGTH, HeaderValue::from(result.len()))];
        Ok(reply_with(headers, result))
    },
    Err(e) => {
        // Log detailed error server-side for debugging
        error!("Failed to dump consensus db: {e:?}");
        // Return generic error to client
        Ok(reply_with_status(
            StatusCode::INTERNAL_SERVER_ERROR,
            UNEXPECTED_ERROR_MESSAGE,  // "An unexpected error was encountered!"
        ))
    },
}
```

Apply the same fix to all error handling in:
- `handle_dump_quorum_store_db_request()` (line 68)
- `handle_dump_block_request()` (line 124)
- Query parameter parsing errors (lines 50, 85, 95)

## Proof of Concept
```rust
// Reproduction Steps:
// 1. Enable AdminService on a test node with authentication disabled or obtain passcode
// 2. Corrupt the consensus database by manually modifying RocksDB files or causing IO errors
// 3. Send HTTP request to trigger error path:

use reqwest;

#[tokio::test]
async fn test_error_information_disclosure() {
    // Assumes AdminService running on localhost:9102 with authentication disabled
    let response = reqwest::get("http://localhost:9102/debug/consensus/consensusdb")
        .await
        .unwrap();
    
    assert_eq!(response.status(), 500);
    let error_body = response.text().await.unwrap();
    
    // Error message will contain internal details like:
    // "AptosDB RocksDB Error: IO error: /var/lib/aptos/consensus_db/consensus_db: No such file or directory"
    // or
    // "AptosDB RocksDB Error: Corruption: corrupted compressed block contents"
    
    // These messages expose file paths and internal state
    assert!(error_body.contains("consensus_db") || error_body.contains("IO error"));
}
```

## Notes
While this vulnerability provides reconnaissance value to attackers, it does not directly compromise consensus safety, validator operations, or lead to fund loss. The primary security harm is information leakage that could facilitate more sophisticated attacks. Defense-in-depth principles dictate that internal implementation details should not be exposed to external callers, even on debugging endpoints.

### Citations

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L30-36)
```rust
        Err(e) => {
            info!("Failed to dump consensus db: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L64-70)
```rust
        Err(e) => {
            info!("Failed to dump quorum store db: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L120-126)
```rust
        Err(e) => {
            info!("Failed to dump block(s): {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-135)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

```

**File:** consensus/src/error.rs (L7-18)
```rust
#[derive(Debug, Error)]
#[error(transparent)]
pub struct DbError {
    #[from]
    inner: anyhow::Error,
}

impl From<aptos_storage_interface::AptosDbError> for DbError {
    fn from(e: aptos_storage_interface::AptosDbError) -> Self {
        DbError { inner: e.into() }
    }
}
```

**File:** storage/storage-interface/src/errors.rs (L9-36)
```rust
/// This enum defines errors commonly used among `AptosDB` APIs.
#[derive(Clone, Debug, Error)]
pub enum AptosDbError {
    /// A requested item is not found.
    #[error("{0} not found.")]
    NotFound(String),
    /// Requested too many items.
    #[error("Too many items requested: at least {0} requested, max is {1}")]
    TooManyRequested(u64, u64),
    #[error("Missing state root node at version {0}, probably pruned.")]
    MissingRootError(u64),
    /// Other non-classified error.
    #[error("AptosDB Other Error: {0}")]
    Other(String),
    #[error("AptosDB RocksDb Error: {0}")]
    RocksDbIncompleteResult(String),
    #[error("AptosDB RocksDB Error: {0}")]
    OtherRocksDbError(String),
    #[error("AptosDB bcs Error: {0}")]
    BcsError(String),
    #[error("AptosDB IO Error: {0}")]
    IoError(String),
    #[error("AptosDB Recv Error: {0}")]
    RecvError(String),
    #[error("AptosDB ParseInt Error: {0}")]
    ParseIntError(String),
    #[error("Hot state not configured properly")]
    HotStateError,
```

**File:** storage/schemadb/src/lib.rs (L389-408)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
}
```

**File:** config/src/config/admin_service_config.rs (L59-81)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
```

**File:** config/src/config/admin_service_config.rs (L84-106)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
```

**File:** keyless/pepper/service/src/request_handler.rs (L65-68)
```rust
// Useful message constants
const METHOD_NOT_ALLOWED_MESSAGE: &str =
    "The request method is not allowed for the requested path!";
const UNEXPECTED_ERROR_MESSAGE: &str = "An unexpected error was encountered!";
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```
