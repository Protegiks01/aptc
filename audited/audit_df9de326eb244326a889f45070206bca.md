# Audit Report

## Title
Resource Exhaustion via Delayed Proof Verification in State Sync Data Client

## Summary
The Aptos data client performs expensive decompression and deserialization operations on peer responses before cryptographic proof verification occurs. This allows malicious peers to force victim nodes to waste CPU resources by sending structurally valid but cryptographically invalid responses, triggering `InvalidResponse` errors only after partial processing completes.

## Finding Description

The state synchronization pipeline processes responses from peers in the following order:

1. **Data Client Layer** receives `StorageServiceResponse` and validates compression settings [1](#0-0) 

2. **Response Decompression & Deserialization** occurs when `get_data_response()` is called during `TryFrom` conversion, performing decompression and BCS deserialization [2](#0-1) 

3. **Type Conversion** extracts specific response types (e.g., `TransactionListWithProofV2`) through multiple `TryFrom` implementations [3](#0-2) 

4. **Stream Engine Processing** validates response structure and extracts fields [4](#0-3) 

5. **Proof Verification** occurs in the state sync driver, significantly later in the pipeline [5](#0-4) 

The critical security issue is that cryptographic signature verification happens through `verify_ledger_info_with_signatures` [6](#0-5)  **after** all expensive processing operations have completed.

**Attack Scenario:**

A malicious peer crafts responses with:
- Valid compression format
- Valid BCS-serialized structure  
- Correct response type variants
- **Forged or invalid cryptographic proofs/signatures**

The victim node will:
1. Accept the response (passes compression and type checks)
2. Decompress the data (CPU cost via `aptos_compression::decompress`)
3. BCS deserialize into structured types (CPU cost via `bcs::from_bytes`)
4. Validate structural properties and extract fields (CPU cost)
5. **Only then** detect the invalid proof and trigger `PayloadProofFailed` feedback [7](#0-6) 

The conversion from storage service errors to `InvalidResponse` occurs before proof verification [8](#0-7) , meaning structural validation errors are classified as `InvalidResponse` while cryptographic failures are reported separately as `ProofVerificationError` [9](#0-8) .

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" category.

**Quantified Impact:**
- Malicious peers can repeatedly send cryptographically invalid but structurally valid responses
- Each response forces the victim to perform expensive decompression and deserialization before detecting the attack
- While peer scoring eventually penalizes malicious peers via `notify_bad_response` [10](#0-9) , this occurs **after** resources have been wasted
- Sustained attacks can cause CPU exhaustion on validator nodes, degrading consensus participation and block processing performance

**Broken Invariant:**
- Invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits"
- Nodes perform unbounded decompression/deserialization on unverified data before cryptographic validation

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements:** Any malicious peer on the network (no special privileges required)
- **Attack Complexity:** Low - attacker needs to:
  1. Construct structurally valid `StorageServiceResponse` messages
  2. Use valid compression and BCS serialization
  3. Insert forged/invalid cryptographic proofs
  4. Send multiple such responses to target victims
- **Detection Difficulty:** The attack is indistinguishable from legitimate structural errors until proof verification
- **Mitigation Gaps:** While peer scoring exists, it activates too late to prevent resource waste

## Recommendation

Implement **early proof verification** before expensive deserialization operations. The recommended fix involves two approaches:

**Option 1: Lightweight Proof Pre-validation**
Add a fast cryptographic proof structure check in the data client layer before decompression. This could validate that proof signatures have the correct format and byte lengths without full verification.

**Option 2: Proof Verification Priority Ordering**
Restructure the processing pipeline to verify proofs immediately after decompression but before deep deserialization:

```rust
// In client.rs after decompression
let data_response = response.get_data_response()?;

// NEW: Extract and verify proof early
if let Some(ledger_info) = data_response.extract_ledger_info_for_verification() {
    // Perform signature verification before TryFrom conversion
    if let Err(e) = verify_ledger_info_early(ledger_info) {
        context.response_callback.notify_bad_response(
            ResponseError::ProofVerificationError
        );
        return Err(Error::InvalidResponse(format!(
            "Proof verification failed before processing: {:?}", e
        )));
    }
}

// Continue with TryFrom conversion only if proof validates
match T::try_from(storage_response) { ... }
```

**Option 3: Resource Limits**
Add strict size limits and complexity bounds on compressed data before decompression, and implement request rate limiting per peer before expensive operations.

## Proof of Concept

```rust
// Malicious peer exploit demonstration
use aptos_storage_service_types::responses::*;
use aptos_types::ledger_info::LedgerInfoWithSignatures;

// Step 1: Create a structurally valid but cryptographically invalid response
fn create_malicious_response() -> StorageServiceResponse {
    // Valid BCS-serialized transaction data
    let valid_structure = create_valid_transaction_structure();
    
    // FORGED ledger info with invalid/random signatures
    let forged_ledger_info = create_forged_ledger_info();
    
    let data_response = DataResponse::NewTransactionsWithProof((
        valid_structure,
        forged_ledger_info, // Invalid signatures!
    ));
    
    // Compress it (valid compression format)
    StorageServiceResponse::new(data_response, true).unwrap()
}

// Step 2: Send to victim
async fn exploit_victim_node(victim_peer: PeerNetworkId) {
    let malicious_response = create_malicious_response();
    
    // Send repeatedly to exhaust resources
    for _ in 0..1000 {
        // Victim will:
        // 1. Accept response (passes compression check)
        // 2. Decompress (CPU cost)
        // 3. BCS deserialize (CPU cost)  
        // 4. Extract transaction fields (CPU cost)
        // 5. ONLY THEN detect invalid proof
        send_storage_response(victim_peer, malicious_response.clone()).await;
    }
}

fn create_forged_ledger_info() -> LedgerInfoWithSignatures {
    // Create ledger info with random/forged BLS signatures
    // that pass structural validation but fail cryptographic verification
    LedgerInfoWithSignatures::new(
        valid_ledger_info(),
        random_signature_aggregation() // Invalid crypto!
    )
}
```

The PoC demonstrates that a malicious peer can force victim nodes to waste significant CPU resources on decompression and deserialization before the forged proofs are detected during cryptographic verification.

## Notes

This vulnerability represents a gap between structural validation (which triggers `InvalidResponse`) and cryptographic validation (which triggers `ProofVerificationError`). The delayed proof verification creates an exploitable window where expensive operations are performed on adversarial data. The fix requires moving proof verification earlier in the processing pipeline or implementing resource-bounded processing with early abort on proof failure.

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L738-748)
```rust
        if request.use_compression && !storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested compressed data, but the response was uncompressed! Response: {:?}",
                storage_response.get_label()
            )));
        } else if !request.use_compression && storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested uncompressed data, but the response was compressed! Response: {:?}",
                storage_response.get_label()
            )));
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L757-760)
```rust
                    context
                        .response_callback
                        .notify_bad_response(ResponseError::InvalidPayloadDataType);
                    Err(err.into())
```

**File:** state-sync/storage-service/types/src/responses.rs (L97-110)
```rust
    pub fn get_data_response(&self) -> Result<DataResponse, Error> {
        match self {
            StorageServiceResponse::CompressedResponse(_, compressed_data) => {
                let raw_data = aptos_compression::decompress(
                    compressed_data,
                    CompressionClient::StateSync,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )?;
                let data_response = bcs::from_bytes::<DataResponse>(&raw_data)
                    .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
                Ok(data_response)
            },
            StorageServiceResponse::RawResponse(data_response) => Ok(data_response.clone()),
        }
```

**File:** state-sync/storage-service/types/src/responses.rs (L396-431)
```rust
impl TryFrom<StorageServiceResponse> for (TransactionListWithProofV2, LedgerInfoWithSignatures) {
    type Error = crate::responses::Error;

    fn try_from(response: StorageServiceResponse) -> crate::Result<Self, Self::Error> {
        let data_response = response.get_data_response()?;
        match data_response {
            DataResponse::NewTransactionsWithProof((
                transaction_list_with_proof,
                ledger_info_with_signatures,
            )) => Ok((
                TransactionListWithProofV2::new_from_v1(transaction_list_with_proof),
                ledger_info_with_signatures,
            )),
            DataResponse::NewTransactionDataWithProof(response) => {
                if let TransactionDataResponseType::TransactionData =
                    response.transaction_data_response_type
                {
                    if let Some(transaction_list_with_proof_v2) =
                        response.transaction_list_with_proof
                    {
                        return Ok((
                            transaction_list_with_proof_v2,
                            response.ledger_info_with_signatures,
                        ));
                    }
                }
                Err(Error::UnexpectedResponseError(
                    "new_transaction_list_with_proof is empty".into(),
                ))
            },
            _ => Err(Error::UnexpectedResponseError(format!(
                "expected new_transactions_with_proof, found {}",
                data_response.get_label()
            ))),
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L299-358)
```rust
    fn transform_client_response_into_notification(
        &mut self,
        client_request: &DataClientRequest,
        client_response_payload: ResponsePayload,
        notification_id_generator: Arc<U64IdGenerator>,
    ) -> Result<Option<DataNotification>, Error> {
        // Update the metrics for the number of received items
        update_response_chunk_size_metrics(client_request, &client_response_payload);

        // Handle and transform the response
        match client_request {
            StateValuesWithProof(request) => {
                // Verify the client request indices
                verify_client_request_indices(
                    self.next_stream_index,
                    request.start_index,
                    request.end_index,
                )?;

                // Identify the last received state index and bound it appropriately
                let last_received_index = match &client_response_payload {
                    ResponsePayload::StateValuesWithProof(state_values_with_proof) => {
                        // Verify that we received at least one state value
                        if state_values_with_proof.raw_values.is_empty() {
                            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                                "Received an empty state values response! Request: {:?}",
                                client_request
                            )));
                        }

                        // Get the last received state index
                        state_values_with_proof.last_index
                    },
                    _ => invalid_response_type!(client_response_payload),
                };
                let last_received_index =
                    bound_by_range(last_received_index, request.start_index, request.end_index);

                // Update the next stream index
                self.next_stream_index = last_received_index.checked_add(1).ok_or_else(|| {
                    Error::IntegerOverflow("Next stream index has overflown!".into())
                })?;

                // Check if the stream is complete
                let last_stream_index = self
                    .get_number_of_states()?
                    .checked_sub(1)
                    .ok_or_else(|| Error::IntegerOverflow("End index has overflown!".into()))?;
                if last_received_index >= last_stream_index {
                    self.stream_is_complete = true;
                }

                // Create a new data notification
                let data_notification = create_data_notification(
                    notification_id_generator,
                    client_response_payload,
                    None,
                    self.clone().into(),
                )?;
                return Ok(Some(data_notification));
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L292-298)
```rust
        // Verify the given proof ledger info
        self.verify_proof_ledger_info(
            consensus_sync_request.clone(),
            notification_metadata.notification_id,
            &ledger_info_with_signatures,
        )
        .await?;
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L453-465)
```rust
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
        {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::PayloadProofFailed,
            )))
            .await?;
            Err(error)
        } else {
            Ok(())
        }
```

**File:** state-sync/aptos-data-client/src/error.rs (L57-60)
```rust
impl From<aptos_storage_service_types::responses::Error> for Error {
    fn from(error: aptos_storage_service_types::responses::Error) -> Self {
        Self::InvalidResponse(error.to_string())
    }
```

**File:** state-sync/aptos-data-client/src/interface.rs (L183-187)
```rust
pub enum ResponseError {
    InvalidData,
    InvalidPayloadDataType,
    ProofVerificationError,
}
```
