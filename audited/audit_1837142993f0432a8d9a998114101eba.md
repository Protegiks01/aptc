# Audit Report

## Title
Unauthenticated Information Disclosure of Network Topology Enables Targeted Validator Attacks

## Summary
The Aptos inspection service exposes sensitive network topology information including validator IP addresses, peer connections, and network configurations through unauthenticated HTTP endpoints. On non-mainnet networks (testnet, devnet), these endpoints are automatically enabled, allowing any attacker to map the entire validator network and launch targeted attacks.

## Finding Description

The inspection service provides two critical endpoints that leak network topology information without authentication:

1. **`/configuration` endpoint** exposes the full `NodeConfig` via `handle_configuration_request()`: [1](#0-0) 

This endpoint exposes `NodeConfig` which contains:
- `validator_network` and `full_node_networks` with `NetworkConfig` structures [2](#0-1) 

Each `NetworkConfig` contains sensitive information:
- `listen_address`: The IP and port the node listens on
- `seed_addrs`: HashMap of peer IDs to their network addresses
- `seeds`: Initial peer set with addresses
- Connection limits and network parameters [3](#0-2) 

2. **`/peer_information` endpoint** exposes detailed peer network data: [4](#0-3) 

This includes `ConnectionMetadata` with actual peer IP addresses: [5](#0-4) 

And trusted peers (validator set & seeds) with their addresses: [6](#0-5) 

Where `Peer` struct contains network addresses: [7](#0-6) 

**Critical Security Flaws:**

1. **No Authentication**: The inspection service has zero authentication checks: [8](#0-7) 

2. **Auto-Enabled on Non-Mainnet**: For testnet/devnet, endpoints are automatically enabled unless explicitly disabled: [9](#0-8) 

3. **Exposed on All Interfaces**: Default configuration binds to 0.0.0.0:9101: [10](#0-9) 

While mainnet validators are protected by a sanitizer: [11](#0-10) 

**Attack Path:**
1. Attacker discovers a testnet/devnet validator's inspection service (port 9101)
2. Issues `GET http://validator-ip:9101/configuration` or `/peer_information`
3. Extracts complete network topology: all validator IPs, ports, peer relationships
4. Launches targeted attacks:
   - **DDoS specific validators** to disrupt consensus (needs <1/3 offline for liveness failure)
   - **Network partitioning** by disrupting connections between validator clusters
   - **Eclipse attacks** by understanding and manipulating peer connections
   - **Targeted exploitation** of validators with known vulnerabilities at specific IPs

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: Attackers can identify and DDoS specific validators, causing performance degradation that impacts consensus participation and block production.

2. **Significant Protocol Violations**: Network partitioning attacks enabled by topology knowledge can violate consensus safety assumptions by creating network splits that prevent proper quorum formation.

3. **Consensus Disruption Risk**: While not a direct consensus safety violation, enabling targeted attacks on <1/3 of validators can cause liveness failures, and attacks on >1/3 could theoretically enable safety violations if combined with other exploits.

4. **Widespread Exposure**: All testnet/devnet validators and fullnodes are vulnerable by default unless operators explicitly disable these endpoints.

The exposed information includes IP addresses, ports, peer relationships, and network topology—exactly the data needed to plan sophisticated network-level attacks against the validator set.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Exploit**: Requires only a simple HTTP GET request with no authentication
2. **Enabled by Default**: Automatically enabled on all non-mainnet networks
3. **Public Exposure**: Many nodes likely have port 9101 publicly accessible
4. **Valuable Information**: Network topology data is extremely valuable for attackers
5. **Wide Attack Surface**: Affects all testnet validators, devnet validators, and fullnodes

The only barrier is network-level firewalling, which many operators may not implement for debugging/monitoring services.

## Recommendation

**Immediate Actions:**

1. **Add Authentication**: Implement token-based or IP whitelist authentication similar to the admin service:
```rust
// In InspectionServiceConfig
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    // NEW: Add authentication
    pub require_authentication: bool,
    pub authentication_token_sha256: Option<String>,
    pub allowed_ips: Vec<String>,
}
```

2. **Disable by Default**: Change the config optimizer to NOT auto-enable sensitive endpoints:
```rust
// In inspection_service_config.rs, modify optimize() to NOT enable by default
// Remove the auto-enabling logic for non-mainnet, require explicit opt-in
```

3. **Bind to Localhost by Default**: Change default address from 0.0.0.0 to 127.0.0.1:
```rust
fn default() -> InspectionServiceConfig {
    InspectionServiceConfig {
        address: "127.0.0.1".to_string(), // Changed from 0.0.0.0
        port: 9101,
        expose_configuration: false,
        expose_identity_information: false,  // Changed from true
        expose_peer_information: false,      // Changed from true
        expose_system_information: false,    // Changed from true
    }
}
```

4. **Redact Sensitive Fields**: Even with authentication, redact IP addresses and ports from responses:
```rust
// Modify handle_configuration_request() to sanitize network addresses
let sanitized_config = sanitize_network_addresses(&node_config);
let encoded_configuration = format!("{:?}", sanitized_config);
```

## Proof of Concept

**Setup: Deploy a testnet validator with default configuration**

**Step 1: Query the configuration endpoint**
```bash
# Discover exposed network topology
curl http://testnet-validator-ip:9101/configuration

# Response will contain:
# validator_network: Some(NetworkConfig {
#     listen_address: /ip4/1.2.3.4/tcp/6180,
#     seed_addrs: {
#         PeerId(abcd...): [/ip4/5.6.7.8/tcp/6180],
#         PeerId(efgh...): [/ip4/9.10.11.12/tcp/6180],
#     },
#     ...
# })
```

**Step 2: Query peer information endpoint**
```bash
curl http://testnet-validator-ip:9101/peer_information

# Response will contain:
# Connection metadata for each peer:
#   - Peer: PeerId(abcd...), connection metadata: {"addr":"/ip4/5.6.7.8/tcp/6180",...}
# Trusted peers (validator set & seeds):
#   - Network: Validator
#     - Peer: PeerId(abcd...), peer information: Peer { addresses: [/ip4/5.6.7.8/tcp/6180], ... }
```

**Step 3: Exploitation**
```python
#!/usr/bin/env python3
import requests
import re

def discover_validator_network(inspection_service_url):
    """Map the entire validator network topology"""
    
    # Get peer information
    peer_info = requests.get(f"{inspection_service_url}/peer_information").text
    
    # Extract all IP addresses and ports
    ip_pattern = r'/ip4/([\d.]+)/tcp/(\d+)'
    peers = re.findall(ip_pattern, peer_info)
    
    print(f"[+] Discovered {len(peers)} validator IPs:")
    for ip, port in peers:
        print(f"    - {ip}:{port}")
    
    # Now launch targeted attacks on specific validators
    # (attack code omitted for responsible disclosure)
    
    return peers

# Example usage
validators = discover_validator_network("http://testnet-validator:9101")
# Attack the first 5 validators to disrupt consensus...
```

**Note**: This PoC demonstrates the information disclosure. Actual attacks (DDoS, network partitioning) are out of scope but become trivial once network topology is known.

---

## Notes

- **Mainnet validators are protected** by the sanitizer that prevents enabling the configuration endpoint, but peer information endpoint could still be enabled manually
- **All testnet/devnet nodes are vulnerable** by default due to the auto-enable optimizer
- **Fullnodes are also affected**, potentially exposing private network deployments
- This is a **design flaw**, not a simple implementation bug—it requires architectural changes to fix properly

### Citations

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/node_config.rs (L57-89)
```rust
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
    pub jwk_consensus: JWKConsensusConfig,
    #[serde(default)]
    pub logger: LoggerConfig,
    #[serde(default)]
    pub mempool: MempoolConfig,
    #[serde(default)]
    pub netbench: Option<NetbenchConfig>,
    #[serde(default)]
    pub node_startup: NodeStartupConfig,
    #[serde(default)]
    pub peer_monitoring_service: PeerMonitoringServiceConfig,
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
    #[serde(default)]
    pub state_sync: StateSyncConfig,
    #[serde(default)]
    pub storage: StorageConfig,
    #[serde(default)]
    pub transaction_filters: TransactionFiltersConfig,
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
```

**File:** config/src/config/network_config.rs (L55-126)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
    // TODO: Add support for multiple listen/advertised addresses in config.
    /// The address that this node is listening on for new connections.
    pub listen_address: NetworkAddress,
    /// Select this to enforce that both peers should authenticate each other, otherwise
    /// authentication only occurs for outgoing connections.
    pub mutual_authentication: bool,
    /// ID of the network to differentiate between networks
    pub network_id: NetworkId,
    /// Number of threads to run for networking
    pub runtime_threads: Option<usize>,
    /// Overrides for the size of the inbound and outbound buffers for each peer.
    /// NOTE: The defaults are None, so socket options are not called. Change to Some values with
    /// caution. Experiments have shown that relying on Linux's default tcp auto-tuning can perform
    /// better than setting these. In particular, for larger values to take effect, the
    /// `net.core.rmem_max` and `net.core.wmem_max` sysctl values may need to be increased. On a
    /// vanilla GCP machine, these are set to 212992. Without increasing the sysctl values and
    /// setting a value will constrain the buffer size to the sysctl value. (In contrast, default
    /// auto-tuning can increase beyond these values.)
    pub inbound_rx_buffer_size_bytes: Option<u32>,
    pub inbound_tx_buffer_size_bytes: Option<u32>,
    pub outbound_rx_buffer_size_bytes: Option<u32>,
    pub outbound_tx_buffer_size_bytes: Option<u32>,
    /// Addresses of initial peers to connect to. In a mutual_authentication network,
    /// we will extract the public keys from these addresses to set our initial
    /// trusted peers set.  TODO: Replace usage in configs with `seeds` this is for backwards compatibility
    pub seed_addrs: HashMap<PeerId, Vec<NetworkAddress>>,
    /// The initial peers to connect to prior to onchain discovery
    pub seeds: PeerSet,
    /// The maximum size of an inbound or outbound request frame
    pub max_frame_size: usize,
    /// Enables proxy protocol on incoming connections to get original source addresses
    pub enable_proxy_protocol: bool,
    /// Interval to send healthcheck pings to peers
    pub ping_interval_ms: u64,
    /// Timeout until a healthcheck ping is rejected
    pub ping_timeout_ms: u64,
    /// Number of failed healthcheck pings until a peer is marked unhealthy
    pub ping_failures_tolerated: u64,
    /// Maximum number of outbound connections, limited by ConnectivityManager
    pub max_outbound_connections: usize,
    /// Maximum number of outbound connections, limited by PeerManager
    pub max_inbound_connections: usize,
    /// Inbound rate limiting configuration, if not specified, no rate limiting
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
    /// The maximum size of an inbound or outbound message (it may be divided into multiple frame)
    pub max_message_size: usize,
    /// The maximum number of parallel message deserialization tasks that can run (per application)
    pub max_parallel_deserialization_tasks: Option<usize>,
    /// Whether or not to enable latency aware peer dialing
    pub enable_latency_aware_dialing: bool,
}
```

**File:** config/src/config/network_config.rs (L457-464)
```rust
/// Represents a single seed configuration for a seed peer
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default)]
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L20-38)
```rust
/// Handles a new peer information request
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L103-169)
```rust
/// A simple helper function that handles each endpoint request
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```
