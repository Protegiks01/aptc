# Audit Report

## Title
State Sync Bandwidth Exhaustion via Oversized Response Exploitation by Malicious Validators

## Summary
Malicious validators can bypass state sync chunk size limits and send responses up to 64 MiB (MAX_MESSAGE_SIZE) instead of the configured 20-40 MiB limits. The client-side lacks validation of response sizes against advertised limits, and validators are exempt from the request moderator that would otherwise ban misbehaving peers. This enables bandwidth exhaustion attacks that significantly slow down node synchronization.

## Finding Description

The vulnerability exists in the state sync protocol's lack of client-side response size validation. The system establishes multiple size limits:

1. The client advertises `max_response_bytes` (20 MiB for v2 requests) in requests to servers [1](#0-0) 

2. The server is configured to limit responses to 40 MiB for v2 requests [2](#0-1) 

3. The network layer permits messages up to 64 MiB [3](#0-2) 

However, the client does not validate received response sizes against the advertised `max_response_bytes` limit. The `Error::DataIsTooLarge` error variant exists but is never raised [4](#0-3) , indicating missing validation logic.

A malicious validator can exploit this by:
1. Receiving a state sync request specifying `max_response_bytes: 20 MiB`
2. Ignoring this limit and sending responses up to 64 MiB
3. The network layer's OutboundStream validates only that messages don't exceed `max_message_size` (64 MiB) [5](#0-4) 
4. The receiving client processes the oversized response without validation
5. If the data is invalid, the client must download, deserialize, validate, and reject it—wasting bandwidth

Critically, validators are exempt from the request moderator that bans misbehaving peers. The moderator only ignores peers on the public network [6](#0-5) , allowing malicious validators to repeat this attack indefinitely without consequences.

Additionally, network rate limiting is disabled by default [7](#0-6) , providing no bandwidth protection.

With 6-12 concurrent state sync requests [8](#0-7) , a malicious validator can force a syncing node to process 384-768 MiB of oversized (and potentially invalid) data simultaneously, causing significant bandwidth exhaustion and synchronization delays.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns." 

A malicious validator can:
- Force syncing nodes to consume 3.2× more bandwidth per response (64 MiB vs 20 MiB)
- With 12 concurrent requests, this totals 768 MiB vs the expected 240 MiB (3.2× amplification)
- Repeat this attack indefinitely without being banned
- Significantly delay state synchronization for validators, VFNs, and fullnodes
- Degrade network performance during critical synchronization periods (e.g., node restarts, new node bootstrapping)

While this doesn't completely prevent synchronization, it causes measurable performance degradation that affects node operations and network health.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
- Requires only modification of validator node code to bypass server-side size limits
- No cryptographic attacks or complex protocol manipulation needed
- Affects all nodes syncing from the malicious validator
- Detection is difficult as responses appear valid at the network layer

The primary barrier is that the attacker must operate a validator node, but this is explicitly within the threat model for Byzantine fault tolerance assumptions (up to 1/3 malicious validators).

## Recommendation

Implement client-side validation of response sizes against advertised limits:

**In `state-sync/aptos-data-client/src/client.rs`**, add validation after receiving responses in the `send_request_to_peer_and_decode` method:

```rust
// After receiving storage_response, validate size for v2 requests
if let Some(max_bytes) = request.get_max_response_bytes() {
    let response_size = bcs::serialized_size(&storage_response)
        .map_err(|e| Error::UnexpectedErrorEncountered(e.to_string()))?;
    
    if response_size as u64 > max_bytes {
        // Report malicious peer
        context.response_callback.notify_bad_response(
            ResponseError::InvalidPayloadDataType
        );
        return Err(Error::DataIsTooLarge(format!(
            "Response size {} exceeds advertised limit {} bytes",
            response_size, max_bytes
        )));
    }
}
```

Additionally:
1. Enable network rate limiting by default for state sync traffic
2. Consider applying request moderator logic to validators (with higher thresholds)
3. Add metrics to track response size violations per peer

## Proof of Concept

**Setup**: Deploy a malicious validator that modifies `state-sync/storage-service/server/src/storage.rs` to ignore chunk size limits:

```rust
// In get_transactions_with_proof_by_size or similar methods
// Malicious validator bypasses max_response_size check:
let malicious_max_size = 64 * 1024 * 1024; // Force 64 MiB
// ... continue with this inflated limit instead of configured max_response_size
```

**Exploitation**:
1. Start a fullnode syncing from the malicious validator
2. Monitor bandwidth consumption: `iftop` or network metrics
3. Observe 64 MiB responses instead of expected 20-40 MiB
4. Measure synchronization time increase (expected: 50-200% slower depending on network conditions)
5. Verify the malicious validator is never banned: check `IGNORED_PEER_COUNT` metric remains 0

**Expected outcome**: The syncing node consumes 3.2× more bandwidth, synchronization slows significantly, and the malicious validator faces no consequences despite repeatedly violating advertised size limits.

### Citations

**File:** config/src/config/state_sync_config.rs (L20-20)
```rust
const CLIENT_MAX_MESSAGE_SIZE_V2: usize = 20 * 1024 * 1024; // 20 MiB (used for v2 data requests)
```

**File:** config/src/config/state_sync_config.rs (L21-21)
```rust
const SERVER_MAX_MESSAGE_SIZE_V2: usize = 40 * 1024 * 1024; // 40 MiB (used for v2 data requests)
```

**File:** config/src/config/state_sync_config.rs (L30-31)
```rust
const MAX_CONCURRENT_REQUESTS: u64 = 6;
const MAX_CONCURRENT_STATE_REQUESTS: u64 = 6;
```

**File:** network/framework/src/constants.rs (L21-21)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** state-sync/aptos-data-client/src/error.rs (L14-15)
```rust
    #[error("The requested data is too large: {0}")]
    DataIsTooLarge(String),
```

**File:** network/framework/src/protocols/stream/mod.rs (L266-273)
```rust
        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );
```

**File:** state-sync/storage-service/server/src/moderator.rs (L54-58)
```rust
        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
```

**File:** config/src/config/network_config.rs (L158-159)
```rust
            inbound_rate_limit_config: None,
            outbound_rate_limit_config: None,
```
