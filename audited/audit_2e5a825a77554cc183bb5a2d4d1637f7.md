# Audit Report

## Title
Script Verification DoS via Missing Global Cache and Unmetered Verification

## Summary
Scripts are not cached in `VERIFIED_MODULES_CACHE` unlike modules, and script bytecode verification is not gas-metered. An attacker can repeatedly submit the same computationally-expensive script across multiple blocks, causing validators to re-verify the same bytecode without cache hits, leading to CPU exhaustion and validator slowdown.

## Finding Description
The Aptos Move VM implements different caching strategies for modules versus scripts:

**Modules** benefit from global persistent caching across blocks: [1](#0-0) 

Module verification checks `VERIFIED_MODULES_CACHE` before performing expensive bytecode verification and caches the result globally.

**Scripts** only use per-block ephemeral caching: [2](#0-1) 

Scripts undergo full bytecode verification on every execution without checking or updating `VERIFIED_MODULES_CACHE`. The script verification is called without gas metering parameters.

During block execution, each block creates a fresh `MVHashMap` with an empty script cache: [3](#0-2) 

This means identical scripts submitted across different blocks will be fully re-verified each time. While per-block caching exists via `MVHashMap.script_cache`, this provides no protection across blocks: [4](#0-3) 

**Attack Flow:**
1. Attacker crafts a syntactically valid but computationally-expensive-to-verify script (complex control flow, deep nesting, maximum allowed instructions)
2. Submits transactions containing this script across multiple blocks with incrementing sequence numbers
3. Each transaction bypasses mempool deduplication (different hashes due to sequence numbers)
4. Mempool validation does NOT verify script bytecode - only runs prologue checks
5. During block execution, each transaction triggers full script verification via `validate_and_execute_script()`: [5](#0-4) 

6. Script loading and verification happens through the loader: [6](#0-5) 

7. Verification is computationally expensive but NOT gas-metered (no gas meter parameter in `build_locally_verified_script`)

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - script verification consumes significant CPU without proper gas accounting.

## Impact Explanation
**Medium Severity** - Validator node slowdowns per Aptos bug bounty criteria.

- Validators must perform expensive bytecode verification (stack safety, type checking, reference safety, control flow analysis) for each script submission across blocks
- Attack can cause measurable CPU exhaustion on validator nodes
- No consensus or fund loss, but degrades network performance
- Economic cost to attacker is lower than CPU cost inflicted (verification unmetered)
- Impacts all validators processing the blocks containing attack transactions

## Likelihood Explanation
**High Likelihood** - Attack is straightforward to execute:

- No special permissions required
- Scripts are still supported transaction types in Aptos
- Attacker only needs funds for transaction gas fees
- Attack can be sustained across multiple blocks
- Verification complexity limits are high enough to cause significant CPU load
- No rate limiting specific to script verification exists

The economic barrier (transaction fees) provides some mitigation but does not fully prevent the attack if verification cost >> execution cost.

## Recommendation
Implement global caching for verified scripts similar to modules:

1. **Add script verification to `VERIFIED_MODULES_CACHE`:**
   - Modify `build_locally_verified_script()` to accept and check `script_hash` parameter
   - Check cache before verification: `if !VERIFIED_MODULES_CACHE.contains(script_hash)`
   - Store result after verification: `VERIFIED_MODULES_CACHE.put(script_hash)`

2. **Add gas metering for script verification:**
   - Make `build_locally_verified_script()` accept a gas meter parameter
   - Charge gas proportional to bytecode size and complexity
   - Ensure verification cost is properly accounted in transaction fees

3. **Implement verification cost limits:**
   - Add maximum script complexity thresholds
   - Charge additional gas for complex scripts
   - Consider deprecating script payloads in favor of entry functions (already in progress)

## Proof of Concept

```rust
// Pseudo-Rust PoC demonstrating the attack
use aptos_types::transaction::Script;
use move_binary_format::file_format::CompiledScript;

fn generate_expensive_script() -> Script {
    // Create a script with maximum allowed complexity:
    // - Deep nested loops
    // - Maximum instruction count  
    // - Complex type signatures
    // - Many local variables
    // This will be slow to verify but can fail execution quickly
    
    let expensive_bytecode = create_complex_but_valid_bytecode();
    Script::new(expensive_bytecode, vec![], vec![])
}

fn dos_attack() {
    let script = generate_expensive_script();
    
    // Submit 1000 transactions across multiple blocks
    // Each with same script but different sequence number
    for seq_num in 0..1000 {
        let txn = create_transaction(
            sender_account,
            seq_num,
            script.clone(),  // Same script each time
            gas_price,
            max_gas,
        );
        
        submit_transaction(txn);
        // Wait for block boundary to ensure fresh MVHashMap
        wait_for_next_block();
    }
    
    // Each transaction causes full verification without cache hits
    // Validators waste CPU re-verifying identical bytecode 1000 times
}
```

**Move Test Scenario:**
```move
// Create a script with deep nesting to maximize verification time
script {
    fun main() {
        // Nested control flow to stress verifier
        let i = 0;
        while (i < 100) {
            if (i % 2 == 0) {
                while (i < 50) {
                    if (i % 3 == 0) {
                        i = i + 1;
                    } else {
                        i = i + 2;
                    };
                };
            } else {
                i = i + 1;
            };
        };
        // Script succeeds but verification was expensive
    }
}
```

Submit this script repeatedly across blocks and measure validator CPU usage to confirm the DoS effect.

## Notes
The vulnerability exists because script verification happens during execution (not mempool validation), is not gas-metered, and lacks global caching across blocks. While per-block caching prevents intra-block attacks, the ephemeral nature of `MVHashMap` leaves validators vulnerable to cross-block script verification DoS attacks.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L141-150)
```rust
    pub fn build_locally_verified_script(
        &self,
        compiled_script: Arc<CompiledScript>,
    ) -> VMResult<LocallyVerifiedScript> {
        move_bytecode_verifier::verify_script_with_config(
            &self.vm_config().verifier_config,
            compiled_script.as_ref(),
        )?;
        Ok(LocallyVerifiedScript(compiled_script))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L1867-1867)
```rust
        let mut versioned_cache = MVHashMap::new();
```

**File:** aptos-move/mvhashmap/src/lib.rs (L46-49)
```rust
    module_cache:
        SyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, Option<TxnIndex>>,
    script_cache: SyncScriptCache<[u8; 32], CompiledScript, Script>,
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1051-1060)
```rust
                    self.validate_and_execute_script(
                        session,
                        serialized_signers,
                        code_storage,
                        gas_meter,
                        traversal_context,
                        script,
                        trace_recorder,
                    )
                })?;
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L147-149)
```rust
        let locally_verified_script = self
            .runtime_environment()
            .build_locally_verified_script(deserialized_script)?;
```
