# Audit Report

## Title
Native Function Panic in `from_u64_internal` Can Crash Validators

## Summary

The `from_u64_internal` native function in the algebra cryptography module uses `assert_eq!` to validate the number of type arguments, which will panic and crash validator nodes if triggered. The panic is not caught by the Move VM during execution, violating defense-in-depth principles. While bytecode verification should prevent this condition, a verifier bug or bypass would enable an attacker to crash all validators executing a malicious transaction. [1](#0-0) 

## Finding Description

The `from_u64_internal` function uses `assert_eq!(1, ty_args.len())` which will panic if the number of type arguments is not exactly 1. This violates the established pattern for native function error handling in Aptos, where invariant violations should return `SafeNativeError::InvariantViolation` instead of panicking.

The Move declaration confirms this function expects exactly one type parameter: [2](#0-1) 

**Attack Path:**

1. Attacker crafts a Move module that calls `from_u64_internal` with an incorrect number of type arguments (e.g., 0 or 2)
2. If this module bypasses bytecode verification (due to a verifier bug, or during testing with `VerificationScope::Nothing`), it gets published
3. When the module executes, the native function is invoked with wrong type argument count
4. The `assert_eq!` panics in the native function
5. Native functions are called directly without `catch_unwind` protection: [3](#0-2) 

6. The crash handler checks if unwinding is allowed based on VMState: [4](#0-3) 

7. Since native execution occurs during RUNTIME (not VERIFIER or DESERIALIZER state), the panic kills the validator process

**Invariant Broken:** Deterministic Execution - validators crash instead of gracefully handling the error, causing availability issues.

**Contrast with Proper Pattern:**

Other native functions correctly handle this scenario by returning errors instead of panicking: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:
- **Validator node slowdowns/crashes** - A single malicious transaction could crash all validators that execute it
- **Significant protocol violation** - Breaks the expectation that native functions handle errors gracefully

The impact is amplified because:
1. All validators executing the malicious transaction would crash simultaneously
2. The network would experience liveness degradation until validators restart
3. This violates the defense-in-depth principle - native functions should never bring down validators

While production bytecode verification should prevent invalid type arguments from reaching native functions: [6](#0-5) 

The defense-in-depth principle requires native functions to handle all potential inputs gracefully, even those that "should never happen."

## Likelihood Explanation

**Likelihood: Low-Medium**

The vulnerability requires one of:
1. **Verifier bug** allowing incorrect type argument counts to pass validation
2. **Verification bypass** through undiscovered means
3. **Testing/development scenarios** where `VerificationScope::Nothing` is used

While production verification is robust, the security principle of "assume verification can fail" is critical. Historical precedent shows that verification bugs have been found in complex type systems, making this a realistic concern.

The impact-likelihood combination justifies High severity classification.

## Recommendation

Replace the `assert_eq!` with proper error handling that returns `SafeNativeError::InvariantViolation`:

```rust
pub fn from_u64_internal(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Replace panic with graceful error
    if ty_args.len() != 1 {
        return Err(SafeNativeError::InvariantViolation(
            PartialVMError::new_invariant_violation(
                "from_u64_internal expects exactly 1 type argument"
            )
        ));
    }
    
    let structure_opt = structure_from_ty_arg!(context, &ty_args[0]);
    abort_unless_arithmetics_enabled_for_structure!(context, structure_opt);
    // ... rest of function
}
```

The error handling in `SafeNativeBuilder::make_native` will properly convert this to a VM error: [7](#0-6) 

**Additional Recommendations:**
1. Audit all other algebra native functions for similar panic patterns
2. Add fuzzing tests that bypass verification to test native function robustness
3. Consider a linting rule that flags `assert!`/`assert_eq!` in native functions

## Proof of Concept

A test demonstrating the issue (conceptual, requires test infrastructure):

```rust
#[test]
#[should_panic(expected = "assertion failed")]
fn test_from_u64_internal_wrong_type_args_panics() {
    // Setup native context
    let mut context = create_test_safe_native_context();
    
    // Call with 0 type arguments (should panic)
    let ty_args: Vec<Type> = vec![];
    let args = VecDeque::from([Value::u64(42)]);
    
    // This will panic instead of returning an error
    let _ = from_u64_internal(&mut context, &ty_args, args);
    // Validator would crash here
}

#[test]
fn test_from_u64_internal_wrong_type_args_returns_error() {
    // After fix, this should return error instead of panic
    let mut context = create_test_safe_native_context();
    let ty_args: Vec<Type> = vec![];
    let args = VecDeque::from([Value::u64(42)]);
    
    let result = from_u64_internal(&mut context, &ty_args, args);
    assert!(matches!(result, Err(SafeNativeError::InvariantViolation(_))));
}
```

To demonstrate the full attack path would require crafting a Move module that bypasses the bytecode verifier's type argument validation, which depends on finding a specific verifier bug. However, the core issue—that panics in native functions crash validators—is independently verifiable through the code paths documented above.

## Notes

This vulnerability represents a defense-in-depth failure rather than a direct exploit in production configuration. However, the Aptos security model should ensure that even if verification fails, native functions handle errors gracefully without crashing validator processes. The fix is straightforward and aligns with the error handling pattern used throughout the codebase.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/new.rs (L30-36)
```rust
pub fn from_u64_internal(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(1, ty_args.len());
    let structure_opt = structure_from_ty_arg!(context, &ty_args[0]);
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move (L316-316)
```text
    native fun from_u64_internal<S>(value: u64): u64;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1106-1106)
```rust
        let result = native_function(&mut native_context, ty_args, args)?;
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** aptos-move/framework/move-stdlib/src/natives/reflect.rs (L35-40)
```rust
    debug_assert!(ty_args.len() == 1);
    let Some(fun_ty) = ty_args.first() else {
        return Err(SafeNativeError::InvariantViolation(
            PartialVMError::new_invariant_violation("wrong number of type arguments"),
        ));
    };
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-156)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L150-151)
```rust
                    // TODO(Gas): Check if err is indeed an invariant violation.
                    InvariantViolation(err) => Err(err),
```
