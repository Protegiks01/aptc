# Audit Report

## Title
Bytecode Verifier Gap: Unchecked LocalIndex in Access Specifier Parameters Causes Runtime Verifier Invariant Violation

## Summary
The Move bytecode verifier does not validate that `LocalIndex` values in access specifiers' `AddressSpecifier::Parameter` variants are within bounds of the function's parameter count. This allows malicious bytecode to pass verification and trigger `VERIFIER_INVARIANT_VIOLATION` errors at runtime during access specifier specialization.

## Finding Description

The vulnerability exists across three components that I have verified in the codebase:

**1. Missing Verification in Bounds Checker**

The `check_function_handle` method validates module, name, parameters, and return signatures but completely ignores the `access_specifiers` field: [1](#0-0) 

Notably, there is no mention of `access_specifiers` validation anywhere in the bounds checking code.

**2. Unchecked Storage in Access Specifier Loader**

The loader creates `AddressSpecifier::Eval` directly from bytecode without validating parameter bounds: [2](#0-1) 

At line 109, `AddressSpecifier::Eval(fun, *param)` is created with the parameter index directly from the file format.

**3. Runtime Failure Path**

During function entry, access specifier specialization is triggered: [3](#0-2) 

Which calls the specialization method: [4](#0-3) 

The Frame's implementation calls copy_loc: [5](#0-4) 

When the index is out of bounds, copy_loc returns an error: [6](#0-5) 

This error is VERIFIER_INVARIANT_VIOLATION: [7](#0-6) 

**Attack Scenario:**
1. Attacker crafts bytecode (using tools like move-asm) with a function having N parameters
2. The function's access specifier contains `AddressSpecifier::Parameter(N, None)` (out of bounds, valid range is 0 to N-1)
3. Bytecode passes verification because the bounds checker doesn't validate access specifier LocalIndex
4. Module is published on-chain
5. When any transaction calls this function, `enter_function` triggers specialization
6. Runtime error with `VERIFIER_INVARIANT_VIOLATION` occurs

The resource access control feature is enabled by default on mainnet: [8](#0-7) 

## Impact Explanation

**Severity: MEDIUM**

This qualifies as **Medium Severity** under Aptos bug bounty criteria:

1. **Protocol Violation:** The occurrence of `VERIFIER_INVARIANT_VIOLATION` at runtime violates the Move VM's fundamental guarantee that verified bytecode should never fail with verifier errors during execution. This represents a gap in the bytecode verifier.

2. **Limited Denial of Service:** Functions with malicious access specifiers become uncallable. However, this requires an attacker to successfully publish crafted bytecode, and the impact is limited to those specific functions.

3. **No Consensus Impact:** Importantly, all validators would encounter the same error deterministically when executing the transaction. There is no consensus divergence risk - all nodes would fail identically and produce the same state root.

4. **No Fund Loss:** This vulnerability does not enable theft of funds, unauthorized minting, or bypass of transfer restrictions.

The issue represents a "Limited Protocol Violation" requiring manual intervention (republishing fixed modules), but does not meet the HIGH severity criteria of "Validator Node Slowdowns" or broader network impact.

## Likelihood Explanation

**Likelihood: MEDIUM**

1. **Moderate Barrier:** While any user can publish Move modules, crafting malicious bytecode requires using bytecode manipulation tools (like move-asm) rather than the standard Move compiler, which likely generates correct bounds.

2. **Detection Difficulty:** The malicious module passes verification, making it difficult for defenders to prevent deployment.

3. **Limited Scope:** The resource access control feature is relatively new and not yet widely adopted. Most existing Move code does not use access specifiers, limiting immediate exposure.

4. **Deterministic Failure:** The bug triggers consistently when the function is called, but all validators fail identically, preventing consensus-level exploitation.

## Recommendation

Add bounds validation for access specifier LocalIndex values in the `check_function_handle` method:

```rust
fn check_function_handle(&self, function_handle: &FunctionHandle) -> PartialVMResult<()> {
    check_bounds_impl(self.view.module_handles(), function_handle.module)?;
    check_bounds_impl(self.view.identifiers(), function_handle.name)?;
    check_bounds_impl(self.view.signatures(), function_handle.parameters)?;
    check_bounds_impl(self.view.signatures(), function_handle.return_)?;
    
    // Validate access specifiers
    if let Some(access_specs) = &function_handle.access_specifiers {
        let param_count = self.view.signatures()
            .get(function_handle.parameters.into_index())
            .map(|sig| sig.0.len())
            .unwrap_or(0);
        
        for spec in access_specs {
            if let AddressSpecifier::Parameter(local_idx, _) = &spec.address {
                if (*local_idx as usize) >= param_count {
                    return Err(bounds_error(
                        StatusCode::INDEX_OUT_OF_BOUNDS,
                        IndexKind::LocalPool,
                        *local_idx,
                        param_count,
                    ));
                }
            }
        }
    }
    
    // ... rest of validation
}
```

## Proof of Concept

A PoC would require crafting malicious bytecode using Move assembler tools to create a module with an access specifier referencing an out-of-bounds parameter index, then attempting to call that function to trigger the VERIFIER_INVARIANT_VIOLATION.

## Notes

This is a genuine bytecode verifier gap that violates the Move VM's security model. While the immediate security impact is limited (no consensus divergence, no fund loss), it represents a fundamental flaw in the verification system where runtime invariant violations can occur on verified bytecode. The severity is assessed as MEDIUM rather than HIGH because the impact is limited to specific crafted functions and does not affect broader network consensus or fund security.

### Citations

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L238-248)
```rust
    fn check_function_handle(&self, function_handle: &FunctionHandle) -> PartialVMResult<()> {
        check_bounds_impl(self.view.module_handles(), function_handle.module)?;
        check_bounds_impl(self.view.identifiers(), function_handle.name)?;
        check_bounds_impl(self.view.signatures(), function_handle.parameters)?;
        check_bounds_impl(self.view.signatures(), function_handle.return_)?;
        // function signature type parameters must be in bounds to the function type parameters
        let type_param_count = function_handle.type_parameters.len();
        self.check_type_parameters_in_signature(function_handle.parameters, type_param_count)?;
        self.check_type_parameters_in_signature(function_handle.return_, type_param_count)?;
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L89-110)
```rust
        Parameter(param, fun) => {
            let fun = if let Some(idx) = fun {
                let fun_inst = access_table(module.function_instantiations(), idx.0)?;
                let fun_handle = access_table(module.function_handles(), fun_inst.handle.0)?;
                let mod_handle = access_table(module.module_handles(), fun_handle.module.0)?;
                let mod_id = module
                    .safe_module_id_for_handle(mod_handle)
                    .ok_or_else(index_out_of_range)?;
                let mod_name = mod_id.short_str_lossless();
                let fun_name = access_table(module.identifiers(), fun_handle.name.0)?;
                AddressSpecifierFunction::parse(&mod_name, fun_name.as_str()).ok_or_else(|| {
                    PartialVMError::new(StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION)
                        .with_message(format!(
                            "function `{}::{}` not supported for address specifier",
                            mod_name, fun_name
                        ))
                })?
            } else {
                AddressSpecifierFunction::Identity
            };
            Ok(AddressSpecifier::Eval(fun, *param))
        },
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L43-46)
```rust
            // Specialize the functions access specifier and push it on the stack.
            let mut fun_specifier = fun.access_specifier().clone();
            fun_specifier.specialize(env)?;
            self.specifier_stack.push(fun_specifier);
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L232-237)
```rust
    fn specialize(&mut self, env: &impl AccessSpecifierEnv) -> PartialVMResult<()> {
        if let AddressSpecifier::Eval(fun, arg) = self {
            *self = AddressSpecifier::Literal(env.eval_address_specifier_function(*fun, *arg)?)
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L79-87)
```rust
impl AccessSpecifierEnv for Frame {
    fn eval_address_specifier_function(
        &self,
        fun: AddressSpecifierFunction,
        local: LocalIndex,
    ) -> PartialVMResult<AccountAddress> {
        fun.eval(self.locals.copy_loc(local as usize)?)
    }
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2352-2362)
```rust
    pub fn copy_loc(&self, idx: usize) -> PartialVMResult<Value> {
        let locals = self.0.borrow();
        match locals.get(idx) {
            Some(Value::Invalid) => Err(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            )
            .with_message(format!("cannot copy invalid value at index {}", idx))),
            Some(v) => Ok(v.copy_value(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))?),
            None => Err(Self::local_index_out_of_bounds(idx, locals.len())),
        }
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2422-2427)
```rust
    fn local_index_out_of_bounds(idx: usize, num_locals: usize) -> PartialVMError {
        PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION).with_message(format!(
            "local index out of bounds: got {}, len: {}",
            idx, num_locals
        ))
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L245-245)
```rust
            FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL,
```
