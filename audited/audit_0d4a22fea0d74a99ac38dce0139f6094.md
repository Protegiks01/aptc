# Audit Report

## Title
Inconsistent KeyRotation Event Emission Breaks Indexer Tracking and Wallet Recovery

## Summary
Multiple key rotation code paths in the Aptos account module emit different events or no events at all, creating incomplete rotation history for indexers and wallets. Some rotations bypass the `OriginatingAddress` table update entirely, breaking the wallet recovery mechanism. The suggested mitigation function `set_originating_address()` is permanently disabled, leaving no path to reconcile the inconsistency.

## Finding Description

The Aptos account module provides multiple entry functions for rotating authentication keys, but they handle event emission and state updates inconsistently:

**Path 1: Full Rotation with Proof-of-Knowledge** [1](#0-0) 
- Calls `update_auth_key_and_originating_address_table()` which emits `KeyRotation` event
- Then emits `KeyRotationToPublicKey` event
- Updates `OriginatingAddress` table (critical for wallet recovery)

**Path 2: Rotation from Public Key** [2](#0-1) 
- Calls `rotate_authentication_key_call()` which does NOT emit `KeyRotation` event
- Emits only `KeyRotationToPublicKey` event
- Does NOT update `OriginatingAddress` table

**Path 3: Direct Rotation Call** [3](#0-2) 
- Emits NO events at all
- Does NOT update `OriginatingAddress` table

The code comments acknowledge this limitation: [4](#0-3) 

They suggest using `set_originating_address()` as a follow-up, but this function is **permanently disabled**: [5](#0-4) 

The `OriginatingAddress` table is critical for wallet recovery: [6](#0-5) 

**Impact on Indexers:**
The indexer's `KeyRotationTranslator` only handles V2 `KeyRotation` events: [7](#0-6) 

It will miss rotations performed via `rotate_authentication_key_from_public_key()` and `rotate_authentication_key_call()` that don't emit `KeyRotation` events. There is no corresponding translator for `KeyRotationToPublicKey` events.

**Confusion from Identical Events:**
When a user rotates A→B→A→B, the events have identical content but represent different rotations at different times. Without transaction sequence numbers in the event data itself, off-chain systems cannot distinguish between a replayed event and a legitimate rotation back to a previous key.

## Impact Explanation

This issue qualifies as **Medium Severity** per Aptos bug bounty criteria:

1. **State inconsistencies requiring intervention**: The `OriginatingAddress` table becomes incomplete for users who rotate via certain paths, requiring manual database fixes or account migration.

2. **Wallet recovery failures**: Users who rotate keys via `rotate_authentication_key_from_public_key()` or `rotate_authentication_key_call()` will be unable to recover their wallets using the standard recovery mechanism, as their rotated authentication keys won't map back to their original addresses.

3. **Incomplete indexer data**: Indexers tracking key rotation history by listening only to `KeyRotation` events will have incomplete records, breaking analytics, security monitoring, and compliance systems.

4. **No direct consensus or fund loss**: This does not affect consensus, cannot be used to steal funds directly, and doesn't break on-chain state consistency. Therefore, it doesn't qualify as Critical or High severity.

## Likelihood Explanation

**Likelihood: HIGH**

This issue affects all users who choose to use the newer rotation functions (`rotate_authentication_key_from_public_key`, `upsert_ed25519_backup_key_on_keyless_account`) which were added specifically for non-standard key algorithms like passkeys.

**Factors increasing likelihood:**
- These are public entry functions callable by any user
- The documentation encourages their use for passkey-based accounts
- Users have no indication that choosing these functions will break wallet recovery
- The disabled `set_originating_address()` function provides no escape hatch

**Real-world impact:**
- Every wallet/indexer must listen to BOTH `KeyRotation` AND `KeyRotationToPublicKey` events
- Wallets must handle cases where the `OriginatingAddress` table is incomplete
- Users who lose access to their rotated key cannot recover their accounts

## Recommendation

**Short-term fix:**
1. Emit `KeyRotation` events consistently from all rotation paths
2. Enable controlled updates to `OriginatingAddress` table with proper validation

**Implementation:**

Modify `rotate_authentication_key_call()` to emit the event and update the table:

```move
entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account, OriginatingAddress {
    let addr = signer::address_of(account);
    ensure_resource_exists(addr);
    assert!(
        new_auth_key.length() == 32,
        error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
    );
    check_rotation_permission(account);
    let account_resource = &mut Account[addr];
    
    // Emit event and update table for consistency
    if (std::features::module_event_migration_enabled()) {
        event::emit(KeyRotation {
            account: addr,
            old_authentication_key: account_resource.authentication_key,
            new_authentication_key: new_auth_key,
        });
    } else {
        event::emit_event<KeyRotationEvent>(
            &mut account_resource.key_rotation_events,
            KeyRotationEvent {
                old_authentication_key: account_resource.authentication_key,
                new_authentication_key: new_auth_key,
            }
        );
    };
    
    // Update OriginatingAddress table if rotation changes the key
    if (account_resource.authentication_key != new_auth_key) {
        let address_map = &mut OriginatingAddress[@aptos_framework].address_map;
        let curr_auth_key = from_bcs::to_address(account_resource.authentication_key);
        let new_auth_key_addr = from_bcs::to_address(new_auth_key);
        
        if (address_map.contains(curr_auth_key)) {
            address_map.remove(curr_auth_key);
        };
        
        if (!address_map.contains(new_auth_key_addr)) {
            address_map.add(new_auth_key_addr, addr);
        };
    };
    
    account_resource.authentication_key = new_auth_key;
}
```

**Long-term solution:**
Add sequence numbers or transaction context to event data to enable proper event ordering and prevent confusion from identical event content.

## Proof of Concept

```move
#[test(account = @0x123)]
fun test_inconsistent_event_emission(account: signer) acquires Account, OriginatingAddress {
    use std::vector;
    use aptos_framework::account;
    
    // Setup: Create account
    let addr = @0x123;
    account::create_account_for_test(addr);
    
    // Generate two different keys
    let key_a = x"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
    let key_b = x"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
    
    // Rotation Path 1: Using rotate_authentication_key_from_public_key
    // This emits KeyRotationToPublicKey but NOT KeyRotation
    account::rotate_authentication_key_from_public_key(&account, 0, key_a);
    
    // Check: OriginatingAddress table is NOT updated
    let auth_key_as_addr = from_bcs::to_address(key_a_auth_key);
    assert!(
        account::originating_address(auth_key_as_addr).is_none(),
        0
    ); // FAILS - table not updated!
    
    // Rotation Path 2: Using rotate_authentication_key with proofs
    // This emits BOTH KeyRotation AND KeyRotationToPublicKey
    // AND updates OriginatingAddress table
    account::rotate_authentication_key(
        &account,
        0, key_a, // from
        0, key_b, // to
        proof_a,
        proof_b
    );
    
    // Check: OriginatingAddress table IS updated
    let auth_key_b_as_addr = from_bcs::to_address(key_b_auth_key);
    assert!(
        account::originating_address(auth_key_b_as_addr).is_some(),
        1
    ); // PASSES - table is updated
    
    // Demonstrates inconsistency: Same operation (key rotation) produces
    // different events and state updates depending on which function is used
}
```

**Notes:**
- This vulnerability creates a **trust boundary violation** between on-chain state and off-chain systems (wallets, indexers)
- The disabled `set_originating_address()` function indicates Aptos developers are aware of the issue but chose to disable the workaround due to "potential poisoning from account abstraction" concerns
- All wallet implementations must implement defensive coding to handle missing `OriginatingAddress` entries
- Indexers must track multiple event types to maintain complete rotation history
- The lack of unique identifiers (sequence numbers, nonces) in events makes it impossible to distinguish replayed event data from legitimate rotations with identical parameters

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L92-102)
```text
    /// It is easy to fetch the authentication key of an address by simply reading it from the `Account` struct at that address.
    /// The table in this struct makes it possible to do a reverse lookup: it maps an authentication key, to the address of the account which has that authentication key set.
    ///
    /// This mapping is needed when recovering wallets for accounts whose authentication key has been rotated.
    ///
    /// For example, imagine a freshly-created wallet with address `a` and thus also with authentication key `a`, derived from a PK `pk_a` with corresponding SK `sk_a`.
    /// It is easy to recover such a wallet given just the secret key `sk_a`, since the PK can be derived from the SK, the authentication key can then be derived from the PK, and the address equals the authentication key (since there was no key rotation).
    ///
    /// However, if such a wallet rotates its authentication key to `b` derived from a different PK `pk_b` with SK `sk_b`, how would account recovery work?
    /// The recovered address would no longer be 'a'; it would be `b`, which is incorrect.
    /// This struct solves this problem by mapping the new authentication key `b` to the original address `a` and thus helping the wallet software during recovery find the correct address.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L452-459)
```text
    /// Private entry function for key rotation that allows the signer to update their authentication key.
    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
    /// the format expected in `rotate_authentication_key`.
    ///
    /// If you'd like to followup with updating the `OriginatingAddress` table, you can call
    /// `set_originating_address()`.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L460-462)
```text
    entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account {
        rotate_authentication_key_internal(account, new_auth_key);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L468-496)
```text
    entry fun rotate_authentication_key_from_public_key(account: &signer, scheme: u8, new_public_key_bytes: vector<u8>) acquires Account {
        let addr = signer::address_of(account);
        let account_resource = &Account[addr];
        let old_auth_key = account_resource.authentication_key;
        let new_auth_key;
        if (scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == SINGLE_KEY_SCHEME) {
            new_auth_key = single_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else if (scheme == MULTI_KEY_SCHEME) {
            new_auth_key = multi_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else {
            abort error::invalid_argument(EUNRECOGNIZED_SCHEME)
        };
        rotate_authentication_key_call(account, new_auth_key);
        event::emit(KeyRotationToPublicKey {
            account: addr,
            // Set verified_public_key_bit_map to [0x00, 0x00, 0x00, 0x00] as the public key(s) are not verified
            verified_public_key_bit_map: vector[0x00, 0x00, 0x00, 0x00],
            public_key_scheme: scheme,
            public_key: new_public_key_bytes,
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L604-681)
```text
    public entry fun rotate_authentication_key(
        account: &signer,
        from_scheme: u8,
        from_public_key_bytes: vector<u8>,
        to_scheme: u8,
        to_public_key_bytes: vector<u8>,
        cap_rotate_key: vector<u8>,
        cap_update_table: vector<u8>,
    ) acquires Account, OriginatingAddress {
        let addr = signer::address_of(account);
        ensure_resource_exists(addr);
        check_rotation_permission(account);
        let account_resource = &mut Account[addr];
        let old_auth_key = account_resource.authentication_key;
        // Verify the given `from_public_key_bytes` matches this account's current authentication key.
        if (from_scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);
            let from_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
            assert!(
                account_resource.authentication_key == from_auth_key,
                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)
            );
        } else if (from_scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);
            let from_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
            assert!(
                account_resource.authentication_key == from_auth_key,
                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)
            );
        } else {
            abort error::invalid_argument(EINVALID_SCHEME)
        };

        // Construct a valid `RotationProofChallenge` that `cap_rotate_key` and `cap_update_table` will validate against.
        let curr_auth_key_as_address = from_bcs::to_address(account_resource.authentication_key);
        let challenge = RotationProofChallenge {
            sequence_number: account_resource.sequence_number,
            originator: addr,
            current_auth_key: curr_auth_key_as_address,
            new_public_key: to_public_key_bytes,
        };

        // Assert the challenges signed by the current and new keys are valid
        assert_valid_rotation_proof_signature_and_get_auth_key(
            from_scheme,
            from_public_key_bytes,
            cap_rotate_key,
            &challenge
        );
        let new_auth_key = assert_valid_rotation_proof_signature_and_get_auth_key(
            to_scheme,
            to_public_key_bytes,
            cap_update_table,
            &challenge
        );

        // Update the `OriginatingAddress` table.
        update_auth_key_and_originating_address_table(addr, account_resource, new_auth_key);

        let verified_public_key_bit_map;
        if (to_scheme == ED25519_SCHEME) {
            // Set verified_public_key_bit_map to [0x80, 0x00, 0x00, 0x00] as the public key is verified and there is only one public key.
            verified_public_key_bit_map = vector[0x80, 0x00, 0x00, 0x00];
        } else {
            // The new key is a multi-ed25519 key, so set the verified_public_key_bit_map to the signature bitmap.
            let len = vector::length(&cap_update_table);
            verified_public_key_bit_map = vector::slice(&cap_update_table, len - 4, len);
        };

        event::emit(KeyRotationToPublicKey {
            account: addr,
            verified_public_key_bit_map,
            public_key_scheme: to_scheme,
            public_key: to_public_key_bytes,
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L832-833)
```text
    entry fun set_originating_address(_account: &signer) acquires Account, OriginatingAddress {
        abort error::invalid_state(ESET_ORIGINATING_ADDRESS_DISABLED);
```

**File:** storage/indexer/src/event_v2_translator.rs (L353-390)
```rust
struct KeyRotationTranslator;
impl EventV2Translator for KeyRotationTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let key_rotation = KeyRotation::try_from_bytes(v2.event_data())?;
        let struct_tag_str = "0x1::account::Account".to_string();
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(key_rotation.account(), &struct_tag)?
        {
            let account_resource: AccountResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *account_resource.key_rotation_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, account_resource.key_rotation_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of KeyRotationEvent is deterministically 1.
            static KEY_ROTATION_EVENT_CREATION_NUMBER: u64 = 1;
            (
                EventKey::new(KEY_ROTATION_EVENT_CREATION_NUMBER, *key_rotation.account()),
                0,
            )
        };
        let key_rotation_event = KeyRotationEvent::new(
            key_rotation.old_authentication_key().clone(),
            key_rotation.new_authentication_key().clone(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            KEY_ROTATION_EVENT_TYPE.clone(),
            bcs::to_bytes(&key_rotation_event)?,
        )?)
    }
}
```
