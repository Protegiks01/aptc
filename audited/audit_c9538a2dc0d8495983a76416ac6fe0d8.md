# Audit Report

## Title
Transaction Filter Rules Exposed Through Multiple Channels Enabling Targeted Bypass Attacks

## Summary
The `BatchTransactionFilter` and related filter configurations are exposed through node startup logs and an optional HTTP inspection endpoint, allowing attackers to learn the exact filtering rules and craft transactions/batches that bypass intended security controls.

## Finding Description

The batch transaction filter system in Aptos Core is designed to allow nodes to reject specific transactions or batches based on configurable rules. However, the filter rules are exposed through multiple channels without proper access control:

**Exposure Vector 1: Startup Logging**

The `NodeConfig` containing all filter rules is serialized to JSON and logged at INFO level during node startup: [1](#0-0) 

This method is called during every node startup: [2](#0-1) 

**Exposure Vector 2: Inspection Service HTTP Endpoint**

When the inspection service is enabled with `expose_configuration: true`, the entire node configuration (including filter rules) is exposed via the `/configuration` HTTP endpoint: [3](#0-2) 

This endpoint is routed and accessible: [4](#0-3) 

**Exposure Vector 3: Public API Without Access Control**

All methods in `BatchTransactionFilter` are public and unrestricted, allowing any external crate to call them: [5](#0-4) 

The filter structs derive `Serialize` and `Deserialize`, enabling direct inspection of rules: [6](#0-5) 

**Attack Path:**

1. Attacker obtains node logs (via compromised log aggregation, monitoring systems, or leaked log files)
2. Attacker parses the JSON-serialized `transaction_filters` configuration from startup logs
3. Attacker identifies which batch IDs, authors, digests, or transaction patterns are being denied
4. Attacker crafts malicious transactions/batches that avoid the filter rules
5. The malicious payloads bypass the filters and are accepted by the `BatchCoordinator`: [7](#0-6) 

## Impact Explanation

This vulnerability enables **targeted bypass of transaction filtering mechanisms**, which may be used to block malicious actors or enforce operational policies. The severity is Medium because:

1. **State Inconsistencies**: If filters are designed to prevent transactions that could cause state inconsistencies, bypassing them could lead to issues requiring manual intervention (Medium per bug bounty criteria: "State inconsistencies requiring intervention")

2. **Defense-in-Depth Bypass**: Transaction filters represent a security layer in the consensus pipeline. Exposing their rules undermines this defense mechanism.

3. **Targeted Attack Enablement**: Unlike random probing, attackers gain complete knowledge of filter logic, enabling precise bypass strategies.

The impact is limited to Medium (not Critical/High) because filters are not the primary security controlâ€”transaction validation, consensus safety, and Move VM execution provide the core security guarantees.

## Likelihood Explanation

**High Likelihood** because:

1. **Automatic Exposure**: Filter rules are logged automatically on every node startup at INFO level, which is typically enabled in production environments
2. **Common Log Access**: Attackers can access logs through:
   - Compromised log aggregation services
   - Misconfigured log storage (S3 buckets, etc.)
   - Social engineering targeting operators
   - Insider threats
3. **Optional HTTP Exposure**: If inspection service is enabled with `expose_configuration: true`, rules are directly accessible via HTTP GET request
4. **No Authentication Required**: The logging and debug endpoints don't require authentication beyond network access

## Recommendation

**1. Remove Sensitive Data from Logging:**

Implement a custom serialization for filter configurations that redacts the actual filter rules while preserving diagnostic information:

```rust
// In config/src/config/transaction_filters_config.rs
impl Serialize for BatchTransactionFilterConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut state = serializer.serialize_struct("BatchTransactionFilterConfig", 2)?;
        state.serialize_field("filter_enabled", &self.filter_enabled)?;
        // Redact actual rules, only show count
        state.serialize_field("rules_count", &self.batch_transaction_filter.batch_transaction_rules.len())?;
        state.end()
    }
}
```

**2. Mark Filter Rules as Silent/Secret:**

Use `SilentDisplay`/`SilentDebug` traits for filter rule types to prevent accidental exposure through debug formatting.

**3. Remove Configuration Endpoint:**

Either remove the `/configuration` endpoint entirely or ensure it never exposes filter rules, even when debugging is enabled.

**4. Restrict Public API Methods:**

Add `pub(crate)` visibility to sensitive methods in `BatchTransactionFilter` that shouldn't be called by external crates:

```rust
// In batch_transaction_filter.rs
pub(crate) fn allows_transaction(...) -> bool { ... }
```

## Proof of Concept

**PoC 1: Extract Filter Rules from Logs**

```bash
# Start an Aptos node
./aptos-node -f node.yaml

# The startup logs will contain:
# INFO Using transaction_filters config: {"quorum_store_filter":{"filter_enabled":true,"batch_transaction_filter":{"batch_transaction_rules":[{"Deny":[{"Batch":{"BatchAuthor":"0x123..."}}]}]}}}

# Parse the JSON to extract exact filter rules
grep "transaction_filters config" aptos-node.log | jq '.quorum_store_filter.batch_transaction_filter.batch_transaction_rules'
```

**PoC 2: Query Inspection Service Endpoint**

```rust
// If inspection service is enabled, query the endpoint
use reqwest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let response = reqwest::get("http://localhost:9101/configuration").await?;
    let config_text = response.text().await?;
    
    // Parse the debug output to extract filter rules
    // The output contains: transaction_filters: TransactionFiltersConfig { ... }
    println!("Filter configuration exposed: {}", config_text);
    
    Ok(())
}
```

**PoC 3: Direct API Probing**

```rust
use aptos_transaction_filters::batch_transaction_filter::*;
use aptos_crypto::HashValue;
use aptos_types::PeerId;

// External crate can create and test filters
fn probe_filter_logic() {
    let filter = BatchTransactionFilter::empty()
        .add_all_filter(false); // Deny all
    
    // Test with various inputs to understand filter behavior
    let allows = filter.allows_transaction(
        batch_id,
        batch_author,
        &batch_digest,
        &signed_transaction,
    );
    
    // Attacker can probe filter logic systematically
}
```

This vulnerability allows attackers to bypass transaction filtering mechanisms by learning the exact rules through log analysis or HTTP endpoints, enabling targeted attacks that circumvent intended security controls.

### Citations

**File:** config/src/config/node_config.rs (L97-110)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
```

**File:** aptos-node/src/lib.rs (L698-698)
```rust
    node_config.log_all_configs();
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-28)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L112-116)
```rust
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L17-20)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct BatchTransactionFilter {
    batch_transaction_rules: Vec<BatchTransactionRule>,
}
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L22-106)
```rust
impl BatchTransactionFilter {
    pub fn new(batch_transaction_rules: Vec<BatchTransactionRule>) -> Self {
        Self {
            batch_transaction_rules,
        }
    }

    /// Returns true iff the filter allows the transaction in the batch
    pub fn allows_transaction(
        &self,
        batch_id: BatchId,
        batch_author: PeerId,
        batch_digest: &HashValue,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the batch transaction
        for batch_transaction_rule in &self.batch_transaction_rules {
            if batch_transaction_rule.matches(
                batch_id,
                batch_author,
                batch_digest,
                signed_transaction,
            ) {
                return match batch_transaction_rule {
                    BatchTransactionRule::Allow(_) => true,
                    BatchTransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the batch transaction by default)
    }

    /// Returns an empty batch transaction filter with no rules
    pub fn empty() -> Self {
        Self {
            batch_transaction_rules: Vec::new(),
        }
    }

    /// Filters the transactions in the given batch and returns only those that are allowed
    pub fn filter_batch_transactions(
        &self,
        batch_id: BatchId,
        batch_author: PeerId,
        batch_digest: HashValue,
        transactions: Vec<SignedTransaction>,
    ) -> Vec<SignedTransaction> {
        transactions
            .into_iter()
            .filter(|txn| self.allows_transaction(batch_id, batch_author, &batch_digest, txn))
            .collect()
    }

    /// Returns true iff the filter is empty (i.e., has no rules)
    pub fn is_empty(&self) -> bool {
        self.batch_transaction_rules.is_empty()
    }

    /// Adds a filter that matches all batch transactions
    pub fn add_all_filter(self, allow: bool) -> Self {
        let batch_matcher = BatchTransactionMatcher::Batch(BatchMatcher::All);
        self.add_multiple_matchers_filter(allow, vec![batch_matcher])
    }

    /// Adds a filter rule containing multiple matchers
    pub fn add_multiple_matchers_filter(
        mut self,
        allow: bool,
        batch_transaction_matchers: Vec<BatchTransactionMatcher>,
    ) -> Self {
        let transaction_rule = if allow {
            BatchTransactionRule::Allow(batch_transaction_matchers)
        } else {
            BatchTransactionRule::Deny(batch_transaction_matchers)
        };
        self.batch_transaction_rules.push(transaction_rule);

        self
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L191-213)
```rust
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```
