# Audit Report

## Title
Authentication Bypass via X-IS-JWT Header Presence Check in Faucet AuthTokenChecker

## Summary
The `AuthTokenChecker` in the Aptos faucet service checks only for the **presence** of the `x-is-jwt` header, not its value, to decide whether to skip API key validation. An attacker can bypass API key authentication entirely by including this header with any value (including "false" or empty string), allowing unauthorized access to faucet funds when JWT validation is not enforced elsewhere.

## Finding Description

The vulnerability exists in the dual authentication system where the faucet supports both API key and JWT authentication modes. The `AuthTokenChecker` is designed to enforce API key authentication but includes logic to skip validation when JWT authentication is intended. [1](#0-0) 

The checker uses `contains_key()` which only verifies header **existence**, not its value. This differs from the JWT validation logic which requires the header value to be exactly "true": [2](#0-1) 

**Attack Scenario:**

When a faucet is configured with:
1. `AuthTokenChecker` to enforce API key authentication
2. `RedisRatelimitChecker` with IP-based rate limiting (not JWT-based) [3](#0-2) 

An attacker can exploit this by:

1. Sending a funding request with header `x-is-jwt: false` (or any non-"true" value)
2. Omitting both valid API key and JWT from the `Authorization` header
3. `AuthTokenChecker` detects the header's presence and skips API key validation
4. `RedisRatelimitChecker` (configured for IP) performs IP-based rate limiting but never validates JWT
5. Request proceeds without any authentication

The request flow in the fund endpoint processes bypassers first, then checkers: [4](#0-3) 

Since no JWT validation occurs when rate limiting is IP-based, the request bypasses all authentication.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **API Security Breach**: Complete bypass of the authentication mechanism intended to protect the faucet API
2. **Unauthorized Fund Access**: Attackers can drain faucet funds without valid credentials
3. **Service Disruption**: Malicious actors can exhaust faucet resources, denying service to legitimate users
4. **Rate Limit Bypass**: When combined with distributed IP addresses, attackers can exceed intended usage limits

While the faucet typically distributes testnet tokens, production faucets may distribute mainnet tokens for onboarding or promotional purposes, making unauthorized access a direct loss of funds.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is:
- **Trivial to exploit**: Requires only adding a single HTTP header
- **No authentication needed**: Attacker needs no valid credentials
- **Configuration-dependent**: Affects faucets configured with API key authentication + non-JWT rate limiting
- **Common configuration**: IP-based rate limiting is simpler to deploy than JWT infrastructure, making this a likely production configuration

The attack requires no specialized knowledge beyond basic HTTP manipulation and can be automated to drain faucet funds systematically.

## Recommendation

**Fix: Validate header value, not just presence**

The `AuthTokenChecker` should verify that `x-is-jwt` is explicitly set to "true" before skipping API key validation, matching the validation logic in `jwt_sub()`:

```rust
// In auth_token.rs, replace lines 37-40 with:
let is_jwt = data.headers
    .get(X_IS_JWT_HEADER)
    .and_then(|v| v.to_str().ok())
    .map(|v| v.eq_ignore_ascii_case("true"))
    .unwrap_or(false);

if is_jwt {
    return Ok(vec![]);
}
```

**Alternative fix: Mandatory JWT validation when header is present**

If `x-is-jwt` header is present (regardless of value), enforce JWT validation even with IP-based rate limiting. This ensures the authentication mode is fully validated before granting access.

**Defense in depth: Configuration validation**

Add startup validation that warns or fails if `AuthTokenChecker` is enabled without either:
- `AuthTokenBypasser` with trusted bypass keys, OR
- `RedisRatelimitChecker` configured for JWT-based rate limiting

This prevents insecure configurations from being deployed.

## Proof of Concept

**Setup:**
1. Configure faucet with `testing_checkers.yaml` (includes `AuthTokenChecker` + `MemoryRatelimit` by IP)
2. Create `/tmp/auth_tokens.txt` with a valid API key: `valid-api-key-123`
3. Start faucet service

**Exploit Request (no valid credentials):**
```bash
curl -X POST http://localhost:8081/fund \
  -H "Content-Type: application/json" \
  -H "x-is-jwt: false" \
  -d '{
    "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    "amount": 100000000
  }'
```

**Expected (Vulnerable) Behavior:**
- Request succeeds (200 OK) without providing valid API key or JWT
- Funds are transferred to the specified address
- Only IP-based rate limiting applies

**Expected (Fixed) Behavior:**
- Request fails with 403/400 error: "The given auth token is not allowed by the server"
- No funds transferred
- Authentication enforced

**Validation:**
Compare response between:
1. Request with `x-is-jwt: false` (should fail after fix)
2. Request with valid API key in `Authorization: Bearer valid-api-key-123` (should succeed)
3. Request with `x-is-jwt: true` and valid JWT (should succeed if JWT valid)

## Notes

This vulnerability demonstrates a critical gap between authentication intent (dual API key + JWT support) and implementation (header presence check without value validation). The inconsistency between `AuthTokenChecker.check()` using `contains_key()` and `jwt_sub()` requiring the exact value "true" creates an exploitable authentication bypass.

The fix aligns the checker's validation logic with the JWT validator's expectations, ensuring that JWT mode is only engaged when explicitly requested with the correct header value.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L70-82)
```rust
    let is_jwt = headers
        .get(X_IS_JWT_HEADER)
        .and_then(|v| v.to_str().ok())
        .map(|v| v.eq_ignore_ascii_case("true"))
        .ok_or_else(|| {
            AptosTapError::new(
                format!(
                    "The {} header must be present and set to 'true'",
                    X_IS_JWT_HEADER
                ),
                AptosTapErrorCode::AuthTokenInvalid,
            )
        })?;
```

**File:** crates/aptos-faucet/configs/testing_checkers.yaml (L7-18)
```yaml
checker_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
  - type: "IpBlocklist"
    file: "/tmp/ip_blocklist.txt"
  - type: "RefererBlocklist"
    file: "/tmp/referer_blocklist.txt"
  - type: "MagicHeader"
    magic_header_key: "what_wallet_my_guy"
    magic_header_value: "the_wallet_that_rocks"
  - type: "MemoryRatelimit"
    max_requests_per_day: 1000000000
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```
