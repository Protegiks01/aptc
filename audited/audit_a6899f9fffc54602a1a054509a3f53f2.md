# Audit Report

## Title
Genesis Load Failure Bypasses Critical Mainnet Security Checks During Node Configuration

## Summary
When `get_genesis_txn()` returns `None` during node configuration loading, the error is caught and execution continues with `chain_id = None`. This bypasses ALL mainnet-specific security sanitization checks, allowing a mainnet validator to start with dangerous configurations including in-memory consensus safety rules (risking equivocation), disabled Move VM verifications (risking consensus splits), and enabled testing features.

## Finding Description

The vulnerability exists in the node configuration loading and sanitization flow. When a node starts, the configuration loader attempts to extract the chain ID from the genesis transaction. However, if the genesis transaction is not configured (`None`), the error is caught and silently ignored, allowing execution to continue with `chain_id = None`.

**Attack Flow:**

1. **Error Suppression**: In `extract_node_type_and_chain_id()`, when `get_chain_id()` fails due to missing genesis transaction, the error is caught and printed but execution continues with `chain_id = None`: [1](#0-0) 

2. **Security Checks Bypassed**: This `None` value is passed to all config optimizers and sanitizers, which conditionally skip mainnet-specific security checks:

   a) **SafetyRulesConfig**: Skips validation that mainnet validators must NOT use in-memory backend for consensus safety rules: [2](#0-1) 

   b) **ExecutionConfig**: Skips validation that mainnet nodes must enable paranoid Move VM verifications: [3](#0-2) 

   c) **FailpointsConfig**: Skips validation that mainnet nodes must NOT enable failpoints: [4](#0-3) 

   d) **ConsensusConfig**: Skips validation that mainnet nodes must NOT enable consensus-only-perf-test: [5](#0-4) 

   e) **StorageConfig**: Skips panic check for storage sharding requirement on mainnet/testnet: [6](#0-5) 

3. **Node Continues Startup**: After config loading succeeds, the node initializes the database. Genesis application is skipped when genesis transaction is `None`: [7](#0-6) 

4. **Mainnet Chain ID Acquired**: The node then fetches the chain ID from the database (which contains mainnet state from snapshot/sync): [8](#0-7) 

5. **VM Configuration Applied**: The insecure config values are applied to the Move VM without any mainnet validation: [9](#0-8) 

**Invariant Violations:**

This breaks multiple critical invariants:
- **Consensus Safety**: A mainnet validator using in-memory safety rules backend will lose consensus state on restart, potentially causing equivocation (double-signing) which violates Byzantine fault tolerance assumptions
- **Deterministic Execution**: Disabled `paranoid_hot_potato_verification` and `paranoid_type_verification` can cause Move VM execution divergence between nodes, violating deterministic execution
- **Access Control**: Testing features (failpoints, consensus-only-perf-test) in production violate security isolation

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple catastrophic scenarios:

1. **Consensus Safety Violation**: A mainnet validator configured with in-memory safety rules backend would lose its `last_voted_round` on restart. This can cause the validator to vote on conflicting blocks at the same round, constituting equivocation. Under AptosBFT, this breaks consensus safety guarantees if multiple validators are similarly compromised.

2. **Consensus Split Risk**: Disabling `paranoid_hot_potato_verification` and `paranoid_type_verification` changes Move VM execution behavior. If even one validator runs with these disabled while others have them enabled, transaction execution results could diverge, causing state root mismatches and potential chain splits.

3. **Network-Wide Impact**: If multiple operators unknowingly deploy with this configuration (e.g., using incomplete documentation or template configs without genesis), the entire network could be compromised.

This meets **Critical Severity** criteria per Aptos Bug Bounty: "Consensus/Safety violations" and potential "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Ease of Exploitation**: An operator only needs to:
   - Omit or remove the genesis transaction from node config
   - Configure dangerous settings (which appear as valid options)
   - Start the node with a mainnet database snapshot

2. **Common Scenario**: Nodes that restore from snapshots or sync from network often don't need genesis in the config, making this a plausible operational pattern

3. **No Warning**: The only indication is a non-error log message that operators may overlook: [10](#0-9) 

4. **Accidental Occurrence**: This could happen unintentionally through incomplete configuration templates, documentation gaps, or migration errors

## Recommendation

**Immediate Fix**: Make chain ID validation mandatory before config sanitization:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    let chain_id = get_chain_id(node_config)?;  // Propagate error instead of catching
    Ok((node_type, chain_id))
}

fn optimize_and_sanitize_node_config(
    node_config: &mut NodeConfig,
    local_config_yaml: Value,
) -> Result<(), Error> {
    let (node_type, chain_id) = extract_node_type_and_chain_id(node_config)?;
    
    println!(
        "Identified node type ({:?}) and chain ID ({:?}) from node config!",
        node_type, chain_id
    );

    // Chain ID is now guaranteed to be valid
    NodeConfig::optimize(node_config, &local_config_yaml, node_type, Some(chain_id))?;
    NodeConfig::sanitize(node_config, node_type, Some(chain_id))
}
```

**Alternative**: If genesis-less operation must be supported, require explicit chain ID in config:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    // Try genesis first, then fall back to explicit config value
    let chain_id = match get_chain_id(node_config) {
        Ok(chain_id) => chain_id,
        Err(_) => {
            // If genesis is missing, chain_id MUST be explicitly configured
            node_config.base.chain_id.ok_or_else(|| {
                Error::InvariantViolation(
                    "Chain ID must be either derived from genesis transaction or explicitly configured!".to_string()
                )
            })?
        }
    };
    
    Ok((node_type, chain_id))
}
```

## Proof of Concept

**Reproduction Steps:**

1. Create a node config file with dangerous settings and NO genesis:

```yaml
base:
  role: "validator"
  # No chain_id specified
  
execution:
  # genesis: null (not configured)
  paranoid_hot_potato_verification: false  # DANGEROUS on mainnet
  paranoid_type_verification: false        # DANGEROUS on mainnet
  
consensus:
  safety_rules:
    backend:
      type: "in_memory"  # DANGEROUS for validators on mainnet
    service:
      type: "local"
    # test: enabled would also be dangerous
```

2. Initialize database from mainnet snapshot or state sync

3. Start the node:
```bash
cargo run -p aptos-node -- -f /path/to/config.yaml
```

4. **Expected (Vulnerable) Behavior:**
   - Config loads successfully (prints "Continuing with None")
   - All mainnet security checks are skipped
   - Node starts and joins mainnet with insecure configuration
   - Validator uses in-memory safety rules (loses state on restart)
   - Move VM executes without paranoid verifications

5. **Expected (Fixed) Behavior:**
   - Config loading fails with: "Chain ID must be either derived from genesis transaction or explicitly configured!"
   - Node refuses to start
   - Operator must fix configuration

**Validation:**
```bash
# Check that paranoid verifications were NOT enabled (vulnerability active)
grep "paranoid_hot_potato_verification" logs/aptos.log
# Should show false on mainnet (CRITICAL BUG)

# Check safety rules backend (for validators)
grep "safety_rules.*backend" logs/aptos.log  
# Should show "in_memory" on mainnet validator (CRITICAL BUG)
```

This demonstrates how a mainnet validator can start with consensus-unsafe configurations by simply omitting the genesis transaction, bypassing all security validations designed to protect network integrity.

### Citations

**File:** config/src/config/node_config_loader.rs (L117-123)
```rust
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/execution_config.rs (L167-183)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/config_sanitizer.rs (L84-91)
```rust
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
```

**File:** config/src/config/consensus_config.rs (L516-523)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && is_consensus_only_perf_test_enabled() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "consensus-only-perf-test should not be enabled in mainnet!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/storage_config.rs (L653-676)
```rust
        if let Some(chain_id) = chain_id {
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["ensure_rlimit_nofile"].is_null()
            {
                config.ensure_rlimit_nofile = 999_999;
                modified_config = true;
            }
            if chain_id.is_testnet() && config_yaml["assert_rlimit_nofile"].is_null() {
                config.assert_rlimit_nofile = true;
                modified_config = true;
            }
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
            // TODO(HotState): Hot state root hash computation is off by default in Mainnet unless
            // explicitly enabled.
            if chain_id.is_mainnet()
                && config_yaml["hot_state_config"]["compute_root_hash"].as_bool() != Some(true)
            {
                config.hot_state_config.compute_root_hash = false;
            }
        }
```

**File:** aptos-node/src/storage.rs (L34-42)
```rust
    if let Some(genesis) = get_genesis_txn(node_config) {
        let ledger_info_opt =
            maybe_bootstrap::<AptosVMBlockExecutor>(db_rw, genesis, genesis_waypoint)
                .map_err(|err| anyhow!("DB failed to bootstrap {}", err))?;
        Ok(ledger_info_opt)
    } else {
        info ! ("Genesis txn not provided! This is fine only if you don't expect to apply it. Otherwise, the config is incorrect!");
        Ok(None)
    }
```

**File:** aptos-node/src/lib.rs (L712-716)
```rust
    // Obtain the chain_id from the DB
    let chain_id = utils::fetch_chain_id(&db_rw)?;

    // Set the chain_id in global AptosNodeIdentity
    aptos_node_identity::set_chain_id(chain_id)?;
```

**File:** aptos-node/src/utils.rs (L52-67)
```rust
/// Sets the Aptos VM configuration based on the node configurations
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
    let effective_concurrency_level = if node_config.execution.concurrency_level == 0 {
        ((num_cpus::get() / 2) as u16).clamp(1, DEFAULT_EXECUTION_CONCURRENCY_LEVEL)
    } else {
        node_config.execution.concurrency_level
    };
    AptosVM::set_concurrency_level_once(effective_concurrency_level as usize);
    AptosVM::set_discard_failed_blocks(node_config.execution.discard_failed_blocks);
    AptosVM::set_num_proof_reading_threads_once(
        node_config.execution.num_proof_reading_threads as usize,
    );
    AptosVM::set_blockstm_v2_enabled_once(node_config.execution.blockstm_v2_enabled);
```
