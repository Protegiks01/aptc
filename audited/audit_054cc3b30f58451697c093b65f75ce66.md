# Audit Report

## Title
Validator Network Topology Disclosure via Peer Monitoring Service Cross-Network Information Leak

## Summary
The Peer Monitoring Service's `GetNetworkInformation` endpoint returns connected peers from ALL networks without filtering by the requesting peer's network context. This allows untrusted peers on a validator's VFN (Validator Full Node) network to query and discover the validator's connections on the private validator network, enabling complete mapping of validator network topology.

## Finding Description

The Peer Monitoring Service is registered on every configured network (validator, VFN, and public networks) during node initialization. [1](#0-0) 

When a peer sends a `GetNetworkInformation` request, the handler calls `get_connected_peers_and_metadata()` which iterates through ALL networks and returns all connected peers without any filtering: [2](#0-1) 

The request handler in the Peer Monitoring Service receives the requesting peer's network_id but only uses it for metrics collection, not for filtering the response: [3](#0-2) 

VFN networks are configured with `MaybeMutual` authentication mode when `mutual_authentication` is false: [4](#0-3) 

The `MaybeMutual` mode explicitly allows all inbound connections from any peer: [5](#0-4)  and [6](#0-5) 

Validators commonly run VFN networks as documented in standard configurations: [7](#0-6) 

The `NetworkInformationResponse` contains a map of `PeerNetworkId` to `ConnectionMetadata`: [8](#0-7) 

Each `PeerNetworkId` reveals both the NetworkId (Validator/Vfn/Public) and the PeerId: [9](#0-8) 

**Attack Path:**
1. Attacker operates a node and connects to target validator's VFN network (accepted by MaybeMutual authentication)
2. Attacker sends `PeerMonitoringServiceRequest::GetNetworkInformation` via RPC
3. Response includes `connected_peers` containing entries from BOTH the VFN network AND the private validator network
4. Each `PeerNetworkId` exposes which network the peer is on and their identity
5. Attacker queries multiple validators to build complete topology map of the validator network

## Impact Explanation

This is a **Medium Severity** information disclosure vulnerability per Aptos bug bounty categories. It does not directly cause:
- Loss of funds or consensus violations (Critical)
- Validator node crashes or protocol violations (High)

However, it enables:
- Complete mapping of the private validator network topology
- Identification of validator interconnections and network structure
- Information that could facilitate more sophisticated attacks (eclipse attacks, targeted analysis, strategic network positioning)
- Violation of network privacy assumptions for validator operations

The impact is limited to information disclosure, but the information revealed (validator network topology) is operationally sensitive and could enable follow-on attacks, justifying Medium severity under "Limited Protocol Violations."

## Likelihood Explanation

**High Likelihood:**
- No special privileges required - any peer can connect to VFN networks
- No authentication or authorization checks on the Peer Monitoring Service GetNetworkInformation endpoint
- Exploit is trivial: single RPC call returns all network information
- Validators commonly run VFN networks to support their validator full nodes (standard configuration)
- The vulnerability is systematic across all validators using default configurations

The attack requires only:
1. Ability to run a node and connect to validators' VFN networks (publicly available capability)
2. Knowledge of the Peer Monitoring Service RPC protocol (documented in codebase)
3. Basic RPC interaction capability

No cryptographic breaks, race conditions, or complex exploitation chains required.

## Recommendation

Implement network-based filtering in the `get_network_information()` handler to only return peers from the same network as the requesting peer:

```rust
fn get_network_information(
    &self,
    requesting_network_id: NetworkId,
) -> Result<PeerMonitoringServiceResponse, Error> {
    // Get connected peers filtered by requesting network
    let connected_peers_and_metadata = self
        .peers_and_metadata
        .get_connected_peers_and_metadata()?
        .into_iter()
        .filter(|(peer_network_id, _)| {
            peer_network_id.network_id() == requesting_network_id
        })
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (
                peer,
                ConnectionMetadata::new(
                    connection_metadata.addr,
                    connection_metadata.remote_peer_id,
                    connection_metadata.role,
                ),
            )
        })
        .collect();
    
    // ... rest of function
}
```

Additionally, update the `Handler::call()` method to pass the `network_id` parameter to `get_network_information()`.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Running a fullnode configured to connect to a validator's VFN network
2. Implementing a simple RPC client that sends `PeerMonitoringServiceRequest::GetNetworkInformation`
3. Observing that the response includes `PeerNetworkId` entries with `NetworkId::Validator`, revealing the validator's private network connections

The execution path is straightforward and requires no special conditions - it works on any standard validator configuration that exposes a VFN network endpoint.

## Notes

This vulnerability demonstrates a clear violation of network isolation principles. The Peer Monitoring Service was designed to provide network information but lacks proper access control to ensure that sensitive validator network topology is not leaked to untrusted peers on different networks. The fix is straightforward - filter responses by the requesting peer's network context.

### Citations

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```

**File:** network/framework/src/application/storage.rs (L108-125)
```rust
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/peer_manager/builder.rs (L38-42)
```rust
    /// Inbound connections will first be checked against the known peers set, and
    /// if the `PeerId` is known it will be authenticated against it's `PublicKey`
    /// Otherwise, the incoming connections will be allowed through in the common
    /// pool of unknown peers.
    MaybeMutual(x25519::PrivateKey),
```

**File:** network/framework/src/noise/handshake.rs (L95-98)
```rust
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
```

**File:** config/src/config/test_data/validator.yaml (L24-38)
```yaml
full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"
```

**File:** peer-monitoring-service/types/src/response.rs (L51-55)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** config/src/network_id.rs (L237-256)
```rust
pub struct PeerNetworkId {
    network_id: NetworkId,
    peer_id: PeerId,
}

impl PeerNetworkId {
    pub fn new(network_id: NetworkId, peer_id: PeerId) -> Self {
        Self {
            network_id,
            peer_id,
        }
    }

    pub fn network_id(&self) -> NetworkId {
        self.network_id
    }

    pub fn peer_id(&self) -> PeerId {
        self.peer_id
    }
```
