# Audit Report

## Title
Script Transaction Payload Filter Bypass in Indexer gRPC Stream

## Summary
The `get_entry_function_payload_from_transaction_payload()` function in the indexer transaction filter returns `None` for script payloads, causing script transactions to bypass payload-based filters and be incorrectly included in filtered indexer streams. [1](#0-0) 

## Finding Description

The `UserTransactionFilter` is designed to filter user transactions based on sender addresses and entry function payloads. The filter documentation explicitly states it supports "UserPayload and MultisigPayload" (entry functions), but not script payloads. [2](#0-1) 

However, when a payload filter is specified, the matching logic has a critical flaw. When processing transactions: [3](#0-2) 

The function attempts to extract an `EntryFunctionPayload` from the transaction. For script payloads (TYPE_SCRIPT_PAYLOAD), the extraction returns `None` at the wildcard pattern: [4](#0-3) 

Script transactions are legitimate transaction types in Aptos, as evidenced by the protobuf definition: [5](#0-4) 

And actual script transactions exist in production, including imported mainnet transactions and test data.

When the payload extraction returns `None`, the payload filter check is skipped entirely (the `if let Some(payload)` block is not entered), and the function returns `true`, allowing the script transaction to pass through.

This means script transactions **bypass** payload filtering in the indexer gRPC stream: [6](#0-5) 

## Impact Explanation

This vulnerability causes **data integrity issues** in the indexer gRPC stream filtering layer, not blockchain state inconsistencies. The impact is:

1. **Incorrect Data Filtering**: Indexer clients requesting specific entry function transactions will also receive unrelated script transactions
2. **Application Logic Errors**: Downstream applications assuming filtered streams contain only matching entry functions may process script transactions incorrectly
3. **Data Pollution**: Filtered streams contain transactions that don't match filter criteria

However, this does **not** meet Medium severity criteria because:
- It doesn't affect blockchain consensus, execution, or state
- It doesn't cause protocol-level funds loss or manipulation  
- It's a filtering/data quality bug in the indexer infrastructure layer, not a security vulnerability in the core blockchain protocol
- The harm is indirect (application-layer) rather than direct (protocol-layer)

This is better classified as a **Low severity implementation bug** rather than a Medium severity security vulnerability.

## Likelihood Explanation

**High likelihood** of occurrence:
- Script transactions exist in production (evidenced by mainnet imports and test data)
- Payload-based filters are actively used by indexer clients
- No special privileges required to send script transactions
- The bug affects all users of the indexer gRPC filtering API

## Recommendation

The payload filter should **reject** script transactions explicitly since they cannot match entry function filters. Modify the matching logic:

```rust
if let Some(payload_filter) = &self.payload {
    let entry_function_payload = user_request
        .payload
        .as_ref()
        .and_then(get_entry_function_payload_from_transaction_payload);
    
    // If payload filter is specified, require entry function payload to match
    match entry_function_payload {
        Some(payload) => {
            if !payload_filter.matches(payload) {
                return false;
            }
        }
        None => {
            // No entry function payload (e.g., script transaction)
            // Reject since it cannot match the entry function filter
            return false;
        }
    }
}
```

Additionally, update the documentation to clarify that script transactions are explicitly excluded from payload filtering.

## Proof of Concept

```rust
#[test]
fn test_script_transaction_rejected_by_payload_filter() {
    use aptos_protos::transaction::v1::{
        Transaction, UserTransaction, UserTransactionRequest,
        TransactionPayload, transaction_payload, ScriptPayload,
        transaction::TxnData,
    };
    
    // Create a script transaction
    let script_txn = Transaction {
        txn_data: Some(TxnData::User(UserTransaction {
            request: Some(UserTransactionRequest {
                sender: "0x1".to_string(),
                payload: Some(TransactionPayload {
                    type_: transaction_payload::Type::TypeScriptPayload as i32,
                    payload: Some(transaction_payload::Payload::ScriptPayload(
                        ScriptPayload::default()
                    )),
                    ..Default::default()
                }),
                ..Default::default()
            }),
            ..Default::default()
        })),
        ..Default::default()
    };
    
    // Create filter for specific entry function
    let filter = UserTransactionFilterBuilder::default()
        .payload(
            UserTransactionPayloadFilterBuilder::default()
                .function(
                    EntryFunctionFilterBuilder::default()
                        .address("0x1")
                        .module("coin")
                        .function("transfer")
                        .build()
                        .unwrap()
                )
                .build()
                .unwrap()
        )
        .build()
        .unwrap();
    
    // CURRENT BUG: Script transaction matches (returns true)
    // EXPECTED: Script transaction should be rejected (return false)
    assert!(!filter.matches(&script_txn), 
        "Script transactions should be rejected by payload filters");
}
```

---

**Note:** While this is a legitimate implementation bug that should be fixed, after strict validation against the Aptos bug bounty criteria, it does not qualify as a Medium severity security vulnerability. It is better classified as a Low severity implementation bug affecting data quality in the indexer layer.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L13-14)
```rust
/// We use this for UserTransactions.
/// We support UserPayload and MultisigPayload
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L100-115)
```rust
        if let Some(payload_filter) = &self.payload {
            // Get the entry_function_payload from both UserPayload and MultisigPayload
            let entry_function_payload = user_request
                .payload
                .as_ref()
                .and_then(get_entry_function_payload_from_transaction_payload);
            if let Some(payload) = entry_function_payload {
                // Here we have an actual EntryFunctionPayload
                if !payload_filter.matches(payload) {
                    return false;
                }
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L275-295)
```rust
fn get_entry_function_payload_from_transaction_payload(
    payload: &TransactionPayload,
) -> Option<&EntryFunctionPayload> {
    if let Some(payload) = &payload.payload {
        match payload {
            transaction_payload::Payload::EntryFunctionPayload(ef_payload) => Some(ef_payload),
            transaction_payload::Payload::MultisigPayload(ms_payload) => ms_payload
                .transaction_payload
                .as_ref()
                .and_then(|tp| tp.payload.as_ref())
                .map(|payload| match payload {
                    multisig_transaction_payload::Payload::EntryFunctionPayload(ef_payload) => {
                        ef_payload
                    },
                }),
            _ => None,
        }
    } else {
        None
    }
}
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L298-315)
```text
message TransactionPayload {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_ENTRY_FUNCTION_PAYLOAD = 1;
    TYPE_SCRIPT_PAYLOAD = 2;
    TYPE_WRITE_SET_PAYLOAD = 4;
    TYPE_MULTISIG_PAYLOAD = 5;
    reserved 3;
  }

  Type type = 1;

  oneof payload {
    EntryFunctionPayload entry_function_payload = 2;
    ScriptPayload script_payload = 3;
    WriteSetPayload write_set_payload = 5;
    MultisigPayload multisig_payload = 6;
  }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-182)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```
