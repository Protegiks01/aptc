# Audit Report

## Title
Cross-Account Vote Stacking via Delegated Voter Manipulation in Partial Governance Voting

## Summary
The partial voting system (VotingRecordsV2) allows different account addresses to vote multiple times on the same proposal using a single stake pool by changing the delegated voter between votes. This circumvents the single-stake-pool voting integrity model enforced in the legacy voting system and enables vote obfuscation and timing attacks.

## Finding Description

The Aptos governance system tracks voting power usage per stake pool in the `VotingRecordsV2` resource using a `RecordKey` structure that contains only `{stake_pool, proposal_id}` without tracking the voter's address. [1](#0-0) 

The `vote_internal` function validates that only the current delegated voter can vote for a stake pool: [2](#0-1) 

However, the voting power tracking in VotingRecordsV2 uses only the stake pool address, not the voter address: [3](#0-2) 

Since the delegated voter can be changed at any time by the stake pool owner: [4](#0-3) 

**Attack Path:**
1. Stake pool X has 100 voting power, Account A is the delegated voter
2. Account A calls `partial_vote(stake_pool=X, proposal_id=0, voting_power=60, should_pass=true)`
3. VotingRecordsV2 records: `RecordKey{X, 0}` → used_voting_power = 60
4. Stake pool owner changes delegated voter to Account B via `stake::set_delegated_voter`
5. Account B calls `partial_vote(stake_pool=X, proposal_id=0, voting_power=40, should_pass=true)`
6. VotingRecordsV2 updates: `RecordKey{X, 0}` → used_voting_power = 100

Both votes succeed because each call validates only that the **current** delegated voter matches, and the remaining voting power calculation is based solely on the stake pool's cumulative usage.

**Critical Difference from Legacy System:**

The legacy voting system explicitly prevented this scenario. The test `test_cannot_double_vote_with_different_voter_addresses` demonstrates that changing the delegated voter after voting should cause the second vote to fail: [5](#0-4) 

In the legacy system, the `VotingRecords` table stored boolean flags indicating a stake pool had voted entirely. The partial voting system removed this protection without equivalent safeguards.

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables several governance integrity violations:

1. **Vote Source Obfuscation**: An attacker controlling one stake pool can make it appear that multiple independent stakeholders support a proposal by splitting votes across different addresses, misleading governance participants and external observers.

2. **Timing Attacks**: An attacker can vote partially with one account, observe proposal dynamics, then complete the vote later using a different account. This provides multiple decision points for a single stake pool, violating the principle of atomic voting decisions.

3. **Monitoring/Rate Limiting Bypass**: Systems monitoring governance activity at the address level (rather than stake pool level) can be circumvented, as the same voting power appears to come from different sources.

4. **Governance Integrity Violation**: The design change from the legacy system suggests this behavior was previously considered undesirable. The lack of any test validating this as intended behavior in partial voting indicates this is likely an oversight, not intentional design.

While the total voting power remains capped at the stake pool's limit, the ability to split votes across accounts fundamentally changes the governance security model without clear justification.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is easily exploitable:
- Requires only standard governance permissions (stake pool ownership and delegated voter control)
- No special timing or validator collusion needed
- Can be executed with simple transaction sequences
- No on-chain indicators would flag this as suspicious behavior

The attack is deterministic and requires minimal sophistication. Any stake pool owner can execute this pattern immediately upon discovering it.

## Recommendation

Add voter address tracking to prevent cross-account vote stacking. Modify the `RecordKey` structure to include the voter address, or add a separate tracking mechanism:

**Option 1: Enhanced RecordKey (Breaking Change)**
```move
struct RecordKey has copy, drop, store {
    stake_pool: address,
    proposal_id: u64,
    voter: address,  // Track original voter
}
```

**Option 2: Delegated Voter Lock (Minimal Change)**
Add a mapping to lock the delegated voter for a stake pool once it votes on a proposal:

```move
struct VotingDelegatedVoterLocks has key {
    locks: SmartTable<RecordKey, address>  // RecordKey -> locked_voter
}
```

Then in `vote_internal`, enforce:
```move
let record_key = RecordKey { stake_pool, proposal_id };
if (VotingDelegatedVoterLocks[@aptos_framework].locks.contains(record_key)) {
    let locked_voter = *VotingDelegatedVoterLocks[@aptos_framework].locks.borrow(record_key);
    assert!(locked_voter == voter_address, EDELEGATED_VOTER_CHANGED);
} else {
    VotingDelegatedVoterLocks[@aptos_framework].locks.add(record_key, voter_address);
}
```

This ensures that once a stake pool votes on a proposal (even partially), only the original delegated voter can continue voting for that proposal.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @0x345)]
public entry fun test_cross_account_vote_stacking_vulnerability(
    aptos_framework: signer,
    proposer: signer,
    voter_1: signer,
    voter_2: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
    
    let voter_1_addr = signer::address_of(&voter_1);
    let voter_2_addr = signer::address_of(&voter_2);
    
    // Create a proposal
    create_proposal_for_test(&proposer, true);
    
    // voter_1 votes with 10 voting power (their stake pool has 20 total)
    partial_vote(&voter_1, voter_1_addr, 0, 10, true);
    assert!(get_remaining_voting_power(voter_1_addr, 0) == 10, 0);
    
    // Change delegated voter from voter_1 to voter_2 for voter_1's stake pool
    stake::set_delegated_voter(&voter_1, voter_2_addr);
    
    // voter_2 can now vote with the remaining 10 power from voter_1's stake pool!
    partial_vote(&voter_2, voter_1_addr, 0, 10, true);
    
    // Both votes succeeded - same stake pool voted through two different accounts
    assert!(get_remaining_voting_power(voter_1_addr, 0) == 0, 1);
    
    // This demonstrates cross-account vote stacking vulnerability
}
```

## Notes

The vulnerability stems from the architectural decision to track voting power per stake pool without binding votes to the voter address that initiated them. While the legacy voting system prevented this through boolean "entirely voted" flags, the partial voting system's granular u64 tracking inadvertently enabled cross-account vote stacking. The absence of tests validating this behavior as intentional, combined with explicit prevention in the legacy system, strongly suggests this is a security regression rather than a design decision.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L93-96)
```text
    struct RecordKey has copy, drop, store {
        stake_pool: address,
        proposal_id: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L548-548)
```text
        assert!(stake::get_delegated_voter(stake_pool) == voter_address, error::invalid_argument(ENOT_DELEGATED_VOTER));
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L568-574)
```text
        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = VotingRecordsV2[@aptos_framework].votes.borrow_mut_with_default(record_key, 0);
        // This calculation should never overflow because the used voting cannot exceed the total voting power of this stake pool.
        *used_voting_power += voting_power;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1051-1071)
```text
    public entry fun test_cannot_double_vote_with_different_voter_addresses(
        aptos_framework: signer,
        proposer: signer,
        voter_1: signer,
        voter_2: signer,
    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
        setup_voting(&aptos_framework, &proposer, &voter_1, &voter_2);

        create_proposal(
            &proposer,
            signer::address_of(&proposer),
            b"0",
            b"",
            b"",
        );

        // Double voting should throw an error for 2 different voters if they still use the same stake pool.
        vote(&voter_1, signer::address_of(&voter_1), 0, true);
        stake::set_delegated_voter(&voter_1, signer::address_of(&voter_2));
        vote(&voter_2, signer::address_of(&voter_1), 0, true);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L787-801)
```text
    public entry fun set_delegated_voter(owner: &signer, new_voter: address) acquires OwnerCapability, StakePool {
        check_stake_permission(owner);
        let owner_address = signer::address_of(owner);
        assert_owner_cap_exists(owner_address);
        let ownership_cap = borrow_global<OwnerCapability>(owner_address);
        set_delegated_voter_with_cap(ownership_cap, new_voter);
    }

    /// Allows an owner to change the delegated voter of the stake pool.
    public fun set_delegated_voter_with_cap(owner_cap: &OwnerCapability, new_voter: address) acquires StakePool {
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        stake_pool.delegated_voter = new_voter;
    }
```
