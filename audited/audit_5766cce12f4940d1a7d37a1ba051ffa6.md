# Audit Report

## Title
Client-Side PeerId Validation Bypass Enabling Man-in-the-Middle Attacks

## Summary
The `dial` method in the network transport layer does not validate that the public key embedded in the `NetworkAddress` corresponds to the expected `PeerId`. This allows an attacker who can inject malicious network addresses to perform man-in-the-middle attacks, where a victim node believes it is connected to a trusted peer but is actually communicating with the attacker.

## Finding Description

The vulnerability exists in the client-side connection establishment flow. When a node dials a peer, it follows this sequence:

1. The `dial` method receives a `PeerId` and `NetworkAddress` parameter [1](#0-0) 

2. The `NetworkAddress` contains an embedded public key in the `/noise-ik/<pubkey>/handshake/<version>` suffix [2](#0-1) 

3. The connection is established using this public key from the address [3](#0-2) 

4. The `ConnectionMetadata` is created with the `remote_peer_id` parameter directly, without deriving it from the authenticated public key [4](#0-3) 

5. Post-connection validation only checks if the metadata's `remote_peer_id` equals the dial parameter - a tautological check [5](#0-4) 

**Critically, there is no client-side validation** that derives the `PeerId` from the authenticated public key and compares it to the expected `PeerId`. The codebase already has this derivation function available [6](#0-5) , and the server-side performs this validation in `MaybeMutual` authentication mode [7](#0-6) .

**Attack Scenario:**
An attacker who can inject malicious `NetworkAddress` entries (through compromised discovery, malicious onchain data, or corrupted seed peer configuration) provides an address like:
`/ip4/<attacker_ip>/tcp/<port>/noise-ik/<attacker_pubkey>/handshake/1`

When the victim dials `PeerId_Bob` using this address:
- The Noise handshake establishes a connection with the attacker's public key
- The victim's `ConnectionMetadata` claims `remote_peer_id = PeerId_Bob`
- All messages intended for Bob are sent to the attacker
- The attacker can read, modify, or drop consensus messages, transactions, state sync data, etc.

## Impact Explanation

This vulnerability enables **man-in-the-middle attacks** on peer-to-peer communications, with severity depending on the affected protocol:

**Critical Severity** - If validator consensus messages are affected:
- Attackers could manipulate or drop vote messages, causing consensus liveness failures
- Attackers could modify block proposals, leading to inconsistent state
- Attackers could prevent validators from reaching quorum
- This violates the "Consensus Safety" invariant

**High Severity** - If state synchronization or transaction propagation is affected:
- Attackers could provide incorrect state sync data
- Attackers could censor transactions
- Attackers could cause validator node slowdowns through message manipulation

The vulnerability is most severe in `MaybeMutual` authentication mode (used for VFN and public networks) where any peer can accept connections, and in scenarios where address discovery can be manipulated.

## Likelihood Explanation

**Likelihood: Medium to High** depending on the attack surface:

**Higher likelihood:**
- In public/VFN networks using onchain discovery, if an attacker can manipulate discovery data
- In networks where seed peer configurations can be tampered with
- During initial network bootstrap when address sources may be less vetted

**Lower likelihood:**
- In validator networks with mutual authentication and strictly controlled configuration
- When addresses come exclusively from hardened onchain governance

The lack of defense-in-depth makes this exploitable whenever upstream address sources are compromised, which is more likely than expected given the complexity of distributed systems.

## Recommendation

Add client-side validation that the authenticated public key corresponds to the expected `PeerId` before accepting the connection. This should be implemented in the `upgrade_outbound` function:

**Validation logic to add after line 373 in `network/framework/src/transport/mod.rs`:**

```rust
// Validate that the remote peer's public key corresponds to the expected PeerId
let derived_peer_id = aptos_types::account_address::from_identity_public_key(remote_pubkey);
if derived_peer_id != remote_peer_id {
    return Err(io::Error::new(
        io::ErrorKind::InvalidData,
        format!(
            "Outbound connection peer ID mismatch: expected {}, but public key derives {}",
            remote_peer_id.short_str(),
            derived_peer_id.short_str()
        ),
    ));
}
```

This validation should occur after the Noise handshake but before creating the `ConnectionMetadata`, ensuring the authenticated public key matches the expected peer identity.

## Proof of Concept

The following demonstrates the vulnerability by showing that a client can establish a connection using an arbitrary public key while the metadata claims a different PeerId:

**Test scenario (to be added to `network/framework/src/transport/test.rs`):**

```rust
#[tokio::test]
async fn test_peer_id_public_key_mismatch() {
    // Create two different keypairs
    let bob_private_key = x25519::PrivateKey::generate(&mut rng);
    let bob_public_key = bob_private_key.public_key();
    let bob_peer_id = from_identity_public_key(bob_public_key);
    
    let attacker_private_key = x25519::PrivateKey::generate(&mut rng);
    let attacker_public_key = attacker_private_key.public_key();
    let attacker_peer_id = from_identity_public_key(attacker_public_key);
    
    // Create a malicious address: claims to be Bob but uses attacker's pubkey
    let malicious_addr = NetworkAddress::from_str(
        &format!("/ip4/127.0.0.1/tcp/6180/noise-ik/{}/handshake/0", 
                 attacker_public_key)
    ).unwrap();
    
    // Alice dials "Bob" using the malicious address
    let result = transport.dial(bob_peer_id, malicious_addr).await;
    
    // Currently succeeds - connection metadata claims remote_peer_id = bob_peer_id
    // but actually connected to attacker_peer_id
    assert!(result.is_ok());
    assert_eq!(result.unwrap().metadata.remote_peer_id, bob_peer_id); // Wrong!
    
    // After fix, this should fail with peer ID mismatch error
}
```

## Notes

This vulnerability represents a **missing security control** rather than a logic error. While the system relies on trusted address sources, defense-in-depth principles dictate that the client should independently verify the server's identity matches expectations. The server-side already performs equivalent validation, demonstrating the security-critical nature of this check. Adding client-side validation prevents entire classes of attacks where address sources are compromised, poisoned, or manipulated.

### Citations

**File:** network/netcore/src/transport/boxed.rs (L82-84)
```rust
    fn dial(&self, peer_id: PeerId, addr: NetworkAddress) -> Result<Self::Outbound, Self::Error> {
        self.inner.dial(peer_id, addr)
    }
```

**File:** network/framework/src/transport/mod.rs (L397-405)
```rust
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
```

**File:** network/framework/src/transport/mod.rs (L549-549)
```rust
        let (base_addr, pubkey, handshake_version) = Self::parse_dial_addr(&addr)?;
```

**File:** network/framework/src/transport/mod.rs (L566-566)
```rust
        let upgrade_fut = upgrade_outbound(self.ctxt.clone(), fut_socket, addr, peer_id, pubkey);
```

**File:** network/framework/src/peer_manager/transport.rs (L238-247)
```rust
                let dialed_peer_id = connection.metadata.remote_peer_id;
                if dialed_peer_id == peer_id {
                    Ok(connection)
                } else {
                    Err(PeerManagerError::from_transport_error(format_err!(
                        "Dialed PeerId '{}' differs from expected PeerId '{}'",
                        dialed_peer_id.short_str(),
                        peer_id.short_str()
                    )))
                }
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** network/framework/src/noise/handshake.rs (L394-404)
```rust
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
```
