# Audit Report

## Title
Excessive Memory Consumption in CommitVote Cache During Epoch Changes with Large Validator Sets

## Summary
The `CommitVote` structure includes the full `LedgerInfo`, which during epoch changes contains a complete `ValidatorVerifier` with all validator public keys and voting power. With the maximum allowed validator set size of 65,536 validators, each `CommitVote` can consume approximately 9-10 MB of memory. The pending commit vote cache stores up to 100 rounds of votes from all validators, potentially consuming hundreds of gigabytes of memory during epoch transitions at scale. [1](#0-0) 

## Finding Description

During epoch changes, the `BlockInfo` structure contains `next_epoch_state: Option<EpochState>`, which includes the full `ValidatorVerifier` for the next epoch. This verifier contains public keys and voting power for all validators in the set. [2](#0-1) 

The `EpochState` contains an `Arc<ValidatorVerifier>`, but when serialized for network transmission, the full validator list is included: [3](#0-2) 

The `ValidatorVerifier` contains a vector of `ValidatorConsensusInfo` for each validator: [4](#0-3) 

Each `ValidatorConsensusInfo` includes approximately 136 bytes (32-byte address + 96-byte BLS public key + 8-byte voting power): [5](#0-4) 

The maximum validator set size is 65,536: [6](#0-5) 

**Memory Calculation:**
- 65,536 validators × 136 bytes = 8,912,896 bytes ≈ 8.5 MB for validator_infos alone
- With overhead: ~9-10 MB per CommitVote during epoch changes

The `BufferManager` caches pending commit votes: [7](#0-6) 

With default configuration allowing 100 rounds of cached votes: [8](#0-7) 

Each validator can send votes for multiple rounds, and the cache stores:
- Up to 100 rounds
- Each round can have votes from all N validators
- Each vote during epoch change: ~10 MB

**Worst case memory:** 100 rounds × 65,536 validators × 10 MB = ~64 TB per node

**Realistic epoch change:** 1 round × 65,536 validators × 10 MB = ~640 GB per node

## Impact Explanation

This issue aligns with **High Severity** criteria from the bug bounty program: "Validator node slowdowns" and "API crashes." At large validator set sizes (thousands of validators), this could cause:

1. **Memory exhaustion** leading to validator node crashes during epoch changes
2. **Network congestion** due to redundant transmission of validator lists
3. **Consensus liveness impact** if nodes crash during critical epoch transitions

However, the practical impact is limited by current validator set sizes (~200-500 validators estimated), where memory usage remains manageable at ~50-350 MB per epoch change round.

## Likelihood Explanation

**Current likelihood: Very Low**
- Current mainnet has hundreds of validators, not tens of thousands
- Memory impact at current scale: 500 validators × 700 KB ≈ 350 MB (manageable)

**Future likelihood: Medium-High (if validator set grows)**
- If validator set reaches 10,000: ~14 GB per epoch change round
- Natural network growth could eventually trigger this issue
- No size validation or optimization exists

**Exploitation complexity:**
- Cannot be directly exploited by external attackers
- Requires validator set to organically grow or governance manipulation
- Not exploitable without significant stake and validator access

## Recommendation

Implement one or more of the following mitigations:

1. **Optimize CommitVote serialization**: Don't include `next_epoch_state` in `CommitVote` since all validators already know the next epoch validator set through other means.

2. **Add size limits**: Implement maximum size checks for cached `CommitVote` messages:
   ```rust
   const MAX_COMMIT_VOTE_SIZE: usize = 1024 * 1024; // 1 MB limit
   ```

3. **Compress validator data**: Use compression for the `ValidatorVerifier` when serializing for network transmission.

4. **Reference-based approach**: Instead of including full `next_epoch_state`, include only a hash reference that validators can look up locally.

5. **Dynamic cache sizing**: Adjust `max_pending_rounds_in_commit_vote_cache` based on validator set size to prevent unbounded memory growth.

## Proof of Concept

```rust
// Reproduction: Calculate CommitVote size with maximum validator set
use aptos_types::{
    block_info::BlockInfo,
    epoch_state::EpochState,
    ledger_info::LedgerInfo,
    validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo},
};
use aptos_consensus_types::pipeline::commit_vote::CommitVote;
use aptos_crypto::bls12381;

fn calculate_commit_vote_size() {
    // Create validator set with maximum size
    let max_validators = 65536;
    let mut validator_infos = Vec::new();
    
    for i in 0..max_validators {
        validator_infos.push(ValidatorConsensusInfo::new(
            AccountAddress::random(),
            bls12381::PublicKey::dummy(),
            100,
        ));
    }
    
    let verifier = ValidatorVerifier::new(validator_infos);
    let epoch_state = EpochState::new(1, verifier);
    
    // Create BlockInfo with next_epoch_state
    let block_info = BlockInfo::new(
        1, 1, HashValue::random(), HashValue::random(),
        0, 0, Some(epoch_state)
    );
    
    let ledger_info = LedgerInfo::new(block_info, HashValue::zero());
    
    // Serialize to measure size
    let serialized = bcs::to_bytes(&ledger_info).unwrap();
    println!("LedgerInfo size with {} validators: {} bytes (~{} MB)",
             max_validators, serialized.len(), serialized.len() / 1024 / 1024);
    
    // Expected: ~9-10 MB
    assert!(serialized.len() > 8_000_000); // > 8 MB
}
```

**Notes**

This is classified as a **design limitation** rather than an immediately exploitable vulnerability because:

1. **Not directly exploitable**: Requires validator set growth that cannot be triggered by external attackers
2. **Current impact minimal**: At current validator set sizes (~200-500), memory usage is acceptable
3. **Question marked "Low"**: The security question itself indicates this is a low-severity concern
4. **Future scalability concern**: Becomes problematic only as validator set grows significantly over time

The issue represents inefficient resource usage in the consensus protocol's commit vote mechanism, where redundant validator list data is transmitted and cached during epoch changes. While technically correct, the practical security impact is limited by economic and operational constraints on validator set growth.

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L17-23)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct CommitVote {
    author: Author,
    ledger_info: LedgerInfo,
    /// Signature on the LedgerInfo along with a status on whether the signature is verified.
    signature: SignatureWithStatus,
}
```

**File:** types/src/block_info.rs (L27-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/epoch_state.rs (L17-22)
```rust
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct EpochState {
    pub epoch: u64,
    pub verifier: Arc<ValidatorVerifier>,
}
```

**File:** types/src/validator_verifier.rs (L70-76)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ValidatorConsensusInfo {
    pub address: AccountAddress,
    pub public_key: PublicKey,
    pub voting_power: u64,
}
```

**File:** types/src/validator_verifier.rs (L135-161)
```rust
#[derive(Debug, Derivative, Serialize)]
#[derivative(PartialEq, Eq)]
pub struct ValidatorVerifier {
    /// A vector of each validator's on-chain account address to its pubkeys and voting power.
    pub validator_infos: Vec<ValidatorConsensusInfo>,
    /// The minimum voting power required to achieve a quorum
    #[serde(skip)]
    quorum_voting_power: u128,
    /// Total voting power of all validators (cached from address_to_validator_info)
    #[serde(skip)]
    total_voting_power: u128,
    /// In-memory index of account address to its index in the vector, does not go through serde.
    #[serde(skip)]
    address_to_validator_index: HashMap<AccountAddress, usize>,
    /// With optimistic signature verification, we aggregate all the votes on a message and verify at once.
    /// We use this optimization for votes, order votes, commit votes, signed batch info. If the verification fails,
    /// we verify each vote individually, which is a time consuming process. These are the list of voters that have
    /// submitted bad votes that has resulted in having to verify each vote individually. Further votes by these validators
    /// will be verified individually bypassing the optimization.
    #[serde(skip)]
    #[derivative(PartialEq = "ignore")]
    pessimistic_verify_set: DashSet<AccountAddress>,
    /// This is the feature flag indicating whether the optimistic signature verification feature is enabled.
    #[serde(skip)]
    #[derivative(PartialEq = "ignore")]
    optimistic_sig_verification: bool,
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L98-100)
```text
    /// Limit the maximum size to u16::max, it's the current limit of the bitvec
    /// https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-bitvec/src/lib.rs#L20
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```

**File:** consensus/src/pipeline/buffer_manager.rs (L167-170)
```rust
    max_pending_rounds_in_commit_vote_cache: u64,
    // If the buffer manager receives a commit vote for a block that is not in buffer items, then
    // the vote will be cached. We can cache upto max_pending_rounds_in_commit_vote_cache (100) blocks.
    pending_commit_votes: BTreeMap<Round, HashMap<AccountAddress, CommitVote>>,
```

**File:** config/src/config/consensus_config.rs (L381-381)
```rust
            max_pending_rounds_in_commit_vote_cache: 100,
```
