# Audit Report

## Title
Premature Stream Termination via Malicious last_index Manipulation in State Sync

## Summary
A malicious peer can cause state sync streams to terminate prematurely by manipulating the `last_index` field in `StateValueChunkWithProof` responses, leaving the syncing node with incomplete state data. This occurs because the stream completion logic trusts the peer-provided `last_index` value without validating it matches the actual data received.

## Finding Description

The vulnerability exists in the state sync data streaming service where two separate validation mechanisms operate at different layers with conflicting outcomes.

**Layer 1 - Data Streaming Service (Vulnerable Point):**

The `StateStreamEngine::transform_client_response_into_notification()` function extracts the `last_index` from peer responses and uses it to determine stream completion: [1](#0-0) 

The critical issue is at lines 330 and 347-348 where `last_index` is extracted directly from the untrusted peer response without validation that it matches the actual number of values in `raw_values`. The function only verifies that `raw_values` is not empty but never checks if `last_index - first_index + 1 == raw_values.len()`.

**Layer 2 - Missing Data Detection (Bypassed):**

The data stream does attempt to detect missing data by comparing received vs requested counts: [2](#0-1) 

However, this check is based on `raw_values.len()` and occurs BEFORE the stream completion check, creating a race condition.

**The Attack Flow:**

The vulnerability is exploited through careful timing in the response processing loop: [3](#0-2) 

At line 473, `request_missing_data()` detects incomplete data and creates a missing data request. At line 502, `send_data_notification_to_client()` calls `transform_client_response_into_notification()` which marks the stream complete based on the manipulated `last_index`. At line 514, the loop breaks due to head-of-line blocking.

On the next iteration, the stream completion check prevents processing: [4](#0-3) 

At line 446, `is_stream_complete()` returns true, causing an early return at line 453. The missing data request queued by `request_missing_data()` is never processed.

**Why Proof Validation Doesn't Help:**

The `StateValueChunkWithProof` struct has a TODO comment indicating proof verification is not yet implemented: [5](#0-4) 

The validation that would catch this (checking `last_index - first_index + 1 == raw_values.len()`) only exists in the bootstrapper layer, which is too late: [6](#0-5) 

By the time the bootstrapper receives the incomplete data, the stream has already terminated and cannot request the missing data.

**Attack Scenario:**

1. Syncing node requests state values 0-99 (where `number_of_states = 100`, thus `last_stream_index = 99`)
2. Multiple requests sent: request₁ for indices 0-49, request₂ for indices 50-99
3. Request₁ processed successfully
4. Malicious peer responds to request₂ with:
   - `first_index = 50`
   - `last_index = 99` (manipulated to equal `last_stream_index`)
   - `raw_values` containing only 10 items (indices 50-59 instead of 50-99)
5. `request_missing_data()` detects 40 missing values and creates a request for indices 60-99
6. `transform_client_response_into_notification()` marks `stream_is_complete = true` because `last_received_index (99) >= last_stream_index (99)`
7. Next iteration: `process_data_responses()` returns early due to stream completion
8. Missing data request for indices 60-99 never processed
9. State sync fails with incomplete state (missing 40% of data)

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria:

**Validator Node Slowdowns**: Nodes attempting to sync will repeatedly fail with incomplete state, requiring manual intervention and causing significant operational delays. Each sync attempt consumes resources without completing successfully.

**Significant Protocol Violations**: This breaks the **State Consistency** invariant that requires state transitions to be atomic and complete. A node with incomplete state cannot validate transactions correctly or participate in consensus safely.

**Availability Impact**: While not a total loss of liveness, this creates a practical barrier to node bootstrapping and state synchronization, particularly affecting:
- New validators joining the network
- Existing validators recovering from downtime
- Full nodes performing state snapshots

The attack requires only a malicious peer (no validator collusion needed) and causes deterministic failures in state sync operations.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Ability to act as a peer in the P2P network (low barrier)
- Knowledge of the target node's state sync request (observable)
- Ability to respond to data requests (standard peer capability)

**Attack Complexity: LOW**
- Single malicious response per sync attempt
- No timing requirements beyond normal request-response flow
- Deterministic outcome once triggered

**Frequency:**
This will trigger on EVERY state sync attempt when a malicious peer is selected to serve data. Given that:
1. Peer selection includes any connected peer
2. State sync occurs during bootstrapping, recovery, and snapshots
3. The attack is undetectable until the stream terminates

The vulnerability will manifest frequently in networks with any malicious peers.

## Recommendation

Add validation in `StateStreamEngine::transform_client_response_into_notification()` to verify that the `last_index` field matches the actual data received:

```rust
// In transform_client_response_into_notification(), after line 335:

// Validate that last_index matches the actual data received
let expected_num_values = last_received_index
    .checked_sub(request.start_index)
    .and_then(|v| v.checked_add(1))
    .ok_or_else(|| Error::IntegerOverflow("Expected values has overflown!".into()))?;
let actual_num_values = state_values_with_proof.raw_values.len() as u64;

if actual_num_values != expected_num_values {
    return Err(Error::AptosDataClientResponseIsInvalid(format!(
        "Mismatched last_index in response! Expected {} values (indices {}-{}), but received {} values. last_index={}, first_index={}",
        expected_num_values, request.start_index, last_received_index,
        actual_num_values, state_values_with_proof.last_index, state_values_with_proof.first_index
    )));
}
```

This ensures that stream completion is only marked when ALL data has actually been received, not just when a manipulated index value claims completion.

**Alternative Fix**: Derive `last_received_index` from actual data:
```rust
let last_received_index = request.start_index
    .checked_add(state_values_with_proof.raw_values.len() as u64)
    .and_then(|v| v.checked_sub(1))
    .ok_or_else(|| Error::IntegerOverflow("Last received index overflown!".into()))?;
```

This removes trust in the peer-provided `last_index` field entirely.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: state-sync/data-streaming-service/src/tests/stream_engine_vulnerability.rs

#[tokio::test]
async fn test_premature_stream_termination_via_malicious_last_index() {
    use crate::stream_engine::StateStreamEngine;
    use aptos_data_client::interface::ResponsePayload;
    use aptos_types::state_store::state_value::{StateValue, StateValueChunkWithProof};
    use aptos_crypto::HashValue;
    
    // Setup: Node needs to sync 100 state values (indices 0-99)
    let mut engine = StateStreamEngine::new(&GetAllStatesRequest {
        version: 1000,
        start_index: 0,
    }).unwrap();
    
    // Simulate receiving number_of_states = 100
    engine.number_of_states = Some(100);
    
    // First request (0-49) succeeds normally
    let request1 = StateValuesWithProofRequest {
        version: 1000,
        start_index: 0,
        end_index: 49,
    };
    
    let response1 = create_valid_response(0, 49, 50); // 50 values
    let _ = engine.transform_client_response_into_notification(
        &DataClientRequest::StateValuesWithProof(request1),
        response1,
        Arc::new(U64IdGenerator::new()),
    ).unwrap();
    
    assert_eq!(engine.next_stream_index, 50);
    assert!(!engine.stream_is_complete); // Not complete yet
    
    // ATTACK: Malicious peer sends response with manipulated last_index
    let request2 = StateValuesWithProofRequest {
        version: 1000,
        start_index: 50,
        end_index: 99, // Requesting 50 values
    };
    
    // Malicious response: claims last_index=99 but only provides 10 values
    let malicious_response = ResponsePayload::StateValuesWithProof(
        StateValueChunkWithProof {
            first_index: 50,
            last_index: 99, // MANIPULATED - claims to have data up to 99
            first_key: HashValue::random(),
            last_key: HashValue::random(),
            raw_values: create_state_values(10), // Only 10 values (50-59)
            proof: SparseMerkleRangeProof::new(vec![]),
            root_hash: HashValue::random(),
        }
    );
    
    let _ = engine.transform_client_response_into_notification(
        &DataClientRequest::StateValuesWithProof(request2),
        malicious_response,
        Arc::new(U64IdGenerator::new()),
    ).unwrap();
    
    // VULNERABILITY: Stream marked complete despite missing data
    assert!(engine.stream_is_complete); // Stream thinks it's done!
    
    // Reality: Only received indices 0-59, missing 60-99 (40 values)
    // Expected: engine.stream_is_complete should be FALSE
    // Expected: next_stream_index should be 60, not 100
    
    // The missing data request created by request_missing_data() will never
    // be processed because subsequent calls to process_data_responses() will
    // return early due to stream_is_complete = true
}

fn create_state_values(count: usize) -> Vec<(StateKey, StateValue)> {
    (0..count)
        .map(|i| {
            (
                StateKey::raw(format!("key_{}", i).as_bytes()),
                StateValue::new_legacy(vec![i as u8].into()),
            )
        })
        .collect()
}

fn create_valid_response(first: u64, last: u64, count: usize) -> ResponsePayload {
    ResponsePayload::StateValuesWithProof(StateValueChunkWithProof {
        first_index: first,
        last_index: last,
        first_key: HashValue::random(),
        last_key: HashValue::random(),
        raw_values: create_state_values(count),
        proof: SparseMerkleRangeProof::new(vec![]),
        root_hash: HashValue::random(),
    })
}
```

This test demonstrates that a malicious peer can cause the stream to mark itself complete while data is still missing, violating the state consistency invariant.

### Citations

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L318-349)
```rust
                // Identify the last received state index and bound it appropriately
                let last_received_index = match &client_response_payload {
                    ResponsePayload::StateValuesWithProof(state_values_with_proof) => {
                        // Verify that we received at least one state value
                        if state_values_with_proof.raw_values.is_empty() {
                            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                                "Received an empty state values response! Request: {:?}",
                                client_request
                            )));
                        }

                        // Get the last received state index
                        state_values_with_proof.last_index
                    },
                    _ => invalid_response_type!(client_response_payload),
                };
                let last_received_index =
                    bound_by_range(last_received_index, request.start_index, request.end_index);

                // Update the next stream index
                self.next_stream_index = last_received_index.checked_add(1).ok_or_else(|| {
                    Error::IntegerOverflow("Next stream index has overflown!".into())
                })?;

                // Check if the stream is complete
                let last_stream_index = self
                    .get_number_of_states()?
                    .checked_sub(1)
                    .ok_or_else(|| Error::IntegerOverflow("End index has overflown!".into()))?;
                if last_received_index >= last_stream_index {
                    self.stream_is_complete = true;
                }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L442-454)
```rust
    pub async fn process_data_responses(
        &mut self,
        global_data_summary: GlobalDataSummary,
    ) -> Result<(), Error> {
        if self.stream_engine.is_stream_complete()
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
        }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L467-516)
```rust
                Ok(client_response) => {
                    // Sanity check and process the response
                    if sanity_check_client_response_type(client_request, &client_response) {
                        // If the response wasn't enough to satisfy the original request (e.g.,
                        // it was truncated), missing data should be requested.
                        let mut head_of_line_blocked = false;
                        match self.request_missing_data(client_request, &client_response.payload) {
                            Ok(missing_data_requested) => {
                                if missing_data_requested {
                                    head_of_line_blocked = true; // We're now head of line blocked on the missing data
                                }
                            },
                            Err(error) => {
                                warn!(LogSchema::new(LogEntry::ReceivedDataResponse)
                                    .stream_id(self.data_stream_id)
                                    .event(LogEvent::Error)
                                    .error(&error)
                                    .message("Failed to determine if missing data was requested!"));
                            },
                        }

                        // If the request was a subscription request and the subscription
                        // stream is lagging behind the data advertisements, the stream
                        // engine should be notified (e.g., so that it can catch up).
                        if client_request.is_subscription_request() {
                            if let Err(error) = self.check_subscription_stream_lag(
                                &global_data_summary,
                                &client_response.payload,
                            ) {
                                self.notify_new_data_request_error(client_request, error)?;
                                head_of_line_blocked = true; // We're now head of line blocked on the failed stream
                            }
                        }

                        // The response is valid, send the data notification to the client
                        self.send_data_notification_to_client(client_request, client_response)
                            .await?;

                        // If the request is for specific data, increase the prefetching limit.
                        // Note: we don't increase the limit for new data requests because
                        // those don't invoke the prefetcher (as we're already up-to-date).
                        if !client_request.is_new_data_request() {
                            self.dynamic_prefetching_state
                                .increase_max_concurrent_requests();
                        }

                        // If we're head of line blocked, we should return early
                        if head_of_line_blocked {
                            break;
                        }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1107-1146)
```rust
fn create_missing_state_values_request(
    request: &StateValuesWithProofRequest,
    response_payload: &ResponsePayload,
) -> Result<Option<DataClientRequest>, Error> {
    // Determine the number of requested state values
    let num_requested_state_values = request
        .end_index
        .checked_sub(request.start_index)
        .and_then(|v| v.checked_add(1))
        .ok_or_else(|| {
            Error::IntegerOverflow("Number of requested state values has overflown!".into())
        })?;

    // Identify the missing data if the request was not satisfied
    match response_payload {
        ResponsePayload::StateValuesWithProof(state_values_with_proof) => {
            // Check if the request was satisfied
            let num_received_state_values = state_values_with_proof.raw_values.len() as u64;
            if num_received_state_values < num_requested_state_values {
                let start_index = request
                    .start_index
                    .checked_add(num_received_state_values)
                    .ok_or_else(|| Error::IntegerOverflow("Start index has overflown!".into()))?;
                Ok(Some(DataClientRequest::StateValuesWithProof(
                    StateValuesWithProofRequest {
                        version: request.version,
                        start_index,
                        end_index: request.end_index,
                    },
                )))
            } else {
                Ok(None) // The request was satisfied!
            }
        },
        payload => Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Invalid response payload found for state values request: {:?}",
            payload
        ))),
    }
}
```

**File:** types/src/state_store/state_value.rs (L337-353)
```rust
/// TODO(joshlind): add a proof implementation (e.g., verify()) and unit tests
/// for these once we start supporting them.
///
/// A single chunk of all state values at a specific version.
/// Note: this is similar to `StateSnapshotChunk` but all data is included
/// in the struct itself and not behind pointers/handles to file locations.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub struct StateValueChunkWithProof {
    pub first_index: u64,     // The first hashed state index in chunk
    pub last_index: u64,      // The last hashed state index in chunk
    pub first_key: HashValue, // The first hashed state key in chunk
    pub last_key: HashValue,  // The last hashed state key in chunk
    pub raw_values: Vec<(StateKey, StateValue)>, // The hashed state key and and raw state value.
    pub proof: SparseMerkleRangeProof, // The proof to ensure the chunk is in the hashed states
    pub root_hash: HashValue, // The root hash of the sparse merkle tree for this chunk
}
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L917-959)
```rust
    /// Verifies the start and end indices in the given state value chunk
    async fn verify_states_values_indices(
        &mut self,
        notification_id: NotificationId,
        state_value_chunk_with_proof: &StateValueChunkWithProof,
    ) -> Result<(), Error> {
        // Verify the payload start index is valid
        let expected_start_index = self.state_value_syncer.next_state_index_to_process;
        if expected_start_index != state_value_chunk_with_proof.first_index {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::InvalidPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(format!(
                "The start index of the state values was invalid! Expected: {:?}, received: {:?}",
                expected_start_index, state_value_chunk_with_proof.first_index
            )));
        }

        // Verify the end index and number of state values is valid
        let expected_num_state_values = state_value_chunk_with_proof
            .last_index
            .checked_sub(state_value_chunk_with_proof.first_index)
            .and_then(|version| version.checked_add(1)) // expected_num_state_values = last_index - first_index + 1
            .ok_or_else(|| {
                Error::IntegerOverflow("The expected number of state values has overflown!".into())
            })?;
        let num_state_values = state_value_chunk_with_proof.raw_values.len() as u64;
        if expected_num_state_values != num_state_values {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::InvalidPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(format!(
                "The expected number of state values was invalid! Expected: {:?}, received: {:?}",
                expected_num_state_values, num_state_values,
            )));
        }

        Ok(())
    }
```
