# Audit Report

## Title
Silent Network Binding Failure in Executor Service Causes Operational Disruption

## Summary
The `ExecutorService` and `RemoteExecutorClient` components fail to properly handle network socket binding errors. When the underlying `NetworkController` fails to bind to the specified socket address (e.g., port already in use), the error triggers a panic in an async spawned task that is silently caught, causing the service to appear operational while being unable to receive network requests.

## Finding Description

The vulnerability exists in the network initialization path used by production executor services. The call chain is:

1. `ProcessExecutorService::new()` creates an `ExecutorService` [1](#0-0) 

2. `ExecutorService::start()` calls `NetworkController::start()` [2](#0-1) 

3. `NetworkController::start()` calls `InboundHandler::start()` which spawns a gRPC server [3](#0-2) 

4. The gRPC server binding occurs in `GRPCNetworkMessageServiceServerWrapper::start_async()`, where `serve_with_shutdown().await.unwrap()` panics on binding failure [4](#0-3) 

The critical issue is that the gRPC server start happens inside a spawned async task [5](#0-4) . When a panic occurs in a spawned tokio task due to the `.unwrap()`, the panic is caught by the runtime, the task terminates, but no error propagates to the caller. The `ProcessExecutorService::new()` constructor returns successfully even though the network service failed to bind.

This affects the production executor service binary [6](#0-5) , which runs as a standalone process for sharded block execution. The same vulnerability exists in `RemoteExecutorClient` [7](#0-6) .

**Attack Scenario:**
1. An attacker binds to the executor service port before the service starts (e.g., port squatting)
2. The executor service starts and appears successful (logs show "Starting process remote executor service")
3. The gRPC server fails to bind and panics in the spawned task
4. The service runs but cannot receive execution requests from the coordinator
5. Block execution requests timeout or fail, causing execution stalls
6. In a sharded execution environment, failed shards prevent block completion

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program:

- **Validator node slowdowns**: Failed executor services cause block execution to stall or timeout, directly impacting validator performance
- **Significant protocol violations**: The executor service violates the availability invariant - it should either operate correctly or fail fast with clear errors
- **Operational impact**: Silent failures are particularly dangerous as operators may not detect the issue until execution failures cascade through the system

In a sharded block execution architecture, each shard must successfully process its portion of transactions. A silently failed shard causes the entire block execution to fail or timeout, affecting consensus progress and validator rewards.

## Likelihood Explanation

**Likelihood: Medium to High**

This issue can occur through:
1. **Port conflicts**: Another process binds to the executor service port first (common in containerized environments)
2. **Permission errors**: Insufficient permissions to bind to privileged ports
3. **Configuration errors**: Multiple executor services configured with the same port
4. **Targeted attack**: An attacker intentionally binds to known executor service ports to disrupt operations

The issue is particularly likely in production deployments where:
- Multiple services run on the same host
- Port allocation is dynamic or poorly coordinated
- Services restart after crashes (port may still be held by OS)

## Recommendation

Replace the `.unwrap()` with proper error handling and propagation:

**Option 1: Return Result from start_async**
```rust
async fn start_async(
    self,
    server_addr: SocketAddr,
    rpc_timeout_ms: u64,
    server_shutdown_rx: oneshot::Receiver<()>,
) -> Result<(), tonic::transport::Error> {
    // ... reflection service setup ...
    
    Server::builder()
        .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
        .add_service(
            NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
        )
        .add_service(reflection_service)
        .serve_with_shutdown(server_addr, async {
            server_shutdown_rx.await.ok();
            info!("Received signal to shutdown server at {:?}", server_addr);
        })
        .await?;  // Propagate error instead of unwrap
    info!("Server shutdown at {:?}", server_addr);
    Ok(())
}
```

**Option 2: Make NetworkController::start() return Result**

Modify the entire call chain to return `Result<(), Error>` and handle binding failures at the `ProcessExecutorService` level, causing the process to exit with a clear error message.

**Option 3: Add retry logic with exponential backoff**

Attempt to bind multiple times before failing, logging each attempt.

## Proof of Concept

```rust
#[cfg(test)]
mod test_network_binding_failure {
    use aptos_executor_service::process_executor_service::ProcessExecutorService;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr, TcpListener};
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_silent_binding_failure() {
        // Setup: Bind to a port to simulate conflict
        let port = 9000;
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), port);
        let _listener = TcpListener::bind(addr).expect("Failed to bind test port");

        let coordinator_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 9001);
        let remote_addrs = vec![addr]; // This will fail to bind

        // This should fail but currently returns successfully
        let _service = ProcessExecutorService::new(
            0,     // shard_id
            1,     // num_shards
            4,     // num_threads
            coordinator_addr,
            remote_addrs,
        );

        // Give time for the async task to attempt binding
        thread::sleep(Duration::from_millis(100));

        // Service appears operational but is non-functional
        // Attempting to send requests would fail/timeout
        // No error was propagated to the caller
    }
}
```

## Notes

While `ThreadExecutorService` is marked as "testing only" [8](#0-7) , the same underlying vulnerability affects production components. The `ProcessExecutorService` is used in the production executor service binary and `RemoteExecutorClient` is used for remote execution coordination.

The silent failure mode is particularly dangerous because monitoring systems may not detect the issue until execution requests begin timing out, making diagnosis difficult and prolonging outages.

### Citations

**File:** execution/executor-service/src/process_executor_service.rs (L35-43)
```rust
        let mut executor_service = ExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            self_address,
            coordinator_address,
            remote_shard_addresses,
        );
        executor_service.start();
```

**File:** execution/executor-service/src/remote_executor_service.rs (L57-58)
```rust
    pub fn start(&mut self) {
        self.controller.start();
```

**File:** secure/net/src/network_controller/mod.rs (L139-150)
```rust
    pub fn start(&mut self) {
        info!(
            "Starting network controller started for at {}",
            self.listen_addr
        );
        self.inbound_server_shutdown_tx = self
            .inbound_handler
            .lock()
            .unwrap()
            .start(&self.inbound_rpc_runtime);
        self.outbound_task_shutdown_tx = self.outbound_handler.start(&self.outbound_rpc_runtime);
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L51-54)
```rust
        rt.spawn(async move {
            self.start_async(server_addr, rpc_timeout_ms, server_shutdown_rx)
                .await;
        });
```

**File:** secure/net/src/grpc_network_service/mod.rs (L81-86)
```rust
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** execution/executor-service/src/main.rs (L37-43)
```rust
    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );
```

**File:** execution/executor-service/src/remote_executor_client.rs (L134-134)
```rust
        controller.start();
```

**File:** execution/executor-service/src/thread_executor_service.rs (L8-8)
```rust
/// separate thread. This should be used for testing only.
```
