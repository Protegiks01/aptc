# Audit Report

## Title
Unbounded Memory Allocation in Executor Service Due to Missing State Key Count Limits

## Summary
The `ExecutorService` and underlying execution infrastructure lack memory limits on the number of state keys that can be accessed per block, allowing a malicious validator to craft blocks with transactions containing excessive `read_hints` and `write_hints`. This causes unbounded memory allocation in multiple data structures during block execution, potentially leading to out-of-memory conditions and validator node crashes.

## Finding Description

The vulnerability exists in the remote executor service's handling of blocks with excessive state access patterns. When processing a block, the system allocates memory proportional to the total number of state keys accessed across all transactions without any bounds checking.

**Attack Flow:**

1. A malicious validator proposes a block containing transactions with an arbitrarily large number of `read_hints` and `write_hints` in their `AnalyzedTransaction` structures. [1](#0-0) 

2. The consensus layer validates the block only based on transaction count and total byte size, but does NOT validate the number of state keys accessed. [2](#0-1) 

3. When the executor service receives the block via `RemoteCoordinatorClient::receive_execute_command()`, it calls `extract_state_keys()` which collects ALL state keys from ALL transactions' read and write hints without any limit checks. [3](#0-2) 

4. The extracted state keys are passed to `RemoteStateViewClient::init_for_block()`, which creates a new `RemoteStateView` and inserts ALL state keys into an unbounded `DashMap`. [4](#0-3) 

5. The `RemoteStateView` uses a `DashMap<StateKey, RemoteStateValue>` with no size limits to store these state keys. [5](#0-4) 

6. Additionally, `CrossShardStateView::create_cross_shard_state_view()` creates a `HashMap` from cross-shard dependencies without any size limits. [6](#0-5) 

**Broken Invariant:**

This violates **Critical Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits." The system fails to enforce memory limits on state access operations during block execution.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria due to "Validator node slowdowns" and potential crashes:

- **Immediate Impact**: Executor service nodes can experience severe memory pressure or out-of-memory (OOM) crashes when processing malicious blocks
- **Consensus Impact**: If enough validators crash simultaneously, the network could experience liveness failures
- **Persistent Degradation**: Validators must process all proposed blocks, so repeated attacks can cause sustained performance degradation

The impact is particularly severe for remote execution configurations where state keys are prefetched into memory upfront before execution begins.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is straightforward to execute:
- **Attacker Requirements**: Only requires being a validator (or compromising a single validator)
- **Detection Difficulty**: The malicious block appears valid to consensus checks and is only detected during execution
- **Execution Complexity**: Low - the attacker simply needs to create transactions with large `read_hints`/`write_hints` vectors
- **System Design**: The Aptos Byzantine fault tolerance model assumes up to 1/3 of validators may be malicious, making this threat realistic

The lack of any bounds checking makes this vulnerability easily exploitable once a malicious validator has block proposal rights.

## Recommendation

Implement strict limits on the number of state keys that can be accessed per transaction and per block:

1. **Add state key count validation in consensus** before accepting blocks:
   - Define `MAX_STATE_KEYS_PER_TRANSACTION` (e.g., 10,000)
   - Define `MAX_STATE_KEYS_PER_BLOCK` (e.g., 1,000,000)
   - Validate these limits in `round_manager.rs::process_proposal()`

2. **Add defensive checks in executor service**:
   ```rust
   // In RemoteCoordinatorClient::extract_state_keys()
   fn extract_state_keys(command: &ExecuteBlockCommand) -> Result<Vec<StateKey>, Error> {
       let mut total_keys = 0;
       let state_keys = /* existing extraction logic */;
       
       ensure!(
           state_keys.len() <= MAX_STATE_KEYS_PER_BLOCK,
           "Block exceeds maximum state key limit: {} > {}",
           state_keys.len(),
           MAX_STATE_KEYS_PER_BLOCK
       );
       
       Ok(state_keys)
   }
   ```

3. **Add per-transaction validation during AnalyzedTransaction creation**:
   ```rust
   // In AnalyzedTransaction::new()
   ensure!(
       read_hints.len() + write_hints.len() <= MAX_STATE_KEYS_PER_TRANSACTION,
       "Transaction exceeds state key limit"
   );
   ```

4. **Implement memory monitoring** in RemoteStateView to reject initialization if projected memory usage exceeds safe thresholds.

## Proof of Concept

```rust
// Test demonstrating unbounded memory allocation
#[test]
fn test_excessive_state_keys_memory_exhaustion() {
    use aptos_types::transaction::analyzed_transaction::*;
    use aptos_types::state_store::state_key::StateKey;
    
    // Create a transaction with excessive state key hints
    let excessive_key_count = 10_000_000; // 10 million state keys
    
    let mut read_hints = Vec::new();
    for i in 0..excessive_key_count {
        let key = StateKey::raw(format!("key_{}", i).as_bytes());
        read_hints.push(StorageLocation::Specific(key));
    }
    
    // This will consume excessive memory without any bounds checking
    // Expected memory usage: ~10M * (size_of(StateKey) + size_of(RemoteStateValue))
    // Estimated: 10M * ~100 bytes = ~1GB just for the DashMap
    
    let state_view_client = RemoteStateViewClient::new(/*...*/);
    
    // Extract state keys - no limit check
    let state_keys: Vec<StateKey> = read_hints.iter()
        .map(|loc| loc.state_key().clone())
        .collect();
    
    // This will allocate unbounded memory
    state_view_client.init_for_block(state_keys);
    
    // System will likely OOM or experience severe memory pressure
}
```

To demonstrate the attack in practice:
1. Create an `AnalyzedTransaction` with 1-10 million entries in `read_hints`
2. Package into a block that passes transaction count/byte limits
3. Submit through a malicious validator
4. Observe executor service memory consumption spike during `init_for_block()`

## Notes

The vulnerability is particularly dangerous because:

1. **No early detection**: Consensus validation passes, so the malicious block propagates to all validators
2. **Amplification**: A single malicious transaction can consume gigabytes of memory
3. **Multiple attack surfaces**: Both `RemoteStateView` and `CrossShardStateView` are vulnerable
4. **Production impact**: Remote execution nodes in production deployments are directly affected

The fix requires defense-in-depth at multiple layers: consensus validation, executor service initialization, and runtime memory monitoring.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L24-37)
```rust
pub struct AnalyzedTransaction {
    transaction: SignatureVerifiedTransaction,
    /// Set of storage locations that are read by the transaction - this doesn't include location
    /// that are written by the transactions to avoid duplication of locations across read and write sets
    /// This can be accurate or strictly overestimated.
    pub read_hints: Vec<StorageLocation>,
    /// Set of storage locations that are written by the transaction. This can be accurate or strictly
    /// overestimated.
    pub write_hints: Vec<StorageLocation>,
    /// A transaction is predictable if neither the read_hint or the write_hint have wildcards.
    predictable_transaction: bool,
    /// The hash of the transaction - this is cached for performance reasons.
    hash: HashValue,
}
```

**File:** consensus/src/round_manager.rs (L1166-1193)
```rust
        ensure!(
            num_validator_txns <= vtxn_count_limit,
            "process_proposal failed with per-block vtxn count limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_txn_count(),
            num_validator_txns
        );
        ensure!(
            validator_txns_total_bytes <= vtxn_bytes_limit,
            "process_proposal failed with per-block vtxn bytes limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_total_bytes(),
            validator_txns_total_bytes
        );
        let payload_len = proposal.payload().map_or(0, |payload| payload.len());
        let payload_size = proposal.payload().map_or(0, |payload| payload.size());
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L52-76)
```rust
    fn extract_state_keys(command: &ExecuteBlockCommand) -> Vec<StateKey> {
        command
            .sub_blocks
            .sub_block_iter()
            .flat_map(|sub_block| {
                sub_block
                    .transactions
                    .par_iter()
                    .map(|txn| {
                        let mut state_keys = vec![];
                        for storage_location in txn
                            .txn()
                            .read_hints()
                            .iter()
                            .chain(txn.txn().write_hints().iter())
                        {
                            state_keys.push(storage_location.state_key().clone());
                        }
                        state_keys
                    })
                    .flatten()
                    .collect::<Vec<StateKey>>()
            })
            .collect::<Vec<StateKey>>()
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L29-38)
```rust
pub struct RemoteStateView {
    state_values: DashMap<StateKey, RemoteStateValue>,
}

impl RemoteStateView {
    pub fn new() -> Self {
        Self {
            state_values: DashMap::new(),
        }
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L118-124)
```rust
    pub fn init_for_block(&self, state_keys: Vec<StateKey>) {
        *self.state_view.write().unwrap() = RemoteStateView::new();
        REMOTE_EXECUTOR_REMOTE_KV_COUNT
            .with_label_values(&[&self.shard_id.to_string(), "prefetch_kv"])
            .inc_by(state_keys.len() as u64);
        self.pre_fetch_state_values(state_keys, false);
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L58-71)
```rust
    pub fn create_cross_shard_state_view(
        base_view: &'a S,
        transactions: &[TransactionWithDependencies<AnalyzedTransaction>],
    ) -> CrossShardStateView<'a, S> {
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
            }
        }
        CrossShardStateView::new(cross_shard_state_key, base_view)
    }
```
