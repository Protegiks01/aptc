# Audit Report

## Title
Gas Metering Bypass in BCS Native Function - Transaction Can Abort Without Paying for Deep Value Traversal

## Summary
The `native_to_bytes()` function in the BCS native module fails to charge gas when `read_ref()` encounters a runtime depth limit error. When processing deeply nested values (>128 levels), the function performs significant computational work traversing the value structure but aborts without charging gas, violating the Move VM's resource limit invariant. [1](#0-0) 

## Finding Description
The vulnerability exists in the error handling path of `native_to_bytes()`. The function uses the `?` operator when calling `read_ref()`, which causes any `PartialVMError` to propagate directly without charging accumulated gas costs. [2](#0-1) 

When `read_ref()` is called, it recursively traverses the value structure via `copy_value()`, incrementing depth at each level. If the value exceeds 128 levels of nesting, `check_depth()` returns a `VM_MAX_VALUE_DEPTH_REACHED` error after already performing 128+ levels of recursive traversal. [3](#0-2) [4](#0-3) 

This error propagates via the `?` operator directly as `Err(PartialVMError)`, which according to the interpreter's native function handling, does NOT charge the native function's accumulated gas cost. [5](#0-4) 

The function's own documentation explicitly states that failures in serialization steps should charge gas, but `read_ref()` failures violate this contract. [6](#0-5) 

This inconsistent error handling contrasts with other error paths in the same function that properly charge failure costs. [7](#0-6) 

Furthermore, the `ReadRef` bytecode instruction charges gas BEFORE calling `read_ref()`, ensuring work is always paid for even on failure. [8](#0-7) 

## Impact Explanation
This is a **Medium Severity** gas metering bypass vulnerability. An attacker can cause validators to perform unbounded computational work (up to transaction gas limits) without paying the corresponding gas costs for deep value traversal. While the impact per transaction is bounded by overall transaction gas limits, this violates the fundamental Move VM invariant that all computational work must be metered and paid for.

The vulnerability enables:
- Free CPU consumption during value traversal (128+ recursive calls)
- Type layout construction work without proper charging
- Validator resource exhaustion through repeated exploitation

This breaks the "Resource Limits: All operations must respect gas, storage, and computational limits" invariant and qualifies as a "gas calculation miscalculation enabling free computation" issue per the Medium severity criteria.

## Likelihood Explanation
The likelihood is **High** because:

1. **Easy to trigger**: Any user can create deeply nested structures in Move (test file confirms 129-level nesting is possible)
2. **No special permissions required**: Regular transaction senders can exploit this
3. **Documented behavior**: Tests show that depth 129 triggers `VM_MAX_VALUE_DEPTH_REACHED` [9](#0-8) 

4. **Wide applicability**: Any Move code using `bcs::to_bytes()` on deep structures hits this path

## Recommendation
The function must charge gas before calling `read_ref()` or catch errors and wrap them in `NativeResult::err()` with accumulated costs. The fix should match the error handling pattern used for other failures:

```rust
// Option 1: Catch and charge on error
let val = match ref_to_val.read_ref() {
    Ok(v) => v,
    Err(_) => {
        cost += gas_params.failure;
        return Ok(NativeResult::err(cost, NFE_BCS_SERIALIZATION_FAILURE));
    }
};

// Option 2: Charge gas before read (like ReadRef instruction)
// Requires adding gas charging for read_ref operations
gas_meter.charge_read_ref(ref_to_val.value_view())?;
let val = ref_to_val.read_ref()?;
```

The first option is simpler and maintains consistency with the function's existing error handling patterns at lines 57-62 and 75-78.

## Proof of Concept

The existing test demonstrates that depth 129 triggers the failure: [10](#0-9) 

To verify gas isn't charged, a Rust unit test can be added:

```rust
#[test]
fn test_deep_nesting_charges_gas() {
    // Create a 129-level nested structure
    // Call native_to_bytes()
    // Assert that gas_params.failure is charged in the returned NativeResult
    // Currently this test would FAIL because the function returns Err(PartialVMError)
    // instead of Ok(NativeResult::err(cost, ...))
}
```

The vulnerability is confirmed by the fact that line 65 uses `?` operator which bypasses the `NativeResult::err()` wrapping used in all other error paths within the same function.

**Notes**

The vulnerability affects both the Move stdlib version and the Aptos framework version of this function. Both implementations use the `?` operator at the `read_ref()` call without proper gas charging: [11](#0-10) 

The core issue is that `VM_MAX_VALUE_DEPTH_REACHED` is a **runtime resource limit check**, not a verifier-time type safety check, yet it's treated as an invariant violation (no gas charged). The VM configuration explicitly sets this as a runtime limit: [12](#0-11) 

This confirms the vulnerability is a legitimate gas metering bypass that violates the documented behavior and Move VM resource limit invariants.

### Citations

**File:** third_party/move/move-stdlib/src/natives/bcs.rs (L24-30)
```rust
 *   gas cost: size_of(val_type) * input_unit_cost +        | get type layout
 *             size_of(val) * input_unit_cost +             | serialize value
 *             max(size_of(output), 1) * output_unit_cost
 *
 *             If any of the first two steps fails, a partial cost + an additional failure_cost
 *             will be charged.
 *
```

**File:** third_party/move/move-stdlib/src/natives/bcs.rs (L50-65)
```rust
    let mut cost = 0.into();

    // pop type and value
    let ref_to_val = pop_arg!(args, Reference);
    let arg_type = &ty_args[0];

    // get type layout
    let layout = match context.type_to_type_layout(arg_type) {
        Ok(layout) => layout,
        Err(_) => {
            cost += gas_params.failure;
            return Ok(NativeResult::err(cost, NFE_BCS_SERIALIZATION_FAILURE));
        },
    };
    // serialize value
    let val = ref_to_val.read_ref()?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L1614-1616)
```rust
    pub fn read_ref(self) -> PartialVMResult<Value> {
        self.0.read_ref(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L6166-6170)
```rust
fn check_depth(depth: u64, max_depth: Option<u64>) -> PartialVMResult<()> {
    if max_depth.is_some_and(|max_depth| depth > max_depth) {
        return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
    }
    Ok(())
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1106-1106)
```rust
        let result = native_function(&mut native_context, ty_args, args)?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2566-2570)
```rust
                    Instruction::ReadRef => {
                        let reference = interpreter.operand_stack.pop_as::<Reference>()?;
                        gas_meter.charge_read_ref(reference.value_view())?;
                        let value = reference.read_ref()?;
                        interpreter.operand_stack.push(value)?;
```

**File:** third_party/move/move-stdlib/tests/bcs_tests.move (L89-102)
```text
    fun box127<T>(x: T): Box127<T> {
        Box127 { x: box63(box63(x)) }
    }

    #[test]
    fun encode_128() {
        bcs::to_bytes(&box127(true));
    }

    #[test]
    #[expected_failure] // VM_MAX_VALUE_DEPTH_REACHED
    fun encode_129() {
        bcs::to_bytes(&Box { x: box127(true) });
    }
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L93-93)
```rust
    let val = ref_to_val.read_ref()?;
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L68-68)
```rust
            max_value_nest_depth: Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH),
```
