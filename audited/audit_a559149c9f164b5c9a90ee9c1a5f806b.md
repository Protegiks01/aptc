# Audit Report

## Title
Revocation Delay: Removed Validators Maintain Authenticated Connections Until Next Connectivity Check

## Summary
When a validator is removed from the trusted peers set during an epoch change, existing authenticated Noise connections remain active for up to 5 seconds (the connectivity check interval). This creates a temporal window where removed validators can continue to send and receive network messages despite being removed from the validator set.

## Finding Description

The vulnerability exists in the ConnectivityManager's architecture, where connection termination is decoupled from trusted peer updates.

**Flow of the Issue:**

1. During an epoch change, the validator set is updated via `on_new_epoch` in stake.move, removing certain validators from the active set.

2. The discovery system detects this change and sends an `UpdateDiscoveredPeers` request to the ConnectivityManager: [1](#0-0) 

3. The ConnectivityManager's `handle_update_discovered_peers` method updates the `discovered_peers` and `trusted_peers` sets: [2](#0-1) 

4. **Critical Gap:** The method does NOT immediately call `close_stale_connections()`. Instead, connection cleanup only occurs during periodic `check_connectivity()` calls triggered by a timer: [3](#0-2) 

5. The `close_stale_connections()` method identifies and disconnects stale peers: [4](#0-3) 

6. The connectivity check interval defaults to 5 seconds: [5](#0-4) 

**Attack Window:** Between when `trusted_peers` is updated and when the next `check_connectivity()` executes (up to 5 seconds), removed validators maintain their authenticated Noise connections.

**What Can Removed Validators Do?**

During this window, removed validators can:
- **Receive network messages**: Including consensus proposals, votes, and other protocol messages from the new epoch (information leakage)
- **Send network messages**: Consuming network bandwidth and processing resources (potential DoS vector)

**Defense in Depth:** The consensus layer provides partial protection via `ValidatorVerifier`, which validates message signatures against the current epoch's validator set. Messages from removed validators (who have 0 voting power in the new epoch) are rejected during consensus processing. However, this doesn't prevent:
- Information leakage from receiving messages
- Resource exhaustion from processing and rejecting invalid messages
- Non-consensus network protocols that may not check ValidatorVerifier

## Impact Explanation

**Severity: High**

This qualifies as **High severity** under "Significant protocol violations" because:

1. **Protocol Violation**: The security invariant that removed validators should be immediately disconnected is violated. The network authentication layer (Noise handshake) trusts these peers for up to 5 seconds after trust should be revoked.

2. **Information Leakage**: Removed validators can observe network traffic from the new epoch before disconnection, potentially including:
   - Early consensus proposals revealing transaction ordering
   - Voting patterns from active validators
   - Network topology information

3. **Resource Exhaustion Attack Surface**: If multiple validators are removed simultaneously (e.g., during major validator set changes), they could coordinate to flood the network with messages during the window, causing:
   - Bandwidth consumption
   - CPU cycles wasted validating and rejecting messages
   - Potential impact on consensus liveness if resources are exhausted

4. **Amplification Potential**: In a coordinated attack, a malicious validator could deliberately get themselves removed (e.g., by going offline) to exploit this window.

## Likelihood Explanation

**Likelihood: Medium**

- **Prerequisites**: Attacker must be an existing validator who gets removed from the validator set
- **Trigger**: Occurs naturally during epoch changes when validators are removed
- **Window**: Limited to 5 seconds, reducing exploitation opportunity
- **Complexity**: Low - the vulnerability is triggered automatically, no complex exploit needed
- **Frequency**: Occurs whenever validators are removed (varies by network governance)

The likelihood is medium because while the attack window is small, validator removals are a normal part of network operation, and malicious validators could potentially time their actions to coincide with expected removal.

## Recommendation

**Immediate Fix:** Call `close_stale_connections()` immediately after updating the trusted peers set in `handle_update_discovered_peers()`:

```rust
// In handle_update_discovered_peers(), after line 1001:
// update eligible peers accordingly
if keys_updated {
    // For each peer, union all of the pubkeys from each discovery source
    // to generate the new eligible peers set.
    let new_eligible = self.discovered_peers.read().get_eligible_peers();

    // Swap in the new eligible peers set
    if let Err(error) = self
        .peers_and_metadata
        .set_trusted_peers(&self.network_context.network_id(), new_eligible)
    {
        error!(
            NetworkSchema::new(&self.network_context),
            error = %error,
            "Failed to update trusted peers set"
        );
    }
    
    // ADD THIS: Immediately close stale connections when trusted peers change
    tokio::spawn({
        let mut conn_mgr_clone = /* clone necessary fields */;
        async move {
            conn_mgr_clone.close_stale_connections().await;
        }
    });
}
```

**Alternative Approach:** Make `close_stale_connections()` a synchronous operation and call it immediately, or add an explicit "trust revocation" event that triggers immediate disconnection.

## Proof of Concept

```rust
// Test case demonstrating the revocation delay
#[tokio::test]
async fn test_validator_removal_revocation_delay() {
    use std::time::{Duration, Instant};
    
    // Setup: Create connectivity manager with 2 validators
    let (peer_id_1, peer_1, _, _) = test_peer(AccountAddress::from_hex_literal("0x1").unwrap());
    let (peer_id_2, peer_2, _, _) = test_peer(AccountAddress::from_hex_literal("0x2").unwrap());
    
    let initial_peers = hashmap! {
        peer_id_1 => peer_1.clone(),
        peer_id_2 => peer_2.clone(),
    };
    
    let (mut mock, mut conn_mgr) = TestHarness::new(initial_peers.clone());
    
    // Simulate both validators connecting
    mock.trigger_connectivity_check().await;
    mock.trigger_pending_dials().await;
    // ... connection setup ...
    
    // Epoch change: Remove validator 2 from trusted peers
    let start_time = Instant::now();
    let updated_peers = hashmap! { peer_id_1 => peer_1 }; // Only peer 1 remains
    
    mock.send_update_discovered_peers(
        DiscoverySource::OnChainValidatorSet, 
        updated_peers
    ).await;
    
    // VULNERABILITY: peer_id_2 is still connected immediately after update
    assert_eq!(mock.get_connected_size().await, 2); // Both still connected!
    
    // Connection only closes after next connectivity check (up to 5 seconds)
    mock.trigger_connectivity_check().await; // Trigger the periodic check
    
    let elapsed = start_time.elapsed();
    
    // Now peer_id_2 should be disconnected
    mock.expect_disconnect_success(peer_id_2, peer_2_addr).await;
    assert_eq!(mock.get_connected_size().await, 1);
    
    // Demonstrate the delay window
    assert!(elapsed >= Duration::from_secs(5), 
        "Connection remained active for at least 5 seconds after removal from trusted_peers");
}
```

**Notes:**

- This vulnerability represents a temporal gap in the security architecture where network-layer authentication (Noise) and application-layer trust (trusted_peers) are not synchronized.
- While consensus-level validation provides defense-in-depth, the 5-second window violates the principle of immediate revocation and creates an information leakage and DoS attack surface.
- The fix should ensure that trust revocation at the application layer immediately triggers connection termination at the network layer, maintaining the security invariant that untrusted peers cannot maintain authenticated connections.

### Citations

**File:** network/discovery/src/lib.rs (L141-150)
```rust
        while let Some(update) = source_stream.next().await {
            if let Ok(update) = update {
                trace!(
                    NetworkSchema::new(&network_context),
                    "{} Sending update: {:?}",
                    network_context,
                    update
                );
                let request = ConnectivityRequest::UpdateDiscoveredPeers(discovery_source, update);
                if let Err(error) = update_channel.try_send(request) {
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-531)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });

            // Close existing connections to stale peers
            for stale_peer in stale_peers {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&stale_peer),
                    "{} Closing stale connection to peer {}",
                    self.network_context,
                    stale_peer.short_str()
                );

                if let Err(disconnect_error) = self
                    .connection_reqs_tx
                    .disconnect_peer(stale_peer, DisconnectReason::StaleConnection)
                    .await
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&stale_peer),
                        error = %disconnect_error,
                        "{} Failed to close stale connection to peer {}, error: {}",
                        self.network_context,
                        stale_peer.short_str(),
                        disconnect_error
                    );
                }
            }
        }
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L807-832)
```rust
    async fn check_connectivity<'a>(
        &'a mut self,
        pending_dials: &'a mut FuturesUnordered<BoxFuture<'static, PeerId>>,
    ) {
        trace!(
            NetworkSchema::new(&self.network_context),
            "{} Checking connectivity",
            self.network_context
        );

        // Log the eligible peers with addresses from discovery
        sample!(SampleRate::Duration(Duration::from_secs(60)), {
            info!(
                NetworkSchema::new(&self.network_context),
                discovered_peers = ?self.discovered_peers,
                "Active discovered peers"
            )
        });

        // Cancel dials to peers that are no longer eligible.
        self.cancel_stale_dials().await;
        // Disconnect from connected peers that are no longer eligible.
        self.close_stale_connections().await;
        // Dial peers which are eligible but are neither connected nor queued for dialing in the
        // future.
        self.dial_eligible_peers(pending_dials).await;
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-1002)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .discovery_source(&src),
                    "{} pubkey sets updated for peer: {}, pubkeys: {}",
                    self.network_context,
                    peer_id.short_str(),
                    peer.keys
                );
                keys_updated = true;
                peer_updated = true;
            }

            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }

            // If we're currently trying to dial this peer, we reset their
            // dial state. As a result, we will begin our next dial attempt
            // from the first address (which might have changed) and from a
            // fresh backoff (since the current backoff delay might be maxed
            // out if we can't reach any of their previous addresses).
            if peer_updated {
                if let Some(dial_state) = self.dial_states.get_mut(&peer_id) {
                    *dial_state = DialState::new(self.backoff_strategy.clone());
                }
            }
        }

        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
    }
```

**File:** config/src/config/network_config.rs (L41-41)
```rust
pub const CONNECTIVITY_CHECK_INTERVAL_MS: u64 = 5000;
```
