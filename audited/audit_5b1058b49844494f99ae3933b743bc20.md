# Audit Report

## Title
Move Assembler Denial of Service via Unbounded Constant Pool Memory Consumption

## Summary
The Move assembler (move-asm) lacks size and depth validation when processing vector constants, allowing attackers to craft malicious `.masm` files with extremely large or deeply nested vector structures that consume excessive memory during assembly, causing denial of service.

## Finding Description

The vulnerability exists across multiple stages of constant processing in the Move assembler:

**1. Parser Stage (Unbounded Vector Parsing)**

The syntax parser recursively processes vector literals without depth or size limits: [1](#0-0) 

The `list` function that processes comma-separated elements has no bounds checking: [2](#0-1) 

**2. Type Conversion Stage (Unbounded Recursion)**

The `to_move_value` function recursively converts `AsmValue` to `MoveValue` without depth limits: [3](#0-2) 

**3. Serialization Stage (No Size Validation)**

The assembler serializes constants using BCS without checking the resulting size before adding to the constant pool: [4](#0-3) 

**4. Constant Pool Addition (No Pre-Validation)**

The `const_index` function adds serialized constants to the pool without size validation: [5](#0-4) 

**5. Delayed Validation (Too Late)**

Size limits are only enforced during final module serialization, after all memory consumption has occurred: [6](#0-5) [7](#0-6) 

**Attack Vectors:**

1. **Large Vector Attack**: `ld_const<vector<u8>> [0,0,0,0,... (millions of zeros)]`
2. **Deep Nesting Attack**: `ld_const<vector<vector<vector<...>>>> [[[[...]]]]`
3. **Combined Attack**: Large vectors at multiple nesting levels

Memory exhaustion occurs during parsing, conversion, BCS serialization, and constant pool storage—all BEFORE the `CONSTANT_SIZE_MAX` (65535 bytes) check can reject the oversized constant.

## Impact Explanation

**Severity: Medium (per question scope)**

This vulnerability affects the Move assembler build toolchain:

- **Denial of Service**: Assembler process crashes or hangs due to memory exhaustion or stack overflow
- **Development Impact**: Developers processing untrusted `.masm` files experience DoS
- **CI/CD Impact**: Build systems can be disrupted if processing malicious assembly files

**Important Limitation**: This vulnerability does NOT directly affect:
- Aptos validator nodes (they execute compiled bytecode, not assembly files)
- Blockchain consensus or safety
- On-chain state or fund security
- Runtime Move VM execution

The impact is limited to build-time tooling. However, if any production systems process untrusted `.masm` files (e.g., compilation services, testing infrastructure), they are vulnerable to resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: Medium-High for affected systems**

- **Attack Complexity**: Very low—attacker only needs to create a text file with malicious assembly syntax
- **Attack Requirements**: No authentication or special privileges required
- **Exploitability**: Trivial to exploit if the assembler processes untrusted input

The vulnerability is certain to trigger if a malicious `.masm` file is processed. However, the likelihood of real-world impact depends on whether production systems actually assemble untrusted `.masm` files, which is uncommon.

## Recommendation

Implement multi-layered validation to prevent unbounded memory consumption:

**1. Add Vector Size Limit During Parsing**

In `syntax.rs`, enforce a maximum vector element count during parsing (e.g., 10,000 elements).

**2. Add Depth Limit During Type Conversion**

In `value.rs`, track recursion depth in `to_move_value` and reject structures exceeding a reasonable limit (e.g., 32 levels).

**3. Add Early Size Validation Before Constant Pool Addition**

In `assembler.rs`, validate the BCS-serialized constant size against `CONSTANT_SIZE_MAX` before calling `const_index`:

```rust
// Before line 721
if bcs.len() > CONSTANT_SIZE_MAX as usize {
    return Err(anyhow!("constant exceeds maximum size of {} bytes", CONSTANT_SIZE_MAX));
}
```

**4. Consider Streaming/Chunked Processing**

For very large valid constants, consider streaming serialization to avoid loading entire structures into memory.

## Proof of Concept

Create a malicious `.masm` file named `dos_attack.masm`:

```
module 0xcafe::attack {
    fun exploit() {
        // Large vector attack: create vector with 1 million elements
        ld_const<vector<u8>> [0,0,0,0,0,0,0,0,0,0,... (repeat 1,000,000 times)]
        pop
        
        // Deep nesting attack: 1000 levels deep
        ld_const<vector<vector<vector<... (1000 levels)>>>> [[[[... (1000 levels) ]]]]
        pop
        
        ret
    }
}
```

**Exploitation Steps:**

1. Generate the malicious file programmatically (manual creation impractical for 1M elements)
2. Run the assembler: `move-asm dos_attack.masm`
3. Observe memory exhaustion or stack overflow before assembly completes

**Expected Result**: The assembler process consumes all available memory and crashes/hangs, demonstrating the DoS condition.

**Test Script** (Rust):
```rust
// Generate malicious .masm file
use std::fs::File;
use std::io::Write;

fn generate_dos_masm() -> std::io::Result<()> {
    let mut file = File::create("dos_attack.masm")?;
    writeln!(file, "module 0xcafe::attack {{")?;
    writeln!(file, "    fun exploit() {{")?;
    write!(file, "        ld_const<vector<u8>> [")?;
    for i in 0..1_000_000 {
        write!(file, "0")?;
        if i < 999_999 {
            write!(file, ",")?;
        }
    }
    writeln!(file, "]")?;
    writeln!(file, "        pop")?;
    writeln!(file, "        ret")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;
    Ok(())
}
```

**Notes**

This vulnerability represents a classic resource exhaustion issue where validation occurs too late in the processing pipeline. While the final serialization step correctly enforces `CONSTANT_SIZE_MAX`, all intermediate stages allocate unbounded memory before reaching that check. The fix requires defense-in-depth: validating constraints at each processing stage rather than only at the final output.

The scope of impact is limited to the assembler toolchain and does not directly affect the Aptos blockchain's runtime security, consensus, or state integrity. However, for any systems that process untrusted assembly files, this represents a clear denial-of-service attack vector that should be mitigated.

### Citations

**File:** third_party/move/tools/move-asm/src/syntax.rs (L339-350)
```rust
    fn list<E>(
        &mut self,
        parser: impl Fn(&mut AsmParser) -> AsmResult<E>,
        separator: &str,
    ) -> AsmResult<Vec<E>> {
        let mut result = vec![parser(self)?];
        while self.is_special(separator) {
            self.advance()?;
            result.push(parser(self)?)
        }
        Ok(result)
    }
```

**File:** third_party/move/tools/move-asm/src/syntax.rs (L366-374)
```rust
        } else if self.is_special("[") {
            self.advance()?;
            let elems = if self.is_value() {
                self.list(Self::value, ",")?
            } else {
                vec![]
            };
            self.expect_special("]")?;
            Ok(AsmValue::Vector(elems))
```

**File:** third_party/move/tools/move-asm/src/value.rs (L119-129)
```rust
            SignatureToken::Vector(elem_type) => {
                if let AsmValue::Vector(vals) = self {
                    Ok(MoveValue::Vector(
                        vals.iter()
                            .map(|v| v.to_move_value(elem_type))
                            .collect::<anyhow::Result<Vec<_>>>()?,
                    ))
                } else {
                    Err(anyhow!("expected vector value"))
                }
            },
```

**File:** third_party/move/tools/move-asm/src/assembler.rs (L713-727)
```rust
            "ld_const" => {
                let [arg1, arg2] = self.args2(instr)?;
                let ty = self.type_(instr, arg1)?;
                if let Argument::Constant(val) = arg2 {
                    let move_value = self.add_diags(instr.loc, val.to_move_value(&ty))?;
                    let bcs = move_value
                        .simple_serialize()
                        .expect("value serialization succeeds");
                    let idx = self.add_diags(instr.loc, self.builder.const_index(bcs, ty))?;
                    LdConst(idx)
                } else {
                    self.error(instr.loc, "expected a constant value");
                    return None;
                }
            },
```

**File:** third_party/move/tools/move-asm/src/module_builder.rs (L890-903)
```rust
    pub fn const_index(&self, data: Vec<u8>, type_: SignatureToken) -> Result<ConstantPoolIndex> {
        let const_ = Constant {
            type_: type_.clone(),
            data: data.clone(),
        };
        self.index(
            &mut self.module.borrow_mut().constant_pool,
            &mut self.cons_to_idx.borrow_mut(),
            (data, type_),
            const_,
            ConstantPoolIndex,
            "constant",
        )
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L69-69)
```rust
pub const CONSTANT_SIZE_MAX: u64 = 65535;
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L188-190)
```rust
fn serialize_constant_size(binary: &mut BinaryData, len: usize) -> Result<()> {
    write_as_uleb128(binary, len as u64, CONSTANT_SIZE_MAX)
}
```
