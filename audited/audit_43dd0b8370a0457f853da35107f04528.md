# Audit Report

## Title
Gas Undercharging via Data Cache Inheritance in Legacy Prologue Session Path

## Summary
When `gas_feature_version < 1`, the `legacy_inherit_prologue_session()` function directly inherits the prologue session's data cache without flushing it. Since the prologue executes with an `UnmeteredGasMeter`, any resources loaded during prologue validation remain cached and are not charged for gas when subsequently accessed during user transaction execution, resulting in systematic gas undercharging.

## Finding Description

The vulnerability exists in the transaction execution flow when networks operate with `gas_feature_version < 1`. The execution follows this path:

1. **Prologue Execution with Unmetered Gas**: The transaction prologue runs with an `UnmeteredGasMeter` [1](#0-0) 

This unmetered gas meter is passed to the prologue Move function execution [2](#0-1) 

2. **Resource Loading During Prologue**: The prologue loads multiple resources to validate the transaction, including the sender's `Account` resource (for authentication key and sequence number verification) and the gas payer's balance resources [3](#0-2) 

3. **Cache Behavior**: When resources are loaded, they are stored in the session's `TransactionDataCache`. The interpreter only charges gas when `bytes_loaded` is `Some(...)`, which occurs only on cache misses [4](#0-3) 

The data cache implementation returns `None` for `bytes_loaded` when a resource is already cached [5](#0-4) 

4. **Legacy Session Inheritance**: When `gas_feature_version < 1`, the prologue session is directly inherited without flushing the cache [6](#0-5) 

This contrasts with the new path where the session is finished and a new one is created, flushing the cache [7](#0-6) 

5. **Gas Undercharging**: When the user transaction payload accesses the same resources (sender's `Account`, gas payer's `CoinStore`, etc.), they are already in the cache, so `bytes_loaded` is `None` and no gas is charged for loading them.

The gas feature version defaults to 0 when `GasScheduleV2` is not configured [8](#0-7) 

## Impact Explanation

This vulnerability constitutes a **High Severity** issue under the Aptos bug bounty criteria due to:

1. **Protocol Violation**: It breaks the critical invariant that "All operations must respect gas, storage, and computational limits" by allowing free resource loads for commonly accessed resources.

2. **Economic Impact**: Systematic gas undercharging reduces validator revenue and can be exploited by any transaction sender on affected networks.

3. **Exploitability**: Any transaction that accesses resources loaded during the prologue (Account resources, CoinStore resources) benefits from free loads. This includes most common transaction patterns.

4. **Determinism Concern**: While the execution itself remains deterministic across validators (all experience the same undercharging), it violates the economic security model.

## Likelihood Explanation

The likelihood is **Medium to High**:

- **Affected Networks**: All networks with `gas_feature_version < 1` are vulnerable, including older deployments, certain testnets, or networks that haven't upgraded their gas schedule.

- **Automatic Exploitation**: The vulnerability is triggered automatically for any transaction on affected networks - no special crafting required. Every transaction that accesses commonly-used resources benefits from the undercharging.

- **Mitigation Exists**: Networks with `gas_feature_version >= 1` are protected, but the legacy code path remains in the codebase for backward compatibility.

## Recommendation

**Short-term**: Ensure all production networks upgrade to `gas_feature_version >= 1` by deploying `GasScheduleV2` configurations.

**Long-term**: Remove the legacy session inheritance path entirely once all networks have migrated:

```rust
// In prologue.rs, remove the conditional and always flush the cache:
pub fn into_user_session(
    self,
    vm: &AptosVM,
    txn_meta: &TransactionMetadata,
    resolver: &'r impl AptosMoveResolver,
    change_set_configs: &ChangeSetConfigs,
    module_storage: &impl AptosModuleStorage,
) -> Result<(SystemSessionChangeSet, UserSession<'r>), VMStatus> {
    let Self { session } = self;
    
    // Always flush cache to ensure correct gas charging
    let change_set = session.finish_with_squashed_change_set(
        change_set_configs,
        module_storage,
        false,
    )?;
    let prologue_session_change_set =
        SystemSessionChangeSet::new(change_set.clone(), change_set_configs)?;

    resolver.release_resource_group_cache();
    Ok((
        prologue_session_change_set,
        UserSession::new(vm, txn_meta, resolver, change_set),
    ))
}
```

## Proof of Concept

To demonstrate this vulnerability:

1. Deploy a network with `gas_feature_version = 0` (or use an existing network with old gas schedule)
2. Submit a transaction that accesses the sender's `Account` resource via `borrow_global` or similar operations
3. Compare gas charged for resource loads with the expected cost
4. Observe that resources already loaded during prologue incur zero loading cost

**Rust Test Outline**:
```rust
#[test]
fn test_gas_undercharging_legacy_path() {
    // Setup executor with gas_feature_version = 0
    // Execute transaction that accesses Account resource
    // Verify gas charged is less than expected
    // Compare with gas_feature_version >= 1 path
    // Assert: legacy path charges less gas
}
```

**Notes**: 
- This is a design-level vulnerability in the legacy gas accounting path, not a new bug
- The mitigation (gas_feature_version >= 1) is already deployed and documented in the code
- Networks still running legacy configurations remain vulnerable
- The vulnerability demonstrates why the cache-flushing approach was necessary and validates the current implementation strategy

### Citations

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L123-123)
```rust
    let mut gas_meter = UnmeteredGasMeter;
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L233-245)
```rust
        session
            .execute_function_bypass_visibility(
                &APTOS_TRANSACTION_VALIDATION.module_id(),
                prologue_function_name,
                vec![],
                serialized_args,
                &mut gas_meter,
                traversal_context,
                module_storage,
            )
            .map(|_return_vals| ())
            .map_err(expect_no_verification_errors)
            .or_else(|err| convert_prologue_error(err, log_context))
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L126-213)
```text
    fun prologue_common(
        sender: &signer,
        gas_payer: &signer,
        replay_protector: ReplayProtector,
        txn_authentication_key: Option<vector<u8>>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        let sender_address = signer::address_of(sender);
        let gas_payer_address = signer::address_of(gas_payer);
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));

        // TODO[Orderless]: Here, we are maintaining the same order of validation steps as before orderless txns were introduced.
        // Ideally, do the replay protection check in the end after the authentication key check and gas payment checks.

        // Check if the authentication key is valid
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };

        // Check for replay protection
        match (replay_protector) {
            SequenceNumber(txn_sequence_number) => {
                check_for_replay_protection_regular_txn(
                    sender_address,
                    gas_payer_address,
                    txn_sequence_number,
                );
            },
            Nonce(nonce) => {
                check_for_replay_protection_orderless_txn(
                    sender_address,
                    nonce,
                    txn_expiration_time,
                );
            }
        };

        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1318-1332)
```rust
        let (gv, bytes_loaded) =
            data_cache.load_resource_mut(gas_meter, traversal_context, &addr, ty)?;
        if let Some(bytes_loaded) = bytes_loaded {
            gas_meter.charge_load_resource(
                addr,
                TypeWithRuntimeEnvironment {
                    ty,
                    runtime_environment: self.loader.runtime_environment(),
                },
                gv.view(),
                bytes_loaded,
            )?;
        }

        Ok(gv)
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L132-147)
```rust
        let bytes_loaded = if !self.data_cache.contains_resource(addr, ty) {
            let (entry, bytes_loaded) = TransactionDataCache::create_data_cache_entry(
                self.loader,
                &LayoutConverter::new(self.loader),
                gas_meter,
                traversal_context,
                self.loader.unmetered_module_storage(),
                self.resource_resolver,
                addr,
                ty,
            )?;
            self.data_cache.insert_resource(*addr, ty.clone(), entry)?;
            Some(bytes_loaded)
        } else {
            None
        };
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L59-80)
```rust
        if vm.gas_feature_version() >= 1 {
            // Create a new session so that the data cache is flushed.
            // This is to ensure we correctly charge for loading certain resources, even if they
            // have been previously cached in the prologue.
            //
            // TODO(Gas): Do this in a better way in the future, perhaps without forcing the data cache to be flushed.
            // By releasing resource group cache, we start with a fresh slate for resource group
            // cost accounting.

            let change_set = session.finish_with_squashed_change_set(
                change_set_configs,
                module_storage,
                false,
            )?;
            let prologue_session_change_set =
                SystemSessionChangeSet::new(change_set.clone(), change_set_configs)?;

            resolver.release_resource_group_cache();
            Ok((
                prologue_session_change_set,
                UserSession::new(vm, txn_meta, resolver, change_set),
            ))
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L82-86)
```rust
            Ok((
                SystemSessionChangeSet::empty(),
                UserSession::legacy_inherit_prologue_session(session),
            ))
        }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L15-19)
```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0)
}
```
