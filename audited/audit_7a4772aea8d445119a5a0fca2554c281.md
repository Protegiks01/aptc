# Audit Report

## Title
Silent Indexer Initialization Failure Breaks Query Services on Sharded Storage Nodes

## Summary
The `get_indexer_db()` function silently returns `None` when the internal indexer is disabled, hiding a critical configuration mismatch that breaks all API query services on nodes with storage sharding enabled. Since storage sharding is mandatory on mainnet/testnet, but the internal indexer flags default to `false`, this creates a broken-by-default configuration that only fails at runtime with cryptic error messages.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Silent Failure in get_indexer_db()**: [1](#0-0) 

The function returns `None` without any logging when `is_internal_indexer_db_enabled()` returns false.

2. **Internal Indexer Disabled by Default**: [2](#0-1) 

All indexer enable flags default to `false`, meaning `is_internal_indexer_db_enabled()` returns false by default.

3. **API Requires Indexer When Sharding Enabled**: [3](#0-2) 

When DB sharding is enabled, the API code path requires the indexer reader to exist, otherwise it fails with "Internal indexer reader doesn't exist".

The same pattern exists for multiple critical API endpoints:
- State values query: [4](#0-3) 
- Resources pagination: [5](#0-4) 
- Modules pagination: [6](#0-5) 
- Account transactions: [7](#0-6) 

4. **Storage Sharding Mandatory on Mainnet/Testnet**: [8](#0-7) 

This enforces that all mainnet/testnet nodes must have storage sharding enabled.

5. **Insufficient Config Validation**: [9](#0-8) 

The config sanitizer only validates that you can't enable the internal indexer without sharding, but doesn't validate the reverse dependency.

**Attack Scenario:**
A node operator deploys a mainnet/testnet node with:
- `storage.rocksdb_configs.enable_storage_sharding = true` (mandatory)
- Default indexer config (all enable flags = false)

The node starts successfully, but all API queries requiring the indexer fail at runtime with generic errors like "Indexer reader doesn't exist", providing no indication that the root cause is a configuration mismatch.

## Impact Explanation

This is a **Medium Severity** issue per the Aptos bug bounty criteria:

1. **Service Availability Break**: All critical API query endpoints fail for accounts, events, resources, modules, and transactions when DB sharding is enabled
2. **Poor Debuggability**: The silent failure during initialization provides no early warning, and runtime errors don't indicate the root cause
3. **Broken Default Configuration**: On mandatory sharded storage (mainnet/testnet), the default indexer config creates a non-functional API
4. **Downstream Service Impact**: External indexers and applications depending on the REST API receive failures without understanding why

This doesn't reach High severity because:
- No consensus or validator operation impact
- No funds loss
- No permanent state corruption
- Can be fixed by configuration change

However, it significantly impacts node operator experience and downstream service reliability.

## Likelihood Explanation

**Likelihood: High**

1. **Affects All Default Deployments**: Any operator following basic documentation without explicitly enabling indexer flags will hit this issue on mainnet/testnet
2. **No Early Detection**: The configuration passes validation and the node starts normally
3. **Silent Failure**: No logs or warnings during initialization
4. **Widespread Impact**: Affects all query-serving nodes (public fullnodes, archive nodes)

The only mitigation is that experienced operators using Helm templates have indexer flags pre-configured: [10](#0-9) 

However, operators manually configuring nodes or using minimal templates will encounter this issue.

## Recommendation

**Add Config Validation:**
Add reverse validation in the `StorageConfig` sanitizer to ensure that if storage sharding is enabled, at least one internal indexer feature must be enabled:

```rust
// In config/src/config/storage_config.rs, add to sanitize():
if node_config.storage.rocksdb_configs.enable_storage_sharding 
    && !node_config.indexer_db_config.is_internal_indexer_db_enabled() {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Internal indexer must be enabled when storage sharding is enabled. \
         Set at least one of: indexer_db_config.enable_transaction, \
         indexer_db_config.enable_event, or indexer_db_config.enable_statekeys to true".into(),
    ));
}
```

**Add Logging:**
Add warning/error logging in `get_indexer_db()`:

```rust
pub fn get_indexer_db(node_config: &NodeConfig) -> Option<InternalIndexerDB> {
    if !node_config.indexer_db_config.is_internal_indexer_db_enabled() {
        if node_config.storage.rocksdb_configs.enable_storage_sharding {
            error!("Internal indexer is disabled but storage sharding is enabled. \
                   API queries will fail. Enable at least one indexer feature.");
        } else {
            info!("Internal indexer is disabled");
        }
        return None;
    }
    // ... rest of function
}
```

## Proof of Concept

**Configuration File (broken_config.yaml):**
```yaml
base:
  data_dir: "/opt/aptos/data"
  role: "full_node"

storage:
  rocksdb_configs:
    enable_storage_sharding: true

indexer_db_config:
  enable_transaction: false
  enable_event: false
  enable_statekeys: false

api:
  enabled: true
```

**Reproduction Steps:**

1. Start a node with the above configuration on testnet/mainnet
2. Node initializes successfully with no errors
3. Call `get_indexer_db()` returns `None` silently: [1](#0-0) 
4. API context is created with `indexer_reader = None`: [11](#0-10) 
5. Attempt API call: `GET /v1/accounts/{address}/events/{event_handle}/{field_name}`
6. API code executes with `db_sharding_enabled() = true`: [12](#0-11) 
7. Fails at: [13](#0-12) 
8. Returns HTTP 500 with error: "Internal indexer reader doesn't exist"

The error message provides no indication that this is a configuration issue or how to fix it.

## Notes

This vulnerability demonstrates a critical gap in configuration validation where the dependency relationship between storage sharding and internal indexer is only validated in one direction. The silent failure pattern in initialization code makes debugging significantly harder for node operators, especially when the error only manifests at runtime in downstream services.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L59-65)
```rust
    pub fn get_indexer_db(node_config: &NodeConfig) -> Option<InternalIndexerDB> {
        if !node_config
            .indexer_db_config
            .is_internal_indexer_db_enabled()
        {
            return None;
        }
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-80)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
}
```

**File:** config/src/config/internal_indexer_db_config.rs (L91-99)
```rust
        // Shouldn't turn on internal indexer for db without sharding
        if !node_config.storage.rocksdb_configs.enable_storage_sharding
            && config.is_internal_indexer_db_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Don't turn on internal indexer db if DB sharding is off".into(),
            ));
        }
```

**File:** api/src/context.rs (L443-458)
```rust
        let mut iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        None,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(&StateKeyPrefix::from(address), None, version)?
        };
```

**File:** api/src/context.rs (L477-496)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L568-587)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L900-920)
```rust
        let txns_res = if !db_sharding_enabled(&self.node_config) {
            self.db.get_account_ordered_transactions(
                address,
                start_seq_number,
                limit as u64,
                true,
                ledger_version,
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Indexer reader is None"))
                .map_err(|err| {
                    E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
                })?
                .get_account_ordered_transactions(
                    address,
                    start_seq_number,
                    limit as u64,
                    true,
                    ledger_version,
```

**File:** api/src/context.rs (L1096-1103)
```rust
        let mut res = if !db_sharding_enabled(&self.node_config) {
            self.db
                .get_events(event_key, start, order, limit as u64, ledger_version)?
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Internal indexer reader doesn't exist"))?
                .get_events(event_key, start, order, limit as u64, ledger_version)?
```

**File:** api/src/context.rs (L1771-1773)
```rust
fn db_sharding_enabled(node_config: &NodeConfig) -> bool {
    node_config.storage.rocksdb_configs.enable_storage_sharding
}
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```

**File:** testsuite/forge/src/backend/k8s/helm-values/aptos-node-default-values.yaml (L28-32)
```yaml
    storage:
      rocksdb_configs:
        enable_storage_sharding: true
    indexer_db_config:
      enable_event: true
```

**File:** aptos-node/src/services.rs (L82-98)
```rust
    let (db_indexer_runtime, txn_event_reader) = match bootstrap_internal_indexer_db(
        node_config,
        db_rw.clone(),
        internal_indexer_db,
        update_receiver,
    ) {
        Some((runtime, db_indexer)) => (Some(runtime), Some(db_indexer)),
        None => (None, None),
    };

    let indexer_readers = IndexerReaders::new(indexer_async_v2, txn_event_reader);

    // Create the API runtime
    let indexer_reader: Option<Arc<dyn IndexerReader>> = indexer_readers.map(|readers| {
        let trait_object: Arc<dyn IndexerReader> = Arc::new(readers);
        trait_object
    });
```
