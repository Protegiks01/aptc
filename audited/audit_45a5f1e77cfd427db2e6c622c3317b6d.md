# Audit Report

## Title
Timeout Certificate Deserialization DoS via Oversized Rounds Vector

## Summary
The `AggregateSignatureWithRounds` struct in timeout certificates lacks deserialization-time validation of the relationship between the aggregated signature's voter count and the rounds vector length. An attacker can craft malicious timeout certificates with a small number of voters but an extremely large rounds vector (up to ~8 million elements), causing memory exhaustion during deserialization and subsequent cloning operations.

## Finding Description
The vulnerability exists in the `AggregateSignatureWithRounds` struct which contains two fields: an `AggregateSignature` (with a bitmap indicating which validators signed) and a `Vec<Round>` (containing round numbers for each signer). [1](#0-0) 

The constructor enforces an invariant that the number of voters must equal the rounds vector length: [2](#0-1) 

However, when deserializing via the derived `Deserialize` trait, this constructor is **bypassed entirely**. An attacker can craft a serialized `TwoChainTimeoutCertificate` where:
- The `AggregateSignature.validator_bitmask` has only N bits set (e.g., 3 validators)
- The `rounds` vector contains M elements where M >> N (e.g., 8 million u64 values â‰ˆ 64 MiB)

**Attack Propagation Path:**

1. Attacker crafts malicious `TwoChainTimeoutCertificate` wrapped in `ProposalMsg` or `SyncInfo`
2. Network layer receives and deserializes the message using BCS with only recursion depth limits (not size limits): [3](#0-2) [4](#0-3) 

The `RECURSION_LIMIT` (64) only constrains nesting depth, not vector size. A `Vec<Round>` with millions of elements is depth-1.

3. BCS deserialization allocates ~64 MiB for the rounds vector
4. Message forwarded to epoch manager, which spawns verification task
5. During verification, `get_voters_and_rounds()` **clones the entire rounds vector**: [5](#0-4) 

This doubles memory consumption to ~128 MiB per malicious message.

6. The `zip()` operation only uses the first N elements (matching the bitmap), wasting the remaining M-N elements

**Invariant Violation:** This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The deserialization consumes excessive memory without corresponding validation.

## Impact Explanation
**Medium Severity** per Aptos Bug Bounty criteria:

This is a **validator node slowdown/crash** vulnerability. An attacker can:
- Send multiple malicious messages simultaneously (e.g., 10 messages = 1.28 GB memory spike)
- Cause memory pressure on validator nodes, leading to:
  - Increased garbage collection overhead
  - Slower consensus message processing
  - Potential OOM crashes under sustained attack
  - Degraded network participation

The network message size limit of 64 MiB enables this attack: [6](#0-5) 

While this doesn't directly cause consensus safety violations or fund loss, it degrades validator availability and network liveness, qualifying as Medium severity under "State inconsistencies requiring intervention."

## Likelihood Explanation
**HIGH Likelihood:**
- No authentication required - any network peer can send consensus messages
- Trivial to exploit - just requires crafting a malformed BCS-serialized structure
- No rate limiting specifically for oversized internal data structures
- Attack is repeatable and scalable
- Detection is difficult until memory exhaustion symptoms appear

## Recommendation
Add explicit validation immediately after deserialization to enforce the invariant. Implement a custom `Deserialize` implementation or add a validation hook:

**Option 1: Custom Deserialize Implementation**
```rust
impl<'de> Deserialize<'de> for AggregateSignatureWithRounds {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct AggregateSignatureWithRoundsHelper {
            sig: AggregateSignature,
            rounds: Vec<Round>,
        }
        
        let helper = AggregateSignatureWithRoundsHelper::deserialize(deserializer)?;
        
        if helper.sig.get_num_voters() != helper.rounds.len() {
            return Err(serde::de::Error::custom(format!(
                "Rounds vector length {} does not match voter count {}",
                helper.rounds.len(),
                helper.sig.get_num_voters()
            )));
        }
        
        Ok(AggregateSignatureWithRounds {
            sig: helper.sig,
            rounds: helper.rounds,
        })
    }
}
```

**Option 2: Add Early Validation**
Add validation in `TwoChainTimeoutCertificate::verify()` before any operations on the rounds vector:

```rust
pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
    // Validate rounds vector length matches voter count FIRST
    ensure!(
        self.signatures_with_rounds.sig().get_num_voters() 
            == self.signatures_with_rounds.rounds().len(),
        "Rounds vector length {} does not match voter count {}",
        self.signatures_with_rounds.rounds().len(),
        self.signatures_with_rounds.sig().get_num_voters()
    );
    
    // ... rest of verification
}
```

## Proof of Concept
```rust
#[test]
fn test_oversized_rounds_vector_dos() {
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        validator_verifier::random_validator_verifier,
    };
    use aptos_bitvec::BitVec;
    use std::time::Instant;

    // Setup validators
    let (signers, validators) = random_validator_verifier(4, None, false);
    
    // Create legitimate timeout certificate
    let timeout = TwoChainTimeout::new(1, 10, /* ... */);
    
    // Craft malicious AggregateSignatureWithRounds
    let mut bitmask = BitVec::default();
    bitmask.set(0); // Only 1 voter in bitmap
    bitmask.set(1);
    bitmask.set(2); // 3 voters total
    
    let malicious_sig = AggregateSignature::new(bitmask, None);
    
    // Create oversized rounds vector (e.g., 1 million elements)
    let oversized_rounds: Vec<Round> = (0..1_000_000).map(|i| i as Round).collect();
    
    println!("Malicious rounds vector size: {} MB", 
             (oversized_rounds.len() * 8) / (1024 * 1024));
    
    let malicious_aggregate = AggregateSignatureWithRounds::new(
        malicious_sig,
        oversized_rounds.clone(), // This will panic in constructor
    );
    
    // To actually exploit via deserialization, serialize manually:
    let serialized = bcs::to_bytes(&(malicious_sig, oversized_rounds)).unwrap();
    println!("Serialized size: {} bytes", serialized.len());
    
    // Deserialize - this allocates massive memory
    let start = Instant::now();
    let deserialized: (AggregateSignature, Vec<Round>) = 
        bcs::from_bytes(&serialized).unwrap();
    println!("Deserialization took: {:?}", start.elapsed());
    
    // Memory is now allocated but validation happens later
    println!("Voter count: {}", deserialized.0.get_num_voters());
    println!("Rounds vector length: {}", deserialized.1.len());
    assert_ne!(deserialized.0.get_num_voters(), deserialized.1.len());
}
```

## Notes
This vulnerability is particularly concerning because:
1. The attack surface includes all validators receiving `ProposalMsg` and `SyncInfo` messages
2. The memory allocation occurs during routine message processing
3. The `clone()` operation at verification time doubles the memory impact
4. Multiple simultaneous malicious messages can compound the effect
5. The MAX_VALIDATOR_SET_SIZE (65,536) is irrelevant since the attack uses mismatched lengths

The fix should be implemented in the deserialization path to fail fast before memory allocation, rather than waiting for verification.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L353-357)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub struct AggregateSignatureWithRounds {
    sig: AggregateSignature,
    rounds: Vec<Round>,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L360-363)
```rust
    pub fn new(sig: AggregateSignature, rounds: Vec<Round>) -> Self {
        assert_eq!(sig.get_num_voters(), rounds.len());
        Self { sig, rounds }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L379-388)
```rust
    pub fn get_voters_and_rounds(
        &self,
        ordered_validator_addresses: &[AccountAddress],
    ) -> Vec<(AccountAddress, Round)> {
        self.sig
            .get_signers_addresses(ordered_validator_addresses)
            .into_iter()
            .zip(self.rounds.clone())
            .collect()
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L156-172)
```rust
    fn encoding(self) -> Encoding {
        match self {
            ProtocolId::ConsensusDirectSendJson | ProtocolId::ConsensusRpcJson => Encoding::Json,
            ProtocolId::ConsensusDirectSendCompressed | ProtocolId::ConsensusRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::MempoolDirectSend => Encoding::CompressedBcs(USER_INPUT_RECURSION_LIMIT),
            ProtocolId::MempoolRpc => Encoding::Bcs(USER_INPUT_RECURSION_LIMIT),
            _ => Encoding::Bcs(RECURSION_LIMIT),
        }
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L259-262)
```rust
    /// Deserializes the value using BCS encoding (with a specified limit)
    fn bcs_decode<T: DeserializeOwned>(&self, bytes: &[u8], limit: usize) -> anyhow::Result<T> {
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
    }
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
