# Audit Report

## Title
Missing Issuer Validation in JWK Fetching Allows Consensus on Malicious JWKs Under DNS+TLS Compromise

## Summary
The JWK consensus system fetches OpenID configurations from OIDC provider URLs but does not validate that the returned `issuer` field matches the expected issuer. Combined with a consensus mechanism that only verifies observation equality (not correctness), this creates a scenario where if DNS hijacking and TLS compromise simultaneously affect >2/3 of validators, they will reach consensus on malicious JWKs without detection, enabling theft from keyless accounts.

## Finding Description

The vulnerability exists in the JWK observation and consensus flow:

**1. Missing Issuer Validation During Fetch**

When validators fetch JWKs from OIDC providers, the `fetch_jwks_uri_from_openid_config` function extracts the `jwks_uri` but discards the `issuer` field without validation: [1](#0-0) 

The OpenID configuration contains an `issuer` field that should match the expected issuer, but this check is never performed: [2](#0-1) 

**2. Consensus Only Verifies Observation Equality**

The observation aggregation mechanism requires that all validators observe identical JWKs to form a quorum certificate: [3](#0-2) 

This means if >2/3 validators fetch the same malicious JWKs (due to coordinated DNS poisoning), they will successfully reach consensus without any validation that the JWKs are authentic.

**3. No Certificate Pinning or Additional DNS Validation**

The system uses default `reqwest::Client::new()` with standard TLS validation but no additional security measures: [4](#0-3) 

**4. Attack Propagation Path**

Each validator periodically fetches JWKs via `JWKObserver`: [5](#0-4) 

When the observation differs from on-chain state, validators sign their observation and initiate consensus: [6](#0-5) 

**5. On-Chain Impact**

Once malicious JWKs achieve quorum, they are committed on-chain and subsequently used to verify keyless signatures: [7](#0-6) 

This breaks the **Cryptographic Correctness** invariant (item #10) and **Deterministic Execution** invariant (item #1).

## Impact Explanation

**Critical Severity** - This qualifies as **Loss of Funds (theft)** under the Critical category (up to $1,000,000).

If an attacker can compromise both DNS infrastructure and TLS validation for >2/3 of validators, they can:
1. Inject malicious JWKs that get consensus-approved on-chain
2. Use corresponding private keys to forge signatures for any keyless account
3. Steal all funds from affected keyless accounts
4. The attack is permanent until governance intervention

However, the **attack prerequisites are extremely high**:
- Requires DNS hijacking/BGP hijacking affecting majority of validators
- Requires TLS compromise (CA compromise, stolen keys, or validator infrastructure compromise)
- Both must occur simultaneously and persistently

## Likelihood Explanation

**Low Likelihood** due to attack prerequisites:

**Required Attack Capabilities:**
1. **DNS/BGP Attack**: Poison DNS caches or perform BGP hijacking to redirect >2/3 of validators' queries for OIDC provider domains
2. **TLS Compromise**: Must also bypass TLS validation via:
   - Compromising a trusted Certificate Authority
   - Stealing OIDC provider's private keys
   - Compromising validator infrastructure to inject malicious CA certificates

**Mitigating Factors:**
- Standard TLS validation prevents simple DNS attacks
- Validators likely use diverse DNS infrastructure
- Geographic distribution makes coordinated attacks difficult
- CA compromise is nation-state level capability

**Aggravating Factors:**
- No defense-in-depth validation of issuer field
- No out-of-band verification mechanism
- No alerting when validators cannot reach consensus
- Silent failure mode if <2/3 agreement

## Recommendation

Implement defense-in-depth validation at multiple layers:

**1. Validate Issuer Field**
```rust
// In crates/jwk-utils/src/lib.rs
pub async fn fetch_jwks_uri_from_openid_config(
    config_url: &str,
    expected_issuer: &str,
) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { issuer, jwks_uri } = 
        client.get(config_url).send().await?.json().await?;
    
    // Validate issuer matches expected value
    if issuer != expected_issuer {
        return Err(anyhow::anyhow!(
            "Issuer mismatch: expected {}, got {}", 
            expected_issuer, issuer
        ));
    }
    
    Ok(jwks_uri)
}
```

**2. Add Certificate Pinning for Known Providers**
```rust
// Add pinned certificates for major OIDC providers
const GOOGLE_CERT_PINS: &[&str] = &[/* SHA256 hashes */];

// Configure reqwest client with pinning
let client = reqwest::Client::builder()
    .danger_accept_invalid_certs(false)
    .add_root_certificate(/* pinned certs */)
    .build()?;
```

**3. Implement Consensus Disagreement Detection**

Add monitoring and alerting when validators cannot reach consensus on JWK observations, as this may indicate an ongoing attack.

**4. Add DNSSEC Validation (if feasible)**

Consider implementing DNSSEC validation for critical OIDC provider domains.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: crates/aptos-jwk-consensus/src/tests/issuer_validation_test.rs

#[tokio::test]
async fn test_missing_issuer_validation() {
    use crate::jwk_utils::fetch_jwks_uri_from_openid_config;
    
    // Setup mock server that returns wrong issuer
    let mock_server = httpmock::MockServer::start();
    let mock = mock_server.mock(|when, then| {
        when.method(GET)
            .path("/.well-known/openid-configuration");
        then.status(200)
            .json_body(json!({
                "issuer": "https://evil-attacker.com",  // Wrong issuer!
                "jwks_uri": "https://evil-attacker.com/jwks"
            }));
    });
    
    // This should fail but currently succeeds
    let config_url = format!(
        "{}/.well-known/openid-configuration",
        mock_server.base_url()
    );
    
    let result = fetch_jwks_uri_from_openid_config(&config_url).await;
    
    // BUG: Function succeeds even though issuer doesn't match
    assert!(result.is_ok());
    
    // Expected behavior: should validate issuer and fail
    // assert!(result.is_err());
    // assert!(result.unwrap_err().to_string().contains("Issuer mismatch"));
}
```

**Note**: While this demonstrates the missing validation, a full end-to-end exploit requires actual DNS and TLS infrastructure compromise, which cannot be realistically demonstrated in a test environment.

---

**Notes**

This vulnerability represents a **defense-in-depth failure** rather than a primary security boundary breach. The system appropriately relies on TLS/PKI for security, but lacks additional validation layers. The attack requires sophisticated nation-state level capabilities (DNS + TLS compromise), making it **unlikely but high-impact**. The missing issuer validation violates security best practices for defense-in-depth, even though TLS should prevent the attack under normal circumstances.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L10-14)
```rust
#[derive(Serialize, Deserialize)]
struct OpenIDConfiguration {
    issuer: String,
    jwks_uri: String,
}
```

**File:** crates/jwk-utils/src/lib.rs (L29-34)
```rust
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L82-84)
```rust
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-109)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L196-228)
```rust
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L91-94)
```rust
fn get_jwks_onchain(resolver: &impl AptosMoveResolver) -> anyhow::Result<PatchedJWKs, VMStatus> {
    PatchedJWKs::fetch_config(resolver)
        .ok_or_else(|| value_deserialization_error!("could not deserialize PatchedJWKs"))
}
```
