# Audit Report

## Title
TranslatedV1EventSchema Pruning Inconsistency Causes Unbounded Storage Growth and State Corruption

## Summary
While V2 event indexing operations are atomic across `TranslatedV1EventSchema`, `EventByKeySchema`, and `EventByVersionSchema` during writes, the pruning operations are **not atomic**. The `EventStorePruner` deletes entries from `EventByKeySchema` and `EventByVersionSchema` but fails to delete corresponding entries from `TranslatedV1EventSchema`, creating a state inconsistency that violates the "State Consistency" invariant and leads to unbounded storage growth.

## Finding Description

When V2 events are translated to V1 format for indexing, the system writes to three schemas atomically: [1](#0-0) 

These writes occur in the same `SchemaBatch` which is committed atomically via RocksDB's `WriteBatch`, ensuring consistency during indexing.

However, during pruning operations, the `EventStorePruner` only deletes from two of the three schemas: [2](#0-1) 

The `prune_event_indices` method only deletes from `EventByKeySchema` (line 209) and `EventByVersionSchema` (line 210-214) for V1 events, but there is **no corresponding deletion** for `TranslatedV1EventSchema` entries. This creates an inconsistent state where:

1. Pruned translated V1 events remain in `TranslatedV1EventSchema` indefinitely
2. Their index entries in `EventByKeySchema` and `EventByVersionSchema` are deleted
3. The storage grows unbounded as more V2 events are translated and never pruned

The `EventStorePruner` orchestrates pruning across multiple sub-pruners in parallel: [3](#0-2) 

But nowhere in this flow is `TranslatedV1EventSchema` being pruned, despite it being populated during indexing.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

1. **State Inconsistencies Requiring Intervention**: The schema inconsistency violates the "State Consistency" invariant which states "State transitions must be atomic and verifiable via Merkle proofs." While the pruning operation is intended to maintain a bounded storage window, `TranslatedV1EventSchema` grows without bound.

2. **Storage Exhaustion Risk**: On high-throughput chains with many V2 events requiring translation (e.g., coin transfers, token operations), the unpruned `TranslatedV1EventSchema` will continuously grow. Over time, this could:
   - Fill validator node disk space
   - Cause node crashes when disk is full
   - Require manual intervention to clean up the database
   - Potentially affect network liveness if multiple validators experience disk exhaustion

3. **Protocol Violation**: The indexer is designed with the assumption that all event-related schemas follow the same pruning lifecycle. This asymmetric pruning violates that design assumption.

While this doesn't immediately cause fund loss or consensus violations, it represents a significant operational risk that will manifest over time on production networks.

## Likelihood Explanation

**Likelihood: High (100%)**

This issue occurs automatically during normal node operation:

1. When `enable_event_v2_translation` is enabled (standard configuration), V2 events are translated and indexed
2. When pruning is enabled (standard for validators to manage disk space), old events are pruned
3. Every pruning cycle deepens the inconsistency by removing more entries from `EventByKeySchema`/`EventByVersionSchema` while leaving `TranslatedV1EventSchema` intact
4. No attacker action is required - this is a deterministic flaw in the pruning logic

On a testnet or mainnet with sustained transaction volume, this will manifest within weeks to months depending on:
- Transaction throughput
- Number of V2 events per transaction
- Pruning window configuration

## Recommendation

Add pruning logic for `TranslatedV1EventSchema` in the `prune_event_indices` method to maintain consistency with other event schemas:

**Modified approach in `event_db.rs`:**

```rust
pub(crate) fn prune_event_indices(
    &self,
    start: Version,
    end: Version,
    mut indices_batch: Option<&mut SchemaBatch>,
) -> Result<Vec<usize>> {
    let mut ret = Vec::new();
    let mut current_version = start;

    for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
        let events = events?;
        ret.push(events.len());

        if let Some(ref mut batch) = indices_batch {
            for (idx, event) in events.iter().enumerate() {
                // Prune V1 event indices
                if let ContractEvent::V1(v1) = event {
                    batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                    batch.delete::<EventByVersionSchema>(&(
                        *v1.key(),
                        current_version,
                        v1.sequence_number(),
                    ))?;
                }
                // ADD THIS: Prune translated V1 events for V2 events
                if let ContractEvent::V2(_) = event {
                    batch.delete::<TranslatedV1EventSchema>(&(current_version, idx as u64))?;
                }
            }
        }
        current_version += 1;
    }

    Ok(ret)
}
```

This ensures that `TranslatedV1EventSchema` entries are deleted atomically with their corresponding index entries, maintaining schema consistency.

## Proof of Concept

**Rust Test to Demonstrate the Inconsistency:**

```rust
#[test]
fn test_translated_v1_event_pruning_inconsistency() {
    // Setup: Create internal indexer DB with event V2 translation enabled
    let tmpdir = TempPath::new();
    let db = Arc::new(DB::open(...));
    let config = InternalIndexerDBConfig {
        enable_event: true,
        enable_event_v2_translation: true,
        batch_size: 1000,
        ..Default::default()
    };
    let indexer_db = InternalIndexerDB::new(db.clone(), config);
    
    // Index transactions with V2 events at versions 0-99
    // These will be translated and written to all three schemas
    for version in 0..100 {
        let v2_event = create_test_v2_event(); // e.g., CoinDeposit event
        // Process and index the event
        // Verify all three schemas have entries
    }
    
    // Verify entries exist in all three schemas before pruning
    assert!(db.get::<TranslatedV1EventSchema>(&(50, 0)).unwrap().is_some());
    assert!(db.get::<EventByVersionSchema>(&(event_key, 50, seq)).unwrap().is_some());
    
    // Trigger pruning for versions 0-49
    let pruner = EventStorePruner::new(ledger_db, 0, Some(indexer_db)).unwrap();
    pruner.prune(0, 50).unwrap();
    
    // BUG: TranslatedV1EventSchema still has entries for pruned versions
    assert!(db.get::<TranslatedV1EventSchema>(&(25, 0)).unwrap().is_some()); // SHOULD BE NONE
    
    // But EventByVersionSchema correctly has no entries
    assert!(db.get::<EventByVersionSchema>(&(event_key, 25, seq)).unwrap().is_none()); // Correctly pruned
    
    // This demonstrates the inconsistency between schemas
}
```

**Notes:**
- The vulnerability is present in the production code path used by all validators running with event V2 translation enabled
- The impact accumulates over time with each pruning cycle
- Manual database intervention would be required to clean up the accumulated unpruned `TranslatedV1EventSchema` entries

### Citations

**File:** storage/indexer/src/db_indexer.rs (L464-481)
```rust
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L192-222)
```rust
    pub(crate) fn prune_event_indices(
        &self,
        start: Version,
        end: Version,
        mut indices_batch: Option<&mut SchemaBatch>,
    ) -> Result<Vec<usize>> {
        let mut ret = Vec::new();

        let mut current_version = start;

        for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
            let events = events?;
            ret.push(events.len());

            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
            current_version += 1;
        }

        Ok(ret)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs (L43-81)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        let mut indexer_batch = None;

        let indices_batch = if let Some(indexer_db) = self.indexer_db() {
            if indexer_db.event_enabled() {
                indexer_batch = Some(SchemaBatch::new());
            }
            indexer_batch.as_mut()
        } else {
            Some(&mut batch)
        };
        let num_events_per_version = self.ledger_db.event_db().prune_event_indices(
            current_progress,
            target_version,
            indices_batch,
        )?;
        self.ledger_db.event_db().prune_events(
            num_events_per_version,
            current_progress,
            target_version,
            &mut batch,
        )?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;

        if let Some(mut indexer_batch) = indexer_batch {
            indexer_batch.put::<InternalIndexerMetadataSchema>(
                &IndexerMetadataKey::EventPrunerProgress,
                &IndexerMetadataValue::Version(target_version),
            )?;
            self.expect_indexer_db()
                .get_inner_db_ref()
                .write_schemas(indexer_batch)?;
        }
        self.ledger_db.event_db().write_schemas(batch)
    }
```
