# Audit Report

## Title
Safety Rules Remote Service Lacks Mutual TLS Authentication Enabling Man-in-the-Middle Attacks on Consensus Signing Operations

## Summary
The `NetworkClient` used by the Safety Rules remote service (Process mode) implements plain TCP communication without TLS encryption or mutual authentication. This allows man-in-the-middle attackers with network access to intercept, modify, or replay safety-critical signing requests between the consensus client and the safety rules signing service, potentially causing consensus safety violations including equivocation and double-signing.

## Finding Description

The Safety Rules component in Aptos enforces consensus safety by controlling access to the validator's private signing key. When configured in `Process` mode for separation, the safety rules service runs as a separate process and communicates with the consensus client over the network.

The `RemoteService` trait's `client()` method instantiates a `NetworkClient` without any TLS or authentication configuration: [1](#0-0) 

This `NetworkClient` uses plain TCP connections from the standard library: [2](#0-1) 

The underlying `NetworkStream` wraps a raw `TcpStream` with only length-prefixed message framing, providing no encryption or authentication: [3](#0-2) 

The safety rules service processes highly sensitive consensus operations over this unauthenticated channel: [4](#0-3) 

An attacker with network access between the client and server can:

1. **Intercept signing requests** to learn the validator's voting intentions before they are broadcast
2. **Modify BlockData** in `SignProposal` requests to trick the validator into signing different block content
3. **Replay old signing requests** to cause equivocation (signing conflicting blocks at the same height)
4. **Inject malicious timeout messages** to manipulate timeout behavior
5. **Modify vote proposals** to alter voting behavior

Example attack flow:
1. Validator configured with `SafetyRulesService::Process` pointing to `127.0.0.1:5555`
2. Attacker with localhost access (e.g., compromised container in same pod) performs ARP spoofing or uses iptables redirect
3. Attacker intercepts `ConstructAndSignVoteTwoChain` request containing `VoteProposal` for block at round N
4. Attacker modifies the block ID in the proposal to a conflicting block
5. Safety rules service signs the modified proposal, creating equivocation
6. Validator broadcasts conflicting votes, violating consensus safety

This breaks the **Consensus Safety** invariant (AptosBFT must prevent equivocation under < 1/3 Byzantine) by allowing external attackers to cause honest validators to equivocate.

## Impact Explanation

**Severity Assessment: High (with Critical potential in specific deployments)**

While this vulnerability represents a critical consensus safety issue, its practical impact is significantly limited:

**Mainnet Protection:** The configuration sanitizer explicitly blocks Process mode on mainnet: [5](#0-4) 

This means mainnet validators cannot use the vulnerable configuration, preventing Critical-severity impact on production.

**However, this remains a High-severity issue because:**

1. **Testnet/Devnet Exposure**: Test networks and development environments that use Process mode are vulnerable
2. **Private Chain Risk**: Enterprise or private Aptos deployments may use Process mode without the mainnet sanitizer restrictions
3. **Configuration Bypass**: Sanitizers may not be enforced in all deployment scenarios
4. **Defense-in-Depth Violation**: Even restricted code paths should implement proper security controls

If exploited on a network where Process mode is active, the impact includes:
- Consensus safety violations (equivocation, double-signing)
- Validator slashing and fund loss
- Potential network halt or fork requiring manual intervention
- Complete compromise of validator's voting behavior

## Likelihood Explanation

**Likelihood: Low to Medium depending on deployment**

**On Mainnet: Very Low**
- Process mode is blocked by config sanitizer
- Requires sanitizer bypass or configuration error

**On Testnets/Private Chains: Medium**
- Process mode may be legitimately used for operational separation
- Attacker needs network-level access (localhost or network path)
- Localhost access is realistic in cloud environments with:
  - Compromised co-located containers
  - Lateral movement from other services
  - Malicious infrastructure components

**Attack Requirements:**
- Network positioning between client and server (localhost or network MitM)
- Understanding of the safety rules protocol
- Ability to parse and modify serialized JSON messages
- Timing to intercept requests before timeout

The attack becomes more likely if:
- Both processes run on same host (localhost interception easier)
- Network lacks additional segmentation controls
- Other services on the host are compromised

## Recommendation

**Immediate Fix: Implement Mutual TLS Authentication**

Add TLS support to `NetworkClient` and `NetworkServer` with:

1. **Certificate-based mutual authentication** using validator identity
2. **TLS 1.3** with strong cipher suites
3. **Certificate pinning** to prevent CA compromise attacks

**Configuration Changes Required:**

Add to `SafetyRulesConfig`:
```rust
pub struct RemoteService {
    pub server_address: NetworkAddress,
    pub tls_config: Option<TlsConfig>,  // NEW
}

pub struct TlsConfig {
    pub cert_path: PathBuf,
    pub key_path: PathBuf,
    pub ca_cert_path: PathBuf,
}
```

**Implementation Options:**

1. **Use rustls for TLS**: Integrate `tokio-rustls` or `async-native-tls`
2. **Reuse existing gRPC infrastructure**: Migrate safety rules to use the gRPC network service with TLS
3. **Add authentication layer**: Implement HMAC-based message authentication if TLS is not feasible

**Alternative Mitigation:**

If separate processes are not required, enforce Local mode universally by removing Process mode support entirely, or restrict it to development-only builds.

**Additional Hardening:**
- Implement request signing with validator key to prevent replay attacks
- Add nonce/timestamp to prevent replay even if TLS is compromised
- Bind server to 127.0.0.1 only and document that network separation requires other controls

## Proof of Concept

```rust
// PoC: Man-in-the-Middle Attack on Safety Rules Communication
// This demonstrates intercepting and modifying safety rules requests

use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};

fn mitm_proxy(listen_addr: &str, target_addr: &str) {
    let listener = TcpListener::bind(listen_addr).unwrap();
    println!("[MitM] Listening on {}", listen_addr);
    
    for stream in listener.incoming() {
        let mut client_stream = stream.unwrap();
        let mut server_stream = TcpStream::connect(target_addr).unwrap();
        
        // Intercept request from consensus client
        let mut request_buf = vec![0u8; 4096];
        let n = client_stream.read(&mut request_buf).unwrap();
        let request = &request_buf[..n];
        
        println!("[MitM] Intercepted request: {} bytes", n);
        
        // Parse the length-prefixed message
        if n >= 4 {
            let data_len = u32::from_le_bytes([
                request[0], request[1], request[2], request[3]
            ]) as usize;
            let payload = &request[4..4+data_len];
            
            // Payload is JSON - could parse and modify here
            if let Ok(json) = std::str::from_utf8(payload) {
                println!("[MitM] Request JSON: {}", json);
                
                // Could modify SafetyRulesInput::SignProposal here
                // to change the BlockData being signed
            }
        }
        
        // Forward to real safety rules server
        server_stream.write_all(request).unwrap();
        
        // Intercept response
        let mut response_buf = vec![0u8; 4096];
        let n = server_stream.read(&mut response_buf).unwrap();
        println!("[MitM] Intercepted response: {} bytes", n);
        
        // Forward to client (or could modify the signature response)
        client_stream.write_all(&response_buf[..n]).unwrap();
    }
}

// To test:
// 1. Start real safety rules server on localhost:5556
// 2. Start MitM proxy: mitm_proxy("127.0.0.1:5555", "127.0.0.1:5556")
// 3. Configure consensus client to connect to localhost:5555
// 4. Observe all signing requests intercepted in plaintext
```

**Note:** This PoC demonstrates the vulnerability exists but should only be tested in isolated test environments, never on production systems.

## Notes

**Scope Limitations:**
- This vulnerability cannot be exploited on mainnet validators due to config sanitizer enforcement
- Impact is limited to testnets, devnets, and private chains where Process mode may be used
- Requires network-level access (not exploitable by transaction senders or smart contracts)

**Defense in Depth:**
Even though mainnet is protected by configuration controls, the underlying implementation should follow security best practices. The absence of TLS/authentication represents a defense-in-depth failure that could be exposed through:
- Configuration errors or bypasses
- Future changes to the sanitizer logic
- Deployment in environments with different security requirements

**Comparison to Other Network Communications:**
The validator network implements mutual authentication [6](#0-5)  while Vault connections use HTTPS with certificate validation [7](#0-6) , demonstrating that the project recognizes the need for authenticated/encrypted channels in security-critical contexts. The safety rules remote service should follow the same pattern.

### Citations

**File:** consensus/safety-rules/src/remote_service.rs (L15-20)
```rust
        let network_client = NetworkClient::new(
            "safety-rules".to_string(),
            self.server_address(),
            self.network_timeout_ms(),
        );
        let service = Box::new(RemoteClient::new(network_client));
```

**File:** secure/net/src/lib.rs (L239-239)
```rust
            let mut stream = TcpStream::connect_timeout(&self.server, timeout);
```

**File:** secure/net/src/lib.rs (L407-412)
```rust
struct NetworkStream {
    stream: TcpStream,
    remote: SocketAddr,
    buffer: Vec<u8>,
    temp_buffer: [u8; 1024],
}
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/test_data/validator.yaml (L7-8)
```yaml
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
```

**File:** config/src/config/test_data/validator.yaml (L78-78)
```yaml
    mutual_authentication: true
```
