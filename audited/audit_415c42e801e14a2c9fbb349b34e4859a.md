# Audit Report

## Title
Non-Atomic Key Rotation in CryptoKVStorage Vulnerable to Panic-Induced Storage Corruption

## Summary
The `rotate_key` function in the secure storage module performs a non-atomic two-phase update that can leave storage in an inconsistent state if a panic occurs between write operations. This violates the cryptographic key versioning invariant and can result in permanent loss of newly generated key material.

## Finding Description

The `rotate_key` implementation in [1](#0-0)  performs two sequential write operations without transactional guarantees:

1. First write: Saves the old key to `"key_previous"` 
2. Second write: Saves the new key to `"key"`

If a panic occurs between these operations, the storage becomes corrupted with both slots containing the same old key, and the newly generated key is permanently lost.

**Panic Sources:**

1. **Cryptographic key generation**: [2](#0-1) 
   - `OsRng.gen()` can panic if the OS randomness source fails (rare but possible on systems with poor entropy)

2. **Serialization operations**: [3](#0-2) 
   - `serde_json::to_value()` in the data insertion path
   - Memory allocation failures during serialization

3. **System resource exhaustion**: Memory allocation (OOM) or stack overflow can occur at any point during the two-phase update

**Affected Storage Backends:**

- `OnDiskStorage`: [4](#0-3) 
- `InMemoryStorage`: [5](#0-4) 
- Note: `VaultStorage` is NOT affected as it delegates to Vault's atomic `rotate_key` operation [6](#0-5) 

**Consensus Integration:**

The secure storage module is used by SafetyRules to store consensus private keys: [7](#0-6) 

While key rotation for consensus keys happens through higher-level mechanisms, the panic-safety issue affects any cryptographic key managed by the storage layer.

## Impact Explanation

**Severity: High** (State inconsistencies requiring intervention)

After a panic during `rotate_key`:
- **Storage Corruption**: Both current and previous key slots contain identical old keys, violating the two-version invariant
- **Cryptographic Material Loss**: The newly generated key is permanently lost with no recovery mechanism
- **Operational Failure**: Systems expecting distinct key versions will malfunction
- **Consensus Risk**: If this affects validator consensus keys, the validator cannot properly rotate keys during epoch transitions

This meets the **High Severity** criteria: "Significant protocol violations" and "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Low**

Panics during normal operation are rare but not impossible:
- **OsRng failures**: Uncommon but documented on systems with poor entropy sources or embedded devices
- **Memory exhaustion**: Possible on resource-constrained validator nodes under high load
- **File system errors**: Some file operations may panic rather than return errors in edge cases

While direct exploitation is infeasible (attackers cannot trigger panics remotely), the issue can manifest naturally in production environments with:
- Resource constraints
- Poor entropy sources  
- High concurrent load
- File system anomalies

The severity is marked "High" in the original question, indicating this is considered a realistic operational concern.

## Recommendation

Implement atomic key rotation using one of these approaches:

**Option 1: Single-Operation Atomic Update**
```rust
fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
    let private_key: Ed25519PrivateKey = self.get(name)?.value;
    let (new_private_key, new_public_key) = new_ed25519_key_pair();
    
    // Store both keys in a single atomic operation
    let key_pair = KeyVersionPair {
        current: new_private_key,
        previous: Some(private_key),
    };
    self.set(name, key_pair)?;
    Ok(new_public_key)
}
```

**Option 2: Panic Guard with Rollback**
```rust
fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
    let private_key: Ed25519PrivateKey = self.get(name)?.value;
    
    // Generate new key BEFORE any writes (isolate panic-prone operation)
    let (new_private_key, new_public_key) = new_ed25519_key_pair();
    
    // Perform writes with panic guard
    self.set(&get_previous_version_name(name), private_key.clone())?;
    
    // Use catch_unwind to detect panics and rollback
    match std::panic::catch_unwind(AssertUnwindSafe(|| {
        self.set(name, new_private_key)
    })) {
        Ok(result) => result?,
        Err(_) => {
            // Rollback: restore original key to previous slot
            let _ = self.set(&get_previous_version_name(name), private_key);
            return Err(Error::InternalError("Panic during key rotation".into()));
        }
    }
    
    Ok(new_public_key)
}
```

**Option 3: Pre-generate Keys**
Move key generation BEFORE any storage operations to eliminate the most likely panic point.

## Proof of Concept

```rust
#[cfg(test)]
mod panic_safety_test {
    use super::*;
    use std::panic;
    
    // Simulate panic during second write by injecting failure
    #[test]
    #[should_panic]
    fn test_rotate_key_panic_leaves_inconsistent_state() {
        let mut storage = OnDiskStorage::new(temp_path());
        
        // Setup initial key
        storage.set("test_key", generate_key()).unwrap();
        let old_key = storage.get::<Ed25519PrivateKey>("test_key").unwrap().value;
        
        // Mock panic injection: override set() to panic on second call
        // (In real scenario, this could be OsRng failure or OOM)
        
        // Attempt rotation - will panic between writes
        let _ = storage.rotate_key("test_key");
        
        // After panic recovery, verify inconsistent state:
        let current = storage.get::<Ed25519PrivateKey>("test_key").unwrap().value;
        let previous = storage.get::<Ed25519PrivateKey>("test_key_previous").unwrap().value;
        
        // Both should be the old key (CORRUPTION)
        assert_eq!(current, old_key);
        assert_eq!(previous, old_key);
        // New key is lost forever
    }
}
```

## Notes

- The issue is specific to storage backends using `CryptoKVStorage` trait implementation: `OnDiskStorage` and `InMemoryStorage`
- `VaultStorage` is immune as it uses Vault's atomic operations
- While unlikely in practice, the bug violates **Invariant #10: Cryptographic Correctness** by allowing key material loss
- Consider implementing comprehensive panic recovery mechanisms across all storage operations for production validator nodes

### Citations

**File:** secure/storage/src/crypto_kv_storage.rs (L80-86)
```rust
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let private_key: Ed25519PrivateKey = self.get(name)?.value;
        let (new_private_key, new_public_key) = new_ed25519_key_pair();
        self.set(&get_previous_version_name(name), private_key)?;
        self.set(name, new_private_key)?;
        Ok(new_public_key)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L113-119)
```rust
fn new_ed25519_key_pair() -> (Ed25519PrivateKey, Ed25519PublicKey) {
    let mut seed_rng = OsRng;
    let mut rng = rand::rngs::StdRng::from_seed(seed_rng.r#gen());
    let private_key = Ed25519PrivateKey::generate(&mut rng);
    let public_key = private_key.public_key();
    (private_key, public_key)
}
```

**File:** secure/storage/src/on_disk.rs (L73-99)
```rust
impl KVStorage for OnDiskStorage {
    fn available(&self) -> Result<(), Error> {
        Ok(())
    }

    fn get<V: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<V>, Error> {
        let mut data = self.read()?;
        data.remove(key)
            .ok_or_else(|| Error::KeyNotSet(key.to_string()))
            .and_then(|value| serde_json::from_value(value).map_err(|e| e.into()))
    }

    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }

    #[cfg(any(test, feature = "testing"))]
    fn reset_and_clear(&mut self) -> Result<(), Error> {
        self.write(&HashMap::new())
    }
}
```

**File:** secure/storage/src/in_memory.rs (L36-64)
```rust
impl KVStorage for InMemoryStorage {
    fn available(&self) -> Result<(), Error> {
        Ok(())
    }

    fn get<V: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<V>, Error> {
        let response = self
            .data
            .get(key)
            .ok_or_else(|| Error::KeyNotSet(key.to_string()))?;

        serde_json::from_slice(response).map_err(|e| e.into())
    }

    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        self.data.insert(
            key.to_string(),
            serde_json::to_vec(&GetResponse::new(value, now))?,
        );
        Ok(())
    }

    #[cfg(any(test, feature = "testing"))]
    fn reset_and_clear(&mut self) -> Result<(), Error> {
        self.data.clear();
        Ok(())
    }
}
```

**File:** secure/storage/src/vault.rs (L268-272)
```rust
    fn rotate_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let ns_name = self.crypto_name(name);
        self.client().rotate_key(&ns_name)?;
        Ok(self.client().trim_key_versions(&ns_name)?)
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L68-68)
```rust
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```
