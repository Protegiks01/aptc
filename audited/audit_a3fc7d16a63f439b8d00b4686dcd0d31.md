# Audit Report

## Title
Layout Cache Race Condition Causes Non-Deterministic BCS Serialization in Parallel Block Execution

## Summary
The global layout cache used for BCS serialization lacks module version tracking, allowing stale type layouts computed from old module definitions to persist after module upgrades. This creates a race condition in parallel block execution where transactions can serialize the same data differently depending on execution timing, violating the deterministic execution invariant critical for consensus.

## Finding Description

The `native_to_bytes` function in the BCS native implementation retrieves type layouts through a global cache that is shared across all parallel transaction executions. The vulnerability stems from three interconnected design issues:

1. **Layout Cache is Global Without Version Tracking**: The layout cache at [1](#0-0)  stores layouts in a `DashMap<StructKey, LayoutCacheEntry>` where `StructKey` only contains the struct index and type arguments, but no module version identifier.

2. **Cache Flush Has a Race Window**: When modules are published, [2](#0-1)  flushes the entire layout cache. However, transactions executing in parallel may be computing layouts at the same moment, creating a Time-of-Check-Time-of-Use (TOCTOU) vulnerability.

3. **Cached Layouts Are Not Re-Validated Against Current Modules**: When a cached layout is retrieved at [3](#0-2) , the system re-reads modules only for gas charging purposes, not to validate that the cached layout matches the current module definition.

**Attack Scenario:**

Thread A (Transaction T1 at index 100):
- Enters `type_to_type_layout_with_delayed_fields` at [4](#0-3) 
- Cache miss, begins computing layout
- Loads module `M` (version 1) with struct `S` having field layout `[u64, u8]`
- Computes layout L1: `Struct([U64, U8])`

Thread B (Transaction T2 at index 50 - publishing module):
- Publishes module `M` version 2 with modified struct `S` having field layout `[u128, bool]`
- Calls `publish_module_write_set` 
- Executes `flush_layout_cache()` - cache is now empty

Thread A (continuing):
- Finishes computing layout L1 (based on M v1)
- Stores at [5](#0-4)  using atomic DashMap entry insert
- Layout L1 is now in the freshly-flushed cache

Thread C (Transaction T3 at index 150):
- Calls `to_bytes<M::S>` at [6](#0-5) 
- Cache HIT - retrieves layout L1 (computed from M v1)
- Re-reads module M v2 for gas charging at [7](#0-6) 
- Module read is recorded, validation will check M v2
- Serializes data using WRONG layout L1 (expects `[u64, u8]` but actual struct has `[u128, bool]`)
- Produces incorrect BCS bytes

Transaction T3's validation at [8](#0-7)  checks if module M v2 is overridden - it is NOT (it's the current version), so validation PASSES despite using the wrong layout.

**Broken Invariant:**
This violates **Invariant #1: Deterministic Execution** - validators executing the same transactions in different orders may cache different layouts, causing identical `to_bytes<T>()` calls to produce different serialized bytes. This breaks consensus as different validators will compute different state roots for identical blocks.

## Impact Explanation

**Critical Severity** - This is a consensus safety violation:

- **Consensus Breaking**: Different validators executing transactions in different parallel schedules will serialize data differently, producing different transaction outputs and state roots for the same block. This violates AptosBFT's safety guarantee.

- **State Divergence**: Two validators that execute the same block may commit different states if their parallel execution schedules differ, leading to chain splits.

- **Unpredictable Behavior**: The same transaction can produce different results depending on timing, making the system non-deterministic.

Layout caching is enabled by default in production at [9](#0-8) , making this vulnerability active in deployed Aptos nodes.

## Likelihood Explanation

**High Likelihood** of occurrence:

1. **Parallel Execution is Core Feature**: Aptos uses Block-STM for parallel transaction execution in every block
2. **Module Publishing is Common**: Framework upgrades, governance proposals, and dApp deployments all publish modules
3. **Race Window Exists**: The gap between cache flush and validation provides opportunity for stale layouts to persist
4. **No Synchronization**: There are no locks or version checks between layout computation and module publishing
5. **Global Cache**: The cache at [1](#0-0)  is shared across all parallel executions

The vulnerability requires no attacker action - it occurs naturally during normal operations when modules are upgraded while transactions are executing.

## Recommendation

Add module version tracking to layout cache entries and validate cached layouts against current module versions:

1. **Add Version to Cache Key**: Extend `StructKey` to include module version or hash:
   ```rust
   pub struct StructKey {
       pub idx: StructNameIndex,
       pub ty_args_id: TypeVecId,
       pub module_version: ModuleVersion, // NEW
   }
   ```

2. **Store Module Version in Cache Entry**: Include the module version when creating `LayoutCacheEntry`

3. **Validate on Cache Hit**: In `load_layout_from_cache`, verify that the cached layout's module version matches the currently visible module version before returning it

4. **Per-Transaction Cache Isolation**: Consider using per-transaction or per-block layout caches instead of a global cache to ensure each transaction has a consistent view

Alternative mitigation: Disable layout caching during blocks with module publications by checking if any transaction publishes modules before starting parallel execution.

## Proof of Concept

```rust
// Test demonstrating the race condition
// File: aptos-move/block-executor/src/tests/layout_cache_race_test.rs

#[test]
fn test_layout_cache_race_on_module_publish() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    let global_cache = Arc::new(GlobalModuleCache::empty());
    let barrier = Arc::new(Barrier::new(3));
    
    // Thread 1: Compute layout for old module
    let cache1 = Arc::clone(&global_cache);
    let barrier1 = Arc::clone(&barrier);
    let handle1 = thread::spawn(move || {
        // Simulate cache miss and start computing layout
        let key = StructKey { idx: StructNameIndex::new(0), ty_args_id: TypeVecId(0) };
        barrier1.wait(); // Synchronize: all threads start together
        
        // Simulate slow layout computation
        thread::sleep(Duration::from_millis(10));
        
        // Store computed layout (simulating line 186-188 of code_cache_global.rs)
        let stale_layout = create_test_layout_v1(); // Layout for module v1
        cache1.store_struct_layout_entry(&key, stale_layout);
    });
    
    // Thread 2: Publish module and flush cache
    let cache2 = Arc::clone(&global_cache);
    let barrier2 = Arc::clone(&barrier);
    let handle2 = thread::spawn(move || {
        barrier2.wait();
        thread::sleep(Duration::from_millis(5)); // Let Thread 1 start computing
        
        // Simulate module publish and cache flush (line 574 of txn_last_input_output.rs)
        cache2.flush_layout_cache();
    });
    
    // Thread 3: Use cached layout
    let cache3 = Arc::clone(&global_cache);
    let barrier3 = Arc::clone(&barrier);
    let handle3 = thread::spawn(move || {
        barrier3.wait();
        thread::sleep(Duration::from_millis(20)); // Wait for Thread 1 to store stale layout
        
        let key = StructKey { idx: StructNameIndex::new(0), ty_args_id: TypeVecId(0) };
        let cached = cache3.get_struct_layout_entry(&key);
        
        // BUG: cached layout is from module v1, but current module is v2
        assert!(cached.is_some(), "Cache should have stale entry from Thread 1");
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    handle3.join().unwrap();
    
    // Demonstrates: Thread 3 gets stale layout that was stored AFTER cache flush
}
```

This race condition manifests in production when the Block-STM executor runs multiple transactions in parallel, one publishes a module, and others are simultaneously computing or using layouts for structs in that module.

### Citations

**File:** aptos-move/block-executor/src/code_cache_global.rs (L96-96)
```rust
    struct_layouts: DashMap<StructKey, LayoutCacheEntry>,
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L186-188)
```rust
        if let dashmap::Entry::Vacant(e) = self.struct_layouts.entry(*key) {
            e.insert(entry);
        }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L574-574)
```rust
            global_module_cache.flush_layout_cache();
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L209-219)
```rust
        let entry = self.module_storage.get_struct_layout(key)?;
        let (layout, modules) = entry.unpack();
        for module_id in modules.iter() {
            // Re-read all modules for this layout, so that transaction gets invalidated
            // on module publish. Also, we re-read them in exactly the same way as they
            // were traversed during layout construction, so gas charging should be exactly
            // the same as on the cache miss.
            if let Err(err) = self.charge_module(gas_meter, traversal_context, module_id) {
                return Some(Err(err));
            }
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L109-114)
```rust
                if let Some(result) = self.struct_definition_loader.load_layout_from_cache(
                    gas_meter,
                    traversal_context,
                    &key,
                ) {
                    return result;
```

**File:** third_party/move/move-stdlib/src/natives/bcs.rs (L57-58)
```rust
    let layout = match context.type_to_type_layout(arg_type) {
        Ok(layout) => layout,
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1061-1061)
```rust
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
```

**File:** config/src/config/execution_config.rs (L92-92)
```rust
            layout_caches_enabled: true,
```
