# Audit Report

## Title
Unsigned Timeout Reason Field Allows Network-Level Reason Manipulation After Signature Verification

## Summary
The `reason` field in `RoundTimeout` is not included in the cryptographic signature, allowing attackers to modify timeout reasons in network messages after signature verification passes. While the `reason()` getter at lines 109-111 correctly returns an immutable reference, the unsigned nature of this field enables manipulation during network transmission, breaking consensus integrity guarantees. [1](#0-0) 

## Finding Description

The `reason()` method returns an immutable reference (`&RoundTimeoutReason`), preventing direct mutation through the API. However, a critical vulnerability exists: the `reason` field is excluded from signature verification.

When verifying a `RoundTimeout`, the signature only covers data from `timeout.signing_format()`: [2](#0-1) 

The signing format only includes `(epoch, round, hqc_round)`: [3](#0-2) 

**Attack Flow:**
1. Honest validator creates `RoundTimeout` with reason `ProposalNotReceived`, signs it (signature covers epoch/round/hqc_round only)
2. Attacker intercepts the serialized network message
3. Attacker modifies the `reason` field to `PayloadUnavailable { missing_authors: <bitvec targeting victim validators> }`
4. Modified message passes signature verification (reason not signed)
5. Victim validators get falsely marked as failing in aggregation [4](#0-3) 

The manipulated reasons are aggregated with voting power: [5](#0-4) [6](#0-5) 

These aggregated reasons control OptQS behavior and validator exclusion: [7](#0-6) [8](#0-7) 

## Impact Explanation

**High Severity** - Significant protocol violation:

1. **Consensus Performance Degradation**: By injecting false `PayloadUnavailable` reasons, attackers disable OptQS (Optimistic Quorum Store), forcing fallback to slower consensus paths
2. **Targeted Validator DoS**: Innocent validators are excluded from optimistic proposals based on fabricated failure reports
3. **Metric Poisoning**: Monitoring systems receive false timeout statistics, masking real issues [9](#0-8) 

This breaks the **Consensus Safety** invariant (validators must agree on protocol state) and **Cryptographic Correctness** (signatures must protect all security-critical fields).

## Likelihood Explanation

**High Likelihood**:
- Attacker only needs network-level access (standard Byzantine model)
- No validator collusion required
- Trivial to execute (modify serde-serialized field, signature still validates)
- Affects every timeout message across the network
- Impact accumulates with f+1 voting power for aggregation

## Recommendation

Include `reason` in the cryptographic signature by modifying `TimeoutSigningRepr`:

```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub reason: RoundTimeoutReason,  // ADD THIS
}
```

Update `TwoChainTimeout::signing_format()`:

```rust
pub fn signing_format(&self, reason: &RoundTimeoutReason) -> TimeoutSigningRepr {
    TimeoutSigningRepr {
        epoch: self.epoch(),
        round: self.round(),
        hqc_round: self.hqc_round(),
        reason: reason.clone(),
    }
}
```

Update `RoundTimeout::verify()` to pass reason:

```rust
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    self.timeout.verify(validator)?;
    validator.verify(
        self.author(),
        &self.timeout.signing_format(&self.reason),
        &self.signature,
    )
    .context("Failed to verify 2-chain timeout signature")?;
    Ok(())
}
```

## Proof of Concept

```rust
// Attacker intercepts legitimate RoundTimeout message
let legitimate_timeout = RoundTimeout::new(
    two_chain_timeout,
    author,
    RoundTimeoutReason::ProposalNotReceived,  // Original reason
    signature,  // Valid signature (covers epoch/round/hqc_round only)
);

// Attacker creates malicious version with same signature
let mut malicious_bitvec = BitVec::with_num_bits(validator_count);
malicious_bitvec.set(victim_validator_index);  // Target specific validator

let malicious_timeout = RoundTimeout::new(
    two_chain_timeout,  // Same epoch/round/hqc_round
    author,
    RoundTimeoutReason::PayloadUnavailable { 
        missing_authors: malicious_bitvec  // Modified reason
    },
    signature,  // SAME signature - still validates!
);

// Signature verification passes despite reason modification
assert!(malicious_timeout.verify(&validator_verifier).is_ok());

// Victim validator gets excluded from OptQS
// Consensus performance degrades
```

### Citations

**File:** consensus/consensus-types/src/round_timeout.rs (L37-45)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct RoundTimeout {
    // The timeout
    timeout: TwoChainTimeout,
    author: Author,
    reason: RoundTimeoutReason,
    /// Signature on the Timeout
    signature: bls12381::Signature,
}
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L109-111)
```rust
    pub fn reason(&self) -> &RoundTimeoutReason {
        &self.reason
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/src/pending_votes.rs (L78-87)
```rust
    pub(super) fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
        reason: RoundTimeoutReason,
    ) {
        self.partial_2chain_tc.add(author, timeout, signature);
        self.timeout_reason.entry(author).or_insert(reason);
    }
```

**File:** consensus/src/pending_votes.rs (L93-118)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/round_manager.rs (L438-459)
```rust
            NewRoundReason::Timeout(ref reason) => {
                counters::TIMEOUT_ROUNDS_COUNT.inc();
                counters::AGGREGATED_ROUND_TIMEOUT_REASON
                    .with_label_values(&[
                        &reason.to_string(),
                        prev_proposer.short_str().as_str(),
                        &is_current_proposer.to_string(),
                    ])
                    .inc();
                if is_current_proposer {
                    if let RoundTimeoutReason::PayloadUnavailable { missing_authors } = reason {
                        let ordered_peers =
                            self.epoch_state.verifier.get_ordered_account_addresses();
                        for idx in missing_authors.iter_ones() {
                            if let Some(author) = ordered_peers.get(idx) {
                                counters::AGGREGATED_ROUND_TIMEOUT_REASON_MISSING_AUTHORS
                                    .with_label_values(&[author.short_str().as_str()])
                                    .inc();
                            }
                        }
                    }
                }
```
