# Audit Report

## Title
Deserialization Bypass Allows WeightedConfigArkworks with Zero Players to Cause Validator Panic

## Summary
The `WeightedConfig` struct (including `WeightedConfigArkworks`) derives `Deserialize` without custom validation, allowing deserialization of invalid configurations with zero players. When such configurations are used in cryptographic setup functions, multiple code paths trigger panics instead of handling errors gracefully, leading to validator node crashes.

## Finding Description

The `WeightedConfig` struct implements proper validation in its constructor that rejects empty player sets [1](#0-0) , but this validation is bypassed during deserialization because the struct uses serde's automatic `Deserialize` implementation [2](#0-1) .

When a `WeightedConfigArkworks` with zero players is used, multiple critical functions panic:

1. **`get_min_weight_player()`** and **`get_max_weight_player()`** contain explicit panic statements [3](#0-2)  and [4](#0-3) 

2. **`get_random_eligible_subset_of_players()`** would panic on `rng.gen_range(0, 0)` when the player set is empty [5](#0-4) 

3. **`pop_eligible_subset()`** would panic on `.pop().unwrap()` on an empty vector [6](#0-5) 

4. In the batch encryption scheme, **`FPTXWeighted::setup()`** would panic with index out of bounds when accessing an empty `vks` vector [7](#0-6)  because `threshold_config.get_players()` returns an empty iterator when there are zero players [8](#0-7) 

While `WeightedConfig` instances in normal operation are created via the validated `new()` constructor [9](#0-8) , the deserialization path remains unprotected. The `DKGPvssConfig` struct, which contains a `WeightedConfigBlstrs` field, also derives `Deserialize` [10](#0-9) , creating a potential attack surface if on-chain state becomes corrupted or if future code paths deserialize configs from untrusted sources.

## Impact Explanation

This qualifies as **Medium severity** under Aptos bug bounty criteria:
- **Validator node crashes**: Any validator attempting to use a zero-player config would immediately panic, causing node unavailability
- **Randomness system disruption**: The FPTXWeighted setup is used for consensus randomness generation, and panics here would prevent proper epoch transitions
- **State inconsistencies requiring intervention**: Recovery would require manual intervention to fix corrupted on-chain DKG state

The impact is limited from Critical severity because:
- No direct fund loss occurs
- Consensus safety is not violated (nodes panic before producing incorrect state)
- Network partition is recoverable through on-chain governance fixes

## Likelihood Explanation

**Likelihood: Low to Medium**

While the constructor validation prevents normal code paths from creating invalid configs, the vulnerability could be triggered through:

1. **On-chain state corruption**: If another vulnerability allows corruption of the `DKGState` resource stored at `@aptos_framework`, a malicious actor could serialize an invalid config on-chain
2. **Future deserialization paths**: Any future API or network protocol that deserializes `WeightedConfig` or `DKGPvssConfig` from external sources would be vulnerable
3. **Epoch transition edge cases**: Validators deserialize and use configs during epoch transitions, making this a high-impact timing window

The likelihood is reduced because:
- Current code paths use validated construction via `new()`
- DKG state is protected by on-chain governance
- No direct external deserialization paths were identified in current consensus flow

## Recommendation

Implement custom deserialization with validation for `WeightedConfig`:

```rust
impl<'de, TC: ThresholdConfig> Deserialize<'de> for WeightedConfig<TC> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct WeightedConfigRaw<TC: ThresholdConfig> {
            tc: TC,
            num_players: usize,
            weights: Vec<usize>,
            starting_index: Vec<usize>,
            max_weight: usize,
            min_weight: usize,
        }
        
        let raw = WeightedConfigRaw::deserialize(deserializer)?;
        
        // Validate weights is non-empty
        if raw.weights.is_empty() {
            return Err(serde::de::Error::custom(
                "expected a non-empty vector of player weights"
            ));
        }
        
        // Additional validation: ensure fields are consistent
        if raw.num_players != raw.weights.len() {
            return Err(serde::de::Error::custom(
                "num_players must match weights length"
            ));
        }
        
        Ok(WeightedConfig {
            tc: raw.tc,
            num_players: raw.num_players,
            weights: raw.weights,
            starting_index: raw.starting_index,
            max_weight: raw.max_weight,
            min_weight: raw.min_weight,
        })
    }
}
```

Alternatively, add defensive checks in all functions that assume non-empty weights to return `Result<T>` instead of panicking.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Weights vector should not be empty")]
fn test_zero_players_deserialization_panic() {
    use aptos_crypto::weighted_config::WeightedConfigBlstrs;
    use aptos_crypto::blstrs::threshold_config::ThresholdConfigBlstrs;
    
    // Construct a malicious serialized WeightedConfig with zero players
    // by manually creating the struct fields (bypassing validation)
    let malicious_config_json = r#"{
        "tc": {"threshold": 0, "total_num_shares": 0},
        "num_players": 0,
        "weights": [],
        "starting_index": [],
        "max_weight": 0,
        "min_weight": 0
    }"#;
    
    // Deserialize bypasses the new() constructor validation
    let config: WeightedConfigBlstrs = 
        serde_json::from_str(malicious_config_json).unwrap();
    
    // This should return an error but instead panics
    let _player = config.get_min_weight_player();
}

#[test]
#[should_panic(expected = "index out of bounds")]
fn test_fptx_weighted_setup_panic_with_zero_players() {
    use aptos_batch_encryption::schemes::fptx_weighted::FPTXWeighted;
    use aptos_crypto::weighted_config::WeightedConfigArkworks;
    // Similar PoC showing FPTXWeighted::setup panics with empty config
}
```

**Notes**

The vulnerability exists due to a defense-in-depth gap where deserialization bypasses constructor validation. While current code paths properly use validated construction, the system remains vulnerable to future attack vectors involving on-chain state corruption or deserialization from untrusted sources. The explicit panic statements in `get_min_weight_player()` and `get_max_weight_player()` confirm that the developers anticipated this should never occur, but failed to enforce this invariant during deserialization.

### Citations

**File:** crates/aptos-crypto/src/weighted_config.rs (L38-39)
```rust
#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, Eq)]
pub struct WeightedConfig<TC: ThresholdConfig> {
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L74-76)
```rust
        if weights.is_empty() {
            return Err(anyhow!("expected a non-empty vector of player weights"));
        }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L123-124)
```rust
            panic!("Weights vector should not be empty");
        }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L138-139)
```rust
            panic!("Weights vector should not be empty");
        }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L263-264)
```rust
        while current_weight < self.tc.get_threshold() {
            let (player, weight) = player_and_weights.pop().unwrap();
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L348-351)
```rust
        while current_weight < self.tc.get_threshold() {
            // pick a random player, and move it to the picked set
            let idx = rng.gen_range(0, player_and_weights.len());
            let (player_id, weight) = player_and_weights[idx];
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L245-257)
```rust
        let vks: Vec<Self::VerificationKey> = threshold_config
            .get_players()
            .into_iter()
            .map(|p| Self::VerificationKey {
                weighted_player: p,
                mpk_g2,
                vks_g2: subtranscript
                    .get_public_key_share(threshold_config, &p)
                    .into_iter()
                    .map(|s| s.as_g2())
                    .collect(),
            })
            .collect();
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L275-276)
```rust
        vks[msk_share.weighted_player.get_id()]
            .vks_g2
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```

**File:** types/src/dkg/real_dkg/mod.rs (L43-47)
```rust
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct DKGPvssConfig {
    pub epoch: u64,
    // weighted config for randomness generation
    pub wconfig: SSConfig,
```
