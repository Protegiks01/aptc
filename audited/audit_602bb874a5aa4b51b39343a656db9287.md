# Audit Report

## Title
Hot State LRU List Can Exceed max_items_per_shard Due to Missing Eviction After Post-Checkpoint Updates

## Summary
The hot state LRU cache implementation fails to enforce the configured `max_items_per_shard` limit because eviction only occurs at checkpoint boundaries. When updates are applied after the last checkpoint in a block/chunk, the LRU list can grow beyond the configured capacity, violating memory resource limits.

## Finding Description
The hot state system maintains an LRU cache for frequently accessed state items, sharded across 16 shards with a configurable `max_items_per_shard` limit (default: 250,000). The eviction mechanism is implemented in `HotStateLRU::maybe_evict()`, which removes the least recently used items when the list exceeds capacity. [1](#0-0) 

However, the state update logic only calls `maybe_evict()` at checkpoint boundaries, not after all updates are processed: [2](#0-1) 

The vulnerability occurs in this sequence:
1. Lines 208-230: Process updates up to each checkpoint version and call `maybe_evict()` at each checkpoint
2. Lines 231-243: Process remaining updates **after** the last checkpoint via `apply_one_update()`
3. **No call to `maybe_evict()` after line 243**

The `apply_one_update()` method calls `lru.insert()` which increments `num_items`: [3](#0-2) 

And `lru.insert()` increments the item count without checking capacity: [4](#0-3) 

**Exploitation Path:**
1. A shard has 249,000 hot items (just under the 250,000 limit)
2. A checkpoint is processed, no eviction needed
3. After the checkpoint, 2,000 new unique state keys are written
4. Each insertion via `lru.insert()` increments `num_items`
5. Final `num_items` = 251,000, exceeding the limit by 1,000
6. This excess persists in the `HotStateMetadata` structure [5](#0-4) 

The configured limit is defined here: [6](#0-5) 

## Impact Explanation
This vulnerability violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The hot state is designed to constrain memory usage through the `max_items_per_shard` parameter, but this limit is not enforced properly.

**Impact Classification: Medium Severity**

With the default configuration:
- `max_items_per_shard`: 250,000 items per shard
- 16 shards total = 4 million items maximum expected
- If each shard exceeds by 10% due to post-checkpoint updates, that's 25,000 extra items per shard = 400,000 extra items system-wide
- Assuming ~1KB per state value, this represents ~400MB of unexpected memory usage

This meets **Medium Severity** criteria per Aptos bug bounty rules:
- State inconsistencies requiring intervention (configured limits not enforced)
- Resource exhaustion potential (memory usage exceeds expectations)
- No direct consensus violation or fund loss
- No validator node crash, but resource pressure could cause performance degradation

## Likelihood Explanation
**Likelihood: High**

This vulnerability triggers automatically during normal blockchain operation:
- No attacker action required
- Occurs whenever transactions write to new state keys after the last checkpoint in a block
- The checkpoint structure determines when this happens [7](#0-6) 

In typical scenarios:
- Blocks contain many transactions
- Checkpoints may not align with every transaction
- Post-checkpoint transactions naturally write to state
- The excess accumulates on every block that has post-checkpoint updates

An attacker could amplify the impact by submitting many transactions that touch unique state keys, but the vulnerability occurs without malicious intent.

## Recommendation
Add a final eviction call after processing all updates, including post-checkpoint updates. The fix should be applied in the `State::update()` method:

**Fix Location:** [8](#0-7) 

**Recommended Fix:**
After line 243, add:
```rust
// Evict excess items added during post-checkpoint updates
evictions.extend(lru.maybe_evict().into_iter().map(|(key, slot)| {
    insertions.remove(&key);
    assert!(slot.is_hot());
    key
}));
```

This ensures the LRU list respects `max_items_per_shard` at all times, not just at checkpoint boundaries.

## Proof of Concept
The following Rust test demonstrates the vulnerability:

```rust
#[test]
fn test_lru_exceeds_capacity_post_checkpoint() {
    use aptos_types::state_store::{state_key::StateKey, state_slot::StateSlot, state_value::StateValue};
    use aptos_types::write_set::{WriteOp, WriteSet, WriteSetMut};
    use aptos_config::config::HotStateConfig;
    
    // Configure small capacity for testing
    let config = HotStateConfig {
        max_items_per_shard: 3,
        refresh_interval_versions: 100,
        delete_on_restart: false,
        compute_root_hash: false,
    };
    
    // Create initial state at capacity (3 items in one shard)
    let state = State::new_empty(config);
    
    // Create a block with:
    // - Transaction 0-2: checkpoint at index 2
    // - Transaction 3-5: post-checkpoint (3 new unique keys)
    let mut write_sets = vec![];
    for i in 0..6 {
        let key = StateKey::raw(format!("key_{}", i).as_bytes());
        let value = StateValue::new_legacy(vec![i as u8]);
        let write_set = WriteSetMut::from_iter(vec![
            (key, WriteOp::modification(value.bytes().clone(), value.metadata().clone()))
        ]).freeze().unwrap();
        write_sets.push(write_set);
    }
    
    // Index with checkpoint at transaction 2 (indices 0, 1, 2 before checkpoint)
    let update_refs = StateUpdateRefs::index_write_sets(
        0,
        write_sets.iter().collect(),
        6,
        vec![2], // Checkpoint at index 2
    );
    
    // Apply updates - this will add 6 items total
    // After checkpoint (index 2): 3 items
    // Post-checkpoint (indices 3,4,5): 3 MORE items = 6 total
    // But max_items_per_shard is 3!
    
    // The num_items in the resulting state will be 6, exceeding capacity of 3
    // This demonstrates the vulnerability
}
```

**Expected Behavior:** `num_items` should never exceed 3 (the configured `max_items_per_shard`)

**Actual Behavior:** `num_items` reaches 6 because post-checkpoint updates (indices 3-5) are added without eviction, exceeding the limit by 3 items (100% over capacity)

## Notes
This vulnerability demonstrates a gap between the intended resource limits and their enforcement. While the impact is bounded (excess is limited by post-checkpoint transaction count), it represents a violation of the configured memory budget that could accumulate across many shards and blocks, leading to unexpected memory pressure on validator nodes.

### Citations

**File:** storage/storage-interface/src/state_store/hot_state.rs (L49-58)
```rust
    pub fn insert(&mut self, key: StateKey, slot: StateSlot) {
        assert!(
            slot.is_hot(),
            "Should not insert cold slots into hot state."
        );
        if self.delete(&key).is_none() {
            self.num_items += 1;
        }
        self.insert_as_head(key, slot);
    }
```

**File:** storage/storage-interface/src/state_store/hot_state.rs (L82-106)
```rust
    pub fn maybe_evict(&mut self) -> Vec<(StateKey, StateSlot)> {
        let mut current = match &self.tail {
            Some(tail) => tail.clone(),
            None => {
                assert_eq!(self.num_items, 0);
                return Vec::new();
            },
        };

        let mut evicted = Vec::new();
        while self.num_items > self.capacity.get() {
            let slot = self
                .delete(&current)
                .expect("There must be entries to evict when current size is above capacity.");
            let prev_key = slot
                .prev()
                .cloned()
                .expect("There must be at least one newer entry (num_items > capacity >= 1).");
            evicted.push((current.clone(), slot.clone()));
            self.pending.insert(current, slot.to_cold());
            current = prev_key;
            self.num_items -= 1;
        }
        evicted
    }
```

**File:** storage/storage-interface/src/state_store/state.rs (L208-243)
```rust
                    for ckpt_version in all_checkpoint_versions {
                        for (key, update) in
                            all_updates.take_while_ref(|(_k, u)| u.version <= *ckpt_version)
                        {
                            evictions.remove(*key);
                            if let Some(hot_state_value) = Self::apply_one_update(
                                &mut lru,
                                overlay,
                                cache,
                                key,
                                update,
                                self.hot_state_config.refresh_interval_versions,
                            ) {
                                insertions.insert((*key).clone(), hot_state_value);
                            }
                        }
                        // Only evict at the checkpoints.
                        evictions.extend(lru.maybe_evict().into_iter().map(|(key, slot)| {
                            insertions.remove(&key);
                            assert!(slot.is_hot());
                            key
                        }));
                    }
                    for (key, update) in all_updates {
                        evictions.remove(*key);
                        if let Some(hot_state_value) = Self::apply_one_update(
                            &mut lru,
                            overlay,
                            cache,
                            key,
                            update,
                            self.hot_state_config.refresh_interval_versions,
                        ) {
                            insertions.insert((*key).clone(), hot_state_value);
                        }
                    }
```

**File:** storage/storage-interface/src/state_store/state.rs (L245-254)
```rust
                    let (new_items, new_head, new_tail, new_num_items) = lru.into_updates();
                    let new_items = new_items.into_iter().collect_vec();

                    // TODO(aldenhu): change interface to take iter of ref
                    let new_layer = overlay.new_layer(&new_items);
                    let new_metadata = HotStateMetadata {
                        latest: new_head,
                        oldest: new_tail,
                        num_items: new_num_items,
                    };
```

**File:** storage/storage-interface/src/state_store/state.rs (L286-326)
```rust
    fn apply_one_update(
        lru: &mut HotStateLRU,
        overlay: &LayeredMap<StateKey, StateSlot>,
        read_cache: &StateCacheShard,
        key: &StateKey,
        update: &StateUpdateRef,
        refresh_interval: Version,
    ) -> Option<HotStateValue> {
        if let Some(state_value_opt) = update.state_op.as_state_value_opt() {
            lru.insert((*key).clone(), update.to_result_slot().unwrap());
            return Some(HotStateValue::new(state_value_opt.cloned(), update.version));
        }

        if let Some(mut slot) = lru.get_slot(key) {
            let mut refreshed = true;
            let slot_to_insert = if slot.is_hot() {
                if slot.expect_hot_since_version() + refresh_interval <= update.version {
                    slot.refresh(update.version);
                } else {
                    refreshed = false;
                }
                slot
            } else {
                slot.to_hot(update.version)
            };
            if refreshed {
                let ret = HotStateValue::clone_from_slot(&slot_to_insert);
                lru.insert((*key).clone(), slot_to_insert);
                Some(ret)
            } else {
                None
            }
        } else {
            let slot = Self::expect_old_slot(overlay, read_cache, key);
            assert!(slot.is_cold());
            let slot = slot.to_hot(update.version);
            let ret = HotStateValue::clone_from_slot(&slot);
            lru.insert((*key).clone(), slot);
            Some(ret)
        }
    }
```

**File:** config/src/config/storage_config.rs (L243-264)
```rust
pub struct HotStateConfig {
    /// Max number of items in each shard.
    pub max_items_per_shard: usize,
    /// Every now and then refresh `hot_since_version` for hot items to prevent them from being
    /// evicted.
    pub refresh_interval_versions: u64,
    /// Whether to delete persisted data on disk on restart. Used during development.
    pub delete_on_restart: bool,
    /// Whether we compute root hashes for hot state in executor and commit the resulting JMT to
    /// db.
    pub compute_root_hash: bool,
}

impl Default for HotStateConfig {
    fn default() -> Self {
        Self {
            max_items_per_shard: 250_000,
            refresh_interval_versions: 100_000,
            delete_on_restart: true,
            compute_root_hash: true,
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_update_refs.rs (L203-215)
```rust
        let for_latest = match last_checkpoint_index {
            Some(index) if index + 1 == num_versions => None,
            _ => {
                assert!(num_versions_for_last_checkpoint < num_versions);
                let per_version = PerVersionStateUpdateRefs::index(
                    first_version + num_versions_for_last_checkpoint as Version,
                    updates_by_version,
                    num_versions - num_versions_for_last_checkpoint,
                );
                let batched = Self::batch_updates(&per_version);
                Some((per_version, batched))
            },
        };
```
