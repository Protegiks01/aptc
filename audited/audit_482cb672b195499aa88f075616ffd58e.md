# Audit Report

## Title
Division by Zero in Proposer Election Causes Validator Crash with All-Zero Voting Powers

## Summary
The `choose_index()` function in the consensus layer's proposer election mechanism lacks validation for all-zero weights, causing a division by zero panic that crashes all validator nodes when all validators in the active set have zero voting power.

## Finding Description

The vulnerability exists in the proposer election logic where validators with zero voting power can remain in the active validator set under specific configurations, leading to a network-wide panic when selecting a proposer.

The `choose_index()` function accumulates weights into `total_weight` without validating whether the result is zero before performing division operations. [1](#0-0) 

The `next_in_range()` function performs a modulo operation where the divisor is `max` (which equals `total_weight`). When `max = 0`, this causes a division by zero panic. [2](#0-1) 

The stake weights used for proposer election are calculated by multiplying reputation weights with validator voting powers. If all validators have zero voting power, all stake weights become zero regardless of reputation values. [3](#0-2) 

The critical gap exists in the staking configuration validation, which allows `minimum_stake = 0`. [4](#0-3) 

During epoch reconfiguration, validators with zero voting power pass the eligibility check when `minimum_stake = 0`, remaining in the active validator set. [5](#0-4) 

Similarly, when joining the validator set, the check allows zero voting power when `minimum_stake = 0`. [6](#0-5) 

The Rust consensus code in `leader_reputation.rs` logs an error when total voting power is zero but does not prevent the crash in `choose_index()`. [7](#0-6) 

This represents a defensive programming failure where the Move framework explicitly allows a configuration (`minimum_stake = 0`) that the Rust consensus layer cannot safely handle.

## Impact Explanation

**Critical Severity** - This vulnerability causes complete loss of network liveness:

- All validators in the network will panic and crash when attempting proposer election with all-zero voting powers
- The network becomes completely unavailable and unable to produce blocks
- Requires emergency intervention or hard fork to recover
- Meets the "Total loss of liveness/network availability" criteria per Aptos bug bounty program (Critical severity, up to $1,000,000)

The panic would occur synchronously across all validators attempting to elect a proposer for the same round, resulting in immediate and total network halt.

## Likelihood Explanation

**Low Likelihood in Production Networks**, but possible through:

1. **Genesis Misconfiguration**: Network initialized with `minimum_stake = 0` and validators having zero initial stake
2. **Governance Configuration Error**: Governance proposal setting `minimum_stake = 0` after validators' stake has been reduced to zero through withdrawals or slashing

While unlikely in a properly configured and monitored production network, this represents a critical defensive programming failure. The Move framework's staking configuration explicitly permits `minimum_stake = 0`, but the Rust consensus layer assumes this edge case will never occur. This architectural mismatch creates a single point of failure where a valid on-chain configuration can trigger catastrophic network failure.

## Recommendation

Add validation in the `choose_index()` function to handle empty or all-zero weights:

```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    assert!(!weights.is_empty(), "Cannot choose from empty weights vector");
    
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    assert!(total_weight > 0, "Total weight must be greater than zero");
    
    let chosen_weight = next_in_range(state, total_weight);
    // ... rest of function
}
```

Alternatively, add validation in `LeaderReputation::get_valid_proposer_and_voting_power_participation_ratio` before calling `choose_index()` to handle the all-zero voting power case gracefully, possibly by falling back to round-robin proposer selection.

Additionally, consider adding validation in `staking_config::validate_required_stake()` to require `minimum_stake > 0`, preventing this configuration from being set through governance.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Configure network with `minimum_stake = 0` in genesis or through governance
2. Initialize validators with zero stake or allow existing validators' stake to drop to zero
3. At epoch reconfiguration, validators with `voting_power = 0` remain in active set (check passes: `0 >= 0`)
4. When `LeaderReputation::get_valid_proposer()` is called for proposer election:
   - Reputation heuristic computes reputation weights (non-zero)
   - Stake weights calculated as `reputation_weight * 0 = 0` for all validators
   - `choose_index()` called with all-zero stake_weights
   - `total_weight` accumulates to 0
   - `next_in_range(state, 0)` executes `hash % 0` â†’ division by zero panic
5. All validators crash synchronously when attempting proposer election
6. Network halts completely

**Notes**

This vulnerability represents a critical architectural gap between the Move framework's permissive configuration validation and the Rust consensus layer's assumptions. While the likelihood is low in production due to economic incentives and proper network monitoring, the defensive programming failure creates an unacceptable single point of failure. The Move layer explicitly allows `minimum_stake = 0` as a valid configuration, but the consensus layer cannot safely handle the resulting state where all validators have zero voting power. This mismatch violates the principle of defense in depth and should be addressed to prevent catastrophic network failure from configuration mistakes.

### Citations

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```

**File:** consensus/src/liveness/leader_reputation.rs (L670-678)
```rust
                        } else if total_voting_power >= 1.0 {
                            participating_voting_power / total_voting_power
                        } else {
                            error!(
                                "Total voting power is {}, should never happen",
                                total_voting_power
                            );
                            1.0
                        };
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-732)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1073-1076)
```text
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1398)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
```
