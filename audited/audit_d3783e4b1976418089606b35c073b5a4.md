# Audit Report

## Title
Configuration Divergence in Genesis Transaction Generation Enables Unauthorized Minting Capabilities in Production-like Networks

## Summary
The `GenesisInfo::generate_genesis_txn()` function in `crates/aptos-genesis/src/lib.rs` hardcodes `is_test: true` at line 145, ignoring the `self.is_test` field that may be set to `false`. This creates a critical divergence between the intended configuration and the actual genesis transaction, resulting in the unintended creation of a `@core_resources` account with unlimited coin minting capabilities and protocol version manipulation rights in networks that are configured to be production-like (with `is_test: false`). [1](#0-0) 

## Finding Description
The vulnerability stems from a configuration inconsistency in the genesis transaction generation process. When a `GenesisInfo` object is created, it accepts a `GenesisConfiguration` parameter that includes an `is_test` field, which is stored in `self.is_test`: [2](#0-1) 

However, when the actual genesis transaction is generated via `generate_genesis_txn()`, line 145 hardcodes `is_test: true` instead of using `self.is_test`: [3](#0-2) 

This divergence has severe security implications because the `is_test` parameter controls the creation of privileged test-only capabilities during genesis. When `is_test` is `true` in the VM genesis module, two critical operations occur:

1. **Minting Capability Creation**: The `initialize_core_resources_and_aptos_coin` function is called, which creates a `@core_resources` account with `MintCapability` stored in it: [4](#0-3) [5](#0-4) [6](#0-5) 

2. **Version Manipulation Capability**: The `allow_core_resources_to_set_version` function is called, granting the ability to manipulate protocol versions: [7](#0-6) [8](#0-7) 

**Attack Scenario:**
1. A team deploys a testnet or devnet using the `GenesisInfo` path (not `MainnetGenesisInfo`) with the intention of creating a production-like environment
2. They set `is_test: false` in their `GenesisConfiguration`, expecting no test-only backdoors to exist: [9](#0-8) 

3. Due to the hardcoded `is_test: true`, the genesis transaction creates the `@core_resources` account with full minting capability
4. Anyone with the private key corresponding to the `root_key` (which becomes `core_resources_key` in the genesis) can:
   - Mint unlimited AptosCoin by calling `aptos_coin::mint()`: [10](#0-9) 

   - Manipulate protocol versions via `version::set_version()`: [11](#0-10) 

   - Delegate minting capability to other accounts: [12](#0-11) 

Note that `MainnetGenesisInfo` correctly hardcodes `is_test: false` and avoids this issue: [13](#0-12) 

## Impact Explanation
This vulnerability has **Critical Severity** impact under the Aptos Bug Bounty program as it enables "Loss of Funds (theft or minting)". 

The ability to mint unlimited AptosCoin completely breaks the economic model of any network deployed with this configuration divergence. An attacker with access to the `root_key` private key can:
- Create arbitrary amounts of AptosCoin, causing unlimited inflation
- Steal value from all other token holders through dilution
- Manipulate the protocol version, potentially causing consensus issues or network instability

This breaks the **Access Control** invariant (#8: "System addresses (@aptos_framework, @core_resources) must be protected") and the economic security model of the blockchain.

## Likelihood Explanation
The likelihood is **Medium to High** for the following reasons:

**Factors Increasing Likelihood:**
1. The bug is silent - there's no error or warning when `is_test: false` is specified but `is_test: true` is used
2. Testnets and devnets frequently use the `GenesisInfo` path and may attempt to set `is_test: false` for production-like testing
3. The `root_key` private key may be known to multiple parties in test environments, or could be leaked/compromised
4. The configuration field exists and is documented, leading operators to believe it works as intended

**Factors Reducing Likelihood:**
1. Production mainnet uses `MainnetGenesisInfo`, which correctly sets `is_test: false`
2. Exploiting requires knowledge of the `root_key` private key
3. Most test networks may intentionally keep `is_test: true` for testing purposes

## Recommendation
Fix the configuration divergence by using `self.is_test` instead of the hardcoded `true`:

**In `crates/aptos-genesis/src/lib.rs`, line 145:**
```rust
fn generate_genesis_txn(&self) -> Transaction {
    aptos_vm_genesis::encode_genesis_transaction(
        self.root_key.clone(),
        &self.validators,
        &self.framework,
        self.chain_id,
        &aptos_vm_genesis::GenesisConfiguration {
            allow_new_validators: self.allow_new_validators,
            epoch_duration_secs: self.epoch_duration_secs,
            is_test: self.is_test,  // FIX: Use self.is_test instead of hardcoded true
            min_stake: self.min_stake,
            // ... rest of fields
        },
        &self.consensus_config,
        &self.execution_config,
        &self.gas_schedule,
    )
}
```

Additionally, add validation to ensure the configuration intent is clear:
1. Add a warning log when `is_test: false` is used with `GenesisInfo` (since it may be unintended)
2. Add documentation clarifying that `MainnetGenesisInfo` should be used for production mainnet deployments
3. Consider adding an assertion or explicit check to prevent accidental misconfiguration

## Proof of Concept

**Step 1: Create a GenesisInfo with is_test: false**
```rust
// This can be done via the CLI with a layout file setting is_test: false
// or programmatically in tests:

use aptos_genesis::{GenesisInfo, builder::GenesisConfiguration};

let genesis_config = GenesisConfiguration {
    is_test: false,  // Operator intends no test capabilities
    // ... other fields
};

let mut genesis_info = GenesisInfo::new(
    chain_id,
    root_key,
    validators,
    framework,
    &genesis_config,
)?;
```

**Step 2: Generate genesis transaction**
```rust
// Due to the bug, this will create genesis with is_test: true
let genesis_tx = genesis_info.get_genesis();
```

**Step 3: Verify the divergence**
```rust
// The GenesisInfo object has is_test: false
assert_eq!(genesis_info.is_test, false);

// But the actual genesis transaction was created with is_test: true
// This means @core_resources account exists with MintCapability
```

**Step 4: Exploit - Mint unlimited coins**
```move
script {
    use std::signer;
    use aptos_framework::aptos_coin;
    
    fun exploit_mint(core_resources: &signer) {
        // This succeeds because MintCapStore exists at @core_resources
        // due to the hardcoded is_test: true
        aptos_coin::mint(core_resources, @attacker, 1000000000000000);
        
        // Can also delegate minting to other accounts
        aptos_coin::delegate_mint_capability(*core_resources, @other_attacker);
    }
}
```

**Step 5: Verify version manipulation capability**
```move
script {
    use aptos_framework::version;
    
    fun exploit_version(core_resources: &signer) {
        // This succeeds because SetVersionCapability exists at @core_resources
        version::set_version(core_resources, 999);
    }
}
```

**Notes**
The vulnerability exists specifically in the `GenesisInfo` path used for non-mainnet deployments. The `MainnetGenesisInfo` implementation correctly handles the `is_test` parameter by hardcoding it to `false` and calling the mainnet-specific genesis function. However, the regular `GenesisInfo` path has this critical bug where the configuration divergence creates unintended privileged capabilities in networks that attempt to configure themselves as production-like with `is_test: false`.

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L86-125)
```rust
    pub fn new(
        chain_id: ChainId,
        root_key: Ed25519PublicKey,
        configs: Vec<ValidatorConfiguration>,
        framework: ReleaseBundle,
        genesis_config: &GenesisConfiguration,
    ) -> anyhow::Result<GenesisInfo> {
        let mut validators = Vec::new();

        for config in configs {
            validators.push(config.try_into()?)
        }

        Ok(GenesisInfo {
            chain_id,
            root_key,
            validators,
            framework,
            genesis: None,
            allow_new_validators: genesis_config.allow_new_validators,
            epoch_duration_secs: genesis_config.epoch_duration_secs,
            is_test: genesis_config.is_test,
            min_stake: genesis_config.min_stake,
            min_voting_threshold: genesis_config.min_voting_threshold,
            max_stake: genesis_config.max_stake,
            recurring_lockup_duration_secs: genesis_config.recurring_lockup_duration_secs,
            required_proposer_stake: genesis_config.required_proposer_stake,
            rewards_apy_percentage: genesis_config.rewards_apy_percentage,
            voting_duration_secs: genesis_config.voting_duration_secs,
            voting_power_increase_limit: genesis_config.voting_power_increase_limit,
            consensus_config: genesis_config.consensus_config.clone(),
            execution_config: genesis_config.execution_config.clone(),
            gas_schedule: genesis_config.gas_schedule.clone(),
            initial_features_override: genesis_config.initial_features_override.clone(),
            randomness_config_override: genesis_config.randomness_config_override.clone(),
            jwk_consensus_config_override: genesis_config.jwk_consensus_config_override.clone(),
            initial_jwks: genesis_config.initial_jwks.clone(),
            keyless_groth16_vk: genesis_config.keyless_groth16_vk.clone(),
        })
    }
```

**File:** crates/aptos-genesis/src/lib.rs (L136-166)
```rust
    fn generate_genesis_txn(&self) -> Transaction {
        aptos_vm_genesis::encode_genesis_transaction(
            self.root_key.clone(),
            &self.validators,
            &self.framework,
            self.chain_id,
            &aptos_vm_genesis::GenesisConfiguration {
                allow_new_validators: self.allow_new_validators,
                epoch_duration_secs: self.epoch_duration_secs,
                is_test: true,
                min_stake: self.min_stake,
                min_voting_threshold: self.min_voting_threshold,
                max_stake: self.max_stake,
                recurring_lockup_duration_secs: self.recurring_lockup_duration_secs,
                required_proposer_stake: self.required_proposer_stake,
                rewards_apy_percentage: self.rewards_apy_percentage,
                voting_duration_secs: self.voting_duration_secs,
                voting_power_increase_limit: self.voting_power_increase_limit,
                employee_vesting_start: 1663456089,
                employee_vesting_period_duration: 5 * 60, // 5 minutes
                initial_features_override: self.initial_features_override.clone(),
                randomness_config_override: self.randomness_config_override.clone(),
                jwk_consensus_config_override: self.jwk_consensus_config_override.clone(),
                initial_jwks: self.initial_jwks.clone(),
                keyless_groth16_vk: self.keyless_groth16_vk.clone(),
            },
            &self.consensus_config,
            &self.execution_config,
            &self.gas_schedule,
        )
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L312-321)
```rust
    if genesis_config.is_test {
        initialize_core_resources_and_aptos_coin(
            &mut session,
            &module_storage,
            &mut traversal_context,
            core_resources_key,
        );
    } else {
        initialize_aptos_coin(&mut session, &module_storage, &mut traversal_context);
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L351-352)
```rust
    if genesis_config.is_test {
        allow_core_resources_to_set_version(&mut session, &module_storage, &mut traversal_context);
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L153-173)
```text
    fun initialize_core_resources_and_aptos_coin(
        aptos_framework: &signer,
        core_resources_auth_key: vector<u8>,
    ) {
        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);

        coin::create_coin_conversion_map(aptos_framework);
        coin::create_pairing<AptosCoin>(aptos_framework);

        // Give stake module MintCapability<AptosCoin> so it can mint rewards.
        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.
        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);
        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.
        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);

        let core_resources = account::create_account(@core_resources);
        account::rotate_authentication_key_internal(&core_resources, core_resources_auth_key);
        aptos_account::register_apt(&core_resources); // registers APT store
        aptos_coin::configure_accounts_for_test(aptos_framework, &core_resources, mint_cap);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L73-89)
```text
    public(friend) fun configure_accounts_for_test(
        aptos_framework: &signer,
        core_resources: &signer,
        mint_cap: MintCapability<AptosCoin>,
    ) {
        system_addresses::assert_aptos_framework(aptos_framework);

        // Mint the core resource account AptosCoin for gas so it can execute system transactions.
        let coins = coin::mint<AptosCoin>(
            18446744073709551615,
            &mint_cap,
        );
        coin::deposit<AptosCoin>(signer::address_of(core_resources), coins);

        move_to(core_resources, MintCapStore { mint_cap });
        move_to(core_resources, Delegations { inner: vector::empty() });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L92-108)
```text
    /// Create new coins and deposit them into dst_addr's account.
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L112-120)
```text
    public entry fun delegate_mint_capability(account: signer, to: address) acquires Delegations {
        system_addresses::assert_core_resource(&account);
        let delegations = &mut borrow_global_mut<Delegations>(@core_resources).inner;
        vector::for_each_ref(delegations, |element| {
            let element: &DelegatedMintCapability = element;
            assert!(element.to != to, error::invalid_argument(EALREADY_DELEGATED));
        });
        vector::push_back(delegations, DelegatedMintCapability { to });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L41-53)
```text
    public entry fun set_version(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        chain_status::assert_genesis();

        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));

        let config = borrow_global_mut<Version>(@aptos_framework);
        config.major = major;

        // Need to trigger reconfiguration so validator nodes can sync on the updated version.
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L81-84)
```text
    fun initialize_for_test(core_resources: &signer) {
        system_addresses::assert_core_resource(core_resources);
        move_to(core_resources, SetVersionCapability {});
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L283-311)
```rust
    Ok(GenesisInfo::new(
        layout.chain_id,
        layout.root_key.unwrap(),
        validators,
        framework,
        &GenesisConfiguration {
            allow_new_validators: layout.allow_new_validators,
            epoch_duration_secs: layout.epoch_duration_secs,
            is_test: layout.is_test,
            min_stake: layout.min_stake,
            min_voting_threshold: layout.min_voting_threshold,
            max_stake: layout.max_stake,
            recurring_lockup_duration_secs: layout.recurring_lockup_duration_secs,
            required_proposer_stake: layout.required_proposer_stake,
            rewards_apy_percentage: layout.rewards_apy_percentage,
            voting_duration_secs: layout.voting_duration_secs,
            voting_power_increase_limit: layout.voting_power_increase_limit,
            employee_vesting_start: layout.employee_vesting_start,
            employee_vesting_period_duration: layout.employee_vesting_period_duration,
            consensus_config: layout.on_chain_consensus_config,
            execution_config: layout.on_chain_execution_config,
            gas_schedule: default_gas_schedule(),
            initial_features_override: None,
            randomness_config_override: None,
            jwk_consensus_config_override: layout.jwk_consensus_config_override.clone(),
            initial_jwks: layout.initial_jwks.clone(),
            keyless_groth16_vk: layout.keyless_groth16_vk_override.clone(),
        },
    )?)
```

**File:** crates/aptos-genesis/src/mainnet.rs (L122-149)
```rust
    fn generate_genesis_txn(&self) -> Transaction {
        aptos_vm_genesis::encode_aptos_mainnet_genesis_transaction(
            &self.accounts,
            &self.employee_vesting_accounts,
            &self.validators,
            &self.framework,
            self.chain_id,
            &aptos_vm_genesis::GenesisConfiguration {
                allow_new_validators: true,
                is_test: false,
                epoch_duration_secs: self.epoch_duration_secs,
                min_stake: self.min_stake,
                min_voting_threshold: self.min_voting_threshold,
                max_stake: self.max_stake,
                recurring_lockup_duration_secs: self.recurring_lockup_duration_secs,
                required_proposer_stake: self.required_proposer_stake,
                rewards_apy_percentage: self.rewards_apy_percentage,
                voting_duration_secs: self.voting_duration_secs,
                voting_power_increase_limit: self.voting_power_increase_limit,
                employee_vesting_start: self.employee_vesting_start,
                employee_vesting_period_duration: self.employee_vesting_period_duration,
                initial_features_override: self.initial_features_override.clone(),
                randomness_config_override: self.randomness_config_override.clone(),
                jwk_consensus_config_override: self.jwk_consensus_config_override.clone(),
                initial_jwks: vec![],
                keyless_groth16_vk: None,
            },
        )
```
