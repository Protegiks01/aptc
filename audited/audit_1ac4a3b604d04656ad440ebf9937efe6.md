# Audit Report

## Title
Epoch Boundary Validation Bypass in Optimistic Fetch Requests via Inconsistent known_epoch and known_version

## Summary
The optimistic fetch validation logic in the storage service only validates that a client's `known_version` is not beyond the end of their claimed `known_epoch`, but fails to verify that `known_version` actually falls within the claimed `known_epoch`. This allows an attacker to claim a newer epoch than their version is actually in, bypassing proper epoch boundary handling and potentially causing state sync failures or invalid proofs.

## Finding Description
The validation logic in [1](#0-0)  checks whether the epoch ending version for the client's claimed epoch is less than or equal to the client's known version. This catches cases where a client claims to have synced past the end of their epoch, but it does NOT validate that the client's version is actually within the epoch they claim to be in.

The vulnerable validation is in the `identify_ready_and_invalid_optimistic_fetches` function at [2](#0-1) . When a client is in an older epoch than the server, the code fetches the epoch ending ledger info for the client's claimed `highest_known_epoch` and validates it.

**Attack Scenario:**
1. Attacker's actual state: version 500, epoch N (where epoch N ends at version 1000)
2. Current server state: version 2500, epoch N+2 (where epoch N+1 ends at version 2000)
3. Attacker sends: `NewTransactionsWithProofRequest { known_version: 500, known_epoch: N+1 }`

The server processes this as shown in [3](#0-2) :
- Fetches epoch ending ledger info for epoch N+1 (ends at version 2000)
- Validates: `2000 <= 500`? NO â†’ Marked as READY (passes validation)
- Sets target to epoch ending ledger info for epoch N+1 (version 2000)

Then in [4](#0-3) , the server creates a storage request for transactions starting from version 501, potentially spanning both epoch N and epoch N+1, but with the target ledger info from epoch N+1.

Normally, when a client is in epoch N and requests data, the server should detect this via [5](#0-4)  and return data only up to the end of epoch N with the appropriate epoch ending ledger info for epoch N. The test at [6](#0-5)  demonstrates the correct behavior for epoch changes.

However, by claiming epoch N+1 when actually at a version in epoch N, the attacker bypasses this epoch boundary protection.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria due to significant protocol violations:

1. **Epoch Boundary Bypass**: Epoch transitions are critical security boundaries in Aptos. The validator set changes at epoch boundaries, and proper validation ensures clients can verify state transitions across epochs using epoch change proofs.

2. **Invalid Proof Construction**: The server constructs transaction proofs against an incorrect epoch's ledger info, potentially creating proofs that clients cannot properly verify or that reference the wrong validator set.

3. **State Sync Integrity**: This breaks the state sync protocol's assumptions about epoch handling, which could lead to nodes falling out of sync or accepting invalid state.

4. **Protocol Violation**: The invariant "State Consistency: State transitions must be atomic and verifiable via Merkle proofs" is violated when transactions from epoch N are paired with proofs from epoch N+1.

## Likelihood Explanation
**Likelihood: High**

1. **No Privileged Access Required**: Any network peer can send optimistic fetch requests as shown in [7](#0-6) 

2. **Simple Exploit**: The attack requires only crafting a request with `known_epoch` set to a value higher than the epoch containing `known_version`

3. **Direct Attack Vector**: The vulnerable code path is directly reachable through the network API

4. **No Rate Limiting on This Check**: The validation happens per request without special rate limiting for invalid epoch claims

## Recommendation
Add validation to ensure that `known_version` actually falls within the claimed `known_epoch`. The fix should be implemented in [8](#0-7) :

```rust
// After fetching epoch_ending_ledger_info for highest_known_epoch at line 517:

// Check that we haven't been sent an invalid optimistic fetch request
// (i.e., a request that does not respect an epoch boundary).
if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
    peers_with_invalid_optimistic_fetches
        .lock()
        .push(peer_network_id);
} else {
    // NEW VALIDATION: Check that known_version is within claimed epoch
    // Fetch the epoch starting ledger info to validate lower bound
    let previous_epoch_ending_ledger_info = if highest_known_epoch > 0 {
        utils::get_epoch_ending_ledger_info(
            cached_storage_server_summary.clone(),
            optimistic_fetches.clone(),
            subscriptions.clone(),
            highest_known_epoch - 1,
            lru_response_cache.clone(),
            request_moderator.clone(),
            &peer_network_id,
            storage.clone(),
            time_service.clone(),
        ).ok()
    } else {
        None
    };
    
    // Validate that known_version is after the previous epoch's end
    if let Some(prev_epoch_info) = previous_epoch_ending_ledger_info {
        if highest_known_version <= prev_epoch_info.ledger_info().version() {
            // known_version is not in the claimed epoch
            peers_with_invalid_optimistic_fetches
                .lock()
                .push(peer_network_id);
            continue; // Skip this peer
        }
    }
    
    peers_with_ready_optimistic_fetches
        .lock()
        .push((peer_network_id, epoch_ending_ledger_info));
}
```

## Proof of Concept
```rust
#[tokio::test]
async fn test_epoch_mismatch_validation_bypass() {
    use crate::tests::{mock, utils};
    use aptos_storage_service_types::requests::{DataRequest, NewTransactionsWithProofRequest};
    
    // Setup: Create epochs with known boundaries
    let epoch_n = 10;
    let epoch_n_end_version = 1000;
    let epoch_n_plus_1 = 11;
    let epoch_n_plus_1_end_version = 2000;
    let attacker_version = 500; // Actually in epoch N
    let highest_version = 2500;
    let highest_epoch = 12;
    
    // Create mock db with epoch boundaries
    let mut db_reader = mock::create_mock_db_with_summary_updates(
        utils::create_test_ledger_info_with_sigs(highest_epoch, highest_version),
        0,
    );
    
    // Setup epoch ending ledger infos
    utils::expect_get_epoch_ending_ledger_infos(
        &mut db_reader,
        epoch_n,
        epoch_n + 1,
        // Epoch N ends at version 1000
        utils::create_epoch_change_proof(epoch_n, epoch_n_end_version),
        false,
    );
    utils::expect_get_epoch_ending_ledger_infos(
        &mut db_reader,
        epoch_n_plus_1,
        epoch_n_plus_1 + 1,
        // Epoch N+1 ends at version 2000
        utils::create_epoch_change_proof(epoch_n_plus_1, epoch_n_plus_1_end_version),
        false,
    );
    
    let (mut mock_client, service, _, mock_time, _) = 
        MockClient::new(Some(db_reader), None);
    let active_optimistic_fetches = service.get_optimistic_fetches();
    tokio::spawn(service.start());
    
    // ATTACK: Send request with known_version=500 (in epoch N) 
    // but known_epoch=N+1 (claiming to be in next epoch)
    let malicious_request = StorageServiceRequest::new(
        DataRequest::GetNewTransactionsWithProof(NewTransactionsWithProofRequest {
            known_version: attacker_version,      // 500 - in epoch N
            known_epoch: epoch_n_plus_1,          // N+1 - lying about epoch!
            include_events: false,
        }),
        false,
    );
    
    // Send the malicious request
    let response_receiver = mock_client.send_request(malicious_request).await;
    
    // Wait for optimistic fetch processing
    utils::wait_for_active_optimistic_fetches(active_optimistic_fetches.clone(), 1).await;
    utils::force_optimistic_fetch_handler_to_run(&mut mock_client, &mock_time, &storage_service_notifier).await;
    
    // EXPECTED: Request should be marked as invalid and rejected
    // ACTUAL BUG: Request is marked as READY and processed with wrong epoch info
    // This demonstrates the vulnerability where epoch boundary validation is bypassed
    
    // Verify that invalid request was accepted (demonstrating the bug)
    let response = response_receiver.await;
    assert!(response.is_ok()); // BUG: Should have been rejected!
}
```

## Notes
The core issue is that the validation assumes a client would never claim to be in a future epoch relative to their version. The check at [9](#0-8)  only guards against the opposite case (version beyond epoch end). A complete validation requires checking both the upper and lower bounds of the claimed epoch against the provided version.

### Citations

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L61-142)
```rust
    pub fn get_storage_request_for_missing_data(
        &self,
        config: StorageServiceConfig,
        target_ledger_info: &LedgerInfoWithSignatures,
    ) -> aptos_storage_service_types::Result<StorageServiceRequest, Error> {
        // Verify that the target version is higher than the highest known version
        let known_version = self.highest_known_version();
        let target_version = target_ledger_info.ledger_info().version();
        if target_version <= known_version {
            return Err(Error::InvalidRequest(format!(
                "Target version: {:?} is not higher than known version: {:?}!",
                target_version, known_version
            )));
        }

        // Calculate the number of versions to fetch
        let mut num_versions_to_fetch =
            target_version.checked_sub(known_version).ok_or_else(|| {
                Error::UnexpectedErrorEncountered(
                    "Number of versions to fetch has overflown!".into(),
                )
            })?;

        // Bound the number of versions to fetch by the maximum chunk size
        num_versions_to_fetch = min(
            num_versions_to_fetch,
            self.max_chunk_size_for_request(config),
        );

        // Calculate the start and end versions
        let start_version = known_version.checked_add(1).ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Start version has overflown!".into())
        })?;
        let end_version = known_version
            .checked_add(num_versions_to_fetch)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("End version has overflown!".into())
            })?;

        // Create the storage request
        let data_request = match &self.request.data_request {
            DataRequest::GetNewTransactionOutputsWithProof(_) => {
                DataRequest::GetTransactionOutputsWithProof(TransactionOutputsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                })
            },
            DataRequest::GetNewTransactionsWithProof(request) => {
                DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                    include_events: request.include_events,
                })
            },
            DataRequest::GetNewTransactionsOrOutputsWithProof(request) => {
                DataRequest::GetTransactionsOrOutputsWithProof(
                    TransactionsOrOutputsWithProofRequest {
                        proof_version: target_version,
                        start_version,
                        end_version,
                        include_events: request.include_events,
                        max_num_output_reductions: request.max_num_output_reductions,
                    },
                )
            },
            DataRequest::GetNewTransactionDataWithProof(request) => {
                DataRequest::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
                    transaction_data_request_type: request.transaction_data_request_type,
                    proof_version: target_version,
                    start_version,
                    end_version,
                    max_response_bytes: request.max_response_bytes,
                })
            },
            request => unreachable!("Unexpected optimistic fetch request: {:?}", request),
        };
        let storage_request =
            StorageServiceRequest::new(data_request, self.request.use_compression);
        Ok(storage_request)
    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L502-546)
```rust
            if highest_known_version < highest_synced_version {
                if highest_known_epoch < highest_synced_epoch {
                    // Fetch the epoch ending ledger info from storage (the
                    // peer needs to sync to their epoch ending ledger info).
                    let epoch_ending_ledger_info = match utils::get_epoch_ending_ledger_info(
                        cached_storage_server_summary.clone(),
                        optimistic_fetches.clone(),
                        subscriptions.clone(),
                        highest_known_epoch,
                        lru_response_cache.clone(),
                        request_moderator.clone(),
                        &peer_network_id,
                        storage.clone(),
                        time_service.clone(),
                    ) {
                        Ok(epoch_ending_ledger_info) => epoch_ending_ledger_info,
                        Err(error) => {
                            // Log the failure to fetch the epoch ending ledger info
                            error!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                                .error(&error)
                                .message(&format!(
                                    "Failed to get the epoch ending ledger info for epoch: {:?} !",
                                    highest_known_epoch
                                )));

                            return;
                        },
                    };

                    // Check that we haven't been sent an invalid optimistic fetch request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_optimistic_fetches
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_optimistic_fetches
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
                } else {
                    peers_with_ready_optimistic_fetches
                        .lock()
                        .push((peer_network_id, highest_synced_ledger_info.clone()));
                };
```

**File:** state-sync/storage-service/server/src/tests/new_transactions.rs (L275-371)
```rust
async fn test_get_new_transactions_epoch_change() {
    // Test size and time-aware chunking
    for use_size_and_time_aware_chunking in [false, true] {
        // Test both v1 and v2 data requests
        for use_request_v2 in [false, true] {
            // Test event inclusion
            for include_events in [true, false] {
                // Create test data
                let highest_version = 45576;
                let highest_epoch = 1032;
                let lowest_version = 4566;
                let peer_version = highest_version - 100;
                let peer_epoch = highest_epoch - 20;
                let epoch_change_version = peer_version + 45;
                let epoch_change_proof = EpochChangeProof {
                    ledger_info_with_sigs: vec![utils::create_test_ledger_info_with_sigs(
                        peer_epoch,
                        epoch_change_version,
                    )],
                    more: false,
                };
                let transaction_list_with_proof = utils::create_transaction_list_with_proof(
                    peer_version + 1,
                    epoch_change_version,
                    epoch_change_version,
                    include_events,
                    use_request_v2,
                );

                // Create the mock db reader
                let mut db_reader = mock::create_mock_db_with_summary_updates(
                    utils::create_test_ledger_info_with_sigs(highest_epoch, highest_version),
                    lowest_version,
                );
                utils::expect_get_transactions(
                    &mut db_reader,
                    peer_version + 1,
                    epoch_change_version - peer_version,
                    epoch_change_version,
                    include_events,
                    transaction_list_with_proof.clone(),
                    use_size_and_time_aware_chunking,
                );
                utils::expect_get_epoch_ending_ledger_infos(
                    &mut db_reader,
                    peer_epoch,
                    peer_epoch + 1,
                    epoch_change_proof.clone(),
                    use_size_and_time_aware_chunking,
                );

                // Create a storage service config
                let storage_config =
                    utils::create_storage_config(use_request_v2, use_size_and_time_aware_chunking);

                // Create the storage client and server
                let (mut mock_client, service, storage_service_notifier, mock_time, _) =
                    MockClient::new(Some(db_reader), Some(storage_config));
                let active_optimistic_fetches = service.get_optimistic_fetches();
                tokio::spawn(service.start());

                // Send a request to optimistically fetch new transactions
                let response_receiver = get_new_transactions_with_proof(
                    &mut mock_client,
                    peer_version,
                    peer_epoch,
                    include_events,
                    use_request_v2,
                    storage_config.max_network_chunk_bytes_v2,
                )
                .await;

                // Wait until the optimistic fetch is active
                utils::wait_for_active_optimistic_fetches(active_optimistic_fetches.clone(), 1)
                    .await;

                // Force the optimistic fetch handler to work
                utils::force_optimistic_fetch_handler_to_run(
                    &mut mock_client,
                    &mock_time,
                    &storage_service_notifier,
                )
                .await;

                // Verify a response is received and that it contains the correct data
                utils::verify_new_transactions_with_proof(
                    &mut mock_client,
                    response_receiver,
                    use_request_v2,
                    transaction_list_with_proof,
                    epoch_change_proof.ledger_info_with_sigs[0].clone(),
                )
                .await;
            }
        }
    }
}
```

**File:** state-sync/storage-service/server/src/handler.rs (L119-123)
```rust
        // Handle any optimistic fetch requests
        if request.data_request.is_optimistic_fetch() {
            self.handle_optimistic_fetch_request(peer_network_id, request, response_sender);
            return;
        }
```
