# Audit Report

## Title
Sensitive Resource Data Disclosure in Resource Group Error Messages

## Summary
The `insert_group_op` function in `unsync_map.rs` includes Debug-formatted HashMap entries in error messages when resource group operation invariants are violated. These error messages, which are propagated through the API layer, leak complete resource bytes (including potentially sensitive user data such as balances and private state) to transaction submitters.

## Finding Description

The error message at lines 268-273 uses Debug formatting (`{:?}`) on a HashMap `Entry` when an invariant violation occurs: [1](#0-0) 

When the `Entry` is `Occupied`, its Debug representation includes the full `ValueWithLayout<V>` value. The `WriteOp` type implements a custom Debug trait that converts resource bytes to hexadecimal strings: [2](#0-1) 

This error propagates through the execution stack where it's logged and wrapped in a `PanicError::CodeInvariantError`: [3](#0-2) 

The error is then converted to a `VMStatus::Error` with the complete message included: [4](#0-3) 

Finally, the API layer appends this message to the transaction's vm_status field, exposing it to external callers: [5](#0-4) 

This creates a complete path from internal state to external disclosure: when a resource group operation invariant is violated (e.g., attempting to create a resource that already exists, or modify one that doesn't exist), the error message exposes the full byte content of the conflicting resource to the API response.

## Impact Explanation

This is a **Low Severity** information disclosure vulnerability as categorized in the Aptos Bug Bounty program under "Minor information leaks" (up to $1,000). The leaked information includes:

1. Complete resource byte content as hexadecimal strings
2. Resource metadata (StateValueMetadata)
3. Internal resource group structure details
4. StructTag information (addresses, module names, type parameters)

While this information disclosure doesn't directly compromise funds, consensus, or system availability, it violates confidentiality principles by exposing potentially sensitive user data (balances, private state) through error messages. This contradicts defense-in-depth practices where error messages should not leak internal implementation details.

## Likelihood Explanation

**Likelihood: Low**

Triggering this vulnerability requires causing a code invariant violation in resource group operations, which should not occur under normal operation. The invalid operation combinations that trigger the error include:

- Creating a resource that already exists (`Occupied` + `Creation`)
- Modifying a non-existent resource (`Vacant` + `Modification`)  
- Deleting a non-existent resource (`Vacant` + `Deletion`)

These scenarios indicate bugs in either the Move VM, transaction validation, or resource group handling logic. An attacker would need to:
1. Discover a separate bug that allows bypassing normal validation
2. Craft transactions that trigger the invariant violation
3. Observe the API error response containing the leaked data

The difficulty in reliably triggering this condition significantly reduces the practical exploitability, though the vulnerability remains real.

## Recommendation

Sanitize error messages to prevent leaking sensitive resource data. Replace Debug formatting of Entry values with generic descriptions:

```rust
(l, r) => {
    let entry_type = match &l {
        Occupied(_) => "Occupied",
        Vacant(_) => "Vacant",
    };
    return Err(code_invariant_error(format!(
        "WriteOp kind {:?} not consistent with previous value at tag {:?}. Entry type: {}, WriteOpKind: {:?}",
        v.write_op_kind(),
        value_tag,
        entry_type,
        r,
    )));
},
```

This preserves debugging information about the mismatch type while preventing exposure of sensitive resource bytes. For internal logging, consider using a separate error path that includes detailed information but doesn't propagate to external APIs.

## Proof of Concept

While creating a complete PoC requires triggering an invariant violation (which itself requires exploiting another bug), the information leak can be demonstrated conceptually:

```rust
// This would trigger if a transaction execution bug caused:
// 1. Move VM to generate a Creation WriteOp for an existing resource
// 2. The resource group cache already has an Occupied entry

// Result: API response would contain:
// "Execution failed with message: Code invariant broken (there is a bug in the code),
//  WriteOp kind Creation not consistent with previous value at tag StructTag {...}. 
//  Existing: Occupied(Entry { ... ValueWithLayout::Exchanged(... Creation(0a1b2c3d..., metadata:...) ...)}), 
//  new: Creation"

// The hexadecimal bytes (0a1b2c3d...) represent the complete resource data that should remain confidential.
```

## Notes

While this vulnerability is categorized as Low severity due to the difficulty in triggering it, it represents a real information disclosure risk that violates security best practices. Error messages should never expose complete internal state, especially sensitive user data, regardless of whether the error "should never happen." This finding aligns with the principle of defense-in-depth and proper error handling hygiene.

### Citations

**File:** aptos-move/mvhashmap/src/unsync_map.rs (L267-274)
```rust
            (l, r) => {
                return Err(code_invariant_error(format!(
                    "WriteOp kind {:?} not consistent with previous value at tag {:?}. Existing: {:?}, new: {:?}",
                    v.write_op_kind(),
                    value_tag,
		    l,
		    r,
                )));
```

**File:** types/src/write_set.rs (L473-495)
```rust
impl Debug for WriteOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use BaseStateOp::*;

        match &self.0 {
            Creation(v) => write!(
                f,
                "Creation({}, metadata:{:?})",
                v.bytes()
                    .iter()
                    .map(|byte| format!("{:02x}", byte))
                    .collect::<String>(),
                v.metadata(),
            ),
            Modification(v) => write!(
                f,
                "Modification({}, metadata:{:?})",
                v.bytes()
                    .iter()
                    .map(|byte| format!("{:02x}", byte))
                    .collect::<String>(),
                v.metadata(),
            ),
```

**File:** types/src/error.rs (L24-31)
```rust
pub fn code_invariant_error<M: std::fmt::Debug>(message: M) -> PanicError {
    let msg = format!(
        "Code invariant broken (there is a bug in the code), {:?}",
        message
    );
    error!("{}", msg);
    PanicError::CodeInvariantError(msg)
}
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L577-583)
```rust
            Err(BlockExecutionError::FatalBlockExecutorError(PanicError::CodeInvariantError(
                err_msg,
            ))) => Err(VMStatus::Error {
                status_code: StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                sub_status: None,
                message: Some(err_msg),
            }),
```

**File:** api/src/transactions.rs (L1745-1755)
```rust
                            match &vm_status {
                                VMStatus::Error {
                                    message: Some(msg), ..
                                }
                                | VMStatus::ExecutionFailure {
                                    message: Some(msg), ..
                                } => {
                                    user_txn.info.vm_status +=
                                        format!("\nExecution failed with message: {}", msg)
                                            .as_str();
                                },
```
