# Audit Report

## Title
Information Disclosure via View Function Error Code Enumeration

## Summary
The view function API returns distinguishable error codes and messages that allow unprivileged attackers to systematically enumerate which modules and functions exist at any address, determine which functions are view functions versus other function types, and infer function signature details.

## Finding Description

The vulnerability exists in the view function execution flow where different error codes are returned based on the specific failure condition. An attacker can exploit these different error responses to map the complete structure of modules and functions on-chain.

**Error Code Differentiation:** [1](#0-0) 

When a module or function doesn't exist, the loader returns `StatusCode::FUNCTION_RESOLUTION_FAILURE` (1091) with the message "Module or function do not exist for {address}::{module}::{function}". [2](#0-1) 

However, when a function exists but is not marked as a view function, a different error code `StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE` (1011) is returned with message "function not marked as view function". [3](#0-2) 

These errors are propagated to the API layer with their status codes intact. [4](#0-3) 

The API returns these status codes to the caller, enabling enumeration attacks.

**Attack Scenario:**
1. Attacker calls view function for `0x1::nonexistent_module::foo` → receives `FUNCTION_RESOLUTION_FAILURE` (1091)
2. Attacker calls view function for `0x1::coin::transfer` (real function, not a view) → receives `INVALID_MAIN_FUNCTION_SIGNATURE` (1011) with "function not marked as view function"
3. From response (2), attacker confirms that `coin::transfer` exists
4. Attacker systematically probes all possible function names across all modules to enumerate the complete codebase structure
5. For view functions, varying argument counts reveals signature information through different validation errors [5](#0-4) 

## Impact Explanation

This is a **Low Severity** vulnerability per Aptos Bug Bounty criteria: "Minor information leaks - Non-critical implementation bugs" (up to $1,000).

The vulnerability enables:
- Enumeration of all deployed modules at any address
- Discovery of all function names within modules
- Differentiation between view and non-view functions
- Inference of function signatures through parameter validation errors

However, it does NOT:
- Enable theft of funds or unauthorized resource access
- Cause consensus violations or state inconsistencies  
- Affect network availability or validator operations
- Break any critical system invariants

## Likelihood Explanation

**Likelihood: HIGH** - This vulnerability is trivially exploitable by any attacker with API access. No special privileges, cryptographic operations, or complex timing are required. An attacker can systematically enumerate the entire module/function namespace through simple HTTP requests to the public view function endpoint.

## Recommendation

Normalize all view function errors to return a single generic error code and message that doesn't distinguish between:
- Module doesn't exist
- Function doesn't exist  
- Function exists but isn't a view function
- Invalid parameters

**Proposed Fix:**

In `aptos-move/aptos-vm/src/aptos_vm.rs`, modify the error handling to return a generic message:

```rust
fn execute_view_function_in_vm(...) -> Result<Vec<Vec<u8>>, VMError> {
    // ... existing code ...
    
    // Map all errors to a generic response
    .map_err(|e| {
        PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
            .with_message("Invalid view function call".to_string())
            .finish(Location::Undefined)
    })
}
```

Alternatively, implement a whitelist-based approach where only explicitly allowed view functions can be called, returning the same error for any non-whitelisted function.

## Proof of Concept

```rust
#[test]
fn test_view_function_enumeration() {
    use aptos_vm::AptosVM;
    use move_core_types::{identifier::Identifier, language_storage::ModuleId};
    use aptos_types::account_address::AccountAddress;
    
    // Setup test environment with state view
    let state_view = /* ... */;
    
    // Test 1: Non-existent module
    let result1 = AptosVM::execute_view_function(
        &state_view,
        ModuleId::new(AccountAddress::ONE, Identifier::new("nonexistent").unwrap()),
        Identifier::new("foo").unwrap(),
        vec![],
        vec![],
        1_000_000,
    );
    // Expect: FUNCTION_RESOLUTION_FAILURE (1091)
    
    // Test 2: Existing function that's not a view
    let result2 = AptosVM::execute_view_function(
        &state_view,
        ModuleId::new(AccountAddress::ONE, Identifier::new("coin").unwrap()),
        Identifier::new("transfer").unwrap(),
        vec![],
        vec![],
        1_000_000,
    );
    // Expect: INVALID_MAIN_FUNCTION_SIGNATURE (1011)
    // Message: "function not marked as view function"
    
    // The different error codes confirm the function exists
    assert_ne!(
        result1.values.unwrap_err().status_code(),
        result2.values.unwrap_err().status_code()
    );
    
    // This proves enumeration is possible
}
```

## Notes

While this is a valid information disclosure vulnerability, it does not meet the **Critical, High, or Medium** severity thresholds required by the validation checklist. The security question itself marks this as **(Low)** severity, consistent with the "Minor information leaks" category in the Aptos Bug Bounty program.

The vulnerability does not break any of the 10 critical invariants (deterministic execution, consensus safety, Move VM safety, state consistency, governance integrity, staking security, transaction validation, access control, resource limits, or cryptographic correctness).

However, it represents a legitimate security concern for privacy-sensitive deployments where module/function existence should remain confidential.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L194-200)
```rust
                PartialVMError::new(StatusCode::FUNCTION_RESOLUTION_FAILURE)
                    .with_message(format!(
                        "Module or function do not exist for {}::{}::{}",
                        module_id.address(),
                        module_id.name(),
                        function_name
                    ))
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L48-52)
```rust
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2690-2729)
```rust
        match execution_result {
            Ok(result) => ViewFunctionOutput::new(Ok(result), gas_used),
            Err(e) => {
                let vm_status = e.clone().into_vm_status();
                match vm_status {
                    VMStatus::MoveAbort { .. } => {},
                    _ => {
                        let message = e
                            .message()
                            .map(|m| m.to_string())
                            .unwrap_or_else(|| e.to_string());
                        return ViewFunctionOutput::new_error_message(
                            message,
                            Some(vm_status.status_code()),
                            gas_used,
                        );
                    },
                }
                let txn_status = TransactionStatus::from_vm_status(
                    vm_status.clone(),
                    vm.features(),
                    vm.gas_feature_version() >= RELEASE_V1_38,
                );
                let execution_status = match txn_status {
                    TransactionStatus::Keep(status) => status,
                    _ => ExecutionStatus::MiscellaneousError(Some(vm_status.status_code())),
                };
                let status_with_abort_info = vm.inject_abort_info_if_available(
                    &module_storage,
                    &traversal_context,
                    &log_context,
                    execution_status,
                );
                ViewFunctionOutput::new_move_abort_error(
                    status_with_abort_info,
                    Some(vm_status.status_code()),
                    gas_used,
                )
            },
        }
```

**File:** api/src/view_function.rs (L163-172)
```rust
    let values = output.values.map_err(|status| {
        let (err_string, vm_error_code) =
            convert_view_function_error(&status, &state_view, &context);
        BasicErrorWith404::bad_request_with_optional_vm_status_and_ledger_info(
            anyhow::anyhow!(err_string),
            AptosErrorCode::InvalidInput,
            vm_error_code,
            Some(&ledger_info),
        )
    })?;
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L244-246)
```rust
    if types.len() != args.len() {
        return Err(invalid_signature());
    }
```
