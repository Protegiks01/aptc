# Audit Report

## Title
Missing Event Inclusion Verification in API Layer for Sharded Database Mode

## Summary
The API layer does not verify the integrity of events returned by IndexerReader implementations when serving account transactions in sharded database mode, allowing buggy implementations to break the atomic relationship between transactions and their emitted events.

## Finding Description

The `IndexerReader` trait defines a `get_account_ordered_transactions()` method that returns `AccountOrderedTransactionsWithProof`. [1](#0-0) 

This return type includes a documented `verify()` method that explicitly checks "Events are present when requested (and not present when not requested)" as stated in the method documentation. [2](#0-1) 

The verification implementation enforces this invariant with an explicit check. [3](#0-2) 

However, when the API layer retrieves account transactions in sharded database mode, it calls the IndexerReader's `get_account_ordered_transactions()` method but **never invokes the `verify()` method** on the returned data before using it. [4](#0-3) 

The unverified data is then converted to `TransactionOnChainData`, where events from the unverified `TransactionWithProof` are used directly via `unwrap_or_default()`. [5](#0-4) 

This means that if an IndexerReader implementation has a bug that causes it to:
1. Return `events: None` when `include_events=true`
2. Return events from a different transaction

The API will serve this incorrect data to clients without detection, breaking the atomic relationship between transactions and their emitted events.

In contrast, test code correctly demonstrates the expected pattern of calling `verify()` on the returned data. [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** per the bug bounty criteria ("State inconsistencies requiring intervention"). While the current DBIndexer implementation appears correct, the lack of verification violates defense-in-depth principles and creates risk in several scenarios:

1. **Software bugs** in the IndexerReader implementation could cause event omission or mismatching
2. **Database corruption** or race conditions could result in incorrect event data
3. **Future implementations** of the IndexerReader trait could introduce bugs
4. **DeFi protocol failures**: Applications relying on transaction-event atomicity would receive incorrect data, potentially causing protocol malfunctions or incorrect state transitions

The issue does not reach High Severity because it requires a software bug in a trusted component rather than being directly exploitable by an unprivileged attacker.

## Likelihood Explanation

**Likelihood: Medium**

While the current implementation appears correct, the likelihood is non-negligible because:
- The verification mechanism exists but is unused in production (inconsistency)
- Test code shows verification is expected, indicating awareness of the requirement
- Database sharding is a complex feature where bugs are more likely
- Future code changes could introduce bugs that would go undetected

## Recommendation

Add verification of the returned `AccountOrderedTransactionsWithProof` in the API layer before using the data:

```rust
let txns = txns_res
    .context("Failed to retrieve account transactions")
    .map_err(|err| {
        E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
    })?;

// Add verification before using the data
txns.verify(
    ledger_info,
    address,
    start_seq_number,
    limit as u64,
    true, // include_events
    ledger_version,
).context("Failed to verify account transactions")
.map_err(|err| {
    E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
})?;

txns.into_inner()
    .into_iter()
    // ... rest of the code
```

This ensures that any bug in the IndexerReader implementation will be caught before serving incorrect data to clients.

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability by creating a buggy IndexerReader
// that returns transactions without events when include_events=true

use aptos_types::{
    account_address::AccountAddress,
    indexer::indexer_db_reader::IndexerReader,
    transaction::{AccountOrderedTransactionsWithProof, TransactionWithProof, Version},
};

struct BuggyIndexerReader;

impl IndexerReader for BuggyIndexerReader {
    fn get_account_ordered_transactions(
        &self,
        _address: AccountAddress,
        _start_seq_num: u64,
        _limit: u64,
        include_events: bool, // This parameter is IGNORED
        _ledger_version: Version,
    ) -> anyhow::Result<AccountOrderedTransactionsWithProof> {
        // Bug: Always returns transactions with events=None
        // even when include_events=true
        let buggy_txn = TransactionWithProof {
            version: 100,
            transaction: /* ... */,
            events: None, // BUG: Should be Some(...) when include_events=true
            proof: /* ... */,
        };
        
        Ok(AccountOrderedTransactionsWithProof::new(vec![buggy_txn]))
    }
    
    // ... other trait methods
}

// If the API used this buggy implementation without calling verify(),
// it would serve transactions with missing events to clients,
// breaking DeFi protocols that rely on events for state tracking.
```

## Notes

While this is a legitimate defense-in-depth issue that should be fixed, it does not represent a directly exploitable vulnerability by an unprivileged external attacker, as IndexerReader implementations are configured at node startup from trusted code paths. The vulnerability manifests only through software bugs in trusted components or database corruption scenarios.

### Citations

**File:** types/src/indexer/indexer_db_reader.rs (L46-53)
```rust
    fn get_account_ordered_transactions(
        &self,
        address: AccountAddress,
        start_seq_num: u64,
        limit: u64,
        include_events: bool,
        ledger_version: Version,
    ) -> Result<AccountOrderedTransactionsWithProof>;
```

**File:** types/src/transaction/mod.rs (L2888-2893)
```rust
    /// 1. Verify all transactions are consistent with the given ledger info.
    /// 2. All transactions were sent by `account`.
    /// 3. The transactions are contiguous by sequence number, starting at `start_seq_num`.
    /// 4. No more transactions than limit.
    /// 5. Events are present when requested (and not present when not requested).
    /// 6. Transactions are not newer than requested ledger version.
```

**File:** types/src/transaction/mod.rs (L2917-2920)
```rust
                ensure!(
                    include_events == txn_with_proof.events.is_some(),
                    "unexpected events or missing events"
                );
```

**File:** api/src/context.rs (L909-929)
```rust
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Indexer reader is None"))
                .map_err(|err| {
                    E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
                })?
                .get_account_ordered_transactions(
                    address,
                    start_seq_number,
                    limit as u64,
                    true,
                    ledger_version,
                )
                .map_err(|e| AptosDbError::Other(e.to_string()))
        };
        let txns = txns_res
            .context("Failed to retrieve account transactions")
            .map_err(|err| {
                E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
            })?;
        txns.into_inner()
```

**File:** api/types/src/transaction.rs (L144-150)
```rust
        Self {
            version: txn.version,
            transaction: txn.transaction,
            info: txn.proof.transaction_info,
            events: txn.events.unwrap_or_default(),
            accumulator_root_hash,
            changes: txn_output.write_set().clone(),
```

**File:** storage/aptosdb/src/db/test_helper.rs (L684-693)
```rust
            acct_txns_with_proof
                .verify(
                    ledger_info,
                    account,
                    first_seq_num,
                    limit,
                    true,
                    ledger_info.version(),
                )
                .unwrap();
```
