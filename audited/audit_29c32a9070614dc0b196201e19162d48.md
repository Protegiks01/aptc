# Audit Report

## Title
Batch Version Fragmentation Attack: Malicious Validators Can Split Quorum Formation Across V1/V2 Batch Formats

## Summary
A malicious validator can exploit the dual v1/v2 batch info format system to prevent quorum formation by sending different format versions of the same batch to different validators, causing them to track incompatible proof aggregations that reject each other's signatures.

## Finding Description

The Aptos quorum store uses two batch info formats: the legacy `BatchInfo` (v1) and the new `BatchInfoExt` enum with V1/V2 variants. When validators receive signed batch info messages, they initialize proof aggregators based on the first message received. [1](#0-0) 

The critical vulnerability occurs because `BatchInfoExt::V1` and `BatchInfoExt::V2` are treated as **different HashMap keys** even when they represent the same underlying batch with identical digest, author, batch_id, and transaction payload. [2](#0-1) 

Both `Batch::new_v1()` and `Batch::new_v2()` compute the digest identically via `payload.hash()`, meaning a malicious validator can create two format variants of the same batch that pass local validation checks but are incompatible across the network. [3](#0-2) 

When signatures arrive, the comparison `signed_batch_info.batch_info() != &self.signature_aggregator.data()` rejects signatures from the wrong format variant, preventing cross-format signature aggregation.

**Attack Execution:**

1. Malicious validator (as batch author) creates identical batch content using both `Batch::new_v1()` and `Batch::new_v2()` with same transactions, batch_id, and epoch
2. Signs `BatchInfoExt::V1 { info }` and sends via `send_signed_batch_info_msg()` to validators {A, B, C}
3. Signs `BatchInfoExt::V2 { info, extra }` and sends via `send_signed_batch_info_msg_v2()` to validators {D, E, F}
4. Validators A,B,C initialize proof coordinator with `BatchSignatureAggregator::BatchInfo` 
5. Validators D,E,F initialize proof coordinator with `BatchSignatureAggregator::BatchInfoExt`
6. When honest validators broadcast their signatures, they are rejected by the opposite group due to format mismatch
7. Neither group can aggregate sufficient signatures to reach quorum threshold [4](#0-3) 

The network layer treats these as separate message types, allowing the attacker to target specific validators with specific format versions.

## Impact Explanation

**High Severity** - This vulnerability causes significant protocol violations:

- **Consensus Liveness Failure**: Prevents specific batches from reaching quorum, blocking transaction finalization
- **Selective Transaction Censorship**: Attacker can target specific transactions by preventing their batch from forming proof
- **Validator Resource Exhaustion**: Validators waste resources tracking and attempting to aggregate incompatible proof states
- **Network-Wide Inconsistency**: Different validators have divergent views of which batches have valid proofs

The attack breaks the critical invariant that "all validators must process identical blocks deterministically" by fragmenting the validator set into incompatible proof tracking states. While not a complete chain halt, it enables targeted censorship and violates AptosBFT safety assumptions.

Per Aptos bug bounty criteria, this qualifies as **High Severity** ($50,000 tier) due to:
- Significant protocol violations in consensus
- Validator node operational impact  
- Does not require >33% Byzantine validators, only a single malicious batch author

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Attacker must be a validator (to author batches)
- No special privileges beyond normal validator operations
- Trivial to execute - just requires sending two different message types
- No cryptographic breaking required
- Works during any v1/v2 transition period in the network

During migration periods where `enable_batch_v2` config varies across validators, this attack becomes particularly effective as the network naturally has validators expecting different formats. A sophisticated attacker could maximize impact by monitoring which validators use which format and strategically fragmenting the quorum. [5](#0-4) 

## Recommendation

**Immediate Fix**: Normalize batch info to a canonical format before using as HashMap key in proof coordinator.

```rust
// In proof_coordinator.rs, modify init_proof to use digest as key instead of full BatchInfoExt
fn init_proof(
    &mut self,
    signed_batch_info: &SignedBatchInfo<BatchInfoExt>,
) -> Result<(), SignedBatchInfoError> {
    // ... existing checks ...
    
    // Use digest as canonical key instead of BatchInfoExt variant
    let canonical_key = signed_batch_info.digest();
    
    if !self.batch_digest_to_proof.contains_key(canonical_key) {
        // Create aggregator based on local batch storage format, not incoming message
        let local_batch_info = self.batch_reader.get_batch_info(canonical_key)?;
        let aggregator = if local_batch_info.is_v2() {
            IncrementalProofState::new_batch_info_ext(local_batch_info)
        } else {
            IncrementalProofState::new_batch_info(local_batch_info.info().clone())
        };
        self.batch_digest_to_proof.insert(*canonical_key, aggregator);
    }
    
    // Normalize incoming signature to match local format before aggregating
    let normalized_signature = self.normalize_to_local_format(signed_batch_info)?;
    // ... continue with normalized signature ...
}
```

**Additional Hardening**:
1. Add version consistency checks when receiving batch messages - reject if same digest appears with different format variants
2. Enforce network-wide format consensus via on-chain governance before enabling v2
3. Add monitoring/alerting for proof aggregation failures due to format mismatches

## Proof of Concept

```rust
// Simplified PoC demonstrating the vulnerability
use aptos_consensus_types::proof_of_store::{BatchInfo, BatchInfoExt, BatchKind, SignedBatchInfo};
use aptos_types::validator_signer::ValidatorSigner;

fn exploit_batch_version_fragmentation() {
    let validator_signer = ValidatorSigner::random(None);
    let transactions = vec![/* same txns */];
    let batch_id = BatchId::new_random();
    
    // Create V1 version
    let batch_v1 = Batch::new_v1(
        batch_id,
        transactions.clone(),
        epoch,
        expiration,
        validator_signer.author(),
        gas_bucket_start,
    );
    
    // Create V2 version with SAME content
    let batch_v2 = Batch::new_v2(
        batch_id,
        transactions.clone(), // SAME transactions
        epoch,
        expiration,
        validator_signer.author(),
        gas_bucket_start,
        BatchKind::Normal,
    );
    
    // Both have same digest but different enum variants
    assert_eq!(batch_v1.digest(), batch_v2.digest()); // ✓ Same digest
    assert_ne!(batch_v1.batch_info(), batch_v2.batch_info()); // ✗ Different variants
    
    // Sign both versions
    let signed_v1 = SignedBatchInfo::new(batch_v1.batch_info().clone(), &validator_signer).unwrap();
    let signed_v2 = SignedBatchInfo::new(batch_v2.batch_info().clone(), &validator_signer).unwrap();
    
    // Send V1 to validators[0..3], V2 to validators[3..6]
    network_sender.send_signed_batch_info_msg(vec![signed_v1], validators[0..3].to_vec()).await;
    network_sender.send_signed_batch_info_msg_v2(vec![signed_v2], validators[3..6].to_vec()).await;
    
    // Result: Validators split into incompatible proof aggregation groups
    // Neither group can reach quorum threshold
}
```

**Expected Outcome**: Validators receiving v1 messages reject v2 signatures and vice versa, preventing proof formation despite having sufficient total signatures network-wide.

---

**Notes**

This vulnerability specifically exploits the transition period where both v1 and v2 batch formats coexist. The root cause is that `BatchInfoExt` enum variants are used directly as HashMap keys without normalization to a format-agnostic canonical representation. The attack becomes trivial during network upgrades when validators have mixed `enable_batch_v2` configurations, allowing natural exploitation of the version fragmentation without requiring sophisticated coordination.

### Citations

**File:** consensus/src/quorum_store/proof_coordinator.rs (L145-155)
```rust
    fn add_signature(
        &mut self,
        signed_batch_info: &SignedBatchInfo<BatchInfoExt>,
        validator_verifier: &ValidatorVerifier,
    ) -> Result<(), SignedBatchInfoError> {
        if signed_batch_info.batch_info() != &self.signature_aggregator.data() {
            return Err(SignedBatchInfoError::WrongInfo((
                signed_batch_info.batch_info().batch_id().id,
                self.signature_aggregator.data().batch_id().id,
            )));
        }
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L289-301)
```rust
        if signed_batch_info.batch_info().is_v2() {
            self.batch_info_to_proof.insert(
                signed_batch_info.batch_info().clone(),
                IncrementalProofState::new_batch_info_ext(signed_batch_info.batch_info().clone()),
            );
        } else {
            self.batch_info_to_proof.insert(
                signed_batch_info.batch_info().clone(),
                IncrementalProofState::new_batch_info(
                    signed_batch_info.batch_info().info().clone(),
                ),
            );
        }
```

**File:** consensus/src/quorum_store/types.rs (L207-251)
```rust
    pub fn new_v2(
        batch_id: BatchId,
        payload: Vec<SignedTransaction>,
        epoch: u64,
        expiration: u64,
        batch_author: PeerId,
        gas_bucket_start: u64,
        batch_kind: BatchKind,
    ) -> Self {
        let payload = BatchPayload::new(batch_author, payload);
        let batch_info = BatchInfoExt::new_v2(
            batch_author,
            batch_id,
            epoch,
            expiration,
            payload.hash(),
            payload.num_txns() as u64,
            payload.num_bytes() as u64,
            gas_bucket_start,
            batch_kind,
        );
        Self::new_generic(batch_info, payload)
    }

    pub fn new_v1(
        batch_id: BatchId,
        payload: Vec<SignedTransaction>,
        epoch: u64,
        expiration: u64,
        batch_author: PeerId,
        gas_bucket_start: u64,
    ) -> Self {
        let payload = BatchPayload::new(batch_author, payload);
        let batch_info = BatchInfoExt::new_v1(
            batch_author,
            batch_id,
            epoch,
            expiration,
            payload.hash(),
            payload.num_txns() as u64,
            payload.num_bytes() as u64,
            gas_bucket_start,
        );
        Self::new_generic(batch_info, payload)
    }
```

**File:** consensus/src/network.rs (L588-609)
```rust
    async fn send_signed_batch_info_msg(
        &self,
        signed_batch_infos: Vec<SignedBatchInfo<BatchInfo>>,
        recipients: Vec<Author>,
    ) {
        fail_point!("consensus::send::signed_batch_info", |_| ());
        let msg =
            ConsensusMsg::SignedBatchInfo(Box::new(SignedBatchInfoMsg::new(signed_batch_infos)));
        self.send(msg, recipients).await
    }

    async fn send_signed_batch_info_msg_v2(
        &self,
        signed_batch_infos: Vec<SignedBatchInfo<BatchInfoExt>>,
        recipients: Vec<Author>,
    ) {
        fail_point!("consensus::send::signed_batch_info", |_| ());
        let msg = ConsensusMsg::SignedBatchInfoMsgV2(Box::new(SignedBatchInfoMsg::new(
            signed_batch_infos,
        )));
        self.send(msg, recipients).await
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-210)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
        } else {
            Batch::new_v1(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
            )
```
