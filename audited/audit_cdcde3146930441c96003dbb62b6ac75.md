# Audit Report

## Title
Vault Authentication Token Leakage via Inspection Service Debug Formatting

## Summary
The `Token` enum in `SecureBackend` configuration derives `Debug` without credential protection, causing Vault authentication tokens to be exposed in plaintext when the inspection service's configuration endpoint is queried. This leaks authentication credentials that provide access to Vaults where consensus private keys may be stored.

## Finding Description

The inspection service's `handle_configuration_request()` function uses Debug formatting to serialize the entire NodeConfig: [1](#0-0) 

The code comment explicitly states that "all secret keys are marked with SilentDisplay and SilentDebug" to prevent leakage. Cryptographic private keys properly implement this protection through the `SilentDebug` derive macro: [2](#0-1) 

However, the `Token` enum used for Vault authentication **derives Debug without any protection**: [3](#0-2) 

This enum is contained within `VaultConfig`: [4](#0-3) 

The attack chain follows the Debug derivation path: NodeConfig → ConsensusConfig → SafetyRulesConfig → SecureBackend → VaultConfig → Token [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

When `Token::FromConfig(String)` is used, the plaintext token string is exposed in Debug output.

The codebase demonstrates awareness of this credential protection pattern. `IndexerConfig` implements a **custom Debug** trait to redact database passwords: [9](#0-8) 

However, this same protection was not applied to the `Token` enum, creating an inconsistent security posture.

**Exploitation Scenario:**

On testnet/devnet, `expose_configuration` is enabled by default through the ConfigOptimizer: [10](#0-9) 

An attacker can:
1. Make HTTP request to `http://<node>:9101/configuration`
2. Receive Debug-formatted NodeConfig containing plaintext Vault tokens
3. Use the token to authenticate to the Vault server (if network-accessible)
4. Retrieve consensus private keys stored in Vault
5. Use keys to sign malicious blocks or perform double-signing attacks

Mainnet validators are protected by a sanitizer: [11](#0-10) 

However, the vulnerability affects:
- All testnet/devnet validators (enabled by default)
- Mainnet fullnodes (if manually misconfigured)
- Development/testing environments

## Impact Explanation

**Severity: MEDIUM to HIGH**

1. **Credential Exposure**: Vault tokens are authentication credentials. The `Token::FromConfig` variant stores plaintext tokens that are exposed via Debug formatting, violating the principle established by `SilentDebug` for other sensitive keys.

2. **Potential Consensus Key Compromise**: If an attacker obtains a Vault token AND can reach the Vault server, they can retrieve consensus private keys, potentially enabling double-signing attacks or malicious block signing.

3. **Defense-in-Depth Violation**: While mainnet validators are protected by the sanitizer, the `Token` type itself should follow the same secure-by-default pattern as cryptographic keys using `SilentDebug`.

4. **Testnet/Devnet Impact**: The vulnerability is immediately exploitable on testnet/devnet where `expose_configuration` is enabled by default. While these environments have lower security requirements, they often test production credential management practices.

Per Aptos bug bounty criteria, this falls under **HIGH severity** ($50,000) as "significant protocol violations" - credential leakage that could enable consensus compromise if environmental conditions (Vault accessibility) are met.

## Likelihood Explanation

**Likelihood varies by deployment:**

1. **Testnet/Devnet**: HIGH - `expose_configuration` is automatically enabled by the ConfigOptimizer for non-mainnet chains, making token exposure occur without any operator misconfiguration.

2. **Mainnet Validators**: N/A - Protected by ConfigSanitizer which rejects configurations with `expose_configuration` enabled.

3. **Mainnet Fullnodes**: LOW to MEDIUM - Only affected if operator manually enables `expose_configuration`, which would be a misconfiguration.

4. **Preconditions for full exploit**: Requires Vault to be network-accessible from attacker's position and consensus keys to be stored in that Vault.

## Recommendation

Implement credential protection for the `Token` enum using one of two approaches:

**Option 1: Custom Debug Implementation (consistent with IndexerConfig)**
```rust
impl std::fmt::Debug for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::FromConfig(_) => f.debug_tuple("FromConfig").field(&"<redacted>").finish(),
            Token::FromDisk(path) => f.debug_tuple("FromDisk").field(path).finish(),
        }
    }
}
```

**Option 2: Use SilentDebug pattern**
Apply the same `SilentDebug` derive macro pattern used for cryptographic keys, if the macro can be extended to support non-key types.

Additionally, consider:
- Audit other configuration types that may contain credentials
- Document the security requirement that all credential fields must override Debug formatting
- Add compile-time or runtime checks to detect Debug-derived types containing credential fields

## Proof of Concept

On a testnet/devnet node with Vault backend configured:

```bash
# Query the configuration endpoint
curl http://testnet-validator:9101/configuration

# Response will contain Debug output including:
# SafetyRulesConfig { 
#   backend: Vault(VaultConfig { 
#     token: FromConfig("hvs.CAESIxxxxxxxxxxxxxx"),  # <-- Plaintext token exposed
#     ...
#   })
# }
```

The token can then be used to authenticate to the Vault server if network-accessible:

```bash
curl -H "X-Vault-Token: hvs.CAESIxxxxxxxxxxxxxx" \
  https://vault-server:8200/v1/secret/data/consensus-key
```

## Notes

This vulnerability represents a **defense-in-depth failure** rather than a direct mainnet exploit, as:
1. Mainnet validators are protected by the ConfigSanitizer
2. Complete exploitation requires Vault network accessibility
3. Testnet/devnet environments have inherently lower security requirements

However, the inconsistency with the codebase's established security pattern (cryptographic keys use `SilentDebug`, but Vault tokens don't) represents a genuine security gap that should be addressed to prevent future misconfiguration risks and maintain secure-by-default principles across all credential types.

### Citations

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L16-19)
```rust
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This file implements traits for Ed25519 private keys and public keys.

#[cfg(any(test, feature = "fuzzing"))]
use crate::test_utils::{self, KeyPair};
use crate::{
    ed25519::{Ed25519Signature, ED25519_PRIVATE_KEY_LENGTH, ED25519_PUBLIC_KEY_LENGTH},
    hash::CryptoHash,
    traits::*,
};
use aptos_crypto_derive::{DeserializeKey, SerializeKey, SilentDebug, SilentDisplay};
use core::convert::TryFrom;
use curve25519_dalek::{edwards::CompressedEdwardsY, scalar::Scalar};
use ed25519_dalek::ExpandedSecretKey;
#[cfg(any(test, feature = "fuzzing"))]
use proptest::prelude::*;
use serde::Serialize;
use std::fmt;

/// An Ed25519 private key
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);

#[cfg(feature = "assert-private-keys-not-cloneable")]
static_assertions::assert_not_impl_any!(Ed25519PrivateKey: Clone);

#[cfg(any(test, feature = "cloneable-private-keys"))]
impl Clone for Ed25519PrivateKey {
    fn clone(&self) -> Self {
        let serialized: &[u8] = &(self.to_bytes());
        Ed25519PrivateKey::try_from(serialized).unwrap()
    }
}

/// An Ed25519 public key
#[derive(DeserializeKey, Clone, SerializeKey)]
pub struct Ed25519PublicKey(pub(crate) ed25519_dalek::PublicKey);

#[cfg(any(test, feature = "fuzzing"))]
impl<'a> arbitrary::Arbitrary<'a> for Ed25519PublicKey {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let bytes: [u8; ED25519_PUBLIC_KEY_LENGTH] = u.arbitrary()?;
        Ed25519PublicKey::from_bytes_unchecked(&bytes)
            .map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

impl Ed25519PrivateKey {
```

**File:** config/src/config/secure_backend_config.rs (L16-22)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum SecureBackend {
    InMemoryStorage,
    Vault(VaultConfig),
    OnDiskStorage(OnDiskStorageConfig),
}
```

**File:** config/src/config/secure_backend_config.rs (L51-74)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
    /// Disable check-and-set when writing secrets to Vault
    pub disable_cas: Option<bool>,
    /// Timeout for new vault socket connections, in milliseconds.
    pub connection_timeout_ms: Option<u64>,
    /// Timeout for generic vault operations (e.g., reads and writes), in milliseconds.
    pub response_timeout_ms: Option<u64>,
}
```

**File:** config/src/config/secure_backend_config.rs (L100-106)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** config/src/config/node_config.rs (L45-45)
```rust
    pub consensus: ConsensusConfig,
```

**File:** config/src/config/consensus_config.rs (L51-51)
```rust
    pub safety_rules: SafetyRulesConfig,
```

**File:** config/src/config/safety_rules_config.rs (L26-26)
```rust
    pub backend: SecureBackend,
```

**File:** config/src/config/indexer_config.rs (L95-99)
```rust
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
```

**File:** config/src/config/inspection_service_config.rs (L54-64)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
```

**File:** config/src/config/inspection_service_config.rs (L84-88)
```rust
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }
```
