# Audit Report

## Title
Missing Ed25519 Curve Point Validation in Authentication Key Rotation Causes Permanent Account Lockout

## Summary
The `rotate_authentication_key_from_public_key` function in the Aptos Framework allows account owners to rotate their authentication keys to arbitrary byte sequences without validating that they represent valid Ed25519 curve points. This creates a permanent account lockout vulnerability where users can accidentally (or be tricked into) rotating to invalid public keys, rendering their accounts permanently inaccessible.

## Finding Description

The vulnerability exists in the Move framework's account management system. When an account owner calls `rotate_authentication_key_from_public_key`, the function accepts public key bytes and directly derives an authentication key without validating that the bytes represent a valid point on the Ed25519 curve. [1](#0-0) 

The function uses `ed25519::new_unvalidated_public_key_from_bytes` which only validates length (32 bytes), not curve validity: [2](#0-1) 

The documentation explicitly promises validation that doesn't exist - line 465 states: "This function will abort if the scheme is not recognized or if new_public_key_bytes is not a valid public key for the given scheme." However, no such validation occurs.

**Attack Flow:**
1. Account owner (or compromised wallet) calls `rotate_authentication_key_from_public_key` with invalid public key bytes (e.g., all zeros, random bytes, or a small-order point)
2. The authentication key updates to `SHA3-256(invalid_bytes || 0x00)`
3. All future transactions fail because signature verification validates the public key and rejects invalid curve points: [3](#0-2) 

4. Account becomes permanently locked - cannot rotate back because the current (invalid) private key doesn't exist

This violates the **Cryptographic Correctness** invariant (#10) which requires secure cryptographic operations, and the **Transaction Validation** invariant (#7) which requires proper signature verification.

## Impact Explanation

**Severity: High (up to $50,000)**

This vulnerability causes "Significant protocol violations" and can lead to permanent loss of account access, meeting High severity criteria. While it doesn't directly cause consensus violations, the impact is severe:

1. **Permanent Account Lockout**: Once rotated to invalid bytes, the account cannot be recovered without hard fork intervention
2. **Loss of Access to Funds**: Any tokens, NFTs, or assets held by the locked account become inaccessible
3. **Governance Impact**: If the locked account holds voting power or is a validator, this disrupts governance and consensus participation
4. **No Recovery Mechanism**: Unlike normal key rotation which requires proof-of-knowledge, this function bypasses safeguards

The vulnerability could also qualify as **Medium severity** ("State inconsistencies requiring intervention") as locked accounts create permanent on-chain state that cannot be fixed through normal operations.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through multiple realistic scenarios:

1. **User Error**: Users may accidentally provide invalid bytes (wrong format, typo, incorrect key derivation)
2. **Compromised Wallet Software**: Malicious or buggy wallet implementations could intentionally or accidentally provide invalid public keys
3. **Social Engineering**: Attackers could trick users into calling this function with crafted invalid bytes
4. **Integration Bugs**: Third-party applications integrating with Aptos may have bugs that generate invalid public keys

The function is marked as `entry fun`, making it directly callable from transactions. The comment at lines 454-456 indicates it's intentionally designed for "non-standard key algorithms, such as passkeys," which suggests active usage.

## Recommendation

Add explicit public key validation before deriving the authentication key. The validation should check that the bytes represent a valid Ed25519 curve point and are not in a small subgroup.

**Fix for account.move:**

```move
entry fun rotate_authentication_key_from_public_key(account: &signer, scheme: u8, new_public_key_bytes: vector<u8>) acquires Account {
    let addr = signer::address_of(account);
    let account_resource = &Account[addr];
    let old_auth_key = account_resource.authentication_key;
    let new_auth_key;
    if (scheme == ED25519_SCHEME) {
        // ADDED: Validate the public key before using it
        let validated_pk_opt = ed25519::new_validated_public_key_from_bytes(new_public_key_bytes);
        assert!(validated_pk_opt.is_some(), error::invalid_argument(EINVALID_PUBLIC_KEY));
        let validated_pk = validated_pk_opt.extract();
        new_auth_key = ed25519::validated_public_key_to_authentication_key(&validated_pk);
    } else if (scheme == MULTI_ED25519_SCHEME) {
        // Similar validation for multi_ed25519
        // ... rest of the code
    }
    // ... rest of function
}
```

The `new_validated_public_key_from_bytes` function already exists and performs the necessary validation: [4](#0-3) 

The native implementation checks both points-on-curve and small-subgroup requirements: [5](#0-4) 

## Proof of Concept

```move
#[test(account = @0x1234)]
#[expected_failure(abort_code = 0x10001, location = aptos_framework::account)]
fun test_rotate_to_invalid_ed25519_key(account: &signer) {
    use aptos_framework::account;
    
    // Create test account
    account::create_account_for_test(signer::address_of(account));
    
    // Attempt to rotate to all-zero bytes (invalid Ed25519 public key)
    let invalid_pk_bytes = vector::empty<u8>();
    let i = 0;
    while (i < 32) {
        vector::push_back(&mut invalid_pk_bytes, 0u8);
        i = i + 1;
    };
    
    // This should abort but currently doesn't - demonstrating the vulnerability
    account::rotate_authentication_key_from_public_key(
        account,
        0, // ED25519_SCHEME
        invalid_pk_bytes
    );
    
    // If we reach here, the account has been rotated to an invalid key
    // and is now permanently locked (cannot sign future transactions)
}
```

**Notes:**
- The referenced benchmark file `aptos-core/crates/aptos-crypto/benches/ed25519.rs` does not exist in the codebase, but the vulnerability is confirmed in the production code paths
- The Rust-level deserialization explicitly documents its lack of validation as intentional for performance
- The vulnerability manifests at the Move framework level where validation should occur before state changes

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L468-496)
```text
    entry fun rotate_authentication_key_from_public_key(account: &signer, scheme: u8, new_public_key_bytes: vector<u8>) acquires Account {
        let addr = signer::address_of(account);
        let account_resource = &Account[addr];
        let old_auth_key = account_resource.authentication_key;
        let new_auth_key;
        if (scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == SINGLE_KEY_SCHEME) {
            new_auth_key = single_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else if (scheme == MULTI_KEY_SCHEME) {
            new_auth_key = multi_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else {
            abort error::invalid_argument(EUNRECOGNIZED_SCHEME)
        };
        rotate_authentication_key_call(account, new_auth_key);
        event::emit(KeyRotationToPublicKey {
            account: addr,
            // Set verified_public_key_bit_map to [0x00, 0x00, 0x00, 0x00] as the public key(s) are not verified
            verified_public_key_bit_map: vector[0x00, 0x00, 0x00, 0x00],
            public_key_scheme: scheme,
            public_key: new_public_key_bytes,
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L73-76)
```text
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        assert!(bytes.length() == PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L79-87)
```text
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        if (public_key_validate_internal(bytes)) {
            option::some(ValidatedPublicKey {
                bytes
            })
        } else {
            option::none<ValidatedPublicKey>()
        }
    }
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L67-82)
```rust
    // This deserialization only performs point-on-curve checks, so we check for small subgroup below
    // NOTE(Gas): O(1) cost: some arithmetic for converting to (X, Y, Z, T) coordinates
    let point = match CompressedEdwardsY(key_bytes_slice).decompress() {
        Some(point) => point,
        None => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    // Check if the point lies on a small subgroup. This is required when using curves with a
    // small cofactor (e.g., in Ed25519, cofactor = 8).
    // NOTE(Gas): O(1) cost: multiplies the point by the cofactor
    context.charge(ED25519_PER_PUBKEY_SMALL_ORDER_CHECK * NumArgs::one())?;
    let valid = !point.is_small_order();

    Ok(smallvec![Value::bool(valid)])
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L214-224)
```rust

```
