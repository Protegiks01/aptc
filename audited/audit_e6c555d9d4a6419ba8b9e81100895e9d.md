# Audit Report

## Title
Mainnet Validator Identity Information Exposure via Missing Configuration Sanitizer Check

## Summary
The `InspectionServiceConfig` sanitizer fails to validate `expose_identity_information` for mainnet validators, while it correctly validates `expose_configuration`. This asymmetry allows testnet configurations with identity exposure enabled to migrate to mainnet without warnings, exposing validator network peer IDs through the `/identity_information` HTTP endpoint.

## Finding Description
The configuration sanitization logic contains an inconsistency that creates a configuration migration vulnerability: [1](#0-0) 

The sanitizer only checks if mainnet validators have `expose_configuration` enabled, but performs no equivalent check for `expose_identity_information`. Meanwhile, the ConfigOptimizer automatically enables identity information exposure for non-mainnet chains: [2](#0-1) 

When enabled, the inspection service exposes validator network peer IDs through an HTTP endpoint: [3](#0-2) [4](#0-3) 

**Attack Scenario:**
1. Operator creates testnet validator configuration file with `expose_identity_information: true` (either explicitly or via optimizer defaults)
2. Operator migrates to mainnet by updating genesis.blob but reusing the same config file
3. Node starts on mainnet - sanitizer passes because it only checks `expose_configuration`
4. Mainnet validator exposes peer IDs at `http://<validator-ip>:9101/identity_information`
5. Attackers can enumerate validator peer IDs for reconnaissance and targeted attacks

The inspection service runs on a separate HTTP port and serves these endpoints: [5](#0-4) 

## Impact Explanation
This qualifies as **Medium severity** per Aptos bug bounty criteria under "Minor information leaks." Exposed peer IDs enable:
- Network topology mapping and validator identification
- Targeted DDoS attacks against specific validators
- Enhanced reconnaissance for sophisticated attacks
- Privacy violations for validator operators

While this doesn't directly cause consensus violations or funds loss, it expands the attack surface for mainnet validators who should maintain operational security.

## Likelihood Explanation
This vulnerability has **high likelihood** because:
- Testnet-to-mainnet migration is a common operational workflow
- ConfigOptimizer defaults enable the exposure for non-mainnet, making it easy for operators to unknowingly persist this setting
- No warning or error prevents the configuration from being used on mainnet
- Operators focusing on critical settings (keys, genesis) may overlook inspection service configuration
- The inconsistency between checking `expose_configuration` but not `expose_identity_information` suggests this gap was unintentional

## Recommendation
Add a sanitizer check for `expose_identity_information` matching the existing `expose_configuration` validation:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                // Verify that mainnet validators do not expose the configuration
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // ADD THIS CHECK: Verify that mainnet validators do not expose identity information
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, update the default value to be more conservative:
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // Changed from true to false
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_sanitize_mainnet_identity_exposure() {
    use aptos_config::config::{InspectionServiceConfig, NodeConfig};
    use aptos_config::config::config_sanitizer::ConfigSanitizer;
    use aptos_config::config::node_config_loader::NodeType;
    use aptos_types::chain_id::ChainId;

    // Create a mainnet validator config with identity information exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_configuration: false,
            expose_identity_information: true, // This should fail sanitization!
            ..Default::default()
        },
        ..Default::default()
    };

    // Attempt to sanitize - this currently PASSES but should FAIL
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // Current behavior: passes (vulnerability exists)
    assert!(result.is_ok()); // This demonstrates the bug
    
    // Expected behavior after fix: should fail
    // assert!(result.is_err());
    // assert!(matches!(result.unwrap_err(), Error::ConfigSanitizerFailed(_, _)));
}
```

This test demonstrates that mainnet validators can currently enable `expose_identity_information` without triggering sanitizer errors, confirming the configuration gap.

### Citations

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-52)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L127-131)
```rust
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
```
