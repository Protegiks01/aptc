# Audit Report

## Title
Stream State Machine Vulnerability: Duplicate Headers Cause Message Loss via Premature State Replacement

## Summary
The `InboundStreamBuffer::new_stream()` method in the network streaming protocol contains a state machine flaw where it replaces an existing in-progress stream before checking whether replacement should be allowed. This allows an attacker to send duplicate headers with the same `request_id`, causing partial message loss and enabling potential message injection attacks.

## Finding Description

The vulnerability exists in the `new_stream()` method where the code performs a state mutation (replacing the current stream) before validating whether this operation should be permitted. [1](#0-0) 

The critical flaw is at line 84 where `self.stream.replace(inbound_stream)` executes unconditionally. The `Option::replace()` method immediately replaces the current value and returns the old value. Only after this replacement does the code check if an old stream existed and return an error via `bail!()` at line 85.

This violates the expected state machine invariant: **a stream should not be replaced while in progress**. The check happens after the mutation, creating a time-of-check-to-time-of-use (TOCTOU) anti-pattern.

**Attack Scenario:**

1. Attacker sends `Header(request_id=1, num_fragments=3, message=ConsensusVote)`
2. Victim node creates an inbound stream and begins receiving fragments
3. Victim receives `Fragment(request_id=1, fragment_id=1)` - stored successfully
4. Victim receives `Fragment(request_id=1, fragment_id=2)` - stored successfully  
5. **Attacker sends malicious duplicate: `Header(request_id=1, num_fragments=1, message=MaliciousData)`**
6. Victim calls `new_stream()`:
   - Line 83: Creates new stream with malicious header
   - Line 84: `replace()` **immediately discards** the old stream with 2 fragments
   - Line 85-88: Returns error "Discarding existing stream for request ID: 1"
7. Error propagates to the peer event loop [2](#0-1) [3](#0-2) 

The error is caught and logged but **the connection continues**. The original consensus message is permanently lost, and the malicious stream is now active. The attacker can complete this new stream with arbitrary data or send another duplicate header to cause continuous disruption.

This breaks the network message delivery guarantee. In Aptos's validator network, large messages (consensus blocks, vote bundles, state sync chunks) use this streaming protocol. Message loss or replacement can cause:

- **Consensus liveness degradation**: Lost consensus messages require retransmission
- **State synchronization failures**: Corrupted state sync chunks  
- **Denial of Service**: Repeated replacements prevent any large message from completing
- **Potential message injection**: If the attacker can predict timing, they might inject malicious content

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: Message loss causes nodes to have incomplete data, requiring retransmission mechanisms to recover
- **Limited protocol violations**: While it doesn't directly break consensus safety, it affects network reliability which consensus depends on
- **Network disruption**: Attackers can repeatedly disrupt large message transfers between validators

The vulnerability doesn't reach High/Critical severity because:
- It doesn't directly violate consensus safety (requires 2/3 honest validators)
- No direct fund loss or validator compromise
- Retransmission mechanisms may eventually recover lost messages
- Requires active attack, doesn't occur automatically

However, it's above Low severity because:
- Real impact on network operations (not just information leak)
- Exploitable by any malicious peer without special privileges
- Can cause measurable disruption to validator communication
- Affects critical consensus message delivery

## Likelihood Explanation

**High likelihood of exploitation:**

- **No authentication required**: Any peer that successfully connects to a validator can send malicious stream headers
- **Simple attack vector**: Attacker only needs to observe legitimate headers (or guess request IDs) and send duplicates
- **No special timing**: Attack works at any point during stream reception
- **Repeatable**: Can be executed continuously for sustained DoS
- **Detection difficulty**: Errors are logged but might be dismissed as network issues

**Attack requirements:**
- Network connection to target validator (standard P2P connection)
- Ability to send `StreamMessage::Header` with duplicate request_id
- No validator keys or special permissions needed

**Limiting factors:**
- Request IDs are generated by the sender, so attacker needs to observe or predict them
- Some retransmission logic may mitigate impact
- Network layer may have rate limiting (not verified in this code)

## Recommendation

**Fix: Check before replacing, not after**

The state validation must occur before any state mutation. Modify `new_stream()` to check for an existing stream first:

```rust
pub fn new_stream(&mut self, header: StreamHeader) -> anyhow::Result<()> {
    // Check if a stream already exists BEFORE creating/replacing
    if self.stream.is_some() {
        bail!(
            "Cannot start new stream: existing stream in progress for request ID {}",
            self.stream.as_ref().unwrap().request_id
        )
    }
    
    // Only create and set the stream if validation passed
    let inbound_stream = InboundStream::new(header, self.max_fragments)?;
    self.stream = Some(inbound_stream);
    Ok(())
}
```

**Additional hardening recommendations:**

1. **Add request_id validation**: Track recently used request IDs to detect duplicates
2. **Connection penalty**: Consider disconnecting peers that send duplicate headers (malicious behavior)
3. **Monitoring**: Add metrics for stream replacement errors to detect attacks
4. **Defense in depth**: Add sequence numbers or nonces to stream headers to make prediction harder

## Proof of Concept

```rust
#[cfg(test)]
mod security_test {
    use super::*;
    use crate::protocols::wire::messaging::v1::{DirectSendMsg, NetworkMessage};
    use crate::protocols::wire::handshake::v1::ProtocolId::ConsensusRpcBcs;

    #[test]
    fn test_duplicate_header_causes_message_loss() {
        // Setup
        let max_fragments = 10;
        let mut buffer = InboundStreamBuffer::new(max_fragments);
        
        // Attacker sends first header
        let header1 = StreamHeader {
            request_id: 42,
            num_fragments: 3,
            message: NetworkMessage::DirectSendMsg(DirectSendMsg {
                protocol_id: ConsensusRpcBcs,
                priority: 0,
                raw_msg: vec![1, 2, 3], // Legitimate consensus data
            }),
        };
        assert!(buffer.new_stream(header1).is_ok());
        
        // Victim receives first fragment
        let frag1 = StreamFragment {
            request_id: 42,
            fragment_id: 1,
            raw_data: vec![4, 5, 6],
        };
        assert!(buffer.append_fragment(frag1).unwrap().is_none());
        
        // Victim receives second fragment  
        let frag2 = StreamFragment {
            request_id: 42,
            fragment_id: 2,
            raw_data: vec![7, 8, 9],
        };
        assert!(buffer.append_fragment(frag2).unwrap().is_none());
        
        // ATTACK: Attacker sends duplicate header with SAME request_id
        let malicious_header = StreamHeader {
            request_id: 42, // Same request_id!
            num_fragments: 1,
            message: NetworkMessage::DirectSendMsg(DirectSendMsg {
                protocol_id: ConsensusRpcBcs,
                priority: 0,
                raw_msg: vec![99, 99, 99], // Malicious data
            }),
        };
        
        // new_stream() returns an error BUT the stream is already replaced
        let result = buffer.new_stream(malicious_header);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Discarding existing stream"));
        
        // BUG: The original stream with 2 fragments is LOST
        // The new malicious stream is now active
        
        // Attacker can complete the malicious stream
        let malicious_frag = StreamFragment {
            request_id: 42,
            fragment_id: 1,
            raw_data: vec![88, 88, 88],
        };
        
        // This succeeds because the NEW stream is in place
        let completed = buffer.append_fragment(malicious_frag);
        assert!(completed.is_ok());
        
        // The completed message contains MALICIOUS data, not the original
        let final_msg = completed.unwrap().unwrap();
        if let NetworkMessage::DirectSendMsg(msg) = final_msg {
            // Original message had [1,2,3] + [4,5,6] + [7,8,9]
            // But we got [99,99,99] + [88,88,88] instead
            assert_eq!(msg.raw_msg[0], 99); // Malicious header data
            println!("VULNERABILITY CONFIRMED: Original message lost, malicious message accepted");
        }
    }
}
```

**Notes**

This vulnerability demonstrates a classic state machine error where validation occurs after mutation. The issue is particularly concerning in Aptos because the network layer is critical for consensus operation. While Byzantine fault tolerance provides resilience against malicious validators, this bug allows external attackers (not validators) to disrupt network message delivery between honest validators, potentially affecting liveness.

The fix is straightforward and should be applied immediately. The existing test at line 367 validates that `new_stream()` returns an error for duplicates, but it doesn't verify that the state remains consistent after the errorâ€”a critical oversight that this audit has identified.

### Citations

**File:** network/framework/src/protocols/stream/mod.rs (L82-92)
```rust
    pub fn new_stream(&mut self, header: StreamHeader) -> anyhow::Result<()> {
        let inbound_stream = InboundStream::new(header, self.max_fragments)?;
        if let Some(old) = self.stream.replace(inbound_stream) {
            bail!(
                "Discarding existing stream for request ID: {}",
                old.request_id
            )
        } else {
            Ok(())
        }
    }
```

**File:** network/framework/src/peer/mod.rs (L255-265)
```rust
                            if let Err(err) = self.handle_inbound_message(message, &mut write_reqs_tx) {
                                warn!(
                                    NetworkSchema::new(&self.network_context)
                                        .connection_metadata(&self.connection_metadata),
                                    error = %err,
                                    "{} Error in handling inbound message from peer: {}, error: {}",
                                    self.network_context,
                                    remote_peer_id.short_str(),
                                    err
                                );
                            }
```

**File:** network/framework/src/peer/mod.rs (L549-549)
```rust
                self.inbound_stream.new_stream(header)?;
```
