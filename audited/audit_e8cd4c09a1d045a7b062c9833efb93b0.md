# Audit Report

## Title
BCS Transaction API Bypass Allows Mempool Pollution via Out-of-Order Sequence Numbers

## Summary
The Aptos API does not validate sequence numbers for BCS-encoded transactions, allowing attackers to submit transactions with arbitrarily high sequence numbers that bypass API-level checks but are accepted into mempool despite being unexecutable. This causes mempool pollution and potential denial-of-service.

## Finding Description

The vulnerability exists in the transaction submission flow where BCS-encoded transactions skip sequence number validation at the API layer, enabling attackers to pollute the mempool with unexecutable transactions.

**Attack Flow:**

1. **API Layer - No Validation**: When BCS transactions are submitted via the `/transactions` endpoint, the `verify()` method for `SubmitTransactionPost::Bcs` returns `Ok(())` without performing any validation. [1](#0-0) 

2. **Mempool Pre-filtering - Insufficient Check**: In `process_incoming_transactions`, mempool fetches the account's current sequence number and filters transactions where `txn_sequence_number < account_sequence_number`. However, it accepts transactions where `txn_sequence_number >= account_sequence_number`, including far-future transactions (e.g., seq 1000 when account seq is 5). [2](#0-1) 

3. **VM Validation - Intentional Acceptance**: The VM validator executes the Move prologue which checks that `txn_sequence_number == account_sequence_number`. If this fails, it returns `PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW`. [3](#0-2) 

4. **Critical Design Flaw**: In `validate_transaction`, when the prologue returns `SEQUENCE_NUMBER_TOO_NEW`, it is explicitly treated as **success** rather than failure, allowing the transaction into mempool. [4](#0-3) 

5. **Mempool Pollution**: The transaction is inserted into mempool (up to 100 per account per `capacity_per_user`). [5](#0-4) 

6. **Consensus Rejection**: When consensus requests transactions via `get_batch`, it only pulls transactions where `account_sequence_number == txn_seq`, skipping all future transactions. [6](#0-5) 

**Result**: Transactions with far-future sequence numbers occupy mempool slots for up to 600 seconds (system_transaction_timeout_secs) without ever being executable, causing resource exhaustion. [7](#0-6) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

- **Mempool Resource Exhaustion**: Attackers can consume mempool capacity (default: 2,000,000 transactions, 2GB) by submitting up to 100 future transactions per account across multiple accounts
- **Denial of Service**: When mempool reaches capacity, it returns `MempoolIsFull` errors, blocking legitimate transactions from entering the system [8](#0-7) 
- **State Inconsistency**: The mempool contains transactions that will never execute (unless the user's sequence number miraculously catches up), violating the expectation that mempool holds executable transactions
- **Limited by Per-Account Cap**: Impact is bounded by the 100 transaction per-account limit and 600-second expiration, preventing critical-severity outcomes

This constitutes "state inconsistencies requiring intervention" under Medium severity classification.

## Likelihood Explanation

**High Likelihood**:

- **No Prerequisites**: Any user can submit BCS-encoded transactions to the public API
- **No Cost Barrier**: Failed transactions don't consume gas; attacker only needs to craft and submit BCS bytes
- **Easy Amplification**: Attacker can create multiple funded accounts to bypass per-account limits (100 txns Ã— N accounts)
- **Repeatable**: As transactions expire after 600 seconds, attacker can continuously resubmit to maintain pressure
- **Detection Gap**: The API provides no feedback that these transactions are problematic until mempool becomes full

## Recommendation

Implement sequence number validation at the API layer for BCS transactions, matching the validation that occurs in mempool. The API should:

1. Fetch the account's current sequence number from state
2. Reject transactions where `txn_sequence_number > account_sequence_number + reasonable_delta` (e.g., delta = 10)
3. Return an appropriate error code to the client

**Proposed Fix** in `api/src/transactions.rs`:

Modify the `get_signed_transaction` method to validate sequence numbers for BCS transactions:

```rust
SubmitTransactionPost::Bcs(data) => {
    let signed_transaction: SignedTransaction = 
        bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
            .context("Failed to deserialize input into SignedTransaction")
            .map_err(|err| { /* ... */ })?;
    
    // Validate sequence number for non-simulation transactions
    if let ReplayProtector::SequenceNumber(txn_seq) = signed_transaction.replay_protector() {
        let state_view = self.context.latest_state_view_poem(ledger_info)?;
        let account_seq = get_account_sequence_number(&state_view, signed_transaction.sender())
            .unwrap_or(0);
        
        // Reject far-future transactions (allow small gap for pipelining)
        const MAX_SEQUENCE_NUMBER_DELTA: u64 = 10;
        if txn_seq > account_seq + MAX_SEQUENCE_NUMBER_DELTA {
            return Err(SubmitTransactionError::bad_request_with_code(
                format!("Transaction sequence number {} is too far ahead of account sequence number {}", 
                    txn_seq, account_seq),
                AptosErrorCode::SequenceNumberTooNew,
                ledger_info,
            ));
        }
    }
    
    self.validate_signed_transaction_payload(ledger_info, &signed_transaction)?;
    Ok(signed_transaction)
}
```

## Proof of Concept

```rust
// Add to api/src/tests/transactions_test.rs

#[tokio::test]
async fn test_bcs_out_of_order_sequence_number_pollution() {
    let mut context = new_test_context(current_function_name!());
    let account = &mut context.gen_account();
    let txn_factory = context.transaction_factory();
    
    // Create account with sequence number 0
    let initial_txn = account.sign_with_transaction_builder(
        txn_factory.payload(aptos_stdlib::aptos_coin_transfer(*account.address(), 0))
    );
    context.commit_block(&vec![initial_txn.clone()]).await;
    
    // Account sequence number is now 1
    
    // Submit 100 transactions with far-future sequence numbers (1000-1099)
    let mut pollution_txns = vec![];
    for seq in 1000..1100 {
        let mut txn = account.sign_with_transaction_builder(
            txn_factory.payload(aptos_stdlib::aptos_coin_transfer(*account.address(), 0))
        );
        // Manually set sequence number
        txn.set_sequence_number(seq);
        pollution_txns.push(txn);
    }
    
    // Submit via BCS API
    let api_context = context.api_context();
    for txn in pollution_txns {
        let bcs_txn = bcs::to_bytes(&txn).unwrap();
        let result = api_context.submit_transaction(
            AcceptType::Bcs,
            SubmitTransactionPost::Bcs(Bcs(bcs_txn))
        ).await;
        
        // VULNERABILITY: These should be rejected but are accepted
        assert!(result.is_ok(), "Far-future transaction should be rejected but was accepted");
    }
    
    // Verify mempool pollution: 100 unexecutable transactions now occupy mempool
    // These transactions cannot execute because account sequence is 1, not 1000
    
    // Try to submit a legitimate transaction - may fail if mempool is full
    let legit_txn = account.sign_with_transaction_builder(
        txn_factory.payload(aptos_stdlib::aptos_coin_transfer(*account.address(), 1))
    );
    // Legitimate transaction with correct sequence (1) may be blocked
}
```

**Notes:**
- The vulnerability demonstrates a clear violation of the Resource Limits invariant (mempool accepting unexecutable transactions)
- Impact is amplified across multiple accounts
- The design choice to accept `SEQUENCE_NUMBER_TOO_NEW` was likely intended to support transaction pipelining, but the lack of API-level bounds checking creates an exploitable gap
- Fix must balance preventing pollution while allowing reasonable transaction pipelining for legitimate users

### Citations

**File:** api/src/transactions.rs (L98-105)
```rust
impl VerifyInput for SubmitTransactionPost {
    fn verify(&self) -> anyhow::Result<()> {
        match self {
            SubmitTransactionPost::Json(inner) => inner.0.verify(),
            SubmitTransactionPost::Bcs(_) => Ok(()),
        }
    }
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L358-393)
```rust
    let transactions: Vec<_> = transactions
        .into_iter()
        .enumerate()
        .filter_map(|(idx, (t, ready_time_at_sender, priority))| {
            if let Ok(account_sequence_num) = account_seq_numbers[idx] {
                match account_sequence_num {
                    Some(sequence_num) => {
                        if t.sequence_number() >= sequence_num {
                            return Some((t, Some(sequence_num), ready_time_at_sender, priority));
                        } else {
                            statuses.push((
                                t,
                                (
                                    MempoolStatus::new(MempoolStatusCode::VmError),
                                    Some(DiscardedVMStatus::SEQUENCE_NUMBER_TOO_OLD),
                                ),
                            ));
                        }
                    },
                    None => {
                        return Some((t, None, ready_time_at_sender, priority));
                    },
                }
            } else {
                // Failed to get account's onchain sequence number
                statuses.push((
                    t,
                    (
                        MempoolStatus::new(MempoolStatusCode::VmError),
                        Some(DiscardedVMStatus::RESOURCE_DOES_NOT_EXIST),
                    ),
                ));
            }
            None
        })
        .collect();
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L238-240)
```text
            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3282-3300)
```rust
        let (counter_label, result) = match self.validate_signed_transaction(
            &mut session,
            module_storage,
            &txn,
            &txn_data,
            &log_context,
            is_approved_gov_script,
            &mut TraversalContext::new(&storage),
            &mut gas_meter,
        ) {
            Err(err) if err.status_code() != StatusCode::SEQUENCE_NUMBER_TOO_NEW => (
                "failure",
                VMValidatorResult::new(Some(err.status_code()), 0),
            ),
            _ => (
                "success",
                VMValidatorResult::new(None, txn.gas_unit_price()),
            ),
        };
```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L322-332)
```rust
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
```

**File:** mempool/src/core_mempool/mempool.rs (L467-471)
```rust
                    let account_sequence_number =
                        self.transactions.get_account_sequence_number(&txn.address);
                    // include transaction if it's "next" for given account or
                    // we've already sent its ancestor to Consensus.
                    if txn_in_sequence || account_sequence_number == Some(&txn_seq) {
```

**File:** config/src/config/mempool_config.rs (L123-129)
```rust
            capacity_per_user: 100,
            default_failovers: 1,
            enable_intelligent_peer_prioritization: true,
            shared_mempool_peer_update_interval_ms: 1_000,
            shared_mempool_priority_update_interval_secs: 600, // 10 minutes (frequent reprioritization is expensive)
            shared_mempool_failover_delay_ms: 500,
            system_transaction_timeout_secs: 600,
```
