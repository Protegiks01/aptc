# Audit Report

## Title
Cross-Module Recursive Struct Definitions Bypass Verification with Lazy Loading Enabled

## Summary
When lazy loading is enabled (default on Aptos mainnet), two modules can reference each other's struct types in a cyclic manner, bypassing all recursive struct definition checks. This allows publication of modules with circular struct dependencies that can cause resource exhaustion and validator node performance degradation.

## Finding Description

The security question correctly identifies a critical gap in the struct recursion verification system. The bytecode verifier's `RecursiveStructDefChecker` only examines struct definitions within a single module by building a dependency graph from the `handle_to_def` mapping, which exclusively contains structs defined in that module. [1](#0-0) 

When two modules reference each other's structs (e.g., Module A has `struct S1 { field: B::S2 }` and Module B has `struct S2 { field: A::S1 }`), this creates a cross-module cycle that the single-module checker cannot detect. The checker relies on the assumption that module dependencies are acyclic, as stated in the comment. [2](#0-1) 

However, this assumption breaks when lazy loading is enabled. During module publishing with lazy loading, cyclic dependency checks are explicitly skipped: [3](#0-2) 

The runtime cyclic dependency detection in `visit_dependencies_and_verify` is bypassed in favor of lazy verification: [4](#0-3) 

Additionally, the `TypeDepthChecker` that could detect cycles at runtime is disabled in production. When `propagate_dependency_limit_error` is true (for gas_feature_version >= 42, currently at 45), the depth checker returns immediately without performing cycle detection: [5](#0-4) [6](#0-5) [7](#0-6) 

Lazy loading is enabled by default on Aptos: [8](#0-7) 

When VM operations like layout construction encounter these cyclic structs, they recursively traverse the struct definitions without cycle detection, relying only on depth and count limits to eventually terminate: [9](#0-8) 

**Attack Scenario:**
1. Attacker publishes a bundle containing two modules with cyclic struct references
2. Both modules pass verification (no cyclic dependency check with lazy loading)
3. Modules are successfully published to the blockchain
4. When any transaction attempts operations involving these structs (e.g., serialization, layout construction), the VM recursively traverses until hitting limits (depth=128 or count=512)
5. This causes excessive gas consumption and validator node performance degradation

## Impact Explanation

This vulnerability represents a **High Severity** issue per Aptos bug bounty criteria, potentially approaching **Critical** depending on exploitation effectiveness:

**Validator Node Slowdowns (High Severity):** Each transaction that triggers layout construction for cyclic structs will recursively traverse the cycle 128+ times (depth limit) or 512+ times (count limit), consuming significant computational resources. Multiple such transactions could severely degrade validator performance.

**Resource Exhaustion (High Severity):** The inefficient traversal wastes gas and execution time. An attacker could publish multiple such module pairs and trigger operations on them to exhaust validator resources.

**Consensus Impact Potential (Critical Severity):** If validators experience different performance degradation due to timing or resource differences, this could lead to disagreements in transaction execution results, potentially violating the Deterministic Execution invariant where "all validators must produce identical state roots for identical blocks."

The vulnerability breaks **Critical Invariant #3 (Move VM Safety)** and **Critical Invariant #9 (Resource Limits)** by allowing operations that do not respect computational constraints efficiently.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is relatively straightforward to execute:
- Attacker needs ability to publish modules (which any user with sufficient gas can do)
- Modules can be crafted to have cyclic struct dependencies  
- No special privileges or insider access required
- Lazy loading is enabled by default on Aptos mainnet

However, likelihood is tempered by:
- Attacker must craft bytecode modules (normal compiler might reject these)
- Both modules must be published in same bundle for dependency resolution
- Triggering the issue requires subsequent transactions to use these structs

Given the accessibility to any module publisher and the enabled-by-default lazy loading configuration, this vulnerability has a moderate to high likelihood of exploitation if attackers become aware of it.

## Recommendation

Implement multi-layered cyclic struct detection:

1. **During Publishing (Immediate Fix):** Add cyclic dependency detection for module bundles even with lazy loading enabled. After staging all modules in a bundle, perform a cross-module cyclic dependency check before accepting the publication.

2. **In TypeDepthChecker:** Remove or revise the `propagate_dependency_limit_error` gating logic that disables cycle detection. The cycle detection in `calculate_struct_depth_formula` should always run regardless of this flag:

```rust
// In ty_depth_checker.rs, lines 57-61
let maybe_max_depth = vm_config.max_value_nest_depth;
// Remove the conditional that sets maybe_max_depth to None
```

3. **In Layout Construction:** Add explicit cycle detection with a `currently_visiting` set similar to TypeDepthChecker's approach, as noted in the TODO comment.

4. **Module Linking:** During the linking phase, verify that the transitive closure of struct field type dependencies forms a DAG (directed acyclic graph) across all modules.

## Proof of Concept

```rust
// Module A (compiled to bytecode and signed by address 0xA)
module 0xA::CyclicA {
    use 0xB::CyclicB;
    
    struct StructA {
        b_field: CyclicB::StructB
    }
}

// Module B (compiled to bytecode and signed by address 0xB)  
module 0xB::CyclicB {
    use 0xA::CyclicA;
    
    struct StructB {
        a_field: CyclicA::StructA
    }
}

// Exploitation Steps:
// 1. Compile both modules to bytecode (may require manual bytecode crafting to bypass compiler checks)
// 2. Publish both modules in a single transaction bundle
// 3. Expected: Both modules publish successfully with lazy loading enabled
// 4. Trigger layout construction by attempting serialization or other type operations
// 5. Observe: Recursive traversal up to depth=128 or count=512 before termination
// 6. Result: Excessive gas consumption and validator performance impact
```

The PoC demonstrates that with lazy loading enabled and type depth checking disabled, cyclic struct definitions can be published and subsequently cause resource exhaustion when VM operations traverse these structures.

**Notes:**
- Cross-module struct cycles cannot be instantiated in Move code (you cannot construct a value without having the other value first)
- However, VM internal operations (layout construction, type checking, serialization attempts) will still traverse the type definitions
- The vulnerability exploits the gap between compile-time/publish-time verification and runtime type system operations

### Citations

**File:** third_party/move/move-bytecode-verifier/src/struct_defs.rs (L5-7)
```rust
//! This module provides a checker for verifying that struct definitions in a module are not
//! recursive. Since the module dependency graph is acylic by construction, applying this checker to
//! each module in isolation guarantees that there is no structural recursion globally.
```

**File:** third_party/move/move-bytecode-verifier/src/struct_defs.rs (L49-71)
```rust
/// Given a module, build a graph of struct definitions. This is useful when figuring out whether
/// the struct definitions in module form a cycle.
struct StructDefGraphBuilder<'a> {
    module: &'a CompiledModule,
    /// Used to follow field definitions' signatures' struct handles to their struct definitions.
    handle_to_def: BTreeMap<StructHandleIndex, StructDefinitionIndex>,
}

impl<'a> StructDefGraphBuilder<'a> {
    fn new(module: &'a CompiledModule) -> Self {
        let mut handle_to_def = BTreeMap::new();
        // the mapping from struct definitions to struct handles is already checked to be 1-1 by
        // DuplicationChecker
        for (idx, struct_def) in module.struct_defs().iter().enumerate() {
            let sh_idx = struct_def.struct_handle;
            handle_to_def.insert(sh_idx, StructDefinitionIndex(idx as TableIndex));
        }

        Self {
            module,
            handle_to_def,
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L57-61)
```rust
        let maybe_max_depth = if vm_config.propagate_dependency_limit_error {
            None
        } else {
            vm_config.max_value_nest_depth
        };
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L79-82)
```rust
        let max_depth = match self.maybe_max_depth {
            Some(max_depth) => max_depth,
            None => return Ok(()),
        };
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L262-262)
```rust
        propagate_dependency_limit_error: gas_feature_version >= RELEASE_V1_38,
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L363-367)
```rust
    // TODO(lazy-loading):
    //   We do not add struct cyclic checks here because it can be rather expensive to check. In
    //   general, because we have depth / count checks and charges for modules this will eventually
    //   terminate in any case. In the future, layouts should be revisited anyway.
    //   Consider adding proper charges here for layout construction (before rollout).
```
