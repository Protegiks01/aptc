# Audit Report

## Title
Subscription Termination Metrics Bypass via Fallback Mode

## Summary
The `OBSERVER_TERMINATED_SUBSCRIPTIONS` metric is not incremented when subscriptions are terminated through the fallback mode path, allowing subscription attack patterns to be hidden from metrics-based monitoring and forensic analysis.

## Finding Description

The consensus observer tracks subscription lifecycle events using two counters: `OBSERVER_CREATED_SUBSCRIPTIONS` and `OBSERVER_TERMINATED_SUBSCRIPTIONS`. [1](#0-0) [2](#0-1) 

These metrics are updated via `update_subscription_change_metrics()` when subscriptions are created or terminated through the normal health check mechanism. [3](#0-2) 

However, when the observer enters fallback mode due to sync progress failures, it calls `terminate_all_subscriptions()` which terminates all active subscriptions without updating the termination metrics. [4](#0-3) [5](#0-4) 

The `unsubscribe_from_peer()` function only removes peers from the subscription map and sends unsubscribe requests, but does not track termination reasons or update metrics. [6](#0-5) 

Fallback mode is triggered when: (1) DB sync progress stops for longer than configured threshold, or (2) sync lag exceeds the threshold. [7](#0-6) 

**Attack Path:**
1. Attacker induces network conditions preventing DB sync (e.g., DoS on subscribed validator nodes, network partition)
2. Observer's `check_syncing_progress()` fails after timeout thresholds
3. `enter_fallback_mode()` is called, which invokes `terminate_all_subscriptions()`
4. All subscriptions are removed from active set without incrementing `OBSERVER_TERMINATED_SUBSCRIPTIONS`
5. Metrics-based monitoring systems miss these termination events
6. Attacker can repeat this pattern to hide subscription churn attacks

## Impact Explanation

This qualifies as **Low Severity** per Aptos bug bounty criteria - specifically a "Non-critical implementation bug" and "Minor information leak":

- Does NOT affect consensus safety or liveness
- Does NOT allow fund theft or state corruption  
- Does NOT create validator node slowdowns or crashes
- ONLY affects observability/forensics capabilities
- Metrics-based intrusion detection systems may fail to detect subscription abuse patterns
- Post-incident forensic analysis will have incomplete subscription termination data

## Likelihood Explanation

**Moderate likelihood** - requires specific but achievable conditions:
- Attacker must have network-level capabilities to disrupt sync (DoS, partition)
- No validator insider access required
- Fallback conditions are well-defined and can be triggered through sustained network attacks
- The bypass is deterministic - every fallback mode entry will skip metrics

## Recommendation

Update `terminate_all_subscriptions()` to collect termination information and update metrics:

```rust
pub fn terminate_all_subscriptions(&mut self) {
    let active_peers = self.get_active_subscription_peers();
    let mut terminated_peers = Vec::new();
    
    for peer_network_id in active_peers {
        self.unsubscribe_from_peer(peer_network_id);
        // Use a generic fallback termination reason
        terminated_peers.push((peer_network_id, Error::SubscriptionsReset("Entering fallback mode".to_string())));
    }
    
    // Update metrics to record the terminations
    for (peer_network_id, termination_reason) in terminated_peers {
        metrics::increment_counter(
            &metrics::OBSERVER_TERMINATED_SUBSCRIPTIONS,
            termination_reason.get_label(),
            &peer_network_id,
        );
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a consensus observer node with active subscriptions
2. Configuring low timeout values for `observer_fallback_progress_threshold_ms`
3. Blocking network traffic to subscribed peers to prevent DB sync
4. Observing that `OBSERVER_NUM_ACTIVE_SUBSCRIPTIONS` drops to 0
5. Verifying that `OBSERVER_TERMINATED_SUBSCRIPTIONS` was NOT incremented
6. Checking logs confirm fallback mode was entered and subscriptions terminated

This creates a gap in subscription forensic tracking that can hide attack patterns from metrics-based monitoring systems.

## Notes

While this is a legitimate observability gap, the security impact is limited to monitoring/forensics capabilities. The observer still functions correctly and enters fallback mode as designed. The issue is that this legitimate operational state change is not fully captured in the metrics system, creating blind spots for security monitoring that relies on these counters to detect subscription abuse patterns.

### Citations

**File:** consensus/src/consensus_observer/common/metrics.rs (L32-38)
```rust
pub static OBSERVER_CREATED_SUBSCRIPTIONS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "consensus_observer_created_subscriptions",
        "Counters for created subscriptions for consensus observer",
        &["creation_label", "network_id"]
    )
    .unwrap()
```

**File:** consensus/src/consensus_observer/common/metrics.rs (L200-207)
```rust
pub static OBSERVER_TERMINATED_SUBSCRIPTIONS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "consensus_observer_terminated_subscriptions",
        "Counters for terminated subscriptions for consensus observer",
        &["termination_label", "network_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L264-268)
```rust
    pub fn terminate_all_subscriptions(&mut self) {
        for peer_network_id in self.get_active_subscription_peers() {
            self.unsubscribe_from_peer(peer_network_id);
        }
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L308-359)
```rust
    fn unsubscribe_from_peer(&mut self, peer_network_id: PeerNetworkId) {
        // Remove the peer from the active subscriptions
        self.active_observer_subscriptions
            .lock()
            .remove(&peer_network_id);

        // Send an unsubscribe request to the peer and process the response.
        // Note: we execute this asynchronously, as we don't need to wait for the response.
        let consensus_observer_client = self.consensus_observer_client.clone();
        let consensus_observer_config = self.consensus_observer_config;
        tokio::spawn(async move {
            // Send the unsubscribe request to the peer
            let unsubscribe_request = ConsensusObserverRequest::Unsubscribe;
            let response = consensus_observer_client
                .send_rpc_request_to_peer(
                    &peer_network_id,
                    unsubscribe_request,
                    consensus_observer_config.network_request_timeout_ms,
                )
                .await;

            // Process the response
            match response {
                Ok(ConsensusObserverResponse::UnsubscribeAck) => {
                    info!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Successfully unsubscribed from peer: {}!",
                            peer_network_id
                        ))
                    );
                },
                Ok(response) => {
                    // We received an invalid response
                    warn!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Got unexpected response type: {:?}",
                            response.get_label()
                        ))
                    );
                },
                Err(error) => {
                    // We encountered an error while sending the request
                    warn!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send unsubscribe request to peer: {}! Error: {:?}",
                            peer_network_id, error
                        ))
                    );
                },
            }
        });
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L388-410)
```rust
/// Updates the subscription creation and termination metrics
fn update_subscription_change_metrics(
    new_subscription_peers: Vec<PeerNetworkId>,
    terminated_subscription_peers: Vec<(PeerNetworkId, Error)>,
) {
    // Update the created subscriptions metrics
    for peer_network_id in new_subscription_peers {
        metrics::increment_counter(
            &metrics::OBSERVER_CREATED_SUBSCRIPTIONS,
            metrics::CREATED_SUBSCRIPTION_LABEL,
            &peer_network_id,
        );
    }

    // Update the terminated subscriptions metrics
    for (peer_network_id, termination_reason) in terminated_subscription_peers {
        metrics::increment_counter(
            &metrics::OBSERVER_TERMINATED_SUBSCRIPTIONS,
            termination_reason.get_label(),
            &peer_network_id,
        );
    }
}
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L237-240)
```rust
    async fn enter_fallback_mode(&mut self) {
        // Terminate all active subscriptions (to ensure we don't process any more messages)
        self.subscription_manager.terminate_all_subscriptions();

```

**File:** consensus/src/consensus_observer/observer/fallback_manager.rs (L55-85)
```rust
    /// Verifies that the DB is continuing to sync and commit new data, and that
    /// the node has not fallen too far behind the rest of the network.
    /// If not, an error is returned, indicating that we should enter fallback mode.
    pub fn check_syncing_progress(&mut self) -> Result<(), Error> {
        // If we're still within the startup period, we don't need to verify progress
        let time_now = self.time_service.now();
        let startup_period = Duration::from_millis(
            self.consensus_observer_config
                .observer_fallback_startup_period_ms,
        );
        if time_now.duration_since(self.start_time) < startup_period {
            return Ok(()); // We're still in the startup period
        }

        // Fetch the synced ledger info version from storage
        let latest_ledger_info_version =
            self.db_reader
                .get_latest_ledger_info_version()
                .map_err(|error| {
                    Error::UnexpectedError(format!(
                        "Failed to read highest synced version: {:?}",
                        error
                    ))
                })?;

        // Verify that the synced version is increasing appropriately
        self.verify_increasing_sync_versions(latest_ledger_info_version, time_now)?;

        // Verify that the sync lag is within acceptable limits
        self.verify_sync_lag_health(latest_ledger_info_version)
    }
```
