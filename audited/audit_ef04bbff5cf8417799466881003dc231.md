# Audit Report

## Title
Non-Deterministic Storage Usage Calculation Due to Missing Data Fallback

## Summary
The `get_usage()` function can return different `StateStorageUsage` values on validators with identical blockchain state when storage sharding is enabled and usage metadata is missing, leading to consensus divergence through gas cost calculation differences.

## Finding Description

The vulnerability exists in the storage usage retrieval mechanism that impacts consensus-critical gas calculations. The chain of execution is:

1. **Entry Point**: `DbStateView::get_usage()` delegates to the database reader [1](#0-0) 

2. **Fallback Logic**: `StateDb::get_state_storage_usage()` has conditional behavior based on `skip_usage` flag [2](#0-1) 

3. **Configuration Dependency**: The `skip_usage` flag is set to `enable_storage_sharding` value [3](#0-2) 

4. **Untracked Returns Zero**: When usage is untracked, both `items()` and `bytes()` return 0 [4](#0-3) 

5. **Move Exposure**: This usage is exposed to Move code via native function [5](#0-4) 

6. **Consensus Impact**: Usage values directly calculate storage gas costs in the Move framework [6](#0-5) 

**Attack Scenario**: If validators have:
- Same blockchain state (version N)
- Different database completeness (one has usage metadata at version N, another doesn't)
- Both have `enable_storage_sharding = true`

Then at epoch boundary when `on_reconfig()` executes:
- Validator A with metadata: Returns actual usage (e.g., items=1000000, bytes=500MB)
- Validator B without metadata: Returns Untracked → (items=0, bytes=0)
- Different gas costs calculated for subsequent transactions
- Transactions execute differently → consensus failure

## Impact Explanation

**Critical Severity** - This violates the fundamental Deterministic Execution invariant. Different validators would:
1. Calculate different `per_item_read/create/write` gas costs
2. Calculate different `per_byte_read/create/write` gas costs  
3. Charge different gas amounts for identical transactions
4. Produce different state roots after executing the same block
5. Cause consensus failure requiring manual intervention or hardfork

This meets the "Consensus/Safety violations" category for Critical severity under the Aptos bug bounty program.

## Likelihood Explanation

**Low Likelihood** due to mitigations:

1. **Mainnet/Testnet Enforcement**: Configuration validation panics if sharding isn't explicitly enabled [7](#0-6) 

2. **Consistent Write Path**: `put_usage()` always writes usage metadata during commits [8](#0-7) 

However, the vulnerability could manifest in:
- Database restore/migration scenarios where metadata is incomplete
- Fast-sync nodes that don't have full historical metadata
- Database corruption affecting only metadata column family
- Non-mainnet networks (devnet, custom chains) without enforced configurations

## Recommendation

**Immediate Fix**: Remove the silent fallback to Untracked. If usage data is missing, this should be a hard error for all nodes:

```rust
fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
    version.map_or(Ok(StateStorageUsage::zero()), |version| {
        self.ledger_db.metadata_db().get_usage(version)
            .map_err(|e| anyhow!("VersionData at {version} is missing: {e}"))
    })
}
```

**Long-term Fix**: 
1. Add state commitment of usage values in transaction info to make divergence immediately detectable
2. Add startup validation that all validators have usage metadata for recent checkpoints
3. Require usage metadata in state snapshots used for fast-sync

## Proof of Concept

```rust
// Reproduction test demonstrating divergent behavior
#[test]
fn test_usage_divergence() {
    // Setup two StateDb instances with same state but different metadata
    let state_db_a = create_state_db_with_usage(1000, 500_000_000);
    let state_db_b = create_state_db_without_usage(); // skip_usage = true
    
    // Both at same version
    let version = Some(100);
    
    let usage_a = state_db_a.get_state_storage_usage(version).unwrap();
    let usage_b = state_db_b.get_state_storage_usage(version).unwrap();
    
    // Validator A: returns tracked usage
    assert_eq!(usage_a.items(), 1000);
    assert_eq!(usage_a.bytes(), 500_000_000);
    
    // Validator B: returns untracked (0, 0)
    assert_eq!(usage_b.items(), 0);
    assert_eq!(usage_b.bytes(), 0);
    
    // This divergence causes different gas calculations
    // in storage_gas.move::on_reconfig()
    let gas_a = calculate_gas_costs(usage_a);
    let gas_b = calculate_gas_costs(usage_b);
    
    assert_ne!(gas_a, gas_b); // CONSENSUS FAILURE
}
```

## Notes

While mainnet/testnet have configuration enforcement, the defensive programming flaw remains in the codebase. The silent fallback to Untracked should be replaced with explicit error handling to prevent any scenario where validators could silently diverge on this consensus-critical value. The current implementation prioritizes liveness over safety, which is inappropriate for storage usage that directly affects transaction execution determinism.

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L66-70)
```rust
    fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
        self.db
            .get_state_storage_usage(self.version)
            .map_err(Into::into)
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1017-1028)
```rust
    fn put_usage(state: &State, batch: &mut SchemaBatch) -> Result<()> {
        if let Some(version) = state.version() {
            let usage = state.usage();
            info!("Write usage at version {version}, {usage:?}.");
            batch.put::<VersionDataSchema>(&version, &usage.into())?;
        } else {
            assert_eq!(state.usage().items(), 0);
            assert_eq!(state.usage().bytes(), 0);
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L148-160)
```rust
        let mut myself = Self::new_with_dbs(
            ledger_db,
            hot_state_merkle_db,
            state_merkle_db,
            state_kv_db,
            pruner_config,
            buffered_state_target_items,
            readonly,
            empty_buffered_state_for_restore,
            rocksdb_configs.enable_storage_sharding,
            internal_indexer_db,
            hot_state_config,
        );
```

**File:** types/src/state_store/state_storage_usage.rs (L30-42)
```rust
    pub fn items(&self) -> usize {
        match self {
            Self::Tracked { items, .. } => *items,
            Self::Untracked => 0,
        }
    }

    pub fn bytes(&self) -> usize {
        match self {
            Self::Tracked { bytes, .. } => *bytes,
            Self::Untracked => 0,
        }
    }
```

**File:** aptos-move/framework/src/natives/state_storage.rs (L59-79)
```rust
fn native_get_usage(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert!(_ty_args.is_empty());
    assert!(_args.is_empty());

    context.charge(STATE_STORAGE_GET_USAGE_BASE_COST)?;

    let ctx = context.extensions().get::<NativeStateStorageContext>();
    let usage = ctx.resolver.get_usage().map_err(|err| {
        PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
            .with_message(format!("Failed to get state storage usage: {}", err))
    })?;

    Ok(smallvec![Value::struct_(Struct::pack(vec![
        Value::u64(usage.items() as u64),
        Value::u64(usage.bytes() as u64),
    ]))])
}
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L515-533)
```text
    public(friend) fun on_reconfig() acquires StorageGas, StorageGasConfig {
        assert!(
            exists<StorageGasConfig>(@aptos_framework),
            error::not_found(ESTORAGE_GAS_CONFIG)
        );
        assert!(
            exists<StorageGas>(@aptos_framework),
            error::not_found(ESTORAGE_GAS)
        );
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
    }
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
