# Audit Report

## Title
Byzantine Validator Censorship via excluded_batches Manipulation in Batch Proof Queue

## Summary
A malicious validator acting as block proposer can systematically censor honest validators' transaction batches by arbitrarily manipulating the `excluded_batches` parameter in the batch selection process. The protocol lacks verification mechanisms to detect or prevent unfair batch exclusion, enabling persistent transaction censorship that violates consensus liveness and fairness guarantees.

## Finding Description

The vulnerability exists in the interaction between the proposal generation flow and the batch proof queue's batch selection mechanism.

**Attack Flow:**

1. **Proposer constructs excluded_batches locally**: In the proposal generator, the proposer creates `excluded_batches` from pending blocks: [1](#0-0) 

2. **excluded_batches passed to ProofManager**: This parameter flows through the payload client to the proof manager: [2](#0-1) 

3. **Batches filtered in pull_internal()**: The proof manager's `pull_internal()` function skips any batches in `excluded_batches`: [3](#0-2) 

4. **No validation by other validators**: When validators receive the proposal, they only verify that included batches have valid signatures and digests: [4](#0-3) [5](#0-4) 

**Critical Security Gap:**

The `excluded_batches` parameter is constructed locally by the proposer and never validated by other validators. The payload verification only checks cryptographic validity (signatures, digests) but not fairness or completeness of batch inclusion. A Byzantine proposer can inject arbitrary batches into `excluded_batches` to censor specific validators' transactions while appearing to follow protocol rules.

**Broken Invariants:**
- **Consensus Liveness**: Transactions in censored batches are indefinitely delayed
- **Fairness**: Violates the fairness guarantees tested in the proof queue implementation
- **Censorship Resistance**: Protocol design assumes <1/3 Byzantine validators cannot systematically censor transactions

## Impact Explanation

**Severity: Critical** (Consensus/Safety violation category - up to $1,000,000)

This vulnerability enables:

1. **Systematic Transaction Censorship**: A malicious proposer can permanently exclude honest validators' batches from blocks, preventing their transactions from executing
2. **Fee Manipulation**: The attacker collects all transaction fees while honest validators receive none
3. **Validator Revenue Loss**: Honest validators lose rewards from batch inclusion
4. **Network Liveness Degradation**: Critical transactions (governance proposals, staking operations) can be blocked
5. **Protocol Fairness Violation**: Breaks the round-robin fairness mechanism that distributes batch inclusion across validators

Unlike normal block proposer discretion (which is limited and temporary), this attack enables **deterministic, persistent censorship** across all rounds where the Byzantine validator is proposer. With typical validator rotation (assuming uniform distribution), an attacker controlling even 5% of validators could censor batches 5% of the time, indefinitely.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:

1. **Low Barrier to Entry**: Only requires validator status and code modification to inject batches into `excluded_batches`
2. **Difficult Detection**: No protocol-level mechanism exists to detect unfair exclusion since `excluded_batches` is not visible to other validators
3. **Regular Opportunity**: Proposers are selected in rotation, providing regular censorship windows
4. **Profitable**: Direct financial benefit through fee monopolization
5. **Deniable**: Can claim batches were excluded due to "size limits" or "local queue state"

The fairness test demonstrates the protocol's *intent* for fair batch selection: [6](#0-5) 

However, this fairness is only enforced in the honest code path, not validated by consensus.

## Recommendation

Implement protocol-level fairness validation through one of these approaches:

**Option 1: Batch Availability Attestations**
- Require proposers to include attestations from other validators about available batches
- Validators verify that all attested batches were either included or had valid exclusion reasons
- Penalize proposers who systematically exclude available batches

**Option 2: Deterministic Exclusion Rules**
- Make `excluded_batches` deterministic and verifiable by computing it from the certified blockchain state
- Other validators independently compute expected `excluded_batches` and verify the proposal doesn't deviate
- Reject proposals that exclude batches not in the deterministic exclusion set

**Option 3: Minimum Inclusion Threshold**
- Require each proposal to include a minimum percentage of available batches from each validator
- Track per-validator batch availability across rounds
- Slash validators who consistently exclude specific validators' batches

**Recommended Implementation (Option 2 - Most Byzantine-resistant):**

```rust
// In proposal_generator.rs
pub fn create_deterministic_excluded_batches(
    pending_blocks: &[Arc<Block>],
    blockchain_state: &BlockchainState,
) -> HashSet<BatchInfoExt> {
    // Compute excluded_batches deterministically from certified blocks
    // All validators can independently verify this computation
    let exclude_payload: Vec<_> = pending_blocks
        .iter()
        .flat_map(|block| block.payload())
        .collect();
    PayloadFilter::from(&exclude_payload)
}

// In proposal verification
pub fn verify_excluded_batches(
    proposal: &Block,
    blockchain_state: &BlockchainState,
) -> Result<()> {
    let expected_excluded = compute_deterministic_excluded_batches(
        blockchain_state.get_pending_blocks(proposal.parent_id()),
        blockchain_state,
    );
    
    // Verify proposal doesn't exclude batches that shouldn't be excluded
    // This requires adding excluded_batches to the block payload
    ensure!(
        proposal.excluded_batches() == expected_excluded,
        "Proposal excluded batches don't match expected exclusion set"
    );
    Ok(())
}
```

## Proof of Concept

```rust
// Malicious validator code modification
// In liveness/proposal_generator.rs - Attack implementation

async fn generate_proposal_inner_malicious(
    &self,
    round: Round,
    parent_id: HashValue,
    proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    target_victim_validator: PeerId, // Validator to censor
) -> anyhow::Result<(Vec<ValidatorTransaction>, Payload, u64)> {
    // Normal flow
    let mut pending_blocks = self
        .block_store
        .path_from_commit_root(parent_id)
        .ok_or_else(|| format_err!("Parent block {} already pruned", parent_id))?;
    pending_blocks.push(self.block_store.commit_root());

    let exclude_payload: Vec<_> = pending_blocks
        .iter()
        .flat_map(|block| block.payload())
        .collect();
    let mut payload_filter = PayloadFilter::from(&exclude_payload);

    // ATTACK: Inject victim's batches into excluded_batches
    // even though they're not in pending blocks
    if let PayloadFilter::InQuorumStore(ref mut excluded_batches) = payload_filter {
        // Get all available batches from victim validator
        let victim_batches = self.get_victim_batches(target_victim_validator).await;
        for batch in victim_batches {
            excluded_batches.insert(batch); // Censor victim's batches
        }
    }

    // Continue with normal proposal generation
    // The manipulated excluded_batches causes victim's batches to be skipped
    // Other validators see a valid block and cannot detect the censorship
    let (validator_txns, payload, timestamp) = self
        .payload_client
        .pull_payload(
            PayloadPullParameters {
                user_txn_filter: payload_filter, // Contains injected exclusions
                // ... other params
            },
            // ... other params
        )
        .await?;

    Ok((validator_txns, payload, timestamp))
}

// Result: Victim validator's batches are permanently excluded
// No protocol mechanism exists to detect or prevent this
```

**Attack Demonstration:**
1. Malicious validator modifies `generate_proposal_inner()` to inject target validator's batches into `excluded_batches`
2. When proposer, creates blocks excluding victim's batches
3. Other validators validate block - signatures check out, no duplicate transactions
4. Block is accepted despite unfair censorship
5. Victim's transactions never execute, attacker monopolizes fees
6. Process repeats every time attacker is selected as proposer

The attack succeeds because the payload verification code only checks cryptographic validity, not fairness: [7](#0-6) 

No validation ensures all available, non-conflicting batches were fairly considered for inclusion.

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L585-589)
```rust
        let exclude_payload: Vec<_> = pending_blocks
            .iter()
            .flat_map(|block| block.payload())
            .collect();
        let payload_filter = PayloadFilter::from(&exclude_payload);
```

**File:** consensus/src/payload_client/user/quorum_store_client.rs (L55-69)
```rust
        exclude_payloads: PayloadFilter,
        block_timestamp: Duration,
    ) -> anyhow::Result<Payload, QuorumStoreError> {
        let (callback, callback_rcv) = oneshot::channel();
        let req = GetPayloadCommand::GetPayloadRequest(GetPayloadRequest {
            max_txns,
            max_txns_after_filtering,
            soft_max_txns_after_filtering,
            maybe_optqs_payload_pull_params,
            max_inline_txns,
            filter: exclude_payloads,
            return_non_full,
            callback,
            block_timestamp,
        });
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L634-636)
```rust
                    if excluded_batches.contains(batch) {
                        excluded_txns += batch.num_txns();
                    } else {
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L97-110)
```rust
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;
```

**File:** consensus/consensus-types/src/common.rs (L575-632)
```rust
        &self,
        verifier: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> anyhow::Result<()> {
        match (quorum_store_enabled, self) {
            (false, Payload::DirectMempool(_)) => Ok(()),
            (true, Payload::InQuorumStore(proof_with_status)) => {
                Self::verify_with_cache(&proof_with_status.proofs, verifier, proof_cache)
            },
            (true, Payload::InQuorumStoreWithLimit(proof_with_status)) => Self::verify_with_cache(
                &proof_with_status.proof_with_data.proofs,
                verifier,
                proof_cache,
            ),
            (true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
            | (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
                Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    inline_batches.iter().map(|(info, txns)| (info, txns)),
                )?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V1(p))) => {
                let proof_with_data = p.proof_with_data();
                Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    p.inline_batches()
                        .iter()
                        .map(|batch| (batch.info(), batch.transactions())),
                )?;
                Self::verify_opt_batches(verifier, p.opt_batches())?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V2(p))) => {
                if true {
                    bail!("OptQuorumStorePayload::V2 cannot be accepted yet");
                }
                #[allow(unreachable_code)]
                {
                    let proof_with_data = p.proof_with_data();
                    Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                    Self::verify_inline_batches(
                        p.inline_batches()
                            .iter()
                            .map(|batch| (batch.info(), batch.transactions())),
                    )?;
                    Self::verify_opt_batches(verifier, p.opt_batches())?;
                    Ok(())
                }
            },
            (_, _) => Err(anyhow::anyhow!(
                "Wrong payload type. Expected Payload::InQuorumStore {} got {} ",
                quorum_store_enabled,
                self
            )),
        }
    }
```

**File:** consensus/src/quorum_store/tests/proof_manager_test.rs (L244-250)
```rust
    // The first two proofs are taken fairly from each peer
    get_proposal_and_assert(&mut proof_manager, 2, &[], &vec![
        peer0_proofs[0].clone(),
        peer1_proof_0.clone(),
    ])
    .await;

```
