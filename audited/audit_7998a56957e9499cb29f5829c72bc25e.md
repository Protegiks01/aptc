# Audit Report

## Title
Incomplete Crash Recovery: Persisted Auxiliary Info Not Truncated During Partial Commit Cleanup

## Summary
The crash recovery mechanism in AptosDB fails to truncate persisted auxiliary info when recovering from partial commits, leaving stale metadata in the database that doesn't correspond to any committed transactions. This violates the State Consistency invariant.

## Finding Description

The ChunkToCommit commit operation is **not fully atomic**. When `save_transactions()` is called, it performs a two-phase commit:

1. **Pre-commit phase** (`pre_commit_ledger`): Writes data to multiple databases in parallel
2. **Commit phase** (`commit_ledger`): Updates commit progress markers

During pre-commit, 7 parallel operations write to different databases: [1](#0-0) 

One of these operations writes persisted auxiliary info: [2](#0-1) 

If the process crashes mid-commit, the crash recovery mechanism (`sync_commit_progress`) attempts to restore consistency by truncating all data beyond the `OverallCommitProgress` marker: [3](#0-2) 

The truncation is performed by `truncate_ledger_db`, which calls `delete_per_version_data` to clean up per-version data: [4](#0-3) 

**The vulnerability**: `delete_per_version_data` does NOT delete persisted auxiliary info. It only deletes:
- TransactionAccumulatorRootHashSchema
- TransactionInfoSchema  
- Transactions and transaction summaries
- VersionDataSchema
- WriteSetSchema

The `LedgerDbSchemaBatches` struct includes a `persisted_auxiliary_info_db_batches` field, but it's never populated during truncation: [5](#0-4) 

While `PersistedAuxiliaryInfoDb` has a prune method that could delete this data: [6](#0-5) 

This method is never called from the truncation logic - only from the regular pruner.

**Attack Scenario**:
1. Node is committing transactions at version N
2. Persisted auxiliary info for versions N, N+1, N+2 is written
3. Process crashes before transaction accumulator/infos are written
4. Node restarts, recovery truncates to version N-1
5. Transactions and other data for N, N+1, N+2 are removed
6. **But auxiliary info for N, N+1, N+2 remains in the database**

This creates database inconsistency where auxiliary info exists for non-committed transactions.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention.

The stale auxiliary info creates database corruption that:
- Violates the State Consistency invariant (#4 in the specification)
- Causes db-tool and verification utilities to see inconsistent data
- Can lead to false positives in replay verification
- Accumulates over multiple crash-recovery cycles
- Requires manual database intervention to fix

This does NOT directly cause:
- Loss of funds (auxiliary info is metadata, not state)
- Consensus safety violations (consensus doesn't rely on auxiliary info for safety)
- Network unavailability (node continues operating)

However, it does cause operational issues and database integrity violations that require intervention to resolve, meeting the Medium severity criteria.

## Likelihood Explanation

**High likelihood** of occurrence:

1. **Crash frequency**: Validator nodes can crash due to:
   - Hardware failures
   - OOM conditions
   - Software bugs
   - Power outages
   - SIGKILL from operators

2. **Timing window**: The vulnerability manifests whenever a crash occurs during the ~10ms window of parallel database writes in `calculate_and_commit_ledger_and_state_kv`

3. **Accumulation**: Each crash during commit adds more stale auxiliary info, compounding the issue over time

4. **No special attacker capability required**: Any crash (accidental or induced) triggers this bug

## Recommendation

Add persisted auxiliary info truncation to the `delete_per_version_data` function:

```rust
fn delete_per_version_data(
    ledger_db: &LedgerDb,
    start_version: Version,
    batch: &mut LedgerDbSchemaBatches,
) -> Result<()> {
    delete_per_version_data_impl::<TransactionAccumulatorRootHashSchema>(
        ledger_db.transaction_accumulator_db_raw(),
        start_version,
        &mut batch.transaction_accumulator_db_batches,
    )?;
    delete_per_version_data_impl::<TransactionInfoSchema>(
        ledger_db.transaction_info_db_raw(),
        start_version,
        &mut batch.transaction_info_db_batches,
    )?;
    delete_transactions_and_transaction_summary_data(
        ledger_db.transaction_db(),
        start_version,
        &mut batch.transaction_db_batches,
    )?;
    delete_per_version_data_impl::<VersionDataSchema>(
        &ledger_db.metadata_db_arc(),
        start_version,
        &mut batch.ledger_metadata_db_batches,
    )?;
    delete_per_version_data_impl::<WriteSetSchema>(
        ledger_db.write_set_db_raw(),
        start_version,
        &mut batch.write_set_db_batches,
    )?;
    // ADD THIS:
    delete_per_version_data_impl::<PersistedAuxiliaryInfoSchema>(
        ledger_db.persisted_auxiliary_info_db().db(),
        start_version,
        &mut batch.persisted_auxiliary_info_db_batches,
    )?;

    Ok(())
}
```

This ensures that auxiliary info is properly cleaned up during crash recovery, maintaining database consistency.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_partial_commit_leaves_stale_auxiliary_info() {
    use tempfile::tempdir;
    use aptos_types::transaction::*;
    
    let tmpdir = tempdir().unwrap();
    let db = AptosDB::new_for_test(tmpdir.path());
    
    // Commit initial transactions
    let txns = vec![/* create test transactions with auxiliary info */];
    db.save_transactions_for_test(&txns, 0, None, true).unwrap();
    
    // Simulate partial commit by directly writing auxiliary info
    // but not updating commit progress
    let auxiliary_info = PersistedAuxiliaryInfo::V1 { transaction_index: 1 };
    let mut batch = SchemaBatch::new();
    db.ledger_db.persisted_auxiliary_info_db()
        .put_persisted_auxiliary_info(100, &auxiliary_info, &mut batch).unwrap();
    db.ledger_db.persisted_auxiliary_info_db().write_schemas(batch).unwrap();
    
    // Close and reopen database (triggers recovery)
    drop(db);
    let db = AptosDB::new_for_test(tmpdir.path());
    
    // Verify: auxiliary info at version 100 should be gone after recovery
    // but it's not - this demonstrates the bug
    let result = db.ledger_db.persisted_auxiliary_info_db()
        .get_persisted_auxiliary_info(100).unwrap();
    
    // BUG: This assertion FAILS - stale auxiliary info still exists!
    assert!(result.is_none(), "Stale auxiliary info was not cleaned up during recovery");
}
```

This test would fail, confirming that auxiliary info is not truncated during crash recovery.

## Notes

The TODO comment at line 272-275 in `aptosdb_writer.rs` acknowledges this class of issues: [7](#0-6) 

This confirms the developers are aware that the parallel writes can cause inconsistencies that need to be "handled at startup time", but the truncation implementation is incomplete for persisted auxiliary info.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L271-319)
```rust
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
        });
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-449)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L430-462)
```rust
fn delete_per_version_data(
    ledger_db: &LedgerDb,
    start_version: Version,
    batch: &mut LedgerDbSchemaBatches,
) -> Result<()> {
    delete_per_version_data_impl::<TransactionAccumulatorRootHashSchema>(
        ledger_db.transaction_accumulator_db_raw(),
        start_version,
        &mut batch.transaction_accumulator_db_batches,
    )?;
    delete_per_version_data_impl::<TransactionInfoSchema>(
        ledger_db.transaction_info_db_raw(),
        start_version,
        &mut batch.transaction_info_db_batches,
    )?;
    delete_transactions_and_transaction_summary_data(
        ledger_db.transaction_db(),
        start_version,
        &mut batch.transaction_db_batches,
    )?;
    delete_per_version_data_impl::<VersionDataSchema>(
        &ledger_db.metadata_db_arc(),
        start_version,
        &mut batch.ledger_metadata_db_batches,
    )?;
    delete_per_version_data_impl::<WriteSetSchema>(
        ledger_db.write_set_db_raw(),
        start_version,
        &mut batch.write_set_db_batches,
    )?;

    Ok(())
}
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L76-85)
```rust
pub struct LedgerDbSchemaBatches {
    pub ledger_metadata_db_batches: SchemaBatch,
    pub event_db_batches: SchemaBatch,
    pub persisted_auxiliary_info_db_batches: SchemaBatch,
    pub transaction_accumulator_db_batches: SchemaBatch,
    pub transaction_auxiliary_data_db_batches: SchemaBatch,
    pub transaction_db_batches: SchemaBatch,
    pub transaction_info_db_batches: SchemaBatch,
    pub write_set_db_batches: SchemaBatch,
}
```

**File:** storage/aptosdb/src/ledger_db/persisted_auxiliary_info_db.rs (L121-126)
```rust
    pub(crate) fn prune(begin: Version, end: Version, batch: &mut SchemaBatch) -> Result<()> {
        for version in begin..end {
            batch.delete::<PersistedAuxiliaryInfoSchema>(&version)?;
        }
        Ok(())
    }
```
