# Audit Report

## Title
Cross-Shard Dependency Corruption Leading to Permanent Liveness Failure in Sharded Block Execution

## Summary
The sharded block executor constructs cross-shard dependencies based on unvalidated transaction write hints that can diverge from actual execution results. When a transaction's actual write set differs from its predicted write hints, dependent transactions in other shards hang indefinitely waiting for cross-shard messages that are never sent, causing complete liveness failure.

## Finding Description

The vulnerability exists in the interaction between transaction hint-based dependency construction and actual execution results in the sharded block executor.

**Phase 1: Dependency Construction from Unvalidated Hints**

Transaction write hints are extracted directly from user-controlled transaction arguments. For `coin::transfer` and `aptos_account::transfer`, the receiver address is parsed from the first argument without validation: [1](#0-0) 

These hints are used to build cross-shard dependencies. The `CrossShardCommitSender` extracts dependent edges from the sub-block's cross-shard dependencies, mapping each transaction index to the state keys that dependent shards expect: [2](#0-1) 

**Phase 2: Cross-Shard State View Initialization**

Dependent shards create `RemoteStateValue` objects in "Waiting" state for all keys in their required edges: [3](#0-2) [4](#0-3) 

When transactions read these cross-shard keys, they block indefinitely using a condition variable with **no timeout**: [5](#0-4) 

**Phase 3: Message Sending Based on Actual Writes**

When a transaction commits successfully, `send_remote_update_for_success` only sends messages for keys in the **actual write set**, not the predicted hints: [6](#0-5) 

**The Vulnerability:**

When a transaction's actual write set differs from its write hints (due to transaction abort, conditional logic, or incorrect hint assumptions), the following occurs:

1. Dependent shards create `RemoteStateValue::waiting()` for keys in the hints based on `required_edges`
2. The transaction executes but doesn't write those keys (e.g., aborts due to insufficient balance)
3. `send_remote_update_for_success()` iterates only over the actual `write_set` and sends messages only for keys that exist in both `write_set` and `dependent_edges`
4. Keys that were in hints but not in actual writes never receive messages
5. Dependent transactions call `get_state_value()` which blocks on line 32-33 waiting for values that never arrive
6. **No timeout mechanism exists** - threads hang forever using `cvar.wait(status)`

This can happen naturally with:
- Transaction aborts (insufficient balance, type mismatches)
- Conditional write paths based on runtime state
- Assumptions in hint generation (e.g., `coin::transfer` assumes receiver exists, `aptos_account::transfer` assumes receiver doesn't exist)

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under Aptos bug bounty criteria for "Total Loss of Liveness/Network Availability":

1. **Complete Chain Halt**: When dependent transactions hang waiting for cross-shard messages, the affected shards cannot make progress. Since block execution requires all shards to complete, this prevents block commitment and halts the chain.

2. **Non-Recoverable Without Intervention**: There is no timeout or recovery mechanism. The blocking uses `cvar.wait()` with no timeout parameter, resulting in indefinite hangs requiring node restarts.

3. **Consensus Liveness Violation**: All validators executing the same block will encounter the same hang deterministically, preventing block commitment and violating the liveness property of consensus.

4. **Affects All Validator Nodes**: The vulnerability triggers deterministically based on transaction execution, affecting all validators uniformly.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Trigger**: Any user can submit transactions that cause hint/execution divergence:
   - Submit a `coin::transfer` with insufficient balance â†’ transaction aborts, writes differ from hints
   - Transfer to a non-existent account with `coin::transfer` (hint assumes account exists)
   - Any conditional Move code where write paths depend on runtime state

2. **No Special Privileges Required**: Any transaction sender can trigger this without validator access or special permissions.

3. **Deterministic**: The vulnerability triggers deterministically when hints diverge from actual execution. This is a natural occurrence with:
   - Failed transactions (insufficient funds, type mismatches, assertion failures)
   - Conditional logic in Move code
   - Hint generation assumptions that don't match runtime state

4. **No Validation**: The system has no validation that write hints match actual execution results, and no timeout mechanism to recover from missing messages.

## Recommendation

1. **Add Timeout Mechanism**: Modify `RemoteStateValue::get_value()` to use `cvar.wait_timeout()` instead of indefinite `cvar.wait()`, with appropriate error handling for timeout cases.

2. **Validate Hints Against Execution**: After transaction execution, validate that all state keys in `dependent_edges` were actually written. Send explicit "no-write" messages for keys that were expected but not written.

3. **Handle Aborted Transactions**: Implement proper handling for aborted transactions with dependent edges, sending explicit abort notifications to dependent shards so they can unblock.

4. **Dynamic Dependency Tracking**: Instead of relying solely on static hints, track actual read/write sets during execution and build dependencies dynamically.

## Proof of Concept

```move
// Attacker submits a coin transfer transaction with insufficient balance
// Assuming accounts A (sender) and B (receiver) exist, and sharded execution is enabled

script {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    fun transfer_insufficient_balance(sender: &signer) {
        // This transaction will generate write hints for:
        // - sender's account resource
        // - sender's coin store
        // - receiver's coin store
        
        // But will abort during execution due to insufficient balance
        // Actual write set will be empty (abort)
        
        // Dependent shards expecting these writes will hang forever
        coin::transfer<AptosCoin>(sender, @receiver_address, 1000000000000);
    }
}
```

The proof of concept demonstrates that:
1. Write hints are generated for sender and receiver coin stores based on transaction arguments
2. If sender has insufficient balance, transaction aborts
3. Actual write set is empty (aborted transaction)
4. Dependent shards created `RemoteStateValue::waiting()` for the expected writes
5. No messages are sent (no actual writes)
6. Dependent shards block indefinitely on `cvar.wait()` with no timeout

## Notes

The core vulnerability stems from the architectural assumption that write hints accurately predict actual execution results. However, this assumption breaks in multiple realistic scenarios (transaction aborts, conditional logic, runtime state dependencies). The lack of timeout mechanisms and validation between hints and actual writes makes this a critical liveness vulnerability that can halt the entire chain.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L254-261)
```rust
                (AccountAddress::ONE, "coin", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, true)
                },
                (AccountAddress::ONE, "aptos_account", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, false)
                },
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L69-86)
```rust
        for (txn_idx, txn_with_deps) in sub_block.txn_with_index_iter() {
            let mut storage_locations_to_target = HashMap::new();
            for (txn_id_with_shard, storage_locations) in txn_with_deps
                .cross_shard_dependencies
                .dependent_edges()
                .iter()
            {
                for storage_location in storage_locations {
                    storage_locations_to_target
                        .entry(storage_location.clone().into_state_key())
                        .or_insert_with(HashSet::new)
                        .insert((txn_id_with_shard.shard_id, txn_id_with_shard.round_id));
                    num_dependent_edges += 1;
                }
            }
            if !storage_locations_to_target.is_empty() {
                dependent_edges.insert(txn_idx as TxnIndex, storage_locations_to_target);
            }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L103-134)
```rust
    fn send_remote_update_for_success(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let edges = self.dependent_edges.get(&txn_idx).unwrap();
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();

        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L26-39)
```rust
    pub fn new(cross_shard_keys: HashSet<StateKey>, base_view: &'a S) -> Self {
        let mut cross_shard_data = HashMap::new();
        trace!(
            "Initializing cross shard state view with {} keys",
            cross_shard_keys.len(),
        );
        for key in cross_shard_keys {
            cross_shard_data.insert(key, RemoteStateValue::waiting());
        }
        Self {
            cross_shard_data,
            base_view,
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L58-71)
```rust
    pub fn create_cross_shard_state_view(
        base_view: &'a S,
        transactions: &[TransactionWithDependencies<AnalyzedTransaction>],
    ) -> CrossShardStateView<'a, S> {
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
            }
        }
        CrossShardStateView::new(cross_shard_state_key, base_view)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```
