# Audit Report

## Title
Critical Signature Verification Bypass in Transaction Backup Restoration

## Summary
Transaction backups can be restored without cryptographic verification of validator signatures, allowing arbitrary ledger state to be injected into a node's database. The restoration process provides multiple code paths that skip signature verification, completely bypassing the consensus security model.

## Finding Description
The transaction backup restoration system is designed to verify `LedgerInfoWithSignatures` using validator sets from `EpochEndingBackup`. However, the implementation provides multiple ways to bypass this verification entirely:

**Bypass Path 1: `--skip-epoch-endings` flag** [1](#0-0) 

When the `--skip-epoch-endings` flag is used, `epoch_history` is set to `None`, and signature verification is completely skipped.

**Bypass Path 2: `Oneoff::Transaction` command** [2](#0-1) 

The `Oneoff::Transaction` command explicitly passes `None` for `epoch_history`, unconditionally disabling verification.

**Where Verification is Skipped:** [3](#0-2) 

When `epoch_history` is `None`, the `verify_ledger_info()` call is skipped. This means the BLS aggregate signatures in `LedgerInfoWithSignatures` are never validated against validator sets.

**What Gets Bypassed:**
The signature verification chain that should occur is:
1. `EpochHistory::verify_ledger_info()` → 
2. `EpochState::verify()` → 
3. `LedgerInfoWithSignatures::verify_signatures()` → 
4. `ValidatorVerifier::verify_multi_signatures()` [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a malicious transaction backup with fabricated `LedgerInfoWithSignatures`
2. The fabricated `LedgerInfo` can claim any `transaction_accumulator_hash`
3. The `TransactionAccumulatorRangeProof` links fake transactions to this fabricated root
4. Victim restores using `db-tool restore oneoff transaction` or with `--skip-epoch-endings`
5. Database is populated with completely unverified transaction history
6. No cryptographic proof exists that validators agreed to this state

**Additional Vulnerability - Incomplete Epoch History:** [6](#0-5) 

Even when `epoch_history` is provided, if it doesn't contain enough epochs, verification is skipped with only a warning. The comment claims "node won't be able to start if this data is malicious," but this provides no cryptographic guarantee.

## Impact Explanation
This qualifies as **Critical Severity** under Aptos bug bounty criteria for the following reasons:

1. **Consensus Safety Violation**: The fundamental security guarantee of BFT consensus is that >2/3 of validators must sign off on ledger state. This bypass allows accepting state with zero validator signatures, completely circumventing consensus.

2. **State Consistency Violation**: Per invariant #4, "State transitions must be atomic and verifiable via Merkle proofs." Without signature verification, there's no cryptographic proof linking the Merkle root to validator consensus.

3. **Cryptographic Correctness Violation**: Per invariant #10, "BLS signatures must be secure." The entire signature verification mechanism is bypassed.

4. **Real-World Harm Scenarios**:
   - Archives/explorers restored from malicious backups show fabricated history
   - RPC nodes serve fake transaction data to applications
   - Analysis tools make decisions based on unverified data
   - Validator nodes bootstrapped with fake state (though they'd desync)

While this doesn't directly steal funds from the network, it violates the core consensus security model and can lead to applications/users trusting completely fabricated ledger history.

## Likelihood Explanation
**High Likelihood** for the following reasons:

1. **Easy to Execute**: Attacker only needs to:
   - Create a malicious backup file (standard BCS serialization)
   - Host it or trick victim into using it
   - Victim runs simple restore command

2. **Multiple Attack Vectors**: Two independent code paths allow bypass

3. **Insufficient Warnings**: The `--skip-epoch-endings` flag only says "used for debugging" but doesn't warn about security implications

4. **Plausible Social Engineering**: Victim might use these flags thinking they're for performance/convenience, not realizing they disable security

5. **Documentation Gap**: No clear warnings that these restore modes are cryptographically unsafe

## Recommendation
**Immediate Fix:**

1. **Remove unsafe restore paths** or require explicit acknowledgment:
```rust
// In coordinators/restore.rs, add validation:
let epoch_history = if !self.skip_epoch_endings {
    Some(Arc::new(
        EpochHistoryRestoreController::new(/* ... */).run().await?,
    ))
} else {
    warn!("SECURITY WARNING: Skipping epoch ending verification. Database will contain UNVERIFIED data!");
    warn!("This should ONLY be used for debugging. DO NOT use in production!");
    warn!("The restored database has NO cryptographic proof of correctness.");
    // Require explicit confirmation or remove this path entirely
    None
};
```

2. **Require epoch history for transaction restore** in production mode:
```rust
// In transaction/restore.rs LoadedChunk::load:
if let Some(epoch_history) = epoch_history {
    epoch_history.verify_ledger_info(&ledger_info)?;
} else {
    // In production builds, this should be an error
    #[cfg(not(debug_assertions))]
    return Err(anyhow!(
        "Transaction backup verification requires epoch history. \
        Refusing to restore unverified backup in production mode."
    ));
    
    #[cfg(debug_assertions)]
    warn!("SECURITY WARNING: Skipping signature verification - DEBUG MODE ONLY");
}
```

3. **Fix incomplete epoch history verification**:
```rust
// In epoch_ending/restore.rs EpochHistory::verify_ledger_info:
if epoch > self.epoch_endings.len() as u64 {
    return Err(anyhow!(
        "Cannot verify ledger info for epoch {} - epoch history only contains {} epochs. \
        Refusing to accept unverified data.",
        epoch,
        self.epoch_endings.len()
    ));
}
```

4. **Add verification status to restored DB**: Store metadata indicating whether the DB was restored with full verification, so downstream applications can check.

## Proof of Concept

**Step 1: Create malicious backup**
```rust
// Create fabricated LedgerInfoWithSignatures
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_types::aggregate_signature::AggregateSignature;
use aptos_types::transaction::Version;

// Create fake ledger info claiming arbitrary state
let fake_ledger_info = LedgerInfo::new(
    /* block_info */ BlockInfo::new(/* arbitrary epoch, round, id, etc. */),
    /* consensus_data_hash */ HashValue::random(),
);

// Create empty/invalid signatures (will never verify, but won't be checked)
let fake_sigs = AggregateSignature::empty();

let unverified_li = LedgerInfoWithSignatures::new(
    fake_ledger_info,
    fake_sigs,
);

// Create fake TransactionAccumulatorRangeProof
// ... craft proof linking to fake transactions ...

// Serialize to backup file
let proof_data = bcs::to_bytes(&(range_proof, unverified_li))?;
// Write to backup storage
```

**Step 2: Restore without verification**
```bash
# Method 1: Using skip-epoch-endings flag
aptos-db-tool restore bootstrap-db \
    --metadata-cache-dir /path/to/metadata \
    --target-db-dir /path/to/target/db \
    --skip-epoch-endings \
    --target-version 1000000

# Method 2: Using oneoff transaction restore
aptos-db-tool restore oneoff transaction \
    --transaction-manifest /path/to/malicious/backup/manifest.json \
    --target-db-dir /path/to/target/db
```

**Step 3: Verify bypass occurred**
```rust
// Check that database was populated without any signature verification
// The database will contain the fake transactions with no cryptographic proof
// of validator consensus
```

The restored database now contains completely unverified ledger history with no cryptographic guarantee of correctness.

**Notes**

This vulnerability fundamentally undermines the security model of the backup system. The documentation comment explicitly states that `EpochEndingBackup` is needed for verification [7](#0-6) , yet the implementation provides multiple ways to bypass this requirement.

The issue is exacerbated by the fact that both bypass mechanisms are easily accessible through command-line tools and don't require any special privileges or code modifications. While the `--skip-epoch-endings` flag indicates it's "used for debugging," there are no runtime warnings about the severe security implications of using it.

This represents a clear violation of defense-in-depth principles - a single flag or command choice completely disables the consensus verification mechanism that is fundamental to blockchain security.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** types/src/epoch_state.rs (L41-49)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L28-31)
```rust
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
```
