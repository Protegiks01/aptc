# Audit Report

## Title
Integer Overflow Panic in Sharded Aggregator Service Delta Accumulation

## Summary
The `DeltaU128` implementation in the sharded block executor's aggregator service uses unchecked arithmetic operations that can trigger panic-induced validator node crashes when processing extreme total supply values during cross-shard aggregation.

## Finding Description

The `DeltaU128::add_delta()` and `ops::Add` implementations use unchecked addition operations that rely on Rust's overflow-checks behavior. When `minuend = u128::MAX` and `subtrahend = 0`, the `get_delta()` function correctly produces `delta = u128::MAX`, but subsequent addition operations cause arithmetic overflow. [1](#0-0) [2](#0-1) 

The vulnerability manifests in two critical locations:

1. **add_delta() function**: Line 53 performs `self.delta + other` without bounds checking. [3](#0-2) 

2. **ops::Add trait**: Line 76 performs `self.delta + rhs.delta` when accumulating deltas across shards. [4](#0-3) 

The Aptos release profile explicitly enables overflow checks: [5](#0-4) 

When overflow occurs with `overflow-checks = true`, Rust triggers a **panic** rather than wrapping. The `aggregate_and_update_total_supply` function is called during block execution without panic handling: [6](#0-5) 

This breaks the **Deterministic Execution** and **State Consistency** invariants because:
- The code claims it will "indicate to the caller of the faulty logic" but actually panics
- Different compilation modes could theoretically produce different behaviors (though release mode is standard)
- A panic during block execution crashes the validator node

## Impact Explanation

**Severity: High** - Validator Node Crash / Denial of Service

While Move framework constraints make it difficult for `total_supply` to reach u128::MAX in normal operation, the vulnerability represents a critical defensive programming failure:

1. **Immediate Impact**: If triggered, causes validator node crash via panic during block execution
2. **Network Liveness**: Multiple validator crashes could degrade network performance
3. **Determinism Violation**: Panic behavior violates the execution determinism guarantee

The realistic exploitability is limited because it requires:
- Total supply values approaching u128::MAX in transaction outputs
- Bypassing Move framework supply constraints (max supply typically << u128::MAX)
- Accumulation across multiple shards to exceed bounds

However, the code should defend against edge cases regardless of framework constraints, as:
- Future protocol changes could modify supply tracking
- State corruption bugs could inject invalid values
- The aggregator base value is set to `u128::MAX >> 1`, making the delta space effectively use the full u128 range

## Likelihood Explanation

**Likelihood: Low** under current conditions, but **Medium** considering defense-in-depth principles.

Current APT supply constraints and the `TOTAL_SUPPLY_AGGR_BASE_VAL = u128::MAX >> 1` design make overflow unlikely in production: [7](#0-6) 

However, the code should be resilient to:
- Edge cases during testing/development
- Future protocol modifications
- Potential state corruption from other bugs
- Malicious or buggy Move modules

The discrepancy between the documented behavior ("indicate to the caller") and actual behavior (panic) represents a contract violation.

## Recommendation

Replace unchecked arithmetic with explicit overflow handling:

```rust
fn add_delta(self, other: u128) -> Result<u128, ArithmeticError> {
    if self.is_positive {
        self.delta.checked_add(other)
            .ok_or(ArithmeticError::Overflow)
    } else {
        other.checked_sub(self.delta)
            .ok_or(ArithmeticError::Underflow)
    }
}

impl ops::Add for DeltaU128 {
    type Output = Result<Self, ArithmeticError>;
    
    fn add(self, rhs: Self) -> Self::Output {
        if self.is_positive == rhs.is_positive {
            let delta = self.delta.checked_add(rhs.delta)
                .ok_or(ArithmeticError::Overflow)?;
            return Ok(Self {
                delta,
                is_positive: self.is_positive,
            });
        }
        // ... handle opposite signs with checked_sub
    }
}
```

Alternatively, use `saturating_add()` if saturating behavior is acceptable, or add explicit bounds validation before aggregation.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to add with overflow")]
fn test_delta_overflow_panic() {
    // Case 1: Maximum delta + non-zero value
    let max_delta = DeltaU128::get_delta(u128::MAX, 0);
    assert_eq!(max_delta.delta, u128::MAX);
    assert!(max_delta.is_positive);
    
    // This will panic with overflow-checks=true
    let _result = max_delta.add_delta(1);
}

#[test]
#[should_panic(expected = "attempt to add with overflow")]
fn test_delta_accumulation_overflow() {
    // Case 2: Accumulating large deltas across shards
    let delta1 = DeltaU128 {
        delta: u128::MAX >> 1,
        is_positive: true,
    };
    let delta2 = DeltaU128 {
        delta: (u128::MAX >> 1) + 2,
        is_positive: true,
    };
    
    // This will panic when deltas sum exceeds u128::MAX
    let _sum = delta1 + delta2;
}
```

## Notes

While the current Move framework's supply constraints make this difficult to trigger in production, the vulnerability represents a failure of defensive programming principles. Blockchain infrastructure must be resilient to edge cases and future protocol changes. The explicit claim that overflow "will indicate to the caller" is misleadingâ€”the code actually panics, which is a more severe failure mode than returning an error.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L26-29)
```rust
/// This class ensures that deltas can use all 128 bits without having to let go of the sign bit for
/// cases where the delta is negative. That is, we don't have to use conversions to i128.
/// However, it does not handle overflow and underflow. That is, it will indicate to the caller of
/// the faulty logic with their usage of deltas.
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L37-49)
```rust
    pub fn get_delta(minuend: u128, subtrahend: u128) -> Self {
        if minuend >= subtrahend {
            Self {
                delta: minuend - subtrahend,
                is_positive: true,
            }
        } else {
            Self {
                delta: subtrahend - minuend,
                is_positive: false,
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L51-57)
```rust
    fn add_delta(self, other: u128) -> u128 {
        if self.is_positive {
            self.delta + other
        } else {
            other - self.delta
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L72-78)
```rust
    fn add(self, rhs: Self) -> Self::Output {
        // the deltas are both positive or both negative, we add the deltas and keep the sign
        if self.is_positive == rhs.is_positive {
            return Self {
                delta: self.delta + rhs.delta,
                is_positive: self.is_positive,
            };
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L215-220)
```rust
        sharded_aggregator_service::aggregate_and_update_total_supply(
            &mut sharded_output,
            &mut global_output,
            state_view.as_ref(),
            self.global_executor.get_executor_thread_pool(),
        );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L14-14)
```rust
pub const TOTAL_SUPPLY_AGGR_BASE_VAL: u128 = u128::MAX >> 1;
```
