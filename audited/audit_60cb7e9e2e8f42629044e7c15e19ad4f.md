# Audit Report

## Title
Storage Service DoS via Unbounded Small Response Requests

## Summary
The `get_transaction_data_with_proof()` function in the storage service accepts client-provided `max_response_bytes` values without enforcing a minimum threshold, allowing malicious clients to force the storage layer into serving data in arbitrarily small chunks, causing resource exhaustion through excessive database reads, proof generation overhead, and network traffic.

## Finding Description

The vulnerability exists in the storage service's handling of v2 transaction data requests. [1](#0-0) 

The code takes the minimum of the client-provided `max_response_bytes` and the server's configured maximum, with no lower bound enforcement. A malicious client can set `max_response_bytes` to extremely small values (e.g., 1 byte).

The response building logic guarantees at least one data item is always returned, regardless of size constraints. [2](#0-1) 

When `always_allow_first_item` is true and no items have been fetched yet, the response will always include at least one transaction/output, even if it exceeds the `max_response_bytes` limit.

**Attack Path:**
1. Malicious peer sends `GetTransactionDataWithProofRequest` with `max_response_bytes = 1` (or similarly tiny value)
2. Request includes a large version range (e.g., start_version=0, end_version=1000000)
3. Server computes `max_response_bytes = min(1, 40MB) = 1 byte`
4. Response progress tracker allows the first item regardless of size
5. Server returns exactly 1 transaction with proof
6. Attacker repeats the request for subsequent versions
7. Instead of ~50-100 normal requests, attacker forces 1,000,000 tiny requests

The request moderator validates whether the request can be serviced but does not check for unreasonable `max_response_bytes` values. [3](#0-2) 

The validation in `can_service()` only checks version ranges and data availability, not request parameter sanity. [4](#0-3) 

## Impact Explanation

This vulnerability causes **resource exhaustion** affecting storage service availability and performance:

1. **Database Amplification**: Each request triggers full storage reads including iterator creation, transaction info retrieval, proof generation, and accumulator range proof computation
2. **Proof Generation Overhead**: Merkle proofs and accumulator range proofs must be generated for each tiny response
3. **Network Overhead**: 1M small responses consume more bandwidth than properly-sized chunks due to per-message overhead
4. **CPU Waste**: Repeated serialization, BCS encoding, and optional compression for minimal data payloads
5. **Cache Pollution**: LRU response cache becomes ineffective as each request has different version ranges

This qualifies as **Medium severity** per Aptos bug bounty criteria:
- "Validator node slowdowns" - storage service degradation impacts validator sync performance
- "State inconsistencies requiring intervention" - extreme cases may require manual peer blocking

While not causing consensus failure or fund loss, sustained attacks can severely degrade node performance during state synchronization, particularly affecting new nodes bootstrapping or nodes recovering from downtime.

## Likelihood Explanation

**Likelihood: High**

- **No authentication barrier**: Any network peer can send storage service requests
- **Trivial to exploit**: Single parameter manipulation (`max_response_bytes`)
- **No automatic detection**: Request moderator only tracks "invalid" requests (wrong versions), not parameter abuse
- **Sustained attack feasible**: Attacker can maintain steady stream of tiny requests
- **Limited mitigation**: Moderator only blocks peers after 500 invalid requests [5](#0-4) 

The only deterrent is eventual blocking after hitting `max_invalid_requests_per_peer`, but tiny `max_response_bytes` is not flagged as invalid, so blocking won't occur automatically.

## Recommendation

Enforce a minimum threshold for `max_response_bytes` to ensure reasonable response sizes:

```rust
// In state-sync/storage-service/server/src/storage.rs
// Add constant at file level
const MIN_RESPONSE_BYTES: u64 = 10 * 1024; // 10 KB minimum

// In get_transaction_data_with_proof() function:
let max_response_bytes = min(
    transaction_data_with_proof_request.max_response_bytes.max(MIN_RESPONSE_BYTES),
    self.config.max_network_chunk_bytes_v2,
);
```

Alternative comprehensive fix with validation:

```rust
// Validate max_response_bytes in RequestModerator
impl RequestModerator {
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Existing validation...
        
        // Add parameter validation
        if let DataRequest::GetTransactionDataWithProof(req) = &request.data_request {
            if req.max_response_bytes < MIN_RESPONSE_BYTES {
                return Err(Error::InvalidRequest(format!(
                    "max_response_bytes ({}) below minimum ({})",
                    req.max_response_bytes, MIN_RESPONSE_BYTES
                )));
            }
        }
        // Similar checks for other v2 request types...
        
        Ok(())
    }
}
```

This approach treats unreasonably small `max_response_bytes` as invalid requests, allowing the moderator's existing rate limiting to block abusive peers.

## Proof of Concept

```rust
// Integration test demonstrating the attack
#[tokio::test]
async fn test_tiny_max_response_bytes_dos() {
    use aptos_storage_service_types::requests::{
        DataRequest, StorageServiceRequest,
    };
    
    // Setup storage service with test data
    let storage = create_test_storage_with_transactions(1000); // 1000 transactions
    let storage_reader = StorageReader::new(
        StorageServiceConfig::default(),
        storage,
        TimeService::real(),
    );
    
    // Malicious request with 1-byte max_response_bytes
    let malicious_request = DataRequest::get_transaction_data_with_proof(
        1000,           // proof_version
        0,              // start_version
        999,            // end_version (request 1000 transactions)
        false,          // include_events
        1,              // max_response_bytes = 1 byte (malicious!)
    );
    
    let request = StorageServiceRequest::new(malicious_request, false);
    
    let mut requests_needed = 0;
    let mut current_version = 0;
    
    // Simulate attacker making repeated requests
    while current_version < 1000 {
        let response = storage_reader
            .get_transaction_data_with_proof(&match request.data_request {
                DataRequest::GetTransactionDataWithProof(req) => req,
                _ => panic!("Wrong request type"),
            })
            .unwrap();
        
        // Extract number of transactions returned
        let num_returned = match response.transaction_list_with_proof {
            Some(ref list) => list.get_num_transactions(),
            None => 0,
        };
        
        requests_needed += 1;
        current_version += num_returned as u64;
        
        // With 1-byte limit, should return exactly 1 transaction each time
        assert_eq!(num_returned, 1, "Server should return exactly 1 transaction with tiny max_response_bytes");
    }
    
    // Attack succeeds: forces 1000 requests instead of ~2-3 normal requests
    assert_eq!(requests_needed, 1000, "DoS attack successful: forced {} requests", requests_needed);
    
    // Compare with normal request behavior
    let normal_request = DataRequest::get_transaction_data_with_proof(
        1000,
        0,
        999,
        false,
        20 * 1024 * 1024, // Normal 20MB limit
    );
    
    let response = storage_reader
        .get_transaction_data_with_proof(&match normal_request {
            DataRequest::GetTransactionDataWithProof(req) => req,
            _ => panic!(),
        })
        .unwrap();
    
    let normal_num_returned = match response.transaction_list_with_proof {
        Some(ref list) => list.get_num_transactions(),
        None => 0,
    };
    
    // Normal request returns many more transactions per request
    assert!(normal_num_returned > 100, "Normal request should return many transactions");
}
```

## Notes

This vulnerability demonstrates a **parameter validation gap** in the storage service. While the server correctly enforces an upper bound on response sizes (preventing clients from requesting excessive data), it fails to enforce a lower bound, allowing resource exhaustion through request amplification.

The fix is straightforward and should be applied to all v2 request types: `GetTransactionDataWithProofRequest`, `GetNewTransactionDataWithProofRequest`, and `SubscribeTransactionDataWithProofRequest`.

### Citations

**File:** state-sync/storage-service/server/src/storage.rs (L1150-1153)
```rust
        let max_response_bytes = min(
            transaction_data_with_proof_request.max_response_bytes,
            self.config.max_network_chunk_bytes_v2,
        );
```

**File:** state-sync/storage-service/server/src/storage.rs (L1399-1412)
```rust
    pub fn data_items_fits_in_response(
        &self,
        always_allow_first_item: bool,
        serialized_data_size: u64,
    ) -> bool {
        if always_allow_first_item && self.num_items_fetched == 0 {
            true // We always include at least one item
        } else {
            let new_serialized_data_size = self
                .serialized_data_size
                .saturating_add(serialized_data_size);
            new_serialized_data_size < self.max_response_size
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-196)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L689-808)
```rust
    /// Returns true iff the request can be serviced
    pub fn can_service(
        &self,
        aptos_data_client_config: &AptosDataClientConfig,
        time_service: TimeService,
        request: &StorageServiceRequest,
    ) -> bool {
        match &request.data_request {
            GetServerProtocolVersion | GetStorageServerSummary => true,
            GetEpochEndingLedgerInfos(request) => {
                let desired_range =
                    match CompleteDataRange::new(request.start_epoch, request.expected_end_epoch) {
                        Ok(desired_range) => desired_range,
                        Err(_) => return false,
                    };
                self.epoch_ending_ledger_infos
                    .map(|range| range.superset_of(&desired_range))
                    .unwrap_or(false)
            },
            GetNewTransactionOutputsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNewTransactionsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNewTransactionsOrOutputsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            GetNumberOfStatesAtVersion(version) => self
                .states
                .map(|range| range.contains(*version))
                .unwrap_or(false),
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
            GetTransactionOutputsWithProof(request) => self
                .can_service_transaction_outputs_with_proof(
                    request.start_version,
                    request.end_version,
                    request.proof_version,
                ),
            GetTransactionsWithProof(request) => self.can_service_transactions_with_proof(
                request.start_version,
                request.end_version,
                request.proof_version,
            ),
            GetTransactionsOrOutputsWithProof(request) => self
                .can_service_transactions_or_outputs_with_proof(
                    request.start_version,
                    request.end_version,
                    request.proof_version,
                ),
            SubscribeTransactionOutputsWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            SubscribeTransactionsOrOutputsWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            SubscribeTransactionsWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),

            // Transaction data v2 requests (transactions with auxiliary data)
            GetTransactionDataWithProof(request) => match request.transaction_data_request_type {
                TransactionDataRequestType::TransactionData(_) => self
                    .can_service_transactions_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
                TransactionDataRequestType::TransactionOutputData => self
                    .can_service_transaction_outputs_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
                TransactionDataRequestType::TransactionOrOutputData(_) => self
                    .can_service_transactions_or_outputs_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
            },
            GetNewTransactionDataWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
            SubscribeTransactionDataWithProof(_) => can_service_subscription_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
        }
    }
```

**File:** config/src/config/state_sync_config.rs (L201-201)
```rust
            max_invalid_requests_per_peer: 500,
```
