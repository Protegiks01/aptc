# Audit Report

## Title
Module Verification DoS: Expensive Bytecode Verification Performed Before Adequate Gas Metering

## Summary
The Move bytecode verifier performs expensive computational work (control flow analysis, type checking, reference safety analysis) on submitted modules without charging gas proportional to the verification complexity. Attackers can submit modules with minimal size but maximum verification complexity within verifier limits, causing validator nodes to perform expensive CPU work while only paying gas based on module byte size, enabling DoS attacks.

## Finding Description

The vulnerability exists in the module publishing flow where bytecode verification happens after only size-based gas charging, breaking the critical invariant that "all operations must respect gas limits and computational limits."

**Execution Flow:**

1. User calls `code::request_publish` native function, which charges gas based on module size: [1](#0-0) 

2. AptosVM processes the publish request, charging additional gas for old versions, new modules, and dependencies - all **size-based**: [2](#0-1) 

3. A complexity check is performed, but this **does not charge gas**, it only enforces a limit: [3](#0-2) 

4. `StagingModuleStorage::create_with_compat_config` is called, which triggers local verification: [4](#0-3) 

5. **Critical Issue:** `build_locally_verified_module()` performs expensive bytecode verification **without any gas meter parameter**: [5](#0-4) 

6. The bytecode verifier performs computationally expensive operations including control flow analysis, type checking, and reference safety analysis: [6](#0-5) 

**Attack Scenario:**

An attacker crafts modules that:
- Are small in byte size (to minimize gas cost)
- Have maximal verification complexity within verifier limits (complex control flow, deep type nesting, many local variables)
- Pass the complexity check budget formula `2048 + size * 20`
- Force expensive CodeUnitVerifier work (control flow graph construction, type analysis, etc.)

The attacker pays gas based on: `CODE_REQUEST_PUBLISH_BASE (1838) + CODE_REQUEST_PUBLISH_PER_BYTE (7) * size`

But validators must perform work bounded by verifier limits: `max_per_mod_meter_units: Some(1000 * 8000)`, which is **not** proportional to gas charged.

## Impact Explanation

**High Severity** - Validator Node Slowdowns

This vulnerability enables attackers to cause significant validator node slowdowns by submitting modules that require expensive verification work while paying minimal gas. This breaks the fundamental DoS protection mechanism (gas metering) and can degrade network performance.

Specific impacts:
1. **Validator CPU exhaustion**: Attackers can spam verification-heavy modules to consume validator CPU cycles
2. **Transaction processing delays**: While validators are busy verifying malicious modules, legitimate transactions experience delays
3. **Economic imbalance**: Attacker cost (minimal gas) << Validator cost (expensive verification), enabling sustained attacks
4. **Breaks invariant**: Violates "All operations must respect gas, storage, and computational limits"

The gas parameters show the problem: [7](#0-6) 

A small module (e.g., 1KB) costs only `1838 + 7*1024 = 9006` internal gas units, but can force verification work up to the verifier's internal limit.

## Likelihood Explanation

**High Likelihood**

1. **Easy to exploit**: Any transaction sender can submit module publishing transactions
2. **No special privileges required**: Does not require validator access or insider knowledge
3. **Deterministic**: The verification cost gap is inherent to the design
4. **Cache bypass**: First submission of any module (unique hash) must go through full verification
5. **Economically viable**: Low gas cost vs. high validator CPU cost makes sustained attacks feasible

The verifier's internal meter exists but doesn't charge transaction gas: [8](#0-7) 

## Recommendation

**Implement gas charging proportional to verification complexity:**

1. **Add gas meter parameter to verification functions:**
   - Modify `build_locally_verified_module()` to accept a gas meter parameter
   - Thread the gas meter through to `verify_module_with_config()`

2. **Charge gas based on verification work:**
   - Use the verifier's internal `BoundMeter` consumption to charge gas
   - Apply a conversion factor from verifier meter units to gas units
   - Charge gas incrementally during verification passes

3. **Alternative mitigation (if full metering is complex):**
   - Charge gas based on the complexity check result from `check_module_complexity()`
   - Since this already computes a "used" value, charge gas proportional to it
   - Formula: `charge_gas(VERIFICATION_BASE + VERIFICATION_PER_COMPLEXITY_UNIT * complexity_used)`

**Example fix for environment.rs:**

```rust
pub fn build_locally_verified_module(
    &self,
    compiled_module: Arc<CompiledModule>,
    module_size: usize,
    module_hash: &[u8; 32],
    gas_meter: &mut impl GasMeter,  // ADD GAS METER PARAMETER
) -> VMResult<LocallyVerifiedModule> {
    if !VERIFIED_MODULES_CACHE.contains(module_hash) {
        let _timer = VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");
        
        // CHARGE GAS BEFORE VERIFICATION
        let estimated_verification_cost = estimate_verification_gas(module_size);
        gas_meter.charge_verification(estimated_verification_cost)?;
        
        move_bytecode_verifier::verify_module_with_config(
            &self.vm_config().verifier_config,
            compiled_module.as_ref(),
        )?;
        check_natives(compiled_module.as_ref())?;
        VERIFIED_MODULES_CACHE.put(*module_hash);
    }
    
    Ok(LocallyVerifiedModule(compiled_module, module_size))
}
```

## Proof of Concept

**Step 1: Craft a malicious module**

Create a Move module with minimal size but maximum verification complexity:

```move
module attacker::dos_module {
    // Small module size but complex verification
    
    struct S<T1, T2, T3, T4> has copy, drop {
        f1: T1, f2: T2, f3: T3, f4: T4
    }
    
    public fun complex_verification<T1, T2, T3, T4>(
        x: u64
    ): u64 {
        // Deep nesting and complex control flow
        let result = if (x > 100) {
            if (x > 200) {
                if (x > 300) {
                    if (x > 400) {
                        // ... continue nesting ...
                        1000
                    } else { 999 }
                } else { 998 }
            } else { 997 }
        } else { 996 };
        
        // Many local variables to stress type checker
        let l1 = 1; let l2 = 2; let l3 = 3;
        // ... repeat for many locals ...
        
        result + l1 + l2 + l3
    }
}
```

**Step 2: Submit multiple publishing transactions**

```rust
// Rust PoC demonstrating the attack
use aptos_types::transaction::ModuleBundle;

fn dos_attack() {
    // Compile the malicious module
    let malicious_module_bytes = compile_module("dos_module.move");
    
    // Submit many transactions to exhaust validator CPU
    for i in 0..1000 {
        let bundle = ModuleBundle::new(vec![malicious_module_bytes.clone()]);
        
        // Each transaction pays minimal gas (based on size)
        // But forces expensive verification work
        submit_publish_transaction(sender_address, bundle);
        
        // Validator must verify each unique module variant
        // (modify slightly to get different hashes and bypass cache)
    }
    
    // Result: Validators spend significant CPU on verification
    // while attacker pays minimal gas
}
```

**Measurement to confirm vulnerability:**

1. Deploy a small module (1KB) with complex verification requirements
2. Measure actual verification time on validator node
3. Compare gas charged vs. CPU cost
4. Demonstrate the economic imbalance

**Expected result:** Verification takes 10-100ms of CPU time, but gas charged only covers ~1ms worth of computation, demonstrating the exploitable gap.

---

**Notes**

The complexity check at line 1554-1559 in aptos_vm.rs provides some protection by limiting worst-case verification work, but it does not charge gas - it only enforces a hard limit. The verifier's internal meter (max_per_mod_meter_units) similarly limits work but doesn't translate to transaction gas charges. This creates an economic imbalance where attackers can force expensive verification work while paying only size-based gas costs, enabling DoS attacks against validator nodes.

### Citations

**File:** aptos-move/framework/src/natives/code.rs (L292-299)
```rust
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1498-1543)
```rust
        if self.gas_feature_version() >= RELEASE_V1_10 {
            // Charge old versions of existing modules, in case of upgrades.
            for module in modules.iter() {
                let addr = module.self_addr();
                let name = module.self_name();

                if !traversal_context.visit_if_not_special_address(addr, name) {
                    continue;
                }

                let size_if_old_module_exists = module_storage
                    .unmetered_get_module_size(addr, name)?
                    .map(|v| v as u64);
                if let Some(old_size) = size_if_old_module_exists {
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            addr,
                            name,
                            NumBytes::new(old_size),
                        )
                        .map_err(|err| {
                            err.finish(Location::Module(ModuleId::new(*addr, name.to_owned())))
                        })?;
                }
            }

            // Charge all modules in the bundle that is about to be published.
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;

                // In case of lazy loading: add all modules in a bundle as visited to avoid double
                // charging during module initialization.
                if self.features().is_lazy_loading_enabled() {
                    traversal_context.visit_if_not_special_address(addr, name);
                }
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L252-257)
```rust
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L320-321)
```rust
        [code_request_publish_base: InternalGas, "code.request_publish.base", 1838],
        [code_request_publish_per_byte: InternalGasPerByte, "code.request_publish.per_byte", 7],
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L46-76)
```rust
    fn verify_module_impl(
        verifier_config: &VerifierConfig,
        module: &CompiledModule,
    ) -> PartialVMResult<()> {
        let mut meter = BoundMeter::new(verifier_config);
        let mut name_def_map = HashMap::new();
        for (idx, func_def) in module.function_defs().iter().enumerate() {
            let fh = module.function_handle_at(func_def.function);
            name_def_map.insert(fh.name, FunctionDefinitionIndex(idx as u16));
        }
        let mut total_back_edges = 0;
        for (idx, function_definition) in module.function_defs().iter().enumerate() {
            let index = FunctionDefinitionIndex(idx as TableIndex);
            let num_back_edges = Self::verify_function(
                verifier_config,
                index,
                function_definition,
                module,
                &name_def_map,
                &mut meter,
            )
            .map_err(|err| err.at_index(IndexKind::FunctionDefinition, index.0))?;
            total_back_edges += num_back_edges;
        }
        if let Some(limit) = verifier_config.max_back_edges_per_module {
            if total_back_edges > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_BACK_EDGES));
            }
        }
        Ok(())
    }
```
