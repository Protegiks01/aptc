# Audit Report

## Title
FeePayer/MultiAgent Transaction Filter Bypass via Secondary Signer Length Mismatch

## Summary
The transaction filter function `matches_transaction_authenticator_address()` incorrectly handles FeePayer and MultiAgent transactions where `secondary_signer_addresses` and `secondary_signers` have mismatched lengths, allowing filter bypass and mempool resource exhaustion attacks.

## Finding Description

The vulnerability exists in the transaction filtering logic that validates whether a transaction involves a specific address. [1](#0-0) 

For FeePayer and MultiAgent transactions, the function checks if an address is involved by examining both `secondary_signer_addresses` (a list of addresses) and `secondary_signers` (a list of authenticators). However, there is **no validation** that these two lists have matching lengths when transactions are constructed. [2](#0-1) 

The transaction authenticator constructors accept these vectors without validation: [3](#0-2) 

The critical flaw is that the filter uses OR logic to check if an address is involved:
- `secondary_signer_addresses.contains(address)` checks the addresses list
- `secondary_signers.iter().any(...)` checks the authenticators

For standard Ed25519/MultiEd25519 authenticators, the authenticator check returns false (it only returns true for special types like FederatedKeyless or Abstract authenticators that embed addresses). [4](#0-3) 

**Attack Path:**

1. Attacker constructs a FeePayer transaction with:
   - `secondary_signer_addresses = [ADDR_A, ADDR_B, ADDR_C]`
   - `secondary_signers = [auth_for_ADDR_A]` (only one authenticator)

2. The transaction passes through mempool filtering where `matches_transaction_authenticator_address()` is called.

3. When checking if ADDR_B or ADDR_C are involved:
   - `secondary_signer_addresses.contains(ADDR_B)` returns TRUE
   - Filter incorrectly concludes ADDR_B is involved
   - Transaction is processed based on this incorrect determination

4. Transaction enters mempool, consumes resources, gets propagated to validators. [5](#0-4) 

5. During execution, the prologue validation catches the mismatch and rejects the transaction. [6](#0-5) 

However, by this point the attacker has achieved:
- **Filter bypass**: Transactions that should be denied based on secondary signer rules entered the mempool
- **Resource exhaustion**: Mempool space and validator CPU cycles wasted processing invalid transactions
- **DoS amplification**: If filters are configured to deny transactions involving certain addresses, attackers can flood the system with malformed transactions claiming to involve those addresses

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:

1. **Validator node slowdowns**: An attacker can flood the network with malformed FeePayer transactions that bypass filter rules, forcing validators to process transactions that should have been filtered out early. Each transaction consumes mempool space, network bandwidth, and validator CPU cycles up to prologue execution before being rejected.

2. **Significant protocol violations**: The transaction filter is a critical security boundary designed to protect nodes from unwanted transactions. This bypass allows attackers to circumvent configured security policies, defeating the purpose of the filtering system. The filter's determination of which addresses are involved in a transaction is fundamentally broken for mismatched-length scenarios.

3. **Mempool pollution**: Filters are often configured to deny transactions from specific addresses for compliance, rate-limiting, or anti-spam purposes. This vulnerability allows those protections to be bypassed, potentially overwhelming the mempool with spam.

The impact is amplified because:
- No special privileges are required to exploit this
- The attack can be automated and scaled
- The prologue validation happens AFTER mempool admission and network propagation
- Different validators may have different filter configurations, creating consensus delays

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Easy to trigger**: Any transaction sender can construct malformed transactions using `SignedTransaction::new_fee_payer()` or `new_multi_agent()` directly without using the signing helper methods that validate length matching. [7](#0-6) 

2. **No validation barriers**: The API layer validation for `FeePayerSignature` does NOT check length matching (unlike `MultiAgentSignature` which does). [8](#0-7) 

3. **Widespread filter usage**: Transaction filters are commonly deployed in production environments for DoS protection, compliance, and resource management.

4. **Low attack cost**: Creating malformed transactions requires minimal resources while causing disproportionate impact on victim nodes.

5. **Detection difficulty**: The attack traffic appears as normal FeePayer transactions until prologue validation, making it hard to distinguish from legitimate traffic at the filter layer.

## Recommendation

**Immediate Fix**: Add length validation to transaction construction and filtering:

1. **In `SignedTransaction` constructors**, validate length matching:

```rust
pub fn new_fee_payer(
    raw_txn: RawTransaction,
    sender: AccountAuthenticator,
    secondary_signer_addresses: Vec<AccountAddress>,
    secondary_signers: Vec<AccountAuthenticator>,
    fee_payer_address: AccountAddress,
    fee_payer_signer: AccountAuthenticator,
) -> Result<Self> {
    // Add validation
    if secondary_signer_addresses.len() != secondary_signers.len() {
        return Err(format_err!(
            "Secondary signer addresses ({}) and signers ({}) length mismatch",
            secondary_signer_addresses.len(),
            secondary_signers.len()
        ));
    }
    
    let authenticator = TransactionAuthenticator::fee_payer(
        sender,
        secondary_signer_addresses,
        secondary_signers,
        fee_payer_address,
        fee_payer_signer,
    );
    Ok(Self::new_signed_transaction(raw_txn, authenticator))
}
```

2. **In `FeePayerSignature::verify()`**, add the same check that exists for `MultiAgentSignature`:

```rust
impl VerifyInput for FeePayerSignature {
    fn verify(&self) -> anyhow::Result<()> {
        self.sender.verify()?;
        
        // Add length validation
        if !self.secondary_signer_addresses.is_empty() 
            && self.secondary_signers.len() != self.secondary_signer_addresses.len() {
            bail!("FeePayer signatures don't match addresses length")
        }
        
        for signer in self.secondary_signers.iter() {
            signer.verify()?;
        }
        self.fee_payer_signer.verify()?;
        Ok(())
    }
}
```

3. **In the filter logic** (defense in depth), add early validation:

```rust
fn matches_transaction_authenticator_address(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
) -> bool {
    match signed_transaction.authenticator_ref() {
        TransactionAuthenticator::MultiAgent {
            secondary_signer_addresses,
            secondary_signers,
            ..
        } => {
            // Reject malformed transactions
            if secondary_signer_addresses.len() != secondary_signers.len() {
                return false;
            }
            // ... rest of logic
        },
        TransactionAuthenticator::FeePayer {
            secondary_signer_addresses,
            secondary_signers,
            ..
        } => {
            // Reject malformed transactions  
            if secondary_signer_addresses.len() != secondary_signers.len() {
                return false;
            }
            // ... rest of logic
        },
        // ... other cases
    }
}
```

## Proof of Concept

```rust
use aptos_types::transaction::{
    authenticator::{AccountAuthenticator, TransactionAuthenticator},
    SignedTransaction, RawTransaction, TransactionPayload, Script,
};
use aptos_types::account_address::AccountAddress;
use aptos_types::chain_id::ChainId;
use aptos_transaction_filters::transaction_filter::TransactionFilter;

#[test]
fn test_fee_payer_length_mismatch_filter_bypass() {
    // Create a raw transaction
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        1000000,
        1,
        99999999999,
        ChainId::new(1),
    );

    // Create malformed FeePayer transaction with length mismatch
    let victim_addr = AccountAddress::random();
    let attacker_addr = AccountAddress::random();
    
    // Addresses list includes victim, but no corresponding authenticator
    let secondary_signer_addresses = vec![victim_addr, attacker_addr];
    let secondary_signers = vec![AccountAuthenticator::NoAccountAuthenticator]; // Only 1, not 2!
    
    let signed_txn = SignedTransaction::new_fee_payer(
        raw_txn,
        AccountAuthenticator::NoAccountAuthenticator,
        secondary_signer_addresses,
        secondary_signers,
        AccountAddress::random(),
        AccountAuthenticator::NoAccountAuthenticator,
    );

    // Create filter that should DENY transactions involving victim_addr
    let filter = TransactionFilter::empty()
        .add_account_address_filter(false, victim_addr); // Deny victim_addr

    // BUG: Filter incorrectly rejects this transaction even though victim_addr
    // doesn't actually have an authenticator (will fail in prologue anyway)
    assert_eq!(
        filter.allows_transaction(&signed_txn),
        false, // Transaction is rejected based on victim_addr being in addresses list
        "Filter should have rejected transaction claiming victim involvement"
    );
    
    // The transaction WILL fail in prologue with PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH
    // but it has already wasted resources by passing the filter and entering mempool
}
```

## Notes

The vulnerability stems from a defense-in-depth gap where the mempool filter layer makes assumptions about transaction validity that are only enforced later in the prologue. While the prologue correctly validates length matching, the filter operates on potentially malformed data, leading to incorrect filtering decisions.

This affects both FeePayer and MultiAgent transaction types, though FeePayer is more concerning due to the missing API-layer validation in `FeePayerSignature::verify()`.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L259-280)
```rust
fn matches_account_authenticator_address(
    account_authenticator: &AccountAuthenticator,
    address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match account_authenticator {
        AccountAuthenticator::Ed25519 { .. }
        | AccountAuthenticator::MultiEd25519 { .. }
        | AccountAuthenticator::NoAccountAuthenticator => false,
        AccountAuthenticator::SingleKey { authenticator } => {
            matches_any_public_key_address(authenticator.public_key(), address)
        },
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|any_public_key| matches_any_public_key_address(any_public_key, address)),
        AccountAuthenticator::Abstract { authenticator } => {
            authenticator.function_info().module_address == *address
        },
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L493-531)
```rust
fn matches_transaction_authenticator_address(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.authenticator_ref() {
        TransactionAuthenticator::Ed25519 { .. }
        | TransactionAuthenticator::MultiEd25519 { .. } => false,
        TransactionAuthenticator::MultiAgent {
            sender,
            secondary_signer_addresses,
            secondary_signers,
        } => {
            matches_account_authenticator_address(sender, address)
                || secondary_signer_addresses.contains(address)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_address(signer, address))
        },
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signer_addresses,
            secondary_signers,
            fee_payer_address,
            fee_payer_signer,
        } => {
            matches_account_authenticator_address(sender, address)
                || secondary_signer_addresses.contains(address)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_address(signer, address))
                || fee_payer_address == address
                || matches_account_authenticator_address(fee_payer_signer, address)
        },
        TransactionAuthenticator::SingleSender { sender } => {
            matches_account_authenticator_address(sender, address)
        },
    }
}
```

**File:** types/src/transaction/mod.rs (L412-461)
```rust
    pub fn sign_fee_payer(
        self,
        sender_private_key: &Ed25519PrivateKey,
        secondary_signers: Vec<AccountAddress>,
        secondary_private_keys: Vec<&Ed25519PrivateKey>,
        fee_payer_address: AccountAddress,
        fee_payer_private_key: &Ed25519PrivateKey,
    ) -> Result<SignatureCheckedTransaction> {
        let message = RawTransactionWithData::new_fee_payer(
            self.clone(),
            secondary_signers.clone(),
            fee_payer_address,
        );
        let sender_signature = sender_private_key.sign(&message)?;
        let sender_authenticator = AccountAuthenticator::ed25519(
            Ed25519PublicKey::from(sender_private_key),
            sender_signature,
        );

        if secondary_private_keys.len() != secondary_signers.len() {
            return Err(format_err!(
                "number of secondary private keys and number of secondary signers don't match"
            ));
        }
        let mut secondary_authenticators = vec![];
        for priv_key in secondary_private_keys {
            let signature = priv_key.sign(&message)?;
            secondary_authenticators.push(AccountAuthenticator::ed25519(
                Ed25519PublicKey::from(priv_key),
                signature,
            ));
        }

        let fee_payer_signature = fee_payer_private_key.sign(&message)?;
        let fee_payer_authenticator = AccountAuthenticator::ed25519(
            Ed25519PublicKey::from(fee_payer_private_key),
            fee_payer_signature,
        );

        Ok(SignatureCheckedTransaction(
            SignedTransaction::new_fee_payer(
                self,
                sender_authenticator,
                secondary_signers,
                secondary_authenticators,
                fee_payer_address,
                fee_payer_authenticator,
            ),
        ))
    }
```

**File:** types/src/transaction/mod.rs (L1135-1174)
```rust
    pub fn new_fee_payer(
        raw_txn: RawTransaction,
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
        fee_payer_address: AccountAddress,
        fee_payer_signer: AccountAuthenticator,
    ) -> Self {
        let authenticator = TransactionAuthenticator::fee_payer(
            sender,
            secondary_signer_addresses,
            secondary_signers,
            fee_payer_address,
            fee_payer_signer,
        );
        Self::new_signed_transaction(raw_txn, authenticator)
    }

    pub fn new_multisig(
        raw_txn: RawTransaction,
        public_key: MultiEd25519PublicKey,
        signature: MultiEd25519Signature,
    ) -> SignedTransaction {
        let authenticator = TransactionAuthenticator::multi_ed25519(public_key, signature);
        Self::new_signed_transaction(raw_txn, authenticator)
    }

    pub fn new_multi_agent(
        raw_txn: RawTransaction,
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
    ) -> Self {
        let authenticator = TransactionAuthenticator::multi_agent(
            sender,
            secondary_signer_addresses,
            secondary_signers,
        );
        Self::new_signed_transaction(raw_txn, authenticator)
    }
```

**File:** types/src/transaction/authenticator.rs (L86-102)
```rust
    MultiAgent {
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
    },
    /// Optional Multi-agent transaction with a fee payer.
    FeePayer {
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
        fee_payer_address: AccountAddress,
        fee_payer_signer: AccountAuthenticator,
    },
    SingleSender {
        sender: AccountAuthenticator,
    },
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-460)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L385-388)
```text
        let num_secondary_signers = vector::length(&secondary_signer_addresses);
        assert!(
            vector::length(&secondary_signer_public_key_hashes) == num_secondary_signers,
            error::invalid_argument(PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH),
```

**File:** api/types/src/transaction.rs (L2334-2343)
```rust
impl VerifyInput for FeePayerSignature {
    fn verify(&self) -> anyhow::Result<()> {
        self.sender.verify()?;

        for signer in self.secondary_signers.iter() {
            signer.verify()?;
        }
        self.fee_payer_signer.verify()?;
        Ok(())
    }
```
