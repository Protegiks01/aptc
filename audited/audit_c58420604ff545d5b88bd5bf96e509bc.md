# Audit Report

## Title
Metadata Validation Bypass for Version 5 Modules Enables Incorrect Resource Group Routing

## Summary
A discrepancy exists between metadata processing during module publishing versus runtime resource access. Version 5 modules with V1 metadata have their `struct_attributes` and `fun_attributes` cleared during publishing validation but not during runtime, allowing publication of modules with invalid resource group metadata that can cause incorrect storage routing and potential consensus issues.

## Finding Description

The vulnerability stems from inconsistent metadata handling across two code paths:

**During Module Publishing:** [1](#0-0) 

The `get_metadata_from_compiled_code()` function specifically clears `struct_attributes` and `fun_attributes` for version 5 modules before validation occurs.

**During Runtime Resource Access:** [2](#0-1) 

The `get_metadata()` function does NOT clear these attributes for version 5 modules, using the raw deserialized metadata instead.

This discrepancy is exploitable through the following path:

1. **Metadata Access at Runtime:** [3](#0-2) 

The `load_module_for_metadata` implementation retrieves deserialized (unverified) modules for metadata access.

2. **Resource Group Routing Decision:** [4](#0-3) 

The metadata is used to determine resource group membership, which affects storage routing.

3. **Storage Path Selection:** [5](#0-4) 

Based on the metadata, resources are loaded from either resource groups or regular storage.

**Attack Scenario:**

1. Attacker manually crafts a version 5 bytecode module with V1 metadata containing resource group member attributes
2. During publishing, `verify_module_metadata_for_module_publishing` calls `get_metadata_from_compiled_code`, which clears the attributes before validation [6](#0-5) 

3. Validation passes because no resource group attributes are visible
4. Module is published on-chain with the crafted metadata intact
5. At runtime, when accessing resources from this module, `get_metadata()` is called WITHOUT clearing version 5 attributes
6. The system incorrectly identifies resources as resource group members
7. Storage routing attempts to load from non-existent or wrong resource groups, causing failures or incorrect data access

**Note:** Version 5 is explicitly supported as the minimum version: [7](#0-6) 

The metadata format check does not validate version compatibility: [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria:

- **State Inconsistencies**: Resources may be accessed from incorrect storage locations, leading to transaction failures or incorrect state reads
- **Validation Bypass**: The publishing validation is circumvented, allowing invalid module metadata to persist on-chain
- **Deterministic Execution Risk**: While all validators would behave consistently (all using the wrong routing), this creates undefined behavior when accessing resources from affected modules

The impact is limited because:
- Requires manual bytecode crafting (not producible by standard compiler)
- Only affects modules the attacker can publish
- Does not directly cause consensus divergence (all validators make the same incorrect decision)

However, it enables:
- Publishing modules that should fail validation
- Incorrect resource access patterns at runtime
- Potential DoS if resource groups don't exist
- State access inconsistencies requiring manual intervention

## Likelihood Explanation

**Likelihood: Medium**

- Requires technical sophistication to manually craft version 5 bytecode with V1 metadata
- Standard Move compiler prevents this by only adding V1 metadata to version 6+ modules: [9](#0-8) 

- However, bytecode can be manually constructed and published via transaction
- No runtime validation prevents version 5 modules from having V1 metadata
- Once published, the module affects all subsequent resource accesses

## Recommendation

Add validation during module publishing to enforce that version 5 modules cannot have V1 metadata with struct/function attributes:

```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                // NEW: Validate version compatibility
                if module.version < METADATA_V1_MIN_FILE_FORMAT_VERSION {
                    return Err(MalformedError::UnknownKey(format!(
                        "V1 metadata not supported for version {}",
                        module.version
                    ).into_bytes()));
                }
                let metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
                // NEW: Validate v5 modules have no attributes
                if module.version == 5 && (!metadata.struct_attributes.is_empty() || !metadata.fun_attributes.is_empty()) {
                    return Err(MalformedError::UnknownKey(
                        "Version 5 modules cannot have struct/function attributes".as_bytes().to_vec()
                    ));
                }
            }
        }
        // ... rest of validation
    }
    Ok(())
}
```

Alternatively, unify the metadata extraction logic by always using the same function that applies version-specific clearing consistently across both publishing and runtime paths.

## Proof of Concept

```rust
// Proof of Concept: Creating a malicious version 5 module with V1 metadata

use move_binary_format::{CompiledModule, file_format::*, file_format_common::VERSION_5};
use move_core_types::metadata::Metadata;
use types::vm::module_metadata::{RuntimeModuleMetadataV1, KnownAttribute, APTOS_METADATA_KEY_V1};
use std::collections::BTreeMap;

fn create_malicious_v5_module() -> CompiledModule {
    // Create a basic version 5 module structure
    let mut module = CompiledModule {
        version: VERSION_5,
        // ... initialize other required fields ...
        metadata: vec![],
        // ... rest of module structure ...
    };
    
    // Create V1 metadata with resource group member attribute
    let mut v1_metadata = RuntimeModuleMetadataV1::default();
    let mut struct_attrs = Vec::new();
    
    // Add resource group member attribute pointing to non-existent group
    struct_attrs.push(KnownAttribute::resource_group_member(
        "0xBAD::malicious::FakeResourceGroup".to_string()
    ));
    
    v1_metadata.struct_attributes.insert(
        "MaliciousResource".to_string(),
        struct_attrs
    );
    
    // Serialize and add to module
    let serialized = bcs::to_bytes(&v1_metadata).unwrap();
    module.metadata.push(Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: serialized,
    });
    
    module
}

// At publishing time:
// - verify_module_metadata_for_module_publishing is called
// - get_metadata_from_compiled_code clears struct_attributes for v5
// - Validation sees no resource groups → PASSES

// At runtime resource access:
// - load_module_for_metadata returns deserialized module
// - get_metadata does NOT clear struct_attributes for v5
// - get_resource_group_member_from_metadata returns FakeResourceGroup
// - System attempts to load from non-existent resource group → ERROR or WRONG DATA
```

## Notes

The vulnerability exists because the comment in the code states: *"Clear out metadata for v5, since it shouldn't have existed in the first place and isn't being used. Note, this should have been gated in the verify module metadata."* This indicates awareness that such gating should have been implemented but was not, leaving the validation gap exploitable.

### Citations

**File:** types/src/vm/module_metadata.rs (L199-230)
```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else if let Some(data) = find_metadata(md, APTOS_METADATA_KEY) {
        V0_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .ok()
                    .map(RuntimeModuleMetadata::upgrade)
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L240-251)
```rust
    fn load_module_for_metadata(
        &self,
        _gas_meter: &mut impl DependencyGasMeter,
        _traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
    ) -> PartialVMResult<Arc<CompiledModule>> {
        // Note:
        //   For backwards compatibility, metadata accesses were never metered.
        self.module_storage
            .unmetered_get_existing_deserialized_module(module_id.address(), module_id.name())
            .map_err(|err| err.to_partial())
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L50-60)
```rust
pub fn get_resource_group_member_from_metadata(
    struct_tag: &StructTag,
    metadata: &[Metadata],
) -> Option<StructTag> {
    let metadata = get_metadata(metadata)?;
    metadata
        .struct_attributes
        .get(struct_tag.name.as_ident_str().as_str())?
        .iter()
        .find_map(|attr| attr.get_resource_group_member())
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1715-1716)
```rust
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L561-562)
```rust
/// Mark which oldest version is supported.
pub const VERSION_MIN: u32 = VERSION_5;
```

**File:** aptos-move/framework/src/built_package.rs (L623-624)
```rust
                        if bytecode_version.unwrap_or(METADATA_V1_MIN_FILE_FORMAT_VERSION)
                            >= METADATA_V1_MIN_FILE_FORMAT_VERSION
```
