# Audit Report

## Title
Critical Validator Crash via Native Struct Publishing Bypass

## Summary
An attacker can crash any Aptos validator node by publishing a Move module containing a native struct definition. The bytecode verifier allows native structs to bypass ability validation checks, but the runtime loader explicitly panics when encountering such structs, causing immediate validator termination and network disruption.

## Finding Description

The vulnerability exists in a validation gap between three components:

**1. Module Builder allows native structs without field validation:**

The `declare_struct()` function creates structs with `StructFieldInformation::Native` and accepts arbitrary `abilities` parameters without validating that these abilities can be satisfied by the (non-existent) native implementation. [1](#0-0) 

**2. Bytecode Verifier skips validation for native structs:**

The `verify_struct_def()` function explicitly returns early for native structs without performing any ability constraint validation against fields, since native structs have no Move-level fields. [2](#0-1) 

**3. Native validation only checks functions, not structs:**

The module publishing validation only checks native functions for special address restrictions, completely missing native struct validation. [3](#0-2) 

**4. Runtime loader panics on native structs:**

When the VM attempts to load a module with a native struct during publishing initialization, the `make_struct_type()` function hits an `unreachable!()` macro that immediately panics the validator process. [4](#0-3) 

**Attack Path:**

1. Attacker uses move-asm to create a malicious module with a native struct (e.g., `native struct Exploit has copy;`)
2. Attacker submits a transaction calling `code::publish_package()` with this module
3. During transaction execution, `validate_publish_request()` calls `validate_module_natives()` which only checks native functions - native structs pass through
4. The module proceeds to `finish_with_module_publishing_and_initialization()`
5. During module initialization, `build_locally_verified_module()` is called, which invokes `Module::new()`
6. `Module::new()` calls `make_struct_type()` for the native struct
7. The `unreachable!("native structs have been removed")` is triggered
8. Validator process crashes immediately [5](#0-4) [6](#0-5) 

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000)

This vulnerability causes **Total loss of liveness/network availability**:

- Any validator processing the malicious transaction will immediately crash via panic
- All validators that attempt to execute the block containing this transaction will crash
- The network becomes partitioned as validators crash one by one during block execution
- Recovery requires manual intervention to remove the malicious transaction from the block
- In the worst case, this could require a hard fork if the transaction is already committed to multiple validator states

The attack breaks the **Deterministic Execution** invariant: validators that process the transaction crash instead of producing a valid state root, while validators that haven't processed it yet continue running, creating a consensus failure.

It also violates the **Move VM Safety** invariant: the panic bypasses all normal error handling and gas metering, causing undefined behavior in the validator process.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable:
- No special permissions required - any user can submit module publishing transactions
- No resource requirements - the malicious module can be extremely small
- No timing constraints - the attack works at any time
- No prior state requirements - doesn't depend on existing on-chain state
- Tools already exist - move-asm is part of the standard Move toolkit
- No economic cost beyond transaction gas fees

The only requirement is creating a simple Move assembly file with a native struct declaration and compiling it with move-asm, which is straightforward.

## Recommendation

Add native struct validation to the module publishing flow by extending `validate_module_natives()` to check both native functions AND native structs:

```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        
        // Check native functions
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message(
                            "Cannot publish native function to non-special address".to_string(),
                        )
                        .finish(Location::Module(module.self_id())),
                );
            }
        }
        
        // Check native structs
        for struct_def in module.struct_defs() {
            if matches!(struct_def.field_information, StructFieldInformation::Native) {
                if !module_address.is_special() {
                    return Err(
                        PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                            .with_message(
                                "Cannot publish native struct to non-special address".to_string(),
                            )
                            .finish(Location::Module(module.self_id())),
                    );
                }
            }
        }
    }
    Ok(())
}
```

Additionally, replace the `unreachable!()` with a proper error return to prevent panic-based crashes even if validation is bypassed:

```rust
StructFieldInformation::Native => {
    return Err(PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
        .with_message("Native structs are not supported".to_string()))
}
```

## Proof of Concept

**Step 1:** Create a malicious Move assembly file `exploit.masm`:

```move-asm
module 0xBAD.Exploit {
    native struct MaliciousStruct has copy, drop, store;
    
    public entry fun trigger() {
        // Function body not needed - module loading will crash
        return;
    }
}
```

**Step 2:** Compile with move-asm:

```bash
move-asm exploit.masm -o exploit.mv
```

**Step 3:** Submit transaction to publish the module using the Aptos CLI or SDK, calling `aptos_framework::code::publish_package()` with the compiled bytecode.

**Expected Result:** The validator processing this transaction will crash with:
```
thread 'main' panicked at 'native structs have been removed', third_party/move/move-vm/runtime/src/loader/modules.rs:453:44
```

This causes immediate validator termination and network disruption.

---

**Notes:**
- The vulnerability affects all Aptos validators running the current codebase
- The attack can be repeated indefinitely, causing persistent denial of service
- The fix requires adding validation in multiple layers for defense in depth
- Historical native struct support was removed but validation was not added to prevent their publication

### Citations

**File:** third_party/move/tools/move-asm/src/module_builder.rs (L272-323)
```rust
    pub fn declare_struct(
        &mut self,
        name: Identifier,
        type_parameters: Vec<(AbilitySet, bool)>,
        abilities: AbilitySet,
    ) -> Result<StructDefinitionIndex> {
        if self.is_script() {
            bail!("script cannot have struct definitions")
        }
        if self.options.validate {
            let module_ref = self.module.borrow();
            let module = &*module_ref;
            for sdef in &module.struct_defs {
                let view = StructDefinitionView::new(module, sdef);
                if view.name() == name.as_ref() {
                    bail!("duplicate struct definition `{}`", name);
                }
            }
        }
        let full_name = self.this_module_id(name.clone());
        let name_idx = self.name_index(name.clone())?;
        let shdl = StructHandle {
            module: self.this_module_idx,
            name: name_idx,
            abilities,
            type_parameters: type_parameters
                .into_iter()
                .map(|(constraints, is_phantom)| StructTypeParameter {
                    constraints,
                    is_phantom,
                })
                .collect(),
        };
        let shdl_idx = self.index(
            &mut self.module.borrow_mut().struct_handles,
            &mut self.struct_to_idx.borrow_mut(),
            full_name,
            shdl,
            StructHandleIndex,
            "struct handle",
        )?;
        let sdef = StructDefinition {
            struct_handle: shdl_idx,
            // Will be later set by `define_struct_layout`
            field_information: StructFieldInformation::Native,
        };
        let new_idx = self.module.borrow().struct_defs.len();
        self.bounds_check(new_idx, TableIndex::MAX, "struct definition index")?;
        let sidx = StructDefinitionIndex(new_idx as TableIndex);
        self.module.borrow_mut().struct_defs.push(sdef);
        Ok(sidx)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1071-1101)
```rust
    fn verify_struct_def(&self, struct_def: &StructDefinition) -> PartialVMResult<()> {
        let struct_handle = self.resolver.struct_handle_at(struct_def.struct_handle);
        let context = struct_handle
            .type_param_constraints()
            .enumerate()
            .map(|(idx, abilities)| (idx as TypeParameterIndex, abilities))
            .collect::<BitsetTypeParameterConstraints<N>>();

        let required_abilities_conditional = struct_handle.abilities.requires();
        let context_all_abilities = (0..struct_handle.type_parameters.len())
            .map(|idx| (idx as TypeParameterIndex, AbilitySet::ALL))
            .collect::<BitsetTypeParameterConstraints<N>>();

        match &struct_def.field_information {
            StructFieldInformation::Native => Ok(()),
            StructFieldInformation::Declared(fields) => self.verify_fields_of_struct(
                struct_handle,
                &context,
                required_abilities_conditional,
                &context_all_abilities,
                fields.iter(),
            ),
            StructFieldInformation::DeclaredVariants(variants) => self.verify_fields_of_struct(
                struct_handle,
                &context,
                required_abilities_conditional,
                &context_all_abilities,
                variants.iter().flat_map(|v| v.fields.iter()),
            ),
        }
    }
```

**File:** aptos-move/aptos-vm/src/verifier/native_validation.rs (L12-28)
```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message(
                            "Cannot publish native function to non-special address".to_string(),
                        )
                        .finish(Location::Module(module.self_id())),
                );
            }
        }
    }
    Ok(())
}
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L444-476)
```rust
    fn make_struct_type(
        module: &CompiledModule,
        struct_def: &StructDefinition,
        struct_name_table: &[StructNameIndex],
    ) -> PartialVMResult<StructType> {
        let struct_handle = module.struct_handle_at(struct_def.struct_handle);
        let abilities = struct_handle.abilities;
        let ty_params = struct_handle.type_parameters.clone();
        let layout = match &struct_def.field_information {
            StructFieldInformation::Native => unreachable!("native structs have been removed"),
            StructFieldInformation::Declared(fields) => {
                let fields: PartialVMResult<Vec<(Identifier, Type)>> = fields
                    .iter()
                    .map(|f| Self::make_field(module, f, struct_name_table))
                    .collect();
                StructLayout::Single(fields?)
            },
            StructFieldInformation::DeclaredVariants(variants) => {
                let variants: PartialVMResult<Vec<(Identifier, Vec<(Identifier, Type)>)>> =
                    variants
                        .iter()
                        .map(|v| {
                            let fields: PartialVMResult<Vec<(Identifier, Type)>> = v
                                .fields
                                .iter()
                                .map(|f| Self::make_field(module, f, struct_name_table))
                                .collect();
                            fields.map(|fields| (module.identifier_at(v.name).to_owned(), fields))
                        })
                        .collect();
                StructLayout::Variants(variants?)
            },
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1690)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```
