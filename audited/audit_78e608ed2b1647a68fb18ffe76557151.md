# Audit Report

## Title
SSRF Vulnerability in Validator Network Address Discovery Due to Missing Address Validation

## Summary
Malicious validator operators can inject arbitrary network addresses (including internal/private IPs, localhost, and cloud metadata endpoints) into the on-chain validator configuration without any validation. These addresses are then used by honest validators during peer discovery, causing them to initiate TCP connections to attacker-controlled targets, resulting in Server-Side Request Forgery (SSRF) attacks.

## Finding Description

The vulnerability exists in the validator address update and discovery flow:

**1. Address Injection Point (No Validation)**

The `update_network_and_fullnode_addresses()` function accepts arbitrary BCS-encoded addresses without validation: [1](#0-0) 

The function directly assigns the raw byte vectors to the validator configuration without checking if they contain valid, safe network addresses. There is no validation for:
- Private IP ranges (RFC1918: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
- Localhost addresses (127.0.0.0/8)
- Link-local addresses (169.254.0.0/16, including AWS metadata at 169.254.169.254)
- DNS names that resolve to internal IPs

**2. Address Extraction Without Validation**

During validator discovery, these addresses are extracted and deserialized: [2](#0-1) 

The addresses are deserialized from BCS at lines 123-130, but only basic BCS deserialization occurs with no security validation: [3](#0-2) 

**3. Direct Connection to Malicious Addresses**

The extracted addresses are used to create `Peer` objects without validation: [4](#0-3) 

These addresses are then directly used for TCP connections via the transport layer: [5](#0-4) 

The `resolve_and_connect` function performs DNS resolution and TCP connection establishment to whatever address is provided, including:
- Direct IP connections (line 232)
- DNS resolution to arbitrary addresses (line 235)
- No filtering of private/internal addresses

**Attack Scenario:**

1. Malicious validator operator calls `update_network_and_fullnode_addresses()` with crafted addresses pointing to:
   - Internal services: `/ip4/10.0.0.5/tcp/6379` (Redis on internal network)
   - Cloud metadata: `/ip4/169.254.169.254/tcp/80` (AWS metadata endpoint)
   - Localhost services: `/ip4/127.0.0.1/tcp/5432` (local PostgreSQL)
   - Internal DNS: `/dns/internal-api.corporate.local/tcp/8080`

2. These malicious addresses are stored on-chain in the ValidatorSet

3. During the next epoch, all honest validators extract these addresses during discovery

4. Honest validators attempt to connect to these addresses, causing:
   - SSRF attacks against internal infrastructure
   - Reconnaissance of internal networks
   - Access to cloud metadata services (credential theft)
   - Port scanning of internal services

## Impact Explanation

**High Severity** - This qualifies as "Significant protocol violations" under the Aptos bug bounty:

- **Validator node exploitation**: Forces honest validators to make arbitrary network requests to attacker-chosen targets
- **Internal network exposure**: Allows reconnaissance and attacks against internal infrastructure that should not be reachable from validator nodes
- **Cloud credential theft**: Access to cloud metadata endpoints (169.254.169.254) can leak AWS/GCP credentials and instance metadata
- **Network protocol violation**: Breaks the security assumption that validators only connect to legitimate, public validator endpoints

While this doesn't directly cause consensus violations or fund loss, it represents a significant security breach that could be used as part of a larger attack chain (e.g., using stolen cloud credentials to compromise validator infrastructure).

## Likelihood Explanation

**High Likelihood**:

- **Low complexity**: Attack requires only a single transaction from a validator operator
- **No detection**: No validation logic exists to detect or prevent the attack
- **Affects all validators**: Every honest validator in the network will attempt connections to the malicious addresses
- **Persistent**: Once addresses are updated, they remain active until the next address update
- **Realistic attacker**: Validator operators have legitimate reasons to update addresses, making this attack path realistic

The only requirement is being a validator operator, which is a realistic attacker profile for targeted attacks.

## Recommendation

Implement strict address validation in `update_network_and_fullnode_addresses()`:

```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
) acquires StakePool, ValidatorConfig {
    check_stake_permission(operator);
    assert_reconfig_not_in_progress();
    assert_stake_pool_exists(pool_address);
    
    // ADD VALIDATION HERE
    validate_network_addresses(&new_network_addresses);
    validate_network_addresses(&new_fullnode_addresses);
    
    // ... rest of function
}

// New validation function
fun validate_network_addresses(encoded_addresses: &vector<u8>) {
    // Deserialize and validate each address
    let addresses = bcs::from_bytes<vector<NetworkAddress>>(encoded_addresses);
    // Check addresses are not private/internal IPs
    // Ensure DNS names don't resolve to RFC1918 ranges
    // Reject localhost, link-local, and metadata endpoints
}
```

Additionally, add defense-in-depth validation in the Rust layer before connection: [6](#0-5) 

Add IP filtering before the proxy check to reject private addresses.

## Proof of Concept

```move
// Move test demonstrating malicious address injection
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
fun test_ssrf_via_malicious_addresses(aptos_framework: &signer, validator: &signer) {
    // Setup validator
    stake::initialize_stake_pool(validator, /* ... */);
    
    // Craft malicious network addresses pointing to internal infrastructure
    let malicious_addresses = vector[];
    
    // Add localhost address
    let localhost_addr = b"/ip4/127.0.0.1/tcp/5432/noise-ik/PUBLIC_KEY/handshake/0";
    vector::push_back(&mut malicious_addresses, localhost_addr);
    
    // Add private network address  
    let private_addr = b"/ip4/10.0.0.5/tcp/6379/noise-ik/PUBLIC_KEY/handshake/0";
    vector::push_back(&mut malicious_addresses, private_addr);
    
    // Add cloud metadata endpoint
    let metadata_addr = b"/ip4/169.254.169.254/tcp/80/noise-ik/PUBLIC_KEY/handshake/0";
    vector::push_back(&mut malicious_addresses, metadata_addr);
    
    // BCS encode the malicious addresses
    let encoded = bcs::to_bytes(&malicious_addresses);
    
    // Update validator addresses - NO VALIDATION OCCURS
    stake::update_network_and_fullnode_addresses(
        validator,
        signer::address_of(validator),
        encoded,
        encoded
    );
    
    // In next epoch, all honest validators will attempt to connect to:
    // - localhost:5432 (potential local database)
    // - 10.0.0.5:6379 (internal Redis)  
    // - 169.254.169.254:80 (AWS metadata - credential theft)
    
    // This demonstrates SSRF vulnerability
}
```

**Notes**

This vulnerability requires validator operator privileges to exploit, which means it's an **insider threat scenario**. The attacker must already be a legitimate validator operator. However, the impact affects ALL other honest validators in the network, not just the attacker's own node. This represents a significant protocol-level security issue where one malicious operator can force the entire validator network to perform SSRF attacks against arbitrary targets.

The lack of any address validation at the Move layer, combined with direct usage of these addresses for TCP connections in the networking layer, creates a complete SSRF attack surface. The vulnerability could be exploited for network reconnaissance, internal service access, or cloud credential theft through metadata endpoints.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** types/src/validator_config.rs (L60-66)
```rust
    pub fn fullnode_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.fullnode_network_addresses)
    }

    pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.validator_network_addresses)
    }
```

**File:** config/src/config/network_config.rs (L498-504)
```rust
    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
```

**File:** network/netcore/src/transport/tcp.rs (L139-148)
```rust
    fn dial(&self, _peer_id: PeerId, addr: NetworkAddress) -> Result<Self::Outbound, Self::Error> {
        let protos = addr.as_slice();

        // ensure addr is well formed to save some work before potentially
        // spawning a dial task that will fail anyway.
        parse_ip_tcp(protos)
            .map(|_| ())
            .or_else(|| parse_dns_tcp(protos).map(|_| ()))
            .ok_or_else(|| invalid_addr_error(&addr))?;

```

**File:** network/netcore/src/transport/tcp.rs (L223-259)
```rust
pub async fn resolve_and_connect(
    addr: NetworkAddress,
    tcp_buff_cfg: TCPBufferCfg,
) -> io::Result<TcpStream> {
    let protos = addr.as_slice();

    if let Some(((ipaddr, port), _addr_suffix)) = parse_ip_tcp(protos) {
        // this is an /ip4 or /ip6 address, so we can just connect without any
        // extra resolving or filtering.
        connect_with_config(port, ipaddr, tcp_buff_cfg).await
    } else if let Some(((ip_filter, dns_name, port), _addr_suffix)) = parse_dns_tcp(protos) {
        // resolve dns name and filter
        let socketaddr_iter = resolve_with_filter(ip_filter, dns_name.as_ref(), port).await?;
        let mut last_err = None;

        // try to connect until the first succeeds
        for socketaddr in socketaddr_iter {
            match connect_with_config(socketaddr.port(), socketaddr.ip(), tcp_buff_cfg).await {
                Ok(stream) => return Ok(stream),
                Err(err) => last_err = Some(err),
            }
        }

        Err(last_err.unwrap_or_else(|| {
            io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "could not resolve dns name to any address: name: {}, ip filter: {:?}",
                    dns_name.as_ref(),
                    ip_filter,
                ),
            )
        }))
    } else {
        Err(invalid_addr_error(&addr))
    }
}
```
