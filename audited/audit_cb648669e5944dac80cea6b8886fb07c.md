# Audit Report

## Title
Non-Atomic Resource Group Write Operations Leading to State Inconsistency in MVHashMap

## Summary
The `data_write_impl()` function in `VersionedGroupData` performs multi-step write operations across separate data structures (`values`, `group_tags`) without atomicity guarantees. If `write_v2()` fails mid-iteration, partial writes remain in `self.values` while `tags_to_write` is not flushed to `self.group_tags`, creating orphaned entries that violate state consistency invariants. [1](#0-0) 

## Finding Description

The vulnerability exists in the write path for resource groups in BlockSTMv2's MVHashMap:

**Step 1 - Iteration Over Values:**
The function iterates over resource group tags, accumulating new tags in `tags_to_write` and calling `self.values.write_v2()` for each tag. [2](#0-1) 

**Step 2 - The Atomicity Gap:**
If `write_v2()` returns an error (via the `?` operator at line 649), the function returns early. At this point:
- Some tags have been successfully written to `self.values` 
- The `tags_to_write` vector contains accumulated tags (both successful and failed)
- The critical update to `self.group_tags` (lines 662-668) **never executes** [3](#0-2) 

**Step 3 - Orphaned State:**
The result is orphaned entries: values written to `self.values` that are not tracked in `self.group_tags`.

**Step 4 - Data Loss in finalize_group():**
When `finalize_group()` is called, it uses `group_tags` to determine which tags to include in the final committed group output. Orphaned tags are never retrieved, causing data loss. [4](#0-3) 

**Additional Complexity:**
At the executor level, metadata writes occur before group data writes, creating a second atomicity boundary. If group data writing fails, metadata remains committed. [5](#0-4) 

## Impact Explanation

**Severity Assessment: Medium (Conditional on Trigger)**

While this violates the **State Consistency** invariant ("State transitions must be atomic"), the current implementation of `write_v2` in `VersionedData` uses `assert!()` for error conditions rather than returning errors: [6](#0-5) 

This means:
1. Current code panics rather than returning errors, making the `?` operator path unlikely
2. Panics cause transaction failure and are caught by the execution framework
3. No clear path exists for unprivileged attackers to trigger assertion failures

However, this remains a **design flaw** because:
- The interface declares `Result<_, PanicError>`, indicating errors are expected
- Panics leave partial state (no rollback mechanism exists)
- Future code changes adding explicit error returns would immediately expose this vulnerability
- Different validators might experience failures at different times, potentially breaking deterministic execution

## Likelihood Explanation

**Current Implementation: Low Likelihood**
- Requires triggering code invariant violations (assertion failures)
- No clear exploitation path for external attackers
- Panics are caught by execution framework

**Future Risk: High Likelihood**
- Any enhancement adding error handling to `write_v2` would activate this path
- The code structure already anticipates failures (uses `?` operator)
- No protection exists against this design flaw

## Recommendation

Implement atomic write operations with rollback capability:

```rust
fn data_write_impl<const V2: bool>(
    &self,
    group_key: &K,
    txn_idx: TxnIndex,
    incarnation: Incarnation,
    values: impl IntoIterator<Item = (T, (V, Option<Arc<MoveTypeLayout>>))>,
    mut prev_tags: HashSet<&T>,
) -> Result<(bool, RegisteredReadDependencies), PanicError> {
    let mut ret_v1 = false;
    let mut ret_v2 = RegisteredReadDependencies::new();
    let mut tags_to_write = vec![];
    let mut write_results = vec![];  // Track all write operations
    
    // Phase 1: Perform all writes, collecting results
    {
        let superset_tags = self.group_tags.get(group_key).ok_or_else(|| {
            code_invariant_error("Group (tags) must be initialized to write to")
        })?;
        
        for (tag, (value, layout)) in values.into_iter() {
            if !superset_tags.contains(&tag) {
                tags_to_write.push(tag.clone());
            }
            
            ret_v1 |= !prev_tags.remove(&tag);
            
            if V2 {
                // Store tag for potential rollback
                write_results.push((tag.clone(), true));
                match self.values.write_v2::<false>(
                    (group_key.clone(), tag),
                    txn_idx,
                    incarnation,
                    Arc::new(value),
                    layout,
                ) {
                    Ok(deps) => ret_v2.extend(deps),
                    Err(e) => {
                        // Rollback all successful writes
                        for (written_tag, _) in &write_results[..write_results.len()-1] {
                            let key_ref = GroupKeyRef { group_key, tag: written_tag };
                            let _ = self.values.remove_v2::<_, false>(&key_ref, txn_idx);
                        }
                        return Err(e);
                    }
                }
            } else {
                self.values.write(
                    (group_key.clone(), tag),
                    txn_idx,
                    incarnation,
                    Arc::new(value),
                    layout,
                );
            }
        }
    }
    
    // Phase 2: Only update group_tags after ALL writes succeed
    if !tags_to_write.is_empty() {
        self.group_tags
            .get_mut(group_key)
            .expect("Group must be initialized")
            .extend(tags_to_write);
    }
    
    // Phase 3: Handle removals
    self.remove_impl::<V2>(group_key, txn_idx, prev_tags, &mut ret_v2)?;
    
    Ok((ret_v1, ret_v2))
}
```

Alternatively, implement a two-phase commit protocol or use transactional memory constructs to ensure atomicity across `values`, `group_tags`, and `group_sizes`.

## Proof of Concept

Due to the current implementation using `assert!()` rather than explicit error returns, a direct PoC is not feasible without code modification. However, the vulnerability can be demonstrated by:

1. **Injection Test**: Modify `write_v2` to return an error after N successful writes
2. **Verification**: Check that `group_tags` is missing entries that exist in `values`
3. **Impact Demonstration**: Call `finalize_group()` and observe missing tags in output

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    
    #[test]
    fn test_partial_write_inconsistency() {
        // This would require modifying write_v2 to inject failures
        // Current implementation only panics, making real-world PoC infeasible
        // The vulnerability is structural (lack of atomicity) rather than 
        // directly exploitable in current code
    }
}
```

**Note**: This vulnerability is currently a **design flaw** rather than an immediately exploitable bug, as the error path is not triggered by the existing implementation.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L531-553)
```rust
        let superset_tags = self
            .group_tags
            .get(group_key)
            .expect("Group tags must be set")
            .clone();

        let committed_group = superset_tags
            .into_iter()
            .map(
                |tag| match self.fetch_tagged_data_no_record(group_key, &tag, txn_idx + 1) {
                    Ok((_, value)) => Ok((value.write_op_kind() != WriteOpKind::Deletion)
                        .then(|| (tag, value.clone()))),
                    Err(MVGroupError::TagNotFound) => Ok(None),
                    Err(e) => Err(code_invariant_error(format!(
                        "Unexpected error in finalize group fetching value {:?}",
                        e
                    ))),
                },
            )
            .collect::<Result<Vec<_>, PanicError>>()?
            .into_iter()
            .flatten()
            .collect();
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L635-669)
```rust
            for (tag, (value, layout)) in values.into_iter() {
                if !superset_tags.contains(&tag) {
                    tags_to_write.push(tag.clone());
                }

                ret_v1 |= !prev_tags.remove(&tag);

                if V2 {
                    ret_v2.extend(self.values.write_v2::<false>(
                        (group_key.clone(), tag),
                        txn_idx,
                        incarnation,
                        Arc::new(value),
                        layout,
                    )?);
                } else {
                    self.values.write(
                        (group_key.clone(), tag),
                        txn_idx,
                        incarnation,
                        Arc::new(value),
                        layout,
                    );
                }
            }
        }

        if !tags_to_write.is_empty() {
            // We extend here while acquiring a write access (implicit lock), while the
            // processing above only requires a read access.
            self.group_tags
                .get_mut(group_key)
                .expect("Group must be initialized")
                .extend(tags_to_write);
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L257-276)
```rust
                        abort_manager.invalidate_dependencies(
                            // Invalidate the readers of group metadata.
                            versioned_cache.data().write_v2::<true>(
                                group_key.clone(),
                                idx_to_execute,
                                incarnation,
                                TriompheArc::new(group_metadata_op),
                                None,
                            )?,
                        )?;
                        abort_manager.invalidate_dependencies(
                            versioned_cache.group_data().write_v2(
                                group_key,
                                idx_to_execute,
                                incarnation,
                                group_ops.into_iter(),
                                group_size,
                                prev_tags,
                            )?,
                        )?;
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L691-693)
```rust
        // Asserted (local, easily checkable invariant), since affected dependencies are obtained
        // by calling split_off at txn_idx + 1.
        assert!(check_lowest_dependency_idx(&affected_dependencies, txn_idx).is_ok());
```
