# Audit Report

## Title
Resource Group Field Name Validation Bypass via Manual Bytecode Crafting

## Summary
A validation gap exists between compile-time and runtime checks for resource group container structs. While compile-time checks enforce that the single field must be named `dummy_field`, runtime validation only checks field count, allowing attackers who manually craft bytecode to bypass field name restrictions and store arbitrary data in resource group containers.

## Finding Description

Resource groups in Aptos are intended to be empty marker structs containing only a `dummy_field: bool` for organizational purposes. However, there is a critical inconsistency in validation: [1](#0-0) 

The compile-time check enforces that the field must be named exactly `dummy_field`. However, the runtime validation during module publishing only checks field count: [2](#0-1) 

The runtime function `is_valid_resource_group` only validates `num_fields == 1`, `abilities == EMPTY`, and `type_parameters.is_empty()`, but does **not** validate the field name or type.

An attacker can exploit this by:
1. Manually crafting Move bytecode (not using standard compiler)
2. Creating a resource group struct with one field named arbitrarily (e.g., `_data`, `value`, `storage`)
3. Setting the field type to any Move type (e.g., `u64`, `vector<u8>`, `String`)
4. Publishing via `code::publish_package_txn` [3](#0-2) 

The validation flow calls `verify_module_metadata_for_module_publishing` which uses the weaker runtime check, allowing the bypass.

**Note on Unicode bypass**: The security question mentions Unicode, but this is not exploitable as Move identifiers are strictly ASCII-only: [4](#0-3) 

## Impact Explanation

This vulnerability represents a **Medium Severity** issue under the "Significant protocol violations" category. While it doesn't directly cause consensus violations or fund loss, it:

1. **Violates design invariants**: Resource groups are explicitly designed to be empty marker structs
2. **Enables data smuggling**: Attackers can store arbitrary data (single field) in structures meant to be empty
3. **Bypasses intended restrictions**: Code interacting with resource groups may have assumptions about their emptiness
4. **Gas cost implications**: If resource group operations are priced assuming empty structs, this could lead to incorrect gas accounting

The issue maintains deterministic execution (all validators apply the same weak validation) and doesn't break state consistency, preventing it from being Critical severity.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Technical sophistication to manually craft valid Move bytecode
- Knowledge of the validation gap
- Ability to serialize and publish bytecode directly

However, it does **not** require:
- Validator access or collusion
- Compromising existing accounts
- Economic attacks or market manipulation

Any developer with knowledge of Move bytecode format can execute this attack, making it reasonably likely for motivated attackers.

## Recommendation

Add field name and type validation to the runtime check in `is_valid_resource_group`:

```rust
pub fn is_valid_resource_group(
    module: &CompiledModule,
    structs: &BTreeMap<&IdentStr, (&StructHandle, &StructDefinition)>,
    struct_: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if let Some((struct_handle, struct_def)) = structs.get(ident_struct.as_ident_str()) {
            let fields = match &struct_def.field_information {
                StructFieldInformation::Native | StructFieldInformation::DeclaredVariants(_) => return Err(...),
                StructFieldInformation::Declared(fields) => fields,
            };
            
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && fields.len() == 1
            {
                // Validate field name is "dummy_field"
                let field = &fields[0];
                let field_name = module.identifier_at(field.name);
                if field_name.as_str() != "dummy_field" {
                    return Err(AttributeValidationError {
                        key: struct_.to_string(),
                        attribute: KnownAttributeKind::ResourceGroup as u8,
                    });
                }
                
                // Validate field type is bool
                if field.signature.0 != SignatureToken::Bool {
                    return Err(AttributeValidationError {
                        key: struct_.to_string(),
                        attribute: KnownAttributeKind::ResourceGroup as u8,
                    });
                }
                
                return Ok(());
            }
        }
    }
    
    Err(AttributeValidationError {
        key: struct_.to_string(),
        attribute: KnownAttributeKind::ResourceGroup as u8,
    })
}
```

This ensures compile-time and runtime checks are consistent.

## Proof of Concept

```rust
// Rust code demonstrating bytecode manipulation
use move_binary_format::{
    file_format::*,
    CompiledModule,
};
use move_core_types::{
    account_address::AccountAddress,
    identifier::Identifier,
};

fn create_malicious_resource_group() -> CompiledModule {
    let mut module = CompiledModule::default();
    
    // Create struct with field named "_data" instead of "dummy_field"
    let struct_handle = StructHandle {
        module: ModuleHandleIndex(0),
        name: IdentifierIndex(0), // "MaliciousGroup"
        abilities: AbilitySet::EMPTY,
        type_parameters: vec![],
    };
    
    let field = FieldDefinition {
        name: IdentifierIndex(1), // "_data" 
        signature: TypeSignature(SignatureToken::U64), // u64 instead of bool
    };
    
    let struct_def = StructDefinition {
        struct_handle: StructHandleIndex(0),
        field_information: StructFieldInformation::Declared(vec![field]),
    };
    
    // Add resource_group metadata
    // This bytecode would pass runtime validation but violates design intent
    
    module
}

// The crafted bytecode can be published and would pass
// verify_module_metadata_for_module_publishing checks
// but violates resource group invariants
```

**Notes**

This vulnerability stems from incomplete validation alignment between compilation and runtime phases. While the immediate security impact is limited (no consensus violation or direct fund loss), it represents a protocol-level design violation that could have cascading effects if resource group assumptions are relied upon elsewhere in the codebase.

### Citations

**File:** aptos-move/framework/src/extended_checks.rs (L425-432)
```rust
        if struct_.get_field_count() == 1 {
            let name = self.name_string(struct_.get_fields().next().unwrap().get_name());
            // TODO: check that the type is bool
            if *name != "dummy_field" {
                self.env
                    .error(&struct_.get_loc(), "resource_group should not have fields");
                return None;
            };
```

**File:** types/src/vm/module_metadata.rs (L398-421)
```rust
pub fn is_valid_resource_group(
    structs: &BTreeMap<&IdentStr, (&StructHandle, &StructDefinition)>,
    struct_: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if let Some((struct_handle, struct_def)) = structs.get(ident_struct.as_ident_str()) {
            let num_fields = match &struct_def.field_information {
                StructFieldInformation::Native | StructFieldInformation::DeclaredVariants(_) => 0,
                StructFieldInformation::Declared(fields) => fields.len(),
            };
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && num_fields == 1
            {
                return Ok(());
            }
        }
    }

    Err(AttributeValidationError {
        key: struct_.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1739)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** third_party/move/move-core/types/src/identifier.rs (L20-47)
```rust
//! Allowed identifiers are currently restricted to ASCII due to unresolved issues with Unicode
//! normalization. See [Rust issue #55467](https://github.com/rust-lang/rust/issues/55467) and the
//! associated RFC for some discussion. Unicode identifiers may eventually be supported once these
//! issues are worked out.
//!
//! This module only determines allowed identifiers at the bytecode level. Move source code will
//! likely be more restrictive than even this, with a "raw identifier" escape hatch similar to
//! Rust's `r#` identifiers.
//!
//! Among other things, identifiers are used to:
//! * specify keys for lookups in storage
//! * do cross-module lookups while executing transactions

use anyhow::{bail, Result};
#[cfg(any(test, feature = "fuzzing"))]
use proptest::prelude::*;
use ref_cast::RefCast;
use serde::{Deserialize, Serialize};
use std::{borrow::Borrow, fmt, ops::Deref, str::FromStr};

/// Return true if this character can appear in a Move identifier.
///
/// Note: there are stricter restrictions on whether a character can begin a Move
/// identifier--only alphabetic characters are allowed here.
#[inline]
pub const fn is_valid_identifier_char(c: char) -> bool {
    matches!(c, '_' | '$' | 'a'..='z' | 'A'..='Z' | '0'..='9')
}
```
