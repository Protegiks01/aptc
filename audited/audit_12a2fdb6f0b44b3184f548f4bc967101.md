# Audit Report

## Title
Maximum Stake Bypass During Epoch Transition Undermines Sybil Resistance

## Summary
The `on_new_epoch()` function in the staking module fails to validate the `maximum_stake` limit when activating validators from the `pending_active` queue. This allows validators to exceed the maximum voting power constraint if `maximum_stake` is reduced via governance between when they join the validator set and when they are activated, directly undermining the sybil resistance mechanism.

## Finding Description

The Aptos staking system enforces sybil resistance through two key parameters: `minimum_stake` (economic barrier to entry) and `maximum_stake` (power concentration limit). When validators join the validator set, both limits are validated: [1](#0-0) 

However, when `on_new_epoch()` activates pending validators during epoch transitions, it only validates `minimum_stake` but completely ignores `maximum_stake`: [2](#0-1) 

Notice the underscore `_` discarding the `maximum_stake` value. Later, only the minimum is checked: [3](#0-2) 

**Attack Scenario:**
1. Validator joins with 100M tokens when `maximum_stake = 100M` (passes validation)
2. Validator enters `pending_active` state, waiting for next epoch
3. Governance legitimately reduces `maximum_stake` to 50M to improve decentralization
4. `on_new_epoch()` is called at epoch boundary
5. Pending validators are appended to active set and their voting power is recalculated
6. Only minimum stake check executes - no maximum stake validation
7. Validator activates with 100M voting power, 2x the intended maximum

This same vulnerability exists in `next_validator_consensus_infos()`: [4](#0-3) [5](#0-4) 

The epoch change verification in Rust relies on the validator set generated by the Move framework: [6](#0-5) 

Since the Move framework allows validators exceeding `maximum_stake` to be activated, the Rust verification code accepts this compromised validator set, propagating the sybil resistance weakness through the entire epoch change mechanism.

## Impact Explanation

**Severity: High** - "Significant protocol violations"

This vulnerability directly violates the sybil resistance security guarantee:

1. **Power Concentration**: Validators can hold voting power exceeding the intended maximum limit, concentrating power beyond protocol-defined bounds
2. **Governance Bypass**: Security improvements via `maximum_stake` reduction can be circumvented by timing validator joins
3. **Asymmetric Advantage**: Attackers monitoring governance can strategically join before limit reductions, gaining disproportionate power over honest validators capped at the new limit
4. **Decentralization Undermined**: The purpose of `maximum_stake` is to enforce power distribution; this bypass defeats that fundamental security control

While this doesn't directly cause fund loss or network halt, it undermines a critical consensus security mechanism (Invariant #5: "Staking Security"). The asymmetry between `minimum_stake` enforcement (present) and `maximum_stake` enforcement (absent) indicates this is unintended behavior.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is highly exploitable because:

1. **Public Information**: Governance proposals are publicly visible on-chain
2. **No Special Access Required**: Any party with sufficient tokens can join the validator set
3. **Timing Window**: Validators remain in `pending_active` for exactly one epoch, providing a predictable exploitation window
4. **Legitimate Trigger**: Governance reducing `maximum_stake` to improve security is a legitimate and expected action
5. **No Detection**: The bypass occurs silently during normal epoch transitions

An attacker only needs to:
- Monitor governance proposals for `update_required_stake` calls
- Join the validator set at current `maximum_stake` before the proposal executes
- Wait for the next epoch transition to gain excessive voting power

## Recommendation

Add `maximum_stake` validation during validator activation in `on_new_epoch()`:

```move
// In on_new_epoch() around line 1373:
let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);

// In the validation loop around line 1391:
if (new_validator_info.voting_power >= minimum_stake && 
    new_validator_info.voting_power <= maximum_stake) {
    // ... activate validator
}
```

Similarly, update `next_validator_consensus_infos()` around line 1539 to check both limits.

Additionally, consider implementing automatic removal of validators who exceed the new maximum when it's reduced via governance, or requiring a grace period for affected validators to reduce their stake.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
public fun test_maximum_stake_bypass_during_epoch_change(
    aptos_framework: &signer,
    validator: &signer,
) {
    // Setup: Initialize staking with maximum_stake = 100M
    initialize_test_staking(aptos_framework);
    staking_config::update_required_stake(
        aptos_framework,
        1_000_000,      // minimum_stake = 1M
        100_000_000,    // maximum_stake = 100M
    );
    
    // Step 1: Validator joins at maximum stake (100M)
    let validator_addr = signer::address_of(validator);
    setup_validator(validator, 100_000_000);
    stake::join_validator_set_internal(validator, validator_addr);
    
    // Verify validator is in pending_active
    assert!(stake::get_validator_state(validator_addr) == VALIDATOR_STATUS_PENDING_ACTIVE, 1);
    
    // Step 2: Governance reduces maximum_stake to 50M
    staking_config::update_required_stake(
        aptos_framework,
        1_000_000,      // minimum_stake = 1M  
        50_000_000,     // NEW maximum_stake = 50M
    );
    
    // Step 3: Epoch transition activates the validator
    stake::on_new_epoch();
    
    // Step 4: Validator is now active with 100M voting power
    // This EXCEEDS the current maximum_stake of 50M!
    assert!(stake::get_validator_state(validator_addr) == VALIDATOR_STATUS_ACTIVE, 2);
    let voting_power = stake::get_current_epoch_voting_power(validator_addr);
    assert!(voting_power == 100_000_000, 3); // Has 100M
    
    // Step 5: Verify this exceeds the current maximum
    let (_, current_maximum) = staking_config::get_required_stake(&staking_config::get());
    assert!(voting_power > current_maximum, 4); // 100M > 50M - VULNERABILITY DEMONSTRATED
}
```

This test demonstrates that a validator can bypass the `maximum_stake` limit, holding 2x the intended maximum voting power and undermining sybil resistance guarantees.

## Notes

This vulnerability is particularly concerning because it can be triggered by legitimate governance actions intended to **improve** security. When governance attempts to enhance decentralization by reducing `maximum_stake`, it inadvertently creates a window for validators to bypass the new limit. The fix is straightforward: ensure consistent validation of both minimum and maximum stake limits during all validator activation paths.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1373-1373)
```text
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1391-1391)
```text
            if (new_validator_info.voting_power >= minimum_stake) {
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1478-1478)
```text
        let (minimum_stake, _) = staking_config::get_required_stake(&staking_config);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1539-1539)
```text
            if (new_voting_power >= minimum_stake) {
```

**File:** types/src/epoch_change.rs (L106-114)
```rust
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
```
