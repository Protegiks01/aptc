# Audit Report

## Title
Telemetry Logging System Lacks Content Filtering - Potential Information Disclosure of Transaction Details

## Summary
The telemetry logging system sends all log batches to a remote telemetry service without any content filtering or sanitization. While private keys are protected through `SilentDebug` implementations, transaction signatures and internal transaction processing details could be inadvertently logged and transmitted if developers use debug formatting on transaction objects.

## Finding Description

The telemetry system in Aptos has no filtering mechanism between log collection and transmission to the remote telemetry service. The vulnerability chain consists of:

1. **No Content Filtering**: The `post_logs()` function transmits log batches without inspecting or sanitizing content [1](#0-0) 

2. **No Batch Filtering**: Log batching also occurs without content validation


3. **Arbitrary Data in LogEntry**: The `LogEntry` structure contains a `data` field that can hold any structured data from logging macros [2](#0-1) 

4. **Transaction Signatures Exposed in Debug**: Both `TransactionAuthenticator` and `AccountAuthenticator` use standard `Debug` trait derivation, exposing all signature fields [3](#0-2) [4](#0-3) 

5. **SignedTransaction Debug Implementation**: Explicitly outputs transaction authenticator data [5](#0-4) 

6. **Remote Log Level Control**: The telemetry service can remotely modify `RUST_LOG_TELEMETRY`, potentially enabling verbose logging [6](#0-5) 

**Positive Security Control**: Private keys ARE protected via `SilentDebug`, preventing their disclosure [7](#0-6) [8](#0-7) 

## Impact Explanation

This issue qualifies as **Low Severity** under Aptos bug bounty criteria ("Minor information leaks") rather than High severity because:

1. **Private keys are protected**: The `SilentDebug` macro prevents private key leakage
2. **Requires developer error**: Sensitive data must first be logged using debug formatting
3. **Limited practical impact**: Transaction signatures become public when transactions are submitted on-chain
4. **Defense-in-depth issue**: No direct exploitation path without prerequisite conditions

However, the risk increases in scenarios where:
- Pre-submission transaction details leak validator strategies
- Failed/rejected transactions that never reach the chain are exposed
- Consensus-related internal state is logged for debugging

## Likelihood Explanation

**Low likelihood** of exploitation because:
- Requires developers to add logging statements that include full transaction objects
- Code review processes should catch such logging
- No evidence found in current codebase of widespread transaction object logging with debug formatting
- The remote log level control requires compromise of the telemetry service endpoint

## Recommendation

Implement a **content sanitization layer** before sending logs to telemetry:

```rust
pub async fn try_send_logs(&self, batch: Vec<String>) {
    // Filter/sanitize logs before sending
    let sanitized_batch = batch.into_iter()
        .map(|log| sanitize_log_entry(log))
        .collect();
    
    if let Ok(json) = serde_json::to_string(&sanitized_batch) {
        // ... existing code
    }
}

fn sanitize_log_entry(log: String) -> String {
    // Implement pattern matching to detect and redact:
    // - Transaction authenticators/signatures
    // - Sensitive consensus data
    // - Account details beyond addresses
    // Return sanitized version
}
```

Additionally:
1. Add documentation warning developers against logging full transaction objects
2. Implement linting rules to detect `debug!("{:?}", transaction)` patterns
3. Add authentication/authorization for remote log level changes
4. Consider implementing allowlist-based filtering for telemetry logs

## Proof of Concept

```rust
// This demonstrates how transaction data would be exposed if logged
use aptos_types::transaction::{SignedTransaction, RawTransaction};

// If a developer adds this logging:
fn process_transaction(txn: &SignedTransaction) {
    debug!("Processing transaction: {:?}", txn);  // UNSAFE - exposes signatures
    // ... rest of processing
}

// The Debug implementation will output:
// SignedTransaction { 
//   raw_txn: RawTransaction { ... },
//   authenticator: Ed25519 { 
//     public_key: <public_key_bytes>,
//     signature: <signature_bytes>  // <- This gets sent to telemetry
//   }
// }
```

The vulnerability requires developers to add such logging, but the system provides no technical safeguard against it.

---

## Notes

While this finding identifies a real gap in defensive security controls, it does **not** meet the high bar for a directly exploitable vulnerability because:
- It requires prerequisite developer error
- Private keys are already protected
- No evidence of sensitive logging in production code
- Transaction signatures are public data post-submission

The issue is better characterized as a **security hardening opportunity** rather than an exploitable vulnerability under strict bug bounty criteria.

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L195-214)
```rust
    async fn post_logs(&self, json: &[u8]) -> Result<Response, anyhow::Error> {
        debug!("Sending logs");

        let mut gzip_encoder = GzEncoder::new(Vec::new(), Compression::default());
        gzip_encoder.write_all(json)?;
        let compressed_bytes = gzip_encoder.finish()?;

        // Send the request and wait for a response
        let response = self
            .send_authenticated_request(
                self.client
                    .post(self.build_path("ingest/logs")?)
                    .header(CONTENT_ENCODING, "gzip")
                    .body(compressed_bytes),
            )
            .await?;

        // Process the result
        error_for_status_with_body(response).await
    }
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L110-123)
```rust
pub struct LogEntry {
    metadata: Metadata,
    thread_name: Option<String>,
    /// The program backtrace taken when the event occurred. Backtraces
    /// are only supported for errors and must be configured.
    backtrace: Option<String>,
    hostname: Option<&'static str>,
    namespace: Option<&'static str>,
    timestamp: String,
    data: BTreeMap<Key, serde_json::Value>,
    message: Option<String>,
    peer_id: Option<&'static str>,
    chain_id: Option<u8>,
}
```

**File:** types/src/transaction/authenticator.rs (L73-73)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
```

**File:** types/src/transaction/authenticator.rs (L524-524)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
```

**File:** types/src/transaction/mod.rs (L1092-1103)
```rust
impl Debug for SignedTransaction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SignedTransaction {{ \n \
             {{ raw_txn: {:#?}, \n \
             authenticator: {:#?}, \n \
             }} \n \
             }}",
            self.raw_txn, self.authenticator
        )
    }
```

**File:** crates/aptos-telemetry/src/service.rs (L212-237)
```rust
fn try_spawn_log_env_poll_task(sender: TelemetrySender) {
    if enable_log_env_polling() {
        tokio::spawn(async move {
            let original_value = env::var(RUST_LOG_TELEMETRY).ok();
            let mut interval = time::interval(Duration::from_secs(LOG_ENV_POLL_FREQ_SECS));
            loop {
                interval.tick().await;
                if let Some(env) = sender.get_telemetry_log_env().await {
                    info!(
                        "Updating {} env variable: previous value: {:?}, new value: {}",
                        RUST_LOG_TELEMETRY,
                        env::var(RUST_LOG_TELEMETRY).ok(),
                        env
                    );
                    // TODO: Audit that the environment access only happens in single-threaded code.
                    unsafe { env::set_var(RUST_LOG_TELEMETRY, env) }
                } else if let Some(ref value) = original_value {
                    // TODO: Audit that the environment access only happens in single-threaded code.
                    unsafe { env::set_var(RUST_LOG_TELEMETRY, value) }
                } else {
                    // TODO: Audit that the environment access only happens in single-threaded code.
                    unsafe { env::remove_var(RUST_LOG_TELEMETRY) }
                }
            }
        });
    }
```

**File:** crates/aptos-crypto/src/x25519.rs (L66-68)
```rust
#[derive(DeserializeKey, SilentDisplay, SilentDebug, SerializeKey)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Clone))]
pub struct PrivateKey(x25519_dalek::StaticSecret);
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L128-142)
```rust
#[proc_macro_derive(SilentDebug)]
pub fn silent_debug(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();

    quote! {
        // In order to ensure that secrets are never leaked, Debug is elided
        impl #impl_generics ::std::fmt::Debug for #name #ty_generics #where_clause {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "<elided secret for {}>", stringify!(#name))
            }
        }
    }
    .into()
```
