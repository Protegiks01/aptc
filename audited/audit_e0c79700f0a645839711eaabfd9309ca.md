# Audit Report

## Title
Gas Metering Bypass in Abort Hook Account Creation - Unmetered Operations Committed Despite Insufficient Gas Payment

## Summary
A critical gas metering bypass exists in the `finish_aborted_transaction` flow where expensive account creation operations executed with `UnmeteredGasMeter` are committed to state even when subsequent gas charging fails, allowing attackers to pay less than the actual cost of operations while state changes are still applied.

## Finding Description

The vulnerability occurs in the abort hook execution path when a transaction aborts and requires automatic account creation. The code flow contains a fatal flaw in its error handling: [1](#0-0) 

When the metered execution of `create_account_if_does_not_exist` fails (typically due to out-of-gas), the code retries with `UnmeteredGasMeter`. This allows expensive operations to execute without gas tracking, including:
- Account resource creation with authentication keys
- Event handle creation (GUID allocation)
- Storage write operations [2](#0-1) 

After the unmetered execution succeeds, the code attempts to retroactively charge for these operations: [3](#0-2) 

**Critical Bug**: When `charge_change_set` fails due to insufficient gas, the error is caught and merely logged (line 750-754), but **not propagated**. The transaction continues execution and the state changes are committed.

The subsequent validation only checks a lower bound, which is explicitly insufficient: [4](#0-3) [5](#0-4) 

The comment explicitly states this is "an underestimation" - it only validates the minimum account creation fee was paid, not the actual cost of all operations performed.

The abort hook session change set containing the unmetered operations is then passed to the epilogue and committed: [6](#0-5) 

**Invariant Violation**: This breaks Critical Invariant #9: "All operations must respect gas, storage, and computational limits". The attacker pays less gas than the actual cost while state changes are permanently committed.

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria for "Significant protocol violations" and gas metering bypasses.

This vulnerability allows:
1. **Economic Attack**: Attackers can create accounts at reduced cost by paying only the lower bound fee instead of actual costs
2. **Resource Exhaustion**: Mass account creation at below-market rates can bloat state storage
3. **Gas Market Manipulation**: Undermines the gas pricing mechanism by allowing operations at incorrect prices
4. **Deterministic Execution Risk**: Different nodes might handle edge cases in gas charging differently, potentially affecting consensus

The attack is repeatable and scalable - an attacker can exploit this repeatedly to create many accounts cheaply, affecting network economics and potentially state bloat.

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily triggered when:

1. Feature flag `DEFAULT_ACCOUNT_RESOURCE` or `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` is enabled (production features)
2. Transaction has sequence number 0 (new account)
3. Account resource doesn't exist for sender
4. Transaction aborts (trivially achievable)
5. Gas provided: `lower_bound <= gas < actual_cost` [7](#0-6) 

No special privileges required - any transaction sender can exploit this. The attacker only needs to:
- Calculate the lower bound fee (publicly known gas parameters)
- Provide gas slightly above this bound but below actual cost
- Submit a transaction that will abort

## Recommendation

**Immediate Fix**: The error from `charge_change_set` must be propagated, not swallowed. Replace the current error handling:

```rust
// VULNERABLE CODE (lines 743-754)
if let Err(err) = self.charge_change_set(...) {
    info!(*log_context, "Failed during charge_change_set: {:?}...", err);
};
```

**Fixed Code**:
```rust
// Charge for the change set - this MUST succeed or transaction fails
self.charge_change_set(
    &mut abort_hook_session_change_set,
    gas_meter,
    txn_data,
    resolver,
    module_storage,
)?; // Propagate error - fail transaction if charging fails
```

**Alternative Fix**: If the intent is to allow some flexibility, the validation must check that actual charges succeeded, not just the lower bound:

```rust
// After charge_change_set, verify gas was actually charged
let charged_amount = /* track what was actually charged */;
if charged_amount < actual_cost_of_operations {
    return Err(insufficient_gas_error);
}
```

**Root Cause**: The comment on line 720-721 indicates the design intent was to validate "below" but the validation implemented is insufficient. The design should either:
1. Require full gas payment upfront (preferred), OR
2. Ensure retroactive charging always succeeds, OR  
3. Roll back state changes if charging fails

## Proof of Concept

```rust
// PoC: Create transaction that exploits gas metering bypass
// Location: Add to aptos-move/aptos-vm/tests/

#[test]
fn test_abort_hook_gas_bypass() {
    // Setup: Enable DEFAULT_ACCOUNT_RESOURCE feature
    // Create new account address (sequence 0, no Account resource)
    let sender = AccountAddress::random();
    
    // Step 1: Calculate lower bound for account creation
    let gas_params = get_gas_params();
    let lower_bound = calculate_hack_account_creation_fee_lower_bound(&gas_params);
    
    // Step 2: Calculate actual cost of account creation with event handles
    let actual_cost = calculate_full_account_creation_cost(&gas_params);
    assert!(actual_cost > lower_bound); // Verify gap exists
    
    // Step 3: Provide gas between lower_bound and actual_cost
    let exploit_gas = lower_bound + ((actual_cost - lower_bound) / 2);
    
    // Step 4: Create transaction that will abort
    let txn = create_aborting_transaction(sender, exploit_gas);
    
    // Step 5: Execute transaction
    let output = execute_transaction(txn);
    
    // Verify exploit: 
    // - Transaction kept (not discarded)
    // - Account was created (state change committed)
    // - Gas charged < actual_cost (underpayment)
    assert!(output.status().is_kept());
    assert!(account_exists(sender)); // Account created
    assert!(output.gas_used() < actual_cost); // Paid less than actual cost
    
    // This demonstrates gas metering bypass:
    // Expensive operations executed, state committed, but insufficient gas charged
}
```

**Notes**

This vulnerability exists because the code attempts to handle OOG gracefully by retrying with unmetered execution, but fails to enforce that the retroactive charging must succeed. The gap between the lower bound validation and actual operation costs creates an exploitable window where attackers pay less than fair market value for state-modifying operations.

The fix requires either strict upfront gas validation or proper error propagation when retroactive charging fails. The current implementation violates the fundamental gas metering invariant by committing state changes that weren't properly paid for.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L712-739)
```rust
            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L741-754)
```rust
            let mut abort_hook_session_change_set =
                abort_hook_session.finish(change_set_configs, module_storage)?;
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L759-785)
```rust
            // Verify we charged sufficiently for creating an account slot
            let gas_params = self.gas_params(log_context)?;
            let gas_unit_price = u64::from(txn_data.gas_unit_price());
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
                    expect_only_successful_execution(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(
                                "Insufficient fee for storing account for lazy account creation"
                                    .to_string(),
                            )
                            .finish(Location::Undefined),
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )?;
                }
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L786-821)
```rust
            (abort_hook_session_change_set, fee_statement)
        } else {
            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
            (prologue_session_change_set, fee_statement)
        };

        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            previous_session_change_set,
        );

        // Abort information is injected using the user defined error in the Move contract.
        let status = self.inject_abort_info_if_available(
            module_storage,
            traversal_context,
            log_context,
            status,
        );
        epilogue_session.execute(|session| {
            transaction_validation::run_failure_epilogue(
                session,
                module_storage,
                serialized_signers,
                gas_meter.balance(),
                fee_statement,
                self.features(),
                txn_data,
                log_context,
                traversal_context,
                self.is_simulation,
            )
        })?;
        epilogue_session.finish(fee_statement, status, change_set_configs, module_storage)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3484)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
}
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L305-334)
```text
    fun create_account_unchecked(new_address: address): signer {
        let new_account = create_signer(new_address);
        let authentication_key = bcs::to_bytes(&new_address);
        assert!(
            authentication_key.length() == 32,
            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
        );

        let guid_creation_num = 0;

        let guid_for_coin = guid::create(new_address, &mut guid_creation_num);
        let coin_register_events = event::new_event_handle<CoinRegisterEvent>(guid_for_coin);

        let guid_for_rotation = guid::create(new_address, &mut guid_creation_num);
        let key_rotation_events = event::new_event_handle<KeyRotationEvent>(guid_for_rotation);

        move_to(
            &new_account,
            Account {
                authentication_key,
                sequence_number: 0,
                guid_creation_num,
                coin_register_events,
                key_rotation_events,
                rotation_capability_offer: CapabilityOffer { for: option::none() },
                signer_capability_offer: CapabilityOffer { for: option::none() },
            }
        );

        new_account
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L229-239)
```rust
    pub fn hack_account_creation_fee_lower_bound(&self, params: &TransactionGasParameters) -> Fee {
        match self {
            Self::V1 => params.legacy_storage_fee_per_state_slot_create * NumSlots::new(1),
            Self::V2 => {
                // This is an underestimation of the fee for account creation, because AccountResource has a
                // vector and two optional addresses in it which will expand to more bytes on-chain
                params.storage_fee_per_state_slot * NumSlots::new(1)
                    + params.storage_fee_per_state_byte
                        * NumBytes::new(std::mem::size_of::<AccountResource>() as u64)
            },
        }
```
