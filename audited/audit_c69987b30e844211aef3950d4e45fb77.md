# Audit Report

## Title
Consensus Observer Accepts Empty Validator Set Leading to Complete Consensus Bypass

## Summary
The `on_new_epoch()` function in the Aptos staking module lacks validation to prevent an empty validator set, which when combined with the consensus observer's epoch state extraction and ValidatorVerifier's handling of empty sets, creates a path for complete consensus bypass with zero validators.

## Finding Description

This vulnerability exists as a **defensive programming failure** where multiple code paths interact to allow a fundamentally unsafe state: a blockchain epoch with zero validators.

**Root Cause 1: Missing Validation in `on_new_epoch()`**

The `on_new_epoch()` function filters validators based on minimum stake requirements but lacks validation to prevent an empty active validator set. [1](#0-0) 

In contrast, the `leave_validator_set()` function explicitly prevents removal of the last validator with: `assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR))`. [2](#0-1) 

This inconsistency means explicit validator exits are protected, but automatic removal via minimum stake filtering during epoch transitions is not.

**Root Cause 2: ValidatorVerifier Accepts Empty Validator Set**

When a ValidatorSet with zero validators is converted to a ValidatorVerifier, the quorum voting power is explicitly set to zero. [3](#0-2) 

**Root Cause 3: Zero Quorum Allows Empty Signatures**

During signature verification, the `check_aggregated_voting_power()` function compares aggregated voting power against a target. When `quorum_voting_power = 0`, the target becomes 0, and an empty signature with `aggregated_voting_power = 0` passes the check `aggregated_voting_power < target` (evaluating to `0 < 0 = false`). [4](#0-3) 

Note that test code at lines 366-371 recognizes this as problematic but only prevents it in test/fuzzing builds, not production.

**Root Cause 4: Consensus Observer Lacks Validation**

The consensus observer extracts the ValidatorSet and creates an EpochState without checking if the validator set is empty. [5](#0-4) 

**Root Cause 5: Genesis Protection Not Extended to Epoch Transitions**

The formal specification requires at least one validator at genesis, but this requirement is only enforced during genesis initialization, not during epoch transitions via `on_new_epoch()`. [6](#0-5) 

**Triggering Scenarios:**

1. **Governance misconfiguration**: A proposal raising `minimum_stake` above all validators' current stakes [7](#0-6) 
2. **Bug in stake calculation**: A software bug incorrectly computing voting power, causing all validators to appear below threshold
3. **Economic/slashing cascade**: Extraordinary circumstances causing all validators' stakes to drop simultaneously below minimum

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety Violation)

This vulnerability breaks the fundamental security guarantee of AptosBFT consensus:

- **Complete Consensus Bypass**: Once an empty validator set is established, any block with empty signatures passes verification, bypassing all consensus safety requirements
- **BFT Safety Violation**: The requirement that < 1/3 Byzantine validators cannot compromise safety is completely bypassed (0 validators needed for quorum)
- **Network Halt or State Corruption**: The blockchain cannot progress with legitimate blocks or accepts arbitrary invalid state transitions
- **Determinism Loss**: Different nodes could accept different blocks, leading to chain splits
- **Hardfork Required**: Recovery would require manual intervention and likely a hardfork

This aligns with the **Consensus/Safety Violations (Critical)** category in the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Low**

While the technical vulnerability is confirmed, the triggering conditions are unlikely under normal operation:

- **Governance scenario**: Requires validators voting for a proposal that removes themselves from the validator set
- **Economic crisis**: Requires simultaneous stake drops across all validators
- **Slashing cascade**: Requires catastrophic infrastructure failures

The most realistic trigger is a **bug in stake calculation logic** that could incorrectly compute voting power for all validators. This defensive programming failure should be fixed despite low exploitation likelihood.

## Recommendation

Add validation in `on_new_epoch()` to prevent empty validator sets, consistent with `leave_validator_set()`:

```move
// After line 1401 in stake.move
validator_set.active_validators = next_epoch_validators;
assert!(
    vector::length(&validator_set.active_validators) > 0,
    error::invalid_state(ELAST_VALIDATOR)
);
```

Additionally, consider adding validation in:
1. `EpochState::new()` to reject empty ValidatorVerifier
2. Consensus observer's `extract_on_chain_configs()` to verify non-empty validator set
3. Reconfiguration logic to validate validator count before committing epoch changes

## Proof of Concept

A complete PoC would require creating a test scenario where all validators fall below minimum stake, which would need to:
1. Set up a validator set with known stakes
2. Raise minimum_stake via governance above all validator stakes
3. Trigger epoch transition via `reconfigure()`
4. Demonstrate that the resulting ValidatorVerifier has `quorum_voting_power = 0`
5. Show that empty signatures pass verification

The lack of validation at the cited locations makes this logic vulnerability valid even without a runnable PoC.

## Notes

This is primarily a **defensive programming failure** rather than an easily exploitable vulnerability. The inconsistency between explicit validator exit protection and automatic removal logic creates a gap that could be triggered under extraordinary circumstances or through bugs in related systems. The validation should be added to maintain the invariant that at least one validator must exist at all times, as assumed by the genesis specification and enforced for explicit validator exits.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1373-1401)
```text
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L462-479)
```rust
    pub fn check_aggregated_voting_power(
        &self,
        aggregated_voting_power: u128,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let target = if check_super_majority {
            self.quorum_voting_power
        } else {
            self.total_voting_power - self.quorum_voting_power + 1
        };

        if aggregated_voting_power < target {
            return Err(VerifyError::TooLittleVotingPower {
                voting_power: aggregated_voting_power,
                expected_voting_power: target,
            });
        }
        Ok(aggregated_voting_power)
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L148-154)
```rust
    let validator_set: ValidatorSet = on_chain_configs
        .get()
        .expect("Failed to get the validator set from the on-chain configs!");
    let epoch_state = Arc::new(EpochState::new(
        on_chain_configs.epoch(),
        (&validator_set).into(),
    ));
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.spec.move (L33-37)
```text
    /// Requirement: An initial set of validators should exist before the end of genesis.
    /// Criticality: Low
    /// Implementation: To ensure that there will be a set of validators available to validate the genesis block, the
    /// length of the ValidatorSet.active_validators vector should be > 0.
    /// Enforcement: Formally verified via [high-level-req-4](set_genesis_end).
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L274-285)
```text
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```
