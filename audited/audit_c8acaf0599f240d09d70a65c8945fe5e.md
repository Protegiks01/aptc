# Audit Report

## Title
Missing Payload Size Validation After PayloadClient::pull_payload() Allows Byzantine Validators to Cause Proposal Failures

## Summary
The `ProposalGenerator` does not validate that payloads returned by `PayloadClient::pull_payload()` respect the size limits specified in `PayloadPullParameters`. A Byzantine validator can provide a malicious `PayloadClient` implementation that returns oversized payloads exceeding `max_receiving_block_*` limits, causing other validators to reject proposals and waste consensus rounds.

## Finding Description

The `PayloadClient` trait defines the interface for retrieving transaction payloads during block proposal generation: [1](#0-0) 

When a validator proposes a block, `ProposalGenerator::generate_proposal_inner()` calls `pull_payload()` with size limits: [2](#0-1) 

After `pull_payload()` returns at line 672, the payload is used directly to construct `BlockData` without validating that it respects the `max_txns` limits passed in `PayloadPullParameters`. The only operation performed is an optional transformation for execution limits (lines 674-684), but no validation against the original size constraints.

The returned payload is then used to create block proposals: [3](#0-2) 

When other validators receive this proposal, they validate it in `RoundManager::process_proposal()` against their `max_receiving_block_*` limits: [4](#0-3) 

**The Vulnerability:**

A Byzantine validator can implement a malicious `PayloadClient` that ignores the `max_txns` parameter and returns arbitrarily large payloads. Since the proposer doesn't validate the returned payload size:

1. If the payload exceeds `max_receiving_block_txns` (default 10,000) or `max_receiving_block_bytes` (default 6MB), all honest validators will reject the proposal
2. The round fails, no block is committed, and consensus progress is delayed
3. A Byzantine validator can repeatedly cause proposal failures whenever they are selected as leader

The configuration shows receiving limits are intentionally larger than sending limits to provide a safety margin: [5](#0-4) 

However, this safety margin doesn't help if the proposer blindly trusts a Byzantine `PayloadClient` that violates even the receiving limits.

## Impact Explanation

This vulnerability enables **consensus liveness degradation** attacks, qualifying as **High Severity** under the Aptos bug bounty program criteria for "Validator node slowdowns" and "Significant protocol violations."

**Concrete Impact:**
- A Byzantine validator with X% stake will be leader approximately X% of rounds
- In each of their rounds, they can cause proposal failure, wasting ~1-3 seconds per failed round
- With 4 Byzantine validators at 2.5% stake each (totaling 10% < 33% Byzantine threshold), consensus throughput could be degraded by ~10%
- Failed proposals increase transaction finality latency for end users

**Why High Severity:**
- Affects core consensus liveness without requiring > 33% Byzantine stake
- Degrades network performance proportionally to Byzantine validator stake
- No recovery mechanism beyond waiting for the next leader rotation
- Violates the expected behavior that consensus code validates all external inputs

This test demonstrates that oversized proposals are indeed rejected: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium-High**

In AptosBFT's Byzantine fault tolerance model, up to f < n/3 validators can behave arbitrarily (Byzantine). A malicious validator can:

1. Modify their node's `PayloadClient` implementation to return oversized payloads
2. Deploy this modified code on their validator infrastructure
3. Cause proposal failures whenever they are selected as leader

**Requirements:**
- Attacker controls at least one validator node (malicious validator scenario)
- Attacker can modify consensus code running on their node
- No additional privileges or exploits needed

**Mitigating Factors:**
- Requires controlling a validator node with stake
- Only affects rounds when the Byzantine validator is leader
- Other validators can still make progress in their own rounds

However, this is a **defense-in-depth failure**: consensus code should validate all inputs from potentially Byzantine components, even those running on the local node. The `PayloadClient` interface represents a trust boundary that lacks proper enforcement.

## Recommendation

Add validation after `pull_payload()` returns to ensure the payload respects the specified limits:

```rust
let (validator_txns, mut payload) = self
    .payload_client
    .pull_payload(
        PayloadPullParameters {
            max_poll_time: self.quorum_store_poll_time.saturating_sub(proposal_delay),
            max_txns: max_block_txns,
            max_txns_after_filtering: max_block_txns_after_filtering,
            soft_max_txns_after_filtering: max_txns_from_block_to_execute
                .unwrap_or(max_block_txns_after_filtering),
            max_inline_txns: self.max_inline_txns,
            maybe_optqs_payload_pull_params,
            user_txn_filter: payload_filter,
            pending_ordering,
            pending_uncommitted_blocks: pending_blocks.len(),
            recent_max_fill_fraction: max_fill_fraction,
            block_timestamp: timestamp,
        },
        validator_txn_filter,
    )
    .await
    .context("Fail to retrieve payload")?;

// VALIDATION: Ensure returned payload respects the limits
let validator_txn_count = validator_txns.len() as u64;
let validator_txn_bytes: u64 = validator_txns
    .iter()
    .map(|txn| txn.size_in_bytes() as u64)
    .sum();
let payload_count = payload.len() as u64;
let payload_bytes = payload.size() as u64;

ensure!(
    validator_txn_count + payload_count <= max_block_txns.count(),
    "PayloadClient returned {} transactions (+ {} validator txns) exceeding limit {}",
    payload_count,
    validator_txn_count,
    max_block_txns.count()
);

ensure!(
    validator_txn_bytes + payload_bytes <= max_block_txns.size_in_bytes(),
    "PayloadClient returned {} bytes (+ {} validator txn bytes) exceeding limit {}",
    payload_bytes,
    validator_txn_bytes,
    max_block_txns.size_in_bytes()
);
```

This validation should be added in `consensus/src/liveness/proposal_generator.rs` in the `generate_proposal_inner()` method immediately after line 672.

## Proof of Concept

```rust
#[cfg(test)]
mod test_byzantine_payload_client {
    use super::*;
    use aptos_consensus_types::{
        common::Payload,
        payload_pull_params::PayloadPullParameters,
        utils::PayloadTxnsSize,
    };
    use aptos_types::validator_txn::ValidatorTransaction;
    use aptos_validator_transaction_pool::TransactionFilter;
    
    /// Byzantine PayloadClient that ignores size limits
    struct ByzantinePayloadClient {
        oversized_txns: Vec<SignedTransaction>,
    }
    
    #[async_trait::async_trait]
    impl PayloadClient for ByzantinePayloadClient {
        async fn pull_payload(
            &self,
            config: PayloadPullParameters,
            _validator_txn_filter: TransactionFilter,
        ) -> anyhow::Result<(Vec<ValidatorTransaction>, Payload), QuorumStoreError> {
            // Maliciously ignore config.max_txns and return oversized payload
            // that exceeds max_receiving_block_txns (default 10000)
            let oversized_payload = Payload::DirectMempool(
                self.oversized_txns.clone()
            );
            
            println!(
                "Byzantine client requested max {} txns, {} bytes, but returning {} txns",
                config.max_txns.count(),
                config.max_txns.size_in_bytes(),
                oversized_payload.len()
            );
            
            Ok((vec![], oversized_payload))
        }
    }
    
    #[tokio::test]
    async fn test_byzantine_payload_client_causes_rejection() {
        // Create 15,000 transactions (exceeds max_receiving_block_txns of 10,000)
        let oversized_txns = create_vec_signed_transactions(15000);
        let byzantine_client = Arc::new(ByzantinePayloadClient { oversized_txns });
        
        // ProposalGenerator calls pull_payload with max_txns = 5000
        // but Byzantine client returns 15,000 transactions
        let params = PayloadPullParameters {
            max_txns: PayloadTxnsSize::new(5000, 3_000_000),
            max_txns_after_filtering: 5000,
            soft_max_txns_after_filtering: 5000,
            // ... other fields
        };
        
        let (_, payload) = byzantine_client
            .pull_payload(params, TransactionFilter::PendingTxnHashSet(HashSet::new()))
            .await
            .unwrap();
        
        // Proposer doesn't validate, creates block with 15,000 txns
        assert_eq!(payload.len(), 15000);
        
        // When honest validators receive this proposal, they reject it
        // because 15000 > max_receiving_block_txns (10000)
        // This causes the round to fail
    }
}
```

**Notes:**
This vulnerability demonstrates a defense-in-depth failure where the consensus protocol fails to validate outputs from a potentially Byzantine component (PayloadClient). While Byzantine validators are expected in BFT systems, the protocol should enforce interface contracts to limit the damage they can cause. The missing validation allows Byzantine validators to waste consensus rounds and degrade network liveness beyond what would otherwise be possible.

### Citations

**File:** consensus/src/payload_client/mod.rs (L13-20)
```rust
#[async_trait::async_trait]
pub trait PayloadClient: Send + Sync {
    async fn pull_payload(
        &self,
        config: PayloadPullParameters,
        validator_txn_filter: TransactionFilter,
    ) -> anyhow::Result<(Vec<ValidatorTransaction>, Payload), QuorumStoreError>;
}
```

**File:** consensus/src/liveness/proposal_generator.rs (L534-543)
```rust
        let block = if self.vtxn_config.enabled() {
            BlockData::new_proposal_ext(
                validator_txns,
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
```

**File:** consensus/src/liveness/proposal_generator.rs (L652-672)
```rust
        let (validator_txns, mut payload) = self
            .payload_client
            .pull_payload(
                PayloadPullParameters {
                    max_poll_time: self.quorum_store_poll_time.saturating_sub(proposal_delay),
                    max_txns: max_block_txns,
                    max_txns_after_filtering: max_block_txns_after_filtering,
                    soft_max_txns_after_filtering: max_txns_from_block_to_execute
                        .unwrap_or(max_block_txns_after_filtering),
                    max_inline_txns: self.max_inline_txns,
                    maybe_optqs_payload_pull_params,
                    user_txn_filter: payload_filter,
                    pending_ordering,
                    pending_uncommitted_blocks: pending_blocks.len(),
                    recent_max_fill_fraction: max_fill_fraction,
                    block_timestamp: timestamp,
                },
                validator_txn_filter,
            )
            .await
            .context("Fail to retrieve payload")?;
```

**File:** consensus/src/round_manager.rs (L1178-1193)
```rust
        let payload_len = proposal.payload().map_or(0, |payload| payload.len());
        let payload_size = proposal.payload().map_or(0, |payload| payload.size());
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** config/src/config/consensus_config.rs (L20-28)
```rust
const MAX_SENDING_BLOCK_TXNS_AFTER_FILTERING: u64 = 1800;
const MAX_SENDING_OPT_BLOCK_TXNS_AFTER_FILTERING: u64 = 1000;
const MAX_SENDING_BLOCK_TXNS: u64 = 5000;
pub(crate) static MAX_RECEIVING_BLOCK_TXNS: Lazy<u64> =
    Lazy::new(|| 10000.max(2 * MAX_SENDING_BLOCK_TXNS));
// stop reducing size at this point, so 1MB transactions can still go through
const MIN_BLOCK_BYTES_OVERRIDE: u64 = 1024 * 1024 + BATCH_PADDING_BYTES as u64;
// We should reduce block size only until two QS batch sizes.
const MIN_BLOCK_TXNS_AFTER_FILTERING: u64 = DEFEAULT_MAX_BATCH_TXNS as u64 * 2;
```

**File:** consensus/src/round_manager_tests/vtxn_on_proposal_test.rs (L272-322)
```rust
fn no_vote_on_proposal_ext_when_receiving_limit_exceeded() {
    let runtime = consensus_runtime();
    let mut playground = NetworkPlayground::new(runtime.handle().clone());

    let alg_config = ConsensusAlgorithmConfig::JolteonV2 {
        main: ConsensusConfigV1::default(),
        quorum_store_enabled: true,
        order_vote_enabled: false,
    };
    let vtxn_config = ValidatorTxnConfig::V1 {
        per_block_limit_txn_count: 5,
        per_block_limit_total_bytes: 400,
    };

    let local_config = ConsensusConfig {
        max_receiving_block_txns: 10,
        max_receiving_block_bytes: 800,
        ..Default::default()
    };

    let randomness_config = OnChainRandomnessConfig::default_enabled();
    let mut nodes = NodeSetup::create_nodes(
        &mut playground,
        runtime.handle().clone(),
        1,
        None,
        Some(OnChainConsensusConfig::V4 {
            alg: alg_config,
            vtxn: vtxn_config,
            window_size: DEFAULT_WINDOW_SIZE,
        }),
        None,
        Some(local_config),
        Some(randomness_config),
        None,
        false,
    );
    let node = &mut nodes[0];
    let genesis_qc = certificate_for_genesis();

    let block_too_many_txns = Block::new_proposal_ext(
        vec![],
        Payload::DirectMempool(create_vec_signed_transactions(11)),
        1,
        1,
        genesis_qc.clone(),
        &node.signer,
        Vec::new(),
    )
    .unwrap();

```
