# Audit Report

## Title
Malicious Peers Can Bypass Rate-Limiting by Triggering StorageErrorEncountered Errors for Storage Reconnaissance and DoS

## Summary
The storage service's request moderator only rate-limits "invalid requests" that fail the `can_service` validation check, but does not rate-limit requests that pass validation yet fail during actual storage reads with `StorageErrorEncountered` errors. Malicious peers can exploit this gap to repeatedly probe storage boundaries, map prune windows, and cause resource exhaustion without triggering the peer-banning mechanism.

## Finding Description

The storage service implements a request moderator that tracks invalid requests from peers and temporarily ignores peers that exceed a threshold (default: 500 invalid requests). However, there's a critical distinction in how errors are classified: [1](#0-0) 

The moderator only increments `invalid_request_count` when `StorageServerSummary::can_service` returns `false`. This validation is based on high-level data range summaries (transactions, outputs, states) advertised by the storage server. [2](#0-1) 

When a request passes validation but subsequently fails during actual storage read operations, it returns a `StorageErrorEncountered` error. These errors are converted from `AptosDbError` types like `NotFound` or `MissingRootError`: [3](#0-2) [4](#0-3) 

Crucially, when these storage errors occur, they are only logged and counted in metrics, but do NOT increment the peer's invalid request count: [5](#0-4) 

The error transformation explicitly converts `StorageErrorEncountered` to `InternalError`, not `InvalidRequest`: [6](#0-5) 

**Attack Scenario:**

1. Attacker connects as a public network peer and queries `GetStorageServerSummary` to learn advertised data ranges (e.g., transactions 1000-50000, states 1000-50000)
2. Attacker sends requests targeting versions at the boundaries or just inside the advertised ranges
3. Due to race conditions with pruning, Merkle tree node availability, or other timing issues, some requests pass `can_service` validation but fail during actual storage reads
4. These failures return `StorageErrorEncountered` errors which do NOT increment `invalid_request_count`
5. Attacker repeats this process systematically to:
   - Map exact storage availability boundaries
   - Discover prune windows
   - Identify which specific versions are available vs. missing
   - Cause continuous storage read operations and error handling overhead
6. The peer is never rate-limited because these aren't counted as "invalid requests"

## Impact Explanation

This vulnerability enables three types of attacks:

**1. Information Disclosure (Primary Impact):** Attackers can precisely map storage internals including:
- Exact prune windows and boundaries
- Which versions are truly available vs. advertised
- Storage capacity and performance characteristics
- This information aids in targeting other attacks or identifying network weaknesses

**2. Resource Exhaustion:** Each probing request triggers:
- Storage database reads (I/O operations)
- Merkle tree traversal attempts
- Error handling and logging overhead
- Network bandwidth consumption

**3. Availability Degradation:** Continuous probing from multiple peers can degrade storage service performance for legitimate peers.

According to the Aptos bug bounty criteria, this qualifies as **Medium Severity** ($10,000):
- State inconsistencies requiring intervention (discovering exact storage state beyond advertised summaries)
- Limited DoS capability (not total network unavailability but degraded service)
- Information disclosure enabling further attacks

The default configuration allows 500 invalid requests per peer before banning, but storage errors are unlimited: [7](#0-6) 

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry:** Any peer can connect to the public network and send storage service requests
2. **Easy to Discover:** The distinction between validation errors and storage errors is observable through error responses
3. **No Special Resources Required:** No validator access, stake, or cryptographic material needed
4. **Clear Attack Vector:** The gap between `can_service` validation and actual storage availability is inherent to distributed storage systems with pruning
5. **Practical Exploitation:** Attackers can use binary search or systematic probing to efficiently map boundaries
6. **Multiple Peers:** An attacker can use multiple peer identities to amplify the attack

The vulnerability is especially exploitable because:
- Storage summaries are periodically refreshed (every 100ms by default)
- Pruning operations create natural windows where summary data is stale
- Merkle tree nodes may be partially pruned while data ranges still advertise availability

## Recommendation

Implement rate-limiting for `StorageErrorEncountered` errors in addition to invalid requests. The fix should track and limit storage errors separately from validation errors:

**Proposed Solution:**

1. **Extend `UnhealthyPeerState` to track storage errors:**

```rust
pub struct UnhealthyPeerState {
    ignore_start_time: Option<Instant>,
    invalid_request_count: u64,
    storage_error_count: u64,  // NEW: Track storage errors
    max_invalid_requests: u64,
    max_storage_errors: u64,  // NEW: Separate threshold for storage errors
    min_time_to_ignore_secs: u64,
    time_service: TimeService,
}
```

2. **Update error handling in handler.rs to report storage errors to moderator:**

```rust
match self.validate_and_handle_request(peer_network_id, &request) {
    Err(error) => {
        // Update the error counter
        increment_counter(
            &metrics::STORAGE_ERRORS_ENCOUNTERED,
            peer_network_id.network_id(),
            error.get_label().into(),
        );

        // NEW: Report storage errors to moderator for rate limiting
        if matches!(error, Error::StorageErrorEncountered(_)) {
            self.request_moderator
                .report_storage_error(peer_network_id, &request);
        }
        
        // ... rest of error handling
    }
}
```

3. **Add configuration parameter:**

```rust
pub struct StorageServiceConfig {
    // ... existing fields
    pub max_storage_errors_per_peer: u64,  // NEW: Default 100
}
```

4. **Implement gradual rate limiting:**
    - Track storage errors separately from validation errors
    - Use a lower threshold (e.g., 100 storage errors vs. 500 invalid requests)
    - Apply the same exponential backoff mechanism
    - Consider tracking storage errors with a sliding window to allow legitimate transient failures

## Proof of Concept

```rust
// This PoC demonstrates how a malicious peer can probe storage boundaries
// without being rate-limited

#[tokio::test]
async fn test_storage_error_bypass_rate_limiting() {
    // Setup: Initialize storage service with known data range
    let (storage_service, peer_network_id) = setup_storage_service_with_pruning().await;
    
    // Step 1: Query storage summary to learn advertised ranges
    let summary = storage_service
        .get_storage_server_summary(&peer_network_id)
        .await
        .unwrap();
    
    let transaction_range = summary.data_summary.transactions.unwrap();
    let prune_boundary = transaction_range.lowest();
    
    // Step 2: Send 1000+ requests for versions just below the prune boundary
    // These pass validation (within advertised range) but fail on storage read
    let mut storage_error_count = 0;
    
    for i in 0..1000 {
        let version = prune_boundary.saturating_sub(i);
        
        let request = StorageServiceRequest::new(
            DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                proof_version: transaction_range.highest(),
                start_version: version,
                end_version: version,
                include_events: false,
            }),
            false,
        );
        
        match storage_service.process_request(&peer_network_id, request).await {
            Err(StorageServiceError::InternalError(_)) => {
                // This is a StorageErrorEncountered converted to InternalError
                storage_error_count += 1;
            }
            _ => {}
        }
    }
    
    // Step 3: Verify peer is NOT banned despite 1000+ storage errors
    // The peer should still be able to make requests (not ignored)
    let moderator_state = storage_service.get_moderator_peer_state(&peer_network_id);
    assert!(!moderator_state.is_ignored());
    assert!(storage_error_count > 500);  // Exceeded "invalid request" threshold
    
    // Step 4: Demonstrate reconnaissance capability
    // By observing which requests succeed vs fail, attacker maps exact prune window
    let mut exact_prune_boundary = None;
    for version in (prune_boundary - 100)..prune_boundary {
        let request = create_transaction_request(version, version);
        if storage_service.process_request(&peer_network_id, request).await.is_ok() {
            exact_prune_boundary = Some(version);
            break;
        }
    }
    
    assert!(exact_prune_boundary.is_some());
    println!("Attacker discovered exact prune boundary: {:?}", exact_prune_boundary);
}
```

**Notes:**

This vulnerability breaks the **Resource Limits** invariant (operations must respect computational limits) by allowing unlimited storage read attempts, and the **Network Protocol** security assumption that malicious peers should be rate-limited when exhibiting abusive behavior.

The fix should maintain legitimate error tolerance (occasional storage errors due to race conditions) while preventing systematic abuse for reconnaissance and DoS.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L154-186)
```rust
            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

```

**File:** state-sync/storage-service/server/src/error.rs (L7-17)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum Error {
    #[error("Invalid request received: {0}")]
    InvalidRequest(String),
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
    #[error("Too many invalid requests: {0}")]
    TooManyInvalidRequests(String),
    #[error("Unexpected error encountered: {0}")]
    UnexpectedErrorEncountered(String),
}
```

**File:** state-sync/storage-service/server/src/error.rs (L43-47)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
}
```

**File:** storage/storage-interface/src/errors.rs (L9-24)
```rust
/// This enum defines errors commonly used among `AptosDB` APIs.
#[derive(Clone, Debug, Error)]
pub enum AptosDbError {
    /// A requested item is not found.
    #[error("{0} not found.")]
    NotFound(String),
    /// Requested too many items.
    #[error("Too many items requested: at least {0} requested, max is {1}")]
    TooManyRequested(u64, u64),
    #[error("Missing state root node at version {0}, probably pruned.")]
    MissingRootError(u64),
    /// Other non-classified error.
    #[error("AptosDB Other Error: {0}")]
    Other(String),
    #[error("AptosDB RocksDb Error: {0}")]
    RocksDbIncompleteResult(String),
```

**File:** state-sync/storage-service/server/src/handler.rs (L151-173)
```rust
            match self.validate_and_handle_request(peer_network_id, &request) {
                Err(error) => {
                    // Update the error counter
                    increment_counter(
                        &metrics::STORAGE_ERRORS_ENCOUNTERED,
                        peer_network_id.network_id(),
                        error.get_label().into(),
                    );

                    // Periodically log the failure
                    sample!(
                            SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
                            warn!(LogSchema::new(LogEntry::StorageServiceError)
                                .error(&error)
                                .peer_network_id(peer_network_id)
                                .request(&request)
                                .optimistic_fetch_related(optimistic_fetch_related)
                        );
                    );

                    // Return the error
                    Err(error)
                },
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```

**File:** config/src/config/state_sync_config.rs (L201-201)
```rust
            max_invalid_requests_per_peer: 500,
```
