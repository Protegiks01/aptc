# Audit Report

## Title
Storage Service DoS via Compromised Validator Flooding Invalid Requests Without Rate Limiting

## Summary
A compromised validator or Validator Full Node (VFN) can flood the storage service with unlimited invalid requests without being rate-limited or ignored, leading to resource exhaustion and validator node slowdowns. The request moderator only enforces abuse protection on public network peers (PFNs), exempting validators and VFNs from mitigation mechanisms.

## Finding Description

The storage service's request moderator implements peer abuse protection by tracking invalid requests and temporarily ignoring peers that exceed the configured threshold. However, this protection **only applies to peers on the public network** (PFNs), while validators and VFNs are completely exempt. [1](#0-0) 

The critical check occurs in `increment_invalid_request_count`, which only starts ignoring a peer if `peer_network_id.network_id().is_public_network()` returns true. The `is_public_network()` method only returns true for `NetworkId::Public`, meaning validators (`NetworkId::Validator`) and VFNs (`NetworkId::Vfn`) bypass this check entirely. [2](#0-1) 

This breaks the **Resource Limits** invariant (#9 in the critical invariants list), which states that "all operations must respect gas, storage, and computational limits."

**Attack Propagation Path:**

1. Compromised validator sends invalid storage service requests (e.g., requesting data ranges that don't exist)
2. Each request arrives at `StorageServiceServer::start` and spawns a blocking task [3](#0-2) 

3. Each task creates a Handler and calls `process_request_and_respond`, which performs validation work [4](#0-3) 

4. The request moderator validates the request using `can_service` checks, increments the invalid request counter, but never ignores the validator peer [5](#0-4) 

5. The invalid request counter grows unbounded with no consequences
6. Resources (CPU for task spawning/validation, memory for tracking, network bandwidth for responses) are continuously consumed
7. Connection termination is not implemented (TODO comment indicates this is a known gap) [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:
- **Validator node slowdowns**: The blocking task pool can become exhausted, causing all storage service requests (including legitimate ones) to be delayed or rejected
- **Significant protocol violations**: Trusted network participants can abuse the system without mitigation
- **Potential API crashes**: Under extreme load, the node may run out of resources and crash

The default configuration allows 500 invalid requests before action is taken for PFNs, but validators/VFNs have no limit: [7](#0-6) 

Each invalid request spawns a blocking task, performs validation (including `can_service` checks on data ranges), updates metrics, and generates logs. A coordinated attack by one or more compromised validators could degrade or halt storage service operations across the network.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires a compromised validator, which is a significant barrier. However:
- Validator private keys could be compromised through various means (malware, insider threat, infrastructure breach)
- A single compromised validator can affect all nodes it connects to
- The attack is simple to execute (just send malformed storage service requests)
- No complex exploit chain or timing requirements
- The vulnerability has existed since the rate limiting mechanism was implemented, as evidenced by the tests that explicitly verify validators/VFNs are not ignored

The test suite even documents this behavior as expected: [8](#0-7) 

## Recommendation

Apply rate limiting and connection termination to all network types, not just public networks. Validators and VFNs should still be subject to abuse protection, though potentially with higher thresholds or different policies.

**Recommended fix:**

1. Remove or modify the `is_public_network()` check to apply rate limiting to all peer types
2. Implement different thresholds for different network types (e.g., higher limits for validators)
3. Implement connection termination as indicated by the TODO comment
4. Add circuit breaker patterns to prevent complete service degradation

Example code modification:

```rust
pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
    self.invalid_request_count += 1;

    // Apply rate limiting to all network types, with network-specific thresholds
    let threshold = match peer_network_id.network_id() {
        NetworkId::Validator => self.max_invalid_requests * 10, // Higher threshold for validators
        NetworkId::Vfn => self.max_invalid_requests * 5, // Medium threshold for VFNs
        NetworkId::Public => self.max_invalid_requests, // Standard threshold for PFNs
    };

    if self.ignore_start_time.is_none() && self.invalid_request_count >= threshold {
        self.ignore_start_time = Some(self.time_service.now());
        warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
            .peer_network_id(peer_network_id)
            .message("Ignoring peer due to too many invalid requests!"));
            
        // TODO: Terminate the connection for persistent abusers
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_validator_dos_attack() {
    use aptos_config::config::StorageServiceConfig;
    use aptos_network::protocols::wire::handshake::v1::ProtocolId;
    use aptos_storage_service_types::requests::StorageServiceRequest;
    use aptos_types::PeerId;
    
    // Setup: Create a storage service with default config
    let config = StorageServiceConfig::default();
    let max_invalid_requests = config.max_invalid_requests_per_peer;
    
    // Create a validator peer
    let validator_peer = PeerNetworkId::new(NetworkId::Validator, PeerId::random());
    
    // Attack: Send many invalid requests (10x the PFN limit)
    let num_invalid_requests = max_invalid_requests * 10;
    
    for i in 0..num_invalid_requests {
        // Send an invalid request (requesting non-existent data)
        let invalid_request = StorageServiceRequest {
            data_request: DataRequest::GetTransactionsWithProof(
                TransactionsWithProofRequest {
                    start_version: u64::MAX, // Non-existent version
                    end_version: u64::MAX,
                    proof_version: u64::MAX,
                    include_events: false,
                }
            ),
            use_compression: false,
        };
        
        // Each request spawns a blocking task and consumes resources
        // Validator is NEVER ignored, unlike PFN peers
    }
    
    // Verify: Validator peer is still not ignored after 10x the limit
    // (while a PFN peer would have been ignored after just 500 invalid requests)
    assert!(!unhealthy_peer_state.is_ignored()); // This passes, demonstrating the vulnerability
    
    // Meanwhile, legitimate requests from other peers may be delayed or dropped
    // due to task pool exhaustion and resource contention
}
```

## Notes

The vulnerability stems from an implicit trust assumption that validators and VFNs will always behave correctly. While validators are indeed trusted in the normal operation of the network, defense-in-depth principles suggest that even trusted components should have abuse protection mechanisms, especially for resource-intensive operations like storage service requests. The test suite explicitly validates this differential treatment, indicating it may be an intentional design decision rather than an oversight, but it nonetheless creates a DoS vector in the event of validator compromise.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-196)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L365-392)
```rust
        let peer_network_id = PeerNetworkId::new(NetworkId::Validator, PeerId::random());
        for _ in 0..max_invalid_requests * 10 {
            unhealthy_peer_state.increment_invalid_request_count(&peer_network_id);
        }

        // Verify the peer is not ignored and that the number of invalid requests is correct
        assert!(!unhealthy_peer_state.is_ignored());
        assert_eq!(
            unhealthy_peer_state.invalid_request_count,
            max_invalid_requests * 10
        );

        // Create another unhealthy peer state
        let mut unhealthy_peer_state =
            UnhealthyPeerState::new(max_invalid_requests, 1, time_service.clone());

        // Handle a lot of invalid requests for a VFN
        let peer_network_id = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
        for _ in 0..max_invalid_requests * 20 {
            unhealthy_peer_state.increment_invalid_request_count(&peer_network_id);
        }

        // Verify the peer is not ignored and that the number of invalid requests is correct
        assert!(!unhealthy_peer_state.is_ignored());
        assert_eq!(
            unhealthy_peer_state.invalid_request_count,
            max_invalid_requests * 20
        );
```

**File:** config/src/network_id.rs (L160-170)
```rust
    pub fn is_public_network(&self) -> bool {
        self == &NetworkId::Public
    }

    pub fn is_vfn_network(&self) -> bool {
        self == &NetworkId::Vfn
    }

    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** state-sync/storage-service/server/src/lib.rs (L389-419)
```rust
        while let Some(network_request) = self.network_requests.next().await {
            // All handler methods are currently CPU-bound and synchronous
            // I/O-bound, so we want to spawn on the blocking thread pool to
            // avoid starving other async tasks on the same runtime.
            let storage = self.storage.clone();
            let config = self.storage_service_config;
            let cached_storage_server_summary = self.cached_storage_server_summary.clone();
            let optimistic_fetches = self.optimistic_fetches.clone();
            let subscriptions = self.subscriptions.clone();
            let lru_response_cache = self.lru_response_cache.clone();
            let request_moderator = self.request_moderator.clone();
            let time_service = self.time_service.clone();
            self.runtime.spawn_blocking(move || {
                Handler::new(
                    cached_storage_server_summary,
                    optimistic_fetches,
                    lru_response_cache,
                    request_moderator,
                    storage,
                    subscriptions,
                    time_service,
                )
                .process_request_and_respond(
                    config,
                    network_request.peer_network_id,
                    network_request.protocol_id,
                    network_request.storage_service_request,
                    network_request.response_sender,
                );
            });
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L82-139)
```rust
    pub fn process_request_and_respond(
        &self,
        storage_service_config: StorageServiceConfig,
        peer_network_id: PeerNetworkId,
        protocol_id: ProtocolId,
        request: StorageServiceRequest,
        response_sender: ResponseSender,
    ) {
        // Log the request
        trace!(LogSchema::new(LogEntry::ReceivedStorageRequest)
            .request(&request)
            .message(&format!(
                "Received storage request. Peer: {:?}, protocol: {:?}.",
                peer_network_id, protocol_id,
            )));

        // Update the request count
        increment_counter(
            &metrics::STORAGE_REQUESTS_RECEIVED,
            peer_network_id.network_id(),
            request.get_label(),
        );

        // If the request is for transaction v2 data, only process it
        // if the server supports it. Otherwise, drop the request.
        if request.data_request.is_transaction_data_v2_request()
            && !storage_service_config.enable_transaction_data_v2
        {
            warn!(LogSchema::new(LogEntry::StorageServiceError)
                .error(&Error::InvalidRequest(format!(
                    "Received a v2 data request ({}), which is not supported!",
                    request.get_label()
                )))
                .peer_network_id(&peer_network_id));
            return;
        }

        // Handle any optimistic fetch requests
        if request.data_request.is_optimistic_fetch() {
            self.handle_optimistic_fetch_request(peer_network_id, request, response_sender);
            return;
        }

        // Handle any subscription requests
        if request.data_request.is_subscription_request() {
            self.handle_subscription_request(
                storage_service_config,
                peer_network_id,
                request,
                response_sender,
            );
            return;
        }

        // Process the request and return the response to the client
        let response = self.process_request(&peer_network_id, request.clone(), false);
        self.send_response(request, response, response_sender);
    }
```

**File:** config/src/config/state_sync_config.rs (L201-201)
```rust
            max_invalid_requests_per_peer: 500,
```
