# Audit Report

## Title
Governance-Triggered Network Halt via Unvalidated window_size Configuration

## Summary
A malicious or erroneous governance proposal can set the consensus configuration's `window_size` to zero, causing all validator nodes to panic and crash during block processing or recovery, resulting in total network liveness failure requiring emergency intervention.

## Finding Description

The vulnerability exists at the intersection of three system components:

**1. Missing Move Framework Validation**

The `consensus_config.move` module accepts consensus configuration updates through governance but only validates that the serialized bytes are non-empty, not the actual field values: [1](#0-0) 

**2. Public Panic-Inducing Utility Function**

The `calculate_window_start_round` function is publicly exposed through the consensus crate and contains an unconditional assert that panics when `window_size == 0`: [2](#0-1) 

The `util` module is publicly exported: [3](#0-2) 

**3. Multiple Vulnerable Execution Paths**

When validators load a consensus config with `window_size: Some(0)`, multiple critical code paths trigger the panic:

**Path A - Block Insertion**: During normal consensus operation, `BlockStore::insert_block` calls `get_ordered_block_window`, which unwraps the `Option<u64>` and passes it to `calculate_window_start_round`: [4](#0-3) [5](#0-4) 

**Path B - Recovery**: During node startup/recovery, `find_root_with_window` directly calls `calculate_window_start_round` with the unwrapped window_size: [6](#0-5) [7](#0-6) 

**Path C - Sync Manager**: During fast-forward sync, the sync manager directly calls `calculate_window_start_round`: [8](#0-7) 

**Attack Propagation**:

1. Attacker submits governance proposal setting `OnChainConsensusConfig::V5 { window_size: Some(0), ... }`
2. The Move module accepts this configuration (only checks bytes are non-empty)
3. At next epoch transition, all validators load the malicious config: [9](#0-8) 

4. When any block is inserted, recovered, or synced, validators panic and crash
5. All validators crash simultaneously due to deterministic config application
6. Network enters total liveness failure

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

- **Total loss of liveness/network availability**: All validators crash simultaneously when processing blocks with window_size=0, halting the entire network
- **Non-recoverable without intervention**: Requires emergency coordination to roll back the malicious config or deploy a hotfix, potentially requiring a hardfork
- **Deterministic network-wide failure**: All validators process the same on-chain config and fail identically

The impact exceeds typical DoS attacks because:
1. It persists across validator restarts (config is on-chain)
2. It affects 100% of validators deterministically
3. Recovery requires coordinated emergency response
4. It bypasses normal safety mechanisms (governance is trusted)

## Likelihood Explanation

**Likelihood: Medium to High**

**Favorable conditions for exploitation**:
- Governance proposals can be submitted by any account with sufficient voting power
- On testnets/devnets, governance thresholds are lower for testing purposes
- A compromised governance participant or buggy proposal generation tool could trigger this accidentally
- The Move framework provides no validation against this specific misconfiguration

**Mitigating factors**:
- Requires governance proposal approval (though this is by design exploitable)
- On mainnet, governance has higher voting thresholds
- The Aptos team likely reviews proposals before execution

**Historical precedent**: There exists a test explicitly checking that window_size=0 causes a panic: [10](#0-9) 

This indicates the developers are aware of the panic but did not implement proper validation at the governance layer.

## Recommendation

Implement multi-layer validation:

**1. Move Framework Validation** (Primary Defense):

Add a native function to validate consensus config structure before accepting it:

```move
// In consensus_config.move
native fun validate_consensus_config_internal(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Add validation before accepting config
    assert!(
        validate_consensus_config_internal(config),
        error::invalid_argument(EINVALID_CONFIG)
    );
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**2. Rust Validation** (Defense in Depth):

Implement validation in the Rust deserialization path:

```rust
// In types/src/on_chain_config/consensus_config.rs
impl OnChainConsensusConfig {
    pub fn validate(&self) -> Result<()> {
        if let Some(window_size) = self.window_size() {
            ensure!(window_size > 0, "window_size must be greater than 0");
            ensure!(window_size < 1000000, "window_size must be reasonable"); // Add upper bound
        }
        Ok(())
    }
}
```

**3. Replace Assert with Result** (Graceful Degradation):

Change the panic-inducing assert to return a Result:

```rust
// In consensus/src/util/mod.rs
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Result<Round> {
    ensure!(window_size > 0, "window_size must be greater than 0");
    Ok((current_round + 1).saturating_sub(window_size))
}
```

## Proof of Concept

**Rust Unit Test** (demonstrates the panic):

```rust
#[test]
#[should_panic(expected = "window_size > 0")]
fn test_governance_triggered_panic() {
    use aptos_consensus::util::calculate_window_start_round;
    
    // Simulate config loaded from governance with window_size=0
    let current_round = 100;
    let malicious_window_size = 0u64;
    
    // This will panic, crashing the validator
    let _ = calculate_window_start_round(current_round, malicious_window_size);
}
```

**Move Governance Attack Simulation**:

```move
script {
    use aptos_framework::consensus_config;
    use aptos_framework::aptos_governance;
    
    fun exploit_window_size_zero(framework_signer: &signer) {
        // Create malicious config with window_size = Some(0)
        let malicious_config = create_malicious_config_with_zero_window_size();
        
        // This will be accepted because only byte length is checked
        consensus_config::set_for_next_epoch(framework_signer, malicious_config);
        
        // Trigger epoch change
        aptos_governance::reconfigure(framework_signer);
        
        // All validators will crash at next block insertion/recovery
    }
}
```

## Notes

While the test `test_window_root_window_size_0_failure` documents the panic behavior, it only tests the internal `find_window_root` function which has a protective assert. The vulnerability exists because:

1. Multiple other code paths (`get_ordered_block_window`, `find_root_with_window`, sync manager) call `calculate_window_start_round` without the same protection
2. The governance layer lacks validation to prevent malicious configs from reaching these code paths
3. The function is publicly accessible, violating defense-in-depth principles

The fix requires validation at the governance entry point, not just at individual call sites.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/util/mod.rs (L26-29)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
}
```

**File:** consensus/src/lib.rs (L48-48)
```rust
pub mod util;
```

**File:** consensus/src/block_storage/block_store.rs (L421-424)
```rust
        let block_window = self
            .inner
            .read()
            .get_ordered_block_window(&block, self.window_size)?;
```

**File:** consensus/src/block_storage/block_tree.rs (L278-282)
```rust
        let Some(window_size) = window_size else {
            return Ok(OrderedBlockWindow::empty());
        };
        let round = block.round();
        let window_start_round = calculate_window_start_round(round, window_size);
```

**File:** consensus/src/persistent_liveness_storage.rs (L102-108)
```rust
    pub fn find_root_with_window(
        &self,
        blocks: &mut Vec<Block>,
        quorum_certs: &mut Vec<QuorumCert>,
        order_vote_enabled: bool,
        window_size: u64,
    ) -> Result<RootInfo> {
```

**File:** consensus/src/persistent_liveness_storage.rs (L165-165)
```rust
        let window_start_round = calculate_window_start_round(commit_block.round(), window_size);
```

**File:** consensus/src/block_storage/sync_manager.rs (L349-353)
```rust
            Some(window_size) => {
                let target_round = calculate_window_start_round(
                    highest_commit_cert.ledger_info().ledger_info().round(),
                    window_size,
                )
```

**File:** consensus/src/epoch_manager.rs (L896-896)
```rust
            onchain_consensus_config.window_size(),
```

**File:** consensus/src/block_storage/execution_pool/block_window_test.rs (L128-142)
```rust
#[should_panic]
#[tokio::test]
async fn test_window_root_window_size_0_failure() {
    const NUM_BLOCKS: usize = 5;
    let window_size = Some(1u64);
    let (_, block_store, pipelined_blocks) =
        create_block_tree_no_forks::<{ NUM_BLOCKS }>(NUM_BLOCKS as u64, window_size).await;

    // Genesis ──> A1 ──> ... ──> A4
    let [genesis_block, _, _, _, _] = pipelined_blocks;

    // Window size must be greater than 0, should panic
    let window_size = Some(0u64);
    block_store.find_window_root(genesis_block.id(), window_size);
}
```
