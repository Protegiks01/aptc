# Audit Report

## Title
Missing Test Coverage for ULEB128 usize Overflow on 32-bit Systems and Unsafe Cast in Transaction Argument Validation

## Summary
The test suite does NOT verify that ULEB128-encoded lengths can't overflow when decoded into `usize` on 32-bit systems. Additionally, an unsafe cast from `u64` to `usize` exists in transaction argument validation that could cause silent truncation on 32-bit platforms, potentially breaking deterministic execution guarantees.

## Finding Description

**Test Coverage Gap:**
The test files contain no verification of ULEB128 decoding behavior on 32-bit systems: [1](#0-0) [2](#0-1) [3](#0-2) 

No tests use `cfg(target_pointer_width = "32")` or test ULEB128 values exceeding `u32::MAX` when converting to `usize`.

**Unsafe Cast Vulnerability:**
In transaction argument validation, the `get_len()` function performs an unsafe cast: [4](#0-3) 

This function is used for decoding vector and string lengths from BCS-serialized transaction arguments: [5](#0-4) [6](#0-5) 

On 32-bit systems, if a ULEB128-encoded length value exceeds `u32::MAX` (4,294,967,295), the direct cast `len as usize` silently truncates to the lower 32 bits, potentially resulting in a value of 0 or an incorrect small number.

**Deterministic Execution Violation:**
This breaks the **Deterministic Execution** invariant: if validators run on different architectures (32-bit vs 64-bit), they would process identical transactions differently, leading to consensus divergence and potential chain splits.

## Impact Explanation

**Severity Assessment: Medium**

While this constitutes a violation of deterministic execution guarantees, the practical impact is limited:

1. **Partial Mitigation:** Additional validation exists at multiple layers:
   - `MAX_NUM_BYTES` limit (1,000,000 bytes) in `read_n_bytes()`
   - Cursor position validation ensuring all data is consumed [7](#0-6) 

2. **Limited Attack Surface:** Modern Aptos validators likely run exclusively on 64-bit systems, making exploitation in production unlikely.

3. **No Direct Fund Loss:** The vulnerability does not directly enable theft or fund manipulation, though it could cause state inconsistencies requiring intervention.

## Likelihood Explanation

**Likelihood: Low**

The attack requires:
- At least one validator running on a 32-bit system (uncommon in modern blockchain infrastructure)
- Crafting transaction arguments with ULEB128 lengths > `u32::MAX`
- Bypassing multiple validation layers

Production Aptos validators standardize on 64-bit architectures, significantly reducing exploitation probability. However, the code should maintain platform-independent correctness guarantees.

## Recommendation

**1. Add Comprehensive Tests:**
Create tests verifying ULEB128 behavior on 32-bit systems:

```rust
#[cfg(target_pointer_width = "32")]
#[test]
fn test_uleb128_usize_overflow_32bit() {
    // Test that values > u32::MAX are properly rejected
    let large_value: u64 = 0x100000000; // u32::MAX + 1
    // Test should verify proper error handling
}
```

**2. Fix Unsafe Cast:**
Replace the unsafe cast with checked conversion in `get_len()`:

```rust
fn get_len(cursor: &mut Cursor<&[u8]>) -> Result<usize, VMStatus> {
    match read_uleb128_as_u64(cursor) {
        Err(_) => Err(VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            None,
        )),
        Ok(len) => len.try_into().map_err(|_| {
            VMStatus::error(
                StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
                Some("Length value exceeds platform usize limit".to_string()),
            )
        }),
    }
}
```

**3. Follow Existing Safe Pattern:**
The deserializer already uses safe conversion via `try_into()`: [8](#0-7) 

This pattern should be consistently applied across all ULEB128 to `usize` conversions.

## Proof of Concept

To demonstrate the issue, a test would need to:

1. Simulate 32-bit environment using `cfg(target_pointer_width = "32")`
2. Create a BCS-encoded transaction argument with ULEB128 length > `u32::MAX`
3. Verify that current code silently truncates while fixed code properly rejects

```rust
#[test]
#[cfg(target_pointer_width = "32")]
fn test_uleb128_length_overflow_detection() {
    use std::io::Cursor;
    use move_binary_format::file_format_common::write_u64_as_uleb128;
    
    // Create ULEB128 encoding of value exceeding u32::MAX
    let mut data = vec![];
    let large_len: u64 = 0x100000000; // 4,294,967,296
    write_u64_as_uleb128(&mut BinaryData::from(data.clone()), large_len).unwrap();
    
    let mut cursor = Cursor::new(&data[..]);
    let result = get_len(&mut cursor);
    
    // Current implementation: silently truncates (WRONG)
    // Fixed implementation: should return error (CORRECT)
    assert!(result.is_err(), "Should reject length values exceeding usize on 32-bit");
}
```

## Notes

- The primary issue is **missing test coverage** for platform-specific behavior
- The unsafe cast exists but has limited practical exploitability due to current deployment constraints
- This represents a code correctness issue that violates deterministic execution principles
- Priority should be given to ensuring all ULEB128â†’usize conversions use `try_into()` for platform independence
- While not immediately exploitable, defensive programming requires proper validation regardless of current deployment architecture

### Citations

**File:** third_party/move/move-binary-format/src/unit_tests/binary_tests.rs (L1-57)
```rust
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::{file_format::Bytecode, file_format_common::*};
use proptest::prelude::*;

#[test]
fn binary_len() {
    let mut binary_data = BinaryData::new();
    for _ in 0..100 {
        binary_data.push(1).unwrap();
    }
    assert_eq!(binary_data.len(), 100);
}

#[test]
fn test_max_number_of_bytecode() {
    let mut nops = vec![];
    for _ in 0..u16::MAX - 1 {
        nops.push(Bytecode::Nop);
    }
    nops.push(Bytecode::Branch(0));

    let result = Bytecode::get_successors(u16::MAX - 1, &nops);
    assert_eq!(result, vec![0]);
}

proptest! {
    #[test]
    fn vec_to_binary(vec in any::<Vec<u8>>()) {
        let binary_data = BinaryData::from(vec.clone());
        let vec2 = binary_data.into_inner();
        assert_eq!(vec.len(), vec2.len());
    }
}

proptest! {
    #[test]
    fn binary_push(item in any::<u8>()) {
        let mut binary_data = BinaryData::new();
        binary_data.push(item).unwrap();
        assert_eq!(binary_data.into_inner()[0], item);
    }
}

proptest! {
    #[test]
    fn binary_extend(vec in any::<Vec<u8>>()) {
        let mut binary_data = BinaryData::new();
        binary_data.extend(&vec).unwrap();
        assert_eq!(binary_data.len(), vec.len());
        for (index, item) in vec.iter().enumerate() {
            assert_eq!(*item, binary_data.as_inner()[index]);
        }
    }
}
```

**File:** third_party/move/move-binary-format/src/unit_tests/number_tests.rs (L24-82)
```rust
fn uleb128_test_u64(value: u64, expected_bytes: usize) {
    let mut buf = BinaryData::new();
    write_u64_as_uleb128(&mut buf, value).expect("serialization should work");
    assert_eq!(buf.len(), expected_bytes);
    let buf = buf.into_inner();
    check_vector(&buf);
    let mut cursor = Cursor::new(&buf[..]);
    let val = read_uleb128_as_u64(&mut cursor).expect("deserialization should work");
    assert_eq!(value, val);
}

#[test]
fn uleb128_test() {
    uleb128_test_u64(0, 1);
    let mut n: usize = 1;
    while n * 7 < 64 {
        let exp = (n * 7) as u32;
        uleb128_test_u64(2u64.pow(exp) - 1, n);
        uleb128_test_u64(2u64.pow(exp), n + 1);
        n += 1;
    }
    uleb128_test_u64(u64::MAX - 1, 10);
    uleb128_test_u64(u64::MAX, 10);
}

#[test]
fn uleb128_malformed_test() {
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x80])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x80, 0x80, 0x80])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2
    ]))
    .is_err());
}

#[test]
fn uleb128_canonicity_test() {
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x00])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x00, 0x00])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x80, 0x80, 0x80, 0x0F])).is_ok());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1
    ]))
    .is_ok());
}

proptest! {
    #[test]
    fn uleb128_roundtrip(input in any::<u64>()) {
        let mut serialized = BinaryData::new();
        write_u64_as_uleb128(&mut serialized, input).expect("serialization should work");
        let serialized = serialized.into_inner();
        let mut cursor = Cursor::new(&serialized[..]);
        let output = read_uleb128_as_u64(&mut cursor).expect("deserialization should work");
        prop_assert_eq!(input, output);
    }

```

**File:** third_party/move/move-binary-format/src/unit_tests/deserializer_tests.rs (L12-172)
```rust
fn malformed_simple_versioned_test(version: u32) {
    // bad uleb (more than allowed for table count)
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(150); // table count (high bit 1)
    binary.push(150); // table count (high bit 1)
    binary.push(1);
    let res = CompiledScript::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected bad uleb").major_status(),
        StatusCode::MALFORMED
    );

    // bad uleb (too big)
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(150); // table count (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(150); // table count again (high bit 1)
    binary.push(0); // table count again
    let res = CompiledScript::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected bad uleb").major_status(),
        StatusCode::MALFORMED
    );

    // no tables
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(0); // table count
    let res = CompiledModule::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected no table count").major_status(),
        StatusCode::MALFORMED
    );

    // missing tables
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(10); // table count
    let res = CompiledModule::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected no table header").major_status(),
        StatusCode::MALFORMED
    );

    // missing table content
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(1); // table count
    binary.push(1); // table type
    binary.push(0); // table offset
    binary.push(10); // table length
    let res = CompiledScript::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected no table content").major_status(),
        StatusCode::MALFORMED
    );

    // bad table header (bad offset)
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(1); // table count
    binary.push(1); // table type
    binary.push(100); // bad table offset
    binary.push(10); // table length
    let res = CompiledModule::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected bad table offset").major_status(),
        StatusCode::BAD_HEADER_TABLE
    );

    // bad table header (bad offset)
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(2); // table count
    binary.push(1); // table type
    binary.push(0); // table offset
    binary.push(10); // table length
    binary.push(2); // table type
    binary.push(100); // bad table offset
    binary.push(10); // table length
    binary.resize(binary.len() + 5000, 0);
    let res = CompiledModule::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected bad table offset").major_status(),
        StatusCode::BAD_HEADER_TABLE
    );

    // incomplete table
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(1); // table count
    binary.push(1); // table type
    binary.push(0); // table offset
    binary.push(10); // table length
    binary.resize(binary.len() + 5, 0);
    let res = CompiledScript::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected bad table content").major_status(),
        StatusCode::MALFORMED
    );

    // unknown table
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(1); // table count
    binary.push(100); // table type
    binary.push(0); // table offset
    binary.push(10); // table length
    binary.resize(binary.len() + 10, 0);
    let res = CompiledModule::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected unknown table").major_status(),
        StatusCode::UNKNOWN_TABLE_TYPE
    );

    // duplicate table
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(3); // table count
    binary.push(1); // table type
    binary.push(0); // table offset
    binary.push(10); // table length
    binary.push(2); // table type
    binary.push(10); // table offset
    binary.push(10); // table length
    binary.push(1); // table type
    binary.push(20); // table offset
    binary.push(10); // table length
    binary.resize(binary.len() + 5000, 0);
    let res = CompiledScript::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected table offset overflow")
            .major_status(),
        StatusCode::DUPLICATE_TABLE
    );

    // bad table in script
    let mut binary = BinaryConstants::MOVE_MAGIC.to_vec();
    binary.extend(version.to_le_bytes()); // version
    binary.push(1); // table count
    binary.push(0xD); // table type - FieldHandle not good for script
    binary.push(0); // table offset
    binary.push(10); // table length
    binary.resize(binary.len() + 5000, 0);
    let res = CompiledScript::deserialize(&binary);
    assert_eq!(
        res.expect_err("Expected table offset overflow")
            .major_status(),
        StatusCode::MALFORMED
    );
}
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L345-363)
```rust
        Vector(inner) => {
            // get the vector length and iterate over each element
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                )?;
                len -= 1;
            }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L450-468)
```rust
        let len = get_len(cursor)?;
        if cursor
            .position()
            .checked_add(len as u64)
            .is_none_or(|l| l > initial_cursor_len as u64)
        {
            // We need to make sure we do not allocate more bytes than
            // needed.
            return Err(VMStatus::error(
                StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
                Some("String argument is too long".to_string()),
            ));
        }

        let mut arg = vec![];
        read_n_bytes(len, cursor, &mut arg)?;
        std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
        return bcs::to_bytes(&arg)
            .map_err(|_| VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None));
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L527-535)
```rust
fn get_len(cursor: &mut Cursor<&[u8]>) -> Result<usize, VMStatus> {
    match read_uleb128_as_u64(cursor) {
        Err(_) => Err(VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            None,
        )),
        Ok(len) => Ok(len as usize),
    }
}
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L546-571)
```rust
fn read_n_bytes(n: usize, src: &mut Cursor<&[u8]>, dest: &mut Vec<u8>) -> Result<(), VMStatus> {
    let deserialization_error = |msg: &str| -> VMStatus {
        VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            Some(msg.to_string()),
        )
    };
    let len = dest.len();

    // It is safer to limit the length under some big (but still reasonable
    // number).
    const MAX_NUM_BYTES: usize = 1_000_000;
    if len.checked_add(n).is_none_or(|s| s > MAX_NUM_BYTES) {
        return Err(deserialization_error(&format!(
            "Couldn't read bytes: maximum limit of {} bytes exceeded",
            MAX_NUM_BYTES
        )));
    }

    // Ensure we have enough capacity for resizing.
    dest.try_reserve(len + n)
        .map_err(|e| deserialization_error(&format!("Couldn't read bytes: {}", e)))?;
    dest.resize(len + n, 0);
    src.read_exact(&mut dest[len..])
        .map_err(|_| deserialization_error("Couldn't read bytes"))
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L177-194)
```rust
fn read_uleb_internal<T>(cursor: &mut VersionedCursor, max: u64) -> BinaryLoaderResult<T>
where
    u64: TryInto<T>,
{
    let x = cursor.read_uleb128_as_u64().map_err(|_| {
        PartialVMError::new(StatusCode::MALFORMED).with_message("Bad Uleb".to_string())
    })?;
    if x > max {
        return Err(PartialVMError::new(StatusCode::MALFORMED)
            .with_message("Uleb greater than max requested".to_string()));
    }

    x.try_into().map_err(|_| {
        // TODO: review this status code.
        let msg = "Failed to convert u64 to target integer type. This should not happen. Is the maximum value correct?".to_string();
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(msg)
    })
}
```
