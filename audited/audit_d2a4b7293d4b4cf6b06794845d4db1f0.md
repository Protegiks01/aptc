# Audit Report

## Title
Gas Undercharging in Ristretto255 Multi-Scalar Multiplication Due to Integer Division Rounding

## Summary
The `safe_native_multi_scalar_mul_no_floating_point()` function systematically undercharges gas for specific input sizes (particularly 2^k - 1 values like 3, 7, 15, 31, 63, 127, 255) due to using integer division with `log2_floor(num + 1)` instead of floating-point calculation with ceiling. This allows attackers to perform cryptographic operations at up to 50% discount, violating the resource limits invariant and enabling potential resource exhaustion attacks.

## Finding Description
The gas charging formula in `safe_native_multi_scalar_mul_no_floating_point()` calculates the computational cost as: [1](#0-0) 

This formula differs from the previous floating-point version which used `ceil(num / log2(num))`: [2](#0-1) 

**The vulnerability arises from two key differences:**

1. **Logarithm argument**: New formula uses `log2_floor(num + 1)` vs old formula's `log2(num)`
2. **Rounding behavior**: New formula uses implicit `floor()` via integer division vs old formula's `ceil()`

For values where `num = 2^k - 1` (i.e., 3, 7, 15, 31, 63, 127, 255, etc.), `log2_floor(num + 1) = k`, which is larger than the continuous `log2(num) ≈ k - ε`. Combined with floor vs ceiling rounding, this creates systematic undercharging:

- **num=3**: Old charges 2 units, new charges 1 (50% undercharge, saves 1,731,396 gas)
- **num=7**: Old charges 3 units, new charges 2 (33% undercharge, saves 1,731,396 gas)  
- **num=15**: Old charges 4 units, new charges 3 (25% undercharge, saves 1,731,396 gas)
- **num=31**: Old charges 7 units, new charges 6 (14% undercharge, saves 1,731,396 gas)

The multi-scalar multiplication function is publicly accessible with no size constraints beyond requiring at least 1 element: [3](#0-2) 

An attacker can craft transactions specifically using these pathological sizes to exploit the undercharging. The actual computational complexity follows O(n/log₂ n) as documented in the code comments: [4](#0-3) 

Since the actual algorithm cost is closer to the continuous `n/log₂(n)` rather than the discrete approximation, the new formula systematically undercharges relative to actual computational work performed.

## Impact Explanation
This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Resource Limits Violation**: Breaks invariant #9 - "All operations must respect gas, storage, and computational limits." The gas charged does not accurately reflect computational cost.

2. **Limited Resource Manipulation**: Allows attackers to consume validator CPU resources at below-market rates (up to 50% discount), fitting the Medium category of "Limited funds loss or manipulation."

3. **Validator Performance Impact**: Repeated exploitation could degrade validator performance by forcing validators to perform more computation than the gas fees compensate for, potentially leading to slowdowns.

4. **Determinism Not Affected**: Does not break consensus determinism since all validators apply the same (incorrect) gas formula consistently.

The gas parameter value is substantial: [5](#0-4) 

With RISTRETTO255_POINT_MUL = 1,731,396 internal gas units, a single call with num=3 saves 1,731,396 gas compared to the theoretically correct charge.

## Likelihood Explanation
**High Likelihood** - This vulnerability is easily exploitable:

1. **No Special Privileges Required**: Any user can submit transactions calling `ristretto255::multi_scalar_mul()` from Move smart contracts
2. **Simple Attack Vector**: Attacker simply needs to choose specific input sizes (3, 7, 15, 31, etc.)
3. **Deterministic Exploitation**: The undercharging is deterministic and guaranteed for specific input sizes
4. **No External Dependencies**: Does not require specific network conditions or timing
5. **Repeatable**: Can be exploited continuously across multiple transactions

The only barrier is that the attacker must understand the gas pricing formula, but this is publicly visible in the codebase.

## Recommendation
Replace the integer division approximation with a more accurate formula that properly handles all input sizes. The fix should:

1. Use a lookup table or piecewise linear approximation for small values
2. Ensure rounding behavior matches actual computational cost
3. Maintain the division-by-zero protection for num=1

**Suggested Fix:**
```rust
pub(crate) fn safe_native_multi_scalar_mul_no_floating_point(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    safely_assert_eq!(args.len(), 2);

    let scalars_ref = safely_pop_arg!(args, VectorRef);
    let points_ref = safely_pop_arg!(args, VectorRef);
    let num = scalars_ref.len()?.value_as::<u64>()? as usize;

    // More accurate gas calculation using ceiling approximation
    let log_plus_one = log2_floor(num + 1).unwrap() as u64;
    let gas_multiplier = if num < (1 << log_plus_one) {
        // For values just below power of 2, add 1 to compensate for floor rounding
        (num as u64 + log_plus_one - 1) / log_plus_one
    } else {
        num as u64 / log_plus_one
    };

    context.charge(
        RISTRETTO255_POINT_PARSE_ARG * NumArgs::new(num as u64)
            + RISTRETTO255_SCALAR_PARSE_ARG * NumArgs::new(num as u64)
            + RISTRETTO255_POINT_MUL * NumArgs::new(gas_multiplier),
    )?;
    
    // ... rest of function unchanged
}
```

Alternatively, use a proper ceiling division: `(num + log2_floor(num + 1) - 1) / log2_floor(num + 1)` to approximate the ceiling behavior of the original formula.

## Proof of Concept
```move
#[test_only]
module test_addr::gas_undercharge_poc {
    use aptos_std::ristretto255::{Self, RistrettoPoint, Scalar};
    use std::vector;

    #[test]
    fun test_gas_undercharging() {
        // Create points and scalars for multi_scalar_mul with pathological sizes
        
        // Test with num=3 (50% undercharge)
        let points_3 = vector::empty<RistrettoPoint>();
        let scalars_3 = vector::empty<Scalar>();
        
        let base = ristretto255::basepoint();
        let scalar_one = ristretto255::new_scalar_from_u64(1);
        
        vector::push_back(&mut points_3, base);
        vector::push_back(&mut points_3, base);
        vector::push_back(&mut points_3, base);
        vector::push_back(&mut scalars_3, scalar_one);
        vector::push_back(&mut scalars_3, scalar_one);
        vector::push_back(&mut scalars_3, scalar_one);
        
        // This call will be undercharged by 1,731,396 gas units
        // Expected charge: 2 * RISTRETTO255_POINT_MUL = 3,462,792
        // Actual charge: 1 * RISTRETTO255_POINT_MUL = 1,731,396
        let _result = ristretto255::multi_scalar_mul(&points_3, &scalars_3);
        
        // Similarly for num=7 (33% undercharge), num=15 (25% undercharge), etc.
        // Each call exploits the systematic undercharging for 2^k-1 values
    }
}
```

**Notes:**
The vulnerability stems from replacing floating-point arithmetic with integer arithmetic without properly accounting for rounding behavior. While the change fixed a division-by-zero bug for num=1, it introduced systematic undercharging for a discrete set of input sizes. The pathological values (3, 7, 15, 31, 63, 127, 255, etc.) are precisely those where `num + 1` is a power of 2, causing `log2_floor(num + 1)` to "jump" to the next integer while the actual `log2(num)` remains slightly below that integer.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L610-614)
```rust
    context.charge(
        RISTRETTO255_POINT_PARSE_ARG * NumArgs::new(num as u64)
            + RISTRETTO255_SCALAR_PARSE_ARG * NumArgs::new(num as u64)
            + RISTRETTO255_POINT_MUL * NumArgs::new((num / log2_floor(num + 1).unwrap()) as u64),
    )?;
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L641-645)
```rust
        // NOTE: The variable-time multiscalar multiplication (MSM) algorithm for a size-n MSM employed in curve25519 is:
        //  1. Strauss, when n <= 190, see https://www.jstor.org/stable/2310929
        //  2. Pippinger, when n > 190, which roughly requires O(n / log_2 n) scalar multiplications
        // For simplicity, we estimate the complexity as O(n / log_2 n)
        RistrettoPoint::vartime_multiscalar_mul(scalars.iter(), points)
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255.rs (L30-34)
```rust
pub fn multi_scalar_mul_gas(
    size: usize,
) -> impl GasExpression<NativeGasParameters, Unit = InternalGasUnit> {
    RISTRETTO255_POINT_MUL * NumArgs::new((size as f64 / f64::log2(size as f64)).ceil() as u64)
}
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move (L321-330)
```text
    public fun multi_scalar_mul(points: &vector<RistrettoPoint>, scalars: &vector<Scalar>): RistrettoPoint {
        assert!(!points.is_empty(), std::error::invalid_argument(E_ZERO_POINTS));
        assert!(!scalars.is_empty(), std::error::invalid_argument(E_ZERO_SCALARS));
        assert!(
            points.length() == scalars.length(), std::error::invalid_argument(E_DIFFERENT_NUM_POINTS_AND_SCALARS));

        RistrettoPoint {
            handle: multi_scalar_mul_internal<RistrettoPoint, Scalar>(points, scalars)
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L211-211)
```rust
        [ristretto255_point_mul: InternalGasPerArg, "ristretto255.point_mul", 1731396],
```
