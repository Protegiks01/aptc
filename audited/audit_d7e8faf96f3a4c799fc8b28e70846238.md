# Audit Report

## Title
Missing Epoch Validation in JWK Consensus Event Processing Allows State Rollback

## Summary
The JWK consensus system fails to validate the epoch field in `ObservedJWKsUpdated` events before processing them. This allows events from previous epochs to reset the current epoch's JWK state, potentially causing validators to use outdated or compromised keys and creating state inconsistencies across the validator set.

## Finding Description

The `ObservedJWKsUpdated` event structure contains an `epoch` field that is emitted with the current epoch value but is completely ignored during event processing. [1](#0-0) 

When these events are received by the `EpochManager`, they are forwarded to the JWK consensus manager without any epoch validation: [2](#0-1) 

Both the issuer-level and per-key JWK consensus managers then process these events by calling `reset_with_on_chain_state`, completely ignoring the epoch field: [3](#0-2) [4](#0-3) 

This violates the fundamental invariant that epoch values should only increase monotonically. The attack scenario occurs during:

1. **State Sync Catch-up**: When a validator is catching up from behind, it processes blocks from previous epochs. Events from these old blocks can be delivered to the current epoch's JWK consensus manager, causing it to reset its state to old JWK values.

2. **Epoch Transition Race Conditions**: During the window when a new epoch begins but old events are still in the processing queue, stale events may be processed by the new epoch manager.

3. **Event Queue Delays**: The KLAST queue style used for event notifications may buffer events that get processed after an epoch transition.

The security guarantees broken include:
- **State Consistency Invariant**: Validators may have inconsistent JWK states if some process old events and others don't
- **Epoch Monotonicity**: The epoch field exists but is not enforced, allowing backwards state transitions
- **Authentication Security**: Keyless accounts rely on current JWK keys; using old keys could enable authentication bypasses or failures

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty criteria because it causes:

1. **Validator Node State Inconsistencies**: Different validators may have different JWK states if they process events at different times during state sync or epoch transitions
2. **Authentication Security Compromises**: Keyless accounts depend on up-to-date JWK keys for authentication. Rolling back to old keys could:
   - Allow authentication with revoked keys
   - Cause authentication failures with valid current keys
   - Create security vulnerabilities if old keys were compromised
3. **Protocol Violation**: This breaks the fundamental assumption that epoch state only moves forward

While this doesn't directly cause funds loss or consensus safety violations, it represents a significant protocol violation affecting validator synchronization and authentication security.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability will trigger in the following scenarios:

1. **Every time a validator performs state sync catch-up** - This is a routine operation when validators restart, fall behind, or join the network
2. **During epoch transitions** - The race condition window exists at every epoch boundary
3. **Network delays in event processing** - Any delay in event notification delivery during epoch transitions

The vulnerability is not dependent on attacker action but rather occurs naturally during normal validator operations. The frequency of state sync operations and epoch transitions (which occur regularly) makes this a realistic and recurring issue.

## Recommendation

Add epoch validation in the `EpochManager::process_onchain_event` method to reject events from incorrect epochs:

```rust
fn process_onchain_event(&mut self, notification: EventNotification) -> Result<()> {
    let EventNotification {
        subscribed_events, ..
    } = notification;
    for event in subscribed_events {
        if let Ok(jwk_event) = ObservedJWKsUpdated::try_from(&event) {
            // Validate epoch matches current epoch
            if let Some(epoch_state) = &self.epoch_state {
                if jwk_event.epoch != epoch_state.epoch {
                    warn!(
                        "Ignoring JWK event from epoch {} (current epoch: {})",
                        jwk_event.epoch, epoch_state.epoch
                    );
                    continue;
                }
            }
            
            if let Some(tx) = self.jwk_updated_event_txs.as_ref() {
                let _ = tx.push((), jwk_event);
            }
        }
    }
    Ok(())
}
```

The same validation pattern should be applied to the DKG event processing in `dkg/src/epoch_manager.rs` which has the identical issue with `DKGStartEvent` epoch validation.

## Proof of Concept

**Scenario Reproduction Steps:**

1. **Setup**: Start a validator network with JWK consensus enabled at epoch N
2. **Trigger**: Emit an `ObservedJWKsUpdated` event with JWK state S_N for epoch N
3. **Epoch Transition**: Network transitions to epoch N+1
4. **Update**: Emit a new `ObservedJWKsUpdated` event with updated JWK state S_{N+1} for epoch N+1
5. **Exploit**: Restart a validator node forcing it to state sync from before epoch N+1
6. **Observation**: During catch-up, the validator processes the old event from epoch N
7. **Result**: The validator's JWK consensus manager resets to state S_N even though the current epoch is N+1

**Expected Behavior**: The validator should ignore the epoch N event and maintain state S_{N+1}

**Actual Behavior**: The validator processes the epoch N event and resets to state S_N, creating inconsistency

**Verification**: Check validator logs during state sync to observe that `reset_with_on_chain_state` is called with old JWK state, and compare JWK state across validators to identify inconsistencies.

## Notes

This vulnerability represents a defensive programming failure rather than a directly exploitable attack vector. The `epoch` field was added to the event structure but validation logic was never implemented. The same pattern appears in both the JWK consensus system and the DKG system, suggesting a systemic issue with event epoch validation across validator transaction subsystems.

The impact is amplified because JWK updates are critical for keyless account authentication security, and state inconsistencies in this subsystem could have cascading effects on authentication reliability and security across the network.

### Citations

**File:** types/src/jwks/mod.rs (L479-484)
```rust
/// See its doc in Move for more details.
#[derive(Serialize, Deserialize)]
pub struct ObservedJWKsUpdated {
    pub epoch: u64,
    pub jwks: AllProvidersJWKs,
}
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L108-120)
```rust
    fn process_onchain_event(&mut self, notification: EventNotification) -> Result<()> {
        let EventNotification {
            subscribed_events, ..
        } = notification;
        for event in subscribed_events {
            if let Ok(jwk_event) = ObservedJWKsUpdated::try_from(&event) {
                if let Some(tx) = self.jwk_updated_event_txs.as_ref() {
                    let _ = tx.push((), jwk_event);
                }
            }
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L140-143)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
                },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L417-420)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
                },
```
