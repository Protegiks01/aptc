# Audit Report

## Title
Attribution Error in OptProposalMsg Logging Before Verification

## Summary
The `EpochManager::process_message` function logs the message's claimed author without logging the actual network sender when rejecting OptProposalMsg messages with disabled features. This creates attribution errors in security audits where forensic investigators cannot determine which peer actually sent invalid messages, potentially attributing malicious behavior to the wrong validator.

## Finding Description

The LogSchema structure defines two fields of type `Author` that serve different purposes:
- `author: Option<Author>` - represents the local node's identity
- `remote_peer: Option<Author>` - represents the remote message sender [1](#0-0) 

In the `EpochManager::process_message` function, when an OptProposalMsg is received but the feature is disabled, the code logs an error using the message's claimed author field without logging the actual network peer_id that sent the message: [2](#0-1) 

**Attack Scenario:**
1. Malicious peer M intercepts or forwards an OptProposalMsg originally from legitimate validator V
2. M sends this message to validator N when optimistic proposals are disabled
3. The error at line 1545-1550 triggers, logging "Author: V" from the message content
4. The actual sender (peer_id = M) is never logged in this error path
5. Security auditors reviewing logs incorrectly attribute the malicious behavior to V instead of M

This attribution error occurs **before** message verification. While the verification logic later ensures that message authors match network senders for valid messages, this check never executes for this error path: [3](#0-2) 

The verification failure logging at lines 1613-1618 correctly logs `remote_peer = peer_id`, but the OptProposalMsg error path at 1545-1550 bypasses this via early `bail!()`.

## Impact Explanation

This issue creates forensic attribution errors that impair security incident response:

1. **Post-Incident Investigation**: Security teams investigating Byzantine attacks cannot accurately identify which peers sent malicious messages
2. **Automated Response Systems**: Any automated systems that ban or penalize peers based on error logs would target the wrong validators
3. **Validator Reputation**: Legitimate validators could be incorrectly blamed for attacks they didn't initiate

However, this does **not** directly cause:
- Consensus safety violations
- Funds loss or manipulation  
- State inconsistencies in blockchain state
- Liveness failures during normal operation

The impact is limited to forensic analysis and audit trail accuracy. While rated as "Medium" in the security question, this does not meet the Aptos bug bounty Medium severity criteria which require "Limited funds loss or manipulation" or "State inconsistencies requiring intervention."

## Likelihood Explanation

The likelihood depends on two factors:
1. **OptProposalMsg with feature disabled**: Requires either a configuration mismatch between validators or malicious forwarding
2. **Malicious exploitation**: An attacker could deliberately trigger this to create attribution confusion

The condition is easy to trigger if validators have different `enable_optimistic_proposal_rx` configurations or if malicious peers forward messages. However, the security impact is limited to forensic analysis rather than runtime consensus behavior.

## Recommendation

Add the `peer_id` to the error message to correctly attribute message origin:

```rust
if let ConsensusMsg::OptProposalMsg(proposal) = &consensus_msg {
    if !self.config.enable_optimistic_proposal_rx {
        bail!(
            "Unexpected OptProposalMsg. Feature is disabled. Sender: {}, Author: {}, Epoch: {}, Round: {}",
            peer_id,  // Add the actual network sender
            proposal.block_data().author(),
            proposal.epoch(),
            proposal.round()
        )
    }
    // ... rest of the code
}
```

Additionally, consider standardizing all security-relevant logging to include both `peer_id` (actual network sender) and message author fields for clear attribution.

## Proof of Concept

```rust
// This demonstrates the attribution error in logs
// File: consensus/src/epoch_manager.rs (conceptual test)

#[tokio::test]
async fn test_attribution_error_opt_proposal() {
    let mut epoch_manager = create_test_epoch_manager_with_disabled_opt_proposal();
    
    // Malicious peer M with address 0xM
    let malicious_peer = AccountAddress::from_hex_literal("0xMALICIOUS").unwrap();
    
    // Create OptProposalMsg claiming to be from legitimate validator V
    let legitimate_author = AccountAddress::from_hex_literal("0xVALIDATOR").unwrap();
    let opt_proposal = create_opt_proposal_from(legitimate_author);
    
    // When M sends this message, the error should log BOTH peer_id (M) and author (V)
    // Currently it only logs author (V), creating attribution error
    let result = epoch_manager.process_message(
        malicious_peer,  // Actual sender: M
        ConsensusMsg::OptProposalMsg(Box::new(opt_proposal))
    ).await;
    
    // Error occurs but logs only show "Author: 0xVALIDATOR" 
    // not "Sender: 0xMALICIOUS"
    assert!(result.is_err());
    
    // In real attack: auditors would blame 0xVALIDATOR when 0xMALICIOUS sent it
}
```

## Notes

While this issue represents a genuine logging inconsistency that impairs forensic analysis, it does not meet the strict criteria for Medium severity per the Aptos bug bounty program, which requires direct security impact such as funds loss or state inconsistencies. This would more appropriately be classified as Low severity ("Non-critical implementation bugs") or a code quality issue affecting observability rather than core security.

The finding validates the security question's premise about attribution confusion between `Author` fields, but the practical security impact is limited to audit trail accuracy rather than consensus or financial security.

### Citations

**File:** consensus/src/logging.rs (L11-18)
```rust
pub struct LogSchema {
    event: LogEvent,
    author: Option<Author>,
    remote_peer: Option<Author>,
    epoch: Option<u64>,
    round: Option<Round>,
    id: Option<HashValue>,
}
```

**File:** consensus/src/epoch_manager.rs (L1543-1560)
```rust
        if let ConsensusMsg::OptProposalMsg(proposal) = &consensus_msg {
            if !self.config.enable_optimistic_proposal_rx {
                bail!(
                    "Unexpected OptProposalMsg. Feature is disabled. Author: {}, Epoch: {}, Round: {}",
                    proposal.block_data().author(),
                    proposal.epoch(),
                    proposal.round()
                )
            }
            observe_block(
                proposal.timestamp_usecs(),
                BlockStage::EPOCH_MANAGER_RECEIVED,
            );
            observe_block(
                proposal.timestamp_usecs(),
                BlockStage::EPOCH_MANAGER_RECEIVED_OPT_PROPOSAL,
            );
        }
```

**File:** consensus/src/epoch_manager.rs (L1587-1622)
```rust
            self.bounded_executor
                .spawn(async move {
                    match monitor!(
                        "verify_message",
                        unverified_event.clone().verify(
                            peer_id,
                            &epoch_state.verifier,
                            &proof_cache,
                            quorum_store_enabled,
                            peer_id == my_peer_id,
                            max_num_batches,
                            max_batch_expiry_gap_usecs,
                        )
                    ) {
                        Ok(verified_event) => {
                            Self::forward_event(
                                quorum_store_msg_tx,
                                round_manager_tx,
                                buffered_proposal_tx,
                                peer_id,
                                verified_event,
                                payload_manager,
                                pending_blocks,
                            );
                        },
                        Err(e) => {
                            error!(
                                SecurityEvent::ConsensusInvalidMessage,
                                remote_peer = peer_id,
                                error = ?e,
                                unverified_event = unverified_event
                            );
                        },
                    }
                })
                .await;
```
