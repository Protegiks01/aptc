# Audit Report

## Title
Admin Service Default Binding Exposes Sensitive Debug Endpoints to Network Interfaces

## Summary
The `AdminServiceConfig::default()` function binds to `0.0.0.0` (all network interfaces) instead of `127.0.0.1` (localhost only), creating unnecessary network exposure of sensitive debugging endpoints even when authentication is configured. On testnet/devnet deployments, this combines with disabled authentication to allow unauthenticated remote access to consensus state dumps, block data, profiling endpoints, and memory statistics. [1](#0-0) 

## Finding Description

The admin service provides sensitive debugging endpoints including consensus database dumps, block data extraction, CPU profiling, and memory statistics. The default configuration violates the principle of "secure by default" by binding to all network interfaces rather than localhost only.

**Affected Endpoints:**
The admin service exposes critical debugging functionality: [2](#0-1) 

These endpoints provide:
- Consensus state (votes, blocks, quorum certificates) [3](#0-2) 
- Complete block data with transaction extraction [4](#0-3) 
- Mempool parking lot addresses
- CPU profiling and thread dumps
- Memory statistics and heap dumps

**Configuration Weakness:**
On non-mainnet chains, authentication is not enforced: [5](#0-4) 

The service is enabled by default on testnet/devnet: [6](#0-5) 

**Security-Conscious Code Uses Localhost:**
The codebase itself demonstrates awareness that localhost binding is more secure, as seen in security-sensitive contexts: [7](#0-6) [8](#0-7) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: The profiling and database dump endpoints can cause significant resource consumption when invoked repeatedly, leading to validator performance degradation during consensus participation.

2. **Information Leakage**: Exposes:
   - Real-time consensus state enabling timing attacks
   - Pre-committed block data and transactions
   - Node performance characteristics
   - Memory layout information useful for exploitation

3. **Protocol Intelligence Gathering**: Attackers can analyze consensus timing, voting patterns, and block production to identify weaknesses or optimize other attacks.

**Attack Surface on Testnet/Devnet:**
- Service enabled by default (line 100 in ConfigOptimizer)
- No authentication required (line 70 sanitizer only checks mainnet)
- Binding to 0.0.0.0 exposes to internet if firewall misconfigured

## Likelihood Explanation

**High Likelihood:**
- Many operators deploy testnet/devnet nodes for testing without comprehensive firewall configuration
- Default configuration is insecure without explicit action
- Cloud deployments often have permissive default security groups during development
- Operators may not realize port 9102 requires protection
- Kubernetes deployments may expose services unintentionally

**Attacker Requirements:**
- Network scan to identify nodes with port 9102 accessible
- Simple HTTP GET requests, no authentication needed on testnet/devnet
- No special privileges or insider access required

## Recommendation

**Change the default binding to localhost:**

```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(),  // Changed from "0.0.0.0"
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

**Additional Hardening:**
1. Require explicit opt-in for non-localhost binding via configuration
2. Add warning log message when binding to 0.0.0.0
3. Enforce authentication on all networks (not just mainnet)
4. Document security implications clearly

**Deployment Guidance:**
- If remote access needed, use SSH tunneling or VPN
- Configure firewalls to block port 9102 from external access
- Use HAProxy with IP allowlisting for authorized access only

## Proof of Concept

**Step 1: Deploy testnet node with default configuration**
```bash
# Node starts with default admin_service config
# address: "0.0.0.0", port: 9102, enabled: true (on testnet)
```

**Step 2: From remote machine, access sensitive endpoints**
```bash
# Dump consensus database (no authentication required on testnet)
curl http://<node-ip>:9102/debug/consensus/consensusdb

# Output includes:
# - Last vote information
# - Highest timeout certificate  
# - All consensus blocks with IDs, authors, epochs, rounds
# - Quorum certificates

# Dump specific block with transactions
curl http://<node-ip>:9102/debug/consensus/block?block_id=<hash>

# Trigger CPU profiling (causes load)
curl http://<node-ip>:9102/profilez?seconds=60

# Get memory statistics
curl http://<node-ip>:9102/malloc/stats
```

**Expected Result:**
All requests succeed, returning sensitive node internals without authentication, demonstrating that default 0.0.0.0 binding creates exploitable exposure when combined with missing testnet authentication requirements.

**Risk Validation:**
The vulnerability is exploitable on any testnet/devnet node deployed with:
- Default configuration (no address override)
- Firewall rules permitting external access to port 9102
- No HAProxy or additional network protection layer

## Notes

While HAProxy configurations exist for production deployments that provide IP-based blocking, the application-level default of 0.0.0.0 violates defense-in-depth principles. Secure defaults prevent security failures in misconfigured or development environments where additional security layers may be absent. The codebase's own security-conscious contexts (workspace server, local testnet) demonstrate the correct pattern of binding to 127.0.0.1 explicitly, indicating developer awareness that localhost-only binding is the security best practice.

### Citations

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L59-82)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/admin_service_config.rs (L84-107)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L183-243)
```rust
        match (req.method().clone(), req.uri().path()) {
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
            _ => Ok(reply_with_status(StatusCode::NOT_FOUND, "Not found.")),
        }
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-215)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }

    if body.is_empty() {
        if let Some(block_id) = block_id {
            body.push_str(&format!("Done, block ({block_id:?}) is not found."));
        } else {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
}
```

**File:** aptos-move/aptos-workspace-server/src/services/node.rs (L83-84)
```rust
    node_config.admin_service.address = IP_LOCAL_HOST.to_string();
    node_config.inspection_service.address = IP_LOCAL_HOST.to_string();
```

**File:** aptos-move/aptos-workspace-server/src/common.rs (L61-62)
```rust
/// The local IP address services are bound to.
pub(crate) const IP_LOCAL_HOST: IpAddr = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));
```
