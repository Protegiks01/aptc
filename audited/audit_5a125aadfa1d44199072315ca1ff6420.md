# Audit Report

## Title
Optimistic Fetch Race Condition Causing Lost Responses and Potential State Sync Disruption

## Summary
A race condition exists in the optimistic fetch handler where concurrent requests from the same peer with different `known_version` values cause the newer request to atomically replace the older one in the server's map, resulting in lost responses and potential state sync disruption.

## Finding Description

The storage service maintains a `DashMap<PeerNetworkId, OptimisticFetchRequest>` that stores at most one active optimistic fetch per peer. [1](#0-0) 

When a peer sends a new optimistic fetch request, the handler uses `insert()` which atomically replaces any existing entry: [2](#0-1) 

The code logs a trace warning when replacement occurs but allows it to proceed: [3](#0-2) 

**The Race Condition:**

1. Peer sends Request A with `known_version=1000`
2. Server stores Request A in the map
3. Background task identifies Request A is ready (target ledger version = 4000)
4. **Before processing**, peer sends Request B with `known_version=100`
5. Request B atomically replaces Request A (dropping A's `response_sender`)
6. Background task calls `remove_if` which checks the **current** entry in the map: [4](#0-3) 
7. Since `100 < 4000`, the predicate succeeds and Request B is removed and processed
8. Server calculates `start_version = 101`, `end_version = min(4000, 101 + 3000 - 1) = 3100`
9. Server sends response `[101, 3100]` to Request B's `response_sender`
10. The client that sent Request A never receives a response (its `response_sender` was dropped)

**Overlapping Data Scenario:**

If the peer later sends Request C with `known_version=1000`, it will receive `[1001, X]`. The ranges `[1001, 3100]` would overlap with the previous response, violating the expectation of non-overlapping sequential data.

**Client-Side Mitigation:**

The client has validation that checks payload start version matches expected version: [5](#0-4) 

If validation fails, the stream resets with `InvalidPayloadData` feedback. However, this doesn't prevent the lost response issue for Request A, which causes timeouts and retries.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

- **State Sync Disruption**: Legitimate optimistic fetch requests can be starved, causing state sync delays for affected peers
- **Resource Exhaustion**: Repeated lost responses trigger timeouts and retries, wasting network bandwidth and server resources
- **Availability Impact**: A malicious peer can intentionally send rapid requests with varying `known_version` values to prevent any request from completing
- **Data Confusion Risk**: While client validation provides protection, the server returning potentially overlapping data violates the state sync protocol's sequential data guarantee

This does not reach Critical/High severity because:
- No consensus impact
- No fund loss or theft
- Limited to individual peer's state sync (not network-wide)
- Client validation mitigates data corruption

## Likelihood Explanation

**Medium to High Likelihood:**

- **Normal Operation**: Legitimate clients with proper version tracking shouldn't trigger this, but network delays or retries could cause race conditions
- **Malicious Exploitation**: An attacker controlling a peer can trivially trigger this by sending concurrent requests with different `known_version` values
- **No Special Access Required**: Any network peer can send optimistic fetch requests
- **Complexity**: Low - the attack is straightforward to execute

The code shows developers are aware (trace logging), but the issue persists: [6](#0-5) 

## Recommendation

**Option 1: Reject Concurrent Requests**

Reject new optimistic fetch requests when one is already active for the peer, and return an error response instead of silently replacing:

```rust
// In handle_optimistic_fetch_request
if let Some(_existing) = self.optimistic_fetches.get(&peer_network_id) {
    // Reject the new request with an error
    let error_response = Err(StorageServiceError::InvalidRequest(
        "An optimistic fetch request is already active for this peer".into()
    ));
    response_sender.send(error_response);
    return;
}

// Only insert if no existing request
self.optimistic_fetches.insert(peer_network_id, optimistic_fetch);
```

**Option 2: Queue Requests**

Maintain a queue of requests per peer instead of a single slot, processing them sequentially.

**Option 3: Version Monotonicity Check**

Track the last `known_version` per peer and reject requests with non-monotonic versions:

```rust
// Verify new known_version >= last known_version for this peer
if new_known_version < last_known_version {
    return Err("Non-monotonic known_version detected");
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_concurrent_optimistic_fetch_race_condition() {
    use aptos_storage_service_types::requests::*;
    
    // Setup test environment
    let time_service = TimeService::mock();
    let peer_network_id = PeerNetworkId::random();
    
    // Create Request A with known_version=1000
    let request_a = StorageServiceRequest::new(
        DataRequest::GetNewTransactionsOrOutputsWithProof(
            NewTransactionsOrOutputsWithProofRequest {
                known_version: 1000,
                known_epoch: 1,
                include_events: false,
                max_num_output_reductions: 3,
            }
        ),
        false,
    );
    
    // Create channel for Request A's response
    let (sender_a, receiver_a) = oneshot::channel();
    let response_sender_a = ResponseSender::new(sender_a);
    
    // Insert Request A
    handler.handle_optimistic_fetch_request(
        peer_network_id,
        request_a,
        response_sender_a,
    );
    
    // Verify Request A is in the map
    assert!(optimistic_fetches.contains_key(&peer_network_id));
    
    // Before processing, send Request B with known_version=100
    let request_b = StorageServiceRequest::new(
        DataRequest::GetNewTransactionsOrOutputsWithProof(
            NewTransactionsOrOutputsWithProofRequest {
                known_version: 100,
                known_epoch: 1,
                include_events: false,
                max_num_output_reductions: 3,
            }
        ),
        false,
    );
    
    let (sender_b, receiver_b) = oneshot::channel();
    let response_sender_b = ResponseSender::new(sender_b);
    
    // Insert Request B (this replaces Request A)
    handler.handle_optimistic_fetch_request(
        peer_network_id,
        request_b,
        response_sender_b,
    );
    
    // Update storage to trigger ready condition
    let synced_ledger_info = create_ledger_info(4000, 1);
    update_storage_summary(cached_storage_server_summary, synced_ledger_info);
    
    // Process optimistic fetches
    handle_active_optimistic_fetches(...).await.unwrap();
    
    // Request A's receiver will timeout/never receive response
    assert!(receiver_a.await.is_err()); // Channel closed without response
    
    // Request B receives response [101, 3100]
    let response_b = receiver_b.await.unwrap();
    assert!(response_b.is_ok());
    // Verify response covers [101, 3100]
    
    // If peer sends Request C with known_version=1000 later,
    // it would receive [1001, X], creating overlap with [101, 3100]
}
```

## Notes

While the client has validation mechanisms to detect and reject mismatched payload versions, the server-side race condition represents a protocol violation. The optimistic fetch mechanism is designed to provide sequential, non-overlapping data ranges, but this race condition allows overlapping ranges to be returned across multiple requests. Even though client validation prevents data corruption, the lost response issue causes unnecessary retries and resource consumption, and a malicious peer can exploit this for targeted denial-of-service against their own state sync process.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L51-51)
```rust
    optimistic_fetches: Arc<DashMap<PeerNetworkId, OptimisticFetchRequest>>,
```

**File:** state-sync/storage-service/server/src/handler.rs (L257-260)
```rust
        if self
            .optimistic_fetches
            .insert(peer_network_id, optimistic_fetch)
            .is_some()
```

**File:** state-sync/storage-service/server/src/handler.rs (L262-272)
```rust
            sample!(
                SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
                trace!(LogSchema::new(LogEntry::OptimisticFetchRequest)
                    .error(&Error::InvalidRequest(
                        "An active optimistic fetch was already found for the peer!".into()
                    ))
                    .peer_network_id(&peer_network_id)
                    .request(&request)
                );
            );
        }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L274-278)
```rust
        let ready_optimistic_fetch =
            optimistic_fetches.remove_if(&peer_network_id, |_, optimistic_fetch| {
                optimistic_fetch.highest_known_version()
                    < target_ledger_info.ledger_info().version()
            });
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L388-420)
```rust
    async fn verify_payload_start_version(
        &mut self,
        notification_id: NotificationId,
        payload_start_version: Option<Version>,
    ) -> Result<Version, Error> {
        // Compare the payload start version with the expected version
        let expected_version = self
            .get_speculative_stream_state()?
            .expected_next_version()?;
        if let Some(payload_start_version) = payload_start_version {
            if payload_start_version != expected_version {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::InvalidPayloadData,
                )))
                .await?;
                Err(Error::VerificationError(format!(
                    "The payload start version does not match the expected version! Start: {:?}, expected: {:?}",
                    payload_start_version, expected_version
                )))
            } else {
                Ok(payload_start_version)
            }
        } else {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            Err(Error::VerificationError(
                "The playload starting version is missing!".into(),
            ))
        }
```
