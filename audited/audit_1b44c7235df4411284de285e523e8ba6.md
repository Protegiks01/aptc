# Audit Report

## Title
Transaction Filter Bypass via Unchecked Addresses in EntryFunction Type Arguments and BCS-Encoded Arguments

## Summary
The `AccountAddress` matcher in transaction filters fails to check addresses embedded in EntryFunction type arguments (`ty_args`) and BCS-encoded function arguments (`args`). This allows attackers to bypass transaction filtering mechanisms by hiding banned addresses in these unchecked locations, circumventing mempool rejection, consensus proposal filtering, and execution-level transaction filters.

## Finding Description

The `TransactionMatcher::AccountAddress` implementation checks five address locations in a transaction: [1](#0-0) 

However, it fails to check two critical locations where addresses can appear:

1. **EntryFunction Type Arguments**: The `ty_args: Vec<TypeTag>` field in EntryFunction can contain addresses through `TypeTag::Struct(StructTag)`, where `StructTag` has an `address` field: [2](#0-1) 

2. **EntryFunction BCS-Encoded Arguments**: The `args: Vec<Vec<u8>>` field contains BCS-encoded arguments that could include addresses, but these are never decoded or inspected.

The `matches_script_argument_address` function explicitly returns `false` for EntryFunction payloads: [3](#0-2) 

**Attack Scenario:**
1. A node operator configures a filter to deny transactions involving address `0xBANNED` (e.g., sanctioned address)
2. Attacker creates an EntryFunction transaction calling: `0x1::coin::transfer<0xBANNED::token::Token>(recipient, amount)`
3. The filter only checks the module address (`0x1`), missing the type argument address (`0xBANNED`)
4. Transaction passes through mempool, consensus, and execution filters
5. The banned address successfully interacts with the network

Transaction filters are used at three critical points: [4](#0-3) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program as it represents a "Significant protocol violation." Specifically:

- **Security Control Bypass**: Transaction filters are a critical security mechanism allowing operators to:
  - Block sanctioned addresses from interacting with the network
  - Prevent known attackers from submitting transactions
  - Enforce access control policies at the protocol level

- **Multi-Layer Impact**: The bypass affects all three filtering layers (mempool, consensus, execution), making it a systemic weakness

- **Access Control Violation**: Breaks the documented invariant that "System addresses (@aptos_framework, @core_resources) must be protected" by allowing filtered addresses to bypass controls

While not a consensus safety violation or fund loss, this significantly undermines a core security feature used for compliance and attack mitigation.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Simple Exploitation**: Requires only basic knowledge of Move generics - any developer can craft transactions with type arguments
2. **No Special Privileges**: Any transaction sender can exploit this without validator access
3. **Real-World Usage**: Type arguments are commonly used in Move (e.g., `Coin<CoinType>`, resource types)
4. **No Detection**: The filtering system provides no warning that type arguments aren't checked
5. **Deployment Reality**: Networks using transaction filters for sanctions/compliance are immediately vulnerable

## Recommendation

Add comprehensive address checking for EntryFunction type arguments and BCS-encoded arguments. The fix requires:

1. **Recursive TypeTag Inspection**: Create a helper function to recursively extract all addresses from `Vec<TypeTag>`:

```rust
/// Recursively extracts all addresses from type arguments
fn extract_addresses_from_type_tags(type_tags: &[TypeTag]) -> Vec<AccountAddress> {
    let mut addresses = Vec::new();
    for type_tag in type_tags {
        match type_tag {
            TypeTag::Struct(struct_tag) => {
                addresses.push(struct_tag.address);
                addresses.extend(extract_addresses_from_type_tags(&struct_tag.type_args));
            },
            TypeTag::Vector(inner) => {
                addresses.extend(extract_addresses_from_type_tags(&[inner.as_ref().clone()]));
            },
            _ => {}, // Primitive types don't contain addresses
        }
    }
    addresses
}
```

2. **EntryFunction Type Argument Checking**: Add a new helper function:

```rust
fn matches_entry_function_type_args(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
) -> bool {
    match signed_transaction.payload() {
        TransactionPayload::EntryFunction(entry_function) => {
            extract_addresses_from_type_tags(entry_function.ty_args())
                .contains(address)
        },
        // Handle other payload variants with EntryFunction
        _ => false,
    }
}
```

3. **Update AccountAddress Matcher**: Modify the matcher to include type argument checking: [1](#0-0) 

Add the new check:
```rust
TransactionMatcher::AccountAddress(address) => {
    matches_sender_address(signed_transaction, address)
        || matches_entry_function_module_address(signed_transaction, address)
        || matches_multisig_address(signed_transaction, address)
        || matches_script_argument_address(signed_transaction, address)
        || matches_transaction_authenticator_address(signed_transaction, address)
        || matches_entry_function_type_args(signed_transaction, address)  // NEW
}
```

4. **BCS Argument Decoding** (optional but recommended): Consider adding logic to decode and inspect BCS-encoded arguments for address values, though this is more complex due to type information requirements.

## Proof of Concept

```rust
#[cfg(test)]
mod test_type_arg_bypass {
    use super::*;
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, SigningKey, Uniform};
    use aptos_types::{
        chain_id::ChainId,
        transaction::{EntryFunction, RawTransaction, SignedTransaction, TransactionPayload},
    };
    use move_core_types::{
        account_address::AccountAddress,
        identifier::Identifier,
        language_storage::{ModuleId, StructTag, TypeTag},
    };

    #[test]
    fn test_account_address_filter_bypass_via_type_args() {
        // Create a banned address that should be filtered
        let banned_address = AccountAddress::from_hex_literal("0xBAD").unwrap();
        
        // Create a filter that denies the banned address
        let filter = TransactionFilter::empty()
            .add_account_address_filter(false, banned_address)
            .add_all_filter(true);
        
        // Create an EntryFunction with the banned address in type arguments
        // Example: 0x1::coin::transfer<0xBAD::token::Token>(...)
        let module = ModuleId::new(
            AccountAddress::from_hex_literal("0x1").unwrap(),
            Identifier::new("coin").unwrap(),
        );
        let function = Identifier::new("transfer").unwrap();
        
        // Type argument: 0xBAD::token::Token
        let malicious_type_arg = TypeTag::Struct(Box::new(StructTag {
            address: banned_address,  // Banned address hidden here!
            module: Identifier::new("token").unwrap(),
            name: Identifier::new("Token").unwrap(),
            type_args: vec![],
        }));
        
        let entry_function = EntryFunction::new(
            module,
            function,
            vec![malicious_type_arg],  // Contains banned address
            vec![],
        );
        
        // Create and sign the transaction
        let sender = AccountAddress::random();
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let raw_txn = RawTransaction::new(
            sender,
            0,
            TransactionPayload::EntryFunction(entry_function),
            100_000,
            1,
            u64::MAX,
            ChainId::new(1),
        );
        let signature = private_key.sign(&raw_txn).unwrap();
        let signed_txn = SignedTransaction::new(
            raw_txn,
            private_key.public_key(),
            signature,
        );
        
        // VULNERABILITY: Transaction with banned address in type args passes filter!
        assert!(
            filter.allows_transaction(&signed_txn),
            "Transaction with banned address in type args should be blocked but passes!"
        );
        
        // Expected: Should be denied because banned_address appears in type arguments
        // Actual: Transaction is allowed, bypassing the filter
    }
}
```

This PoC demonstrates that a transaction containing a banned address in its type arguments will bypass the `AccountAddress` filter, allowing the filtered address to interact with the network despite the filtering configuration.

## Notes

Additional context:

1. **TypeTag Structure**: TypeTag can be deeply nested through `Struct.type_args` and `Vector`, requiring recursive inspection to catch all addresses.

2. **No Test Coverage**: The existing test suite only validates sender, module address, multisig, script arguments, and authenticator addresses - no tests exist for type arguments: [5](#0-4) 

The test utility creates EntryFunction with empty type arguments, confirming this attack surface was not considered.

3. **Real-World Impact**: Move's type system heavily uses generics (e.g., `Coin<AptosCoin>`, `0x1::object::Object<0xADDRESS::nft::NFT>`), making this a practical bypass vector for any filtering use case.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L456-459)
```rust
    match signed_transaction.payload() {
        TransactionPayload::EntryFunction(_)
        | TransactionPayload::Multisig(_)
        | TransactionPayload::ModuleBundle(_) => false,
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L216-223)
```rust
pub struct StructTag {
    pub address: AccountAddress,
    pub module: Identifier,
    pub name: Identifier,
    // alias for compatibility with old json serialized data.
    #[serde(rename = "type_args", alias = "type_params")]
    pub type_args: Vec<TypeTag>,
}
```

**File:** config/src/config/transaction_filters_config.rs (L12-18)
```rust
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** crates/aptos-transaction-filters/src/tests/utils.rs (L102-108)
```rust
pub fn create_entry_function(function: MemberId) -> EntryFunction {
    let MemberId {
        module_id,
        member_id: function_id,
    } = function;
    EntryFunction::new(module_id, function_id, vec![], vec![])
}
```
