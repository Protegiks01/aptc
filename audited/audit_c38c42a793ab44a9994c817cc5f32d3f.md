# Audit Report

## Title
Indexer Transaction Version i64 Overflow Causes Chronological Ordering Failure in Current Tables

## Summary
The Aptos indexer casts transaction versions from `u64` to `i64` without overflow protection. When transaction versions exceed `i64::MAX` (9,223,372,036,854,775,807), they wrap to negative values, breaking the chronological ordering logic in database upsert operations for "current" state tables.

## Finding Description

The indexer processes blockchain transactions and maintains both historical and "current" state tables in PostgreSQL. Transaction versions are cast from `u64` to `i64` throughout the indexer codebase. [1](#0-0) 

The `U64` type wraps a `u64` value, and the `.0` accessor retrieves the inner u64. [2](#0-1) 

In Rust, casting `u64` to `i64` using `as` performs a wrapping conversion. Values exceeding `i64::MAX` wrap around to negative numbers (e.g., `9,223,372,036,854,775,808_u64` becomes `-9,223,372,036,854,775,808_i64`).

The vulnerability manifests in database upsert operations that use a WHERE clause to ensure chronological ordering: [3](#0-2) 

This pattern appears in multiple processors:
- **Token processor**: `current_collection_datas`, `current_token_datas` [4](#0-3) 
- **Coin processor**: `current_coin_balances` [5](#0-4) 
- **Default processor**: `current_table_items` [6](#0-5) 

When a negative version number is compared with existing positive versions, the WHERE clause evaluates to FALSE, causing the update to be skipped and leaving stale data in the current tables.

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

While this breaks the State Consistency invariant, the practical impact is limited because:

1. **Indexer is non-consensus-critical**: The indexer is an auxiliary query service, not part of consensus. Validator nodes and blockchain operation are unaffected.

2. **Data staleness only**: The bug causes query results to be stale but doesn't corrupt consensus state, lose funds, or affect network liveness.

3. **Localized to indexer**: Only affects PostgreSQL-based indexer deployments; does not impact on-chain state or other nodes.

Per the Aptos bug bounty criteria, this qualifies as "State inconsistencies requiring intervention" under Medium Severity.

## Likelihood Explanation

**Likelihood: Extremely Low (Theoretical Only)**

This vulnerability requires transaction version to exceed `i64::MAX` = 9,223,372,036,854,775,807.

Calculation at various throughput rates:
- **10,000 TPS**: ~29,247 years to reach i64::MAX
- **100,000 TPS**: ~2,925 years to reach i64::MAX  
- **1,000,000 TPS**: ~292 years to reach i64::MAX

Even at unrealistic sustained throughput of 1 million transactions per second (far exceeding current blockchain capabilities), this would take centuries to manifest. The blockchain would undergo multiple protocol upgrades, migrations, and architectural changes before reaching this threshold.

**This is effectively a theoretical code quality issue rather than a practically exploitable vulnerability.**

## Recommendation

Replace `i64` with `NUMERIC` type in PostgreSQL for transaction version fields, and use `BigDecimal` in Rust instead of `i64`:

```rust
// In models/token_models/collection_datas.rs
pub struct CollectionData {
    pub collection_data_id_hash: String,
    pub transaction_version: BigDecimal,  // Changed from i64
    // ... other fields
}

// In tokens.rs
let txn_version = BigDecimal::from(user_txn.info.version.0);  // No cast
```

Update database migration:
```sql
ALTER TABLE collection_datas 
  ALTER COLUMN transaction_version TYPE NUMERIC(78, 0);
```

This preserves the full u64 range without overflow risk.

## Proof of Concept

```rust
// Demonstration of the overflow behavior
#[test]
fn test_u64_to_i64_overflow() {
    let max_i64 = i64::MAX as u64;
    let overflow_value = max_i64 + 1;
    
    // This cast wraps to negative
    let wrapped = overflow_value as i64;
    assert_eq!(wrapped, i64::MIN);
    
    // Demonstrates WHERE clause failure
    let existing_version: i64 = i64::MAX;
    let new_version: i64 = wrapped;
    
    // This comparison fails, preventing update
    assert!(!(existing_version <= new_version));
    println!("Update would be skipped: {} <= {} = {}", 
             existing_version, new_version, existing_version <= new_version);
}
```

**Notes:**

The database schema confirms BIGINT (i64) usage: [7](#0-6) 

While this is a valid technical bug in the codebase, it does not meet the threshold for a realistic, exploitable vulnerability due to the extreme timeframe required for manifestation. This should be addressed as a code quality improvement to ensure long-term correctness, but poses no immediate security risk to the Aptos network.

### Citations

**File:** crates/indexer/src/models/token_models/tokens.rs (L103-103)
```rust
            let txn_version = user_txn.info.version.0 as i64;
```

**File:** api/types/src/move_types.rs (L57-62)
```rust
macro_rules! define_integer_type {
    ($n:ident, $t:ty, $d:literal) => {
        #[doc = $d]
        #[doc = "Encoded as a string to encode into JSON."]
        #[derive(Clone, Debug, Default, Eq, PartialEq, Copy)]
        pub struct $n(pub $t);
```

**File:** crates/indexer/src/processors/token_processor.rs (L455-488)
```rust
fn insert_current_collection_datas(
    conn: &mut PgConnection,
    items_to_insert: &[CurrentCollectionData],
) -> Result<(), diesel::result::Error> {
    use schema::current_collection_datas::dsl::*;

    let chunks = get_chunks(items_to_insert.len(), CurrentCollectionData::field_count());

    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::current_collection_datas::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict(collection_data_id_hash)
                .do_update()
                .set((
                    creator_address.eq(excluded(creator_address)),
                    collection_name.eq(excluded(collection_name)),
                    description.eq(excluded(description)),
                    metadata_uri.eq(excluded(metadata_uri)),
                    supply.eq(excluded(supply)),
                    maximum.eq(excluded(maximum)),
                    maximum_mutable.eq(excluded(maximum_mutable)),
                    uri_mutable.eq(excluded(uri_mutable)),
                    description_mutable.eq(excluded(description_mutable)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    table_handle.eq(excluded(table_handle)),
                    inserted_at.eq(excluded(inserted_at)),
                )),
            Some(" WHERE current_collection_datas.last_transaction_version <= excluded.last_transaction_version "),
        )?;
    }
    Ok(())
}
```

**File:** crates/indexer/src/processors/coin_processor.rs (L221-221)
```rust
                Some(" WHERE current_coin_balances.last_transaction_version <= excluded.last_transaction_version "),
```

**File:** crates/indexer/src/processors/default_processor.rs (L400-400)
```rust
                Some(" WHERE current_table_items.last_transaction_version <= excluded.last_transaction_version "),
```

**File:** crates/indexer/migrations/2022-09-04-194128_add_token_data/up.sql (L75-91)
```sql
CREATE TABLE collection_datas (
  -- sha256 of creator + collection_name
  collection_data_id_hash VARCHAR(64) NOT NULL,
  transaction_version BIGINT NOT NULL,
  creator_address VARCHAR(66) NOT NULL,
  collection_name VARCHAR(128) NOT NULL,
  description TEXT NOT NULL,
  metadata_uri VARCHAR(512) NOT NULL,
  supply NUMERIC NOT NULL,
  maximum NUMERIC NOT NULL,
  maximum_mutable BOOLEAN NOT NULL,
  uri_mutable BOOLEAN NOT NULL,
  description_mutable BOOLEAN NOT NULL,
  inserted_at TIMESTAMP NOT NULL DEFAULT NOW(),
  -- Constraints
  PRIMARY KEY (collection_data_id_hash, transaction_version)
);
```
