# Audit Report

## Title
Aptos Faucet Auth Token Hot-Reload Missing - Stale Tokens Remain Valid Indefinitely

## Summary
The `AuthTokenChecker` and `AuthTokenBypasser` in the Aptos faucet service load authentication tokens from disk once at initialization and never reload them. When the token file is updated on disk, changes are not picked up without a service restart, allowing compromised tokens to remain valid indefinitely until manual intervention.

## Finding Description
The faucet authentication system uses the `ListManager` class to load and validate authentication tokens. The vulnerability exists in the initialization flow:

1. `AuthTokenChecker::new()` creates a `ListManager` instance with the token file path [1](#0-0) 

2. `ListManager::new()` reads the token file once and stores tokens in an in-memory `HashSet<String>` [2](#0-1) 

3. Token validation uses only the in-memory `HashSet`, never re-reading the file [3](#0-2) 

4. The faucet server runs continuously without any configuration reload mechanism [4](#0-3) 

**Attack Scenario:**
1. Attacker obtains a valid auth token (through logs, leaked configs, compromised systems)
2. Security team detects the compromise and removes the token from the configuration file
3. The attacker continues using the token successfully because the in-memory `HashSet` still contains it
4. If using `AuthTokenBypasser`, the attacker can bypass rate limits to drain testnet funds [5](#0-4) 

This affects both authentication checking (blocking invalid tokens) and bypass mechanisms (allowing privileged access).

## Impact Explanation
This finding qualifies as **Medium severity** under the Aptos bug bounty criteria ("State inconsistencies requiring intervention"):

- **Credential Management Failure**: Administrators cannot revoke compromised credentials without causing service downtime
- **Extended Exposure Window**: Compromised tokens remain valid for extended periods (hours to days) until service restart
- **Bypass Token Risk**: Compromised bypasser tokens allow unlimited faucet requests, potentially draining testnet resources
- **Operational Security Gap**: Violates security best practices requiring immediate credential revocation capability

While this affects testnet operations only (not mainnet), it represents a significant operational security gap that requires manual intervention (service restart) to remediate.

## Likelihood Explanation
**Likelihood: Medium**

Token compromise scenarios include:
- Leaked configuration files in public repositories
- Compromised CI/CD pipelines with access to secrets
- Insider threats or departed employees retaining tokens
- Accidental exposure in logs or monitoring systems

Once obtained, the attack requires no special privileges or technical sophistication. The gap between detection and effective revocation creates an exploitable window.

## Recommendation
Implement hot-reload capability for the `ListManager` class:

```rust
use std::sync::{Arc, RwLock};
use std::time::{Duration, SystemTime};

pub struct ListManager {
    items: Arc<RwLock<HashSet<String>>>,
    config: ListManagerConfig,
    last_modified: Arc<RwLock<SystemTime>>,
}

impl ListManager {
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let items = Arc::new(RwLock::new(Self::load_items(&config)?));
        let last_modified = Arc::new(RwLock::new(
            std::fs::metadata(&config.file)?.modified()?
        ));
        
        let manager = Self { items, config: config.clone(), last_modified };
        
        // Spawn background task to check for file changes
        manager.spawn_reload_task();
        
        Ok(manager)
    }
    
    fn spawn_reload_task(&self) {
        let items = self.items.clone();
        let config = self.config.clone();
        let last_modified = self.last_modified.clone();
        
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(30)).await;
                
                if let Ok(metadata) = std::fs::metadata(&config.file) {
                    if let Ok(modified) = metadata.modified() {
                        let last = *last_modified.read().unwrap();
                        if modified > last {
                            if let Ok(new_items) = Self::load_items(&config) {
                                *items.write().unwrap() = new_items;
                                *last_modified.write().unwrap() = modified;
                                info!("Reloaded {} items from {}", 
                                      new_items.len(), 
                                      config.file.display());
                            }
                        }
                    }
                }
            }
        });
    }
    
    fn load_items(config: &ListManagerConfig) -> Result<HashSet<String>> {
        // Existing loading logic from lines 22-31
        ...
    }
    
    pub fn contains(&self, item: &str) -> bool {
        self.items.read().unwrap().contains(item)
    }
}
```

This implementation:
- Checks file modification time every 30 seconds
- Automatically reloads when the file changes
- Uses `RwLock` for thread-safe concurrent access
- Maintains backward compatibility with existing API

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_token_hot_reload_vulnerability() -> Result<()> {
    // Create initial token file with "valid_token"
    let token_file = "/tmp/test_tokens.txt";
    std::fs::write(token_file, "valid_token\n")?;
    
    // Start faucet server
    let config = ListManagerConfig {
        file: PathBuf::from(token_file),
    };
    let checker = AuthTokenChecker::new(config)?;
    
    // Verify token works
    let mut headers = HeaderMap::new();
    headers.insert(
        AUTHORIZATION,
        HeaderValue::from_str("Bearer valid_token")?,
    );
    let data = CheckerData { headers, ..Default::default() };
    
    let result = checker.check(data.clone(), false).await?;
    assert!(result.is_empty(), "Token should be valid");
    
    // Admin removes compromised token from file
    std::fs::write(token_file, "")?;
    
    // Wait to ensure file system sync
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // VULNERABILITY: Token still works despite being removed from file
    let result = checker.check(data, false).await?;
    assert!(result.is_empty(), "BUG: Removed token still valid!");
    
    // This would only fail after service restart
    Ok(())
}
```

## Notes

The vulnerability affects both `AuthTokenChecker` (access control) and `AuthTokenBypasser` (rate limit bypass). The same issue exists in `IpRangeManager` for IP allowlists/blocklists, suggesting a systemic pattern that should be addressed across all configuration-based security controls.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L20-27)
```rust
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let manager = ListManager::new(config)?;
        info!(
            "Loaded {} auth tokens into AuthTokenChecker",
            manager.num_items()
        );
        Ok(Self { manager })
    }
```

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L20-33)
```rust
impl ListManager {
    pub fn new(config: ListManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;
        let mut items = HashSet::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            items.insert(line);
        }
        Ok(Self { items })
    }
```

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L35-37)
```rust
    pub fn contains(&self, item: &str) -> bool {
        self.items.contains(item)
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L85-86)
```rust
    async fn run_impl(self, port_tx: Option<OneShotSender<u16>>) -> Result<()> {
        info!("Running with config: {:#?}", self);
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L32-49)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }

        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(false),
        };

        Ok(self.manager.contains(auth_token))
    }
```
