# Audit Report

## Title
Information Disclosure via Unsanitized Internal Error Messages in Storage Service

## Summary
The storage service handler exposes internal database errors and implementation details to untrusted network clients through insufficient error message sanitization. When mapping internal `Error` types to `StorageServiceError` types, the catch-all error handler preserves complete error messages that may contain sensitive information such as database internal states, column family names, RocksDB error details, and potentially file system paths.

## Finding Description

The storage service is a network-facing RPC service that handles data synchronization requests from peers, including untrusted public fullnodes (PFNs). [1](#0-0) 

In the request processing flow, internal errors from the storage layer are mapped to client-facing error types. The error mapping logic uses a catch-all pattern that converts internal errors to strings without sanitization: [2](#0-1) 

The internal `Error` enum contains variants that wrap raw error messages from the storage subsystem: [3](#0-2) 

When `AptosDbError` instances are converted to internal `Error` types, they preserve the full error message: [4](#0-3) 

The `AptosDbError` type contains multiple variants that may expose internal implementation details: [5](#0-4) 

These errors include database-specific information such as column family names, property names, RocksDB internal error messages, I/O errors with potential path information, and internal state validation messages. [6](#0-5) 

When RocksDB errors occur, they are converted with full error details: [7](#0-6) 

The resulting `StorageServiceError` is serialized and sent to the requesting peer over the network: [8](#0-7) 

**Attack Path:**
1. Attacker operates a malicious public fullnode that connects to an honest validator or VFN
2. Attacker sends crafted storage service requests designed to trigger specific internal errors (e.g., requesting data at invalid versions, requesting missing state keys, or causing database read failures)
3. The storage service processes the request, encounters an error from `AptosDB` or storage operations
4. The error is mapped through the catch-all handler to `StorageServiceError::InternalError(error.to_string())`
5. The error message containing internal details is serialized and transmitted back to the attacker
6. Attacker extracts information about database structure, column families, internal validation logic, RocksDB configuration, and potentially file system paths

## Impact Explanation

This issue constitutes **information disclosure** that exposes internal implementation details to untrusted network peers. The severity assessment depends on the nature of leaked information:

The Aptos bug bounty program categorizes information leaks under Low Severity ("Minor information leaks"). However, the disclosure of substantial internal implementation details including database internals, validation logic, and potentially deployment-specific information to untrusted network actors represents more than a "minor" leak.

While this vulnerability does not directly enable:
- Consensus violations or safety breaks
- Fund theft or unauthorized minting
- Node crashes or availability loss
- State corruption or manipulation

It does facilitate:
- Reconnaissance for more sophisticated attacks by revealing internal architecture
- Understanding of database implementation that could inform other attack vectors
- Potential exposure of deployment-specific configuration details
- Violation of defense-in-depth principles by exposing implementation internals

The vulnerability represents a **security boundary violation** where the network-facing API exposes details that should remain internal to the node implementation.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is easily exploitable because:
1. **No special privileges required**: Any node operator running a public fullnode can send storage service requests
2. **Low complexity**: Triggering storage errors is straightforward by requesting invalid data ranges, missing versions, or non-existent state keys
3. **Deterministic behavior**: The error mapping consistently exposes internal details whenever storage errors occur
4. **No rate limiting bypass needed**: Even with request moderation, legitimate-appearing requests that happen to trigger errors will leak information

The storage service is designed to handle requests from untrusted public fullnodes as part of normal state synchronization operations, making this attack surface continuously available to potential attackers.

## Recommendation

Implement error sanitization in the error mapping logic to prevent internal details from leaking to clients. The fix should:

1. **Map internal errors to generic error categories** without exposing implementation details
2. **Log detailed errors server-side** for debugging while sending sanitized versions to clients
3. **Preserve only client-actionable information** in error responses

**Recommended fix** in `handler.rs`:

```rust
// Transform the request error into a storage service error (for the client)
process_result.map_err(|error| match error {
    Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
    Error::TooManyInvalidRequests(error) => {
        StorageServiceError::TooManyInvalidRequests(error)
    },
    Error::StorageErrorEncountered(_) => {
        // Log the full error internally but return generic message
        StorageServiceError::InternalError("Storage error occurred".to_string())
    },
    Error::UnexpectedErrorEncountered(_) => {
        // Log the full error internally but return generic message
        StorageServiceError::InternalError("Internal error occurred".to_string())
    },
})
```

Additionally, ensure that the internal error logging captures sufficient detail for debugging while the client-facing error messages remain generic.

## Proof of Concept

```rust
// File: state-sync/storage-service/server/src/tests/error_disclosure_test.rs

#[tokio::test]
async fn test_error_message_disclosure() {
    use crate::{error::Error, handler::Handler};
    use aptos_storage_interface::AptosDbError;
    use aptos_storage_service_types::{
        requests::{DataRequest, StorageServiceRequest, TransactionsWithProofRequest},
        StorageServiceError,
    };
    
    // Simulate a storage error with internal details
    let internal_error = AptosDbError::Other(
        "Internal database state: column family 'transaction_info' property 'rocksdb.estimate-num-keys' returned None at /var/lib/aptos/db".to_string()
    );
    
    // Convert to internal Error type (as done by From trait)
    let server_error = Error::from(internal_error);
    
    // Simulate the error mapping in process_request (lines 196-202)
    let client_error: StorageServiceError = match server_error {
        Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
        Error::TooManyInvalidRequests(error) => {
            StorageServiceError::TooManyInvalidRequests(error)
        },
        error => StorageServiceError::InternalError(error.to_string()),
    };
    
    // Verify that internal details are exposed
    match client_error {
        StorageServiceError::InternalError(msg) => {
            // The error message should NOT contain these internal details, but it does
            assert!(msg.contains("column family"));
            assert!(msg.contains("rocksdb"));
            assert!(msg.contains("/var/lib/aptos/db")); // File path leaked!
            println!("VULNERABILITY CONFIRMED: Internal details leaked to client: {}", msg);
        },
        _ => panic!("Expected InternalError"),
    }
}
```

This test demonstrates that internal database details including file paths, column family names, and RocksDB-specific information are preserved in error messages sent to network clients, violating the security boundary between internal implementation and external API.

## Notes

While this vulnerability does not directly compromise consensus safety, fund security, or network availability, it represents a **defense-in-depth failure** by exposing internal implementation details to potentially adversarial network peers. Information disclosure vulnerabilities of this nature should be addressed to maintain proper security boundaries and minimize reconnaissance opportunities for attackers.

The categorization as Medium severity (as suggested in the security question) may be generousâ€”this more closely aligns with Low severity "minor information leaks" per the bug bounty program. However, the specific information being leaked (database internals, potential file paths, implementation-specific details) to untrusted network actors elevates this above purely cosmetic information disclosure.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L49-68)
```rust
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```

**File:** state-sync/storage-service/server/src/error.rs (L7-17)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum Error {
    #[error("Invalid request received: {0}")]
    InvalidRequest(String),
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
    #[error("Too many invalid requests: {0}")]
    TooManyInvalidRequests(String),
    #[error("Unexpected error encountered: {0}")]
    UnexpectedErrorEncountered(String),
}
```

**File:** state-sync/storage-service/server/src/error.rs (L43-46)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
```

**File:** storage/storage-interface/src/errors.rs (L10-37)
```rust
#[derive(Clone, Debug, Error)]
pub enum AptosDbError {
    /// A requested item is not found.
    #[error("{0} not found.")]
    NotFound(String),
    /// Requested too many items.
    #[error("Too many items requested: at least {0} requested, max is {1}")]
    TooManyRequested(u64, u64),
    #[error("Missing state root node at version {0}, probably pruned.")]
    MissingRootError(u64),
    /// Other non-classified error.
    #[error("AptosDB Other Error: {0}")]
    Other(String),
    #[error("AptosDB RocksDb Error: {0}")]
    RocksDbIncompleteResult(String),
    #[error("AptosDB RocksDB Error: {0}")]
    OtherRocksDbError(String),
    #[error("AptosDB bcs Error: {0}")]
    BcsError(String),
    #[error("AptosDB IO Error: {0}")]
    IoError(String),
    #[error("AptosDB Recv Error: {0}")]
    RecvError(String),
    #[error("AptosDB ParseInt Error: {0}")]
    ParseIntError(String),
    #[error("Hot state not configured properly")]
    HotStateError,
}
```

**File:** storage/schemadb/src/lib.rs (L345-350)
```rust
                aptos_storage_interface::AptosDbError::Other(
                    format!(
                        "Unable to get property \"{}\" of  column family \"{}\".",
                        property_name, cf_name,
                    )
                    .to_string(),
```

**File:** storage/schemadb/src/lib.rs (L406-407)
```rust
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
```

**File:** state-sync/storage-service/types/src/lib.rs (L29-37)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum StorageServiceError {
    #[error("Internal service error: {0}")]
    InternalError(String),
    #[error("Invalid storage request: {0}")]
    InvalidRequest(String),
    #[error("Too many invalid requests! Back off required: {0}")]
    TooManyInvalidRequests(String),
}
```
