# Audit Report

## Title
Git Dependency Version Pinning Bypass via Branch/Commit Name Collision

## Summary
The Move package resolution system's `download_and_update_if_remote()` function fails to properly validate commit hash pinning for Git dependencies. An attacker controlling a dependency repository can create a remote branch with the same name as a commit hash, causing the build system to silently switch to malicious code despite developers believing they have pinned to a specific immutable commit.

## Finding Description

The vulnerability exists in the Git dependency update logic at [1](#0-0) .

When a Move package specifies a Git dependency with what appears to be a commit hash (e.g., `rev = "abc123def456"`), developers expect immutable version pinning - that exact code should be used forever. However, the update logic contains a critical flaw:

1. **Initial Safety Check** [2](#0-1) : The code attempts to verify if the revision is a commit by calling `git rev-parse --verify` and checking if the result starts with the specified revision string.

2. **The Vulnerability**: If this check fails (returns a commit hash that doesn't start with the expected string), the code assumes the revision must be a branch name and proceeds to update it.

3. **Malicious Exploitation** [3](#0-2) : The code calls `reset_hard()` which executes `git reset --hard origin/{rev}` [4](#0-3) .

**Attack Scenario:**
1. Developer specifies: `MyLib = { git = "https://github.com/attacker/lib", rev = "abc123def456" }`
2. Initially, commit `abc123def456...` contains legitimate code
3. Attacker creates a remote branch named `abc123def456` pointing to malicious commit `999evil...`
4. On next build (without `--skip-fetch-latest-git-deps`):
   - `git fetch origin` retrieves the new branch
   - `git rev-parse --verify abc123def456` resolves to `999evil...` (the branch's commit)
   - Check `999evil....starts_with("abc123def456")` â†’ **FALSE**
   - Falls through to `git reset --hard origin/abc123def456`
   - **Silently switches to the malicious branch**

The root cause is that `reset_hard()` blindly prepends `origin/` to the revision string, assuming it's a branch name when the commit hash check fails. This breaks the fundamental security guarantee of commit hash pinning.

## Impact Explanation

This vulnerability enables supply chain attacks on Move package dependencies. While it doesn't directly compromise the Aptos blockchain's consensus or runtime, it affects the security of Move application development:

**Direct Impact:**
- Developers lose the security guarantee of immutable version pinning
- Malicious dependencies can be substituted without detection
- Compromised dependencies can contain backdoors, fund-stealing logic, or vulnerabilities

**Potential Blockchain Impact:**
- If malicious code is compiled into Move modules and deployed on-chain, it could steal user funds
- Critically, if this affects Aptos Framework builds (though unlikely due to controlled dependencies), it could compromise the entire blockchain

**Severity Assessment:** This is a **High severity** vulnerability under "Significant protocol violations" - it violates the security contract of commit hash pinning in the Move package resolution protocol. While not directly causing fund loss or consensus breaks, it's a critical security control bypass that enables further attacks.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is easily exploitable when:
1. A developer uses Git dependencies (common practice)
2. The dependency repository is controlled by an attacker or gets compromised
3. Developers rebuild without `--skip-fetch-latest-git-deps` (default behavior)

Factors increasing likelihood:
- Default behavior enables the vulnerability (auto-fetch is on by default)
- Developers expect commit hashes to provide immutable pinning
- No warning is shown when switching to a branch with a commit-hash-like name
- Supply chain attacks are increasingly common

Factors decreasing likelihood:
- Requires attacker control of the dependency repository
- Aptos Framework dependencies are trusted and unlikely to be compromised
- Some developers may use `--skip-fetch-latest-git-deps`

## Recommendation

The vulnerability should be fixed by properly distinguishing between commit hashes and branch names:

**Solution 1: Validate commit existence before reset**
```rust
// In download_and_update_if_remote, after line 588:
if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
    if parsed_rev.trim().starts_with(git_rev) {
        // It's a valid commit hash - verify it still exists
        return Ok(());
    }
}

// Before calling reset_hard, verify it's actually a branch:
if git::find_tag(git_path, git_rev).is_ok() {
    // Handle as tag
} else {
    // Only call reset_hard if we're CERTAIN it's a branch
    // Don't assume branch just because commit check failed
    git::reset_hard(git_path, git_rev, dep_name)?;
}
```

**Solution 2: Never auto-update commit hashes**
```rust
// Check if rev looks like a commit hash (hex string)
if git_rev.chars().all(|c| c.is_ascii_hexdigit()) {
    // Treat as immutable commit hash - never update
    if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
        if parsed_rev.trim().starts_with(git_rev) {
            return Ok(()); // Commit exists, don't update
        }
    }
    // Commit doesn't exist - error out rather than falling back to branch
    bail!("Git commit '{}' not found for package '{}'", git_rev, dep_name);
}
// Only proceed with branch update logic if it's not hex
```

**Solution 3: Use the safer move-package-cache implementation**
The newer implementation in [5](#0-4)  separates revision resolution from checkout and uses proper Git object IDs, making it harder to confuse branches and commits.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: third_party/move/tools/move-package/tests/test_version_pinning_bypass.rs

#[test]
fn test_commit_hash_branch_confusion() {
    use std::process::Command;
    use tempfile::TempDir;
    
    // Setup: Create a test Git repository
    let repo_dir = TempDir::new().unwrap();
    let repo_path = repo_dir.path();
    
    // Initialize repo
    Command::new("git")
        .args(["init"])
        .current_dir(repo_path)
        .output()
        .unwrap();
    
    // Create initial commit
    std::fs::write(repo_path.join("file.txt"), "legitimate").unwrap();
    Command::new("git")
        .args(["add", "."])
        .current_dir(repo_path)
        .output()
        .unwrap();
    Command::new("git")
        .args(["commit", "-m", "initial"])
        .current_dir(repo_path)
        .output()
        .unwrap();
    
    // Get commit hash
    let output = Command::new("git")
        .args(["rev-parse", "HEAD"])
        .current_dir(repo_path)
        .output()
        .unwrap();
    let commit_hash = String::from_utf8(output.stdout).unwrap();
    let short_hash = &commit_hash[0..7];
    
    // Create malicious commit
    std::fs::write(repo_path.join("file.txt"), "MALICIOUS").unwrap();
    Command::new("git")
        .args(["add", "."])
        .current_dir(repo_path)
        .output()
        .unwrap();
    Command::new("git")
        .args(["commit", "-m", "malicious"])
        .current_dir(repo_path)
        .output()
        .unwrap();
    
    // Create branch with same name as commit hash
    Command::new("git")
        .args(["branch", short_hash])
        .current_dir(repo_path)
        .output()
        .unwrap();
    
    // Simulate the vulnerability:
    // checkout() would use the commit hash, but reset_hard() would use the branch
    let checkout_result = Command::new("git")
        .args(["checkout", short_hash])
        .current_dir(repo_path)
        .output()
        .unwrap();
    
    // Read file - should be legitimate
    let content = std::fs::read_to_string(repo_path.join("file.txt")).unwrap();
    assert_eq!(content, "legitimate");
    
    // Now simulate reset_hard with origin/ prefix
    // (In real scenario, origin/branch would point to malicious commit)
    Command::new("git")
        .args(["checkout", &format!("refs/heads/{}", short_hash)])
        .current_dir(repo_path)
        .output()
        .unwrap();
    
    // Read file - now it's malicious!
    let content = std::fs::read_to_string(repo_path.join("file.txt")).unwrap();
    assert_eq!(content, "MALICIOUS");
    
    // This demonstrates that branch/commit name collision allows bypassing version pinning
}
```

## Notes

This vulnerability specifically affects the legacy Move package resolution system. The impact is primarily on Move application developers rather than the Aptos blockchain runtime itself. However, it represents a significant security control bypass that violates the fundamental trust model of commit hash pinning. Developers who believe they have immutable dependencies are actually vulnerable to silent code substitution attacks.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-616)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
        }
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L97-125)
```rust
pub(crate) fn reset_hard(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "reset",
            "--hard",
            &format!("origin/{}", rev)
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps",
                rev,
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            rev,
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L180-202)
```rust
    /// Resolves a Git revision string to a specific commit id.
    ///
    /// This will clone the repo if it is not already cached, or update it if it is.
    pub async fn resolve_git_revision(&self, git_url: &Url, rev: &str) -> Result<Oid>
    where
        L: PackageCacheListener,
    {
        let repo = self.clone_or_update_git_repo(git_url).await?;

        let obj = repo
            .repo
            .revparse_single(&format!("origin/{}", rev))
            .map_err(|_err| {
                anyhow!(
                    "Failed to resolve rev string \"{}\" in repo {}",
                    rev,
                    git_url
                )
            })?;
        let oid = obj.id();

        Ok(oid)
    }
```
