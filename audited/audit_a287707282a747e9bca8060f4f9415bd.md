# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Causes JWK Consensus Liveness Failure

## Summary
The `UnsupportedJWK` struct uses non-canonical JSON serialization when converting from `serde_json::Value`, causing validators that observe semantically identical JWKs with different JSON key orderings to fail consensus. A malicious OIDC provider or man-in-the-middle attacker can serve the same JWK with different key orderings to different validators, preventing them from reaching quorum on JWK updates.

## Finding Description

The vulnerability exists in the `UnsupportedJWK::from(serde_json::Value)` implementation: [1](#0-0) 

When converting a `serde_json::Value` to an `UnsupportedJWK`, the code calls `.to_string()` to serialize the JSON value. The developer's TODO comment explicitly acknowledges this issue: `//TODO: canonical to_string.`

The problem is that `serde_json::Value` uses an insertion-order-preserving map (IndexMap) for JSON objects. This means:
- `{"kid":"123","kty":"EC"}` and `{"kty":"EC","kid":"123"}` parse into different `serde_json::Value` structures
- Calling `.to_string()` preserves the original key order, producing different byte strings
- Different byte strings produce different SHA3-256 hashes for the `id` field
- Two `UnsupportedJWK` objects are not equal despite being semantically identical

This propagates through the JWK consensus protocol. When validators fetch JWKs from OIDC providers: [2](#0-1) 

Each validator converts the JSON to `JWK` objects: [3](#0-2) 

During consensus, validators must agree on observed JWKs. The observation aggregation logic strictly enforces equality: [4](#0-3) 

If validator A observes a JWK with keys ordered `["kid","kty"]` and validator B observes the same JWK with keys ordered `["kty","kid"]`, their `UnsupportedJWK` objects will have:
- Different `payload` byte arrays
- Different `id` hashes
- The equality check `self.local_view == peer_view` fails
- Validator A rejects validator B's observation
- Consensus cannot be reached

**Attack Scenario:**
1. A malicious OIDC provider deploys a load balancer that randomly permutes JSON key ordering
2. Different validators receive the same JWK content but with different key orderings
3. Each validator converts to `UnsupportedJWK` with different `id` and `payload`
4. Validators broadcast their observations but reject each other's views as "mismatched"
5. The quorum threshold is never reached
6. The JWK update cannot be committed to on-chain state
7. Keyless accounts using the new JWK cannot authenticate

## Impact Explanation

This vulnerability causes a **consensus liveness failure** in the JWK consensus subsystem. While it does not directly break the main AptosBFT consensus or cause fund loss, it has significant impacts:

**Severity: High** (per Aptos Bug Bounty criteria)
- **Significant protocol violations**: The JWK consensus protocol cannot reach agreement, violating its safety guarantees
- **Denial of Service**: Keyless account authentication is disrupted for users whose JWKs cannot be updated on-chain
- **Requires manual intervention**: Governance would need to manually patch the affected JWKs or emergency-upgrade the node software

The impact is amplified because:
- JWK consensus runs continuously in the background on all validators
- A single malicious OIDC provider can affect the entire validator set
- The attack is undetectable from the validators' perspective (they see legitimately different JWKs)
- This could be used to selectively DoS keyless authentication for specific OIDC providers

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is realistic because:
1. **Attacker Control**: Any OIDC provider can control JSON key ordering in their responses
2. **No Detection**: The attack appears as legitimate protocol disagreement
3. **Low Cost**: Requires only HTTP response manipulation, no cryptographic attacks
4. **Multiple Vectors**: Can be executed via compromised OIDC provider OR man-in-the-middle attack on HTTPS connections (if TLS is compromised)

The vulnerability is clearly acknowledged by developers (TODO comment), indicating they are aware but haven't fixed it yet.

Real-world factors that increase likelihood:
- JSON libraries in different languages often produce different key orderings
- Cloud load balancers may route validators to different backend servers
- OIDC providers may rotate backend infrastructure with different JSON serializers

## Recommendation

**Fix: Implement canonical JSON serialization for UnsupportedJWK**

Replace the non-canonical `.to_string()` with canonical JSON serialization:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization (RFC 8785 / JCS)
        let payload = canonical_json(&json_value).into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}

fn canonical_json(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Object(map) => {
            let mut entries: Vec<_> = map.iter().collect();
            entries.sort_by_key(|(k, _)| *k); // Sort keys alphabetically
            let serialized_entries: Vec<String> = entries
                .iter()
                .map(|(k, v)| format!("\"{}\":{}", k, canonical_json(v)))
                .collect();
            format!("{{{}}}", serialized_entries.join(","))
        },
        serde_json::Value::Array(arr) => {
            let serialized: Vec<String> = arr.iter().map(canonical_json).collect();
            format!("[{}]", serialized.join(","))
        },
        _ => value.to_string(), // Primitives are already canonical
    }
}
```

**Alternative Fix**: Use a canonical JSON library like `serde_jcs` (JSON Canonicalization Scheme):

```rust
use serde_jcs;

impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = serde_jcs::to_vec(&json_value)
            .expect("canonical serialization should not fail");
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**Migration Considerations**: Existing on-chain `UnsupportedJWK` entries will have non-canonical payloads. A migration strategy is needed:
1. Feature flag to enable canonical serialization for new JWKs
2. Governance proposal to re-canonicalize existing JWKs
3. Or accept that old and new JWKs use different formats (check version)

## Proof of Concept

```rust
// This test demonstrates the vulnerability
#[test]
fn test_jwk_key_ordering_causes_inequality() {
    use serde_json::json;
    use aptos_types::jwks::unsupported::UnsupportedJWK;
    
    // Same JWK content, different key ordering
    let jwk_order_1 = json!({
        "kid": "test-key-123",
        "kty": "EC",
        "crv": "P-256"
    });
    
    let jwk_order_2 = json!({
        "kty": "EC",
        "kid": "test-key-123",
        "crv": "P-256"
    });
    
    // Convert to UnsupportedJWK
    let unsupported_1 = UnsupportedJWK::from(jwk_order_1);
    let unsupported_2 = UnsupportedJWK::from(jwk_order_2);
    
    // These should be equal semantically, but they're not!
    assert_ne!(unsupported_1.payload, unsupported_2.payload, 
               "Payloads differ due to key ordering");
    assert_ne!(unsupported_1.id, unsupported_2.id, 
               "IDs differ because they hash different payloads");
    assert_ne!(unsupported_1, unsupported_2, 
               "JWKs are not equal despite being semantically identical");
    
    // This causes consensus failure in the real system
    println!("Payload 1: {:?}", String::from_utf8_lossy(&unsupported_1.payload));
    println!("Payload 2: {:?}", String::from_utf8_lossy(&unsupported_2.payload));
    println!("ID 1: {:?}", hex::encode(&unsupported_1.id));
    println!("ID 2: {:?}", hex::encode(&unsupported_2.id));
}
```

**Consensus Failure Simulation**: Deploy a mock OIDC provider that serves JSON with randomized key ordering to different validators, then observe the JWK consensus logs showing "mismatched view" errors and failure to aggregate quorum.

## Notes

The vulnerability is explicitly acknowledged in the codebase via the TODO comment, indicating developer awareness but no fix has been implemented. This is a time-bomb waiting to be triggered by any OIDC provider update that changes JSON serialization behavior, or by an active attacker targeting the JWK consensus system.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/jwk-utils/src/lib.rs (L34-36)
```rust
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```
