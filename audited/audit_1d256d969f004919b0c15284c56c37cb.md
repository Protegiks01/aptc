# Audit Report

## Title
Transitive Purity Propagation Failure in Mutually Recursive Functions

## Summary
The `FunctionPurenessChecker` in `pureness_checker.rs` incorrectly marks functions as pure when they participate in mutually recursive call graphs with impure functions. The cycle-breaking mechanism (line 163) temporarily marks functions as pure before checking their bodies, but functions checked during this temporary state never get re-evaluated when the true purity status is determined.

## Finding Description

The pureness checker is used by the Move compiler's spec checker to validate that specification expressions only call pure (side-effect-free) functions. [1](#0-0) 

The transitive purity checking logic at lines 122-142 has a critical flaw when handling mutually recursive functions: [2](#0-1) 

**Vulnerability Mechanism:**

Consider two mutually recursive functions:
- `impure_func()` - contains direct impurity (e.g., `Mutate` operation) and calls `wrapper_func()`
- `wrapper_func()` - calls `impure_func()` (creating a cycle)

**Execution trace when checking `impure_func` first:**

1. `impure_func` not in pureness map, enter check at line 126
2. Call `check_function(impure_func)` at line 129
3. Inside `check_function`, line 163 inserts `impure_func -> true` (cycle breaker): [3](#0-2) 
4. During `impure_func`'s body check, encounter call to `wrapper_func`
5. `wrapper_func` not in pureness map, enter nested check
6. Call `check_function(wrapper_func)`
7. Line 163 inserts `wrapper_func -> true` (cycle breaker)
8. During `wrapper_func`'s body check, encounter call to `impure_func`
9. **Critical**: `impure_func` IS in pureness map (value = `true` from step 3)
10. Line 126 condition fails, skip nested check: [4](#0-3) 
11. Line 134 checks: `if !pureness[impure_func]` = `if !true` = `false`, so don't mark as impure
12. `wrapper_func` completes with `is_impure = false`
13. Line 130 inserts `wrapper_func -> true` (marked as PURE)
14. Return to `impure_func` check, continue scanning body
15. Encounter `Mutate` operation: `is_impure = true`
16. `impure_func` completes, line 130 inserts `impure_func -> false` (correctly marked as impure)

**Final result:** `impure_func -> false` (impure - correct), `wrapper_func -> true` (pure - **INCORRECT**)

The bug is that `wrapper_func` was evaluated when `impure_func` was temporarily marked pure. After `impure_func`'s true status (impure) is determined, `wrapper_func` is never re-evaluated. This violates transitive purity: if `wrapper_func` calls `impure_func` which is impure, then `wrapper_func` must also be impure.

**Security Impact:**

The spec checker uses this pureness checker to validate specification expressions: [5](#0-4) 

If a function is incorrectly marked as pure, specification functions can call it without compilation errors, allowing specifications to have side effects. This breaks the fundamental invariant that specifications must be pure, which could lead to:

1. **Incorrect Formal Verification Results**: The Move Prover may produce incorrect verification results if specs have unintended side effects
2. **False Security Guarantees**: Contracts that appear formally verified may contain vulnerabilities
3. **Deployed Vulnerable Contracts**: Developers relying on formal verification may deploy insecure contracts

## Impact Explanation

This is a **Medium Severity** vulnerability with indirect security implications:

- **Not Critical/High** because it doesn't directly affect runtime execution, consensus, or cause immediate loss of funds
- **Medium Severity** because it affects the correctness of formal verification tooling, potentially leading to incorrectly verified contracts being deployed
- Breaks the invariant that specification expressions must be pure
- Could indirectly lead to security vulnerabilities in production contracts if developers rely on flawed verification results

The impact is primarily on **formal verification correctness** rather than direct blockchain security, but the downstream consequences could include vulnerable contract deployment.

## Likelihood Explanation

**Likelihood: Medium**

- Mutual recursion is explicitly supported in Move (evidenced by test cases)
- The bug triggers whenever mutually recursive functions are checked and one is impure
- Developers may write recursive helper functions in their Move code
- The bug is deterministic and will always occur for the affected pattern
- However, it requires specific circumstances: spec checking must be enabled, and the code must use mutually recursive functions with impurity

## Recommendation

The pureness checker needs to track functions whose purity determination depends on cycle-breaker assumptions and re-evaluate them when those assumptions change.

**Proposed Fix:**

1. Track which functions were checked while depending on cycle-breaker temporary values
2. After a function's true purity is determined, re-check all dependent functions
3. Alternatively, use a different cycle-breaking strategy such as assuming functions are impure initially (more conservative)

**Code fix approach:**

```rust
// After line 130, add re-evaluation logic:
self.pureness.insert(qid, !self.is_impure);
// Check if this differs from the cycle-breaker value
// If so, re-check any functions that were evaluated assuming the old value
if let Some(old_value) = previous_cycle_breaker_value {
    if old_value != !self.is_impure {
        // Re-evaluate dependent functions
        for dependent in self.get_dependent_functions(qid) {
            self.re_check_function(env, dependent);
        }
    }
}
```

This would require tracking dependencies during traversal.

## Proof of Concept

**Move module demonstrating the vulnerability:**

```move
module 0x42::cyclic_impurity_test {
    
    // This function is directly impure (uses mutation)
    // and calls wrapper_func creating mutual recursion
    fun impure_func(x: u64): u64 {
        let r = &mut x;
        *r = *r + 1;  // Direct impurity: Mutate operation
        if (x > 10) {
            x
        } else {
            wrapper_func(x)  // Call to wrapper_func
        }
    }
    
    // This function calls impure_func
    // Should be marked as impure (transitively)
    // But due to cycle-breaking bug, may be marked as pure
    fun wrapper_func(x: u64): u64 {
        if (x > 5) {
            impure_func(x - 1)  // Call back to impure_func (creates cycle)
        } else {
            x
        }
    }
    
    // This spec function calls wrapper_func
    // Should fail pureness check but may not due to the bug
    spec fun should_fail_but_might_not(x: u64): u64 {
        wrapper_func(x)  // This should be rejected as impure
    }
    
    spec module {
        // This invariant calls the spec function
        // Should fail if pureness checking works correctly
        invariant should_fail_but_might_not(5) > 0;
    }
}
```

**Expected behavior:** Compilation should fail with error "specification expression cannot call impure Move function `wrapper_func`"

**Actual behavior (with bug):** If `impure_func` is checked first and the cycle-breaking logic runs, `wrapper_func` may be incorrectly marked as pure, allowing the spec to compile without error.

**Testing steps:**
1. Enable spec checking in Move compiler v2 with `SPEC_CHECK` experiment flag
2. Compile the above module
3. Observe whether pureness checking correctly rejects the spec function call

## Notes

This vulnerability specifically affects the **formal verification tooling** (Move Prover and spec checker) rather than runtime execution. The pureness checker operates at compile-time on the AST level [6](#0-5) , and specifications are not executed on-chain.

While this doesn't directly compromise consensus or cause immediate loss of funds, it undermines the security guarantees provided by formal verification, which is a critical defense layer for Move smart contracts on Aptos.

### Citations

**File:** third_party/move/move-model/src/pureness_checker.rs (L1-18)
```rust
// Copyright Â© Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

//! Checks pureness (absence of side-effects) of expressions.
//! An expression is pure if
//!
//! - It does not use borrow_global_mut or `&mut e`.
//! - It does not use Mutate
//! - It does not call another impure function.
//!
//! In specification checking mode, in addition the following constructs are disallowed
//!
//! - No use of Assign
//! - Not use of Return
//! - No use of uninitialized let bindings
//!
//! The checker does a DFS search to figure whether transitive call chains are pure or not.

```

**File:** third_party/move/move-model/src/pureness_checker.rs (L122-142)
```rust
                Call(id, MoveFunction(mid, sid), ..) => {
                    let qid = mid.qualified(*sid);
                    // false positive: can't use entry because of borrow conflict
                    #[allow(clippy::map_entry)]
                    if !self.pureness.contains_key(&qid) {
                        self.visiting.push((qid, *id));
                        let old_impure = mem::take(&mut self.is_impure);
                        self.check_function(env, qid);
                        self.pureness.insert(qid, !self.is_impure);
                        self.visiting.pop();
                        self.is_impure |= old_impure;
                    }
                    if !self.pureness.get(&qid).unwrap() {
                        (self.impure_action)(
                            *id,
                            "calls a function which modifies state",
                            &self.visiting,
                        );
                        self.is_impure = true
                    }
                },
```

**File:** third_party/move/move-model/src/pureness_checker.rs (L159-165)
```rust
    fn check_function(&mut self, env: &GlobalEnv, qid: QualifiedId<FunId>) {
        let fun = env.get_function(qid);
        if let Some(def) = fun.get_def() {
            // For breaking cycles, assume initially function is pure
            self.pureness.insert(qid, true);
            // Continue recursively
            self.check_exp(env, def);
```

**File:** third_party/move/move-model/src/env_pipeline/spec_checker.rs (L50-57)
```rust

```
