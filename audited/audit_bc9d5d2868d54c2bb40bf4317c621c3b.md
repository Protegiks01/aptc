# Audit Report

## Title
API Returns Unverified State Values Without Merkle Proofs

## Summary
The Aptos REST API endpoint `get_raw_state_value` returns state values without including cryptographic Merkle proofs, enabling malicious or compromised API nodes to return fake data that clients cannot verify. This violates the fundamental blockchain principle of trustless verification and breaks the "State Consistency" invariant.

## Finding Description

The `RawStateValueRequest` struct in the API accepts state key queries, but the corresponding endpoint implementation returns only the raw state value without any Merkle proof. [1](#0-0) 

The API endpoint `get_raw_state_value` processes these requests: [2](#0-1) 

The underlying `raw_value` function retrieves state values directly from the state view without generating or including any cryptographic proofs: [3](#0-2) 

Critically, on lines 548-568, the code calls `state_view.get_state_value(&state_key)` which only retrieves the value itself. The `TStateView` trait does not provide methods to obtain Merkle proofs: [4](#0-3) 

However, the underlying storage layer DOES provide methods to retrieve state values with proofs via `get_state_value_with_proof_by_version_ext`: [5](#0-4) 

The storage layer also defines `SparseMerkleProof` structures that can authenticate state values: [6](#0-5) 

**Attack Path:**
1. Attacker runs a full node with API enabled (requires no special privileges)
2. Attacker modifies their local database or API response handler to return fake state values
3. User/application queries the attacker's API endpoint for account resources, modules, or table items
4. Attacker's node returns fabricated data with valid response headers (ledger version, chain ID, etc.)
5. User has no cryptographic proof to verify the returned data is authentic
6. User makes decisions or transactions based on fake state (e.g., fake account balance, fake smart contract state)

This breaks the critical invariant #4: **"State Consistency: State transitions must be atomic and verifiable via Merkle proofs"**

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: Blockchain systems must provide cryptographic verifiability. The absence of Merkle proofs in API responses violates this fundamental security property.

2. **Widespread User Impact**: Any application or user relying on the public API cannot verify data authenticity. This affects:
   - Light clients attempting to query state trustlessly
   - DApps making decisions based on state queries
   - Wallets displaying account balances
   - Block explorers showing state information

3. **Financial Harm Potential**: Users could:
   - Receive fake account balances and make financial decisions based on incorrect data
   - Query fake smart contract state leading to loss of funds
   - Be shown fake module bytecode that differs from the canonical chain

4. **No Mitigation Available**: Users have no way to detect or prevent this attack when using the public API, as the response format doesn't support proof verification.

The vulnerability enables data manipulation attacks against any user querying the API, satisfying the "Significant protocol violations" criterion for High severity.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is straightforward to execute:
- **Low Technical Barrier**: Attacker only needs to run a full node and modify API responses
- **No Special Access Required**: Does not require validator privileges or consensus participation
- **Existing Infrastructure**: Many users rely on third-party API nodes they do not control
- **Difficult to Detect**: Without proofs, users cannot distinguish legitimate from malicious responses

Real-world scenarios where this occurs:
- Compromised public API infrastructure
- Malicious node operators targeting specific users
- Man-in-the-middle attacks on API traffic (when combined with other vulnerabilities)
- Adversarial nodes in decentralized API networks

The attack is highly feasible for any motivated attacker targeting users of public API endpoints.

## Recommendation

**Modify the API response structure to include Merkle proofs for all state queries:**

1. **Update Response Types**: Create new response types that include both the state value and its Merkle proof:
   - For single state values: Include `SparseMerkleProofExt`
   - For state chunks: Include `SparseMerkleRangeProof`

2. **Modify API Implementation**: Update the `raw_value` function to call `get_state_value_with_proof_by_version_ext` instead of `get_state_value`:

```rust
// In api/src/state.rs, modify the raw_value function:
pub fn raw_value(
    &self,
    accept_type: &AcceptType,
    request: RawStateValueRequest,
    ledger_version: Option<U64>,
) -> BasicResultWith404<StateValueWithProof> {  // New response type
    let (ledger_info, ledger_version, state_view) = self
        .context
        .state_view(ledger_version.map(|inner| inner.0))?;

    let state_key = bcs::from_bytes(&request.key.0)
        .context("Failed deserializing state key")
        .map_err(|err| { /* ... */ })?;
    
    // Use proof-enabled method instead
    let key_hash = state_key.hash();
    let (state_value_opt, proof) = self.context.db
        .get_state_value_with_proof_by_version_ext(
            &key_hash,
            ledger_version,
            0, // root_depth
            false // use_hot_state
        )
        .context("Failed fetching state value with proof")
        .map_err(|err| { /* ... */ })?;
    
    // Return both value and proof
    let response = StateValueWithProof {
        state_value: state_value_opt,
        proof,
    };
    
    // Serialize and return
    BasicResponse::try_from_encoded((
        bcs::to_bytes(&response)?,
        &ledger_info,
        BasicResponseStatus::Ok
    ))
}
```

3. **Client-Side Verification**: Provide SDK functions that automatically verify proofs against known ledger state roots.

4. **Backward Compatibility**: Consider versioning the API or providing both verified and unverified endpoints during transition.

## Proof of Concept

**Scenario**: Attacker runs malicious API node that returns fake account balance

```rust
// Attacker's modified API node (pseudo-code)
// In their forked api/src/state.rs:

pub fn raw_value(
    &self,
    accept_type: &AcceptType,
    request: RawStateValueRequest,
    ledger_version: Option<U64>,
) -> BasicResultWith404<MoveValue> {
    // Attacker checks if query is for specific account resource
    let state_key: StateKey = bcs::from_bytes(&request.key.0)?;
    
    if is_target_account(&state_key) {
        // Return FAKE state value with 1000x the real balance
        let fake_value = create_fake_account_resource(
            original_balance * 1000
        );
        let fake_bytes = bcs::to_bytes(&fake_value)?;
        
        // Return fake data with legitimate-looking headers
        return BasicResponse::try_from_encoded((
            fake_bytes,
            &ledger_info,  // Real ledger info from actual chain
            BasicResponseStatus::Ok
        ));
    }
    
    // For other queries, return real data to avoid detection
    // ... normal implementation ...
}

// Victim client code:
let api_url = "https://malicious-node.example.com";
let account_balance = query_account_balance(api_url, victim_address);
// Receives fake balance, has no way to verify
// Makes financial decision based on incorrect data
```

**Demonstration Steps:**
1. Run modified Aptos node with altered API response handler
2. Client queries account resource via API
3. Compare returned value with blockchain explorer using different node
4. Observe discrepancy with no way for client to detect it cryptographically
5. Client cannot verify which response is correct without querying multiple nodes and trusting majority

**Notes**

This vulnerability affects ALL state query endpoints in the API:
- `get_account_resource` [7](#0-6) 
- `get_account_module` [8](#0-7) 
- `get_table_item` [9](#0-8) 
- `get_raw_table_item` [10](#0-9) 

All these endpoints retrieve state without proofs, making them vulnerable to the same attack vector. The issue is systemic across the entire state query API surface.

The storage layer already implements proof generation via Jellyfish Merkle Trees, so adding proof support requires plumbing these existing capabilities through to the API layer rather than implementing new cryptographic functionality.

### Citations

**File:** api/types/src/state.rs (L10-12)
```rust
pub struct RawStateValueRequest {
    pub key: HexEncodedBytes,
}
```

**File:** api/src/state.rs (L51-84)
```rust
    async fn get_account_resource(
        &self,
        accept_type: AcceptType,
        /// Address of account with or without a `0x` prefix
        address: Path<Address>,
        /// Name of struct to retrieve e.g. `0x1::account::Account`
        resource_type: Path<MoveStructTag>,
        /// Ledger version to get state of account
        ///
        /// If not provided, it will be the latest version
        ledger_version: Query<Option<U64>>,
    ) -> BasicResultWith404<MoveResource> {
        resource_type
            .0
            .verify(0)
            .context("'resource_type' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        fail_point_poem("endpoint_get_account_resource")?;
        self.context
            .check_api_output_enabled("Get account resource", &accept_type)?;

        let api = self.clone();
        api_spawn_blocking(move || {
            api.resource(
                &accept_type,
                address.0,
                resource_type.0,
                ledger_version.0.map(|inner| inner.0),
            )
        })
        .await
    }
```

**File:** api/src/state.rs (L99-124)
```rust
    async fn get_account_module(
        &self,
        accept_type: AcceptType,
        /// Address of account with or without a `0x` prefix
        address: Path<Address>,
        /// Name of module to retrieve e.g. `coin`
        module_name: Path<IdentifierWrapper>,
        /// Ledger version to get state of account
        ///
        /// If not provided, it will be the latest version
        ledger_version: Query<Option<U64>>,
    ) -> BasicResultWith404<MoveModuleBytecode> {
        verify_module_identifier(module_name.0.as_str())
            .context("'module_name' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        fail_point_poem("endpoint_get_account_module")?;
        self.context
            .check_api_output_enabled("Get account module", &accept_type)?;
        let api = self.clone();
        api_spawn_blocking(move || {
            api.module(&accept_type, address.0, module_name.0, ledger_version.0)
        })
        .await
    }
```

**File:** api/src/state.rs (L144-176)
```rust
    async fn get_table_item(
        &self,
        accept_type: AcceptType,
        /// Table handle hex encoded 32-byte string
        table_handle: Path<Address>,
        /// Table request detailing the key type, key, and value type
        table_item_request: Json<TableItemRequest>,
        /// Ledger version to get state of account
        ///
        /// If not provided, it will be the latest version
        ledger_version: Query<Option<U64>>,
    ) -> BasicResultWith404<MoveValue> {
        table_item_request
            .0
            .verify()
            .context("'table_item_request' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        fail_point_poem("endpoint_get_table_item")?;
        self.context
            .check_api_output_enabled("Get table item", &accept_type)?;
        let api = self.clone();
        api_spawn_blocking(move || {
            api.table_item(
                &accept_type,
                table_handle.0,
                table_item_request.0,
                ledger_version.0,
            )
        })
        .await
    }
```

**File:** api/src/state.rs (L194-227)
```rust
    async fn get_raw_table_item(
        &self,
        accept_type: AcceptType,
        /// Table handle hex encoded 32-byte string
        table_handle: Path<Address>,
        /// Table request detailing the key type, key, and value type
        table_item_request: Json<RawTableItemRequest>,
        /// Ledger version to get state of account
        ///
        /// If not provided, it will be the latest version
        ledger_version: Query<Option<U64>>,
    ) -> BasicResultWith404<MoveValue> {
        fail_point_poem("endpoint_get_table_item")?;

        if AcceptType::Json == accept_type {
            return Err(api_forbidden(
                "Get raw table item",
                "Only BCS is supported as an AcceptType.",
            ));
        }
        self.context
            .check_api_output_enabled("Get raw table item", &accept_type)?;

        let api = self.clone();
        api_spawn_blocking(move || {
            api.raw_table_item(
                &accept_type,
                table_handle.0,
                table_item_request.0,
                ledger_version.0,
            )
        })
        .await
    }
```

**File:** api/src/state.rs (L243-266)
```rust
    async fn get_raw_state_value(
        &self,
        accept_type: AcceptType,
        /// Request that carries the state key.
        request: Json<RawStateValueRequest>,
        /// Ledger version at which the value is got.
        ///
        /// If not provided, it will be the latest version
        ledger_version: Query<Option<U64>>,
    ) -> BasicResultWith404<MoveValue> {
        fail_point_poem("endpoint_get_raw_state_value")?;

        if AcceptType::Json == accept_type {
            return Err(api_forbidden(
                "Get raw state value",
                "Only BCS is supported as an AcceptType.",
            ));
        }
        self.context
            .check_api_output_enabled("Get raw state value", &accept_type)?;

        let api = self.clone();
        api_spawn_blocking(move || api.raw_value(&accept_type, request.0, ledger_version.0)).await
    }
```

**File:** api/src/state.rs (L525-591)
```rust
    pub fn raw_value(
        &self,
        accept_type: &AcceptType,
        request: RawStateValueRequest,
        ledger_version: Option<U64>,
    ) -> BasicResultWith404<MoveValue> {
        // Retrieve local state
        let (ledger_info, ledger_version, state_view) = self
            .context
            .state_view(ledger_version.map(|inner| inner.0))?;

        let state_key = bcs::from_bytes(&request.key.0)
            .context(format!(
                "Failed deserializing state value. key: {}",
                request.key
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?;
        let state_value = state_view
            .get_state_value(&state_key)
            .context(format!("Failed fetching state value. key: {}", request.key,))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
            .ok_or_else(|| {
                build_not_found(
                    "Raw State Value",
                    format!(
                        "StateKey({}) and Ledger version({})",
                        request.key, ledger_version
                    ),
                    AptosErrorCode::StateValueNotFound,
                    &ledger_info,
                )
            })?;
        let bytes = bcs::to_bytes(&state_value)
            .context(format!(
                "Failed serializing state value. key: {}",
                request.key
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?;

        match accept_type {
            AcceptType::Json => Err(api_forbidden(
                "Get raw state value",
                "This serves only bytes. Use other APIs for Json.",
            )),
            AcceptType::Bcs => {
                BasicResponse::try_from_encoded((bytes, &ledger_info, BasicResponseStatus::Ok))
            },
        }
    }
```

**File:** types/src/state_store/mod.rs (L64-75)
```rust
    /// Gets the state value for a given state key.
    fn get_state_value(&self, state_key: &Self::Key) -> StateViewResult<Option<StateValue>> {
        // if not implemented, delegate to get_state_slot.
        self.get_state_slot(state_key)
            .map(StateSlot::into_state_value_opt)
    }

    /// Gets the state value bytes for a given state key.
    fn get_state_value_bytes(&self, state_key: &Self::Key) -> StateViewResult<Option<Bytes>> {
        let val_opt = self.get_state_value(state_key)?;
        Ok(val_opt.map(|val| val.bytes().clone()))
    }
```

**File:** storage/storage-interface/src/lib.rs (L404-410)
```rust
        fn get_state_value_with_proof_by_version_ext(
            &self,
            key_hash: &HashValue,
            version: Version,
            root_depth: usize,
            use_hot_state: bool,
        ) -> Result<(Option<StateValue>, SparseMerkleProofExt)>;
```

**File:** types/src/proof/definition.rs (L133-150)
```rust
/// A proof that can be used to authenticate an element in a Sparse Merkle Tree given trusted root
/// hash. For example, `TransactionInfoToAccountProof` can be constructed on top of this structure.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct SparseMerkleProof {
    /// This proof can be used to authenticate whether a given leaf exists in the tree or not.
    ///     - If this is `Some(leaf_node)`
    ///         - If `leaf_node.key` equals requested key, this is an inclusion proof and
    ///           `leaf_node.value_hash` equals the hash of the corresponding account blob.
    ///         - Otherwise this is a non-inclusion proof. `leaf_node.key` is the only key
    ///           that exists in the subtree and `leaf_node.value_hash` equals the hash of the
    ///           corresponding account blob.
    ///     - If this is `None`, this is also a non-inclusion proof which indicates the subtree is
    ///       empty.
    leaf: Option<SparseMerkleLeafNode>,

    /// All siblings in this proof, including the default ones. Siblings are ordered from the root
    /// level to the bottom level.
    siblings: Vec<HashValue>,
```
