# Audit Report

## Title
Permanent Account Lockout When OIDC Provider Shuts Down Without Proactive Backup Key Addition

## Summary
Keyless accounts tied to an OIDC provider (issuer) become permanently inaccessible if the provider shuts down before users add backup keys, resulting in irreversible fund loss with no recovery mechanism.

## Finding Description

The keyless authentication system requires users to obtain fresh JWTs from their OIDC provider for each transaction. The authentication flow has an unbreakable dependency chain: [1](#0-0) 

Each transaction requires:
1. A new ephemeral keypair with limited expiration
2. A fresh JWT from the OIDC provider containing a nonce that commits to the ephemeral public key
3. On-chain JWK validation using the provider's public keys

The validation process fetches JWKs from on-chain storage: [2](#0-1) 

**Critical Weakness**: When an OIDC provider permanently shuts down:
- Users cannot obtain new JWTs (OAuth servers are offline)
- Even with JWKs stored on-chain, JWT acquisition is impossible
- Ephemeral keys expire after `max_exp_horizon_secs` (~115 days maximum)
- Without new JWTs, users cannot create new transactions [3](#0-2) 

The backup key mechanism exists but requires authentication: [4](#0-3) 

**The Circular Dependency**: To add a backup key, users must:
1. Submit an authenticated transaction (requires `account: &signer`)
2. Authentication requires a valid keyless signature
3. Keyless signatures require fresh JWTs from the provider
4. **If the provider is down, step 3 is impossible → account is permanently locked**

The override AUD recovery mechanism only addresses dapp/wallet shutdowns, not OIDC provider failures: [5](#0-4) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criteria:

**Permanent Freezing of Funds**: All assets in keyless accounts tied to defunct OIDC providers are irreversibly locked. While the bounty program lists "permanent freezing requiring hardfork" as Critical, this case is slightly different—no hardfork can recover these accounts because the authentication dependency is by design.

**Affected Users**: 
- Anyone using smaller OIDC providers (higher shutdown risk)
- Users who haven't proactively added backup keys
- Enterprise deployments using custom identity providers

**No Recovery Path**: Unlike other account types:
- No governance intervention possible
- No emergency authentication bypass
- No time-based recovery mechanism
- Manual JWK management doesn't help (users still need JWTs)

## Likelihood Explanation

**Moderate to High Likelihood**:

1. **OIDC Provider Shutdowns Are Real**: History shows services like MySpace, Yahoo, and numerous smaller OAuth providers have shut down or deprecated services
2. **User Behavior**: Users typically don't proactively set up backup mechanisms unless forced
3. **No Guardrails**: The system doesn't:
   - Force backup key creation during account setup
   - Warn users about provider dependency risks
   - Monitor provider health or alert users
4. **One-Way Door**: Once locked out, the situation is irreversible

## Recommendation

Implement multiple protective layers:

### 1. Mandatory Backup Key During Account Creation
Modify account creation flow to require backup key setup, or implement a grace period with prominent warnings.

### 2. Provider Health Monitoring
Add on-chain or off-chain monitoring to detect provider issues and notify affected users before complete shutdown.

### 3. Extended Grace Period
Allow a special "recovery mode" where governance can temporarily extend ephemeral key expiration for affected issuers during provider sunset events.

### 4. Multi-Provider Binding
Allow accounts to bind to multiple OIDC providers, so failure of one doesn't lock the account.

### Example Fix (Concept):
```move
// Add to account creation flow
public entry fun create_keyless_account_with_backup(
    user: &signer,
    keyless_pk: vector<u8>,
    backup_pk: vector<u8>,
    backup_proof: vector<u8>
) {
    // Create account with keyless auth
    // Immediately add backup key
    upsert_ed25519_backup_key_on_keyless_account(
        user, keyless_pk, backup_pk, backup_proof
    );
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a traditional PoC because it requires an actual OIDC provider shutdown. However, the logical proof follows:

**Scenario**:
1. User creates keyless account with issuer `https://example-oauth.com`
2. User does NOT call `upsert_ed25519_backup_key_on_keyless_account`
3. `example-oauth.com` shuts down permanently
4. User's last ephemeral key expires (after max 115 days)
5. User attempts to transact:
   - Needs fresh JWT from `example-oauth.com` → **FAILS (provider offline)**
   - Cannot add backup key → **FAILS (requires authentication)**
   - Cannot recover via governance → **NO MECHANISM EXISTS**
   - **Result**: Account permanently locked, funds irretrievable

**Evidence of Design Gap**: [6](#0-5) 

The AIP-61 design does not address provider sunset scenarios beyond the override AUD mechanism, which assumes the underlying OIDC provider remains operational.

---

**Notes**:
- This represents a **protocol design limitation** that can lead to permanent fund loss
- While a mitigation exists (backup keys), it's not enforced and requires proactive user action
- The circular dependency (need authentication to add backup, need provider to authenticate) creates an unbreakable lock-out scenario
- This should be addressed through improved UX, forced backup mechanisms, or protocol-level recovery procedures

### Citations

**File:** types/src/keyless/mod.rs (L126-160)
```rust
/// A signature from the OIDC provider over the user ID, the application ID and the EPK, which serves
/// as a "certificate" binding the EPK to the keyless account associated with that user and application.
///
/// This is a \[ZKPoK of an\] OpenID signature over a JWT containing several relevant fields
/// (e.g., `aud`, `sub`, `iss`, `nonce`) where `nonce` is a commitment to the `ephemeral_pubkey` and
/// the expiration time
/// `exp_timestamp_secs`.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, Serialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub enum EphemeralCertificate {
    ZeroKnowledgeSig(ZeroKnowledgeSig),
    OpenIdSig(OpenIdSig),
}

/// NOTE: See `KeylessPublicKey` comments for why this cannot be named `Signature`.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, Serialize)]
pub struct KeylessSignature {
    pub cert: EphemeralCertificate,

    /// The decoded/plaintext JWT header (i.e., *not* base64url-encoded), with two relevant fields:
    ///  1. `kid`, which indicates which of the OIDC provider's JWKs should be used to verify the
    ///     \[ZKPoK of an\] OpenID signature.,
    ///  2. `alg`, which indicates which type of signature scheme was used to sign the JWT
    pub jwt_header_json: String,

    /// The expiry time of the `ephemeral_pubkey` represented as a UNIX epoch timestamp in seconds.
    pub exp_date_secs: u64,

    /// A short lived public key used to verify the `ephemeral_signature`.
    pub ephemeral_pubkey: EphemeralPublicKey,

    /// A signature over the transaction and, if present, the ZKP, under `ephemeral_pubkey`.
    /// The ZKP is included in this signature to prevent malleability attacks.
    pub ephemeral_signature: EphemeralSignature,
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-150)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;

    let jwk = JWK::try_from(jwk_move_struct)
        .map_err(|_| invalid_signature!("Could not unpack Any in JWK Move struct"))?;

    match &jwk {
        JWK::RSA(rsa_jwk) => {
            if rsa_jwk.alg != jwt_header.alg {
                return Err(invalid_signature!(format!(
                    "JWK alg ({}) does not match JWT header's alg ({})",
                    rsa_jwk.alg, jwt_header.alg
                )));
            }
        },
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
    }

    Ok(jwk)
}
```

**File:** types/src/keyless/configuration.rs (L62-73)
```rust
    pub fn new_for_devnet() -> Configuration {
        Configuration {
            override_aud_vals: vec![Self::OVERRIDE_AUD_FOR_TESTING.to_owned()],
            max_signatures_per_txn: 3,
            max_exp_horizon_secs: 10_000_000, // ~115.74 days
            training_wheels_pubkey: None,
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
            max_iss_val_bytes: circuit_constants::MAX_ISS_VAL_BYTES,
            max_extra_field_bytes: circuit_constants::MAX_EXTRA_FIELD_BYTES,
            max_jwt_header_b64_bytes: circuit_constants::MAX_JWT_HEADER_B64_BYTES,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L520-560)
```text
    entry fun upsert_ed25519_backup_key_on_keyless_account(account: &signer, keyless_public_key: vector<u8>, backup_public_key: vector<u8>, backup_key_proof: vector<u8>) acquires Account {
        // Check that the provided public key is a keyless public key
        let keyless_single_key = single_key::new_public_key_from_bytes(keyless_public_key);
        assert!(single_key::is_keyless_or_federated_keyless_public_key(&keyless_single_key), error::invalid_argument(ENOT_A_KEYLESS_PUBLIC_KEY));

        let addr = signer::address_of(account);
        let account_resource = &mut Account[addr];
        let old_auth_key = account_resource.authentication_key;

        // Check that the provided public key is original public key of the account by comparing
        // its authentication key to the account address.
        assert!(
            bcs::to_bytes(&addr) == keyless_single_key.to_authentication_key(),
            error::invalid_argument(ENOT_THE_ORIGINAL_PUBLIC_KEY)
        );

        let curr_auth_key_as_address = from_bcs::to_address(old_auth_key);
        let challenge = RotationProofChallenge {
            sequence_number: account_resource.sequence_number,
            originator: addr,
            current_auth_key: curr_auth_key_as_address,
            new_public_key: backup_public_key,
        };

        // Assert the challenges signed by the provided backup key is valid
        assert_valid_rotation_proof_signature_and_get_auth_key(
            ED25519_SCHEME,
            backup_public_key,
            backup_key_proof,
            &challenge
        );

        // Get the backup key as a single key
        let backup_key_ed25519 = ed25519::new_unvalidated_public_key_from_bytes(backup_public_key);
        let backup_key_as_single_key = single_key::from_ed25519_public_key_unvalidated(backup_key_ed25519);

        let new_public_key = multi_key::new_multi_key_from_single_keys(vector[keyless_single_key, backup_key_as_single_key], 1);
        let new_auth_key = new_public_key.to_authentication_key();

        // Rotate the authentication key to the new multi key public key
        rotate_authentication_key_call(account, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L1-2)
```text
/// This module is responsible for configuring keyless blockchain accounts which were introduced in
/// [AIP-61](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md).
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L48-57)
```text
    struct Configuration has key, store, drop, copy {
        /// An override `aud` for the identity of a recovery service, which will help users recover their keyless accounts
        /// associated with dapps or wallets that have disappeared.
        /// IMPORTANT: This recovery service **cannot**, on its own, take over user accounts: a user must first sign in
        /// via OAuth in the recovery service in order to allow it to rotate any of that user's keyless accounts.
        ///
        /// Furthermore, the ZKP eventually expires, so there is a limited window within which a malicious recovery
        /// service could rotate accounts. In the future, we can make this window arbitrarily small by further lowering
        /// the maximum expiration horizon for ZKPs used for recovery, instead of relying on the `max_exp_horizon_secs`
        /// value in this resource.
```
