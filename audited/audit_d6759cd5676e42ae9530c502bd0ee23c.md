# Audit Report

## Title
Unstable Bytecode Deployment Bypass via Missing CompilationMetadata on Mainnet

## Summary
The `reject_unstable_bytecode` enforcement mechanism can be completely bypassed by omitting CompilationMetadata from compiled module bytecode. An attacker can compile Move code using unstable language versions (V2_4, V2_5) that enable experimental features, strip the CompilationMetadata, and deploy to mainnet, violating the explicit policy that unstable code "should not be allowed on production networks."

## Finding Description
The Aptos blockchain has a critical safety mechanism to prevent deployment of code compiled with unstable compiler or language versions on mainnet. This is enforced through:

1. **Compilation Metadata Embedding**: The compiler embeds `CompilationMetadata` containing `compiler_version`, `language_version`, and an `unstable` flag set to true if either version is unstable. [1](#0-0) 

2. **Mainnet Rejection Logic**: The `reject_unstable_bytecode` function checks this metadata and rejects modules marked as unstable on mainnet. [2](#0-1) 

**The Critical Flaw**: The rejection logic uses `if let Some(metadata) = get_compilation_metadata(module)` which means if NO metadata exists, the entire check is silently skipped. The function only validates metadata that is present. [3](#0-2) 

3. **Missing Metadata Not Enforced**: The metadata validation function `check_metadata_format` only validates metadata keys that exist - it does NOT require CompilationMetadata to be present. [4](#0-3) 

4. **Unstable Versions**: Language versions V2_4 and V2_5 are explicitly marked as unstable and enable experimental features like public struct visibility. [5](#0-4) 

**Attack Path**:
1. Attacker compiles Move module using `set_language_version(LanguageVersion::V2_4)` or V2_5 off-chain [6](#0-5) 

2. Compilation generates bytecode with VERSION_10 (enabled on mainnet) and includes CompilationMetadata with `unstable: true` [7](#0-6) 

3. Attacker deserializes the CompiledModule, removes the CompilationMetadata entry from the `metadata` vector, and re-serializes

4. Attacker submits module publication transaction to mainnet

5. During validation, `validate_publish_request` calls `reject_unstable_bytecode` [8](#0-7) 

6. Since `get_compilation_metadata` returns `None`, the unstable check is bypassed completely [9](#0-8) 

7. Module with unstable language features is successfully published to mainnet

## Impact Explanation
**Severity: HIGH**

This vulnerability breaks the critical invariant that "An unstable version should not be allowed on production networks" and bypasses the `_REJECT_UNSTABLE_BYTECODE` feature flag (flag 58) which is explicitly marked as "Enabled on mainnet, can never be disabled." [10](#0-9) [11](#0-10) 

**Impact Categories**:
- **Significant Protocol Violation**: Circumvents a mandatory mainnet safety mechanism
- **Deployment of Untested Code**: Unstable features are experimental and may contain security vulnerabilities
- **Deterministic Execution Risk**: Different language versions could theoretically produce non-deterministic behavior
- **Potential for Future Exploits**: As unstable features are not production-ready, undiscovered bugs could be exploited

This qualifies as **High Severity** per Aptos bug bounty criteria: "Significant protocol violations."

## Likelihood Explanation
**Likelihood: HIGH**

- **Trivial to Execute**: Requires only basic bytecode manipulation (deserialize, modify metadata vector, re-serialize)
- **No Special Privileges**: Any external user can submit module publication transactions
- **Clear Attack Path**: Well-defined steps from compilation to deployment
- **No Detection**: The bypass is completely silent - no errors or warnings are generated
- **Widely Applicable**: Works for any unstable compiler or language version

The only requirement is off-chain access to the Move compiler (publicly available) and basic understanding of bytecode structure.

## Recommendation
**Immediate Fix**: Require CompilationMetadata to be present for all modules published to mainnet, or treat missing metadata as unstable by default.

**Proposed Code Fix** for `reject_unstable_bytecode` in `aptos-move/aptos-vm/src/aptos_vm.rs`:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            // Get compilation metadata - treat missing as unstable
            let metadata = get_compilation_metadata(module);
            
            // REQUIRED: All mainnet modules must have compilation metadata
            if metadata.is_none() {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "modules without compilation metadata are not allowed on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
            
            // Check if metadata indicates unstable version
            if metadata.unwrap().unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

**Alternative Approach**: Modify `check_metadata_format` to require CompilationMetadata on mainnet environments.

## Proof of Concept

```rust
// PoC: Demonstrates bypassing unstable bytecode rejection by stripping metadata
// This would be executed as a Rust integration test

use move_binary_format::CompiledModule;
use move_model::metadata::{CompilationMetadata, CompilerVersion, LanguageVersion, COMPILATION_METADATA_KEY};
use move_core_types::metadata::Metadata;

fn create_unstable_module_without_metadata() -> Vec<u8> {
    // Step 1: Compile a module with unstable language version V2_4
    // (In practice, this uses move-compiler-v2 with set_language_version)
    let mut compiled_module = compile_with_unstable_version(); // hypothetical
    
    // Step 2: Verify CompilationMetadata exists with unstable=true
    let has_unstable_metadata = compiled_module.metadata.iter().any(|m| {
        m.key == *COMPILATION_METADATA_KEY && 
        bcs::from_bytes::<CompilationMetadata>(&m.value)
            .map(|cm| cm.unstable)
            .unwrap_or(false)
    });
    assert!(has_unstable_metadata, "Module should have unstable metadata");
    
    // Step 3: ATTACK - Strip the CompilationMetadata
    compiled_module.metadata.retain(|m| m.key != *COMPILATION_METADATA_KEY);
    
    // Step 4: Serialize modified bytecode
    let mut bytecode = vec![];
    compiled_module.serialize(&mut bytecode).unwrap();
    
    // Step 5: This bytecode will now bypass reject_unstable_bytecode on mainnet
    // because get_compilation_metadata returns None
    bytecode
}

// Expected behavior: Module publication succeeds on mainnet despite unstable features
// Actual (vulnerable) behavior: Succeeds
// Fixed behavior: Should fail with UNSTABLE_BYTECODE_REJECTED
```

**Notes:**
- The vulnerability is in the enforcement logic, not the `set_language_version` function itself
- The function is correctly used during compilation but cannot prevent post-compilation tampering
- This bypasses the explicit mainnet protection that was intentionally designed and deployed

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L64-71)
```rust
impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L317-326)
```rust
    pub fn infer_bytecode_version(&self, version: Option<u32>) -> u32 {
        env::get_bytecode_version_from_env(version).unwrap_or(match self {
            LanguageVersion::V1 => VERSION_DEFAULT,
            LanguageVersion::V2_0
            | LanguageVersion::V2_1
            | LanguageVersion::V2_2
            | LanguageVersion::V2_3 => VERSION_DEFAULT,
            LanguageVersion::V2_4 | LanguageVersion::V2_5 => VERSION_DEFAULT_LANG_V2_4,
        })
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1689-1689)
```rust
        self.reject_unstable_bytecode(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** third_party/move/move-compiler-v2/src/options.rs (L163-169)
```rust
    /// Sets the language version to use.
    pub fn set_language_version(self, version: LanguageVersion) -> Self {
        Self {
            language_version: Some(version),
            ..self
        }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L79-80)
```rust
    /// Enabled on mainnet, can never be disabled.
    _REJECT_UNSTABLE_BYTECODE = 58,
```

**File:** types/src/on_chain_config/aptos_features.rs (L229-229)
```rust
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE,
```
