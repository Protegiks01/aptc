# Audit Report

## Title
Cross-Network Pollution: Public Network Peers Treated as Validator Peers Due to Missing NetworkId Validation in ConnectivityManager

## Summary
The ConnectivityManager does not validate the NetworkId field in ConnectionNotification events, causing it to incorrectly track peers from other networks (e.g., public network) as if they belong to its own network (e.g., validator network). This violates the fundamental network isolation trust boundary in Aptos.

## Finding Description

Aptos nodes run multiple isolated networks (Validator, VFN, Public) that should operate independently with strict trust boundaries. The codebase uses a single global `PeersAndMetadata` instance shared across all networks, which broadcasts `ConnectionNotification` events to all subscribers regardless of network origin. [1](#0-0) 

Each `ConnectionNotification` includes a `NetworkId` field to identify which network the peer belongs to: [2](#0-1) 

When a peer connects to ANY network, the corresponding PeerManager sends a notification that is broadcast globally: [3](#0-2) 

The critical vulnerability exists in `ConnectivityManager::handle_control_notification()`, which receives these notifications but **completely ignores** the `NetworkId` parameter: [4](#0-3) 

Note the `_network_id` parameter is intentionally ignored (underscore prefix indicates unused variable). The ConnectivityManager adds ALL peers to its `connected` HashMap regardless of their actual network, treating public network peers as validator network peers.

In contrast, the HealthChecker correctly implements NetworkId filtering with an explicit comment acknowledging the global singleton pattern: [5](#0-4) 

**Attack Scenario:**
1. Validator node runs two networks: NetworkId::Validator (trusted) and NetworkId::Public (untrusted)
2. Attacker connects to the Public network as a malicious peer
3. Public PeerManager broadcasts `ConnectionNotification::NewPeer(attacker_metadata, NetworkId::Public)`
4. Validator network's ConnectivityManager receives notification and ignores the `NetworkId::Public` field
5. Attacker is added to validator ConnectivityManager's `connected` HashMap
6. Validator network now tracks an untrusted public peer as if it were a validator peer

## Impact Explanation

**HIGH Severity** - This vulnerability violates a fundamental security boundary. According to the Aptos network isolation design, validator networks must remain completely isolated from public networks to prevent untrusted peers from interfering with consensus operations. [6](#0-5) 

The vulnerability causes:
- **Trust Boundary Violation**: Untrusted public peers are tracked as validator peers
- **Connectivity Management Pollution**: Validator ConnectivityManager makes incorrect decisions based on mixed peer sets
- **Metrics Corruption**: Network metrics and peer counters reflect cross-network pollution
- **Potential Denial of Service**: Public peers could trigger unwanted dial attempts or connectivity checks in validator network

While this doesn't directly compromise consensus safety, it represents a **significant protocol violation** that undermines the network isolation architecture, qualifying as HIGH severity per the bug bounty criteria.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability triggers automatically on any multi-network node (validator + public, VFN + public, etc.) whenever a peer connects to any network. 

The vulnerability requires:
- No special privileges
- No malicious intent (happens with legitimate peers too)
- Standard node configuration with multiple networks

The code path is deterministic and affects all production validator nodes running both validator and public networks.

## Recommendation

Add NetworkId validation in `ConnectivityManager::handle_control_notification()` following the same pattern as HealthChecker:

```rust
fn handle_control_notification(&mut self, notif: peer_manager::ConnectionNotification) {
    trace!(
        NetworkSchema::new(&self.network_context),
        connection_notification = notif,
        "Connection notification"
    );
    match notif {
        peer_manager::ConnectionNotification::NewPeer(metadata, network_id) => {
            // Filter events to only process notifications for this network
            if network_id != self.network_context.network_id() {
                return;
            }
            
            let peer_id = metadata.remote_peer_id;
            counters::peer_connected(&self.network_context, &peer_id, 1);
            self.connected.insert(peer_id, metadata);
            self.dial_states.remove(&peer_id);
            self.dial_queue.remove(&peer_id);
        },
        peer_manager::ConnectionNotification::LostPeer(metadata, network_id) => {
            // Filter events to only process notifications for this network
            if network_id != self.network_context.network_id() {
                return;
            }
            
            let peer_id = metadata.remote_peer_id;
            if let Some(stored_metadata) = self.connected.get(&peer_id) {
                counters::peer_connected(&self.network_context, &peer_id, 0);
                // ... rest of logic
                self.connected.remove(&peer_id);
            }
        },
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_cross_network_pollution() {
    use aptos_config::network_id::NetworkId;
    use aptos_types::PeerId;
    
    // Create shared PeersAndMetadata for both networks
    let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Validator, NetworkId::Public]);
    
    // Setup validator network ConnectivityManager
    let validator_context = NetworkContext::new(RoleType::Validator, NetworkId::Validator, PeerId::random());
    let (validator_conn_tx, validator_conn_rx) = conn_notifs_channel::new();
    let mut validator_conn_mgr = ConnectivityManager::new(
        validator_context,
        TimeService::mock(),
        peers_and_metadata.clone(),
        PeerSet::new(),
        // ... other params
    );
    
    // Setup public network PeerManager simulation
    let public_peer_id = PeerId::random();
    let public_metadata = ConnectionMetadata::mock(public_peer_id);
    
    // Public network peer connects - notification includes NetworkId::Public
    let notif = ConnectionNotification::NewPeer(public_metadata.clone(), NetworkId::Public);
    
    // Send to validator ConnectivityManager
    validator_conn_mgr.handle_control_notification(notif);
    
    // VULNERABILITY: Validator ConnectivityManager now tracks public peer
    let connected_peers = validator_conn_mgr.get_connected_peers();
    assert!(connected_peers.contains_key(&public_peer_id), 
        "BUG: Public network peer is tracked as validator peer!");
}
```

## Notes

This vulnerability was confirmed by observing that HealthChecker explicitly implements the required filtering with a comment: "PeersAndMetadata is a global singleton across all networks; filter connect/disconnect events to the NetworkId that this HealthChecker instance is watching". The fact that HealthChecker developers recognized the need for filtering but ConnectivityManager was not updated indicates this is a legitimate oversight rather than intentional design.

### Citations

**File:** aptos-node/src/network.rs (L239-242)
```rust
pub fn create_peers_and_metadata(node_config: &NodeConfig) -> Arc<PeersAndMetadata> {
    let network_ids = extract_network_ids(node_config);
    PeersAndMetadata::new(&network_ids)
}
```

**File:** network/framework/src/peer_manager/types.rs (L38-44)
```rust
#[derive(Clone, PartialEq, Eq, Serialize)]
pub enum ConnectionNotification {
    /// Connection with a new peer has been established.
    NewPeer(ConnectionMetadata, NetworkId),
    /// Connection to a peer has been terminated. This could have been triggered from either end.
    LostPeer(ConnectionMetadata, NetworkId),
}
```

**File:** network/framework/src/application/storage.rs (L371-395)
```rust
    fn broadcast(&self, event: ConnectionNotification) {
        let mut listeners = self.subscribers.lock();
        let mut to_del = vec![];
        for i in 0..listeners.len() {
            let dest = listeners.get_mut(i).unwrap();
            if let Err(err) = dest.try_send(event.clone()) {
                match err {
                    TrySendError::Full(_) => {
                        // Tried to send to an app, but the app isn't handling its messages fast enough.
                        // Drop message. Maybe increment a metrics counter?
                        sample!(
                            SampleRate::Duration(Duration::from_secs(1)),
                            warn!("PeersAndMetadata.broadcast() failed, some app is slow"),
                        );
                    },
                    TrySendError::Closed(_) => {
                        to_del.push(i);
                    },
                }
            }
        }
        for evict in to_del.into_iter() {
            listeners.swap_remove(evict);
        }
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1004-1051)
```rust
    fn handle_control_notification(&mut self, notif: peer_manager::ConnectionNotification) {
        trace!(
            NetworkSchema::new(&self.network_context),
            connection_notification = notif,
            "Connection notification"
        );
        match notif {
            peer_manager::ConnectionNotification::NewPeer(metadata, _network_id) => {
                let peer_id = metadata.remote_peer_id;
                counters::peer_connected(&self.network_context, &peer_id, 1);
                self.connected.insert(peer_id, metadata);

                // Cancel possible queued dial to this peer.
                self.dial_states.remove(&peer_id);
                self.dial_queue.remove(&peer_id);
            },
            peer_manager::ConnectionNotification::LostPeer(metadata, _network_id) => {
                let peer_id = metadata.remote_peer_id;
                if let Some(stored_metadata) = self.connected.get(&peer_id) {
                    // Remove node from connected peers list.

                    counters::peer_connected(&self.network_context, &peer_id, 0);

                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&peer_id)
                            .connection_metadata(&metadata),
                        stored_metadata = stored_metadata,
                        "{} Removing peer '{}' metadata: {}, vs event metadata: {}",
                        self.network_context,
                        peer_id.short_str(),
                        stored_metadata,
                        metadata
                    );
                    self.connected.remove(&peer_id);
                } else {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&peer_id)
                            .connection_metadata(&metadata),
                        "{} Ignoring stale lost peer event for peer: {}, addr: {}",
                        self.network_context,
                        peer_id.short_str(),
                        metadata.addr
                    );
                }
            },
        }
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L210-227)
```rust
                    match conn_event {
                        ConnectionNotification::NewPeer(metadata, network_id) => {
                            // PeersAndMetadata is a global singleton across all networks; filter connect/disconnect events to the NetworkId that this HealthChecker instance is watching
                            if network_id == self_network_id {
                                self.network_interface.create_peer_and_health_data(
                                    metadata.remote_peer_id, self.round
                                );
                            }
                        }
                        ConnectionNotification::LostPeer(metadata, network_id) => {
                            // PeersAndMetadata is a global singleton across all networks; filter connect/disconnect events to the NetworkId that this HealthChecker instance is watching
                            if network_id == self_network_id {
                                self.network_interface.remove_peer_and_health_data(
                                    &metadata.remote_peer_id
                                );
                            }
                        }
                    }
```

**File:** config/src/network_id.rs (L72-76)
```rust
/// A representation of the network being used in communication.
/// There should only be one of each NetworkId used for a single node (except for NetworkId::Public),
/// and handshakes should verify that the NetworkId being used is the same during a handshake,
/// to effectively ensure communication is restricted to a network.  Network should be checked that
/// it is not the `DEFAULT_NETWORK`
```
