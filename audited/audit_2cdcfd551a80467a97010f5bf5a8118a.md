# Audit Report

## Title
Simulation Funding Bypasses Concurrent Fungible Balance, Causing State Divergence from Mainnet

## Summary
The `Fund::execute()` command in the simulation tool directly modifies `FungibleStore.balance` without checking or updating the `ConcurrentFungibleBalance` resource. When forking from mainnet where concurrent balance is enabled, this creates an inconsistent state that causes subsequent Move operations to execute different code paths than would occur on mainnet, leading to incorrect contract testing that misses real bugs.

## Finding Description
When developers use the `aptos move sim fund` command to fund accounts in a simulation forked from mainnet, the underlying `fund_apt_fungible_store()` function directly manipulates storage state in a way that diverges from how the Move framework properly handles APT balances: [1](#0-0) 

The issue occurs because:

1. **On mainnet with concurrent balance enabled**: When `DEFAULT_TO_CONCURRENT_FUNGIBLE_BALANCE` feature flag is active, proper account initialization creates both `FungibleStore` (with `balance=0`) and `ConcurrentFungibleBalance` (with the actual balance stored in an aggregator): [2](#0-1) 

2. **In simulation**: The `fund_apt_fungible_store()` function only modifies `FungibleStore.balance` and completely ignores `ConcurrentFungibleBalance`. It doesn't check whether concurrent balance is enabled or whether a `ConcurrentFungibleBalance` resource exists.

3. **State Divergence**: This creates an inconsistent state where:
   - **Mainnet**: `FungibleStore.balance = 0`, `ConcurrentFungibleBalance.balance = actual_amount`
   - **Simulation after funding**: `FungibleStore.balance = funded_amount`, `ConcurrentFungibleBalance.balance = old_amount` (if it exists)

4. **Different Execution Paths**: The Move framework's deposit/withdrawal logic checks `if store.balance == 0 && concurrent_fungible_balance_exists()` to decide which balance to use: [3](#0-2) [4](#0-3) 

After simulation funding, since `store.balance != 0`, all subsequent operations will use the regular balance path instead of the concurrent balance path, causing different behavior than would occur on mainnet.

5. **Balance Reading Divergence**: Balance queries also exhibit this divergence: [5](#0-4) 

When `store.balance != 0`, the query returns `store.balance` and completely ignores any existing `ConcurrentFungibleBalance`, even if it exists with a different value.

## Impact Explanation
**Medium Severity** - This causes state inconsistencies in the simulation environment that lead to incorrect contract testing:

- Developers testing contracts that interact with APT balances will observe different behavior in simulation versus mainnet
- Contracts that pass tests in simulation may fail on mainnet (false negatives)
- Contracts with bugs might appear to work in simulation but fail on mainnet (missed bugs)
- The divergence specifically affects logic involving concurrent operations, balance checks, and deposit/withdrawal flows

This meets the **Medium Severity** criteria of "State inconsistencies requiring intervention" because while it doesn't directly affect the production network, it systematically causes simulation state to diverge from mainnet state, undermining the reliability of contract testing.

## Likelihood Explanation
**High Likelihood** - This will occur whenever developers:
1. Fork a simulation session from mainnet using `aptos move sim init --network mainnet`
2. Use `aptos move sim fund` to fund test accounts
3. The mainnet version being forked has the `DEFAULT_TO_CONCURRENT_FUNGIBLE_BALANCE` feature flag enabled (which is likely on modern mainnet)

The CLI commands are documented and commonly used for testing, making this a frequent occurrence.

## Recommendation
The `fund_apt_fungible_store()` function must be updated to properly handle concurrent fungible balance:

```rust
fn fund_apt_fungible_store(&self, address: AccountAddress, amount: u64) -> Result<(u64, u64)> {
    let primary_store_object_address = primary_apt_store(address);
    
    let mut resource_group = self
        .get_resource_group::<ObjectGroupResource>(primary_store_object_address)?
        .unwrap_or_else(BTreeMap::new);
    
    // Check if ConcurrentFungibleBalance exists
    let has_concurrent_balance = resource_group
        .contains_key(&ConcurrentFungibleBalanceResource::struct_tag());
    
    let mut fungible_store = match resource_group.get(&FungibleStoreResource::struct_tag()) {
        Some(blob) => bcs::from_bytes(blob)?,
        None => FungibleStoreResource::new(AccountAddress::TEN, 0, false),
    };
    
    let before = if has_concurrent_balance && fungible_store.balance == 0 {
        // Read from concurrent balance
        let concurrent_blob = resource_group.get(&ConcurrentFungibleBalanceResource::struct_tag()).unwrap();
        let concurrent: ConcurrentFungibleBalanceResource = bcs::from_bytes(concurrent_blob)?;
        concurrent.balance()
    } else {
        fungible_store.balance
    };
    
    // Update the appropriate balance location
    if has_concurrent_balance && fungible_store.balance == 0 {
        // Update concurrent balance
        let concurrent_blob = resource_group.get(&ConcurrentFungibleBalanceResource::struct_tag()).unwrap();
        let mut concurrent: ConcurrentFungibleBalanceResource = bcs::from_bytes(concurrent_blob)?;
        concurrent.add(amount)?;
        resource_group.insert(
            ConcurrentFungibleBalanceResource::struct_tag(),
            bcs::to_bytes(&concurrent)?,
        );
    } else {
        // Update regular balance
        fungible_store.balance += amount;
        resource_group.insert(
            FungibleStoreResource::struct_tag(),
            bcs::to_bytes(&fungible_store)?,
        );
    }
    
    let after = before + amount;
    
    self.set_resource_group::<ObjectGroupResource>(
        primary_store_object_address,
        &resource_group,
    )?;
    
    Ok((before, after))
}
```

Alternatively, instead of bypassing the Move framework entirely, the simulation could execute proper Move transactions to fund accounts, ensuring consistency with mainnet behavior.

## Proof of Concept

**Reproduction Steps:**

1. Fork simulation from mainnet at a version with concurrent balance enabled:
```bash
aptos move sim init --path ./test-sim --network mainnet
```

2. Fund an account that already exists on mainnet:
```bash
aptos move sim fund --session ./test-sim --account 0x1 --amount 1000000000
```

3. Inspect the resulting state - `FungibleStore.balance` will be non-zero while `ConcurrentFungibleBalance` remains unchanged

4. Execute a contract that performs APT operations - observe different behavior than would occur on mainnet

**Expected behavior**: After funding, if mainnet uses concurrent balance, the simulation should also use concurrent balance with the updated amount.

**Actual behavior**: The simulation puts the balance in `FungibleStore.balance`, causing subsequent operations to use non-concurrent code paths.

## Notes
This vulnerability specifically affects the simulation/testing infrastructure rather than the production blockchain protocol itself. However, it systematically causes developers to test contracts against incorrect state representations, which can result in vulnerable contracts being deployed to mainnet. The simulation tool's purpose is to accurately represent mainnet behavior, and this divergence undermines that core functionality.

### Citations

**File:** aptos-move/aptos-transaction-simulation/src/state_store.rs (L292-330)
```rust
    fn fund_apt_fungible_store(&self, address: AccountAddress, amount: u64) -> Result<(u64, u64)> {
        let primary_store_object_address = primary_apt_store(address);

        let mut resource_group = self
            .get_resource_group::<ObjectGroupResource>(primary_store_object_address)?
            .unwrap_or_else(BTreeMap::new);

        resource_group
            .entry(ObjectCoreResource::struct_tag())
            .or_insert(bcs::to_bytes(&ObjectCoreResource::new(
                address,
                false,
                EventHandle::new(
                    aptos_types::event::EventKey::new(0, primary_store_object_address),
                    0,
                ),
            ))?);

        let mut fungible_store = match resource_group.get(&FungibleStoreResource::struct_tag()) {
            Some(blob) => bcs::from_bytes(blob)?,
            None => FungibleStoreResource::new(AccountAddress::TEN, 0, false),
        };

        let before = fungible_store.balance;
        fungible_store.balance += amount;
        let after = fungible_store.balance;

        resource_group.insert(
            FungibleStoreResource::struct_tag(),
            bcs::to_bytes(&fungible_store)?,
        );

        self.set_resource_group::<ObjectGroupResource>(
            primary_store_object_address,
            &resource_group,
        )?;

        Ok((before, after))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L691-704)
```text
    fun balance_impl<T: key>(store: Object<T>): u64 acquires FungibleStore, ConcurrentFungibleBalance {
        let store_addr = store.object_address();
        if (store_exists_inline(store_addr)) {
            let store_balance = borrow_store_resource(&store).balance;
            if (store_balance == 0
                && concurrent_fungible_balance_exists_inline(store_addr)) {
                let balance_resource =
                    borrow_global<ConcurrentFungibleBalance>(store_addr);
                balance_resource.balance.read()
            } else {
                store_balance
            }
        } else { 0 }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L881-903)
```text
        constructor_ref: &ConstructorRef, metadata: Object<T>
    ): Object<FungibleStore> {
        let store_obj = &constructor_ref.generate_signer();
        move_to(
            store_obj,
            FungibleStore { metadata: metadata.convert(), balance: 0, frozen: false }
        );

        if (is_untransferable(metadata)) {
            constructor_ref.set_untransferable();
        };

        if (default_to_concurrent_fungible_balance()) {
            move_to(
                store_obj,
                ConcurrentFungibleBalance {
                    balance: aggregator_v2::create_unbounded_aggregator()
                }
            );
        };

        constructor_ref.object_from_constructor_ref<FungibleStore>()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1244-1269)
```text
    inline fun unchecked_deposit_with_no_events_inline(
        store_addr: address, fa: FungibleAsset
    ): u64 {
        let FungibleAsset { metadata, amount } = fa;
        assert!(
            exists<FungibleStore>(store_addr),
            error::not_found(EFUNGIBLE_STORE_EXISTENCE)
        );
        let store = borrow_global_mut<FungibleStore>(store_addr);
        assert!(
            metadata == store.metadata,
            error::invalid_argument(EFUNGIBLE_ASSET_AND_STORE_MISMATCH)
        );

        if (amount != 0) {
            if (store.balance == 0
                && concurrent_fungible_balance_exists_inline(store_addr)) {
                let balance_resource =
                    borrow_global_mut<ConcurrentFungibleBalance>(store_addr);
                balance_resource.balance.add(amount);
            } else {
                store.balance += amount;
            };
        };
        amount
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1298-1326)
```text
    inline fun unchecked_withdraw_with_no_events(
        store_addr: address, amount: u64
    ): FungibleAsset {
        assert!(
            exists<FungibleStore>(store_addr),
            error::not_found(EFUNGIBLE_STORE_EXISTENCE)
        );

        let store = borrow_global_mut<FungibleStore>(store_addr);
        let metadata = store.metadata;
        if (amount != 0) {
            if (store.balance == 0
                && concurrent_fungible_balance_exists_inline(store_addr)) {
                let balance_resource =
                    borrow_global_mut<ConcurrentFungibleBalance>(store_addr);
                assert!(
                    balance_resource.balance.try_sub(amount),
                    error::invalid_argument(EINSUFFICIENT_BALANCE)
                );
            } else {
                assert!(
                    store.balance >= amount,
                    error::invalid_argument(EINSUFFICIENT_BALANCE)
                );
                store.balance -= amount;
            };
        };
        FungibleAsset { metadata, amount }
    }
```
