# Audit Report

## Title
Moderator Validation Bypass via Optimistic Fetch and Subscription Request Handling

## Summary
Optimistic fetch and subscription requests bypass the `RequestModerator::validate_request()` check entirely during initial acceptance, allowing malicious peers to flood storage servers with invalid requests without being tracked or banned by the moderator's invalid request counting mechanism. This creates a direct path for DoS attacks and resource exhaustion.

## Finding Description

The storage service implements a request moderation system to track peers sending invalid requests and ignore those exceeding `max_invalid_requests_per_peer`. However, optimistic fetch and subscription requests completely bypass this protection.

**Normal Request Flow (with moderator protection):** [1](#0-0) 

Regular requests call `process_request()` → `validate_and_handle_request()` → `request_moderator.validate_request()`: [2](#0-1) 

The moderator checks `can_service()` and increments invalid request counter when it fails: [3](#0-2) 

**Bypass #1: Optimistic Fetch Requests**

Optimistic fetch requests (e.g., `GetNewTransactionOutputsWithProof`) are detected early and routed to a separate handler: [4](#0-3) 

This handler stores the request WITHOUT calling the moderator: [5](#0-4) 

The `can_service()` function DOES validate optimistic fetch requests by checking ledger lag: [6](#0-5) 

But this check is never performed during initial acceptance. Later, when invalid requests are detected, they're simply removed and logged: [7](#0-6) 

The moderator's `increment_invalid_request_count()` is NEVER called.

**Bypass #2: Subscription Requests**

Subscription requests follow the same pattern, bypassing the moderator: [8](#0-7) 

When subscription validation fails (e.g., invalid stream metadata, too many active subscriptions), the error is handled without moderator tracking: [9](#0-8) 

Validation errors in `add_subscription_request()` return `Error::InvalidRequest`: [10](#0-9) 

But `handle_subscription_request_failure()` only logs and responds to the client - it never calls `increment_invalid_request_count()`.

**Attack Scenario:**

1. Attacker identifies storage servers by monitoring network
2. Sends flood of optimistic fetch requests when servers are lagging (would fail `can_service()` check)
3. Sends flood of subscription requests with invalid parameters (wrong stream IDs, excessive counts)
4. Requests are accepted and stored without moderator validation
5. Moderator's invalid request counter remains at 0
6. Peer is never marked as unhealthy or ignored
7. Attacker continues flooding indefinitely, causing resource exhaustion

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

- **Validator node slowdowns**: Storage servers must process and store invalid requests, consuming memory and CPU
- **Significant protocol violations**: The moderator's protection mechanism is completely bypassed, violating the design intent
- **Resource exhaustion**: Unbounded storage of invalid requests in `DashMap` structures can lead to memory exhaustion
- **DoS vector**: Public fullnodes are particularly vulnerable as they're specifically targeted by the moderator (only public peers get ignored)

While this doesn't directly cause consensus violations or fund loss, it enables attackers to degrade storage service availability, which can cascade into state sync failures and network partition risks.

## Likelihood Explanation

**Likelihood: High**

- **Attack complexity: Low** - Any peer can send these requests without special privileges
- **Detection difficulty: Medium** - Invalid requests are logged but not aggregated per-peer in metrics
- **Attacker requirements: Minimal** - Standard network connectivity, no validator access needed
- **Public exposure: High** - Storage service is exposed to all network peers including untrusted public fullnodes

The moderator was specifically designed to protect against this attack pattern (tracking invalid requests, ignoring misbehaving peers), but the implementation has gaps that completely negate this protection for two major request types.

## Recommendation

**Fix #1: Validate optimistic fetch requests on initial acceptance** [4](#0-3) 

Before storing optimistic fetch requests, call the moderator:

```rust
// Handle any optimistic fetch requests
if request.data_request.is_optimistic_fetch() {
    // Validate with moderator BEFORE storing
    if let Err(error) = self.request_moderator.validate_request(&peer_network_id, &request) {
        self.send_response(request, Err(error.into()), response_sender);
        return;
    }
    self.handle_optimistic_fetch_request(peer_network_id, request, response_sender);
    return;
}
```

**Fix #2: Track subscription validation failures** [9](#0-8) 

When subscription validation fails, increment the moderator's counter:

```rust
fn handle_subscription_request_failure(
    &self,
    peer_network_id: PeerNetworkId,
    request: StorageServiceRequest,
    error: Error,
    subscription_request: SubscriptionRequest,
) {
    // Log error...
    
    // Increment moderator's invalid request count
    if matches!(error, Error::InvalidRequest(_)) {
        let mut unhealthy_peer_state = self.request_moderator
            .get_unhealthy_peer_states()
            .entry(peer_network_id)
            .or_insert_with(|| { /* create new state */ });
        unhealthy_peer_state.increment_invalid_request_count(&peer_network_id);
    }
    
    // Update metrics and notify client...
}
```

**Fix #3: Add validation before storing subscriptions** [8](#0-7) 

Validate subscription requests with moderator before accepting:

```rust
// Handle any subscription requests
if request.data_request.is_subscription_request() {
    // Validate with moderator BEFORE processing
    if let Err(error) = self.request_moderator.validate_request(&peer_network_id, &request) {
        self.send_response(request, Err(error.into()), response_sender);
        return;
    }
    self.handle_subscription_request(
        storage_service_config,
        peer_network_id,
        request,
        response_sender,
    );
    return;
}
```

## Proof of Concept

```rust
// Proof of Concept: Bypassing moderator tracking
// This demonstrates how optimistic fetch requests bypass validation

#[tokio::test]
async fn test_optimistic_fetch_bypasses_moderator() {
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::*;
    use std::time::Duration;

    // Setup storage service with moderator
    let config = StorageServiceConfig {
        max_invalid_requests_per_peer: 5,  // Low threshold for testing
        max_optimistic_fetch_lag_secs: 1,  // Very strict lag requirement
        ..Default::default()
    };
    
    // Create a peer that will send invalid requests
    let malicious_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Simulate server with outdated ledger (lagging beyond max_optimistic_fetch_lag_secs)
    // Wait 2 seconds to ensure lag check will fail
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // Send 10 optimistic fetch requests (2x the max_invalid_requests threshold)
    for i in 0..10 {
        let request = StorageServiceRequest::new(
            DataRequest::GetNewTransactionOutputsWithProof(
                NewTransactionOutputsWithProofRequest {
                    known_version: i * 100,
                    known_epoch: 0,
                }
            ),
            false,
        );
        
        // These requests are accepted and stored WITHOUT moderator validation
        // handler.handle_optimistic_fetch_request() is called directly
        // moderator.validate_request() is NEVER called
        handler.process_request_and_respond(
            config.clone(),
            malicious_peer,
            protocol_id,
            request,
            response_sender.clone(),
        );
    }
    
    // Verify: moderator's invalid request count is still 0
    let unhealthy_states = moderator.get_unhealthy_peer_states();
    let peer_state = unhealthy_states.get(&malicious_peer);
    
    // BUG: Despite sending 10 requests that should fail can_service(),
    // the peer has NO invalid request count and is NOT ignored
    assert!(peer_state.is_none() || peer_state.unwrap().invalid_request_count == 0);
    assert!(peer_state.is_none() || !peer_state.unwrap().is_ignored());
    
    // Expected behavior: After 5 invalid requests, peer should be ignored
    // Actual behavior: Peer can send unlimited invalid requests
    println!("VULNERABILITY CONFIRMED: Moderator bypass allows unlimited invalid requests");
}
```

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L119-123)
```rust
        // Handle any optimistic fetch requests
        if request.data_request.is_optimistic_fetch() {
            self.handle_optimistic_fetch_request(peer_network_id, request, response_sender);
            return;
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L125-134)
```rust
        // Handle any subscription requests
        if request.data_request.is_subscription_request() {
            self.handle_subscription_request(
                storage_service_config,
                peer_network_id,
                request,
                response_sender,
            );
            return;
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L136-138)
```rust
        // Process the request and return the response to the client
        let response = self.process_request(&peer_network_id, request.clone(), false);
        self.send_response(request, response, response_sender);
```

**File:** state-sync/storage-service/server/src/handler.rs (L206-228)
```rust
    fn validate_and_handle_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<StorageServiceResponse, Error> {
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;

        // Process the request
        match &request.data_request {
            DataRequest::GetServerProtocolVersion => {
                let data_response = self.get_server_protocol_version();
                StorageServiceResponse::new(data_response, request.use_compression)
                    .map_err(|error| error.into())
            },
            DataRequest::GetStorageServerSummary => {
                let data_response = self.get_storage_server_summary();
                StorageServiceResponse::new(data_response, request.use_compression)
                    .map_err(|error| error.into())
            },
            _ => self.process_cachable_request(peer_network_id, request),
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L243-280)
```rust
    pub fn handle_optimistic_fetch_request(
        &self,
        peer_network_id: PeerNetworkId,
        request: StorageServiceRequest,
        response_sender: ResponseSender,
    ) {
        // Create the optimistic fetch request
        let optimistic_fetch = OptimisticFetchRequest::new(
            request.clone(),
            response_sender,
            self.time_service.clone(),
        );

        // Store the optimistic fetch and check if any existing fetches were found
        if self
            .optimistic_fetches
            .insert(peer_network_id, optimistic_fetch)
            .is_some()
        {
            sample!(
                SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
                trace!(LogSchema::new(LogEntry::OptimisticFetchRequest)
                    .error(&Error::InvalidRequest(
                        "An active optimistic fetch was already found for the peer!".into()
                    ))
                    .peer_network_id(&peer_network_id)
                    .request(&request)
                );
            );
        }

        // Update the optimistic fetch metrics
        increment_counter(
            &metrics::OPTIMISTIC_FETCH_EVENTS,
            peer_network_id.network_id(),
            OPTIMISTIC_FETCH_ADD.into(),
        );
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L354-380)
```rust
    fn handle_subscription_request_failure(
        &self,
        peer_network_id: PeerNetworkId,
        request: StorageServiceRequest,
        error: Error,
        subscription_request: SubscriptionRequest,
    ) {
        // Something went wrong when adding the request to the stream
        sample!(
            SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
            warn!(LogSchema::new(LogEntry::SubscriptionRequest)
                .error(&error)
                .peer_network_id(&peer_network_id)
                .request(&request)
            );
        );

        // Update the subscription metrics
        update_failed_subscription_metrics(peer_network_id);

        // Notify the client of the failure
        self.send_response(
            request,
            Err(StorageServiceError::InvalidRequest(error.to_string())),
            subscription_request.take_response_sender(),
        );
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L154-185)
```rust
            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }
```

**File:** state-sync/storage-service/types/src/responses.rs (L892-901)
```rust
/// Returns true iff an optimistic data request can be serviced
/// by the peer with the given synced ledger info.
fn can_service_optimistic_request(
    aptos_data_client_config: &AptosDataClientConfig,
    time_service: TimeService,
    synced_ledger_info: Option<&LedgerInfoWithSignatures>,
) -> bool {
    let max_lag_secs = aptos_data_client_config.max_optimistic_fetch_lag_secs;
    check_synced_ledger_lag(synced_ledger_info, time_service, max_lag_secs)
}
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L585-605)
```rust
/// Removes the invalid optimistic fetches from the active map
fn remove_invalid_optimistic_fetches(
    optimistic_fetches: Arc<DashMap<PeerNetworkId, OptimisticFetchRequest>>,
    peers_with_invalid_optimistic_fetches: Vec<PeerNetworkId>,
) {
    for peer_network_id in peers_with_invalid_optimistic_fetches {
        if let Some((peer_network_id, optimistic_fetch)) =
            optimistic_fetches.remove(&peer_network_id)
        {
            warn!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                .error(&Error::InvalidRequest(
                    "Mismatch between known version and epoch!".into()
                ))
                .request(&optimistic_fetch.request)
                .message(&format!(
                    "Dropping invalid optimistic fetch request for peer: {:?}!",
                    peer_network_id
                )));
        }
    }
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L341-381)
```rust
    pub fn add_subscription_request(
        &mut self,
        storage_service_config: StorageServiceConfig,
        subscription_request: SubscriptionRequest,
    ) -> Result<(), (Error, SubscriptionRequest)> {
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
        }

        // Verify that the subscription request index is valid
        let subscription_request_index = subscription_request.subscription_stream_index();
        if subscription_request_index < self.next_index_to_serve {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                    self.next_index_to_serve, subscription_request_index
                )),
                subscription_request,
            ));
        }

        // Verify that the number of active subscriptions respects the maximum
        let max_num_active_subscriptions =
            storage_service_config.max_num_active_subscriptions as usize;
        if self.pending_subscription_requests.len() >= max_num_active_subscriptions {
            return Err((
                Error::InvalidRequest(format!(
                    "The maximum number of active subscriptions has been reached! Max: {:?}, found: {:?}",
                    max_num_active_subscriptions, self.pending_subscription_requests.len()
                )),
                subscription_request,
            ));
        }
```
