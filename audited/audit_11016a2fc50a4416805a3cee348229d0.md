# Audit Report

## Title
Configuration Migration Vulnerability: Inspection Service Endpoints Exposed on Mainnet Validators

## Summary
The `ConfigSanitizer` for `InspectionServiceConfig` only validates `expose_configuration` for mainnet validators but fails to check `expose_identity_information`, `expose_peer_information`, and `expose_system_information`. These three endpoints default to `true` and can remain enabled during testnet-to-mainnet migration, exposing sensitive validator network topology, peer identities, and system information through the unauthenticated HTTP inspection service on port 9101.

## Finding Description
The vulnerability exists in the configuration validation logic for the inspection service. The `InspectionServiceConfig` struct defines four boolean flags controlling endpoint exposure: [1](#0-0) 

The default configuration enables three of these endpoints: [2](#0-1) 

However, the `ConfigSanitizer` implementation only validates `expose_configuration` for mainnet validators: [3](#0-2) 

This creates a security gap because:

1. **Testnet Configuration Migration**: The `ConfigOptimizer` automatically enables all inspection endpoints for non-mainnet nodes to aid debugging: [4](#0-3) 

2. **Default Values Persist**: When operators migrate from testnet to mainnet, if they reuse configuration files or don't explicitly disable these endpoints, the default `true` values persist because the sanitizer doesn't catch them.

3. **Unauthenticated Access**: The inspection service binds to `0.0.0.0:9101` by default with no authentication: [5](#0-4) 

**Information Exposed:**

- **`/identity_information`**: Exposes validator network peer ID and fullnode network peer IDs: [6](#0-5) 

- **`/peer_information`**: Exposes complete network topology, all connected peers, connection states, trusted validator set, internal client states, and state sync metadata (lines 40-106 of peer_information.rs).

- **`/system_information`**: Exposes system information and exact Aptos build version for targeted exploit development.

**Attack Scenario:**
1. Validator operator runs testnet validator (all endpoints auto-enabled by optimizer)
2. Operator upgrades to mainnet, reusing config file with `expose_identity_information: true` explicitly set
3. ConfigSanitizer passes validation (only checks `expose_configuration`)
4. Mainnet validator starts with inspection endpoints exposed
5. If port 9101 is accessible (misconfigured firewall, bare-metal deployment, or through HAProxy), attackers can:
   - Map the entire validator network topology
   - Identify specific validators for targeted DoS attacks
   - Fingerprint Aptos versions for exploit targeting
   - Track validator connection patterns and network changes

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: The validator network is designed as a permissioned, private network where validators only connect to known peers. Exposing the complete network topology and peer identities violates this security model.

2. **Enables Targeted Attacks**: Attackers can:
   - Identify and target specific validators with network-level attacks
   - Map consensus network topology to optimize disruption strategies
   - Correlate validators across network reconfigurations
   - Exploit version-specific vulnerabilities after fingerprinting

3. **Network Reconnaissance**: The `/peer_information` endpoint exposes comprehensive network state including connection metadata, trusted peers (entire validator set), and state sync status, enabling sophisticated reconnaissance.

4. **Validator Node Impact**: While this doesn't directly cause consensus violation or fund theft, it significantly degrades validator security posture and enables follow-on attacks that could impact validator operations or network liveness.

## Likelihood Explanation
**Likelihood: Medium-High**

1. **Migration Path is Common**: Testnet-to-mainnet migration is a standard operational procedure, and configuration reuse is common practice.

2. **Default Values are Insecure**: The default configuration has `expose_identity_information: true`, creating a "secure by explicit configuration" rather than "secure by default" approach.

3. **Example Configs Don't Address This**: Production configuration examples in the codebase don't explicitly set inspection service values: [7](#0-6) 

4. **Firewall Dependency**: While Kubernetes deployments have NetworkPolicy protection, bare-metal or misconfigured cloud deployments may expose port 9101 publicly.

5. **No Runtime Warning**: The node starts successfully without warnings about exposed inspection endpoints on mainnet.

## Recommendation
Extend the `ConfigSanitizer` to validate all inspection service endpoints for mainnet validators:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive endpoints
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // NEW: Check identity information exposure
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                
                // NEW: Check peer information exposure
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                
                // NEW: Check system information exposure
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, update the default values to be secure by default:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,  // Changed from true
            expose_peer_information: false,      // Changed from true
            expose_system_information: false,    // Changed from true
        }
    }
}
```

## Proof of Concept

**Setup:**
1. Start a mainnet validator with config containing `expose_identity_information: true`
2. Ensure port 9101 is accessible (for testing purposes)

**Exploitation:**
```bash
# Expose validator identity
curl http://validator-ip:9101/identity_information

# Sample output:
# Identity Information:
#   - Validator network (Validator), peer ID: 0x1234567890abcdef...
#   - Fullnode network (vfn), peer ID: 0xfedcba0987654321...

# Expose complete network topology
curl http://validator-ip:9101/peer_information

# Sample output includes:
# - Number of peers: 100
# - Registered networks: [Validator, vfn]
# - Connection metadata for each peer
# - Trusted peers (entire validator set with peer IDs)
# - Internal client states

# Version fingerprinting
curl http://validator-ip:9101/system_information

# Returns JSON with exact build version and system info
```

**Verification:**
An attacker can verify the vulnerability by scanning for exposed inspection services:
```bash
# Scan for exposed inspection services
nmap -p 9101 --script http-title validator-ip-range

# Test endpoints
for ip in $(cat validator-ips.txt); do
    echo "Testing $ip"
    curl -s http://$ip:9101/identity_information | grep "Validator network"
done
```

The vulnerability is confirmed if any mainnet validator returns identity information instead of the HTTP 403 FORBIDDEN response with message "This endpoint is disabled!".

## Notes
- While validator peer IDs are theoretically derivable from on-chain `validator_network_addresses` containing x25519 public keys, the inspection service provides real-time operational data that differs from on-chain configuration
- The `/peer_information` endpoint exposes significantly more data than just peer IDs, including complete network topology and connection states
- Kubernetes deployments with proper NetworkPolicy are partially protected, but bare-metal and misconfigured deployments remain vulnerable
- The vulnerability affects production deployments where operators migrate configurations from testnet without reviewing inspection service settings

### Citations

**File:** config/src/config/inspection_service_config.rs (L15-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L50-101)
```rust
pub fn start_inspection_service(
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();

    // Create a runtime for the inspection service
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

    // Spawn the inspection service
    thread::spawn(move || {
        // Create the service function that handles the endpoint requests
        let make_service = make_service_fn(move |_conn| {
            let node_config = node_config.clone();
            let aptos_data_client = aptos_data_client.clone();
            let peers_and_metadata = peers_and_metadata.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |request| {
                    serve_requests(
                        request,
                        node_config.clone(),
                        aptos_data_client.clone(),
                        peers_and_metadata.clone(),
                    )
                }))
            }
        });

        // Start and block on the server
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
    });
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-52)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}

/// Returns a simple text formatted string with identity information
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** config/src/config/test_data/validator.yaml (L1-81)
```yaml
base:
    data_dir: "/opt/aptos/data"
    role: "validator"
    waypoint:
        from_storage:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"

consensus:
    safety_rules:
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"

execution:
    genesis_file_location: "relative/path/to/genesis"

# For validator node we setup two networks, validator_network to allow validator connect to each other,
# and full_node_networks to allow fullnode connects to validator.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"

validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
    identity:
        type: "from_storage"
        key_name: "validator_network"
        peer_id_name: "owner_account"
        backend:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"
    network_id: "validator"
    ### Load keys from file
    # identity:
    #     type: "from_file"
    #     path: /full/path/to/private-keys.yml
    #
    ### Load keys from secure storage service like vault:
    #
    # identity:
    #     type: "from_storage"
    #     key_name: "validator_network"
    #     peer_id_name: "owner_account"
    #     backend:
    #         type: "vault"
    #         server: "https://127.0.0.1:8200"
    #         ca_certificate: "/full/path/to/certificate"
    #         token:
    #             from_disk: "/full/path/to/token"
    #
    ### Load keys directly from config
    #
    # identity:
    #     type: "from_config"
    #     key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    #     peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
    mutual_authentication: true
    max_frame_size: 4194304 # 4 MiB
api:
    enabled: true
```
