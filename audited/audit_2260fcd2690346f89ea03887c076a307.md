# Audit Report

## Title
Race Condition Between Pipeline Abortion and Executor Lifecycle Causing Potential Node Crashes and Silent Commit Failures

## Summary
The interface between `persisting_phase` and the executor is not properly synchronized when state sync occurs during active block commit operations. Spawned blocking tasks can execute after the executor is reset, leading to either node crashes (panic) or silent commit failures with state inconsistency.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Persisting Phase** [1](#0-0) 
   - Waits for commit completion but ignores the result at line 71
   - Always returns `Ok` regardless of actual commit status

2. **Pipeline Builder's commit_ledger** [2](#0-1) 
   - Uses `tokio::task::spawn_blocking` at line 1098 to call executor methods
   - These blocking tasks are NOT cancelled when the parent async task is aborted

3. **State Sync Executor Lifecycle** [3](#0-2) 
   - Calls `executor.finish()` which sets the executor's inner state to `None`

**The Race Condition:**

When state sync is triggered via `fast_forward_sync`, the following sequence occurs: [4](#0-3) 

The `abort_pipeline_for_state_sync()` aborts pipeline tasks: [5](#0-4) 

However, this only aborts the async tasks, not the `spawn_blocking` tasks they spawned. The executor is then finished: [6](#0-5) 

**Critical Race Window:**

If a `spawn_blocking` task from `commit_ledger` executes after `finish()` but before (or after) `reset()`: [7](#0-6) 

The `.expect("BlockExecutor is not reset")` at line 147 will **panic** if `inner` is `None`, crashing the validator node.

Alternatively, if the blocking task runs after `reset()`, it calls `commit_ledger` on a different `BlockExecutorInner` instance. The block won't be found in the new block tree: [8](#0-7) 

This returns `ExecutorError::BlockNotFound`, but the error is silently ignored by: [9](#0-8) 

## Impact Explanation

This breaks **Critical Invariant #4: State Consistency** - state transitions must be atomic and verifiable. The vulnerability can cause:

1. **Node Crashes (High Severity)**: If the blocking task executes while `inner` is `None`, the validator panics and crashes, causing validator node downtime per bug bounty criteria.

2. **Silent Commit Failures (Medium Severity)**: If the task executes on the wrong executor instance, the commit fails but the consensus layer believes it succeeded, causing state inconsistency requiring manual intervention.

Both scenarios violate the deterministic execution invariant where all validators should maintain identical state.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific timing:
- State sync must trigger while a `commit_ledger` blocking task is queued or executing
- The window between `executor.finish()` and `executor.reset()` is small
- More likely under high load when blocking thread pools are saturated

However, state sync is triggered automatically when nodes fall behind, making this a naturally occurring race condition rather than requiring attacker manipulation. While not easily exploitable deterministically, it **can occur during normal operation** under specific network conditions.

## Recommendation

**Fix 1: Track and cancel blocking tasks**
Store the `JoinHandle` from `spawn_blocking` and explicitly wait for it during pipeline abortion before calling `executor.finish()`.

**Fix 2: Validate commit completion**
Modify `persisting_phase` to check the result of `wait_for_commit_ledger()` and propagate errors rather than ignoring them.

**Fix 3: Add executor state validation**
Add a generation counter to `BlockExecutor` that increments on `reset()`, and have `commit_ledger` validate it hasn't changed during execution.

## Proof of Concept

```rust
// Reproduction scenario (conceptual - timing-dependent):
// 
// 1. Start consensus with active block pipeline
// 2. Trigger state sync while commit_ledger is executing
// 3. Observe either:
//    a) Node panic: "BlockExecutor is not reset"
//    b) Silent commit failure with state divergence
//
// To increase likelihood:
// - Run under high load to saturate blocking thread pool
// - Trigger frequent state syncs
// - Monitor for executor state mismatches
```

**Note**: This is difficult to reproduce deterministically due to the race condition nature, but the code paths clearly show the vulnerability exists.

---

## Notes

While this vulnerability has a clear technical path and breaks state consistency invariants, its exploitability is limited because triggering it requires specific timing during state sync operations that are not directly controllable by unprivileged attackers. However, it represents a **real reliability and correctness issue** that could manifest during normal validator operation, potentially causing node crashes or state divergence between validators.

### Citations

**File:** consensus/src/pipeline/persisting_phase.rs (L59-81)
```rust
    async fn process(&self, req: PersistingRequest) -> PersistingResponse {
        let PersistingRequest {
            blocks,
            commit_ledger_info,
        } = req;

        for b in &blocks {
            if let Some(tx) = b.pipeline_tx().lock().as_mut() {
                tx.commit_proof_tx
                    .take()
                    .map(|tx| tx.send(commit_ledger_info.clone()));
            }
            b.wait_for_commit_ledger().await;
        }

        let response = Ok(blocks.last().expect("Blocks can't be empty").round());
        if commit_ledger_info.ledger_info().ends_epoch() {
            self.commit_msg_tx
                .send_epoch_change(EpochChangeProof::new(vec![commit_ledger_info], false))
                .await;
        }
        response
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1079-1106)
```rust
    async fn commit_ledger(
        pre_commit_fut: TaskFuture<PreCommitResult>,
        commit_proof_fut: TaskFuture<LedgerInfoWithSignatures>,
        parent_block_commit_fut: TaskFuture<CommitLedgerResult>,
        executor: Arc<dyn BlockExecutorTrait>,
        block: Arc<Block>,
    ) -> TaskResult<CommitLedgerResult> {
        let mut tracker = Tracker::start_waiting("commit_ledger", &block);
        parent_block_commit_fut.await?;
        pre_commit_fut.await?;
        let ledger_info_with_sigs = commit_proof_fut.await?;

        // it's committed as prefix
        if ledger_info_with_sigs.commit_info().id() != block.id() {
            return Ok(None);
        }

        tracker.start_working();
        let ledger_info_with_sigs_clone = ledger_info_with_sigs.clone();
        tokio::task::spawn_blocking(move || {
            executor
                .commit_ledger(ledger_info_with_sigs_clone)
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
        Ok(Some(ledger_info_with_sigs))
    }
```

**File:** consensus/src/state_computer.rs (L183-186)
```rust
        // Before state synchronization, we have to call finish() to free the
        // in-memory SMT held by BlockExecutor to prevent a memory leak.
        self.executor.finish();

```

**File:** consensus/src/block_storage/sync_manager.rs (L504-514)
```rust
        // abort any pending executor tasks before entering state sync
        // with zaptos, things can run before hitting buffer manager
        if let Some(block_store) = maybe_block_store {
            monitor!(
                "abort_pipeline_for_state_sync",
                block_store.abort_pipeline_for_state_sync().await
            );
        }
        execution_client
            .sync_to_target(highest_commit_cert.ledger_info().clone())
            .await?;
```

**File:** consensus/src/block_storage/block_store.rs (L617-627)
```rust
    pub async fn abort_pipeline_for_state_sync(&self) {
        let blocks = self.inner.read().get_all_blocks();
        // the blocks are not ordered by round here, so we need to abort all then wait
        let futs: Vec<_> = blocks
            .into_iter()
            .filter_map(|b| b.abort_pipeline())
            .collect();
        for f in futs {
            f.wait_until_finishes().await;
        }
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L141-149)
```rust
    fn commit_ledger(&self, ledger_info_with_sigs: LedgerInfoWithSignatures) -> ExecutorResult<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "commit_ledger"]);

        self.inner
            .read()
            .as_ref()
            .expect("BlockExecutor is not reset")
            .commit_ledger(ledger_info_with_sigs)
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L151-155)
```rust
    fn finish(&self) {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "finish"]);

        *self.inner.write() = None;
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L380-381)
```rust
        // Confirm the block to be committed is tracked in the tree.
        self.block_tree.get_block(block_id)?;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L562-568)
```rust
    pub async fn wait_for_commit_ledger(&self) {
        // may be aborted (e.g. by reset)
        if let Some(fut) = self.pipeline_futs() {
            // this may be cancelled
            let _ = fut.commit_ledger_fut.await;
        }
    }
```
