# Audit Report

## Title
Non-Canonical IdCommitment Field Reduction Enables Multiple Addresses for Single Keyless Identity

## Summary
The keyless authentication system fails to validate that `IdCommitment` bytes represent canonical scalar field elements (< BN254 Fr modulus). When computing the public inputs hash for proof verification, non-canonical IdCommitment values are silently reduced via `Fr::from_le_bytes_mod_order()`, allowing an attacker to create multiple distinct addresses that all successfully verify proofs intended for a single OAuth identity.

## Finding Description
The vulnerability exists in the keyless account address derivation and proof verification flow:

**Address Derivation Path:**
1. A `KeylessPublicKey` contains an `IdCommitment` struct wrapping a 32-byte `Vec<u8>` [1](#0-0) 
2. The IdCommitment deserialization uses only BCS deserialization without validating the bytes represent a value < field modulus [2](#0-1) 
3. Account addresses are derived via `SHA3-256(public_key_bytes || scheme_byte)` [3](#0-2) 

**Proof Verification Path:**
1. During transaction validation, `get_public_inputs_hash()` is called with the KeylessPublicKey [4](#0-3) 
2. The function converts IdCommitment bytes to Fr using `Fr::from_le_bytes_mod_order(&idc.0)` which **silently reduces modulo the field order** [5](#0-4) 
3. This reduced value is used to compute the public inputs hash for proof verification

**Attack Scenario:**
1. Legitimate user Alice has canonical IdCommitment `idc_canonical` (< MODULUS) with address `A_canonical`
2. Attacker constructs `idc_malicious` with bytes representing `idc_canonical + MODULUS` (where MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617)
3. Attacker creates KeylessPublicKey with `idc_malicious`, deriving address `A_malicious` (different SHA3 preimage)
4. Since IdCommitment deserialization has no validation, the malicious public key is accepted
5. During proof verification, `idc_malicious` is reduced to `idc_canonical` via modular arithmetic
6. Proofs generated for `A_canonical` successfully verify for `A_malicious`

This breaks the fundamental invariant that each OAuth identity maps to a **unique** on-chain address, enabling address confusion attacks.

## Impact Explanation
**Severity: Medium** (per Aptos Bug Bounty criteria)

This vulnerability causes **state inconsistencies requiring intervention**:
- **Keyless Account Uniqueness Violation**: Multiple addresses can be controlled by a single OAuth identity, violating the design assumption of one-to-one mapping
- **Address-Based Access Control Bypass**: Systems relying on address comparisons for access control can be confused by shadow addresses
- **Impersonation Risk**: An attacker knowing a legitimate user's canonical IdCommitment (which is public) can create shadow addresses that validate against the user's proofs
- **State Confusion**: Different addresses in the state (A_canonical vs A_malicious) both authenticate with the same OAuth credentials

This does not directly cause fund loss but creates significant security and usability issues requiring protocol-level intervention.

## Likelihood Explanation
**Likelihood: Medium-High**

The attack is **easy to execute**:
- No special privileges required beyond submitting transactions
- IdCommitment bytes can be trivially manipulated (just add MODULUS to canonical bytes)
- The canonical IdCommitment value can be observed from legitimate transactions or computed from public parameters
- BCS deserialization accepts any 32-byte Vec<u8> without validation

The impact is **moderate** because:
- Requires knowledge of the canonical IdCommitment (publicly derivable)
- Exploitability depends on downstream systems that rely on address uniqueness
- Does not immediately enable fund theft but enables confusion attacks

## Recommendation
Add validation during `IdCommitment` deserialization to ensure bytes represent a canonical scalar field element:

```rust
impl TryFrom<&[u8]> for IdCommitment {
    type Error = CryptoMaterialError;
    
    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let idc: IdCommitment = bcs::from_bytes(value)
            .map_err(|_| CryptoMaterialError::DeserializationError)?;
        
        // Validate that the bytes represent a canonical Fr element (< MODULUS)
        if idc.0.len() != IdCommitment::NUM_BYTES {
            return Err(CryptoMaterialError::ValidationError);
        }
        
        // Attempt to deserialize as Fr, which validates the value is < modulus
        ark_bn254::Fr::deserialize_uncompressed(idc.0.as_slice())
            .map_err(|_| CryptoMaterialError::ValidationError)?;
        
        Ok(idc)
    }
}
```

Additionally, consider using `Fr::deserialize_uncompressed()` instead of `Fr::from_le_bytes_mod_order()` in `hash_public_inputs()` to fail explicitly on non-canonical inputs rather than silently reducing.

## Proof of Concept
```rust
// Add to types/src/keyless/mod.rs tests
#[test]
fn test_non_canonical_idc_creates_different_address() {
    use ark_bn254::Fr;
    use ark_ff::{BigInteger, PrimeField};
    use ark_serialize::CanonicalSerialize;
    
    // Create canonical IdCommitment
    let canonical_fr = Fr::from(12345u64);
    let mut canonical_bytes = vec![0u8; 32];
    canonical_fr.serialize_uncompressed(&mut canonical_bytes).unwrap();
    let canonical_idc = IdCommitment(canonical_bytes.clone());
    
    // Create non-canonical IdCommitment (add MODULUS to canonical value)
    let modulus = Fr::MODULUS;
    let canonical_bigint = canonical_fr.into_bigint();
    let non_canonical_bigint = canonical_bigint.add(&modulus);
    let non_canonical_bytes = non_canonical_bigint.to_bytes_le();
    let non_canonical_idc = IdCommitment(non_canonical_bytes[..32].to_vec());
    
    // Create KeylessPublicKeys with same iss but different IdCommitments
    let pk_canonical = KeylessPublicKey {
        iss_val: "https://accounts.google.com".to_string(),
        idc: canonical_idc,
    };
    let pk_non_canonical = KeylessPublicKey {
        iss_val: "https://accounts.google.com".to_string(),
        idc: non_canonical_idc,
    };
    
    // Derive addresses
    let addr_canonical = AuthenticationKey::any_key(
        AnyPublicKey::Keyless { public_key: pk_canonical }
    ).account_address();
    
    let addr_non_canonical = AuthenticationKey::any_key(
        AnyPublicKey::Keyless { public_key: pk_non_canonical }
    ).account_address();
    
    // Addresses are DIFFERENT
    assert_ne!(addr_canonical, addr_non_canonical);
    
    // But when computing public inputs hash, both reduce to the same Fr value
    let hash_canonical = Fr::from_le_bytes_mod_order(&pk_canonical.idc.0);
    let hash_non_canonical = Fr::from_le_bytes_mod_order(&pk_non_canonical.idc.0);
    
    // Same Fr value after reduction - VULNERABILITY!
    assert_eq!(hash_canonical, hash_non_canonical);
    
    println!("Canonical address: {:?}", addr_canonical);
    println!("Non-canonical address: {:?}", addr_non_canonical);
    println!("Both verify with same proof due to field reduction!");
}
```

**Notes**

The function `create_proof_with_trapdoor()` in the referenced file is used only for proof simulation/testing and accepts `public_inputs: &[E::ScalarField]` which are already type-constrained to be valid field elements [6](#0-5) . However, the real vulnerability lies in how `IdCommitment` values flow from untrusted transaction input through deserialization into the proof verification system. The lack of canonical form validation during IdCommitment deserialization, combined with the use of modular reduction during hash computation, enables the creation of multiple addresses for a single keyless identity.

### Citations

**File:** types/src/keyless/mod.rs (L287-289)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct IdCommitment(#[serde(with = "serde_bytes")] pub(crate) Vec<u8>);
```

**File:** types/src/keyless/mod.rs (L342-349)
```rust
impl TryFrom<&[u8]> for IdCommitment {
    type Error = CryptoMaterialError;

    fn try_from(_value: &[u8]) -> Result<Self, Self::Error> {
        bcs::from_bytes::<IdCommitment>(_value)
            .map_err(|_e| CryptoMaterialError::DeserializationError)
    }
}
```

**File:** types/src/transaction/authenticator.rs (L884-887)
```rust
    pub fn from_preimage(mut public_key_bytes: Vec<u8>, scheme: Scheme) -> AuthenticationKey {
        public_key_bytes.push(scheme as u8);
        AuthenticationKey::new(*HashValue::sha3_256_of(&public_key_bytes).as_ref())
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-316)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
```

**File:** types/src/keyless/bn254_circom.rs (L323-323)
```rust
    let idc = Fr::from_le_bytes_mod_order(&idc.0);
```

**File:** types/src/keyless/proof_simulation.rs (L152-157)
```rust
    pub fn create_proof_with_trapdoor(
        pk: &Trapdoor<E>,
        a: E::ScalarField,
        b: E::ScalarField,
        public_inputs: &[E::ScalarField],
    ) -> Result<Proof<E>, SynthesisError> {
```
