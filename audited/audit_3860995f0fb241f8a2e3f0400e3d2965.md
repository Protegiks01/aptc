# Audit Report

## Title
Unsafe Default Value for TC Round in safe_to_timeout() Allows Invalid Timeouts in Round 1

## Summary
The `safe_to_timeout()` function in `consensus/safety-rules/src/safety_rules_2chain.rs` uses `map_or(0, ...)` to default `tc_round` to 0 when no Timeout Certificate exists. [1](#0-0)  This creates a semantic error where "no TC" is treated identically to "TC for round 0", allowing the safety check to pass incorrectly in round 1 when signature verification is disabled (`skip_sig_verify = true`).

## Finding Description
The 2-chain timeout safety rule states that a validator can timeout round R if: `(R == QC.round + 1) OR (R == TC.round + 1)` AND `QC.round >= one_chain_round`. [2](#0-1) 

When no TC exists, the code defaults `tc_round` to 0: [1](#0-0) 

In round 1, this causes `next_round(tc_round)` to evaluate to `next_round(0) = 1`, making the condition `round == next_round(tc_round)?` TRUE even when no TC actually exists.

The vulnerability manifests when:
1. **Round = 1** (first round after genesis)
2. **No TC exists** (tc_round defaults to 0)
3. **skip_sig_verify = true** (local mode) [3](#0-2) 
4. **QC round â‰  0** (validator has an incorrect QC)

In local mode, SafetyRules is instantiated with `skip_sig_verify = true`: [4](#0-3) 

This bypasses the verification check that ensures `hqc_round() < round()`: [5](#0-4) 

**Attack Path:**
1. Validator runs SafetyRules in local mode (skip_sig_verify = true)
2. Consensus layer (due to a bug or malicious behavior) attempts to timeout round 1 with a QC for round 5
3. `safe_to_timeout()` evaluates: `(1 == next_round(5) || 1 == next_round(0)) && 5 >= one_chain_round`
4. This becomes: `(false || true) && true` = **TRUE** (incorrectly passes)
5. Validator signs the invalid timeout
6. If multiple validators have the same issue, an invalid TC could be formed for round 1

The test suite demonstrates this behavior expects `tc_round = 0` in error messages when no TC exists: [6](#0-5) 

## Impact Explanation
This vulnerability violates **Consensus Safety** (Critical severity category). The 2-chain timeout safety rule is a fundamental invariant that prevents validators from making unsafe decisions. By allowing invalid timeouts to be signed in round 1, this could potentially:

1. **Enable Safety Rule Violations**: Validators can sign timeouts that don't satisfy the documented safety conditions
2. **Compromise Safety Net**: SafetyRules is the last line of defense against unsafe consensus decisions; this bug weakens that protection
3. **Risk Consensus Divergence**: If multiple validators sign invalid timeouts due to this bug, an invalid TC could be formed, potentially leading to consensus inconsistencies

While the impact is limited to round 1 and requires local mode configuration, round 1 is critical as it's the first round after genesis in each epoch. A safety violation here could compromise the entire epoch's consensus.

## Likelihood Explanation
**Likelihood: Medium**

The vulnerability requires specific conditions:
- Validators must be running in local mode (`skip_sig_verify = true`)
- The consensus layer must attempt to timeout round 1 with an incorrect QC
- This could occur due to bugs in the consensus implementation or during epoch transitions

However, local mode is used in production deployments where "consensus already verifies" according to the code comments. [7](#0-6)  If a bug in the consensus layer triggers this condition, SafetyRules should catch it but currently fails to do so in round 1.

## Recommendation
Replace the sentinel value approach with explicit boolean logic that only evaluates the TC condition when a TC actually exists:

```rust
fn safe_to_timeout(
    &self,
    timeout: &TwoChainTimeout,
    maybe_tc: Option<&TwoChainTimeoutCertificate>,
    safety_data: &SafetyData,
) -> Result<(), Error> {
    let round = timeout.round();
    let qc_round = timeout.hqc_round();
    
    let can_timeout_with_qc = round == next_round(qc_round)?;
    let can_timeout_with_tc = maybe_tc
        .map(|tc| round == next_round(tc.round()))
        .transpose()?
        .unwrap_or(false);
    
    if (can_timeout_with_qc || can_timeout_with_tc) && qc_round >= safety_data.one_chain_round {
        Ok(())
    } else {
        let tc_round = maybe_tc.map_or(u64::MAX, |tc| tc.round()); // Use MAX for error reporting
        Err(Error::NotSafeToTimeout(
            round,
            qc_round,
            tc_round,
            safety_data.one_chain_round,
        ))
    }
}
```

This ensures that when no TC exists, the TC condition is definitively false rather than accidentally true for round 1. For error reporting, use `u64::MAX` instead of 0 to clearly indicate "no TC" in logs.

## Proof of Concept

```rust
#[test]
fn test_timeout_round_1_with_invalid_qc_no_tc() {
    use crate::{SafetyRules, PersistentSafetyStorage};
    use consensus_types::timeout_2chain::TwoChainTimeout;
    
    // Setup: Create safety rules in local mode (skip_sig_verify = true)
    let storage = PersistentSafetyStorage::in_memory();
    let mut safety_rules = SafetyRules::new(storage, true); // skip_sig_verify = true
    
    // Initialize with genesis
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Create a QC for round 5 (simulating a bug or attack)
    let high_round_qc = test_utils::make_qc_for_round(5, &signer);
    
    // Attempt to timeout round 1 with QC for round 5, no TC
    // This should FAIL but currently SUCCEEDS due to tc_round defaulting to 0
    let timeout = TwoChainTimeout::new(1, 1, high_round_qc);
    let result = safety_rules.sign_timeout_with_qc(&timeout, None);
    
    // BUG: This incorrectly succeeds because:
    // - round == next_round(tc_round) evaluates to 1 == next_round(0) = 1 (TRUE)
    // - Verification is skipped (skip_sig_verify = true)
    // - Therefore validator signs an invalid timeout
    assert!(result.is_ok(), "VULNERABILITY: Invalid timeout was signed!");
}
```

The test demonstrates that a timeout for round 1 with an incorrect QC (round 5) and no TC incorrectly succeeds when it should fail, specifically when `skip_sig_verify = true`.

## Notes
- The vulnerability is specific to **round 1** because `next_round(0) = 1`. Other rounds are not affected.
- The same pattern exists in `safe_to_vote()` function [8](#0-7)  and should also be reviewed.
- This is a defensive programming issue that weakens the safety guarantees of the SafetyRules module, which is critical for consensus integrity.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L27-31)
```rust
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-123)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L132-132)
```rust
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L157-158)
```rust
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L131-136)
```rust
    pub fn new_local(storage: PersistentSafetyStorage) -> Self {
        let safety_rules = SafetyRules::new(storage, true);
        Self {
            internal_safety_rules: SafetyRulesWrapper::Local(Arc::new(RwLock::new(safety_rules))),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L74-81)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.hqc_round() < self.round(),
            "Timeout round should be larger than the QC round"
        );
        self.quorum_cert.verify(validators)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L788-792)
```rust
        safety_rules
            .sign_timeout_with_qc(&TwoChainTimeout::new(1, 2, genesis_qc.clone()), None)
            .unwrap_err(),
        Error::NotSafeToTimeout(2, 0, 0, 0),
    );
```

**File:** consensus/safety-rules/src/safety_rules.rs (L45-47)
```rust
    // Skip verification of signatures and well-formed, this can be set if it's used in local mode
    // where consensus already verifies.
    pub(crate) skip_sig_verify: bool,
```
