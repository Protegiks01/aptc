# Audit Report

## Title
ProofCache State Pollution via Failed Proposal Verification Allows Resource Exhaustion Attack

## Summary
The `ProposalMsg::verify()` function in the consensus layer performs payload verification and signature verification in parallel, inserting cryptographically valid proofs into a shared `ProofCache` before executing structural validation via `verify_well_formed()`. When `verify_well_formed()` fails, the cache entries are not rolled back, allowing malicious actors to pollute validator caches with proofs from rejected proposals, leading to cache resource exhaustion and inconsistent state across validators.

## Finding Description

The vulnerability exists in the verification flow of consensus proposals. The `ProposalMsg::verify()` function executes verification steps in a specific order that creates a state inconsistency window: [1](#0-0) 

The function uses `rayon::join()` to parallelize payload verification and signature validation. During payload verification, the code calls into `Payload::verify()`: [2](#0-1) 

This invokes `verify_with_cache()` which filters and verifies proofs: [3](#0-2) 

Each `ProofOfStore::verify()` call inserts successful verifications into the cache: [4](#0-3) 

**The critical issue:** After the cache is populated at line 649, control returns to `ProposalMsg::verify()` where `verify_well_formed()` is called. This function performs structural validation: [5](#0-4) 

If any of these checks fail (epoch mismatch, parent_id mismatch, round inconsistency, etc.), the proposal is rejected **but the cache entries remain**.

The `ProofCache` is a shared, mutable structure with a 20-second TTL: [6](#0-5) 

**Attack Scenario:**

1. Malicious actor crafts `ProposalMsg` with:
   - Cryptographically valid `ProofOfStore` signatures (pass multi-signature verification)
   - Structurally invalid properties: wrong epoch in `sync_info`, incorrect `parent_id`, invalid round relationships
   
2. When validators receive this message via `UnverifiedEvent::verify()`: [7](#0-6) 

3. The payload proofs are verified and cached, then `verify_well_formed()` fails and returns `VerifyError`

4. **Result:** Cache is polluted with verified proofs from a rejected proposal

5. **Exploitation:** Attacker floods validators with such messages, filling the cache with entries from invalid proposals, causing:
   - Legitimate proof eviction (cache has max capacity)
   - Inconsistent cache state across validators (different validators receive different invalid proposals)
   - Resource waste (CPU spent verifying proofs for rejected proposals)

## Impact Explanation

This vulnerability meets **Medium Severity** criteria under the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: Different validators accumulate different cache states based on which malicious proposals they receive, creating non-deterministic verification behavior across the network.

- **Resource exhaustion vector**: The cache has a finite capacity (configurable via `proof_cache_capacity`). An attacker can fill the cache with proofs from rejected proposals, evicting legitimate entries and forcing re-verification of valid proofs, degrading validator performance.

While this doesn't directly break consensus safety (cryptographic verification remains sound), it violates the **State Consistency** invariant by creating inconsistent cache states across validators and the **Resource Limits** invariant by allowing unbounded cache pollution through malicious proposals.

## Likelihood Explanation

**High likelihood** - This attack is:
- **Trivial to execute**: Any network peer can send malformed proposals
- **No special privileges required**: No validator access or stake needed
- **Low cost**: Attacker only needs to craft proposals with valid signatures but invalid structure
- **Continuous impact**: With a 20-second TTL, attacker can maintain persistent cache pollution
- **Affects all validators**: All nodes receiving the malicious proposals are impacted

## Recommendation

Implement transactional cache semantics with rollback on verification failure:

```rust
pub fn verify(
    &self,
    sender: Author,
    validator: &ValidatorVerifier,
    proof_cache: &ProofCache,
    quorum_store_enabled: bool,
) -> Result<()> {
    if let Some(proposal_author) = self.proposal.author() {
        ensure!(
            proposal_author == sender,
            "Proposal author {:?} doesn't match sender {:?}",
            proposal_author,
            sender
        );
    }
    
    // Track cache insertions during verification
    let mut cached_entries = Vec::new();
    
    let (payload_result, sig_result) = rayon::join(
        || {
            self.proposal().payload().map_or(Ok(()), |p| {
                // Pass a callback to track cache insertions
                p.verify_with_tracking(validator, proof_cache, quorum_store_enabled, &mut cached_entries)
            })
        },
        || {
            self.proposal()
                .validate_signature(validator)
                .map_err(|e| format_err!("{:?}", e))
        },
    );
    
    // Check results before structural validation
    let early_result = payload_result.and(sig_result);
    
    if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
        tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
    }
    
    // Perform structural validation
    let well_formed_result = self.verify_well_formed();
    
    // Rollback cache on any failure
    if early_result.is_err() || well_formed_result.is_err() {
        for entry in cached_entries {
            proof_cache.invalidate(&entry);
        }
        early_result?;
        well_formed_result?;
    }
    
    Ok(())
}
```

Alternatively, reverse the verification order to perform `verify_well_formed()` **before** payload verification, though this breaks the parallelization optimization.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_crypto::HashValue;
    use aptos_types::validator_verifier::ValidatorVerifier;
    use mini_moka::sync::Cache;
    use std::time::Duration;
    
    #[test]
    fn test_cache_pollution_on_verify_well_formed_failure() {
        // Setup validator verifier and proof cache
        let validator_verifier = ValidatorVerifier::new_single(
            AccountAddress::random(),
            PublicKey::dummy(),
        );
        let proof_cache: ProofCache = Cache::builder()
            .max_capacity(100)
            .time_to_live(Duration::from_secs(20))
            .build();
        
        // Create a proposal with valid proofs but invalid structure
        // (e.g., epoch mismatch between proposal and sync_info)
        let mut proposal_msg = create_proposal_with_valid_proofs_invalid_structure();
        
        // Verify that cache is initially empty
        assert_eq!(proof_cache.entry_count(), 0);
        
        // Attempt verification - should fail at verify_well_formed()
        let result = proposal_msg.verify(
            AccountAddress::random(),
            &validator_verifier,
            &proof_cache,
            true,
        );
        
        // Verification should fail
        assert!(result.is_err());
        
        // BUG: Cache should be empty, but it contains entries from rejected proposal
        assert!(proof_cache.entry_count() > 0, "Cache polluted with entries from failed verification");
        
        // Demonstrate that cache pollution persists for TTL duration
        std::thread::sleep(Duration::from_secs(1));
        assert!(proof_cache.entry_count() > 0, "Polluted cache entries persist");
    }
}
```

**Notes**

This vulnerability specifically affects the consensus layer's verification caching mechanism. The core issue is the lack of atomicity in the verification processâ€”state mutations (cache insertions) occur before all validation checks complete, with no rollback mechanism. While the cryptographic integrity of proofs remains intact, the resource management and state consistency properties are violated, making this a valid medium-severity security issue rather than merely a code quality concern.

### Citations

**File:** consensus/consensus-types/src/proposal_msg.rs (L32-80)
```rust
    /// Verifies that the ProposalMsg is well-formed.
    pub fn verify_well_formed(&self) -> Result<()> {
        ensure!(
            !self.proposal.is_nil_block(),
            "Proposal {} for a NIL block",
            self.proposal
        );
        self.proposal
            .verify_well_formed()
            .context("Fail to verify ProposalMsg's block")?;
        ensure!(
            self.proposal.round() > 0,
            "Proposal for {} has an incorrect round of 0",
            self.proposal,
        );
        ensure!(
            self.proposal.epoch() == self.sync_info.epoch(),
            "ProposalMsg has different epoch number from SyncInfo"
        );
        ensure!(
            self.proposal.parent_id()
                == self.sync_info.highest_quorum_cert().certified_block().id(),
            "Proposal HQC in SyncInfo certifies {}, but block parent id is {}",
            self.sync_info.highest_quorum_cert().certified_block().id(),
            self.proposal.parent_id(),
        );
        let previous_round = self
            .proposal
            .round()
            .checked_sub(1)
            .ok_or_else(|| anyhow!("proposal round overflowed!"))?;

        let highest_certified_round = std::cmp::max(
            self.proposal.quorum_cert().certified_block().round(),
            self.sync_info.highest_timeout_round(),
        );
        ensure!(
            previous_round == highest_certified_round,
            "Proposal {} does not have a certified round {}",
            self.proposal,
            previous_round
        );
        ensure!(
            self.proposal.author().is_some(),
            "Proposal {} does not define an author",
            self.proposal
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L82-118)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        if let Some(proposal_author) = self.proposal.author() {
            ensure!(
                proposal_author == sender,
                "Proposal author {:?} doesn't match sender {:?}",
                proposal_author,
                sender
            );
        }
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;

        // if there is a timeout certificate, verify its signatures
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/consensus-types/src/common.rs (L517-539)
```rust
    fn verify_with_cache<T>(
        proofs: &[ProofOfStore<T>],
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
    ) -> anyhow::Result<()>
    where
        T: TBatchInfo + Send + Sync + 'static,
        BatchInfoExt: From<T>,
    {
        let unverified: Vec<_> = proofs
            .iter()
            .filter(|proof| {
                proof_cache
                    .get(&BatchInfoExt::from(proof.info().clone()))
                    .is_none_or(|cached_proof| cached_proof != *proof.multi_signature())
            })
            .collect();
        unverified
            .par_iter()
            .with_min_len(2)
            .try_for_each(|proof| proof.verify(validator, proof_cache))?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/common.rs (L574-632)
```rust
    pub fn verify(
        &self,
        verifier: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> anyhow::Result<()> {
        match (quorum_store_enabled, self) {
            (false, Payload::DirectMempool(_)) => Ok(()),
            (true, Payload::InQuorumStore(proof_with_status)) => {
                Self::verify_with_cache(&proof_with_status.proofs, verifier, proof_cache)
            },
            (true, Payload::InQuorumStoreWithLimit(proof_with_status)) => Self::verify_with_cache(
                &proof_with_status.proof_with_data.proofs,
                verifier,
                proof_cache,
            ),
            (true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
            | (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
                Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    inline_batches.iter().map(|(info, txns)| (info, txns)),
                )?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V1(p))) => {
                let proof_with_data = p.proof_with_data();
                Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    p.inline_batches()
                        .iter()
                        .map(|batch| (batch.info(), batch.transactions())),
                )?;
                Self::verify_opt_batches(verifier, p.opt_batches())?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V2(p))) => {
                if true {
                    bail!("OptQuorumStorePayload::V2 cannot be accepted yet");
                }
                #[allow(unreachable_code)]
                {
                    let proof_with_data = p.proof_with_data();
                    Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                    Self::verify_inline_batches(
                        p.inline_batches()
                            .iter()
                            .map(|batch| (batch.info(), batch.transactions())),
                    )?;
                    Self::verify_opt_batches(verifier, p.opt_batches())?;
                    Ok(())
                }
            },
            (_, _) => Err(anyhow::anyhow!(
                "Wrong payload type. Expected Payload::InQuorumStore {} got {} ",
                quorum_store_enabled,
                self
            )),
        }
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L635-652)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
        let batch_info_ext: BatchInfoExt = self.info.clone().into();
        if let Some(signature) = cache.get(&batch_info_ext) {
            if signature == self.multi_signature {
                return Ok(());
            }
        }
        let result = validator
            .verify_multi_signatures(&self.info, &self.multi_signature)
            .context(format!(
                "Failed to verify ProofOfStore for batch: {:?}",
                self.info
            ));
        if result.is_ok() {
            cache.insert(batch_info_ext, self.multi_signature.clone());
        }
        result
    }
```

**File:** consensus/src/epoch_manager.rs (L250-254)
```rust
            proof_cache: Cache::builder()
                .max_capacity(node_config.consensus.proof_cache_capacity)
                .initial_capacity(1_000)
                .time_to_live(Duration::from_secs(20))
                .build(),
```

**File:** consensus/src/round_manager.rs (L108-127)
```rust
    pub fn verify(
        self,
        peer_id: PeerId,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
        self_message: bool,
        max_num_batches: usize,
        max_batch_expiry_gap_usecs: u64,
    ) -> Result<VerifiedEvent, VerifyError> {
        let start_time = Instant::now();
        Ok(match self {
            UnverifiedEvent::ProposalMsg(p) => {
                if !self_message {
                    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proposal"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProposalMsg(p)
```
