# Audit Report

## Title
URL Query Parameter and Fragment Injection in Node Checker Metrics Endpoints

## Summary
The `get_api_url()` function in `node_address.rs` preserves query parameters and fragments through `url.clone()` and `set_port()` operations. While these parameters are dropped when constructing API client requests via `build_path()`, they persist and are injected into HTTP requests made by `MetricsProvider` and `SystemInformationProvider`, which use `set_path()` instead. This allows attackers to inject arbitrary query parameters into monitoring endpoint requests.

## Finding Description

When a user calls the public node-checker API endpoint `/check`, they provide a `node_url` parameter that is user-controlled. [1](#0-0) 

This URL is used to create a `NodeAddress` object: [2](#0-1) 

The `get_api_url()` function clones the URL and calls `set_port()`, which preserves query parameters and fragments: [3](#0-2) 

While the `AptosRestClient` uses `build_path()` which drops these parameters through `join()` operations, the `MetricsProvider` and `SystemInformationProvider` use a different approach. They call `set_path()` which **preserves** query parameters and fragments: [4](#0-3) 

Similarly for SystemInformationProvider: [5](#0-4) 

These URLs with preserved query parameters are then used directly in HTTP GET requests: [6](#0-5) 

**Attack Scenario:**
1. Attacker calls `/check` with `node_url=http://target.com?malicious=value&exploit=param`
2. NodeAddress is created with this URL
3. MetricsProvider sets path to `/metrics` â†’ URL becomes `http://target.com:9101/metrics?malicious=value&exploit=param`
4. HTTP GET request is sent with injected query parameters
5. Similar injection occurs for `/system_information` endpoint

The URLs are also logged without sanitization: [7](#0-6) 

## Impact Explanation

This vulnerability does **not** meet Critical or High severity criteria as it:
- Does not affect blockchain consensus, state, or execution
- Does not impact validator operations or the core protocol
- Is limited to the node-checker operational monitoring tool

It qualifies as **Low Severity** per the bug bounty criteria ("Non-critical implementation bugs" and "Minor information leaks"):

1. **Query Parameter Injection**: Attackers can inject arbitrary parameters into monitoring requests, potentially exploiting backend vulnerabilities in target node endpoints if they process query parameters unsafely
2. **Log Injection**: Malicious URL content is logged without sanitization, enabling log pollution and potential confusion in security audits
3. **Monitoring Service Abuse**: The node-checker acts as an unintended HTTP proxy for crafted requests

**Important Note**: This is an operational security issue affecting the node-checker ecosystem tool, not a core blockchain vulnerability. It does not break any of the critical blockchain invariants (consensus safety, deterministic execution, state consistency, etc.).

## Likelihood Explanation

**High Likelihood**: The `/check` endpoint is publicly accessible via OpenAPI, requires no authentication, and accepts arbitrary user-provided URLs with no validation of query parameters or fragments. Exploitation requires only a single HTTP request.

## Recommendation

Add URL sanitization to remove query parameters and fragments when accepting user input:

```rust
pub fn new(
    mut url: Url,
    api_port: Option<u16>,
    metrics_port: Option<u16>,
    noise_port: Option<u16>,
    public_key: Option<x25519::PublicKey>,
) -> Self {
    // Sanitize URL by removing query and fragment
    url.set_query(None);
    url.set_fragment(None);
    
    Self {
        url,
        api_port,
        metrics_port,
        noise_port,
        public_key,
        cookie_store: Arc::new(Jar::default()),
    }
}
```

Additionally, validate and sanitize URLs before logging.

## Proof of Concept

```bash
# Call the node-checker API with injected query parameters
curl -X GET "http://node-checker-service/check?baseline_configuration_id=devnet_fullnode&node_url=http://target-node.com?injected=malicious&exploit=value&api_port=8080&metrics_port=9101"

# The node-checker will make requests to:
# http://target-node.com:9101/metrics?injected=malicious&exploit=value
# http://target-node.com:9101/system_information?injected=malicious&exploit=value

# These injected parameters could:
# 1. Exploit vulnerabilities in the target node's metrics endpoint
# 2. Pollute logs with malicious content
# 3. Cause unexpected behavior if endpoints process query parameters
```

**Notes**

This vulnerability confirms the security question's premise that query parameters and fragments persist through `url.clone()` and `set_port()`, causing unintended request behavior in the metrics and system information providers. However, its impact is limited to the operational monitoring tool and does not affect the core Aptos blockchain infrastructure, consensus, or state management systems.

### Citations

**File:** ecosystem/node-checker/src/server/api.rs (L35-35)
```rust
        node_url: Query<Url>,
```

**File:** ecosystem/node-checker/src/server/api.rs (L81-87)
```rust
        let target_node_address = NodeAddress::new(
            node_url.0,
            api_port.0,
            metrics_port.0,
            noise_port.0,
            public_key,
        );
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L73-81)
```rust
    pub fn get_api_url(&self) -> Result<Url> {
        let mut url = self.url.clone();
        url.set_port(Some(
            self.api_port
                .context("Can't build API URL without an API port")?,
        ))
        .unwrap();
        Ok(url)
    }
```

**File:** ecosystem/node-checker/src/provider/metrics.rs (L40-57)
```rust
    pub fn new(
        config: MetricsProviderConfig,
        client: Arc<reqwest::Client>,
        mut url: Url,
        metrics_port: u16,
    ) -> Self {
        url.set_path("metrics");
        url.set_port(Some(metrics_port)).unwrap();
        let output_cache = Arc::new(OutputCache::new(Duration::from_millis(
            config.common.cache_ttl_ms,
        )));
        Self {
            config,
            client,
            metrics_url: url,
            output_cache,
        }
    }
```

**File:** ecosystem/node-checker/src/provider/metrics.rs (L59-66)
```rust
    pub async fn get_scrape(&self) -> Result<Scrape, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/metrics", e))?;
```

**File:** ecosystem/node-checker/src/provider/system_information.rs (L38-55)
```rust
    pub fn new(
        config: SystemInformationProviderConfig,
        client: Arc<reqwest::Client>,
        mut url: Url,
        metrics_port: u16,
    ) -> Self {
        url.set_path("system_information");
        url.set_port(Some(metrics_port)).unwrap();
        let output_cache = Arc::new(OutputCache::new(Duration::from_millis(
            config.common.cache_ttl_ms,
        )));
        Self {
            config,
            client,
            metrics_url: url,
            output_cache,
        }
    }
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L89-92)
```rust
        info!(
            target_node_url = target_node_address.url,
            event = "check_starting"
        );
```
