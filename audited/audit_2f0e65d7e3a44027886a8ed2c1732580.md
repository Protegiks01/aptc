# Audit Report

## Title
Silent Deserialization Failure in Validator Transaction Configuration Causes Consensus Split During Network Upgrades

## Summary
The `validator_txn_enabled()` native function and the epoch manager's configuration loading both use `.unwrap_or_default()` when deserializing the on-chain consensus configuration. This silently converts deserialization failures into a default configuration with validator transactions disabled, causing validators with different code versions to make conflicting decisions about accepting blocks during network upgrades, leading to consensus failure.

## Finding Description

The vulnerability exists in two critical code paths that determine whether validator transactions are enabled:

**Path 1: Move Native Function**

The native function `validator_txn_enabled` deserializes on-chain consensus configuration bytes and uses `.unwrap_or_default()` to silently convert deserialization failures into a default configuration: [1](#0-0) 

**Path 2: Epoch Manager Configuration Loading**

When the epoch manager starts a new epoch, it attempts to deserialize the consensus configuration. Deserialization failures are logged as warnings but then silently converted to defaults via `.unwrap_or_default()`: [2](#0-1) 

**The Default Configuration Disables Validator Transactions**

The default implementation returns a V4 configuration with validator transactions disabled: [3](#0-2) 

The `ValidatorTxnConfig::default_if_missing()` method returns V0, which represents the disabled state: [4](#0-3) 

The `enabled()` method confirms that V0 means validator transactions are disabled: [5](#0-4) 

**Consensus Decision Point Creates Split**

The RoundManager stores the validator transaction configuration and uses it to determine whether to accept ProposalExt blocks. When validator transactions are disabled, it explicitly rejects ProposalExt blocks: [6](#0-5) 

The RoundManager initializes this configuration from the on-chain consensus config: [7](#0-6) 

**Attack Scenario During Network Upgrades**

When governance updates the consensus configuration to a new `OnChainConsensusConfig` enum variant (e.g., upgrading from V4 to V5, or introducing a hypothetical V6):

1. Validators running **updated code** can deserialize the new variant → successfully read the configuration → `vtxn_enabled = true` (if configured)
2. Validators running **older code** cannot deserialize the unknown enum variant → BCS deserialization fails → `.unwrap_or_default()` → V4 with `vtxn_enabled = false`
3. Proposers with updated code create `ProposalExt` blocks containing validator transactions
4. Updated validators accept these blocks (vtxn enabled)
5. Older validators reject these blocks with "ProposalExt unexpected while the vtxn feature is disabled"
6. **Consensus split**: The validator set cannot agree on which blocks to commit
7. **Chain halt**: The network cannot make progress until the split is resolved

The vulnerability breaks the **Deterministic Execution** invariant of consensus: validators processing identical on-chain data arrive at different conclusions due to code version differences being silently masked by `.unwrap_or_default()`.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program under two categories:

1. **Consensus/Safety Violations**: Validators disagree on block validity, causing different subsets of validators to accept or reject the same blocks. This violates consensus safety properties where all honest validators should agree on the canonical chain.

2. **Total Loss of Liveness/Network Availability**: When the validator set is split on whether to accept ProposalExt blocks, the network cannot form quorum certificates for conflicting blocks, halting block production and preventing the chain from making progress.

The issue is particularly severe because:
- It occurs during **routine network upgrades**, not exceptional circumstances
- The failure is **silent** - only warning logs are emitted, making it difficult for operators to diagnose
- The mismatch affects both the **Move execution layer** (via native function) and the **consensus layer** (via epoch manager)
- It can lead to **non-recoverable network partition** requiring emergency coordination or hardfork to resolve

## Likelihood Explanation

**High Likelihood** during network upgrades:

1. **Network upgrades are regular operational events**: Validators must be upgraded periodically to support new features and protocol improvements
2. **Rolling upgrades create mixed versions**: During rolling upgrades, validators naturally run different code versions temporarily
3. **Multiple config versions exist**: The codebase shows OnChainConsensusConfig versions V1, V2, V3, V4, and V5, demonstrating that new versions are introduced over time
4. **BCS deserialization is strict**: When older code encounters a new enum variant (e.g., V5 or V6) that it doesn't recognize, BCS deserialization will fail with an error
5. **No explicit version compatibility checking**: Neither the native function nor the epoch manager performs version compatibility checks before attempting deserialization

The vulnerability triggers when:
- Governance deploys a new `OnChainConsensusConfig` enum variant (e.g., V6 with new fields)
- Some validators still run code that only understands up to V5
- The older validators fail BCS deserialization and silently fall back to defaults
- The coordination window between validator upgrades and config deployment creates the vulnerable state

## Recommendation

**Immediate Fix**: Replace `.unwrap_or_default()` with explicit error handling that fails the validator process when configuration deserialization fails:

```rust
// In epoch_manager.rs
let consensus_config = onchain_consensus_config
    .expect("CRITICAL: Failed to deserialize consensus config. This validator may be running outdated code.");

// In consensus_config.rs native function  
let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
    .expect("CRITICAL: Failed to deserialize consensus config bytes");
```

**Long-term Solutions**:

1. **Version Compatibility Matrix**: Implement explicit version compatibility checking before attempting deserialization, with clear error messages about required validator version
2. **Graceful Degradation**: Add version negotiation protocol where validators can signal their supported config versions
3. **Coordinated Upgrades**: Enhance governance tooling to verify all validators support new config versions before allowing deployment
4. **Fail-Stop Instead of Fail-Byzantine**: Ensure validators halt when they cannot parse critical configuration rather than silently using defaults that cause divergence

## Proof of Concept

The vulnerability can be demonstrated through a test scenario simulating a mixed-version network:

```rust
// Simulated test showing the consensus split
#[test]
fn test_consensus_split_on_config_version_mismatch() {
    // Simulate V5 config with validator transactions enabled
    let new_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::default_for_genesis(),
        vtxn: ValidatorTxnConfig::default_enabled(),
        window_size: Some(1),
        rand_check_enabled: true,
    };
    
    // Validator with NEW code deserializes successfully
    let config_bytes = bcs::to_bytes(&new_config).unwrap();
    let parsed_new = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes);
    assert!(parsed_new.is_ok());
    assert!(parsed_new.unwrap().is_vtxn_enabled()); // true
    
    // Validator with OLD code (only knows V1-V4) fails deserialization
    // This would fail in reality, but unwrap_or_default() masks it:
    let default_config = OnChainConsensusConfig::default();
    assert!(!default_config.is_vtxn_enabled()); // false
    
    // Result: NEW validators accept ProposalExt, OLD validators reject
    // This creates a consensus split where blocks are not committed
}
```

The actual triggering requires:
1. Deploying a new OnChainConsensusConfig variant via governance
2. Having validators with mixed code versions during rolling upgrade
3. Observing that ProposalExt blocks are rejected by subset of validators
4. Network halts due to inability to reach consensus on block validity

## Notes

The vulnerability is fundamentally a **protocol resilience issue** rather than a malicious attack vector. While governance participants are trusted roles, the system should be resilient to operational coordination failures during upgrades. The `.unwrap_or_default()` pattern converts what should be a fail-stop error (validator crashes when it can't parse critical config) into fail-Byzantine behavior (validators silently disagree on configuration), which is significantly worse for consensus safety.

The report's claim about "V0→V1 transition" causing the issue is partially inaccurate - changing the validator transaction config from V0 to V1 **within the same OnChainConsensusConfig version** would not cause deserialization failure. However, the core vulnerability regarding **new enum variant introduction** causing consensus splits is valid and critical.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** consensus/src/epoch_manager.rs (L1187-1201)
```rust
        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L162-167)
```rust
    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** consensus/src/round_manager.rs (L363-364)
```rust
        let vtxn_config = onchain_config.effective_validator_txn_config();
        debug!("vtxn_config={:?}", vtxn_config);
```

**File:** consensus/src/round_manager.rs (L1116-1124)
```rust
        if !self.vtxn_config.enabled()
            && matches!(
                proposal.block_data().block_type(),
                BlockType::ProposalExt(_)
            )
        {
            counters::UNEXPECTED_PROPOSAL_EXT_COUNT.inc();
            bail!("ProposalExt unexpected while the vtxn feature is disabled.");
        }
```
