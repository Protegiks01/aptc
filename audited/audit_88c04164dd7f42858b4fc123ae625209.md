# Audit Report

## Title
Insufficient Auto-Bootstrapping Sanitization for Non-Fast-Sync Modes Allows State Inconsistency in Production

## Summary
The `is_fast_sync()` function only identifies `BootstrappingMode::DownloadLatestStates` as requiring peer synchronization, but all four bootstrapping modes require data from peers to complete synchronization. This allows operators to misconfigure nodes with `enable_auto_bootstrapping: true` for modes like `ApplyTransactionOutputsFromGenesis`, causing nodes to mark themselves as bootstrapped at genesis without syncing required historical data from peers, leading to temporary state inconsistencies.

## Finding Description

The vulnerability stems from an incomplete logical check in the bootstrapping mode validation. [1](#0-0) 

This function only returns `true` for `DownloadLatestStates`, but examining the bootstrapper implementation reveals that **all four bootstrapping modes** require fetching data from peers: [2](#0-1) 

The sanitizer check uses `is_fast_sync()` to prevent auto-bootstrapping: [3](#0-2) 

However, this check is insufficient. Auto-bootstrapping logic triggers when no peers are found: [4](#0-3) 

**Attack Scenario:**
A node operator configuring a new validator/fullnode for an existing network (testnet/mainnet/multi-validator devnet) could:

1. Set `bootstrapping_mode: ApplyTransactionOutputsFromGenesis` (or `ExecuteTransactionsFromGenesis`/`ExecuteOrApplyFromGenesis`)
2. Set `enable_auto_bootstrapping: true`
3. Keep `waypoint.version: 0` (genesis)
4. Deploy node during temporary network issues (no peers initially available)

Result: After `max_connection_deadline_secs`, the node auto-bootstraps at genesis, marking itself as complete without syncing any historical transaction outputs/transactions that existed since genesis. The node believes it's bootstrapped but has incomplete state until the continuous syncer (if functional) catches up.

This breaks the **State Consistency** invariant: nodes should not be marked as operational until they've synced required historical data.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Validator Impact**: A validator that auto-bootstraps at genesis may attempt to participate in consensus with incomplete state, potentially causing voting on incorrect state transitions until it catches up
2. **Fullnode Impact**: Fullnodes serving API requests would return genesis state instead of current state, misleading users and applications
3. **Temporary Duration**: The node may eventually catch up through continuous syncing, but during the gap, it operates with inconsistent state
4. **Production Risk**: While requiring operator misconfiguration, this is plausible in production scenarios where operators follow incomplete setup guides or reuse single-node test configurations

This matches the bug bounty's Medium severity category: "State inconsistencies requiring intervention."

## Likelihood Explanation

**Medium Likelihood:**

- Requires operator error (enabling auto-bootstrapping for non-single-node deployment)
- However, realistic scenarios include:
  - Operators copying configuration from single-node test environments to production
  - Temporary peer connectivity issues during node initialization
  - Following incomplete documentation that enables auto-bootstrapping for "faster startup"

The likelihood increases because:
- The default `enable_auto_bootstrapping: false` is safe, but operators may enable it
- Test configurations explicitly enable it, which operators might copy
- The sanitizer gives false confidence by only warning for `DownloadLatestStates` [5](#0-4) 

## Recommendation

Expand the sanitizer check to prevent auto-bootstrapping for **all** bootstrapping modes that require peer synchronization:

```rust
pub fn is_fast_sync(&self) -> bool {
    *self == BootstrappingMode::DownloadLatestStates
}

pub fn requires_peer_sync(&self) -> bool {
    // All modes except genesis-only deployments require peer sync
    matches!(
        self,
        BootstrappingMode::ApplyTransactionOutputsFromGenesis
            | BootstrappingMode::DownloadLatestStates
            | BootstrappingMode::ExecuteTransactionsFromGenesis
            | BootstrappingMode::ExecuteOrApplyFromGenesis
    )
}
```

Update the sanitizer to use `requires_peer_sync()`:

```rust
let requires_peer_sync = state_sync_driver_config.bootstrapping_mode.requires_peer_sync();
if state_sync_driver_config.enable_auto_bootstrapping && requires_peer_sync {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "Auto-bootstrapping should not be enabled when peer synchronization is required! \
         This setting is only for single-node deployments at genesis.".to_string(),
    ));
}
```

## Proof of Concept

```rust
// Reproduction steps:
// 1. Configure a node with:
//    - bootstrapping_mode: ApplyTransactionOutputsFromGenesis
//    - enable_auto_bootstrapping: true
//    - waypoint.version: 0
//
// 2. Start the node with no available peers
//
// 3. Wait for max_connection_deadline_secs (default: 10 seconds)
//
// 4. Observe: Node marks itself as bootstrapped at genesis
//    - is_bootstrapped() returns true
//    - But get_synced_version() returns 0 (genesis)
//    - Node should have synced transaction outputs from peers
//
// 5. Expected: Sanitizer should reject this configuration
//    Actual: Configuration passes sanitization

#[test]
fn test_sanitizer_allows_unsafe_auto_bootstrap_config() {
    use aptos_config::config::{NodeConfig, StateSyncConfig, StateSyncDriverConfig};
    use aptos_config::config::state_sync_config::{BootstrappingMode, ConfigSanitizer};
    use aptos_types::chain_id::ChainId;
    
    // Create unsafe configuration
    let node_config = NodeConfig {
        state_sync: StateSyncConfig {
            state_sync_driver: StateSyncDriverConfig {
                bootstrapping_mode: BootstrappingMode::ApplyTransactionOutputsFromGenesis,
                enable_auto_bootstrapping: true,
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    // This should fail but currently passes
    let result = StateSyncConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::testnet())
    );
    
    // BUG: Sanitizer allows this unsafe configuration
    assert!(result.is_ok(), "Sanitizer should reject auto-bootstrapping with ApplyTransactionOutputsFromGenesis");
}
```

**Notes:**
- This vulnerability requires operator misconfiguration, not direct exploitation
- The impact is temporary if continuous syncing catches up, but creates a window of state inconsistency
- The semantic meaning of "fast sync" should include all modes requiring peer data, not just `DownloadLatestStates`
- Production networks automatically use `DownloadLatestStates` via the optimizer, providing partial mitigation
- Single-node deployments legitimately need auto-bootstrapping, but current sanitizer cannot distinguish deployment types

### Citations

**File:** config/src/config/state_sync_config.rs (L70-73)
```rust
    /// Returns true iff the bootstrapping mode is fast sync
    pub fn is_fast_sync(&self) -> bool {
        *self == BootstrappingMode::DownloadLatestStates
    }
```

**File:** config/src/config/state_sync_config.rs (L507-516)
```rust
        // Verify that auto-bootstrapping is not enabled for
        // nodes that are fast syncing.
        let fast_sync_enabled = state_sync_driver_config.bootstrapping_mode.is_fast_sync();
        if state_sync_driver_config.enable_auto_bootstrapping && fast_sync_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Auto-bootstrapping should not be enabled for nodes that are fast syncing!"
                    .to_string(),
            ));
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L748-800)
```rust
        let data_stream = match self.get_bootstrapping_mode() {
            BootstrappingMode::ApplyTransactionOutputsFromGenesis => {
                self.streaming_client
                    .get_all_transaction_outputs(
                        next_version,
                        end_version,
                        highest_known_ledger_version,
                    )
                    .await?
            },
            BootstrappingMode::ExecuteTransactionsFromGenesis => {
                self.streaming_client
                    .get_all_transactions(
                        next_version,
                        end_version,
                        highest_known_ledger_version,
                        false,
                    )
                    .await?
            },
            BootstrappingMode::ExecuteOrApplyFromGenesis => {
                if self.output_fallback_handler.in_fallback_mode() {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::Bootstrapper.get_label(),
                        1,
                    );
                    self.streaming_client
                        .get_all_transaction_outputs(
                            next_version,
                            end_version,
                            highest_known_ledger_version,
                        )
                        .await?
                } else {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::Bootstrapper.get_label(),
                        0,
                    );
                    self.streaming_client
                        .get_all_transactions_or_outputs(
                            next_version,
                            end_version,
                            highest_known_ledger_version,
                            false,
                        )
                        .await?
                }
            },
            bootstrapping_mode => {
                unreachable!("Bootstrapping mode not supported: {:?}", bootstrapping_mode)
            },
```

**File:** state-sync/state-sync-driver/src/driver.rs (L636-664)
```rust
    async fn check_auto_bootstrapping(&mut self) {
        if !self.bootstrapper.is_bootstrapped()
            && self.is_consensus_or_observer_enabled()
            && self.driver_configuration.config.enable_auto_bootstrapping
            && self.driver_configuration.waypoint.version() == 0
        {
            if let Some(start_time) = self.start_time {
                if let Some(connection_deadline) = start_time.checked_add(Duration::from_secs(
                    self.driver_configuration
                        .config
                        .max_connection_deadline_secs,
                )) {
                    if self.time_service.now() >= connection_deadline {
                        info!(LogSchema::new(LogEntry::AutoBootstrapping).message(
                            "Passed the connection deadline! Auto-bootstrapping the validator!"
                        ));
                        if let Err(error) = self.bootstrapper.bootstrapping_complete().await {
                            warn!(LogSchema::new(LogEntry::AutoBootstrapping)
                                .error(&error)
                                .message("Failed to mark bootstrapping as complete!"));
                        }
                    }
                } else {
                    warn!(LogSchema::new(LogEntry::AutoBootstrapping)
                        .message("The connection deadline overflowed! Unable to auto-bootstrap!"));
                }
            }
        }
    }
```

**File:** testsuite/forge/src/backend/local/swarm.rs (L147-158)
```rust
                if number_of_validators.get() == 1 {
                    // this delays empty block by (30-1) * 30ms
                    config.consensus.quorum_store_poll_time_ms = 900;
                    config
                        .state_sync
                        .state_sync_driver
                        .enable_auto_bootstrapping = true;
                    config
                        .state_sync
                        .state_sync_driver
                        .max_connection_deadline_secs = 1;
                }
```
