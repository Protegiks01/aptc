# Audit Report

## Title
Type Parameter Fails to Shadow Module Aliases Leading to Incorrect Name Resolution

## Summary
The `shadow_for_type_parameters()` function in the Move compiler only removes member aliases when type parameters are introduced, but fails to remove module aliases with the same name. This allows type parameters to be incorrectly resolved as module qualifiers in two-part name expressions like `T::SomeType`, violating the expected shadowing semantics.

## Finding Description
When a function or struct declares a type parameter (e.g., `T`), it should shadow all outer-scope aliases with the same name, including both member aliases and module aliases. However, the implementation in `shadow_for_type_parameters()` only removes entries from the `members` map, not from the `modules` map. [1](#0-0) 

The function only calls `self.members.remove(tp_name)` at line 248, leaving module aliases intact.

During name resolution for two-part expressions, the compiler checks both member and module aliases: [2](#0-1) 

At line 2272, `module_alias_get(&n1)` is called, which will successfully resolve a module alias that should have been shadowed by a type parameter.

**Attack Scenario:**
```move
module 0x1::Target { struct TypeA {} }
module 0x2::Vulnerable {
    use 0x1::Target as T;  // Module alias T
    
    fun exploit<T>() {  // Type parameter T should shadow module alias
        // Developer expects this to fail (T is a type param)
        // Compiler incorrectly resolves T to module 0x1::Target
        let _x: T::TypeA;  
    }
}
```

## Impact Explanation
This compiler bug violates Move's name resolution semantics and could lead to **Medium severity** issues:

1. **Bytecode Inconsistency**: Different compiler versions or configurations might handle this differently, producing different bytecode from identical source code
2. **Developer Confusion**: Code that should fail compilation succeeds with unexpected semantics
3. **Upgrade Compatibility Issues**: If the bug is fixed in future compiler versions, previously-compiling code may break

However, this does NOT qualify for High/Critical severity because:
- Validators execute pre-compiled bytecode, not source code
- No direct consensus divergence (all validators execute the same bytecode)
- No immediate loss of funds or state corruption
- Impact limited to compilation phase, not runtime execution

## Likelihood Explanation
The likelihood is **LOW to MEDIUM** for several reasons:
- Requires specific naming collision between module alias and type parameter
- Most developers avoid such naming conflicts
- The pattern of using single-letter names (like `T`) for both module aliases and type parameters is uncommon
- Impact limited to developers who encounter this specific edge case

## Recommendation
Modify `shadow_for_type_parameters()` to also remove module aliases:

```rust
pub fn shadow_for_type_parameters<'a, I: IntoIterator<Item = &'a Name>>(
    &mut self,
    tparams: I,
) -> OldAliasMap
where
    I::IntoIter: ExactSizeIterator,
{
    let tparams_iter = tparams.into_iter();
    if tparams_iter.len() == 0 {
        return OldAliasMap(None);
    }

    let outer_scope = OldAliasMap(Some(self.clone()));
    self.unused.push(AliasSet::new());
    for tp_name in tparams_iter {
        self.members.remove(tp_name);
        self.modules.remove(tp_name);  // ADD THIS LINE
    }
    outer_scope
}
```

## Proof of Concept
```move
address 0x1 {
module Target {
    struct TypeA {}
}
}

address 0x2 {
module Test {
    use 0x1::Target as T;
    
    public fun vulnerable<T>(): bool {
        // This should fail: T is a type parameter, not a module
        // But currently compiles and resolves T to 0x1::Target
        let _x: T::TypeA = 0x1::Target::TypeA {};
        true
    }
}
}
```

Compile this code. Expected: Compilation error stating T cannot be used as module qualifier. Actual: Compiles successfully with T resolved to `0x1::Target`.

---

**Notes:**
This is a compiler correctness bug with limited security impact. While it violates expected Move semantics, it does not create direct runtime vulnerabilities or consensus issues since validators execute identical pre-compiled bytecode. The primary risk is developer confusion and potential bytecode inconsistency across compiler versions, qualifying this as a Medium-severity compiler bug rather than a Critical blockchain vulnerability.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs (L233-251)
```rust
    pub fn shadow_for_type_parameters<'a, I: IntoIterator<Item = &'a Name>>(
        &mut self,
        tparams: I,
    ) -> OldAliasMap
    where
        I::IntoIter: ExactSizeIterator,
    {
        let tparams_iter = tparams.into_iter();
        if tparams_iter.len() == 0 {
            return OldAliasMap(None);
        }

        let outer_scope = OldAliasMap(Some(self.clone()));
        self.unused.push(AliasSet::new());
        for tp_name in tparams_iter {
            self.members.remove(tp_name);
        }
        outer_scope
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L2264-2281)
```rust
        (_, PN::Two(sp!(_, LN::Name(n1)), n2)) => {
            if let Some((mident, mem)) = context.aliases.member_alias_get(&n1).filter(|_| {
                context.env.flags().lang_v2()
                    && is_valid_struct_constant_or_schema_name(n1.value.as_str())
                    && is_valid_struct_constant_or_schema_name(n2.value.as_str())
            }) {
                // n1 is interpreted as a type and n2 as a variant in the type
                EN::ModuleAccess(mident, mem, Some(n2))
            } else if let Some(mident) = context.aliases.module_alias_get(&n1) {
                // n1 is interpreted as a module and n2 as type.
                EN::ModuleAccess(mident, n2, None)
            } else {
                context.env.add_diag(diag!(
                    NameResolution::UnboundModule,
                    (n1.loc, format!("Unbound module or type alias '{}'", n1))
                ));
                return None;
            }
```
