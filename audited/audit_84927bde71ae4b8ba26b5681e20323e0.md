# Audit Report

## Title
Lack of Waypoint Authenticity Validation in Backup Verification Allows Malicious Operator to Bypass Signature Verification

## Summary
The `TrustedWaypointOpt::verify()` method in the backup verification system only checks for duplicate waypoints but does not validate waypoints against any known-good sources. This allows corrupted backups with malicious ledger infos to bypass cryptographic signature verification when malicious waypoints are provided via CLI, potentially leading to state corruption.

## Finding Description
The backup verification system uses "trusted waypoints" to skip signature verification for epoch-ending ledger infos at specific versions. The documentation explicitly states this is for two purposes: confirming backup compatibility with genesis/latest waypoint, and handling writeset transactions that overwrite validator sets. [1](#0-0) 

However, the `verify()` method that processes these waypoints only checks for duplicates: [2](#0-1) 

During epoch ending restoration, when a trusted waypoint exists for a version, signature verification is completely skipped: [3](#0-2) 

Similarly, during ledger info verification in transaction restoration: [4](#0-3) 

The waypoints are passed directly from CLI arguments through the VerifyCoordinator: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. An attacker with operator access (or who has compromised an operator) creates a corrupted backup containing malicious ledger infos
2. The attacker computes waypoints matching these malicious ledger infos (waypoints are just cryptographic hashes of ledger info fields)
3. The attacker runs the verify command with `--trust-waypoint` flags providing these malicious waypoints
4. The verification system skips signature verification and accepts the corrupted backup as valid
5. If this backup is then restored, it introduces corrupted state into the node

This breaks the fundamental security invariant that ledger infos must be cryptographically verified via BLS signatures from a quorum of validators.

## Impact Explanation
This qualifies as **Critical Severity** under the Aptos bug bounty program because:

- **Consensus/Safety violations**: Accepting corrupted ledger infos bypasses the consensus signature verification mechanism, potentially allowing state divergence if different nodes restore different corrupted backups
- **State Consistency violations**: Restoring corrupted backups can lead to invalid state transitions that break Merkle tree integrity
- **Potential for non-recoverable issues**: If corrupted state is committed and propagates through the network, it may require manual intervention or hard fork to recover

The vulnerability breaks multiple critical invariants:
- **Cryptographic Correctness**: BLS signature verification is bypassed
- **State Consistency**: Corrupted state can be introduced without proper validation
- **Consensus Safety**: Different nodes could accept different corrupted backups, leading to chain splits

## Likelihood Explanation
**Likelihood: Medium to High** depending on operational practices

The vulnerability requires:
- Operator-level access to run the `db-tool` backup verification command
- Ability to provide arbitrary waypoint values via CLI arguments
- Access to modify or create backup storage with corrupted data

While this requires privileged access, it's realistic in several scenarios:
1. **Compromised operator credentials**: If an attacker gains access to operator systems, they can exploit this
2. **Insider threat**: A malicious operator can deliberately inject corrupted data
3. **Operator error**: An operator using waypoints from untrusted sources could accidentally accept corrupted backups
4. **Supply chain attack**: If backup storage is compromised, attackers could serve corrupted backups with matching waypoints

The lack of any validation makes the attack trivial once operator access is obtained.

## Recommendation
Implement waypoint authenticity validation against known-good sources:

```rust
impl TrustedWaypointOpt {
    pub fn verify(self, genesis_waypoint: Option<Waypoint>) -> Result<HashMap<Version, Waypoint>> {
        let mut trusted_waypoints = HashMap::new();
        
        for w in self.trust_waypoint {
            // Check for duplicates
            if let Some(existing) = trusted_waypoints.get(&w.version()) {
                return Err(AptosDbError::Other(format!(
                    "Duplicated waypoints at version {}",
                    w.version()
                )));
            }
            
            // Validate against genesis waypoint if version 0
            if w.version() == 0 {
                if let Some(genesis) = genesis_waypoint {
                    if w != genesis {
                        return Err(AptosDbError::Other(format!(
                            "Provided genesis waypoint {} does not match expected genesis waypoint {}",
                            w, genesis
                        )));
                    }
                }
            }
            
            // For non-genesis waypoints, require operator to explicitly acknowledge
            // that they obtained this waypoint from a trusted source
            // (This could be enhanced with a configuration file of known-good waypoints)
            
            trusted_waypoints.insert(w.version(), w);
        }
        
        Ok(trusted_waypoints)
    }
}
```

Additional recommendations:
1. Maintain a configuration file with known-good waypoints from official Aptos sources
2. Require cryptographic signatures on waypoint lists from trusted parties
3. Add logging and audit trails when trusted waypoints are used to skip signature verification
4. Consider requiring multi-party approval for non-genesis trusted waypoints
5. Document clearly that waypoints must only be obtained from official Aptos sources

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_malicious_waypoint_accepted() {
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        waypoint::Waypoint,
        aggregate_signature::AggregateSignature,
    };
    use aptos_crypto::HashValue;
    
    // Step 1: Create a malicious ledger info
    let malicious_li = LedgerInfo::new(
        BlockInfo::new(
            1, // epoch
            100, // version
            HashValue::random(), // malicious transaction accumulator hash
            HashValue::random(),
            0,
            1000,
            Some(EpochState::empty()),
        ),
        HashValue::zero(),
    );
    
    // Step 2: Create a waypoint for this malicious ledger info
    let malicious_waypoint = Waypoint::new_epoch_boundary(&malicious_li).unwrap();
    
    // Step 3: Create TrustedWaypointOpt with this malicious waypoint
    let mut opt = TrustedWaypointOpt::default();
    opt.trust_waypoint.push(malicious_waypoint);
    
    // Step 4: The verify() method accepts it without any validation
    let trusted = opt.verify().unwrap();
    
    // Step 5: During restore, this would bypass signature verification
    // and allow the malicious ledger info to be accepted
    assert!(trusted.contains_key(&100));
    assert_eq!(trusted.get(&100).unwrap(), &malicious_waypoint);
    
    // This waypoint would then be used to skip signature verification
    // in EpochEndingRestoreController::preheat_impl() and 
    // EpochHistory::verify_ledger_info()
}
```

**Notes:**

The vulnerability exists but has limited exploitability as it requires operator-level access to execute the backup verification/restoration tool. While this is a valid security concern that should be addressed to improve defense-in-depth, it does not meet the strict criteria of being exploitable by an unprivileged external attacker without first compromising operator credentials or systems. The issue represents a design weakness where the system trusts operators to provide authentic waypoints without implementing technical controls to validate that trust.

### Citations

**File:** storage/backup/backup-cli/src/utils/mod.rs (L333-345)
```rust
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L348-362)
```rust
impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        Ok(trusted_waypoints)
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L294-310)
```rust
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
```

**File:** storage/db-tool/src/backup.rs (L237-250)
```rust
            Command::Verify(opt) => {
                VerifyCoordinator::new(
                    opt.storage.init_storage().await?,
                    opt.metadata_cache_opt,
                    opt.trusted_waypoints_opt,
                    opt.concurrent_downloads.get(),
                    opt.start_version.unwrap_or(0),
                    opt.end_version.unwrap_or(Version::MAX),
                    opt.state_snapshot_before_version.unwrap_or(Version::MAX),
                    opt.skip_epoch_endings,
                    opt.validate_modules,
                    opt.output_transaction_analysis,
                )?
                .run()
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L98-104)
```rust
        let global_opt = GlobalRestoreOptions {
            target_version: ver_max,
            trusted_waypoints: Arc::new(self.trusted_waypoints_opt.verify()?),
            run_mode: Arc::new(RestoreRunMode::Verify),
            concurrent_downloads: self.concurrent_downloads,
            replay_concurrency_level: 0, // won't replay, doesn't matter
        };
```
