# Audit Report

## Title
Epoch Change Causes Transaction Count Underreporting in Validator Analysis Tool

## Summary
The validator analysis tool in `analyze_validators.rs` incorrectly calculates transaction counts when analyzing blocks that precede epoch changes. The formula `next.version - block.version - 2` assumes every block ends with a StateCheckpoint or BlockEpilogue transaction, but during epoch changes (reconfiguration), these transactions are omitted, causing transaction counts to be underreported by 1. [1](#0-0) 

## Finding Description

The `analyze()` function calculates the number of transactions in each block by computing the version difference between consecutive BlockMetadata transactions. The formula assumes a fixed structure:

**Normal block structure:**
- Version V: BlockMetadata
- Version V+1 to V+N: Transactions  
- Version V+N+1: StateCheckpoint/BlockEpilogue
- Version V+N+2: Next BlockMetadata

However, during epoch changes (reconfiguration), the block executor explicitly **does not append** a BlockEpilogue or StateCheckpoint transaction: [2](#0-1) 

**Epoch change block structure:**
- Version V: BlockMetadata
- Version V+1 to V+N: Transactions
- Version V+N+1: Next BlockMetadata (NO StateCheckpoint/BlockEpilogue)

The calculation `(V+N+1) - V - 2 = N-1` produces an undercount of 1 transaction.

This affects:
1. Per-validator transaction statistics [3](#0-2) 

2. TPS (transactions per second) calculations used for performance monitoring [4](#0-3) 

3. Total epoch transaction counts [5](#0-4) 

## Impact Explanation

**This issue does NOT meet bug bounty severity criteria** because it affects only an **off-chain analysis tool**, not the blockchain protocol itself. Specifically:

- ❌ Does NOT affect consensus safety or liveness
- ❌ Does NOT affect on-chain state or transaction execution  
- ❌ Does NOT affect validator rewards (calculated on-chain in Move)
- ❌ Does NOT cause funds loss or network partition
- ❌ Does NOT run during block production on validator nodes

This is a **quality/correctness bug in monitoring tooling**, producing incorrect statistics that could mislead operators about network performance, but it has **no direct security impact** on the blockchain.

## Likelihood Explanation

The bug triggers deterministically at every epoch boundary (reconfiguration), which occurs regularly in the Aptos network. However, since this only affects off-chain analysis output, the operational impact is limited to incorrect dashboards/reports.

## Recommendation

Detect epoch changes by checking if the next block has a different epoch number, and adjust the calculation accordingly:

```rust
let cur_transactions_option = blocks
    .get(pos + 1)
    .map(|next| {
        // Check if epoch changed (no StateCheckpoint/BlockEpilogue appended)
        let epoch_changed = next.event.epoch() != block.event.epoch();
        let version_gap = next.version - block.version;
        let adjustment = if epoch_changed { 1 } else { 2 };
        u32::try_from(version_gap - adjustment).unwrap()
    });
```

## Proof of Concept

Create two consecutive blocks where the second triggers an epoch change:
- Block 1: version 100, epoch 5, with 3 user transactions (versions 101-103)
- Block 2: version 104, epoch 6 (epoch change, no StateCheckpoint)

Current calculation: `104 - 100 - 2 = 2` (incorrect, should be 3)
Fixed calculation: `104 - 100 - 1 = 3` (correct)

## Notes

While this is a real bug causing incorrect metrics in the validator analysis tool, it **does not constitute a security vulnerability** under the Aptos bug bounty program criteria. The blockchain continues to operate correctly; only the off-chain monitoring statistics are affected. This would be classified as a **tooling quality issue** rather than a security finding.

### Citations

**File:** crates/aptos/src/node/analyze/analyze_validators.rs (L457-459)
```rust
            let cur_transactions_option = blocks
                .get(pos + 1)
                .map(|next| u32::try_from(next.version - block.version - 2).unwrap());
```

**File:** crates/aptos/src/node/analyze/analyze_validators.rs (L471-471)
```rust
                *transactions.entry(event.proposer()).or_insert(0) += cur_transactions;
```

**File:** crates/aptos/src/node/analyze/analyze_validators.rs (L502-503)
```rust
                        let txns: u32 = max_tps_deque.iter().map(|(txns, _)| *txns).sum();
                        let tps = txns as f32 / passed;
```

**File:** crates/aptos/src/node/analyze/analyze_validators.rs (L515-517)
```rust
        let total_successes: u32 = successes.values().sum();
        let total_failures: u32 = failures.values().sum();
        let total_transactions: u32 = transactions.values().sum();
```

**File:** aptos-move/block-executor/src/executor.rs (L2508-2529)
```rust
                let mut has_reconfig = false;
                if let Some(last_output) = ret.last() {
                    if last_output.after_materialization()?.has_new_epoch_event() {
                        has_reconfig = true;
                    }
                }
                ret.resize_with(num_txns, E::Output::skip_output);
                if let Some(block_id) =
                    transaction_slice_metadata.append_state_checkpoint_to_block()
                {
                    if !has_reconfig {
                        block_epilogue_txn = Some(self.gen_block_epilogue(
                            block_id,
                            signature_verified_block,
                            ret.iter(),
                            idx as TxnIndex,
                            block_limit_processor.get_block_end_info(),
                            module_cache_manager_guard.environment().features(),
                        )?);
                    } else {
                        info!("Reach epoch ending, do not append BlockEpilogue txn, block_id: {block_id:?}.");
                    }
```
