# Audit Report

## Title
Missing Version Range Validation in Backup Verification Allows Silent Verification Bypass

## Summary
The `VerifyCoordinator` in the backup verification system lacks validation to ensure `start_version <= end_version`, unlike its counterpart `ReplayVerifyCoordinator`. When version parameters are accidentally reversed or misconfigured, backup verification silently succeeds without actually verifying any transaction data, creating false confidence that backups are valid when they may be corrupted or incomplete.

## Finding Description
The backup verification system has two coordinators for verifying backup integrity:

1. **ReplayVerifyCoordinator** - Includes explicit validation: [1](#0-0) 

2. **VerifyCoordinator** - Missing this validation: [2](#0-1) 

When `start_version > end_version`, the `select_transaction_backups` function returns an empty list because: [3](#0-2) 

The transaction restore controller then silently succeeds with no verification: [4](#0-3) 

**Attack Scenario:**
1. Operator intends to verify backup from version 0 to version 1000
2. Due to configuration error, parameters are reversed: `start_version=1000, end_version=100`
3. Verification command succeeds with no error
4. Operator believes backup is valid and uses it in disaster recovery
5. During actual restore, backup is discovered to be corrupted/incomplete, causing data loss

The CLI interface further exacerbates this issue: [5](#0-4) 

Note that `parse_maxable_u64` is only applied to `start_version`, not `end_version`, creating semantic inconsistency.

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program ("State inconsistencies requiring intervention"):

- **Data Integrity Risk**: Operators may rely on unverified backups during disaster recovery scenarios, leading to restoration of corrupted or incomplete blockchain state
- **False Security Confidence**: Silent success of verification provides false assurance of backup validity
- **Production Impact**: In disaster recovery situations, discovering backup corruption too late could cause extended downtime or data loss requiring manual intervention
- **Scope**: Affects any deployment using the backup verification tool, particularly automated backup validation pipelines

## Likelihood Explanation
**Likelihood: Medium-High**

The vulnerability is likely to occur because:
- Parameter ordering errors are common in CLI tools with similar-looking arguments
- Automated scripts may have configuration bugs that swap parameters
- The semantic difference between "max" for start_version (skip) vs end_version (verify all) is confusing
- No runtime warning or validation alerts operators to the misconfiguration
- The test suite does not cover this edge case: [6](#0-5) 

## Recommendation
Add validation in `VerifyCoordinator::new()` to match `ReplayVerifyCoordinator`:

```rust
pub fn new(
    storage: Arc<dyn BackupStorage>,
    metadata_cache_opt: MetadataCacheOpt,
    trusted_waypoints_opt: TrustedWaypointOpt,
    concurrent_downloads: usize,
    start_version: Version,
    end_version: Version,
    state_snapshot_before_version: Version,
    skip_epoch_endings: bool,
    validate_modules: bool,
    output_transaction_analysis: Option<PathBuf>,
) -> Result<Self> {
    // Add validation
    if start_version > end_version {
        return Err(anyhow::anyhow!(
            "start_version {} should precede end_version {}.",
            start_version, end_version
        ));
    }
    
    Ok(Self {
        storage,
        metadata_cache_opt,
        trusted_waypoints_opt,
        concurrent_downloads,
        start_version,
        end_version,
        state_snapshot_before_version,
        skip_epoch_endings,
        validate_modules,
        output_transaction_analysis,
    })
}
```

Additionally, consider adding `value_parser = parse_maxable_u64` to the `end_version` field for consistency: [7](#0-6) 

## Proof of Concept
```bash
# Create a backup directory with sample backups
mkdir -p /tmp/test_backup

# Run verify with reversed version parameters
# Expected: Should fail with validation error
# Actual: Silently succeeds without verifying anything
aptos-db-tool backup verify \
  --local-fs-dir /tmp/test_backup \
  --start-version 1000 \
  --end-version 100

# Exit code 0 (success) despite no verification occurring

# Compare with replay-verify which correctly rejects this:
aptos-db-tool replay-verify \
  --local-fs-dir /tmp/test_backup \
  --target-db-dir /tmp/test_db \
  --start-version 1000 \
  --end-version 100

# Returns error: "start_version 1000 should precede end_version 100."
```

## Notes
This vulnerability demonstrates an inconsistency between two related code paths (`VerifyCoordinator` vs `ReplayVerifyCoordinator`) where one implements proper validation while the other does not. The missing validation creates a dangerous silent failure mode that undermines the entire purpose of backup verification - ensuring data integrity before disaster recovery scenarios.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L110-115)
```rust
        if self.start_version > self.end_version {
            return Err(ReplayError::OtherError(format!(
                "start_version {} should precede end_version {}.",
                self.start_version, self.end_version
            )));
        }
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L84-96)
```rust
    async fn run_impl(self) -> Result<()> {
        let metadata_view = metadata::cache::sync_and_load(
            &self.metadata_cache_opt,
            Arc::clone(&self.storage),
            self.concurrent_downloads,
        )
        .await?;
        let ver_max = Version::MAX;
        let state_snapshot =
            metadata_view.select_state_snapshot(self.state_snapshot_before_version)?;
        let transactions =
            metadata_view.select_transaction_backups(self.start_version, self.end_version)?;
        let epoch_endings = metadata_view.select_epoch_ending_backups(ver_max)?;
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L132-160)
```rust
    pub fn select_transaction_backups(
        &self,
        start_version: Version,
        target_version: Version,
    ) -> Result<Vec<TransactionBackupMeta>> {
        // This can be more flexible, but for now we assume and check backups are continuous in
        // range (which is always true when we backup from a single backup coordinator)
        let mut next_ver = 0;
        let mut res = Vec::new();
        for backup in self.transaction_backups.iter().sorted() {
            if backup.first_version > target_version {
                break;
            }
            ensure!(
                backup.first_version == next_ver,
                "Transaction backup ranges not continuous, expecting version {}, got {}.",
                next_ver,
                backup.first_version,
            );

            if backup.last_version >= start_version {
                res.push(backup.clone());
            }

            next_ver = backup.last_version + 1;
        }

        Ok(res)
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L300-303)
```rust
    async fn run_impl(self) -> Result<()> {
        if self.manifest_handles.is_empty() {
            return Ok(());
        }
```

**File:** storage/db-tool/src/backup.rs (L134-146)
```rust
    #[clap(
        long,
        value_parser = parse_maxable_u64,
        help = "The first transaction version required to be verified. Pass \"max\" to skip \
        transaction verification. [Defaults to 0]"
    )]
    start_version: Option<Version>,
    #[clap(
        long,
        help = "The last transaction version required to be verified (if present \
        in the backup). [Defaults to the latest version available]"
    )]
    end_version: Option<Version>,
```

**File:** storage/db-tool/src/tests.rs (L49-66)
```rust
    run_cmd(&["aptos-db-tool", "backup", "verify", "--local-fs-dir", "."]);
    run_cmd(&[
        "aptos-db-tool",
        "replay-verify",
        "--target-db-dir",
        ".",
        "--local-fs-dir",
        ".",
    ]);
    run_cmd(&[
        "aptos-db-tool",
        "backup",
        "verify",
        "--local-fs-dir",
        ".",
        "--start-version",
        "Max",
    ]);
```
