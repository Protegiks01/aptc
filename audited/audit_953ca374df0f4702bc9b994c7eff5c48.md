# Audit Report

## Title
Private Key Exposure Through Unprotected Config Serialization in OverrideNodeConfig.save_config()

## Summary
The `save_config()` function in `OverrideNodeConfig` serializes the entire `NodeConfig` structure to disk without sanitizing sensitive cryptographic key material. This results in network identity private keys (x25519) and consensus private keys (BLS12-381) being written in plaintext YAML to world-readable config files, enabling key theft and node impersonation attacks.

## Finding Description

The vulnerability exists in the `save_config()` implementation which performs complete serialization of `NodeConfig` without any key sanitization: [1](#0-0) 

This function calls `get_yaml()` which directly serializes the `override_config` field: [2](#0-1) 

The `NodeConfig` structure contains multiple fields that can hold private keys: [3](#0-2) 

Specifically, `validator_network` and `full_node_networks` are of type `NetworkConfig`, which contains an `identity` field: [4](#0-3) 

When the identity is configured as `Identity::FromConfig`, it embeds the private key directly: [5](#0-4) 

The `ConfigKey<x25519::PrivateKey>` wrapper is fully serializable with no skip annotation: [6](#0-5) 

**Attack Path 1 - Fullnode Key Exposure:**

During genesis setup, fullnodes have their identities set using embedded keys: [7](#0-6) 

This function is called during fullnode initialization: [8](#0-7) 

The config is then saved with the embedded private key: [9](#0-8) 

**Attack Path 2 - Test Validator Consensus Key Exposure:**

When generating random validator configs for testing, both network identity keys and consensus keys are embedded: [10](#0-9) 

The `SafetyRulesTestConfig` contains the BLS consensus private key: [11](#0-10) 

The file writing uses default permissions with no special protections: [12](#0-11) 

## Impact Explanation

**For Fullnodes (Public and Validator Fullnodes): HIGH Severity**
- Network identity private keys (x25519) are written to `node.yaml` in plaintext
- Files created with default permissions (potentially 0644 - world-readable)
- Attackers who gain read access (via misconfigured backups, accidental git commits, container escape, or file permission errors) can:
  - Impersonate the fullnode in the P2P network
  - Perform man-in-the-middle attacks on peers connecting to this node
  - Disrupt network connectivity and serve false state data to clients
  - This affects network security and data integrity

**For Test Validators: CRITICAL Severity (if deployed in production-like environments)**
- Both network identity keys AND BLS12-381 consensus private keys are exposed
- Attackers with access can:
  - Sign consensus messages (proposals and votes) as that validator
  - Potentially cause consensus safety violations
  - However, mainnet validators have protections via SafetyRulesConfig sanitizer that prevents test configs

**Realistic Attack Scenarios:**
1. **Backup Exposure**: Config files backed up to less secure storage (S3 buckets, shared drives)
2. **Accidental Version Control Commit**: Operators commit configs to git repositories
3. **Container Breakout**: In containerized deployments, attackers access mounted config volumes
4. **File Permission Misconfiguration**: Default umask allows world-readable files
5. **Log/Debug Output**: Configs accidentally logged or included in debug bundles

This qualifies as **HIGH severity** per Aptos bug bounty criteria as it represents a significant protocol violation and enables node impersonation attacks.

## Likelihood Explanation

**Likelihood: MEDIUM-to-HIGH**

The vulnerability is triggered in multiple production code paths:
- All fullnodes created via genesis builder tools embed network identity keys
- Test validators embed both network and consensus keys
- No warning or documentation indicates this security risk

Factors increasing likelihood:
- Common operational security mistakes (backup exposure, git commits) provide attack vectors
- Default file permissions may be world-readable depending on system configuration
- Operators may not realize config files contain sensitive material
- Docker/Kubernetes deployments often have broader file access

Factors decreasing likelihood:
- Mainnet validators properly use `Identity::FromFile` and external secure storage
- Requires attacker to gain read access to the filesystem first
- Most production deployments have some access controls

## Recommendation

**Immediate Fix**: Implement key sanitization in `save_config()` before serialization.

**Option 1 - Skip Serialization of Embedded Keys (Recommended):**

Modify `IdentityFromConfig` to skip serializing the private key:

```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten, skip_serializing)]  // Add skip_serializing
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,
    #[serde(skip)]
    pub source: IdentitySource,
}
```

Similarly for `SafetyRulesTestConfig`:

```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
pub struct SafetyRulesTestConfig {
    pub author: PeerId,
    #[serde(skip_serializing)]  // Add skip_serializing
    pub consensus_key: Option<ConfigKey<bls12381::PrivateKey>>,
    pub waypoint: Option<Waypoint>,
}
```

**Option 2 - Always Use FromFile for Production:**

Modify genesis builder to always write keys to separate identity files instead of embedding them:

```rust
fn set_identity_for_network(network: &mut NetworkConfig, config_dir: &Path) -> anyhow::Result<()> {
    if let Identity::None = network.identity {
        let mut keygen = KeyGen::from_os_rng();
        let key = keygen.generate_x25519_private_key()?;
        let peer_id = aptos_types::account_address::from_identity_public_key(key.public_key());
        
        // Write to separate identity file instead of embedding
        let identity_blob = IdentityBlob {
            account_address: Some(peer_id),
            account_private_key: None,
            consensus_private_key: None,
            network_private_key: key,
        };
        let identity_path = config_dir.join("network-identity.yaml");
        identity_blob.to_file(&identity_path)?;
        
        network.identity = Identity::from_file(identity_path);
    }
    Ok(())
}
```

**Option 3 - Add Warning Documentation:**

Document clearly that configs may contain private keys and should be treated as secrets.

## Proof of Concept

```rust
#[cfg(test)]
mod key_exposure_poc {
    use aptos_config::config::{NodeConfig, OverrideNodeConfig, PersistableConfig, RoleType};
    use aptos_temppath::TempPath;
    use std::fs;

    #[test]
    fn test_private_keys_leaked_in_saved_config() {
        // Create a random validator config with embedded keys
        let mut node_config = NodeConfig::generate_random_config();
        node_config.base.role = RoleType::Validator;
        
        // Wrap in OverrideNodeConfig
        let override_config = OverrideNodeConfig::new_with_default_base(node_config);
        
        // Save to temporary file
        let temp_path = TempPath::new();
        temp_path.create_as_file().unwrap();
        override_config.save_config(temp_path.path()).unwrap();
        
        // Read the saved YAML file
        let saved_content = fs::read_to_string(temp_path.path()).unwrap();
        
        // VULNERABILITY: Config file contains private key material in plaintext
        // Look for x25519 private key (32 bytes hex encoded = 64 chars)
        assert!(
            saved_content.contains("key:") || saved_content.contains("private_key:"),
            "VULNERABILITY CONFIRMED: Private key material found in saved config:\n{}",
            saved_content
        );
        
        // For validators, consensus key is also exposed
        if saved_content.contains("consensus_key") {
            println!("CRITICAL: Consensus private key also exposed!");
        }
        
        println!("Config file content:\n{}", saved_content);
    }
}
```

**Notes**

The vulnerability is confirmed to exist in production code paths. While mainnet validators are protected by using `Identity::FromFile` and secure storage backends, fullnodes universally use embedded keys. The genesis builder's `set_identity_for_network` function creates this vulnerability for all fullnode deployments. Any attacker gaining read access to these config files obtains the node's cryptographic identity, enabling network-level attacks.

### Citations

**File:** config/src/config/override_node_config.rs (L127-133)
```rust
    pub fn get_yaml(&self) -> anyhow::Result<serde_yaml::Value> {
        let config_yaml = serde_yaml::to_value(&self.override_config)?;
        let base_yaml = serde_yaml::to_value(&self.base_config)?;
        diff_override_config_yaml(config_yaml, base_yaml).map(|diff_yaml| {
            diff_yaml.unwrap_or(serde_yaml::Value::Mapping(serde_yaml::Mapping::new()))
        })
    }
```

**File:** config/src/config/override_node_config.rs (L142-152)
```rust
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        let yaml_value = self.get_yaml()?;
        let yaml_string = serde_yaml::to_string(&yaml_value).map_err(|e| {
            Error::Yaml(
                "Unable to serialize override config to yaml. Error: {}".to_string(),
                e,
            )
        })?;
        let yaml_bytes = yaml_string.as_bytes().to_vec();
        Self::write_file(yaml_bytes, output_file)
    }
```

**File:** config/src/config/node_config.rs (L35-92)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NodeConfig {
    #[serde(default)]
    pub admin_service: AdminServiceConfig,
    #[serde(default)]
    pub api: ApiConfig,
    #[serde(default)]
    pub base: BaseConfig,
    #[serde(default)]
    pub consensus: ConsensusConfig,
    #[serde(default)]
    pub consensus_observer: ConsensusObserverConfig,
    #[serde(default)]
    pub dag_consensus: DagConsensusConfig,
    #[serde(default)]
    pub dkg: DKGConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub failpoints: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
    pub jwk_consensus: JWKConsensusConfig,
    #[serde(default)]
    pub logger: LoggerConfig,
    #[serde(default)]
    pub mempool: MempoolConfig,
    #[serde(default)]
    pub netbench: Option<NetbenchConfig>,
    #[serde(default)]
    pub node_startup: NodeStartupConfig,
    #[serde(default)]
    pub peer_monitoring_service: PeerMonitoringServiceConfig,
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
    #[serde(default)]
    pub state_sync: StateSyncConfig,
    #[serde(default)]
    pub storage: StorageConfig,
    #[serde(default)]
    pub transaction_filters: TransactionFiltersConfig,
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
    #[serde(default)]
    pub indexer_db_config: InternalIndexerDBConfig,
}
```

**File:** config/src/config/node_config.rs (L213-226)
```rust
        if node_config.base.role.is_validator() {
            let peer_id = PeerId::random();

            if node_config.validator_network.is_none() {
                let network_config = NetworkConfig::network_with_id(NetworkId::Validator);
                node_config.validator_network = Some(network_config);
            }

            let validator_network = node_config.validator_network.as_mut().unwrap();
            validator_network.random_with_peer_id(rng, Some(peer_id));

            let mut safety_rules_test_config = SafetyRulesTestConfig::new(peer_id);
            safety_rules_test_config.random_consensus_key(rng);
            node_config.consensus.safety_rules.test = Some(safety_rules_test_config);
```

**File:** config/src/config/network_config.rs (L55-73)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
```

**File:** config/src/config/identity_config.rs (L130-139)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** crates/aptos-genesis/src/builder.rs (L250-266)
```rust
    pub fn public_fullnode(
        name: String,
        config_dir: &Path,
        config: OverrideNodeConfig,
        waypoint: &Waypoint,
        genesis: &Transaction,
    ) -> anyhow::Result<Self> {
        let mut fullnode_config = Self::new(name, config_dir, config)?;

        fullnode_config.insert_waypoint(waypoint);
        fullnode_config.insert_genesis(genesis)?;
        fullnode_config.set_identity()?;
        fullnode_config.randomize_ports();
        fullnode_config.save_config()?;

        Ok(fullnode_config)
    }
```

**File:** crates/aptos-genesis/src/builder.rs (L330-349)
```rust
    /// Sets identity for a public full node.  Should only be run on a public full node
    fn set_identity(&mut self) -> anyhow::Result<()> {
        let config = self.config.override_config_mut();

        if config
            .full_node_networks
            .iter()
            .any(|config| config.network_id == NetworkId::Vfn)
        {
            panic!("Shouldn't call set_identity on a Validator full node");
        }

        let public_network = config
            .full_node_networks
            .iter_mut()
            .find(|config| config.network_id == NetworkId::Public)
            .unwrap();

        set_identity_for_network(public_network)?;
        Ok(())
```

**File:** crates/aptos-genesis/src/builder.rs (L402-410)
```rust
fn set_identity_for_network(network: &mut NetworkConfig) -> anyhow::Result<()> {
    if let Identity::None = network.identity {
        let mut keygen = KeyGen::from_os_rng();
        let key = keygen.generate_x25519_private_key()?;
        let peer_id = aptos_types::account_address::from_identity_public_key(key.public_key());
        network.identity = Identity::from_config(key, peer_id);
    }
    Ok(())
}
```

**File:** config/src/config/safety_rules_config.rs (L241-246)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
pub struct SafetyRulesTestConfig {
    pub author: PeerId,
    pub consensus_key: Option<ConfigKey<bls12381::PrivateKey>>,
    pub waypoint: Option<Waypoint>,
}
```

**File:** config/src/config/persistable_config.rs (L43-50)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
    }
```
