# Audit Report

## Title
Unvalidated Peer Storage Capabilities Enable State Synchronization Denial of Service

## Summary
The `identify_serviceable()` function in the Aptos data client trusts peer-reported storage capabilities without validation, allowing malicious peers to advertise false data availability. This causes the client to send requests to peers that cannot fulfill them, resulting in failed synchronization attempts, wasted network resources, and node performance degradation.

## Finding Description

The vulnerability exists in the state synchronization peer selection mechanism. The attack flow is as follows:

**Step 1: Malicious peer sends false capabilities**

When the data client polls peers for their storage summaries, it sends a `GetStorageServerSummary` request. A malicious peer can respond with a crafted `StorageServerSummary` containing false data ranges: [1](#0-0) 

The client directly stores this summary without any validation or sanity checking: [2](#0-1) [3](#0-2) 

**Step 2: Client uses false capabilities for peer selection**

When the client needs to fetch data, `identify_serviceable()` filters peers based on their stored storage summaries: [4](#0-3) 

The `can_service_request` check relies on the peer's self-reported capabilities: [5](#0-4) 

This check delegates to the unvalidated `storage_summary`: [6](#0-5) 

**Step 3: Failed synchronization**

The client sends requests to the malicious peer, which either:
- Times out (peer doesn't respond)
- Returns an error from its server-side moderator
- Returns invalid/incomplete data

This breaks the **State Consistency** invariant by causing failed state synchronization attempts and wasting resources.

**Attack Scenario:**

A malicious peer can advertise that it has:
- Transaction ranges (0, 1000000) when it only has (0, 100)
- A synced_ledger_info at version 1000000 when it's actually at version 100
- False chunk sizes to manipulate request distribution

The client will select this peer for requests in the range it falsely advertises, leading to:
1. Network bandwidth wasted on requests to unserviceable peers
2. Timeout delays waiting for responses that never arrive
3. Client retrying with other peers after failures
4. Cumulative synchronization delays as multiple peers behave maliciously

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria:

1. **Validator node slowdowns**: Nodes experience degraded synchronization performance due to wasted requests and retry delays. If multiple malicious peers coordinate, they can significantly slow down state synchronization across the network.

2. **Significant protocol violations**: The peer capability validation mechanism is bypassed, violating the trust assumptions of the state synchronization protocol.

3. **Resource exhaustion**: Each failed synchronization attempt wastes:
   - Network bandwidth (request/response overhead)
   - CPU cycles (request processing, timeout handling)
   - Time (waiting for timeouts, retrying with other peers)

4. **Potential availability impact**: If enough malicious peers advertise false capabilities, honest nodes may struggle to find reliable peers for synchronization, potentially causing nodes to fall behind and affecting their ability to participate in consensus.

While the peer scoring system eventually penalizes malicious peers, the damage occurs during the initial synchronization attempts before scores drop below the ignore threshold.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
1. Any network peer can send storage summaries in response to polling requests
2. No authentication or validation prevents false capability advertisement
3. The malicious peer only needs to respond to `GetStorageServerSummary` requests with crafted data
4. Multiple malicious peers can coordinate to amplify the impact

**Attack Requirements:**
- Network connectivity to target nodes
- Ability to respond to storage service requests
- No privileged access or validator status required

**Exploitation Complexity: Low**
- Does not require cryptographic vulnerabilities
- Does not require consensus participation
- Simple message manipulation attack

## Recommendation

Implement validation of peer-reported storage summaries to prevent false capability advertisement:

**Solution 1: Cross-validate storage summaries**

When receiving a storage summary from a peer, validate it against known blockchain state:
- Check that advertised versions don't exceed the globally known highest version
- Validate that synced_ledger_info is properly signed and part of the known chain
- Cross-check advertised ranges against multiple peers for consistency

**Solution 2: Implement progressive trust**

Instead of immediately trusting peer capabilities:
- Start with small request ranges to verify peer claims
- Gradually increase trust based on successful responses
- Faster detection of false advertisements through initial probing

**Solution 3: Add sanity checks on storage summary receipt**

In `peer_states.rs`, add validation before storing:

```rust
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Validate the storage summary against known blockchain state
    if let Err(e) = self.validate_storage_summary(&storage_summary) {
        warn!("Rejecting invalid storage summary from peer {:?}: {:?}", peer, e);
        return;
    }
    
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}

fn validate_storage_summary(&self, summary: &StorageServerSummary) -> Result<(), Error> {
    // Check for obviously invalid data ranges
    // Validate synced_ledger_info signatures and chain membership
    // Cross-check against global data summary for plausibility
    Ok(())
}
```

**Solution 4: Penalize false advertisements more aggressively**

Update the scoring system to more heavily penalize peers whose actual responses don't match their advertised capabilities, rather than treating them as generic errors.

## Proof of Concept

```rust
#[tokio::test]
async fn test_malicious_peer_false_capability_advertisement() {
    use aptos_storage_service_types::{
        responses::{CompleteDataRange, DataSummary, ProtocolMetadata, StorageServerSummary},
    };
    use state_sync::aptos_data_client::{AptosDataClient, peer_states::PeerStates};
    use aptos_config::config::AptosDataClientConfig;
    use aptos_types::PeerId;
    
    // Setup: Create a data client with peer states
    let config = Arc::new(AptosDataClientConfig::default());
    let peer_states = Arc::new(PeerStates::new(config.clone()));
    let peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Step 1: Malicious peer advertises false capabilities
    let malicious_summary = StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(create_fake_ledger_info(1_000_000)), // False high version
            transactions: Some(CompleteDataRange::new(0, 1_000_000).unwrap()), // Claims to have 1M txns
            transaction_outputs: Some(CompleteDataRange::new(0, 1_000_000).unwrap()),
            states: Some(CompleteDataRange::new(0, 1_000_000).unwrap()),
            epoch_ending_ledger_infos: Some(CompleteDataRange::new(0, 100).unwrap()),
        },
    };
    
    // Step 2: Client stores the false summary without validation
    peer_states.update_summary(peer, malicious_summary.clone());
    
    // Step 3: Client believes peer can service requests in the false range
    let request = StorageServiceRequest::new(
        DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
            start_version: 500_000,
            end_version: 500_100,
            proof_version: 500_100,
            include_events: false,
        }),
        false,
    );
    
    // Step 4: Verify that can_service_request incorrectly returns true
    let can_service = peer_states.can_service_request(
        &peer,
        TimeService::mock(),
        &request,
    );
    
    assert!(can_service, "Client incorrectly believes malicious peer can service request");
    
    // Step 5: In practice, when the client sends the request, it will:
    // - Timeout (peer doesn't actually have the data)
    // - Receive an error from the peer's server-side moderator
    // - Waste resources and time before retrying with another peer
    
    println!("VULNERABILITY CONFIRMED: Client trusts false peer capabilities");
    println!("Attack impact: Failed synchronization, wasted resources, performance degradation");
}
```

**Notes:**

The vulnerability is systemic and affects all state synchronization paths. The severity increases with the number of coordinated malicious peers, as they can collectively degrade network synchronization performance. The current mitigation (peer scoring) is reactive rather than preventive, allowing damage to occur before detection.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L406-439)
```rust
        let data_request = DataRequest::GetStorageServerSummary;
        let use_compression = data_summary_poller.data_client_config.use_compression;
        let storage_request = StorageServiceRequest::new(data_request, use_compression);

        // Fetch the storage summary for the peer and stop the timer
        let request_timeout = data_summary_poller.data_client_config.response_timeout_ms;
        let result: crate::error::Result<StorageServerSummary> = data_summary_poller
            .data_client
            .send_request_to_peer_and_decode(peer, storage_request, request_timeout)
            .await
            .map(Response::into_payload);

        // Mark the in-flight poll as now complete
        data_summary_poller.in_flight_request_complete(&peer);

        // Check the storage summary response
        let storage_summary = match result {
            Ok(storage_summary) => storage_summary,
            Err(error) => {
                warn!(
                    (LogSchema::new(LogEntry::StorageSummaryResponse)
                        .event(LogEvent::PeerPollingError)
                        .message("Error encountered when polling peer!")
                        .error(&error)
                        .peer(&peer))
                );
                return;
            },
        };

        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L177-179)
```rust
    fn update_storage_summary(&mut self, storage_summary: StorageServerSummary) {
        self.storage_summary = Some(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L200-227)
```rust
    pub fn can_service_request(
        &self,
        peer: &PeerNetworkId,
        time_service: TimeService,
        request: &StorageServiceRequest,
    ) -> bool {
        // Storage services can always respond to data advertisement requests.
        // We need this outer check, since we need to be able to send data summary
        // requests to new peers (who don't have a peer state yet).
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return true;
        }

        // Check if the peer can service the request
        if let Some(peer_state) = self.peer_to_state.get(peer) {
            return match peer_state.get_storage_summary_if_not_ignored() {
                Some(storage_summary) => {
                    storage_summary.can_service(&self.data_client_config, time_service, request)
                },
                None => false, // The peer is temporarily ignored
            };
        }

        // Otherwise, the request cannot be serviced
        false
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-329)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
```

**File:** state-sync/aptos-data-client/src/client.rs (L540-560)
```rust
    fn identify_serviceable(
        &self,
        peers_by_priorities: &BTreeMap<PeerPriority, HashSet<PeerNetworkId>>,
        priority: PeerPriority,
        request: &StorageServiceRequest,
    ) -> HashSet<PeerNetworkId> {
        // Get the peers for the specified priority
        let prospective_peers = peers_by_priorities
            .get(&priority)
            .unwrap_or(&hashset![])
            .clone();

        // Identify and return the serviceable peers
        prospective_peers
            .into_iter()
            .filter(|peer| {
                self.peer_states
                    .can_service_request(peer, self.time_service.clone(), request)
            })
            .collect()
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L621-631)
```rust
    pub fn can_service(
        &self,
        aptos_data_client_config: &AptosDataClientConfig,
        time_service: TimeService,
        request: &StorageServiceRequest,
    ) -> bool {
        self.protocol_metadata.can_service(request)
            && self
                .data_summary
                .can_service(aptos_data_client_config, time_service, request)
    }
```
