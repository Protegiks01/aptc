# Audit Report

## Title
VFN Network Mutual Authentication Not Enforced by Config Sanitizer Allowing Network Isolation Bypass

## Summary
The configuration sanitizer at line 144 fails to enforce mutual authentication for VFN (Validator Full Node) networks in validators' `full_node_networks` configuration. This allows validators to accept unauthenticated connections from any node on their VFN network, violating the intended network segmentation between validators, VFNs, and PFNs. [1](#0-0) 

## Finding Description

The Aptos network architecture enforces three-tier isolation:
- **Validator network**: Validators communicate with mutual authentication
- **VFN network**: Validators accept connections from authorized VFNs  
- **Public network**: Open fullnode communication

Validators configure a VFN network in their `full_node_networks` to accept connections from their associated VFNs. However, the sanitizer has a critical gap:

**The vulnerability chain:**

1. **Default behavior**: VFN networks default to `mutual_authentication = false` because the default is set based on `network_id.is_validator_network()`, which returns false for VFN networks: [2](#0-1) 

2. **Sanitizer gap**: The `sanitize_fullnode_network_configs()` function only checks that fullnode networks don't contain validator network IDs and are unique, but does NOT enforce mutual authentication for VFN networks: [3](#0-2) 

3. **Validator network sanitizer only checks validator_network**: The `sanitize_validator_network_config()` enforces mutual authentication only for the `validator_network` field, not for VFN networks in `full_node_networks`: [4](#0-3) 

4. **Runtime behavior**: When `mutual_authentication = false`, the network uses `MaybeMutual` authentication mode: [5](#0-4) 

5. **Unauthorized access**: In `MaybeMutual` mode, validators accept connections from unknown peers on VFN networks and assign them `PeerRole::ValidatorFullNode`: [6](#0-5) 

**Attack scenario:**
1. Attacker discovers a validator's VFN network endpoint (typically port 6181)
2. Validator is running with standard configuration where VFN network has `mutual_authentication = false` (default)
3. Attacker connects to the VFN network posing as a VFN
4. Validator accepts the connection and grants `ValidatorFullNode` peer role
5. Attacker gains unauthorized access to validator services meant for trusted VFNs

This is confirmed by the standard validator configuration which doesn't specify `mutual_authentication` for VFN networks: [7](#0-6) 

## Impact Explanation

**HIGH Severity** - This meets the "Significant protocol violations" criteria:

- **Network Isolation Violation**: The fundamental security boundary between validators and untrusted nodes is breached
- **Unauthorized Validator Access**: Attackers can connect to validators without proper authorization
- **Potential Information Leakage**: VFN peers may receive validator state, block proposals, or consensus messages not meant for public access
- **Resource Exhaustion**: Malicious peers could exhaust validator connection limits or bandwidth
- **Trust Model Violation**: The three-tier network architecture assumes only authorized VFNs can connect to validators

While not a direct consensus safety violation, this significantly weakens the validator security perimeter and could be chained with other vulnerabilities.

## Likelihood Explanation

**High Likelihood**:

1. **Default configuration vulnerability**: Every validator using default/recommended configs is affected
2. **No warning or error**: The sanitizer silently accepts the misconfiguration
3. **Standard deployment pattern**: Production validators commonly expose VFN networks as shown in the reference configuration
4. **Easy to exploit**: Attacker only needs to discover the VFN endpoint and connect with a standard Aptos client
5. **Low detection risk**: Legitimate VFN connections are expected, making malicious connections hard to distinguish without additional monitoring

## Recommendation

Add VFN network mutual authentication enforcement to the sanitizer:

```rust
// In config/src/config/config_sanitizer.rs, modify sanitize_fullnode_network_configs():

fn sanitize_fullnode_network_configs(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FULLNODE_NETWORKS_SANITIZER_NAME.to_string();
    let fullnode_networks = &node_config.full_node_networks;

    // ... existing checks ...

    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // ... existing validator network check ...

        // NEW: Enforce mutual authentication for VFN networks on validators
        if network_id.is_vfn_network() {
            // If this is a validator node with VFN network, require mutual auth
            if node_type.is_validator() && !fullnode_network_config.mutual_authentication {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "VFN networks on validators must have mutual_authentication enabled!".into(),
                ));
            }
        }

        // ... existing uniqueness check ...
    }

    Ok(())
}
```

Additionally, update the default configuration generation to explicitly set `mutual_authentication: true` for VFN networks.

## Proof of Concept

```rust
#[cfg(test)]
mod test_vfn_mutual_auth_vulnerability {
    use super::*;
    use crate::config::{NodeConfig, NetworkConfig, BaseConfig, RoleType};
    use crate::network_id::NetworkId;

    #[test]
    fn test_validator_vfn_network_without_mutual_auth_passes_sanitizer() {
        // Create a validator config with VFN network but no mutual auth
        let node_config = NodeConfig {
            base: BaseConfig {
                role: RoleType::Validator,
                ..Default::default()
            },
            full_node_networks: vec![NetworkConfig {
                network_id: NetworkId::Vfn,
                mutual_authentication: false, // VULNERABLE: No mutual auth
                ..Default::default()
            }],
            validator_network: Some(NetworkConfig {
                network_id: NetworkId::Validator,
                mutual_authentication: true,
                ..Default::default()
            }),
            ..Default::default()
        };

        // This should FAIL but currently PASSES - demonstrating the vulnerability
        let result = NodeConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet())
        );
        
        // Currently passes when it should fail
        assert!(result.is_ok(), "Sanitizer incorrectly allows VFN without mutual auth");
        
        // After fix, this should fail:
        // assert!(result.is_err(), "Sanitizer should reject VFN without mutual auth");
    }
}
```

**Notes**

The vulnerability exists because the sanitizer was designed to prevent fullnodes from accessing the validator network, but overlooked that validators also need protection when accepting VFN connections. The default value logic in `NetworkConfig::network_with_id()` only enables mutual authentication for validator networks, not VFN networks, creating a dangerous default. This gap allows network isolation bypass that contradicts the intended security architecture where only trusted VFNs should connect to validators.

### Citations

**File:** config/src/config/node_config_loader.rs (L144-144)
```rust
    NodeConfig::sanitize(node_config, node_type, chain_id)
```

**File:** config/src/config/network_config.rs (L136-136)
```rust
        let mutual_authentication = network_id.is_validator_network();
```

**File:** config/src/config/config_sanitizer.rs (L112-154)
```rust
fn sanitize_fullnode_network_configs(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FULLNODE_NETWORKS_SANITIZER_NAME.to_string();
    let fullnode_networks = &node_config.full_node_networks;

    // Verify that the fullnode network configs are not empty for fullnodes
    if fullnode_networks.is_empty() && !node_type.is_validator() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Fullnode networks cannot be empty for fullnodes!".into(),
        ));
    }

    // Check each fullnode network config and ensure uniqueness
    let mut fullnode_network_ids = HashSet::new();
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // Verify that the fullnode network config is not a validator network config
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }

        // Verify that the fullnode network config is unique
        if !fullnode_network_ids.insert(network_id) {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "Each fullnode network config must be unique! Found duplicate: {}",
                    network_id
                ),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/config_sanitizer.rs (L192-197)
```rust
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/noise/handshake.rs (L407-416)
```rust
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
```

**File:** config/src/config/test_data/validator.yaml (L24-38)
```yaml
full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"
```
