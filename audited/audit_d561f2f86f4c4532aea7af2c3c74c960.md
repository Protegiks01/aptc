# Audit Report

## Title
Zero Concurrency Panic: Node Crash Due to CPU Detection Failure in Containerized Environments

## Summary
When `concurrency_level` is set to 0 (default configuration) and the `num_cpus::get()` function returns 0 (which can occur in restrictive containerized environments), the fallback calculation logic contains a critical flaw that results in a zero concurrency level being stored. This causes an immediate panic in `BlockExecutor::new()`, crashing the validator or full node before any block execution can occur.

## Finding Description

The vulnerability exists in a multi-stage concurrency level calculation that breaks the **Deterministic Execution** and **Resource Limits** invariants by causing complete node failure.

**Attack Path:**

1. **Default Configuration**: `ExecutionConfig` defaults to `concurrency_level: 0`, which triggers fallback calculation logic. [1](#0-0) 

2. **First Safeguard - Clamp Operation**: In `aptos-node/src/utils.rs`, when `concurrency_level == 0`, the code calculates a safe default using `.clamp(1, 32)` which ensures a minimum value of 1. [2](#0-1) 

3. **Safeguard Bypass - Min Operation**: However, this clamped value is then passed to `AptosVM::set_concurrency_level_once()`, which performs a secondary operation that **overwrites** the safe value. [3](#0-2) 

4. **Zero Value Storage**: If `num_cpus::get()` returns 0 (possible in containers with CPU limits like `--cpus=0.5`, cgroups restrictions, or CPU detection failures), then `min(1, 0) = 0`, and this zero value is stored in `EXECUTION_CONCURRENCY_LEVEL`.

5. **Value Retrieval**: When blocks need to be executed, `get_concurrency_level()` retrieves this stored zero value (not the fallback default of 1, because the value IS set). [4](#0-3) [5](#0-4) 

6. **Panic Trigger**: When `BlockExecutor::new()` is called with `concurrency_level = 0`, it immediately panics on the assertion check. [6](#0-5) [7](#0-6) 

The panic occurs **before** the sequential execution fallback at line 2557 can be reached, as the constructor fails first. [8](#0-7) 

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria:
- **Validator node crashes**: Complete node failure with immediate panic, preventing all block execution
- **API crashes**: The entire node process terminates, making all APIs unavailable
- **Loss of liveness**: Affected validators cannot participate in consensus, reducing network capacity
- **Protocol violation**: Breaks the availability guarantee that nodes should process transactions

This affects:
- Validators deployed in containerized environments (Docker, Kubernetes) with CPU restrictions
- Full nodes in cloud environments with fractional CPU allocations
- Any deployment where CPU detection fails or returns 0

The impact is **not** Critical severity because:
- No funds are lost or stolen
- No consensus safety violation (only liveness)
- Network recovers when nodes are properly configured
- No permanent state corruption

## Likelihood Explanation

**MEDIUM Likelihood:**

**Triggering Conditions:**
1. Node uses default `concurrency_level: 0` configuration (default for all new deployments)
2. `num_cpus::get()` returns 0 due to:
   - Docker containers with fractional CPU limits (`--cpus=0.5` rounds down)
   - Kubernetes with CPU limits < 1.0 CPU
   - cgroups v1/v2 with restrictive `cpu.cfs_quota_us` settings
   - Virtualized environments with CPU detection failures
   - Corrupted `/proc` or `/sys` filesystems

**Real-World Scenarios:**
- Cloud deployments commonly use fractional CPU allocations for cost optimization
- Container orchestration platforms routinely set CPU limits below 1.0
- The `num_cpus` crate can return 0 in edge cases documented in its issue tracker

**Mitigation Factors:**
- Operators can explicitly set `concurrency_level` to a non-zero value
- Most production deployments allocate â‰¥1 CPU
- Issue is immediately detectable (node crashes on startup when processing first block)

## Recommendation

**Fix Strategy**: Add defensive checks at the point where the vulnerability is introduced.

**Recommended Fix for `aptos-move/aptos-vm/src/aptos_vm.rs`:**

```rust
pub fn set_concurrency_level_once(mut concurrency_level: usize) {
    let num_cpus = num_cpus::get().max(1); // Ensure at least 1 CPU
    concurrency_level = min(concurrency_level, num_cpus);
    // Only the first call succeeds, due to OnceCell semantics.
    EXECUTION_CONCURRENCY_LEVEL.set(concurrency_level).ok();
}
```

**Alternative Fix (More Defensive)**: Also add a check in `utils.rs` to ensure the final value is never 0:

```rust
let effective_concurrency_level = if node_config.execution.concurrency_level == 0 {
    ((num_cpus::get().max(1) / 2) as u16).clamp(1, DEFAULT_EXECUTION_CONCURRENCY_LEVEL)
} else {
    node_config.execution.concurrency_level
};
```

**Additional Safeguard**: Modify `BlockExecutor::new()` to provide a clearer error message instead of panic:

```rust
pub fn new(
    config: BlockExecutorConfig,
    executor_thread_pool: Arc<ThreadPool>,
    transaction_commit_hook: Option<L>,
) -> Self {
    let num_cpus = num_cpus::get().max(1); // Ensure at least 1 CPU
    assert!(
        config.local.concurrency_level > 0,
        "Concurrency level cannot be 0. Detected {} CPUs, configured level: {}. This likely indicates CPU detection failure in a containerized environment.",
        num_cpus,
        config.local.concurrency_level,
    );
    // Rest of the constructor...
}
```

## Proof of Concept

**Rust Test to Reproduce:**

```rust
#[cfg(test)]
mod test_zero_concurrency {
    use super::*;
    
    #[test]
    #[should_panic(expected = "Parallel execution concurrency level")]
    fn test_zero_concurrency_causes_panic() {
        // Simulate the scenario where num_cpus::get() returns 0
        // and concurrency_level calculation results in 0
        
        // Step 1: Simulate utils.rs calculation with num_cpus = 0
        let num_cpus_result = 0; // Simulated failure
        let clamped_value = ((num_cpus_result / 2) as u16).clamp(1, 32);
        // clamped_value is 1
        
        // Step 2: Simulate set_concurrency_level_once with num_cpus = 0
        let final_concurrency = std::cmp::min(clamped_value as usize, num_cpus_result);
        // final_concurrency is 0
        
        // Step 3: Try to create BlockExecutor with concurrency_level = 0
        let config = BlockExecutorConfig {
            local: BlockExecutorLocalConfig {
                blockstm_v2: false,
                concurrency_level: final_concurrency, // 0
                allow_fallback: true,
                discard_failed_blocks: false,
                module_cache_config: BlockExecutorModuleCacheLocalConfig::default(),
            },
            onchain: BlockExecutorConfigFromOnchain::new_no_block_limit(),
        };
        
        // This will panic with the assertion failure
        let thread_pool = Arc::new(
            rayon::ThreadPoolBuilder::new()
                .num_threads(1)
                .build()
                .unwrap()
        );
        
        let _executor = BlockExecutor::<
            MockTransaction, 
            MockTask, 
            MockStateView, 
            NoOpTransactionCommitHook,
            MockTxnProvider,
            ()
        >::new(config, thread_pool, None);
        // Panic occurs here
    }
}
```

**Deployment Reproduction:**

```bash
# Create a Docker container with fractional CPU limit
docker run -it --cpus="0.5" aptos-node:latest

# Or using Kubernetes with CPU limit
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: aptos-node
    resources:
      limits:
        cpu: "500m"  # 0.5 CPUs
```

The node will crash immediately upon attempting to execute its first block with:
```
thread 'main' panicked at 'Parallel execution concurrency level 0 should be between 1 and number of CPUs (0)'
```

**Notes:**
- This vulnerability only affects nodes with default `concurrency_level: 0` configuration in restrictive container environments
- Operators can work around this by explicitly setting `concurrency_level: 1` or higher in the configuration
- The fix should be applied at multiple layers (detection, storage, and usage) for defense in depth
- The issue represents a violation of the fail-safe principle, where a defensive clamp is undone by a subsequent operation

### Citations

**File:** config/src/config/execution_config.rs (L83-84)
```rust
            // use min of (num of cores/2, DEFAULT_CONCURRENCY_LEVEL) as default concurrency level
            concurrency_level: 0,
```

**File:** aptos-node/src/utils.rs (L57-61)
```rust
    let effective_concurrency_level = if node_config.execution.concurrency_level == 0 {
        ((num_cpus::get() / 2) as u16).clamp(1, DEFAULT_EXECUTION_CONCURRENCY_LEVEL)
    } else {
        node_config.execution.concurrency_level
    };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L426-430)
```rust
    pub fn set_concurrency_level_once(mut concurrency_level: usize) {
        concurrency_level = min(concurrency_level, num_cpus::get());
        // Only the first call succeeds, due to OnceCell semantics.
        EXECUTION_CONCURRENCY_LEVEL.set(concurrency_level).ok();
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L436-441)
```rust
    pub fn get_concurrency_level() -> usize {
        match EXECUTION_CONCURRENCY_LEVEL.get() {
            Some(concurrency_level) => *concurrency_level,
            None => 1,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3110-3120)
```rust
        let config = BlockExecutorConfig {
            local: BlockExecutorLocalConfig {
                blockstm_v2: AptosVM::get_blockstm_v2_enabled(),
                concurrency_level: AptosVM::get_concurrency_level(),
                allow_fallback: true,
                discard_failed_blocks: AptosVM::get_discard_failed_blocks(),
                module_cache_config: BlockExecutorModuleCacheLocalConfig::default(),
            },
            onchain: onchain_config,
        };
        self.execute_block_with_config(txn_provider, state_view, config, transaction_slice_metadata)
```

**File:** aptos-move/block-executor/src/executor.rs (L119-132)
```rust
    /// The caller needs to ensure that concurrency_level > 1 (0 is illegal and 1 should
    /// be handled by sequential execution) and that concurrency_level <= num_cpus.
    pub fn new(
        config: BlockExecutorConfig,
        executor_thread_pool: Arc<ThreadPool>,
        transaction_commit_hook: Option<L>,
    ) -> Self {
        let num_cpus = num_cpus::get();
        assert!(
            config.local.concurrency_level > 0 && config.local.concurrency_level <= num_cpus,
            "Parallel execution concurrency level {} should be between 1 and number of CPUs ({})",
            config.local.concurrency_level,
            num_cpus,
        );
```

**File:** aptos-move/block-executor/src/executor.rs (L2556-2597)
```rust

        if self.config.local.concurrency_level > 1 {
            let parallel_result = if self.config.local.blockstm_v2 {
                BLOCKSTM_VERSION_NUMBER.set(2);
                self.execute_transactions_parallel_v2(
                    signature_verified_block,
                    base_view,
                    transaction_slice_metadata,
                    module_cache_manager_guard,
                )
            } else {
                BLOCKSTM_VERSION_NUMBER.set(1);
                self.execute_transactions_parallel(
                    signature_verified_block,
                    base_view,
                    transaction_slice_metadata,
                    module_cache_manager_guard,
                )
            };

            // If parallel gave us result, return it
            if let Ok(output) = parallel_result {
                return Ok(output);
            }

            if !self.config.local.allow_fallback {
                panic!("Parallel execution failed and fallback is not allowed");
            }

            // All logs from the parallel execution should be cleared and not reported.
            // Clear by re-initializing the speculative logs.
            init_speculative_logs(signature_verified_block.num_txns() + 1);

            // Flush all caches to re-run from the "clean" state.
            module_cache_manager_guard
                .environment()
                .runtime_environment()
                .flush_all_caches();
            module_cache_manager_guard.module_cache_mut().flush();

            info!("parallel execution requiring fallback");
        }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L545-550)
```rust
        let executor =
            BlockExecutor::<SignatureVerifiedTransaction, E, S, L, TP, AuxiliaryInfo>::new(
                config,
                executor_thread_pool,
                transaction_commit_listener,
            );
```
