# Audit Report

## Title
Missing Structural Validation in Chunky PVSS Protocol Allows Malformed Transcript Acceptance (Latent Vulnerability - Not Production-Deployed)

## Summary
The chunky PVSS implementation in `weighted_transcriptv2.rs` lacks production-grade validation of ciphertext structure sizes, allowing a malicious dealer to construct transcripts with empty `elgamal_randomness` that produce empty ciphertext arrays (`Cs`) while passing all cryptographic verification checks. **However, this code is not deployed in production** - the actual DKG system uses the DAS protocol which has proper validation.

## Finding Description

The vulnerability exists in the chunky protocol's verification logic but is **not exploitable in the current production system**.

### Root Cause
The `verify` function in `weighted_transcriptv2.rs` only validates outer vector lengths (number of players) but not inner structure sizes: [1](#0-0) 

The critical missing validation is evident from a commented-out assertion in the dealing code: [2](#0-1) 

Structural validation only exists as `debug_assert` statements (compiled out in release builds): [3](#0-2) 

### Attack Mechanism
Due to zip behavior in the ElGamal encryption homomorphism, empty `elgamal_randomness` causes empty ciphertexts: [4](#0-3) 

When `plaintext_randomness` is empty, the zip produces zero elements, resulting in empty `Cs` arrays even with correctly-structured `chunked_plaintexts`.

### Why Validation Passes
1. **Outer length checks pass**: `Cs.len() == num_players` (each player has an entry, albeit empty)
2. **Sigma PoK passes**: Both witness and statement have empty ElGamal components, making the verification equation trivially satisfy
3. **Range proof passes**: Commits to non-empty `chunked_plaintexts` from HKZG component  
4. **LDT passes**: `Vs` remains correctly structured

### Decryption Failure
When validators attempt decryption, the code panics on empty arrays: [5](#0-4) 

With empty `Cs`, accessing `Cs[i]` triggers index out of bounds panic.

## Impact Explanation

**Current Impact: None** - This code is **not used in production**. The actual DKG implementation uses the DAS protocol: [6](#0-5) 

The DAS protocol has proper structural validation via `check_sizes()`: [7](#0-6) [8](#0-7) 

**Theoretical Impact (if deployed)**: High severity - Denial of Service causing validator crashes and DKG failure.

## Likelihood Explanation

**Current Likelihood: Zero** - The vulnerable code path is unreachable because chunky protocol is not integrated into the production DKG system.

**Future Likelihood (if deployed)**: Medium - Requires a malicious dealer (validator) who can craft and submit transcripts.

## Recommendation

If the chunky protocol is ever deployed, add mandatory structural validation in the `verify` function:

```rust
// Add after line 487 in weighted_transcriptv2.rs
fn verify<A: Serialize + Clone>(
    &self,
    sc: &Self::SecretSharingConfig,
    pp: &Self::PublicParameters,
    spks: &[Self::SigningPubKey],
    eks: &[Self::EncryptPubKey],
    sid: &A,
) -> anyhow::Result<()> {
    // Existing outer checks...
    
    // Add structural validation (similar to DAS protocol):
    let expected_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
    for (i, player_cs) in self.subtrs.Cs.iter().enumerate() {
        let weight = sc.get_player_weight(&sc.get_player(i));
        ensure!(
            player_cs.len() == weight,
            "Player {} ciphertexts: expected {}, got {}",
            i, weight, player_cs.len()
        );
        for cs in player_cs {
            ensure!(
                cs.len() == expected_chunks,
                "Expected {} chunks per ciphertext, got {}",
                expected_chunks, cs.len()
            );
        }
    }
    
    ensure!(
        self.subtrs.Rs.len() == sc.get_max_weight(),
        "Randomness arrays: expected {}, got {}",
        sc.get_max_weight(), self.subtrs.Rs.len()
    );
    
    // Continue with existing verification...
}
```

## Proof of Concept

Not applicable - the vulnerability cannot be demonstrated in the current production system as this code is not deployed.

---

## Notes

This finding represents a **latent vulnerability** in unused code. While the security flaw is real and well-documented, it poses **zero current risk** because:

1. Production DKG uses the DAS protocol exclusively
2. The chunky protocol exists only in test/benchmark contexts
3. No configuration mechanism switches between protocols in production

The vulnerability should be fixed if chunky protocol deployment is ever planned, but does not constitute an active security threat to the current Aptos blockchain.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L467-487)
```rust
        if eks.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} encryption keys, but got {}",
                sc.get_total_num_players(),
                eks.len()
            );
        }
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L622-631)
```rust
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));

        if !Cs.is_empty() {
            if let Some(first_key) = self.Rs.first() {
                debug_assert_eq!(
                    first_key.len(),
                    Cs[0].len(),
                    "Number of ephemeral keys does not match the number of ciphertext chunks"
                );
            }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L862-868)
```rust
        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L1023-1027)
```rust
        // debug_assert_eq!(
        //     Cs.len(),
        //     sc.get_total_weight(),
        //     "Number of encrypted chunks must equal number of players"
        // );
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L210-217)
```rust
    chunks_vec
        .iter()
        .zip(correlated_randomness_vec.iter())
        .map(|(chunks, correlated_randomness)| {
            chunks_msm_terms::<C>(pp, ek, chunks, correlated_randomness)
        })
        .collect()
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-38)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L288-288)
```rust
        self.check_sizes(sc)?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L450-452)
```rust
        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }
```
