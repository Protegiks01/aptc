# Audit Report

## Title
Zero Lease Duration Token Renewal Creates Infinite Renewal Loop and Bypasses Token Expiration

## Summary
The `process_token_renew_response()` function does not validate that Vault returns a non-zero lease duration. When `lease_duration=0` is returned, the token renewal logic calculates `next_renewal = now + 0/2 = now`, causing every subsequent operation to trigger a token renewal attempt. This bypasses token expiration mechanisms and prevents security alerts from firing when tokens should expire. [1](#0-0) 

## Finding Description

The vulnerability exists in the automatic token renewal mechanism used by validator nodes for Vault authentication. When `renew_ttl_secs` is configured, the system automatically renews Vault tokens to maintain long-running access to cryptographic keys and secrets. [2](#0-1) 

The critical flaw occurs at the calculation of `next_renewal`: [3](#0-2) 

When Vault returns `lease_duration=0` (which can occur for non-renewable tokens, expired tokens, or due to misconfiguration), the calculation becomes:
- `next_renewal = now + (0 as u64) / 2 = now + 0 = now`

This causes the condition `now >= next_renewal` to always evaluate to true on every subsequent call, triggering:

1. **Infinite Renewal Loop**: Every call to `client()` attempts token renewal, potentially overwhelming the Vault server
2. **Bypassed Expiration**: The token continues to be used indefinitely despite Vault indicating it should not be renewed
3. **Failed Security Alerts**: The system has a fail-safe mechanism that panics on `PermissionDenied` errors to alert operators of token expiration issues, but this never triggers because the token keeps being used [4](#0-3) 

The fuzzing tests explicitly generate arbitrary `lease_duration` values including zero, but no validation exists in production code: [5](#0-4) 

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos bug bounty criteria)

This vulnerability affects validator node security in multiple ways:

1. **Protocol Violation**: Bypasses the authentication token expiration mechanism that is critical for limiting the blast radius of compromised tokens

2. **Security Alert Bypass**: The codebase includes explicit fail-safe logic that panics when storage permission errors occur, specifically to alert operators about token renewal issues. This vulnerability prevents that alert mechanism from ever triggering.

3. **Validator Node Performance Degradation**: Every cryptographic operation (signing, key access) triggers a renewal attempt, potentially causing:
   - Increased latency in consensus operations
   - Network overhead from constant Vault API calls
   - Vault server overload affecting all validators

4. **Unauthorized Access Window**: If an operator attempts to revoke access by reducing a token's TTL to 0, the validator continues using the token indefinitely rather than failing fast

This meets the HIGH severity criteria: "Validator node slowdowns" and "Significant protocol violations"

## Likelihood Explanation

**Likelihood: MEDIUM**

This vulnerability can manifest in several realistic scenarios:

1. **Vault Misconfiguration**: Administrators may configure tokens with 0 TTL thinking they are creating permanent tokens, when Vault actually interprets this as non-renewable

2. **Token Revocation Attempts**: Security teams may attempt to expire tokens by setting TTL to 0, expecting operations to fail immediately

3. **Vault Version Differences**: Different Vault versions or configurations may return `lease_duration=0` in edge cases

4. **Network/Vault Failures**: Transient issues during renewal might cause Vault to return malformed responses with zero durations

The fuzzing test suite explicitly tests this case, indicating it's a recognized edge case that should be handled: [6](#0-5) 

## Recommendation

Add validation in `process_token_renew_response()` to reject zero lease durations: [1](#0-0) 

**Recommended Fix:**
```rust
pub fn process_token_renew_response(resp: Response) -> Result<u32, Error> {
    if resp.ok() {
        let resp: RenewTokenResponse = serde_json::from_str(&resp.into_string()?)?;
        let lease_duration = resp.auth.lease_duration;
        
        // Validate that lease_duration is non-zero to prevent infinite renewal loops
        if lease_duration == 0 {
            return Err(Error::InternalError(
                "Vault returned zero lease_duration for token renewal. Token may be non-renewable or expired.".into()
            ));
        }
        
        Ok(lease_duration)
    } else {
        Err(resp.into())
    }
}
```

Additionally, add a minimum threshold check in the `client()` method to prevent renewal loops even with small non-zero values:

```rust
fn client(&self) -> &Client {
    if self.renew_ttl_secs.is_some() {
        let now = self.time_service.now_secs();
        let next_renewal = self.next_renewal.load(Ordering::Relaxed);
        if now >= next_renewal {
            let result = self.client.renew_token_self(self.renew_ttl_secs);
            if let Ok(ttl) = result {
                // Ensure TTL is at least 2 seconds to prevent renewal loops
                if ttl < 2 {
                    aptos_logger::error!("Token renewal returned insufficient TTL: {}", ttl);
                } else {
                    let next_renewal = now + (ttl as u64) / 2;
                    self.next_renewal.store(next_renewal, Ordering::Relaxed);
                }
            } else if let Err(e) = result {
                aptos_logger::error!("Unable to renew lease: {}", e.to_string());
            }
        }
    }
    &self.client
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_zero_lease_duration {
    use super::*;
    use aptos_vault_client::fuzzing::arb_token_renew_response;
    
    #[test]
    fn test_zero_lease_duration_causes_infinite_renewal() {
        // Create a mock response with lease_duration=0
        let zero_lease_response = RenewTokenResponse {
            auth: RenewTokenAuth {
                lease_duration: 0,
            }
        };
        
        let response_json = serde_json::to_string(&zero_lease_response).unwrap();
        let mock_response = Response::new(200, "OK", &response_json);
        
        // Process the response - should return 0
        let ttl = process_token_renew_response(mock_response).unwrap();
        assert_eq!(ttl, 0);
        
        // Simulate the renewal logic
        let now = 100u64;
        let next_renewal = now + (ttl as u64) / 2;
        
        // This demonstrates the bug: next_renewal equals now
        assert_eq!(next_renewal, now);
        
        // On the very next call, the condition will be true again
        let next_now = now; // Even if time hasn't advanced
        assert!(next_now >= next_renewal); // Will always be true!
    }
    
    #[test]
    fn test_recommended_fix_rejects_zero_lease() {
        let zero_lease_response = RenewTokenResponse {
            auth: RenewTokenAuth {
                lease_duration: 0,
            }
        };
        
        let response_json = serde_json::to_string(&zero_lease_response).unwrap();
        let mock_response = Response::new(200, "OK", &response_json);
        
        // With the fix, this should return an error
        let result = process_token_renew_response_fixed(mock_response);
        assert!(result.is_err());
        
        if let Err(Error::InternalError(msg)) = result {
            assert!(msg.contains("zero lease_duration"));
        }
    }
}
```

**Notes:**

This vulnerability represents a failure of defensive programming against malformed upstream responses. While it requires Vault to return an anomalous response (lease_duration=0), such responses can occur due to misconfiguration, version incompatibilities, or security incidents. The system should validate all external inputs and fail safely rather than entering an infinite loop that bypasses security controls.

### Citations

**File:** secure/storage/vault/src/lib.rs (L586-594)
```rust
/// Processes the response returned by a token renew vault request.
pub fn process_token_renew_response(resp: Response) -> Result<u32, Error> {
    if resp.ok() {
        let resp: RenewTokenResponse = serde_json::from_str(&resp.into_string()?)?;
        Ok(resp.auth.lease_duration)
    } else {
        Err(resp.into())
    }
}
```

**File:** secure/storage/src/vault.rs (L69-84)
```rust
    fn client(&self) -> &Client {
        if self.renew_ttl_secs.is_some() {
            let now = self.time_service.now_secs();
            let next_renewal = self.next_renewal.load(Ordering::Relaxed);
            if now >= next_renewal {
                let result = self.client.renew_token_self(self.renew_ttl_secs);
                if let Ok(ttl) = result {
                    let next_renewal = now + (ttl as u64) / 2;
                    self.next_renewal.store(next_renewal, Ordering::Relaxed);
                } else if let Err(e) = result {
                    aptos_logger::error!("Unable to renew lease: {}", e.to_string());
                }
            }
        }
        &self.client
    }
```

**File:** consensus/safety-rules/src/error.rs (L81-90)
```rust
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
```

**File:** secure/storage/vault/src/fuzzing.rs (L125-143)
```rust
prop_compose! {
    pub fn arb_token_renew_response(
    )(
        status in any::<u16>(),
        status_text in any::<String>(),
        lease_duration in any::<u32>(),
    ) -> Response {
    let auth = RenewTokenAuth {
        lease_duration,
    };
    let renew_token_response = RenewTokenResponse {
        auth,
     };

     let renew_token_response =
            serde_json::to_string::<RenewTokenResponse>(&renew_token_response).unwrap();
     Response::new(status, &status_text, &renew_token_response)
    }
}
```

**File:** secure/storage/vault/src/fuzzing.rs (L348-350)
```rust
        fn process_token_renew_response_proptest(response in arb_token_renew_response()) {
            let _ = process_token_renew_response(response);
        }
```
