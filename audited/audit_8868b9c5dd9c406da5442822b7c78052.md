# Audit Report

## Title
Complete Absence of Policy Enforcement in Secure Storage Backends Allows Unrestricted Access to Consensus Keys

## Summary
The secure storage subsystem defines a comprehensive Policy framework for capability-based access control (Read, Write, Sign, Export, Rotate) but **completely fails to enforce it** across all storage backend implementations. All three backends—InMemoryStorage, OnDiskStorage, and VaultStorage—bypass policy checks entirely, allowing any process with storage access to perform unrestricted cryptographic operations on validator consensus keys.

## Finding Description

The `policy.rs` file defines a structured access control system with Identities, Permissions, and Capabilities: [1](#0-0) 

However, examination of all storage backend implementations reveals **zero enforcement** of these policies:

**InMemoryStorage explicitly declares no permission checks:** [2](#0-1) 

**OnDiskStorage similarly provides no permission checks:** [3](#0-2) 

**VaultStorage acknowledges missing permission enforcement:** [4](#0-3) 

The production initialization code creates storage instances **without any policy parameter or enforcement wrapper:** [5](#0-4) 

Critically, the only policy-aware wrapper (`VaultPolicy`) exists **exclusively in test code** and is never used in production: [6](#0-5) 

These storage backends are used by `PersistentSafetyStorage` to store validator consensus private keys: [7](#0-6) 

Production validator configurations use OnDiskStorage despite README warnings: [8](#0-7) 

The OnDiskStorage implementation stores keys in **plaintext JSON** without encryption: [9](#0-8) 

## Impact Explanation

This finding falls into **High Severity** rather than Critical because exploitation requires privileged access (local filesystem or Vault credentials). However, it represents a significant defense-in-depth failure:

1. **Consensus Key Exposure**: Any process with storage access can export validator consensus private keys
2. **Unauthorized Signing**: Malicious code can sign arbitrary consensus messages without capability checks
3. **Safety Data Manipulation**: Attackers can modify last_voted_round and preferred_round, potentially causing safety violations
4. **No Granular Access Control**: The Policy system promises Read/Write/Sign/Export/Rotate separation but provides none

While filesystem permissions provide the primary security boundary for OnDiskStorage, the complete absence of secondary policy enforcement violates defense-in-depth principles expected in consensus-critical systems.

## Likelihood Explanation

**Likelihood: Medium-High** conditional on initial access:

1. OnDiskStorage is used in documented production configurations
2. Keys stored in plaintext JSON at predictable paths (`/opt/aptos/data/secure-data.json`)
3. No encryption-at-rest for consensus keys
4. Policy enforcement architecture exists but is never activated
5. Any local code execution vulnerability becomes a key extraction path

The README states OnDiskStorage "should not be used in production," yet production Helm charts and Docker configurations explicitly use it. This documentation-implementation mismatch increases risk of misdeployment.

## Recommendation

**Immediate Actions:**

1. **Enforce Policy in All Backends**: Move `VaultPolicy` logic out of test-only code and make policy enforcement mandatory:
   - Wrap all storage instantiations with policy checks
   - Fail initialization if policies are undefined for production backends
   - Implement policy enforcement in `KVStorage` and `CryptoStorage` trait methods

2. **Deprecate OnDiskStorage for Production**: 
   - Add config sanitizer check blocking OnDiskStorage on mainnet (similar to InMemoryStorage)
   - Update Helm charts to use Vault backend exclusively
   - Add encryption-at-rest for any disk-based storage

3. **Complete VaultStorage Policy Integration**:
   - Enable VaultPolicy wrapper by default in production initialization
   - Integrate with Vault's native ACL system for defense-in-depth
   - Require explicit policy definitions in validator configurations

4. **Add Runtime Policy Verification**:
   - Log all storage operations with capability checks
   - Alert on policy violations or missing policy definitions
   - Implement least-privilege by default (deny-all unless explicitly permitted)

## Proof of Concept

```rust
// Exploitation scenario: Direct key extraction bypassing policies
// File: consensus/safety-rules/exploit_demo.rs

use aptos_secure_storage::{KVStorage, CryptoStorage, OnDiskStorage};
use aptos_crypto::bls12381::PrivateKey;
use aptos_global_constants::CONSENSUS_KEY;
use std::path::PathBuf;

fn exploit_policy_bypass() {
    // Attacker gains filesystem access to validator node
    let storage_path = PathBuf::from("/opt/aptos/data/secure-data.json");
    
    // Create storage handle - NO POLICY CHECKS PERFORMED
    let storage = OnDiskStorage::new(storage_path);
    
    // Extract consensus private key - NO CAPABILITY CHECK
    // This should require Export capability, but no enforcement exists
    let consensus_key: PrivateKey = storage
        .get(CONSENSUS_KEY)
        .expect("Failed to read key")
        .value;
    
    println!("Consensus key extracted without policy enforcement: {:?}", 
             consensus_key.public_key());
    
    // Attacker can now:
    // 1. Sign arbitrary consensus messages
    // 2. Participate in consensus as the validator
    // 3. Cause safety violations (double voting)
    // 4. Extract key material for offline attacks
}
```

**Demonstration of missing enforcement:**

```rust
// Expected behavior (NOT IMPLEMENTED):
let storage = OnDiskStorage::new(path);
let policy = Policy::new(vec![
    Permission::new(Identity::User("safety_rules".into()), 
                   vec![Capability::Read, Capability::Sign])
]);
let enforced_storage = PolicyEnforcedStorage::new(storage, policy);

// This SHOULD fail with PermissionDenied but currently succeeds:
let key = enforced_storage.export_private_key(CONSENSUS_KEY);
```

## Notes

**Critical Context:**

1. The Policy system is fully defined with proper type structures but **completely unused** in production code paths
2. The `VaultPolicy` wrapper demonstrates the intended architecture but exists only under `#[cfg(test)]` 
3. Production validator configurations in Helm charts use OnDiskStorage despite README explicitly stating it "should not be used in production environments"
4. The config sanitizer enforces blocking InMemoryStorage on mainnet but does NOT block OnDiskStorage
5. Consensus keys are stored in plaintext JSON with no encryption-at-rest protection

This represents an incomplete security feature where the architecture was designed but enforcement was never implemented, creating a false sense of security for operators who might assume the Policy framework provides protection.

### Citations

**File:** secure/storage/src/policy.rs (L6-58)
```rust
/// Dictates a set of permissions
#[derive(Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
pub struct Policy {
    pub permissions: Vec<Permission>,
}

impl Policy {
    pub fn new(permissions: Vec<Permission>) -> Self {
        Self { permissions }
    }

    pub fn public() -> Self {
        Self::new(vec![Permission::new(Identity::Anyone, vec![
            Capability::Read,
            Capability::Write,
        ])])
    }
}

/// Maps an identity to a set of capabilities
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct Permission {
    pub id: Identity,
    pub capabilities: Vec<Capability>,
}

impl Permission {
    pub fn new(id: Identity, capabilities: Vec<Capability>) -> Self {
        Self { id, capabilities }
    }
}

/// Id represents an internal identifier for a given process. For example, safety_rules or
/// key_manager. It is up to the Storage and its deployment to translate these identifiers into
/// verifiable material. For example, the process running safety_rules may have a token that is
/// intended for only safety_rules to own. The specifics are left to the implementation of the
/// storage backend interface layer.
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Identity {
    User(String),
    Anyone,
    NoOne,
}

/// Represents actions
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Capability {
    Export,
    Read,
    Rotate,
    Sign,
    Write,
}
```

**File:** secure/storage/src/in_memory.rs (L9-14)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** secure/storage/src/vault.rs (L26-32)
```rust
/// VaultStorage utilizes Vault for maintaining encrypted, authenticated data. This
/// version currently matches the behavior of OnDiskStorage and InMemoryStorage. In the future,
/// Vault will be able to create keys, sign messages, and handle permissions across different
/// services. The specific vault service leveraged herein is called KV (Key Value) Secrets Engine -
/// Version 2 (<https://www.vaultproject.io/api/secret/kv/kv-v2.html>). So while Secure Storage
/// calls pointers to data keys, Vault has actually a secret that contains multiple key value
/// pairs.
```

**File:** secure/storage/src/vault.rs (L309-328)
```rust
#[cfg(test)]
pub mod policy {
    use super::*;
    use crate::{Capability, Identity, Policy};
    use aptos_vault_client as vault;

    const APTOS_DEFAULT: &str = "aptos_default";

    /// VaultStorage utilizes Vault for maintaining encrypted, authenticated data. This
    /// version currently matches the behavior of OnDiskStorage and InMemoryStorage. In the future,
    /// Vault will be able to create keys, sign messages, and handle permissions across different
    /// services. The specific vault service leveraged herein is called KV (Key Value) Secrets Engine -
    /// Version 2 (https://www.vaultproject.io/api/secret/kv/kv-v2.html). So while Secure Storage
    /// calls pointers to data keys, Vault has actually a secret that contains multiple key value
    /// pairs.
    pub struct VaultPolicy {
        vault: VaultStorage,
        namespace: Option<String>,
    }

```

**File:** config/src/config/secure_backend_config.rs (L162-195)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
        }
    }
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-80)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L11-17)
```yaml
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```
