# Audit Report

## Title
Governance-Triggered Memory Exhaustion DoS via Malicious DKG Randomness Threshold Configuration

## Summary
A malicious governance proposal can set randomness threshold parameters (secrecy_threshold and reconstruction_threshold) to be nearly identical values, causing the DKG (Distributed Key Generation) weight computation to attempt allocating terabytes to exabytes of memory during epoch transition, resulting in validator crashes and complete network halt.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **No validation in Move randomness config**: The `randomness_config.move` module allows governance to set arbitrary threshold values without validation. [1](#0-0) 

2. **Insufficient gap enforcement in DKG rounding**: While `DKGRounding::new()` ensures a minimum gap between thresholds, it uses `U64F64::DELTA` (approximately 2^-64), which is astronomically small. [2](#0-1) 

3. **Unbounded memory allocation in batch evaluation domain**: When computing DKG weights, the system calculates `total_weight_upper_bound = (n/2 + 2) / (reconstruct_threshold - secrecy_threshold)`. With a gap of ~2^-64 and 65,536 validators, this results in weights on the order of 10^19. [3](#0-2) 

4. **Critical missing validation**: `BatchEvaluationDomain::new()` blindly allocates memory for N roots of unity (32 bytes each) where N is the next power of 2 >= total_weight, without any size checks unlike `EvaluationDomain::new()`. [4](#0-3) 

**Attack Path**:
1. Governance submits proposal to set `secrecy_threshold = 0.5` and `reconstruction_threshold = 0.5` (or any identical/very close values)
2. On next epoch, all validators invoke `DKGRounding::new()` during DKG setup [5](#0-4) 

3. The code adjusts thresholds to ensure minimum gap of DELTA, but this is ~2^-64
4. `total_weight_upper_bound()` computes huge value (order of 10^19 to 10^23)
5. `DKGRoundingProfile::infallible()` fallback is triggered, computing validator weights [6](#0-5) 

6. `WeightedConfigBlstrs::new()` is called with these huge weights [7](#0-6) 

7. `ThresholdConfigBlstrs::new()` calls `BatchEvaluationDomain::new(W)` where W ≈ 10^19 [8](#0-7) 

8. `BatchEvaluationDomain::new()` tries to allocate vector of 2^64 scalars (≈590 exabytes)
9. All validators crash or hang with OOM, network halts completely

## Impact Explanation

This is **Critical Severity** because it causes "Total loss of liveness/network availability" as defined in the bug bounty program. Once the malicious governance proposal takes effect:

- All validators attempting epoch transition will crash during DKG setup
- The network cannot progress past the poisoned epoch
- Recovery requires emergency intervention (likely hardfork to override the configuration)
- Unlike temporary DoS attacks, this persists until manually resolved

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The memory allocation happens outside any gas metering context during validator transaction processing.

## Likelihood Explanation

**Likelihood: Medium to High**

Requirements:
- Governance approval for malicious randomness configuration (requires 50%+ voting power)
- No technical sophistication needed - just set two thresholds to similar values

Mitigating factors:
- Requires governance access (but governance attacks are in scope per the prompt)
- May be detected during proposal review (but no automated validation exists)

Exacerbating factors:
- No input validation in Move or Rust prevents this
- Default fallback to `infallible()` method ensures attack succeeds even if primary algorithm fails
- Affects all validators simultaneously

## Recommendation

Implement validation at multiple layers:

**1. Move-level validation** in `randomness_config.move`:
```move
public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
    // Ensure thresholds are in valid range
    assert!(fixed_point64::greater_or_equal(secrecy_threshold, fixed_point64::create_from_rational(1, 3)), EINVALID_THRESHOLD);
    assert!(fixed_point64::less_or_equal(reconstruction_threshold, fixed_point64::create_from_rational(2, 3)), EINVALID_THRESHOLD);
    
    // Ensure minimum gap (e.g., 1%)
    let min_gap = fixed_point64::create_from_rational(1, 100);
    let gap = fixed_point64::sub(reconstruction_threshold, secrecy_threshold);
    assert!(fixed_point64::greater_or_equal(gap, min_gap), EINVALID_THRESHOLD_GAP);
    
    // ... rest of function
}
```

**2. Rust-level validation** in `total_weight_upper_bound()`:
```rust
pub fn total_weight_upper_bound(...) -> anyhow::Result<usize> {
    // Ensure minimum practical gap (e.g., 0.01 = 1%)
    const MIN_THRESHOLD_GAP: U64F64 = U64F64::from_bits(184467440737095516); // 0.01
    
    let gap = reconstruct_threshold_in_stake_ratio - secrecy_threshold_in_stake_ratio;
    ensure!(gap >= MIN_THRESHOLD_GAP, "Threshold gap too small");
    
    let result = ((n / two + two) / gap).ceil().to_num::<usize>();
    
    // Cap at reasonable maximum (e.g., 10 million)
    const MAX_TOTAL_WEIGHT: usize = 10_000_000;
    ensure!(result <= MAX_TOTAL_WEIGHT, "Computed weight exceeds maximum");
    
    Ok(result)
}
```

**3. Add bounds check** in `BatchEvaluationDomain::new()`:
```rust
pub fn new(n: usize) -> Result<Self, CryptoMaterialError> {
    let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
    
    // Add same check as EvaluationDomain::new()
    if log_N >= Scalar::S as usize {
        return Err(CryptoMaterialError::WrongLengthError);
    }
    
    // Additional practical limit (e.g., 2^28 = 256M)
    const MAX_LOG_N: usize = 28;
    if log_N > MAX_LOG_N {
        return Err(CryptoMaterialError::WrongLengthError);
    }
    
    // ... rest of function
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
#[should_panic(expected = "memory allocation")]
fn test_malicious_threshold_dos() {
    use aptos_types::dkg::real_dkg::rounding::DKGRounding;
    use fixed::types::U64F64;
    
    // Simulate 65,536 validators each with 1 billion APTOS stake
    let validator_stakes: Vec<u64> = vec![1_000_000_000_000_000_000; 65536];
    
    // Malicious thresholds: set them equal to trigger minimum DELTA gap
    let malicious_secrecy = U64F64::from_num(0.5);
    let malicious_reconstruct = U64F64::from_num(0.5); // Will be adjusted to 0.5 + DELTA
    
    // This will attempt to allocate exabytes of memory and crash
    let _rounding = DKGRounding::new(
        &validator_stakes,
        malicious_secrecy,
        malicious_reconstruct,
        None,
    );
    
    // If we reach here without panic/OOM, the vulnerability is fixed
}
```

```move
// Move governance proposal to trigger the attack
script {
    use aptos_framework::randomness_config;
    use aptos_std::fixed_point64;
    
    fun malicious_randomness_config(governance: &signer) {
        // Set identical thresholds to trigger vulnerability
        let config = randomness_config::new_v1(
            fixed_point64::create_from_rational(1, 2),  // 0.5
            fixed_point64::create_from_rational(1, 2),  // 0.5 (should be > secrecy!)
        );
        
        randomness_config::set_for_next_epoch(governance, config);
        // On next epoch, all validators will crash during DKG setup
    }
}
```

## Notes

The vulnerability is subtle because:
- The number of players (validators) IS limited to 65,536 by `MAX_VALIDATOR_SET_SIZE`
- Individual stakes ARE limited by staking configuration  
- However, the **combination** of threshold gap and validator count produces unbounded weight calculations
- The `DELTA` constant (2^-64) was likely chosen as a mathematical minimum, not considering practical DoS implications
- The fallback to `infallible()` method ensures the attack succeeds even if primary validation fails

This demonstrates a critical gap between theoretical correctness (ensuring thresholds are distinct) and practical security (ensuring resource bounds).

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-100)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L34-48)
```rust
pub fn total_weight_upper_bound(
    validator_stakes: &[u64],
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    secrecy_threshold_in_stake_ratio: U64F64,
) -> usize {
    reconstruct_threshold_in_stake_ratio = max(
        reconstruct_threshold_in_stake_ratio,
        secrecy_threshold_in_stake_ratio + U64F64::DELTA,
    );
    let two = U64F64::from_num(2);
    let n = U64F64::from_num(validator_stakes.len());
    ((n / two + two) / (reconstruct_threshold_in_stake_ratio - secrecy_threshold_in_stake_ratio))
        .ceil()
        .to_num::<usize>()
}
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L67-70)
```rust
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L88-96)
```rust
            Err(e) => {
                let profile = DKGRoundingProfile::infallible(
                    validator_stakes,
                    secrecy_threshold_in_stake_ratio,
                    reconstruct_threshold_in_stake_ratio,
                    fast_secrecy_threshold_in_stake_ratio,
                );
                (profile, Some(format!("{e}")), "infallible".to_string())
            },
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L113-153)
```rust
impl BatchEvaluationDomain {
    /// Returns a batch evaluation domain for FFTs of size $1, 2, 4, 8, 16, \ldots n$, where $n$ is the
    /// number of coefficients in the polynomial $f(X) \cdot g(X)$.
    ///
    /// This then allows more efficient fetching of subdomains for any of those sizes than via
    /// `get_evaluation_dom_for_multiplication`.
    #[allow(non_snake_case)]
    pub fn new(n: usize) -> Self {
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);

        let mut omegas = Vec::with_capacity(N);
        omegas.push(Scalar::ONE);

        let mut acc = omega;
        for _ in 1..N {
            omegas.push(acc);
            acc *= omega; // $\omega^i$
        }

        debug_assert_eq!(omegas.len(), N);

        let mut N_inverses = Vec::with_capacity(log_N);
        let mut i = 1u64;
        for _ in 0..=log_N {
            N_inverses.push(Scalar::from(i).invert().unwrap());

            i *= 2;
        }

        debug_assert_eq!(
            N_inverses.last().unwrap().invert().unwrap(),
            Scalar::from(N as u64)
        );

        BatchEvaluationDomain {
            log_N,
            omegas,
            N_inverses,
        }
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L199-224)
```rust
    fn new_public_params(dkg_session_metadata: &DKGSessionMetadata) -> RealDKGPublicParams {
        let randomness_config = dkg_session_metadata
            .randomness_config_derived()
            .unwrap_or_else(OnChainRandomnessConfig::default_enabled);
        let secrecy_threshold = randomness_config
            .secrecy_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_SECRECY_THRESHOLD);
        let reconstruct_threshold = randomness_config
            .reconstruct_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_RECONSTRUCT_THRESHOLD);
        let maybe_fast_path_secrecy_threshold = randomness_config.fast_path_secrecy_threshold();

        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
        let verifier = ValidatorVerifier::new(dkg_session_metadata.dealer_consensus_infos_cloned());
        RealDKGPublicParams {
            session_metadata: dkg_session_metadata.clone(),
            pvss_config,
            verifier: verifier.into(),
        }
    }
```

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L109-132)
```rust
    fn new(t: usize, n: usize) -> anyhow::Result<Self> {
        if t == 0 {
            return Err(anyhow!("expected the reconstruction threshold to be > 0"));
        }

        if n == 0 {
            return Err(anyhow!("expected the number of shares to be > 0"));
        }

        if t > n {
            return Err(anyhow!(
                "expected the reconstruction threshold {t} to be < than the number of shares {n}"
            ));
        }

        let batch_dom = BatchEvaluationDomain::new(n);
        let dom = batch_dom.get_subdomain(n);
        Ok(ThresholdConfigBlstrs {
            t,
            n,
            dom,
            batch_dom,
        })
    }
```
