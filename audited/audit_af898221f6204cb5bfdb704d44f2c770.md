# Audit Report

## Title
Integer Overflow DoS via Unchecked Arithmetic in Transaction Shuffler Configuration

## Summary
The on-chain execution config deserialization lacks validation for `usize` field values in `TransactionShufflerType::UseCaseAware`. When combined with unchecked arithmetic operations in the transaction shuffler, extreme values can trigger integer overflow panics (due to `overflow-checks = true`), causing validator node crashes and network-wide liveness failure.

## Finding Description

The vulnerability exists across two components:

**1. Missing Input Validation at Deserialization** [1](#0-0) [2](#0-1) 

The `TransactionShufflerType::UseCaseAware` variant contains three `usize` fields (`sender_spread_factor`, `platform_use_case_spread_factor`, `user_use_case_spread_factor`) that are deserialized without any bounds validation. [3](#0-2) 

The Move contract only validates that the config vector is non-empty, with no validation of the deserialized content or integer field bounds.

**2. Unchecked Arithmetic Operations** [4](#0-3) [5](#0-4) 

The spread factor values are used in unchecked addition: `self.output_idx + 1 + self.config.sender_spread_factor()`. With `overflow-checks = true` in release profile: [6](#0-5) 

Integer overflow causes a panic rather than wrapping, leading to validator node crashes.

**Attack Scenario:**

1. Attacker gains governance control (or exploits separate governance vulnerability)
2. Crafts malicious `OnChainExecutionConfig` with `TransactionShufflerType::UseCaseAware` where `sender_spread_factor = usize::MAX - 5000`
3. Deploys config via `execution_config::set_for_next_epoch()`
4. At next epoch, validators deserialize and use this config
5. During transaction shuffling, when `output_idx` reaches ~5000+, the addition `output_idx + 1 + (usize::MAX - 5000)` overflows
6. With `overflow-checks = true`, this triggers a panic
7. ALL validators crash simultaneously, causing complete network halt

## Impact Explanation

**Critical Severity** - This qualifies as "Total loss of liveness/network availability" per Aptos bug bounty criteria. When malicious configuration is deployed on-chain, all validators executing the transaction shuffler will panic due to integer overflow, causing simultaneous crashes across the entire validator set. The network cannot produce blocks until validators manually recover and the configuration is corrected through emergency intervention.

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - the overflow panic is an uncontrolled failure mode.

## Likelihood Explanation

**Medium Likelihood**: Requires governance-level access to deploy malicious configuration, which is a high privilege. However, governance compromise is a realistic attack vector, and once deployed, the impact is deterministic and affects all validators. The lack of any input validation makes exploitation straightforward once governance access is obtained.

## Recommendation

Implement validation in both Move and Rust layers:

**Move Layer (execution_config.move):**
Add bounds checking before accepting configuration updates. Example:
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    validate_config_bounds(&config); // New validation function
    config_buffer::upsert(ExecutionConfig { config });
}
```

**Rust Layer (execution_config.rs):**
Add validation method after deserialization:
```rust
impl TransactionShufflerType {
    pub fn validate(&self) -> Result<()> {
        if let TransactionShufflerType::UseCaseAware {
            sender_spread_factor,
            platform_use_case_spread_factor,
            user_use_case_spread_factor,
        } = self {
            const MAX_SPREAD_FACTOR: usize = 1_000_000; // Reasonable upper bound
            ensure!(*sender_spread_factor <= MAX_SPREAD_FACTOR, "sender_spread_factor too large");
            ensure!(*platform_use_case_spread_factor <= MAX_SPREAD_FACTOR, "platform_use_case_spread_factor too large");
            ensure!(*user_use_case_spread_factor <= MAX_SPREAD_FACTOR, "user_use_case_spread_factor too large");
        }
        Ok(())
    }
}
```

**Arithmetic Layer (delayed_queue.rs):**
Use checked arithmetic operations:
```rust
let account_try_delay_till = self.output_idx
    .checked_add(1)
    .and_then(|v| v.checked_add(self.config.sender_spread_factor()))
    .unwrap_or(usize::MAX); // Saturate on overflow instead of panic
```

## Proof of Concept

```rust
#[test]
fn test_integer_overflow_in_transaction_shuffler() {
    use types::on_chain_config::{OnChainExecutionConfig, TransactionShufflerType, ExecutionConfigV7};
    use consensus::transaction_shuffler::use_case_aware::{Config, DelayedQueue};
    
    // Craft malicious config with extreme spread factor
    let malicious_config = OnChainExecutionConfig::V7(ExecutionConfigV7 {
        transaction_shuffler_type: TransactionShufflerType::UseCaseAware {
            sender_spread_factor: usize::MAX - 5000,
            platform_use_case_spread_factor: 0,
            user_use_case_spread_factor: 0,
        },
        // ... other fields ...
    });
    
    // Serialize and deserialize (simulating on-chain storage)
    let bytes = bcs::to_bytes(&malicious_config).unwrap();
    let deserialized: OnChainExecutionConfig = bcs::from_bytes(&bytes).unwrap();
    
    // Create shuffler with malicious config
    let config = Config {
        sender_spread_factor: usize::MAX - 5000,
        platform_use_case_spread_factor: 0,
        user_use_case_spread_factor: 0,
    };
    
    let mut delayed_queue = DelayedQueue::new(config);
    delayed_queue.bump_output_idx(5001);
    
    // This will panic with overflow-checks = true:
    // output_idx (5001) + 1 + (usize::MAX - 5000) = overflow!
    // Expected: panic with "attempt to add with overflow"
}
```

## Notes

The vulnerability requires governance-level access for exploitation, but governance compromise is a documented attack vector. The serde attributes themselves (lines 11, 229, 266, 273) are structurally correct for BCS serialization, but the absence of post-deserialization validation allows malicious values to propagate through the system unchecked, violating defense-in-depth principles for critical consensus-affecting configurations.

### Citations

**File:** types/src/on_chain_config/execution_config.rs (L11-11)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
```

**File:** types/src/on_chain_config/execution_config.rs (L228-240)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum TransactionShufflerType {
    NoShuffling,
    DeprecatedSenderAwareV1(u32),
    SenderAwareV2(u32),
    DeprecatedFairness,
    UseCaseAware {
        sender_spread_factor: usize,
        platform_use_case_spread_factor: usize,
        user_use_case_spread_factor: usize,
    },
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L51-55)
```text
        config_buffer::upsert(ExecutionConfig { config });
    }

    /// Only used in reconfigurations to apply the pending `ExecutionConfig`, if there is any.
    public(friend) fun on_new_epoch(framework: &signer) acquires ExecutionConfig {
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L336-339)
```rust
        account.update_try_delay_till(self.output_idx + 1 + self.config.sender_spread_factor());
        use_case.update_try_delay_till(
            self.output_idx + 1 + self.config.use_case_spread_factor(&use_case_key),
        );
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L482-484)
```rust
        let account_try_delay_till = self.output_idx + 1 + self.config.sender_spread_factor();
        let use_case_try_delay_till =
            self.output_idx + 1 + self.config.use_case_spread_factor(&use_case_key);
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```
