# Audit Report

## Title
Unhandled Panic in Rosetta Account Balance API Due to Invalid Fungible Asset Address

## Summary
The account balance endpoint in the Rosetta API contains an uncaught panic when processing user-supplied fungible asset addresses. While Move function errors are properly caught and converted to `ApiError`, the argument preparation code uses `.unwrap()` on potentially invalid user input, causing a server panic instead of returning a proper error response.

## Finding Description

The security question asks whether Move function errors during view function execution are properly caught. **The answer is YES** - Move VM errors (aborts/panics) are correctly handled through the error chain:
1. `AptosVM::execute_view_function` catches all VM errors and returns `ViewFunctionOutput` [1](#0-0) 
2. The REST API handler converts these to `AptosErrorCode::InvalidInput` [2](#0-1) 
3. The Rosetta client converts `RestError::Api` to appropriate `ApiError` variants [3](#0-2) 

**However**, a related vulnerability exists in the same code path where the vulnerability occurs BEFORE the Move function is called. In the argument preparation code, when handling fungible asset balance queries, the code uses `.unwrap()` on user-supplied address strings without validation: [4](#0-3) 

The `fa_address` field comes from the user's `AccountBalanceRequest.currencies` field, which is deserialized from JSON without validation: [5](#0-4) 

The `Currency.metadata.fa_address` is defined as an optional string with no validation: [6](#0-5) 

**Attack Path:**
1. Attacker sends POST request to `/account/balance` with malformed currency data
2. Request includes `currencies: [{ "symbol": "FAKE", "decimals": 8, "metadata": { "fa_address": "invalid_address" }}]`
3. Code attempts `AccountAddress::from_str("invalid_address").unwrap()`
4. Parse fails and `.unwrap()` panics
5. Server task crashes with panic instead of returning proper error

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos Bug Bounty Program criteria for "API crashes". The impact includes:

- **Service Disruption**: Malicious requests cause the Rosetta API handler task to panic
- **Denial of Service**: An attacker can repeatedly crash API handlers by sending invalid requests
- **Poor Error Handling**: Users receive generic 500 errors instead of informative validation errors

This does NOT affect consensus, validator operation, or blockchain state - only the Rosetta API service availability.

## Likelihood Explanation

**Likelihood: HIGH**

- **Exploitability**: Trivial - requires only crafting a malformed HTTP POST request
- **Privilege Required**: None - any unauthenticated user can call the public API
- **Complexity**: Minimal - attacker only needs to send invalid JSON data
- **Detection**: Difficult - panics may be logged but could be buried in normal traffic

The vulnerability is easily exploitable by any attacker with network access to the Rosetta API endpoint.

## Recommendation

Replace all `.unwrap()` calls with proper error handling that converts parse failures to `ApiError`:

```rust
// In get_base_balances function, lines 333-336
vec![
    bcs::to_bytes(&owner_address)?,
    bcs::to_bytes(
        &AccountAddress::from_str(fa_address)
            .map_err(|e| ApiError::InvalidInput(Some(format!("Invalid fa_address: {}", e))))?
    )?,
]
```

Additionally, consider adding validation when deserializing `Currency` objects to fail fast with clear error messages.

## Proof of Concept

```bash
# Send malicious request to Rosetta API
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": {
      "blockchain": "aptos",
      "network": "testnet"
    },
    "account_identifier": {
      "address": "0x1"
    },
    "currencies": [{
      "symbol": "MALICIOUS",
      "decimals": 8,
      "metadata": {
        "fa_address": "not_a_valid_address"
      }
    }]
  }'

# Expected: Server panics with AccountAddressParseError
# Should return: ApiError::InvalidInput with validation message
```

## Notes

To directly answer the original security question: **Move function errors (panics/aborts) ARE properly caught and converted to ApiError**. The error handling chain through the REST API and Rosetta client is correct for VM errors.

This report documents a **separate but related vulnerability** in the same code path where Rust-level input validation uses `.unwrap()` instead of proper error handling, causing panics before the Move function is ever called.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2690-2729)
```rust
        match execution_result {
            Ok(result) => ViewFunctionOutput::new(Ok(result), gas_used),
            Err(e) => {
                let vm_status = e.clone().into_vm_status();
                match vm_status {
                    VMStatus::MoveAbort { .. } => {},
                    _ => {
                        let message = e
                            .message()
                            .map(|m| m.to_string())
                            .unwrap_or_else(|| e.to_string());
                        return ViewFunctionOutput::new_error_message(
                            message,
                            Some(vm_status.status_code()),
                            gas_used,
                        );
                    },
                }
                let txn_status = TransactionStatus::from_vm_status(
                    vm_status.clone(),
                    vm.features(),
                    vm.gas_feature_version() >= RELEASE_V1_38,
                );
                let execution_status = match txn_status {
                    TransactionStatus::Keep(status) => status,
                    _ => ExecutionStatus::MiscellaneousError(Some(vm_status.status_code())),
                };
                let status_with_abort_info = vm.inject_abort_info_if_available(
                    &module_storage,
                    &traversal_context,
                    &log_context,
                    execution_status,
                );
                ViewFunctionOutput::new_move_abort_error(
                    status_with_abort_info,
                    Some(vm_status.status_code()),
                    gas_used,
                )
            },
        }
```

**File:** api/src/view_function.rs (L163-172)
```rust
    let values = output.values.map_err(|status| {
        let (err_string, vm_error_code) =
            convert_view_function_error(&status, &state_view, &context);
        BasicErrorWith404::bad_request_with_optional_vm_status_and_ledger_info(
            anyhow::anyhow!(err_string),
            AptosErrorCode::InvalidInput,
            vm_error_code,
            Some(&ledger_info),
        )
    })?;
```

**File:** crates/aptos-rosetta/src/error.rs (L269-331)
```rust
impl From<RestError> for ApiError {
    fn from(err: RestError) -> Self {
        match err {
            RestError::Api(err) => match err.error.error_code {
                AptosErrorCode::AccountNotFound => {
                    ApiError::AccountNotFound(Some(err.error.message))
                },
                AptosErrorCode::ResourceNotFound => {
                    ApiError::ResourceNotFound(Some(err.error.message))
                },
                AptosErrorCode::ModuleNotFound => ApiError::ModuleNotFound(Some(err.error.message)),
                AptosErrorCode::StructFieldNotFound => {
                    ApiError::StructFieldNotFound(Some(err.error.message))
                },
                AptosErrorCode::VersionNotFound => {
                    ApiError::VersionNotFound(Some(err.error.message))
                },
                AptosErrorCode::TransactionNotFound => {
                    ApiError::TransactionNotFound(Some(err.error.message))
                },
                AptosErrorCode::TableItemNotFound => {
                    ApiError::TableItemNotFound(Some(err.error.message))
                },
                AptosErrorCode::BlockNotFound => ApiError::BlockNotFound(Some(err.error.message)),
                AptosErrorCode::StateValueNotFound => {
                    ApiError::StateValueNotFound(Some(err.error.message))
                },
                AptosErrorCode::VersionPruned => ApiError::VersionPruned(Some(err.error.message)),
                AptosErrorCode::BlockPruned => ApiError::BlockPruned(Some(err.error.message)),
                AptosErrorCode::InvalidInput => ApiError::InvalidInput(Some(err.error.message)),
                AptosErrorCode::InvalidTransactionUpdate => {
                    ApiError::InvalidInput(Some(err.error.message))
                },
                AptosErrorCode::SequenceNumberTooOld => {
                    ApiError::SequenceNumberTooOld(Some(err.error.message))
                },
                AptosErrorCode::VmError => ApiError::VmError(Some(err.error.message)),
                AptosErrorCode::RejectedByFilter => {
                    ApiError::RejectedByFilter(Some(err.error.message))
                },
                AptosErrorCode::HealthCheckFailed => {
                    ApiError::InternalError(Some(err.error.message))
                },
                AptosErrorCode::MempoolIsFull => ApiError::MempoolIsFull(Some(err.error.message)),
                AptosErrorCode::WebFrameworkError => {
                    ApiError::InternalError(Some(err.error.message))
                },
                AptosErrorCode::BcsNotSupported => ApiError::InvalidInput(Some(err.error.message)),
                AptosErrorCode::InternalError => ApiError::InternalError(Some(err.error.message)),
                AptosErrorCode::ApiDisabled => ApiError::InternalError(Some(err.error.message)),
            },
            RestError::Bcs(_) => ApiError::DeserializationFailed(None),
            RestError::Json(_) => ApiError::DeserializationFailed(None),
            RestError::Http(status_code, err) => ApiError::InternalError(Some(format!(
                "Failed internal API call with HTTP code {}: {:#}",
                status_code, err
            ))),
            RestError::UrlParse(err) => ApiError::InternalError(Some(err.to_string())),
            RestError::Timeout(err) => ApiError::InternalError(Some(err.to_string())),
            RestError::Unknown(err) => ApiError::InternalError(Some(err.to_string())),
        }
    }
}
```

**File:** crates/aptos-rosetta/src/account.rs (L334-335)
```rust
                        bcs::to_bytes(&owner_address).unwrap(),
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
```

**File:** crates/aptos-rosetta/src/types/requests.rs (L36-37)
```rust
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currencies: Option<Vec<Currency>>,
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L177-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```
