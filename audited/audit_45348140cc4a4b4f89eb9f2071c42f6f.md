# Audit Report

## Title
Session File Tampering in CLI Transaction Simulation Allows Malicious State Injection

## Summary
The `dispatch_transaction()` function in the Aptos CLI loads session files for transaction simulation without any integrity validation, allowing attackers to inject malicious state data that produces misleading simulation results.

## Finding Description
When using the `--session` flag with CLI commands, the transaction simulation feature loads session data from user-provided paths without validating file integrity, authenticity, or content safety.

The vulnerability chain is as follows: [1](#0-0) 

This calls: [2](#0-1) 

Which directly loads session files: [3](#0-2) 

The `Config::load_from_file()` performs no validation: [4](#0-3) 

Similarly, `load_delta()` loads state data without integrity checks: [5](#0-4) 

An attacker can create malicious `config.json` and `delta.json` files containing:
- Manipulated account balances and resource states
- Modified remote node URLs (pointing to attacker-controlled nodes)
- Arbitrary state values that mislead developers about transaction behavior

The simulation executes using this tampered data, producing false results that could influence development decisions, security audits, or deployment choices.

## Impact Explanation
This is classified as **Medium Severity** based on the following assessment:

While this vulnerability does NOT directly affect on-chain blockchain state, consensus, or validator operations, it creates a **state inconsistency** between expected and actual simulation behavior. This falls under the Medium severity category: "State inconsistencies requiring intervention."

The impact includes:
- **Misleading Simulation Results**: Developers receive false information about gas costs, transaction outcomes, and state changes
- **Development Decision Manipulation**: Tampered simulations could lead to deploying vulnerable contracts or making incorrect operational decisions
- **Security Audit Compromise**: If simulation results are used in security analysis, tampered data invalidates the audit

However, severity is limited because:
- No direct on-chain impact (local simulation only)
- Requires local file access or social engineering
- Primarily affects development/testing workflows, not production validators

## Likelihood Explanation
**Likelihood: Medium**

The attack is feasible in several scenarios:
1. **Shared Development Environments**: Malicious session files in shared project directories
2. **Supply Chain**: Compromised example/tutorial session files distributed with learning materials
3. **Social Engineering**: Convincing developers to use "helpful" pre-configured session files for testing
4. **Insider Threats**: Malicious team members injecting tampered sessions

The lack of any warning, signature verification, or integrity checking makes exploitation straightforward once an attacker can influence session file contents.

## Recommendation
Implement integrity validation for session files:

```rust
// Add to Session::load()
pub fn load(session_path: impl AsRef<Path>) -> Result<Self> {
    let session_path = session_path.as_ref().to_path_buf();
    
    // Validate session directory permissions
    validate_session_directory_permissions(&session_path)?;
    
    // Load and validate config
    let config_path = session_path.join("config.json");
    let config = Config::load_from_file(&config_path)?;
    validate_config_integrity(&config_path, &config)?;
    
    // Load and validate delta
    let delta_path = session_path.join("delta.json");
    let delta = load_delta(&delta_path)?;
    validate_delta_integrity(&delta_path, &delta)?;
    
    // ... rest of implementation
}

fn validate_session_directory_permissions(path: &Path) -> Result<()> {
    // Check that session files are owned by current user
    // Warn if world-writable
    Ok(())
}

fn validate_config_integrity(path: &Path, config: &Config) -> Result<()> {
    // Check for signature file or checksum
    // Validate remote URLs against allowlist
    // Warn user about untrusted sessions
    Ok(())
}
```

Additional mitigations:
1. **Display Security Warning**: Show prominent warning when loading sessions from untrusted sources
2. **Signature Support**: Allow sessions to be cryptographically signed by trusted parties
3. **Checksum Validation**: Generate and verify checksums for session files
4. **Permission Checks**: Warn if session files have overly permissive access rights

## Proof of Concept

```bash
# Step 1: Create malicious session directory
mkdir -p /tmp/malicious_session

# Step 2: Create tampered config.json
cat > /tmp/malicious_session/config.json << 'EOF'
{
  "base": "Empty",
  "ops": 0
}
EOF

# Step 3: Create malicious delta.json with manipulated state
cat > /tmp/malicious_session/delta.json << 'EOF'
{
  "resource/0x1/0x1::account::Account": "0000c16ff28623000000000000000001c801000000000000"
}
EOF

# Step 4: Use malicious session for simulation
aptos move run \
  --session /tmp/malicious_session \
  --function-id 0x1::coin::transfer \
  --args address:0x2 u64:1000000
  
# Result: Simulation runs with tampered state, showing false balance
# and potentially misleading gas estimates or execution outcomes
```

The vulnerability is confirmed through code analysis showing no validation mechanisms at any stage of session file loading.

**Notes:**
This vulnerability is limited to CLI development tooling and does not affect production blockchain operations, validator consensus, or on-chain state. The primary risk is to development workflows where simulation results inform security-critical decisions.

### Citations

**File:** crates/aptos/src/common/utils.rs (L524-527)
```rust
    if let Some(session_path) = &txn_options_ref.session {
        txn_options_ref
            .simulate_using_session(session_path, payload)
            .await
```

**File:** crates/aptos/src/common/types.rs (L2215-2220)
```rust
    pub async fn simulate_using_session(
        &self,
        session_path: &Path,
        payload: TransactionPayload,
    ) -> CliTypedResult<TransactionSummary> {
        let mut sess = Session::load(session_path)?;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L200-202)
```rust
    pub fn load(session_path: impl AsRef<Path>) -> Result<Self> {
        let session_path = session_path.as_ref().to_path_buf();
        let config = Config::load_from_file(&session_path.join("config.json"))?;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L63-66)
```rust
    pub fn load_from_file(path: &std::path::Path) -> Result<Self> {
        let json = std::fs::read_to_string(path)?;
        let config = serde_json::from_str(&json)?;
        Ok(config)
```

**File:** aptos-move/aptos-transaction-simulation-session/src/delta.rs (L35-37)
```rust
pub fn load_delta(delta_path: &Path) -> Result<HashMap<StateKey, Option<StateValue>>> {
    let json = std::fs::read_to_string(delta_path)?;
    let delta_str: HashMap<HumanReadable<StateKey>, Option<String>> = serde_json::from_str(&json)?;
```
