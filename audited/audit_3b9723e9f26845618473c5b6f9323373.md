# Audit Report

## Title
ZKP Proof Invalidation During JWK Rotation Causes Transaction Validation Failures for Keyless Accounts

## Summary
When JSON Web Keys (JWKs) are updated on-chain, Zero-Knowledge Proof (ZKP) signatures that were created with references to old JWK values become invalid, causing legitimate keyless transactions to fail validation. There is no grace period or transition mechanism to handle JWK rotations, resulting in an availability vulnerability affecting all keyless accounts.

## Finding Description

The Aptos keyless authentication system uses Zero-Knowledge Proofs (ZKPs) to authenticate transactions. During ZKP creation, the system computes a `public_inputs_hash` that includes a hash of the JWK (JSON Web Key) used by the OIDC provider. [1](#0-0) 

This JWK hash is derived from the RSA modulus and exponent of the provider's public key. [2](#0-1) 

When a transaction is submitted for validation, the system retrieves the current on-chain JWK using the issuer and key ID (`kid`) from the JWT header. [3](#0-2) 

The validator then recomputes the public inputs hash using this retrieved JWK. [4](#0-3) 

Finally, the Groth16 proof is verified against this recomputed hash. [5](#0-4) 

**The vulnerability occurs when:**

1. A user creates a ZKP proof off-chain at time T1 using JWK version V1
2. The OIDC provider rotates their keys (as happens regularly for security)
3. Validators observe the new JWK and update on-chain storage to version V2
4. The user submits their transaction at time T3
5. The validator looks up the JWK by `kid` and retrieves V2 (the new key)
6. The recomputed `public_inputs_hash` uses V2's hash, which differs from V1's hash
7. The ZKP verification fails because the proof was created with V1's hash

**Critical code paths demonstrating the issue:**

For federated keyless accounts, the `update_federated_jwk_set` function removes ALL existing JWKs before adding new ones. [6](#0-5) 

For consensus-based JWKs, the `upsert_jwk` function replaces existing JWKs with the same `kid`. [7](#0-6) 

The JWK lookup only uses `issuer` and `kid` - there is no version tracking or historical JWK storage. [8](#0-7) 

The JWT header only contains `kid` and `alg` fields, with no version or timestamp information. [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Significant Protocol Violation**: The keyless authentication protocol fails to maintain availability during routine JWK rotations, violating the expectation that valid proofs created within their expiry window should be accepted.

2. **Widespread Impact**: ALL keyless accounts are affected during JWK rotation windows, not just a subset of users.

3. **Transaction Validation Failures**: Legitimate transactions fail validation despite being correctly constructed, causing denial of service for keyless users.

4. **No Recovery Mechanism**: Users have no way to make their transactions succeed except to regenerate the entire ZKP proof with the new JWK, which requires re-authenticating with the OIDC provider.

5. **Validator Node Impact**: Validators waste computational resources validating proofs that will inevitably fail due to JWK mismatches.

While this doesn't qualify as Critical (no fund loss or consensus violation), it represents a significant availability issue affecting a core authentication mechanism.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence:

1. **Regular JWK Rotations**: OIDC providers (Google, Facebook, Apple, etc.) rotate their signing keys regularly for security best practices, typically every few months or on-demand if keys are compromised.

2. **Transaction Latency**: There is inherent latency between ZKP proof creation and transaction submission (network delays, user actions, mempool queuing). During this window, JWKs can be updated.

3. **No Grace Period**: The system provides no overlap period where both old and new JWKs are accepted, maximizing the likelihood of failures.

4. **Automatic Updates**: Validators automatically update JWKs through consensus, making rotations inevitable and outside user control.

5. **Ephemeral Key Lifespan**: ZKP proofs can be valid for up to the configured maximum expiration horizon (e.g., 10 days), meaning proofs created near the start of this period are highly likely to encounter a JWK rotation before submission.

## Recommendation

Implement a **JWK versioning and grace period mechanism**:

1. **Add Version Tracking**: Extend the `ProviderJWKs` struct to maintain a versioned history of JWKs, not just the current version number.

2. **Grace Period Storage**: When a JWK is updated, keep the old JWK available for a configured grace period (e.g., 24-48 hours) to allow in-flight transactions to complete.

3. **Multi-JWK Lookup**: Modify the validation logic to attempt verification with both current and recent historical JWKs:

```rust
// In keyless_validation.rs, modify get_jwk_for_authenticator to:
// 1. Try current JWK
// 2. If verification fails, try recent historical JWKs within grace period
// 3. Only fail if no historical JWK produces a valid proof
```

4. **Enhanced Move Module**: Update `jwks.move` to maintain a bounded history:

```move
// Add to ProviderJWKs struct:
struct ProviderJWKs {
    issuer: vector<u8>,
    version: u64,
    jwks: vector<JWK>,
    // New field:
    historical_jwks: vector<HistoricalJWK>,
}

struct HistoricalJWK {
    jwk: JWK,
    deprecated_epoch: u64, // When it was replaced
}
```

5. **Cleanup Policy**: Implement automatic cleanup of historical JWKs beyond the grace period to prevent unbounded growth.

6. **Documentation**: Clearly document the grace period in the keyless authentication specification so users and dApp developers understand the timing constraints.

## Proof of Concept

```rust
// Reproduction steps (can be implemented as a Rust integration test):

// Step 1: Setup - Deploy initial JWK for issuer "https://accounts.google.com"
let initial_jwk = RSA_JWK {
    kid: "key_id_v1".to_string(),
    kty: "RSA".to_string(),
    alg: "RS256".to_string(),
    e: "AQAB".to_string(),
    n: "initial_modulus_v1".to_string(),
};
update_federated_jwk_set(&jwk_owner, issuer, vec![initial_jwk]);

// Step 2: User creates a ZKP proof off-chain with JWK v1
let sig = create_keyless_signature_with_jwk(&user, &initial_jwk);
let txn = create_keyless_transaction(&user, sig);

// Step 3: Simulate JWK rotation - update on-chain JWK
let rotated_jwk = RSA_JWK {
    kid: "key_id_v1".to_string(), // Same kid
    kty: "RSA".to_string(),
    alg: "RS256".to_string(),
    e: "AQAB".to_string(),
    n: "new_modulus_v2".to_string(), // Different modulus!
};
update_federated_jwk_set(&jwk_owner, issuer, vec![rotated_jwk]);

// Step 4: User submits transaction
let result = submit_transaction(txn);

// Expected: Transaction should succeed (proof was valid when created)
// Actual: Transaction FAILS with "Proof verification failed"
assert!(result.is_err());
assert_eq!(result.unwrap_err().status_code(), StatusCode::INVALID_SIGNATURE);

// The failure occurs because:
// - ZKP proof was created with hash of initial_jwk
// - Validator recomputes hash with rotated_jwk
// - Hashes don't match, proof verification fails
```

**Move Test Scenario:**

```move
#[test(framework = @aptos_framework, jwk_owner = @0x123)]
fun test_jwk_rotation_breaks_valid_proofs(framework: &signer, jwk_owner: &signer) {
    // 1. Install initial JWK set
    let initial_jwks = create_jwk_set(b"kid_v1", b"modulus_v1");
    jwks::update_federated_jwk_set(jwk_owner, b"https://issuer.com", initial_jwks);
    
    // 2. Create keyless account and signature with initial JWK
    // (signature creation happens off-chain, hash includes modulus_v1)
    
    // 3. Rotate JWK on-chain (same kid, different modulus)
    let rotated_jwks = create_jwk_set(b"kid_v1", b"modulus_v2");
    jwks::update_federated_jwk_set(jwk_owner, b"https://issuer.com", rotated_jwks);
    
    // 4. Attempt to submit transaction with signature created in step 2
    // Expected: Should fail validation even though signature was valid when created
    // This demonstrates the vulnerability
}
```

## Notes

This vulnerability affects the core availability guarantees of the keyless authentication system. While it doesn't result in fund loss or consensus violations, it represents a significant usability and availability issue that impacts all keyless account users during routine security operations (JWK rotations).

The root cause is the lack of temporal awareness in the ZKP verification process - the system assumes JWKs are immutable, but in practice, they rotate regularly for security reasons. The fix requires adding versioning and grace period support to bridge the gap between proof creation and verification time.

### Citations

**File:** types/src/keyless/bn254_circom.rs (L268-277)
```rust
pub fn cached_jwk_hash(jwk: &RSA_JWK) -> anyhow::Result<Fr> {
    match JWK_HASH_CACHE.get(jwk) {
        None => {
            let hash = jwk.to_poseidon_scalar()?;
            JWK_HASH_CACHE.insert(jwk.clone(), hash);
            Ok(hash)
        },
        Some(hash) => Ok(hash),
    }
}
```

**File:** types/src/keyless/bn254_circom.rs (L317-317)
```rust
    let jwk_hash = cached_jwk_hash(jwk)?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-126)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-316)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L347-362)
```rust
                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());

                        result.map_err(|_| {
                            // println!("[aptos-vm][groth16] ZKP verification failed");
                            // println!("[aptos-vm][groth16] PIH: {}", public_inputs_hash);
                            // match zksig.proof {
                            //     ZKP::Groth16(proof) => {
                            //         println!("[aptos-vm][groth16] ZKP: {}", proof.hash());
                            //     },
                            // }
                            // println!(
                            //     "[aptos-vm][groth16] PVK: {}",
                            //     Groth16VerificationKey::from(pvk).hash()
                            // );
                            invalid_signature!("Proof verification failed")
                        })?;
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L626-654)
```text
    fun upsert_jwk(set: &mut ProviderJWKs, jwk: JWK): Option<JWK> {
        let found = false;
        let index = 0;
        let num_entries = vector::length(&set.jwks);
        while (index < num_entries) {
            let cur_entry = vector::borrow(&set.jwks, index);
            let comparison = compare_u8_vector(get_jwk_id(&jwk), get_jwk_id(cur_entry));
            if (is_greater_than(&comparison)) {
                index = index + 1;
            } else {
                found = is_equal(&comparison);
                break
            }
        };

        // Now if `found == true`, `index` points to the JWK we want to update/remove; otherwise, `index` points to
        // where we want to insert.
        let ret = if (found) {
            let entry = vector::borrow_mut(&mut set.jwks, index);
            let old_entry = option::some(*entry);
            *entry = jwk;
            old_entry
        } else {
            vector::insert(&mut set.jwks, index, jwk);
            option::none()
        };

        ret
    }
```

**File:** types/src/jwks/mod.rs (L231-237)
```rust
    pub fn get_jwk(&self, iss: &str, kid: &str) -> anyhow::Result<&JWKMoveStruct> {
        let provider_jwk_set = self
            .get_provider_jwks(iss)
            .context("JWK not found for issuer")?;
        let jwk = provider_jwk_set.get_jwk(kid)?;
        Ok(jwk)
    }
```

**File:** types/src/keyless/mod.rs (L186-190)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct JWTHeader {
    pub kid: String,
    pub alg: String,
}
```
