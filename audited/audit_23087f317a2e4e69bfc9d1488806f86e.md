# Audit Report

## Title
Node Startup Panic with Empty Database and Non-Genesis Waypoint Prevents Network Participation

## Summary
The `fetch_chain_id()` function panics when called on an empty database during node startup, preventing nodes from joining existing networks. This occurs when a node starts with an empty database and a non-genesis waypoint, a standard configuration for fullnodes syncing to mainnet or testnet.

## Finding Description

During node initialization, the startup sequence requires the chain ID to be fetched from the database before state synchronization can begin. However, this creates a critical ordering issue: [1](#0-0) 

The `fetch_chain_id()` function unconditionally expects the `ChainIdResource` to exist in the database: [2](#0-1) 

The genesis application logic in `maybe_bootstrap()` only applies genesis when the database version matches the waypoint version: [3](#0-2) 

**Attack Path:**

1. A new fullnode joins the network with:
   - Empty database (version = None â†’ 0 via `map_or`)
   - Genesis blob configured (`genesis.blob`)
   - Non-genesis waypoint (e.g., version 1,000,000 pointing to current network state)

2. During `initialize_database_and_checkpoints()`, the `maybe_apply_genesis()` function is called: [4](#0-3) 

3. The `maybe_bootstrap()` function checks if DB version (0) equals waypoint version (1,000,000), finds they don't match, skips genesis, and returns `Ok(None)`: [5](#0-4) 

4. The database remains empty (no ChainIdResource)

5. `fetch_chain_id()` is called, which uses `.expect()` on the missing resource, causing a panic: [6](#0-5) 

This prevents the node from starting and joining the network through state synchronization.

**Even in Fast Sync Mode:**

When fast sync is enabled, the code creates a temporary database for genesis and expects it to contain the genesis ledger info: [7](#0-6) 

However, if the waypoint is non-genesis, the `maybe_apply_genesis()` call at line 77 skips genesis, and the `.expect()` at line 84 panics with "Genesis ledger info must exist".

## Impact Explanation

**High Severity** - This vulnerability affects node availability and network participation:

- **Validator Node Slowdowns/Crashes**: New validator nodes cannot start, preventing network expansion and affecting decentralization
- **API Crashes**: Fullnode API services cannot start, impacting ecosystem applications
- **Significant Protocol Violation**: Breaks the fundamental ability of nodes to join the network

The issue prevents proper initialization of any node starting from an empty state with a non-genesis waypoint, which is the standard configuration for joining existing networks (mainnet, testnet). This affects:
- New fullnode operators
- Nodes recovering from data loss
- Fresh deployments in production environments

## Likelihood Explanation

**High Likelihood** - This issue occurs in standard deployment scenarios:

- **No attacker required**: Natural consequence of correct configuration
- **Affects legitimate use case**: Standard procedure for joining existing networks
- **Simple reproduction**: Empty database + genesis.blob + non-genesis waypoint
- **Production impact**: Mainnet/testnet fullnodes use non-genesis waypoints by design

While the config optimizer enables fast sync for mainnet/testnet, both code paths (fast sync and non-fast sync) contain panic conditions when genesis is skipped.

## Recommendation

Modify `fetch_chain_id()` to handle missing ChainIdResource gracefully by extracting it from the genesis transaction when the database is empty:

```rust
pub fn fetch_chain_id(db: &DbReaderWriter, node_config: &NodeConfig) -> anyhow::Result<ChainId> {
    let db_state_view = db
        .reader
        .latest_state_checkpoint_view()
        .map_err(|err| anyhow!("[aptos-node] failed to create db state view {}", err))?;
    
    // Try to fetch from database first
    if let Some(chain_id_resource) = ChainIdResource::fetch_config(&db_state_view) {
        return Ok(chain_id_resource.chain_id());
    }
    
    // If DB is empty, extract from genesis transaction
    if let Some(genesis_txn) = get_genesis_txn(node_config) {
        // Extract ChainId from genesis transaction
        if let Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) = genesis_txn {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;
            if let Some(write_op) = change_set.write_set().get(&chain_id_state_key) {
                if let WriteOp::Modification(bytes) | WriteOp::Creation(bytes) = write_op {
                    let chain_id = bcs::from_bytes::<ChainId>(bytes)?;
                    return Ok(chain_id);
                }
            }
        }
    }
    
    Err(anyhow!("[aptos-node] missing chain ID resource and cannot extract from genesis"))
}
```

Alternatively, modify the genesis application logic to always apply genesis to a temporary/in-memory state for chain ID extraction, or make chain ID a required configuration parameter.

## Proof of Concept

```rust
// Reproduction steps (Rust test):
#[test]
fn test_empty_db_non_genesis_waypoint_panic() {
    use aptos_config::config::NodeConfig;
    use aptos_storage_interface::DbReaderWriter;
    use aptos_types::waypoint::Waypoint;
    use tempfile::TempDir;
    
    // Create node config with genesis and non-genesis waypoint
    let mut node_config = NodeConfig::default();
    let temp_dir = TempDir::new().unwrap();
    node_config.set_data_dir(temp_dir.path().to_path_buf());
    
    // Set non-genesis waypoint (version > 0)
    let non_genesis_waypoint = Waypoint::new_any(&LedgerInfo::new(...)); // version 1000000
    node_config.base.waypoint = WaypointConfig::FromConfig(non_genesis_waypoint);
    
    // Load genesis transaction
    let genesis_txn = vm_genesis::generate_test_genesis(...);
    node_config.execution.genesis = Some(genesis_txn);
    
    // Initialize empty database
    let (db_rw, ..) = storage::initialize_database_and_checkpoints(&mut node_config)
        .expect("DB initialization should succeed");
    
    // This panics with "[aptos-node] missing chain ID resource"
    let result = utils::fetch_chain_id(&db_rw);
    assert!(result.is_err()); // Currently panics before this assertion
}
```

**Notes**

This vulnerability demonstrates a critical initialization ordering flaw where the node requires chain ID before state sync can populate the database, but the chain ID exists only in the database. The issue is compounded by the waypoint verification logic that intentionally skips genesis when the waypoint points to a later version, which is standard for nodes joining existing networks. Both fast-sync and non-fast-sync paths contain panic conditions, making this a systemic issue affecting node availability and network participation.

### Citations

**File:** aptos-node/src/lib.rs (L704-713)
```rust
    let (db_rw, backup_service, genesis_waypoint, indexer_db_opt, update_receiver) =
        storage::initialize_database_and_checkpoints(&mut node_config)?;

    admin_service.set_aptos_db(db_rw.clone().into());

    // Set the Aptos VM configurations
    utils::set_aptos_vm_configurations(&node_config);

    // Obtain the chain_id from the DB
    let chain_id = utils::fetch_chain_id(&db_rw)?;
```

**File:** aptos-node/src/utils.rs (L42-50)
```rust
pub fn fetch_chain_id(db: &DbReaderWriter) -> anyhow::Result<ChainId> {
    let db_state_view = db
        .reader
        .latest_state_checkpoint_view()
        .map_err(|err| anyhow!("[aptos-node] failed to create db state view {}", err))?;
    Ok(ChainIdResource::fetch_config(&db_state_view)
        .expect("[aptos-node] missing chain ID resource")
        .chain_id())
}
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L48-59)
```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```

**File:** aptos-node/src/storage.rs (L23-42)
```rust
pub(crate) fn maybe_apply_genesis(
    db_rw: &DbReaderWriter,
    node_config: &NodeConfig,
) -> Result<Option<LedgerInfoWithSignatures>> {
    // We read from the storage genesis waypoint and fallback to the node config one if it is none
    let genesis_waypoint = node_config
        .execution
        .genesis_waypoint
        .as_ref()
        .unwrap_or(&node_config.base.waypoint)
        .genesis_waypoint();
    if let Some(genesis) = get_genesis_txn(node_config) {
        let ledger_info_opt =
            maybe_bootstrap::<AptosVMBlockExecutor>(db_rw, genesis, genesis_waypoint)
                .map_err(|err| anyhow!("DB failed to bootstrap {}", err))?;
        Ok(ledger_info_opt)
    } else {
        info ! ("Genesis txn not provided! This is fine only if you don't expect to apply it. Otherwise, the config is incorrect!");
        Ok(None)
    }
```

**File:** aptos-node/src/storage.rs (L75-84)
```rust
        Either::Right(fast_sync_db_wrapper) => {
            let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
            maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
            let (db_arc, db_rw) = DbReaderWriter::wrap(fast_sync_db_wrapper);
            let fast_sync_db = db_arc.get_fast_sync_db();
            // FastSyncDB requires ledger info at epoch 0 to establish provenance to genesis
            let ledger_info = db_arc
                .get_temporary_db_with_genesis()
                .get_epoch_ending_ledger_info(0)
                .expect("Genesis ledger info must exist");
```
