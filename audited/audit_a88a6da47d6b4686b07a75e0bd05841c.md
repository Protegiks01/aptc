# Audit Report

## Title
InputSecret Generation Lacks Verifiable Randomness - Byzantine Validators Can Inject Bias into DKG Output

## Summary
The DKG (Distributed Key Generation) protocol does not verify that validators generate their `InputSecret` values randomly. Malicious validators can deliberately choose biased `InputSecret` values, pass all PVSS verification checks, and influence the final shared randomness used for consensus operations, violating the explicit security guarantee that "randomness cannot be biased in any way by validators." [1](#0-0) 

## Finding Description

The DKG protocol generates shared randomness through PVSS (Publicly Verifiable Secret Sharing) where each validator contributes an `InputSecret`. The security claim states randomness cannot be biased by validators, but the implementation has no mechanism to verify `InputSecret` generation was truly random.

**The Vulnerability Chain:**

1. **InputSecret Generation (No Proof of Randomness):** Each validator generates an `InputSecret` locally using their own RNG: [2](#0-1) 

2. **PVSS Verification (Insufficient Checks):** The transcript verification only checks:
   - Proof of Knowledge (PoK) - proves the dealer knows the secret
   - Range proofs - proves shares are in valid range  
   - Low-degree tests - proves polynomial properties [3](#0-2) 

**None of these proofs verify the secret was randomly generated.** A malicious validator can choose any specific `InputSecret` value, create a valid PVSS transcript with proper PoK/range proofs, and pass verification.

3. **Transcript Aggregation (Additive Combination):** The final shared secret is computed by adding all validators' input secrets: [4](#0-3) 

4. **No Commit-Reveal Protection:** The protocol uses immediate broadcast without commitment phase, and explicitly allows equivocation: [5](#0-4) 

This means validators can observe other transcripts via reliable broadcast before finalizing their own contribution, enabling last-actor attacks.

**Attack Scenario:**
1. Byzantine validator observes honest validators' transcripts via reliable broadcast
2. Computes desired bias and generates corresponding non-random `InputSecret`  
3. Creates valid PVSS transcript with all required cryptographic proofs
4. Passes verification and influences final shared randomness
5. Biased randomness affects leader election, WVUF evaluations, and consensus decisions

## Impact Explanation

**High Severity** - This constitutes a significant protocol violation breaking the core security guarantee of the randomness subsystem.

The explicit security claim in the randomness module states: [6](#0-5) 

This vulnerability breaks invariant #10 (Cryptographic Correctness) as the VRF/WVUF system is built on a foundation that can be biased by validators. While the Byzantine threshold assumption (< 1/3 malicious validators) provides some statistical protection, the implementation fails to match its stated absolute guarantee that randomness "cannot be biased **in any way** by validators."

Potential impacts include:
- Biased leader selection favoring colluding validators
- Manipulation of any consensus decisions dependent on randomness
- Violation of fairness properties in randomness-dependent applications
- Undermining trust in the randomness subsystem's security claims

## Likelihood Explanation

**Medium-High Likelihood:**
- Any validator can execute this attack unilaterally
- No additional cryptographic capabilities required
- The reliable broadcast mechanism enables observation of peer transcripts
- Attack is undetectable as biased transcripts appear cryptographically valid
- No on-chain evidence distinguishes malicious from honest transcript generation

The explicit allowance for equivocation increases exploitability as validators can generate multiple candidate transcripts and select strategically.

## Recommendation

Implement **verifiable randomness generation** for `InputSecret` values using one of these approaches:

**Option 1: VDF-based Commitment**
Require validators to commit to their `InputSecret` before seeing others' commitments, using a Verifiable Delay Function (VDF) to ensure pre-commitment:

```rust
// In dkg_manager/mod.rs, add commitment phase before dealing:
let commitment = vdf_commit(&input_secret);
// Broadcast commitment first, wait for quorum
// Then reveal input_secret with proof it matches commitment
```

**Option 2: Fiat-Shamir Randomness Derivation**  
Derive `InputSecret` deterministically from verifiable sources using Fiat-Shamir:

```rust
// Derive from validator's signing key + epoch + public randomness beacon
let input_secret_bytes = hash(
    signing_key.to_bytes() || 
    epoch.to_le_bytes() || 
    previous_epoch_randomness
);
let input_secret = DKG::InputSecret::from_bytes(&input_secret_bytes);
```

**Option 3: Add Proof of Correct Generation**
Extend PVSS proofs to include zero-knowledge proof that `InputSecret` was generated from specified entropy source.

**Minimum Fix:** Update documentation to accurately reflect that validators CAN influence randomness under the Byzantine threshold model, removing the absolute guarantee.

## Proof of Concept

```rust
// Malicious validator in dkg_manager/mod.rs can replace:
let input_secret = DKG::InputSecret::generate(&mut rng);

// With biased generation:
let biased_value = Scalar::from(0x1337); // Chosen constant
let input_secret = InputSecret { a: biased_value };

// Generate transcript - all PVSS proofs will still verify:
let trx = DKG::generate_transcript(
    &mut rng,
    &public_params, 
    &input_secret,  // Uses biased secret
    self.my_index as u64,
    &self.dealer_sk,
    &self.dealer_pk,
);
// This transcript passes all verification checks despite biased input
```

**Verification Test:**
```rust
#[test]
fn test_biased_input_secret_passes_verification() {
    // Setup DKG with malicious validator using fixed InputSecret
    let biased_secret = InputSecret { a: Scalar::from(0x42) };
    let transcript = generate_transcript(..., &biased_secret, ...);
    
    // Verify transcript passes all checks despite bias
    assert!(verify_transcript(&params, &transcript).is_ok());
    
    // Aggregate with honest transcripts
    let mut agg = honest_transcript.clone();
    aggregate_transcripts(&params, &mut agg, transcript);
    
    // Final secret is influenced by bias
    // Statistical tests would show non-uniformity with multiple trials
}
```

## Notes

While the Byzantine threshold assumption (2f+1 honest out of 3f+1 total) provides some protection—as honest validators' random contributions mask individual biases statistically—the implementation fails to meet its explicit security claim. Standard DKG protocols address this through commit-reveal schemes or verifiable randomness generation. The current design's reliance solely on honest majority statistical properties is weaker than the documented guarantee and creates exploitable attack surface for strategic validator behavior.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/randomness.move (L1-7)
```text
/// This module provides access to *instant* secure randomness generated by the Aptos validators, as documented in
/// [AIP-41](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-41.md).
///
/// Secure randomness means (1) the randomness cannot be predicted ahead of time by validators, developers or users
/// and (2) the randomness cannot be biased in any way by validators, developers or users.
///
/// Security holds under the same proof-of-stake assumption that secures the Aptos network.
```

**File:** dkg/src/dkg_manager/mod.rs (L291-292)
```rust
    /// NOTE: the dealt DKG transcript does not have to be persisted:
    /// it is ok for a validator to equivocate on its DKG transcript, as long as the transcript is valid.
```

**File:** dkg/src/dkg_manager/mod.rs (L325-330)
```rust
        let mut rng = if cfg!(feature = "smoke-test") {
            StdRng::from_seed(self.my_addr.into_bytes())
        } else {
            StdRng::from_rng(thread_rng()).unwrap()
        };
        let input_secret = DKG::InputSecret::generate(&mut rng);
```

**File:** types/src/dkg/real_dkg/mod.rs (L332-374)
```rust
    fn verify_transcript(
        params: &Self::PublicParams,
        trx: &Self::Transcript,
    ) -> anyhow::Result<()> {
        // Verify dealer indices are valid.
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );

        let all_eks = params.pvss_config.eks.clone();

        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();

        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L403-420)
```rust
    fn aggregate_transcripts(
        params: &Self::PublicParams,
        accumulator: &mut Self::Transcript,
        element: Self::Transcript,
    ) {
        accumulator
            .main
            .aggregate_with(&params.pvss_config.wconfig, &element.main)
            .expect("Transcript aggregation failed");
        if let (Some(acc), Some(ele), Some(config)) = (
            accumulator.fast.as_mut(),
            element.fast.as_ref(),
            params.pvss_config.fast_wconfig.as_ref(),
        ) {
            acc.aggregate_with(config, ele)
                .expect("Transcript aggregation failed");
        }
    }
```
