# Audit Report

## Title
GRPC Error Handling Bypass Causes Unhandled Panics in Network Controller Service

## Summary
The network controller's GRPC communication layer explicitly panics on any GRPC error instead of propagating errors through the defined error handling system. This bypasses the `error.rs` error handling entirely and can crash validator nodes during block execution when network disruptions occur.

## Finding Description

The network controller in `secure/net` uses GRPC (via tonic) for RPC communication between the coordinator and remote executor shards during sharded block execution. However, the error handling implementation has a critical flaw: [1](#0-0) 

The `Error` enum defined in `error.rs` provides error handling for channel operations and serialization, but lacks any `From` implementation for GRPC-specific error types (`tonic::Status` or `tonic::transport::Error`).

The actual GRPC client implementation explicitly panics on any GRPC error: [2](#0-1) 

This panic occurs in the `send_message` method which is called asynchronously from the outbound handler: [3](#0-2) 

The outbound handler spawns an async task that continuously processes messages: [4](#0-3) 

This network controller is used by the remote executor client for critical block execution operations: [5](#0-4) 

**Attack Scenario:**

1. A validator node is configured with sharded block execution using RemoteExecutorClient
2. During block execution, the coordinator sends execute commands to remote shards via GRPC
3. An attacker causes a network disruption (packet loss, connection drop, timeout) or sends malformed GRPC responses
4. The GRPC client encounters an error (timeout, connection refused, deserialization error, etc.)
5. The `send_message` method panics unconditionally
6. The panic occurs in an async task, crashing the network controller
7. The validator node's execution service fails, making it unable to process blocks
8. This breaks the liveness invariant and can cascade if multiple validators are affected

**Why Error Handling is Bypassed:**

The `error.rs` file defines error types for the network controller but has no way to convert GRPC errors:
- No `From<tonic::Status>` implementation
- No `From<tonic::transport::Error>` implementation  
- The `send_message` method returns `()` instead of `Result<(), Error>`
- GRPC errors never reach the error handling systemâ€”they trigger immediate panics

## Impact Explanation

This vulnerability meets **HIGH severity** criteria per the Aptos bug bounty program:

- **API crashes**: The panic crashes the network controller service, which is a critical API component
- **Validator node slowdowns/crashes**: Affected validator nodes cannot execute blocks, leading to node unavailability

The impact extends to:

1. **Loss of Liveness**: Individual validators crash and cannot participate in consensus
2. **Execution Layer Disruption**: Block execution fails when sharded execution is enabled
3. **Potential Network-Wide Impact**: If multiple validators are configured with sharded execution and experience network issues simultaneously, this could significantly impact network availability

The vulnerability breaks the following invariants:
- **Deterministic Execution**: Nodes may crash at different times based on network conditions
- **Resource Limits**: Panics bypass graceful error handling and resource cleanup

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be triggered in production because:

1. **Common Trigger Conditions**: Network errors are routine occurrences
   - Network timeouts (5 second timeout configured)
   - Connection drops
   - Packet loss
   - DNS resolution failures
   - Port unreachability

2. **No Special Privileges Required**: Any network disruption can trigger the panic
   - No need for validator access
   - No need for cryptographic capabilities
   - Simple network interference is sufficient

3. **Production Usage**: The remote executor service is designed for production sharded execution

4. **Async Task Context**: The panic occurs in an async task spawned by tokio runtime, which will crash the service rather than being caught by normal Rust panic handlers

## Recommendation

Implement proper error propagation through the error handling system:

1. **Add GRPC error conversions to error.rs**:
```rust
impl From<tonic::Status> for Error {
    fn from(error: tonic::Status) -> Self {
        Self::InternalError(format!("GRPC error: {}", error))
    }
}

impl From<tonic::transport::Error> for Error {
    fn from(error: tonic::transport::Error) -> Self {
        Self::InternalError(format!("GRPC transport error: {}", error))
    }
}
```

2. **Change send_message to return Result**:
```rust
pub async fn send_message(
    &mut self,
    sender_addr: SocketAddr,
    message: Message,
    mt: &MessageType,
) -> Result<(), Error> {
    let request = tonic::Request::new(NetworkMessage {
        message: message.data,
        message_type: mt.get_type(),
    });
    
    self.remote_channel
        .simple_msg_exchange(request)
        .await
        .map_err(|e| Error::InternalError(format!(
            "Error '{}' sending message to {} on node {:?}",
            e, self.remote_addr, sender_addr
        )))?;
    
    Ok(())
}
```

3. **Handle errors in the caller**:
```rust
match grpc_clients
    .get_mut(remote_addr)
    .unwrap()
    .send_message(*socket_addr, msg, message_type)
    .await
{
    Ok(_) => {},
    Err(e) => {
        warn!("Failed to send message to {}: {:?}", remote_addr, e);
        // Implement retry logic or circuit breaker pattern
    }
}
```

4. **Add retry logic with exponential backoff** as suggested by the TODO comment at line 150

## Proof of Concept

To reproduce this vulnerability:

```rust
// In a test environment or integration test:

#[tokio::test]
async fn test_grpc_error_causes_panic() {
    use aptos_secure_net::network_controller::NetworkController;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    
    // Create a network controller
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 52200);
    let remote_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 52201);
    
    let mut controller = NetworkController::new(
        "test".to_string(),
        server_addr,
        100, // Very short timeout
    );
    
    // Create outbound channel to non-existent remote
    let sender = controller.create_outbound_channel(
        remote_addr, // This address is not listening
        "test_msg".to_string(),
    );
    
    controller.start();
    
    // Send a message to trigger the GRPC error
    // The remote address is not listening, so this will cause a connection error
    sender.send(Message::new(vec![1, 2, 3])).unwrap();
    
    // Wait for the panic to occur
    std::thread::sleep(std::time::Duration::from_millis(200));
    
    // The test will fail due to panic in the async task:
    // "Error 'transport error' sending message to 127.0.0.1:52201 on node 127.0.0.1:52200"
}
```

To trigger in a real scenario:
1. Configure Aptos node with sharded execution
2. Set up remote executor shards with NetworkController
3. During block execution, disrupt network connectivity (firewall rules, packet drop)
4. Observe validator node crash with panic message including GRPC error details

## Notes

This vulnerability is particularly concerning because:

1. The panic message indicates this is intentional behavior ("TODO: Retry with exponential backoff on failures" comment suggests awareness)
2. The error occurs in critical execution path during block processing
3. The async task context means standard panic handlers may not catch it
4. No graceful degradation or circuit breaker pattern is implemented
5. The 5-second timeout means errors accumulate quickly under poor network conditions

The fix should include not just error propagation, but also retry logic, circuit breakers, and graceful degradation to maintain validator liveness under adverse network conditions.

### Citations

**File:** secure/net/src/network_controller/error.rs (L9-40)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
/// Different reasons for executor service fails to execute a block.
pub enum Error {
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
}

impl From<SendError<network_controller::Message>> for Error {
    fn from(error: SendError<network_controller::Message>) -> Self {
        Self::InternalError(error.to_string())
    }
}

impl From<RecvError> for Error {
    fn from(error: RecvError) -> Self {
        Self::InternalError(error.to_string())
    }
}

impl From<bcs::Error> for Error {
    fn from(error: bcs::Error) -> Self {
        Self::SerializationError(format!("{}", error))
    }
}

impl From<crate::Error> for Error {
    fn from(error: crate::Error) -> Self {
        Self::InternalError(error.to_string())
    }
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L151-159)
```rust
        match self.remote_channel.simple_msg_exchange(request).await {
            Ok(_) => {},
            Err(e) => {
                panic!(
                    "Error '{}' sending message to {} on node {:?}",
                    e, self.remote_addr, sender_addr
                );
            },
        }
```

**File:** secure/net/src/network_controller/outbound_handler.rs (L89-99)
```rust
        rt.spawn(async move {
            info!("Starting outbound handler at {}", address.to_string());
            Self::process_one_outgoing_message(
                outbound_handlers,
                &address,
                inbound_handler.clone(),
                &mut grpc_clients,
            )
            .await;
            info!("Stopping outbound handler at {}", address.to_string());
        });
```

**File:** secure/net/src/network_controller/outbound_handler.rs (L155-160)
```rust
                grpc_clients
                    .get_mut(remote_addr)
                    .unwrap()
                    .send_message(*socket_addr, msg, message_type)
                    .await;
            }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L154-158)
```rust
            NetworkController::new(
                "remote-executor-coordinator".to_string(),
                coordinator_address,
                5000,
            ),
```
