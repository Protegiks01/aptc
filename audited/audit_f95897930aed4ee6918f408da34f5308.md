# Audit Report

## Title
Missing Events in BlockEpilogueTransaction API Responses Cause Incomplete Indexer Data

## Summary
Block epilogue transaction events are extracted from storage but silently dropped during API type conversion, causing indexers and API consumers to receive incomplete event data. This breaks the consistency guarantee that all transaction events should be accessible through APIs and indexers.

## Finding Description

The vulnerability exists in the API conversion layer where `BlockEpilogueTransaction` events are discarded despite being present in the underlying `TransactionOutput`.

**Event Extraction and Storage:**
When transactions execute, including block epilogue transactions, the VM produces a `VMOutput` that contains events emitted during execution. [1](#0-0) 

This `VMOutput` is converted to `TransactionOutput`, preserving the events: [2](#0-1) 

The `TransactionOutput` structure explicitly includes an `events` field that stores all contract events: [3](#0-2) 

**API Conversion Bug:**
When converting stored transactions to API types, events are extracted from storage for ALL transaction types: [4](#0-3) 

However, for `BlockEpilogueTransaction`, the extracted events are completely ignored and NOT included in the API response: [5](#0-4) 

The `BlockEpilogueTransaction` API type lacks an `events` field entirely: [6](#0-5) 

This is inconsistent with other transaction types like `UserTransaction` (which includes events), `GenesisTransaction`, and `BlockMetadataTransaction` that all properly include their events in API responses.

**Indexer Impact:**
The indexer gRPC conversion also fails to extract events for `BlockEpilogueTransaction`: [7](#0-6) 

Compare this to `UserTransaction` which correctly extracts events: [8](#0-7) 

## Impact Explanation

**Medium Severity** - This vulnerability qualifies as Medium severity per Aptos bug bounty criteria because it causes "State inconsistencies requiring intervention" and leads to incomplete data being served to indexers and API consumers.

**Specific Impacts:**
1. **Incomplete Event History**: Any events emitted during block epilogue execution (now or in future framework updates) are invisible to off-chain systems
2. **Indexer Data Gaps**: Blockchain indexers will have incomplete event logs, affecting data integrity
3. **Broken Monitoring**: Event-based monitoring systems cannot observe block epilogue events
4. **Developer Confusion**: Inconsistent behavior between transaction types violates principle of least surprise
5. **Future-Proofing Risk**: Framework updates that add event emissions to block epilogue will silently fail to propagate

While the current `block::block_epilogue` implementation doesn't emit events, the infrastructure allows for events and future framework changes could introduce them, making this a real vulnerability.

## Likelihood Explanation

**High Likelihood** - This bug affects every block epilogue transaction in every block:

1. **Automatic Trigger**: Block epilogue transactions execute automatically at the end of every block (when epoch change doesn't occur)
2. **No Attacker Action Required**: This is a code bug, not an exploit - it happens naturally
3. **Already Occurring**: If any events are currently emitted from block epilogue execution, they are already being dropped
4. **Future Framework Changes**: Any addition of event emissions to the block epilogue flow will immediately be affected

The bug is deterministic and affects all nodes equally, making it highly likely to cause issues for any system relying on complete event data from the blockchain.

## Recommendation

**Fix 1: Add Events Field to API Type**

Modify the `BlockEpilogueTransaction` struct to include an events field:

```rust
// In api/types/src/transaction.rs
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct BlockEpilogueTransaction {
    #[serde(flatten)]
    #[oai(flatten)]
    pub info: TransactionInfo,
    pub timestamp: U64,
    pub block_end_info: Option<BlockEndInfo>,
    /// Events generated by the transaction
    pub events: Vec<Event>,
}
```

**Fix 2: Update API Conversion**

Pass events to the constructor in the conversion function: [5](#0-4) 

```rust
BlockEpilogue(block_epilogue_payload) => {
    let block_end_info = /* ... existing code ... */;
    Transaction::BlockEpilogueTransaction(BlockEpilogueTransaction {
        info,
        timestamp: timestamp.into(),
        block_end_info,
        events,  // ADD THIS
    })
}
```

**Fix 3: Update Indexer Conversion**

Add events extraction to the indexer gRPC conversion: [7](#0-6) 

```rust
Transaction::BlockEpilogueTransaction(block_epilogue) => {
    transaction::transaction::TxnData::BlockEpilogue(
        transaction::BlockEpilogueTransaction {
            block_end_info: /* ... existing code ... */,
            events: convert_events(&block_epilogue.events),  // ADD THIS
        },
    )
}
```

## Proof of Concept

**Step 1: Create a test framework modification**

Modify `aptos-move/framework/aptos-framework/sources/block.move` to emit an event in `block_epilogue`:

```move
#[event]
struct BlockEpilogueFeeDistribution has drop, store {
    num_validators: u64,
    total_fees: u64,
}

fun block_epilogue(
    vm: &signer,
    fee_distribution_validator_indices: vector<u64>,
    fee_amounts_octa: vector<u64>,
) {
    // Emit event to track fee distribution
    let total_fees = 0;
    let i = 0;
    while (i < fee_amounts_octa.length()) {
        total_fees = total_fees + fee_amounts_octa[i];
        i = i + 1;
    };
    
    event::emit(BlockEpilogueFeeDistribution {
        num_validators: fee_distribution_validator_indices.length(),
        total_fees,
    });
    
    stake::record_fee(vm, fee_distribution_validator_indices, fee_amounts_octa);
}
```

**Step 2: Query the API**

After a block executes with the modified framework:
1. Query the transaction via REST API: `GET /transactions/{version}`
2. Observe that `BlockEpilogueTransaction` returns no events
3. Query the events directly from storage: `GET /accounts/0x1/events/{event_handle}/{sequence}`
4. The event exists in storage but is not exposed in the transaction response

**Step 3: Check Indexer**

Query the indexer gRPC stream and verify that `BlockEpilogueTransaction` protobuf messages contain no events in the `events` field, despite events being emitted and stored.

**Step 4: Compare with UserTransaction**

Execute a user transaction that emits events and observe that events are correctly included in both API responses and indexer data, demonstrating the inconsistency.

This demonstrates that the infrastructure supports block epilogue events at the VM and storage layers, but the API/indexer layers drop them, creating an incomplete view of blockchain state for external consumers.

### Citations

**File:** aptos-move/aptos-vm-types/src/output.rs (L94-96)
```rust
    pub fn events(&self) -> &[(ContractEvent, Option<MoveTypeLayout>)] {
        self.change_set.events()
    }
```

**File:** aptos-move/aptos-vm-types/src/output.rs (L209-218)
```rust
        let (write_set, events) = change_set
            .try_combine_into_storage_change_set(module_write_set)?
            .into_inner();
        Ok(TransactionOutput::new(
            write_set,
            events,
            fee_statement.gas_used(),
            status,
            TransactionAuxiliaryData::default(),
        ))
```

**File:** types/src/transaction/mod.rs (L1767-1783)
```rust
pub struct TransactionOutput {
    /// The list of writes this transaction intends to do.
    write_set: WriteSet,

    /// The list of events emitted during this transaction.
    events: Vec<ContractEvent>,

    /// The amount of gas used during execution.
    gas_used: u64,

    /// The execution status. The detailed error info will not be stored here instead will be stored in the auxiliary data.
    status: TransactionStatus,

    /// The transaction auxiliary data that includes detail error info that is not used for calculating the hash
    #[serde(skip)]
    auxiliary_data: TransactionAuxiliaryData,
}
```

**File:** api/types/src/convert.rs (L192-192)
```rust
        let events = self.try_into_events(&data.events)?;
```

**File:** api/types/src/convert.rs (L214-236)
```rust
            BlockEpilogue(block_epilogue_payload) => {
                let block_end_info = block_epilogue_payload
                    .try_as_block_end_info()
                    .unwrap()
                    .clone();
                let block_end_info = match block_end_info {
                    BlockEndInfo::V0 {
                        block_gas_limit_reached,
                        block_output_limit_reached,
                        block_effective_block_gas_units,
                        block_approx_output_size,
                    } => Some(crate::transaction::BlockEndInfo {
                        block_gas_limit_reached,
                        block_output_limit_reached,
                        block_effective_block_gas_units,
                        block_approx_output_size,
                    }),
                };
                Transaction::BlockEpilogueTransaction(BlockEpilogueTransaction {
                    info,
                    timestamp: timestamp.into(),
                    block_end_info,
                })
```

**File:** api/types/src/transaction.rs (L433-440)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct BlockEpilogueTransaction {
    #[serde(flatten)]
    #[oai(flatten)]
    pub info: TransactionInfo,
    pub timestamp: U64,
    pub block_end_info: Option<BlockEndInfo>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L872-873)
```rust
                events: convert_events(&ut.events),
            })
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L902-916)
```rust
        Transaction::BlockEpilogueTransaction(block_epilogue) => {
            transaction::transaction::TxnData::BlockEpilogue(
                transaction::BlockEpilogueTransaction {
                    block_end_info: block_epilogue
                        .block_end_info
                        .as_ref()
                        .map(|block_end_info| transaction::BlockEndInfo {
                            block_gas_limit_reached: block_end_info.block_gas_limit_reached,
                            block_output_limit_reached: block_end_info.block_output_limit_reached,
                            block_effective_block_gas_units: block_end_info
                                .block_effective_block_gas_units,
                            block_approx_output_size: block_end_info.block_approx_output_size,
                        }),
                },
            )
```
