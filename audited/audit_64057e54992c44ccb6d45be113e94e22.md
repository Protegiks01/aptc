# Audit Report

## Title
Consensus Publisher Amplification Attack via Unlimited Unauthenticated Subscriber Registration

## Summary
The Consensus Publisher accepts unlimited subscription requests from any peer without authentication or authorization, enabling an attacker to register many malicious subscribers and amplify bandwidth/CPU consumption when block payloads are broadcast to all subscribers during normal consensus operation.

## Finding Description

The vulnerability exists in how the `ConsensusPublisher` handles subscriber registration and message broadcasting:

**Missing Access Control:**
The publisher accepts any `Subscribe` request without validation: [1](#0-0) 

Any peer that can establish a network connection (limited only by network-level `max_inbound_connections` of ~100) can subscribe.

**Amplification Points:**
When blocks are processed, the payload manager broadcasts to ALL subscribers:

1. For validators/VFNs using quorum store: [2](#0-1) 

2. For consensus observers: [3](#0-2) 

**Broadcast Implementation:**
The `publish_message` method clones the message for each subscriber: [4](#0-3) 

**Attack Flow:**
1. Attacker establishes N connections to a validator/VFN publisher (N â‰¤ `max_inbound_connections`, typically ~100)
2. Each connection sends `ConsensusObserverRequest::Subscribe` 
3. Publisher accepts all without validation, adding them to `active_subscribers`
4. During normal consensus, each block triggers `get_transactions()` 
5. This calls `publish_message()` which:
   - Clones the block payload message N times (line 221)
   - Queues each for serialization in separate tasks
   - Sends each over the network
6. Resource consumption scales linearly with N per block

The system processes blocks at consensus rate (~1-4 blocks/second), continuously triggering this amplification.

## Impact Explanation

**High Severity - Validator Node Slowdowns:**

This vulnerability causes significant resource exhaustion on validators and VFNs:

- **CPU Exhaustion**: Cloning and serializing large block payloads N times per block consumes CPU in the critical consensus path
- **Memory Pressure**: Buffering N messages in the outbound channel (capacity 1000 from config): [5](#0-4) 
- **Bandwidth Saturation**: Broadcasting full block payloads to N malicious peers

With N=100 malicious subscribers and blocks at ~10KB, this generates ~1MB of outbound traffic per block, or ~4MB/second sustained, degrading validator network performance.

The attack affects validators because publisher is enabled by default: [6](#0-5) 

And the publisher is passed to the payload manager: [7](#0-6) 

## Likelihood Explanation

**High Likelihood:**

- **No authentication required**: Any peer can subscribe
- **No rate limiting**: Unlimited subscribe requests accepted
- **No subscriber limit**: Only constrained by network connection limits (~100)
- **Automatic triggering**: Normal consensus flow triggers amplification; attacker doesn't need to send blocks
- **Easy to execute**: Standard network connection + RPC call
- **Affects default configuration**: Validators run with `publisher_enabled=true` by default

## Recommendation

Implement multiple layers of defense:

1. **Subscriber Limit**: Add configurable maximum subscribers
2. **Authentication**: Validate subscribers against known validator/VFN set or use peer reputation
3. **Rate Limiting**: Limit subscribe requests per peer
4. **Subscription Authorization**: Require proof of legitimate observer status

Example fix for subscriber limit:

```rust
// In ConsensusObserverConfig
pub max_active_subscribers: u64, // e.g., default 10

// In ConsensusPublisher
fn add_active_subscriber(&self, peer_network_id: PeerNetworkId) -> Result<(), Error> {
    let mut subscribers = self.active_subscribers.write();
    
    // Check subscriber limit
    if subscribers.len() >= self.consensus_observer_config.max_active_subscribers as usize {
        return Err(Error::TooManySubscribers);
    }
    
    subscribers.insert(peer_network_id);
    Ok(())
}

fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    // ... existing code ...
    match message {
        ConsensusObserverRequest::Subscribe => {
            // Add validation
            if let Err(e) = self.add_active_subscriber(peer_network_id) {
                warn!("Failed to add subscriber: {:?}", e);
                response_sender.send(ConsensusObserverResponse::SubscribeNack);
                return;
            }
            // ... rest of subscribe handling ...
        },
        // ... rest of match ...
    }
}
```

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_publisher_amplification_attack() {
    // Setup validator with publisher enabled
    let mut test_env = TestEnvironment::new();
    let validator = test_env.create_validator_with_publisher();
    
    // Attacker subscribes many malicious nodes
    let num_malicious_subscribers = 100;
    let mut subscribers = vec![];
    
    for i in 0..num_malicious_subscribers {
        let malicious_peer = test_env.create_peer();
        
        // Send subscribe request
        let response = malicious_peer
            .send_rpc(ConsensusObserverRequest::Subscribe)
            .await
            .unwrap();
        
        assert!(matches!(response, ConsensusObserverResponse::SubscribeAck));
        subscribers.push(malicious_peer);
    }
    
    // Verify all subscribers were accepted
    assert_eq!(
        validator.get_publisher().get_active_subscribers().len(),
        num_malicious_subscribers
    );
    
    // Trigger block processing through normal consensus
    validator.produce_block().await;
    
    // Measure resource consumption
    let metrics = validator.get_metrics();
    
    // Each subscriber should receive the block payload
    for subscriber in &mut subscribers {
        let message = subscriber.receive_message().await.unwrap();
        assert!(matches!(message, ConsensusObserverDirectSend::BlockPayload(_)));
    }
    
    // Verify amplification: N messages sent for single block
    assert_eq!(
        metrics.publisher_messages_sent,
        num_malicious_subscribers
    );
    
    // Verify resource consumption is linear in subscribers
    assert!(metrics.cpu_usage > baseline_cpu_usage * num_malicious_subscribers / 10);
}
```

**Notes:**
- This vulnerability violates the "Resource Limits" invariant by allowing unbounded subscribers
- The attack is sustainable as long as consensus produces blocks
- Combined with the bounded channel capacity, this can cause message drops for legitimate observers
- The lack of subscriber authentication enables any peer to exploit this amplification

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L180-192)
```rust
        match message {
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L551-557)
```rust
        if let Some(consensus_publisher) = &self.maybe_consensus_publisher {
            let message = ConsensusObserverMessage::new_block_payload_message(
                block.gen_block_info(HashValue::zero(), 0, None),
                transaction_payload.clone(),
            );
            consensus_publisher.publish_message(message);
        }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L60-68)
```rust
    // If the payload is valid, publish it to any downstream observers
    let transaction_payload = block_payload.transaction_payload();
    if let Some(consensus_publisher) = consensus_publisher {
        let message = ConsensusObserverMessage::new_block_payload_message(
            block.gen_block_info(HashValue::zero(), 0, None),
            transaction_payload.clone(),
        );
        consensus_publisher.publish_message(message);
    }
```

**File:** config/src/config/consensus_observer_config.rs (L68-68)
```rust
            max_network_channel_size: 1000,
```

**File:** config/src/config/consensus_observer_config.rs (L112-117)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/epoch_manager.rs (L765-767)
```rust
        let (payload_manager, quorum_store_msg_tx) =
            quorum_store_builder.init_payload_manager(self.consensus_publisher.clone());
        self.quorum_store_msg_tx = quorum_store_msg_tx;
```
