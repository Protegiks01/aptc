# Audit Report

## Title
Incomplete Transaction Info Validation Allows State Root Bypass in Replay Verification Path

## Summary
The `ensure_match_transaction_info` function validates only 4 out of 7 fields in `TransactionInfo`, failing to check `state_checkpoint_hash` (state root), `transaction_hash`, and `auxiliary_info_hash`. This allows partial matches to pass validation during transaction replay and verification operations.

## Finding Description

The `ensure_match_transaction_info` function is responsible for verifying that a re-executed transaction's output matches the expected `TransactionInfo`. However, it performs incomplete validation: [1](#0-0) 

The function validates only:
- Transaction status
- Gas used
- State change hash (write set hash)
- Event root hash

The `TransactionInfoV0` structure contains 7 fields: [2](#0-1) 

Three critical fields are **never validated**:
1. `transaction_hash` - The hash of the transaction itself
2. `state_checkpoint_hash` - The Sparse Merkle Tree root hash representing the complete world state
3. `auxiliary_info_hash` - Hash of persisted auxiliary information including transaction index

The security question specifically asks about "state root" validation. While `state_change_hash` (write set hash) IS validated, `state_checkpoint_hash` (the actual state merkle root) is NOT validated.

This function is used in critical verification paths: [3](#0-2) [4](#0-3) 

**State Checkpoint Hash Generation Context:**

State checkpoint hashes are generated periodically (typically at block boundaries): [5](#0-4) 

While the main state sync path validates `state_checkpoint_hash` via `DoStateCheckpoint`: [6](#0-5) 

The replay verification path (`verify_execution`) does NOT perform this validation and relies solely on `ensure_match_transaction_info`, which skips it. [7](#0-6) 

## Impact Explanation

This issue constitutes **Medium Severity** per the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Missing state_checkpoint_hash validation could allow state divergence to go undetected during replay operations
- **Significant protocol violations**: Breaks the deterministic execution invariant by allowing different state roots to pass validation

However, it does NOT reach High/Critical severity because:
- The main consensus and state sync path (`apply_chunk_output`) validates state_checkpoint_hash separately
- Exploitation requires the attacker to influence TransactionInfo inputs to replay operations
- No direct consensus safety violation or fund loss in normal operation

The vulnerability could be exploited if:
1. Database corruption or backup tampering provides malicious TransactionInfos
2. A separate vulnerability allows injection of incorrect TransactionInfos into replay paths
3. Forensic analysis or debugging tools are misled by accepting incorrect state roots

## Likelihood Explanation

**Likelihood: Low-to-Medium**

The vulnerability requires specific conditions:
- Attacker must compromise the source of TransactionInfos (database, backups, or state sync data)
- Affected code paths are primarily used in replay/verification scenarios, not main consensus
- The incomplete validation acts as a missing defense-in-depth layer rather than a direct attack vector

In normal operations, TransactionInfos come from trusted sources (committed blocks, local database). However, if these sources are compromised or if there's a bug in state sync that allows malicious TransactionInfos, the incomplete validation would fail to detect state root mismatches.

## Recommendation

Add validation for all three missing fields in `ensure_match_transaction_info`:

```rust
pub fn ensure_match_transaction_info(
    &self,
    version: Version,
    txn_info: &TransactionInfo,
    expected_write_set: Option<&WriteSet>,
    expected_events: Option<&[ContractEvent]>,
) -> Result<()> {
    const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";

    // Existing validations...
    
    // ADD: Validate state_checkpoint_hash if present
    if let Some(expected_checkpoint_hash) = txn_info.state_checkpoint_hash() {
        let actual_checkpoint_hash = self.compute_state_checkpoint_hash()?;
        ensure!(
            actual_checkpoint_hash == expected_checkpoint_hash,
            "{}: version:{}, state_checkpoint_hash mismatch, actual:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            actual_checkpoint_hash,
            expected_checkpoint_hash,
        );
    }
    
    // ADD: Validate auxiliary_info_hash if present
    if let Some(expected_aux_hash) = txn_info.auxiliary_info_hash() {
        if let Some(actual_aux_hash) = self.auxiliary_data().compute_hash() {
            ensure!(
                actual_aux_hash == expected_aux_hash,
                "{}: version:{}, auxiliary_info_hash mismatch, actual:{:?}, expected:{:?}",
                ERR_MSG,
                version,
                actual_aux_hash,
                expected_aux_hash,
            );
        }
    }
    
    // Note: transaction_hash validation requires the original transaction,
    // which is not available in TransactionOutput context
    
    Ok(())
}
```

**Note**: `transaction_hash` validation would require access to the original transaction, which isn't available in the `TransactionOutput` context. This field should be validated at the caller level where the transaction is available.

## Proof of Concept

```rust
// Proof of Concept: Demonstrate that mismatched state_checkpoint_hash passes validation
#[test]
fn test_incomplete_transaction_info_validation() {
    use aptos_types::transaction::{TransactionInfo, TransactionInfoV0, TransactionOutput, TransactionStatus, WriteSet};
    use aptos_crypto::{HashValue, hash::CryptoHash};
    
    // Create a transaction output
    let write_set = WriteSet::default();
    let events = vec![];
    let gas_used = 1000u64;
    let status = TransactionStatus::Keep(ExecutionStatus::Success);
    
    let txn_output = TransactionOutput::new(
        write_set.clone(),
        events.clone(),
        gas_used,
        status.clone(),
        TransactionAuxiliaryData::default(),
    );
    
    // Create TransactionInfo with INCORRECT state_checkpoint_hash
    let write_set_hash = CryptoHash::hash(&write_set);
    let event_root = HashValue::zero();
    let incorrect_state_checkpoint = Some(HashValue::random()); // WRONG state root!
    
    let txn_info = TransactionInfo::V0(TransactionInfoV0::new(
        HashValue::random(), // transaction_hash
        write_set_hash,      // state_change_hash (matches)
        event_root,          // event_root_hash (matches)
        incorrect_state_checkpoint, // INCORRECT but not validated!
        gas_used,            // gas_used (matches)
        ExecutionStatus::Success, // status (matches)
        None,                // auxiliary_info_hash
    ));
    
    // This should FAIL but actually PASSES because state_checkpoint_hash is not validated
    let result = txn_output.ensure_match_transaction_info(
        0, 
        &txn_info,
        Some(&write_set),
        Some(&events),
    );
    
    assert!(result.is_ok(), "Validation passed despite incorrect state_checkpoint_hash!");
    // ^ This assertion succeeds, demonstrating the vulnerability
}
```

**Notes:**
- The proof of concept demonstrates that incorrect `state_checkpoint_hash` values pass validation
- In production, this could allow state divergence during replay operations to go undetected
- The vulnerability exists across all replay/verification code paths using this function
- Fix requires implementing state checkpoint validation as shown in the recommendation

### Citations

**File:** types/src/transaction/mod.rs (L1869-1928)
```rust
    pub fn ensure_match_transaction_info(
        &self,
        version: Version,
        txn_info: &TransactionInfo,
        expected_write_set: Option<&WriteSet>,
        expected_events: Option<&[ContractEvent]>,
    ) -> Result<()> {
        const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";

        let expected_txn_status: TransactionStatus = txn_info.status().clone().into();
        ensure!(
            self.status() == &expected_txn_status,
            "{}: version:{}, status:{:?}, auxiliary data:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.status(),
            self.auxiliary_data(),
            expected_txn_status,
        );

        ensure!(
            self.gas_used() == txn_info.gas_used(),
            "{}: version:{}, gas_used:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.gas_used(),
            txn_info.gas_used(),
        );

        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );

        let event_hashes = self
            .events()
            .iter()
            .map(CryptoHash::hash)
            .collect::<Vec<_>>();
        let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
        ensure!(
            event_root_hash == txn_info.event_root_hash(),
            "{}: version:{}, event_root_hash:{:?}, expected:{:?}, events: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            event_root_hash,
            txn_info.event_root_hash(),
            self.events(),
            expected_events,
        );

        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L2025-2051)
```rust
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}
```

**File:** execution/executor/src/chunk_executor/mod.rs (L350-357)
```rust
            Some(
                chunk_verifier
                    .transaction_infos()
                    .iter()
                    .map(|t| t.state_checkpoint_hash())
                    .collect_vec(),
            ),
        )?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L592-652)
```rust
    fn verify_execution(
        &self,
        transactions: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        transaction_infos: &[TransactionInfo],
        write_sets: &[WriteSet],
        event_vecs: &[Vec<ContractEvent>],
        begin_version: Version,
        end_version: Version,
        verify_execution_mode: &VerifyExecutionMode,
    ) -> Result<Version> {
        // Execute transactions.
        let parent_state = self.commit_queue.lock().latest_state().clone();
        let state_view = self.state_view(parent_state.latest())?;
        let txns = transactions
            .iter()
            .take((end_version - begin_version) as usize)
            .cloned()
            .map(|t| t.into())
            .collect::<Vec<SignatureVerifiedTransaction>>();

        let auxiliary_info = persisted_aux_info
            .iter()
            .take((end_version - begin_version) as usize)
            .map(|persisted_aux_info| AuxiliaryInfo::new(*persisted_aux_info, None))
            .collect::<Vec<_>>();
        // State sync executor shouldn't have block gas limit.
        let execution_output = DoGetExecutionOutput::by_transaction_execution::<V>(
            &V::new(),
            txns.into(),
            auxiliary_info,
            &parent_state,
            state_view,
            BlockExecutorConfigFromOnchain::new_no_block_limit(),
            TransactionSliceMetadata::chunk(begin_version, end_version),
        )?;
        // not `zip_eq`, deliberately
        for (version, txn_out, txn_info, write_set, events) in multizip((
            begin_version..end_version,
            &execution_output.to_commit.transaction_outputs,
            transaction_infos.iter(),
            write_sets.iter(),
            event_vecs.iter(),
        )) {
            if let Err(err) = txn_out.ensure_match_transaction_info(
                version,
                txn_info,
                Some(write_set),
                Some(events),
            ) {
                return if verify_execution_mode.is_lazy_quit() {
                    error!("(Not quitting right away.) {}", err);
                    verify_execution_mode.mark_seen_error();
                    Ok(version + 1)
                } else {
                    Err(err)
                };
            }
        }
        Ok(end_version)
    }
```

**File:** aptos-move/aptos-debugger/src/aptos_debugger.rs (L230-232)
```rust
                .ensure_match_transaction_info(version, txn_info, None, None)
                .unwrap_or_else(|err| println!("{}", err))
        }
```

**File:** execution/executor/src/workflow/do_state_checkpoint.rs (L44-88)
```rust
    fn get_state_checkpoint_hashes(
        execution_output: &ExecutionOutput,
        known_state_checkpoints: Option<Vec<Option<HashValue>>>,
        state_summary: &LedgerStateSummary,
    ) -> Result<Vec<Option<HashValue>>> {
        let _timer = OTHER_TIMERS.timer_with(&["get_state_checkpoint_hashes"]);

        let num_txns = execution_output.to_commit.len();
        let last_checkpoint_index = execution_output
            .to_commit
            .state_update_refs()
            .last_inner_checkpoint_index();

        if let Some(known) = known_state_checkpoints {
            ensure!(
                known.len() == num_txns,
                "Bad number of known hashes. {} vs {}",
                known.len(),
                num_txns
            );
            if let Some(idx) = last_checkpoint_index {
                ensure!(
                    known[idx] == Some(state_summary.last_checkpoint().root_hash()),
                    "Root hash mismatch with known hashes passed in. {:?} vs {:?}",
                    known[idx],
                    Some(&state_summary.last_checkpoint().root_hash()),
                );
            }

            Ok(known)
        } else {
            if !execution_output.is_block {
                // We should enter this branch only in test.
                execution_output.to_commit.ensure_at_most_one_checkpoint()?;
            }

            let mut out = vec![None; num_txns];

            if let Some(index) = last_checkpoint_index {
                out[index] = Some(state_summary.last_checkpoint().root_hash());
            }

            Ok(out)
        }
    }
```
