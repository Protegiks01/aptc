# Audit Report

## Title
Unmetered Deep Cloning of Large Multisig Payloads Enables Validator DoS Attack

## Summary
The `Multisig` struct performs unmetered deep copying of transaction payloads up to 1MB in size. During transaction execution, multisig payloads are cloned 6-7 times across different execution phases without gas metering for these operations. This creates an economic mismatch where users pay gas for processing data once, but validators perform 6-7× the computational work, enabling resource exhaustion attacks.

## Finding Description

The `Multisig` struct uses a derived `Clone` trait [1](#0-0)  that performs deep copies of the entire payload, including the `MultisigTransactionPayload` enum which wraps an `EntryFunction` [2](#0-1) .

The `EntryFunction` struct contains a `Vec<Vec<u8>>` args field [3](#0-2)  that can hold up to 64KB for regular transactions or 1MB for governance transactions [4](#0-3) .

**Critical Unmetered Clone Operations:**

1. **Pre-Gas-Meter Clones:** In `TransactionMetadata::new()`, the Multisig is cloned when creating transaction metadata [5](#0-4) . This occurs **before** the gas meter is even created [6](#0-5) , meaning zero gas accounting for initial clones. A TODO comment acknowledges this issue [7](#0-6) .

2. **Validation Clone:** During multisig validation, the EntryFunction is cloned for serialization [8](#0-7) .

3. **Getter Clones:** The `multisig_payload()` and `entry_function_payload()` getter methods return cloned data [9](#0-8) .

4. **Session Creation Clones:** The `as_user_transaction_context()` method calls these cloning getters [10](#0-9)  and is invoked in:
   - `PrologueSession::new()` [11](#0-10) 
   - `UserSession::new()` [12](#0-11) 
   - `EpilogueSession::new()` [13](#0-12) 
   - `AbortHookSession::new()` [14](#0-13) 

5. **Additional conversion clones:** The `as_entry_function_payload()` method clones the args field [15](#0-14) .

**The Core Issue:** While intrinsic gas is charged based on transaction size [16](#0-15) , this only accounts for the payload size once. The gas calculation [17](#0-16)  does not account for the 6-7 clone operations that scale linearly with payload size.

**Attack Scenario:**
1. Attacker creates multisig transactions with maximum-sized payloads (64KB regular or 1MB governance)
2. Submits multiple such transactions to validators
3. Each transaction causes 6-7 full deep copies of the payload (384-448KB for regular, 6-7MB for governance per transaction)
4. Validators perform O(payload_size × clone_count) unmetered work
5. Memory bandwidth contention and CPU overhead accumulate across multiple transactions

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program category "Validator node slowdowns" - defined as significant performance degradation affecting consensus through DoS via resource exhaustion.

**Quantified Impact:**
- **Economic Mismatch:** Users pay gas for 1× data processing, validators perform 6-7× computational work
- **Resource Exhaustion:** For 1MB governance transactions: 7MB of cloning per transaction (700% overhead)
- **CPU Overhead:** Repeated memcpy operations proportional to payload size
- **Memory Pressure:** Multiple simultaneous allocations during concurrent transaction processing
- **Cascading Effects:** Memory bandwidth saturation when processing blocks with multiple large multisig transactions

The vulnerability does not cause consensus violations or fund loss, appropriately limiting severity to High rather than Critical.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Standard transaction submission capability (any Aptos user)
- Sufficient APT tokens for gas fees (predictable cost)
- Knowledge to construct large multisig payloads (straightforward)

**Ease of Exploitation:**
- Single transaction type triggers the issue
- No special privileges or timing requirements
- Easily automated
- Transactions appear legitimate (valid multisig transactions)

**Detection Difficulty:**
- No distinguishing characteristics from normal large multisig transactions
- Performance degradation is the only indicator
- No obvious attack signature until aggregate impact manifests

## Recommendation

**Immediate Fix:**
1. Implement reference-based access patterns where possible to avoid unnecessary clones
2. For unavoidable clones, charge gas proportional to clone operations: `gas_cost = base_intrinsic_gas + (payload_size × clone_multiplier × clone_gas_per_byte)`

**Code Changes:**
- Modify getter methods in `TransactionMetadata` to return references instead of clones where lifetime permits
- Use `Rc<>` or `Arc<>` for shared payload data across sessions
- Add explicit gas charging for clone operations that cannot be eliminated
- Address the TODO comment by restructuring payload handling to minimize cloning

**Long-term Solution:**
- Refactor transaction metadata and session creation to use a shared reference model
- Implement copy-on-write semantics for payload data
- Add performance monitoring for clone operations in transaction processing

## Proof of Concept

```rust
// PoC: Submit large multisig transaction to trigger unmetered cloning
// This can be executed using the Aptos CLI or SDK:

// 1. Create a multisig account
// 2. Create a transaction with maximum-sized args (64KB or 1MB for governance)
// 3. Submit multiple such transactions
// 4. Observe validator CPU/memory metrics showing 6-7× overhead

// Example using Aptos CLI (pseudo-code):
// aptos multisig create --account <addr>
// aptos multisig create-transaction \
//   --function-id <module>::<function> \
//   --args <64KB_of_data> \
//   --multisig-address <addr>
// 
// Repeat submission to observe cumulative impact on validators
```

**Notes:**
- The vulnerability is confirmed through code analysis of all clone sites
- The TODO comment at line 114 indicates developer awareness of the clone inefficiency
- The 6-7× computational overhead creates an exploitable economic mismatch between gas payment and actual validator work
- Modern validator hardware mitigates but does not eliminate the impact, especially under concurrent load
- This represents a protocol-level resource exhaustion vulnerability distinct from network-level DoS attacks

### Citations

**File:** types/src/transaction/multisig.rs (L11-17)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Multisig {
    pub multisig_address: AccountAddress,

    // Transaction payload is optional if already stored on chain.
    pub transaction_payload: Option<MultisigTransactionPayload>,
}
```

**File:** types/src/transaction/multisig.rs (L21-24)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum MultisigTransactionPayload {
    EntryFunction(EntryFunction),
}
```

**File:** types/src/transaction/script.rs (L108-115)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct EntryFunction {
    module: ModuleId,
    function: Identifier,
    ty_args: Vec<TypeTag>,
    #[serde(with = "vec_bytes")]
    args: Vec<Vec<u8>>,
}
```

**File:** types/src/transaction/script.rs (L152-163)
```rust
    pub fn as_entry_function_payload(&self) -> EntryFunctionPayload {
        EntryFunctionPayload::new(
            self.module.address,
            self.module.name().to_string(),
            self.function.to_string(),
            self.ty_args
                .iter()
                .map(|ty| ty.to_canonical_string())
                .collect(),
            self.args.clone(),
        )
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-81)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L101-121)
```rust
            multisig_payload: match txn.payload() {
                TransactionPayload::Multisig(m) => Some(m.clone()),
                TransactionPayload::Payload(TransactionPayloadInner::V1 {
                    executable,
                    extra_config:
                        TransactionExtraConfig::V1 {
                            multisig_address: Some(multisig_address),
                            ..
                        },
                }) => Some(Multisig {
                    multisig_address: *multisig_address,
                    transaction_payload: match executable {
                        TransactionExecutable::EntryFunction(e) => {
                            // TODO[Orderless]: How to avoid the clone operation here.
                            Some(MultisigTransactionPayload::EntryFunction(e.clone()))
                        },
                        _ => None,
                    },
                }),
                _ => None,
            },
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L201-207)
```rust
    pub fn entry_function_payload(&self) -> Option<EntryFunction> {
        self.entry_function_payload.clone()
    }

    pub fn multisig_payload(&self) -> Option<Multisig> {
        self.multisig_payload.clone()
    }
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L209-223)
```rust
    pub fn as_user_transaction_context(&self) -> UserTransactionContext {
        UserTransactionContext::new(
            self.sender,
            self.secondary_signers.clone(),
            self.fee_payer.unwrap_or(self.sender),
            self.max_gas_amount.into(),
            self.gas_unit_price.into(),
            self.chain_id.id(),
            self.entry_function_payload()
                .map(|entry_func| entry_func.as_entry_function_payload()),
            self.multisig_payload()
                .map(|multisig| multisig.as_multisig_payload()),
            self.transaction_index_kind,
        )
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1040-1046)
```rust
        gas_meter.charge_intrinsic_gas_for_transaction(txn_data.transaction_size())?;
        if txn_data.is_keyless() {
            gas_meter.charge_keyless()?;
        }
        if txn_data.is_slh_dsa_sha2_128s() {
            gas_meter.charge_slh_dsa_sha2_128s()?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2143-2164)
```rust
        let txn_metadata = TransactionMetadata::new(txn, auxiliary_info);

        let is_approved_gov_script = is_approved_gov_script(resolver, txn, &txn_metadata);

        let vm_params = self.gas_params(log_context)?.vm.clone();

        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn.max_gas_amount().into())
        } else {
            txn.max_gas_amount().into()
        };

        let mut gas_meter = make_gas_meter(
            self.gas_feature_version(),
            vm_params,
            self.storage_gas_params(log_context)?.clone(),
            is_approved_gov_script,
            initial_balance,
            code_storage,
        );
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L411-415)
```rust
    let provided_payload = match executable {
        TransactionExecutableRef::EntryFunction(entry_function) => bcs::to_bytes(
            &MultisigTransactionPayload::EntryFunction(entry_function.clone()),
        )
        .map_err(|_| unreachable_error.clone())?,
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L32-47)
```rust
    pub fn new(
        vm: &AptosVM,
        txn_meta: &TransactionMetadata,
        resolver: &'r impl AptosMoveResolver,
    ) -> Self {
        let session_id = SessionId::prologue_meta(txn_meta);
        let session = RespawnedSession::spawn(
            vm,
            session_id,
            resolver,
            VMChangeSet::empty(),
            Some(txn_meta.as_user_transaction_context()),
        );

        Self { session }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L42-59)
```rust
    pub fn new(
        vm: &AptosVM,
        txn_meta: &TransactionMetadata,
        resolver: &'r impl AptosMoveResolver,
        prologue_change_set: VMChangeSet,
    ) -> Self {
        let session_id = SessionId::txn_meta(txn_meta);

        let session = RespawnedSession::spawn(
            vm,
            session_id,
            resolver,
            prologue_change_set,
            Some(txn_meta.as_user_transaction_context()),
        );

        Self { session }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L74-96)
```rust
    fn new(
        vm: &AptosVM,
        txn_meta: &TransactionMetadata,
        resolver: &'r impl AptosMoveResolver,
        previous_session_change_set: VMChangeSet,
        module_write_set: ModuleWriteSet,
        storage_refund: Fee,
    ) -> Self {
        let session_id = SessionId::epilogue_meta(txn_meta);
        let session = RespawnedSession::spawn(
            vm,
            session_id,
            resolver,
            previous_session_change_set,
            Some(txn_meta.as_user_transaction_context()),
        );

        Self {
            session,
            storage_refund,
            module_write_set,
        }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/abort_hook.rs (L30-47)
```rust
    pub fn new(
        vm: &AptosVM,
        txn_meta: &TransactionMetadata,
        resolver: &'r impl AptosMoveResolver,
        prologue_session_change_set: SystemSessionChangeSet,
    ) -> Self {
        let session_id = SessionId::run_on_abort(txn_meta);

        let session = RespawnedSession::spawn(
            vm,
            session_id,
            resolver,
            prologue_session_change_set.unpack(),
            Some(txn_meta.as_user_transaction_context()),
        );

        Self { session }
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-158)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
```
