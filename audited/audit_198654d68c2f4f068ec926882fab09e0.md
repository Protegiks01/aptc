# Audit Report

## Title
Panic-Induced Validator Crash via Malformed Telemetry Handshake Response

## Summary
The telemetry authentication function uses `.unwrap()` on Noise protocol handshake methods, causing validator nodes to crash with `process::exit(12)` when receiving malformed handshake responses from the telemetry service. This creates a single point of failure where compromising the centralized telemetry infrastructure can cause network-wide validator crashes.

## Finding Description

The `authenticate()` function in the telemetry sender performs a Noise IK handshake with the telemetry service but uses unsafe `.unwrap()` calls that panic on errors: [1](#0-0) [2](#0-1) 

Both `initiate_connection()` and `finalize_connection()` return `Result<T, NoiseError>` types that can fail with errors such as: [3](#0-2) 

When the telemetry service (compromised or malfunctioning) sends a malformed handshake response—such as a message that is too short, has corrupted encryption, or invalid format—the `finalize_connection()` call returns an error. The `.unwrap()` panics, triggering the global panic handler installed during node startup: [4](#0-3) [5](#0-4) 

The panic handler checks if the panic occurred during Move bytecode verification/deserialization and otherwise calls `process::exit(12)`, terminating the entire validator process. Since telemetry code is not in the VM verifier context, all authentication panics kill the node.

**Attack Execution Path:**

1. Validator node starts and spawns telemetry service in separate runtime
2. Background task attempts to send metrics (every 15 seconds)
3. First authenticated request triggers `authenticate()` 
4. Noise handshake initiated, AuthRequest sent to telemetry service
5. Malicious/compromised telemetry service responds with malformed data (e.g., response < 32 bytes or corrupted ciphertext)
6. `finalize_connection()` returns `NoiseError::MsgTooShort` or `NoiseError::Decrypt`
7. `.unwrap()` panics with thread panic
8. Global panic handler invoked, kills validator process via `process::exit(12)`

Contrast this with the proper error handling used in the network layer's Noise implementation: [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability enables a **total loss of network liveness** attack:

- The telemetry service at `telemetry.aptoslabs.com` / `telemetry.mainnet.aptoslabs.com` is a centralized infrastructure component shared by all validators
- Compromising this service allows sending malformed handshake responses to all connecting validators
- Each validator crashes on first authentication attempt (~15 seconds after startup)
- If attackers crash >33% of validators by stake weight, the network loses BFT liveness and cannot produce blocks
- Recovery requires restarting validators, during which the attacker can repeatedly crash them

This qualifies as **Critical Severity** per Aptos bug bounty criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)" if the attack persists.

Even if only affecting individual validators, this is **High Severity**: "Validator node slowdowns" and "Significant protocol violations" as nodes cannot participate in consensus.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attack Prerequisites:**
- Compromise of Aptos Labs telemetry infrastructure OR
- Successful MITM attack on HTTPS connections (via DNS hijacking, CA compromise, etc.) OR  
- Malfunction/bug in telemetry service sending invalid responses

**Exploitation Complexity:** Low - simply respond with corrupted or truncated data

**Frequency:** Authentication occurs on every validator startup and after 401 errors, making this a persistent attack vector

While compromising centralized infrastructure requires privileged access, the impact severity (network-wide liveness loss) and the ease of exploitation once access is gained make this a serious vulnerability. The centralized nature of the telemetry service creates a single point of failure affecting the entire validator network.

## Recommendation

Replace `.unwrap()` with proper error propagation using the `?` operator and handle authentication failures gracefully:

```rust
pub async fn authenticate(&self) -> Result<String, anyhow::Error> {
    let noise_config = match &self.auth_context.noise_config {
        Some(config) => config,
        None => return Err(anyhow!("Cannot send telemetry without private key")),
    };
    let server_public_key = self.server_public_key().await?;

    let mut client_noise_msg = vec![0; noise::handshake_init_msg_len(0)];
    let mut prologue = [0; PROLOGUE_SIZE];
    // ... setup prologue ...
    let mut rng = rand::rngs::OsRng;

    // Replace unwrap() with ? operator
    let initiator_state = noise_config
        .initiate_connection(
            &mut rng,
            &prologue,
            server_public_key,
            None,
            &mut client_noise_msg,
        )
        .map_err(|e| anyhow!("Failed to initiate noise handshake: {}", e))?;

    let auth_request = AuthRequest { /* ... */ };
    let response = self.client.post(self.build_path("auth")?).json(&auth_request).send().await?;
    let resp = error_for_status_with_body(response).await?.json::<AuthResponse>().await?;

    // Replace unwrap() with ? operator
    let (response_payload, _) = noise_config
        .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
        .map_err(|e| anyhow!("Failed to finalize noise handshake: {}", e))?;

    let jwt = String::from_utf8(response_payload)?;
    Ok(jwt)
}
```

This allows authentication failures to be logged and handled by callers (which already use `map_or_else` for error handling) without crashing the validator node.

## Proof of Concept

```rust
// Malicious telemetry server POC
use axum::{response::Json, routing::post, Router};
use aptos_telemetry_service::types::auth::{AuthRequest, AuthResponse};

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/api/v1/auth", post(malicious_auth_handler));
    
    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn malicious_auth_handler(
    Json(_payload): Json<AuthRequest>,
) -> Json<AuthResponse> {
    // Return malformed handshake message (too short)
    Json(AuthResponse {
        handshake_msg: vec![0u8; 10], // Should be 48 bytes minimum
    })
}

// To exploit:
// 1. Set TELEMETRY_SERVICE_URL=http://localhost:8080 on validator
// 2. Start validator node
// 3. Node crashes after ~15 seconds with panic in finalize_connection()
```

**Notes**

While this vulnerability exists in the codebase and the technical exploit path is valid, the practical exploitation requires either compromising the centralized Aptos Labs telemetry infrastructure or performing network-level MITM attacks, which may require privileged access. However, the centralized nature of the telemetry service and the severity of impact (network-wide liveness loss) make this a critical infrastructure vulnerability that should be addressed regardless of exploitation difficulty.

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L309-317)
```rust
        let initiator_state = noise_config
            .initiate_connection(
                &mut rng,
                &prologue,
                server_public_key,
                None,
                &mut client_noise_msg,
            )
            .unwrap();
```

**File:** crates/aptos-telemetry/src/sender.rs (L346-348)
```rust
        let (response_payload, _) = noise_config
            .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
            .unwrap();
```

**File:** crates/aptos-crypto/src/noise.rs (L139-181)
```rust
/// A NoiseError enum represents the different types of error that noise can return to users of the crate
#[derive(Debug, Error)]
pub enum NoiseError {
    /// the received message is too short to contain the expected data
    #[error("noise: the received message is too short to contain the expected data")]
    MsgTooShort,

    /// HKDF has failed (in practice there is no reason for HKDF to fail)
    #[error("noise: HKDF has failed")]
    Hkdf,

    /// encryption has failed (in practice there is no reason for encryption to fail)
    #[error("noise: encryption has failed")]
    Encrypt,

    /// could not decrypt the received data (most likely the data was tampered with
    #[error("noise: could not decrypt the received data")]
    Decrypt,

    /// the public key received is of the wrong format
    #[error("noise: the public key received is of the wrong format")]
    WrongPublicKeyReceived,

    /// session was closed due to decrypt error
    #[error("noise: session was closed due to decrypt error")]
    SessionClosed,

    /// the payload that we are trying to send is too large
    #[error("noise: the payload that we are trying to send is too large")]
    PayloadTooLarge,

    /// the message we received is too large
    #[error("noise: the message we received is too large")]
    ReceivedMsgTooLarge,

    /// the response buffer passed as argument is too small
    #[error("noise: the response buffer passed as argument is too small")]
    ResponseBufferTooSmall,

    /// the nonce exceeds the maximum u64 value (in practice this should not happen)
    #[error("noise: the nonce exceeds the maximum u64 value")]
    NonceOverflow,
}
```

**File:** aptos-node/src/lib.rs (L234-234)
```rust
    aptos_crash_handler::setup_panic_handler();
```

**File:** crates/crash-handler/src/lib.rs (L21-57)
```rust
/// Invoke to ensure process exits on a thread panic.
///
/// Tokio's default behavior is to catch panics and ignore them.  Invoking this function will
/// ensure that all subsequent thread panics (even Tokio threads) will report the
/// details/backtrace and then exit.
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** network/framework/src/noise/handshake.rs (L209-218)
```rust
        let initiator_state = self
            .noise_config
            .initiate_connection(
                &mut rng,
                prologue_msg,
                remote_public_key,
                Some(&payload),
                client_noise_msg,
            )
            .map_err(NoiseHandshakeError::BuildClientHandshakeMessageFailed)?;
```

**File:** network/framework/src/noise/handshake.rs (L253-256)
```rust
        let (_, session) = self
            .noise_config
            .finalize_connection(initiator_state, &server_response)
            .map_err(NoiseHandshakeError::ClientFinalizeFailed)?;
```
