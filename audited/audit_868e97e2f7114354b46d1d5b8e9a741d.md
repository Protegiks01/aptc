# Audit Report

## Title
Insecure File Permissions in Move Package Download - World-Readable Source Code Exposure

## Summary
The `save_package_to_disk()` function in the Aptos CLI does not set explicit file permissions when writing Move.toml and source files to disk, relying instead on the system's umask. On multi-user systems with permissive umask settings (common on many Linux distributions), downloaded Move packages are created with world-readable permissions, exposing proprietary source code and package configuration to unauthorized local users.

## Finding Description

The `save_package_to_disk()` function writes Move package files without setting explicit Unix file permissions: [1](#0-0) 

The function uses `fs::create_dir_all()` for directories and `fs::write()` for files, both of which apply default permissions based on the system's umask rather than enforcing secure permissions. This creates a security vulnerability where:

1. **Default File Permissions**: Rust's `fs::write()` creates files with mode `0o666 & !umask`
2. **Default Directory Permissions**: `fs::create_dir_all()` creates directories with mode `0o777 & !umask`
3. **Common Umask Values**: Many Linux distributions use umask `0o002` or `0o022`, resulting in:
   - Files: `0o664` (rw-rw-r--) or `0o644` (rw-r--r--) → **world-readable**
   - Directories: `0o775` (rwxrwxr-x) or `0o755` (rwxr-xr-x) → **world-readable/traversable**

In contrast, the codebase provides `write_to_user_only_file()` that explicitly sets mode `0o600` (user read/write only): [2](#0-1) 

This secure function is used throughout the codebase for sensitive files:
- Private keys: [3](#0-2) 
- Configuration files: [4](#0-3) 

However, `save_package_to_disk()` is called during package downloads without these protections: [5](#0-4) 

**Attack Scenario:**
1. Developer downloads a Move package on a shared system (development server, cloud VM) using `aptos move download`
2. System has default umask `0o002` (common on Ubuntu, Debian, RHEL)
3. Files are created with permissions `0o664` (world-readable)
4. Other local users can read the Move source code: `cat /path/to/package/sources/*.move`
5. Exposed information includes:
   - Proprietary business logic and algorithms
   - Smart contract implementation details
   - Package dependencies and structure (from Move.toml)

In extreme cases with umask `0o000`, files would be world-writable (`0o666`), allowing code tampering and supply chain attacks.

## Impact Explanation

This vulnerability falls under **Low Severity** per the Aptos bug bounty criteria: "Minor information leaks, Non-critical implementation bugs."

**Why Low (not higher):**
- Does not affect blockchain consensus or validator operations
- Does not enable funds theft or on-chain exploits
- Does not cause network partition or liveness failures
- Requires local system access (not remote exploitation)
- Impact limited to information disclosure on the local machine

**Security Harm:**
- **Information Disclosure**: Proprietary Move source code becomes readable by unauthorized local users
- **Competitive Intelligence Leak**: Business logic and algorithms exposed to competitors with local access
- **Limited Tampering Risk**: With very permissive umask, malicious local users could modify code before compilation

This is a defense-in-depth issue affecting confidentiality on multi-user systems, where developers may reasonably expect their working files to be protected from other system users.

## Likelihood Explanation

**High Likelihood** on affected systems:

1. **Common Configuration**: Many Linux distributions ship with umask `0o002` or `0o022` by default, making downloaded packages world-readable
2. **Typical Environments**: Development teams commonly use:
   - Shared development servers accessed by multiple developers
   - Cloud VMs (AWS, GCP, Azure) where multiple team members have shell access
   - Containerized development environments with shared volumes
3. **No User Warning**: The CLI provides no indication that downloaded files may be accessible to other users
4. **Automatic Exposure**: The vulnerability is triggered automatically during normal package download operations

**Attacker Requirements:**
- Local user account on the same system as the victim
- Ability to read files in the victim's directory (depends on umask and parent directory permissions)
- No special privileges required

## Recommendation

Apply the same security pattern used for sensitive files throughout the Aptos CLI codebase. Modify `save_package_to_disk()` to use restricted permissions:

```rust
pub fn save_package_to_disk(&self, path: &Path) -> anyhow::Result<()> {
    use std::os::unix::fs::OpenOptionsExt;
    use std::fs::OpenOptions;
    use std::io::Write;
    
    fs::create_dir_all(path)?;
    
    // Write Move.toml with restricted permissions (0o600)
    let manifest_path = path.join("Move.toml");
    let manifest_content = unzip_metadata_str(&self.metadata.manifest)?;
    #[cfg(unix)]
    {
        let mut file = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .mode(0o600)
            .open(&manifest_path)?;
        file.write_all(manifest_content.as_bytes())?;
    }
    #[cfg(not(unix))]
    {
        fs::write(&manifest_path, manifest_content)?;
    }
    
    let sources_dir = path.join(CompiledPackageLayout::Sources.path());
    fs::create_dir_all(&sources_dir)?;
    
    for module in &self.metadata.modules {
        if !module.source.is_empty() {
            let source = unzip_metadata_str(&module.source)?;
            let source_path = sources_dir.join(format!("{}.move", module.name));
            
            #[cfg(unix)]
            {
                let mut file = OpenOptions::new()
                    .write(true)
                    .create(true)
                    .truncate(true)
                    .mode(0o600)
                    .open(&source_path)?;
                file.write_all(source.as_bytes())?;
            }
            #[cfg(not(unix))]
            {
                fs::write(&source_path, source)?;
            }
        }
    }
    Ok(())
}
```

Alternatively, refactor to use the existing `write_to_user_only_file()` helper: [2](#0-1) 

## Proof of Concept

**Setup:**
```bash
# On a Linux system with umask 0o002 (default on many distributions)
$ umask
0002

# Create a test user to simulate an attacker
$ sudo useradd -m attacker

# As normal developer user, download a Move package
$ aptos move download --account 0x1 --package AptosFramework --output-dir /tmp/test_package
```

**Exploitation:**
```bash
# As the attacker user, attempt to read the downloaded package
$ su - attacker
$ ls -la /tmp/test_package/
drwxrwxr-x  sources/
-rw-rw-r--  Move.toml     # World-readable!

$ cat /tmp/test_package/Move.toml
# Contents visible to attacker

$ cat /tmp/test_package/sources/*.move
# All Move source code visible to attacker
```

**Verification of Vulnerability:**
```bash
# Check actual permissions
$ stat -c "%a %n" /tmp/test_package/Move.toml
664 /tmp/test_package/Move.toml

$ stat -c "%a %n" /tmp/test_package/sources/*.move
664 /tmp/test_package/sources/account.move
664 /tmp/test_package/sources/coin.move
# All files are world-readable (group and others can read)
```

**Expected Behavior (with fix):**
```bash
$ stat -c "%a %n" /tmp/test_package/Move.toml
600 /tmp/test_package/Move.toml  # Only owner can read/write

$ cat /tmp/test_package/Move.toml
cat: /tmp/test_package/Move.toml: Permission denied  # Attacker blocked
```

## Notes

This vulnerability represents a deviation from the security pattern established elsewhere in the Aptos CLI codebase, where sensitive files (private keys, configuration) are consistently protected with mode `0o600`. The oversight appears to stem from treating Move source code as non-sensitive, when in fact it may contain proprietary business logic that developers expect to remain confidential on shared systems.

While this does not affect the blockchain's security properties directly, it violates reasonable developer expectations about file confidentiality and represents a defense-in-depth weakness that should be addressed to align with the security practices applied to other file operations in the codebase.

### Citations

**File:** crates/aptos/src/move_tool/stored_package.rs (L161-181)
```rust
    pub fn save_package_to_disk(&self, path: &Path) -> anyhow::Result<()> {
        fs::create_dir_all(path)?;
        fs::write(
            path.join("Move.toml"),
            unzip_metadata_str(&self.metadata.manifest)?,
        )?;
        let sources_dir = path.join(CompiledPackageLayout::Sources.path());
        fs::create_dir_all(&sources_dir)?;
        for module in &self.metadata.modules {
            match module.source.is_empty() {
                true => {
                    println!("module without code: {}", module.name);
                },
                false => {
                    let source = unzip_metadata_str(&module.source)?;
                    fs::write(sources_dir.join(format!("{}.move", module.name)), source)?;
                },
            };
        }
        Ok(())
    }
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```

**File:** crates/aptos/src/config/mod.rs (L369-379)
```rust
        write_to_user_only_file(
            global_folder.join(GLOBAL_CONFIG_FILE).as_path(),
            "Global Config",
            &to_yaml(&self)?.into_bytes(),
        )?;
        // Let's also write a .gitignore that ignores this folder
        write_to_user_only_file(
            global_folder.join(GIT_IGNORE).as_path(),
            ".gitignore",
            APTOS_FOLDER_GIT_IGNORE.as_bytes(),
        )
```

**File:** crates/aptos/src/move_tool/mod.rs (L2001-2004)
```rust
        let package_path = output_dir.join(package.name());
        package
            .save_package_to_disk(package_path.as_path())
            .map_err(|e| CliError::UnexpectedError(format!("Failed to save package: {}", e)))?;
```
