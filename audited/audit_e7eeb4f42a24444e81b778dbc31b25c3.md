# Audit Report

## Title
Symlink Attack in Aptos CLI Initialization Allows Private Key Disclosure

## Summary
The `aptos init` command writes Ed25519 private keys to `.aptos/config.yaml` without validating that the path is not a symlink. An attacker with local filesystem access can pre-create a symlink at this location pointing to an attacker-controlled file, causing the CLI to write the user's private key to the symlink target, leading to complete account compromise and loss of funds.

## Finding Description
The vulnerability exists in the file writing mechanism used by the Aptos CLI initialization process. When a user runs `aptos init`, the tool generates or accepts an Ed25519 private key and saves it to `.aptos/config.yaml` in the current directory. [1](#0-0) 

The configuration save process calls `CliConfig::save()` which writes the serialized config containing the private key: [2](#0-1) 

The `write_to_user_only_file()` function ultimately uses `OpenOptions::open()` which follows symlinks by default: [3](#0-2) 

There is no symlink validation using `O_NOFOLLOW`, metadata checks via `Path::symlink_metadata()`, or any other symlink protection mechanism in the codebase.

**Attack Flow:**
1. Attacker with write access to the target directory creates `.aptos/` directory
2. Attacker creates symlink: `.aptos/config.yaml` â†’ `/tmp/attacker_file`
3. User runs `aptos init` in that directory
4. CLI writes private key to symlink target (`/tmp/attacker_file`)
5. Attacker reads private key from `/tmp/attacker_file`
6. Attacker gains full control of user's Aptos account

The ProfileConfig structure stores the sensitive Ed25519 private key: [4](#0-3) 

## Impact Explanation
**Severity: HIGH** (per Aptos Bug Bounty criteria: up to $50,000)

This vulnerability leads to complete private key disclosure, which enables:
- **Total Loss of Funds**: Attacker can sign transactions to transfer all APT tokens and assets from the victim's account
- **Account Takeover**: Permanent compromise of the user's Aptos identity
- **Transaction Forgery**: Ability to submit arbitrary transactions as the victim

While this is a client-side CLI vulnerability rather than a protocol vulnerability, it directly causes "Loss of Funds" which meets Critical severity criteria. However, given that it requires local filesystem access (not remote exploitation), HIGH severity is most appropriate.

## Likelihood Explanation
**Likelihood: MEDIUM**

The attack requires:
- Local filesystem write access to the directory where user runs `aptos init`
- Timing: Symlink must be created before user runs `aptos init`
- Social engineering or shared system access

Common scenarios:
- Shared development environments
- Compromised local machines
- Malicious scripts in development tools
- Docker containers with untrusted volumes

The attack is technically simple (single symlink creation) but requires local access, making it moderately likely in multi-user or compromised environments.

## Recommendation

Implement symlink protection in the file writing functions. On Unix systems, use `O_NOFOLLOW` flag to prevent following symlinks:

```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        // Add O_NOFOLLOW to prevent symlink following
        opts.custom_flags(libc::O_NOFOLLOW);
    }
    
    // Check if path is a symlink before opening
    if path.exists() {
        let metadata = std::fs::symlink_metadata(path)
            .map_err(|e| CliError::IO(name.to_string(), e))?;
        if metadata.is_symlink() {
            return Err(CliError::UnexpectedError(
                format!("Refusing to write to symlink: {}", path.display())
            ));
        }
    }
    
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

Additionally, validate that `.aptos/` directory is not a symlink: [5](#0-4) 

## Proof of Concept

**Setup:**
```bash
# Create test directory
mkdir /tmp/aptos-test && cd /tmp/aptos-test

# Attacker creates malicious symlink
mkdir .aptos
ln -s /tmp/stolen_keys.txt .aptos/config.yaml

# Create attacker-controlled target file
touch /tmp/stolen_keys.txt
chmod 666 /tmp/stolen_keys.txt
```

**Execution:**
```bash
# Victim runs aptos init
aptos init --network devnet --assume-yes

# Attacker reads stolen private key
cat /tmp/stolen_keys.txt
# Output contains: private_key: "ed25519-priv-0x..."
```

**Verification:**
```bash
# Confirm symlink was followed
ls -la .aptos/config.yaml
# Shows: .aptos/config.yaml -> /tmp/stolen_keys.txt

# Confirm private key is readable
grep "private_key" /tmp/stolen_keys.txt
# Shows the Ed25519 private key in plaintext
```

The attacker now has complete control over the victim's Aptos account and can drain all funds.

## Notes

This vulnerability affects all Unix-based systems (Linux, macOS) where symlinks are supported. The attack requires local filesystem access, making it most relevant in:
- Shared development servers
- Multi-user systems  
- Compromised developer machines
- Containerized environments with untrusted mounts

The fix should be applied to all file writing operations handling sensitive data, not just config files.

### Citations

**File:** crates/aptos/src/common/init.rs (L280-280)
```rust
        profile_config.private_key = private_key;
```

**File:** crates/aptos/src/common/types.rs (L276-282)
```rust
    #[serde(
        skip_serializing_if = "Option::is_none",
        default,
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub private_key: Option<Ed25519PrivateKey>,
```

**File:** crates/aptos/src/common/types.rs (L441-445)
```rust
        let config_file = aptos_folder.join(CONFIG_FILE);
        let config_bytes = serde_yaml::to_string(&self).map_err(|err| {
            CliError::UnexpectedError(format!("Failed to serialize config {}", err))
        })?;
        write_to_user_only_file(&config_file, CONFIG_FILE, config_bytes.as_bytes())?;
```

**File:** crates/aptos/src/common/utils.rs (L232-246)
```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/common/utils.rs (L416-425)
```rust
pub fn create_dir_if_not_exist(dir: &Path) -> CliTypedResult<()> {
    // Check if the directory exists, if it's not a dir, it will also fail here
    if !dir.exists() || !dir.is_dir() {
        std::fs::create_dir_all(dir).map_err(|e| CliError::IO(dir.display().to_string(), e))?;
        debug!("Created {} folder", dir.display());
    } else {
        debug!("{} folder already exists", dir.display());
    }
    Ok(())
}
```
