# Audit Report

## Title
BlockSTMv2 Partial Delayed Field Application Leads to Panic on Re-execution

## Summary
In `process_delayed_field_output()`, when `record_change()` fails for a delayed field, the function captures the error but continues processing subsequent fields. In BlockSTMv2, the abort path does not properly clean up these partially-applied changes, causing a panic when re-execution attempts to remove the never-recorded field.

## Finding Description

The vulnerability exists in the error handling path of delayed field processing within the BlockSTMv2 execution flow.

**Step 1: Partial Application of Delayed Fields**

When processing delayed field outputs, if `record_change()` fails with a `PanicOr::Or(_)` error (such as `MVDelayedFieldsError::NotFound`), the function captures the error but continues processing: [1](#0-0) 

The critical issue is that after capturing the error at lines 371-373, the loop continues without returning, allowing subsequent delayed fields to be successfully recorded in `versioned_cache`.

**Step 2: Validation Failure and Incomplete Cleanup**

When validation fails due to the captured error, the delayed field error flag causes validation to return false: [2](#0-1) 

This triggers re-execution via `abort_pre_final_reexecution()`. However, in BlockSTMv2, this function does NOT call `update_transaction_on_abort()`: [3](#0-2) 

In contrast, BlockSTMv1 properly cleans up partial state: [4](#0-3) 

**Step 3: Panic During Cleanup**

During re-execution, if the new incarnation produces different delayed field outputs, the cleanup code attempts to remove previous fields: [5](#0-4) 

When trying to remove a field that failed to record initially, the `remove()` method panics because the field never existed: [6](#0-5) 

**Attack Scenario:**
1. Attacker submits a transaction that attempts to apply an `AggregatorDelta` to a non-existent aggregator ID
2. During execution, some delayed fields record successfully (field A), but the delta application fails with `NotFound` (field B), and other fields record successfully (field C)
3. The error flag is set, but A and C remain in `versioned_cache`
4. Validation fails, triggering re-execution
5. BlockSTMv2's abort path does NOT clean up A and C from `versioned_cache`
6. Re-execution produces different delayed field outputs (e.g., only field D)
7. Cleanup attempts to remove field B, which never existed
8. `remove()` panics with code_invariant_error, crashing the validator

This breaks the **Deterministic Execution** and **State Consistency** invariants, as validators may encounter different timing conditions that cause the panic, leading to consensus divergence.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

- **Validator node crashes**: The panic caused by attempting to remove a non-existent delayed field will crash the validator node, qualifying as "Validator node slowdowns" or worse
- **Consensus impact**: If different validators experience different execution states due to timing or state variations, some may panic while others continue, potentially causing consensus issues
- **Significant protocol violation**: The partial application of state changes violates atomicity guarantees

While this doesn't directly cause permanent funds loss, it can cause validator unavailability and consensus disruption, meeting High Severity criteria.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is exploitable when:
1. A transaction attempts delayed field operations on non-existent aggregators (can be crafted by attacker)
2. The system uses BlockSTMv2 (the newer execution model)
3. Re-execution produces different delayed field outputs than the initial execution

The attacker can deliberately craft transactions that trigger the `NotFound` error by:
- Creating delayed field operations that reference aggregator IDs that don't exist in storage
- Using SnapshotDelta or derived operations on non-existent base aggregators

The complexity is low - the attacker only needs to submit a transaction with specific delayed field operations. No special privileges are required.

## Recommendation

**Fix 1: Ensure BlockSTMv2 cleans up partial state on abort**

Modify `abort_pre_final_reexecution()` to call `update_transaction_on_abort()` for BlockSTMv2:

```rust
pub(crate) fn abort_pre_final_reexecution<T, E>(
    &self,
    txn_idx: TxnIndex,
    incarnation: Incarnation,
    last_input_output: &TxnLastInputOutput<T, E::Output>,
    versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
) -> Result<(), PanicError>
where
    T: BlockExecutableTransaction,
    E: ExecutorTask<Txn = T>,
{
    match self {
        SchedulerWrapper::V1(_, _) => {
            update_transaction_on_abort::<T, E>(txn_idx, last_input_output, versioned_cache);
        },
        SchedulerWrapper::V2(scheduler, _) => {
            // Add cleanup for V2 as well
            update_transaction_on_abort::<T, E>(txn_idx, last_input_output, versioned_cache);
            scheduler.direct_abort(txn_idx, incarnation, true)?;
        },
    }
    Ok(())
}
```

**Fix 2: Early return on record_change failure**

Alternatively, modify `process_delayed_field_output()` to return immediately on `record_change()` failure, preventing partial application:

```rust
if let Err(e) = versioned_cache
    .delayed_fields()
    .record_change(id, idx_to_execute, entry)
{
    match e {
        PanicOr::CodeInvariantError(m) => {
            return Err(code_invariant_error(format!(
                "Record change failed with CodeInvariantError: {:?}",
                m
            )));
        },
        PanicOr::Or(_) => {
            read_set.capture_delayed_field_read_error(&PanicOr::Or(
                MVDelayedFieldsError::DeltaApplicationFailure,
            ));
            // Return early to prevent partial application
            return Ok(());
        },
    };
}
```

**Recommended Approach:** Implement Fix 1, as it maintains consistency with BlockSTMv1's behavior and ensures proper cleanup of partial state.

## Proof of Concept

```rust
// Rust-based reproduction steps:

// 1. Create a transaction that attempts to apply a delta to a non-existent aggregator
// Example delayed field operation:
let non_existent_aggregator_id = DelayedFieldID::new_for_test_for_u64(99999);
let delta = DeltaOp::new(SignedU128::Positive(100), 1000, DeltaHistory::default());
let change = DelayedEntry::Apply(DelayedApplyEntry::AggregatorDelta { delta });

// 2. Execute the transaction in BlockSTMv2 mode
// - First execution will fail when recording the change for the non-existent aggregator
// - Error is captured but other fields may be recorded successfully
// - Validation fails, triggering re-execution

// 3. During re-execution with different outputs:
// - Cleanup code attempts to remove the non-existent field
// - Panic occurs in versioned_delayed_fields.rs:533

// Expected behavior: Code invariant error panic
// Error message: "VersionedValue for an (resolved) ID DelayedFieldID(...) must already exist"
```

**Move-based test scenario:**

```move
// Create a Move transaction that:
// 1. Attempts to create or modify multiple aggregators/snapshots
// 2. Include operations on non-existent aggregator IDs
// 3. Mix valid and invalid delayed field operations
// This will trigger the partial application vulnerability in BlockSTMv2 execution
```

The vulnerability is reproducible by crafting transactions with delayed field operations that reference non-existent aggregator IDs, causing `record_change()` to fail for some fields while succeeding for others, then observing the panic during cleanup on re-execution.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L358-377)
```rust
                if let Err(e) =
                    versioned_cache
                        .delayed_fields()
                        .record_change(id, idx_to_execute, entry)
                {
                    match e {
                        PanicOr::CodeInvariantError(m) => {
                            return Err(code_invariant_error(format!(
                                "Record change failed with CodeInvariantError: {:?}",
                                m
                            )));
                        },
                        PanicOr::Or(_) => {
                            read_set.capture_delayed_field_read_error(&PanicOr::Or(
                                MVDelayedFieldsError::DeltaApplicationFailure,
                            ));
                        },
                    };
                }
            }
```

**File:** aptos-move/block-executor/src/executor.rs (L380-384)
```rust
        for id in prev_modified_delayed_fields {
            versioned_cache
                .delayed_fields()
                .remove(&id, idx_to_execute, is_v2)?;
        }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1147-1149)
```rust
        if self.delayed_field_speculative_failure {
            return Ok(false);
        }
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L118-122)
```rust
            SchedulerWrapper::V1(_, _) => {
                // Updating the scheduler state not required as the execute method invoked
                // in [executor::execute_txn_after_commit] does not take in the scheduler.
                update_transaction_on_abort::<T, E>(txn_idx, last_input_output, versioned_cache);
            },
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L123-125)
```rust
            SchedulerWrapper::V2(scheduler, _) => {
                scheduler.direct_abort(txn_idx, incarnation, true)?;
            },
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L531-540)
```rust
        self.values
            .get_mut(id)
            .ok_or_else(|| {
                code_invariant_error(format!(
                    "VersionedValue for an (resolved) ID {:?} must already exist",
                    id
                ))
            })?
            .remove(txn_idx, is_blockstm_v2);
        Ok(())
```
