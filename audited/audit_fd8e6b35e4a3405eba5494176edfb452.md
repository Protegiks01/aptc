# Audit Report

## Title
Missing Network Sender Authentication in Secret Share Broadcast Path Enables Share Replay and Attribution Confusion

## Summary
The secret sharing subsystem fails to validate that the network sender matches the claimed author when processing broadcast secret shares. While cryptographic validation ensures shares are genuine, the absence of sender authentication allows Byzantine validators to replay other validators' shares, causing attribution errors and complicating Byzantine fault detection.

## Finding Description

The Aptos consensus uses threshold secret sharing to decrypt transactions in blocks. Each validator computes and broadcasts their share, which are aggregated once the threshold is met.

There are two code paths for receiving shares:

**Path 1 - Reliable Broadcast (request-response)**: Properly validates sender matches author [1](#0-0) 

**Path 2 - Proactive Broadcast**: Missing sender validation  
The network layer captures the actual sender: [2](#0-1) 

However, the `sender` field is marked unused and the verification task discards this information: [3](#0-2) 

When shares are processed, only cryptographic validation occurs without checking network sender: [4](#0-3) 

The unused `_author` field in `SecretShareConfig` could support additional validation but remains unutilized: [5](#0-4) 

**Attack Scenario:**
1. Byzantine validator Alice monitors network traffic and captures honest validator Bob's share for round R
2. Alice re-broadcasts Bob's share before Bob completes his broadcast to all nodes
3. The share passes cryptographic verification (it's Bob's genuine share signed with Bob's key)
4. The share is stored with `author=Bob` without verifying the network sender was actually Bob
5. Logs attribute the share to Bob, not Alice

Shares are deduplicated by author in the aggregator: [6](#0-5) 

## Impact Explanation

This constitutes a **Medium severity** protocol violation based on:

1. **Byzantine Fault Detection Degradation**: Forensic analysis cannot reliably determine which validators sent which shares, complicating identification of Byzantine behavior during incident response

2. **Attribution Integrity**: Consensus logs misattribute share transmission, violating the integrity of audit trails required for validator accountability

3. **Defense-in-Depth Violation**: The inconsistency between the reliable broadcast path (which validates sender) and the proactive broadcast path creates an unnecessary attack surface

While this does not directly cause funds loss or state inconsistencies, it represents a significant protocol violation where network-level authentication is bypassed. The cryptographic validation alone is insufficient for a complete security model in distributed consensus.

## Likelihood Explanation

**High likelihood** - Any Byzantine validator (< 1/3 of stake) can exploit this by:
- Passively monitoring network traffic (standard network capability)
- Re-broadcasting captured shares (no special privileges required)
- No cryptographic attacks needed (uses genuine shares)

The attack requires minimal sophistication and can be executed continuously without detection.

## Recommendation

Add sender validation in the verification task before forwarding messages:

```rust
async fn verification_task(
    epoch_state: Arc<EpochState>,
    mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
    verified_msg_tx: UnboundedSender<SecretShareRpc>,
    config: SecretShareConfig,
    bounded_executor: BoundedExecutor,
) {
    while let Some(dec_msg) = incoming_rpc_request.next().await {
        let tx = verified_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        let config_clone = config.clone();
        let sender = dec_msg.sender;  // Capture sender
        bounded_executor
            .spawn(async move {
                match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                    Ok(msg) => {
                        if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                            // Add sender validation for Share messages
                            if let SecretShareMessage::Share(ref share) = msg {
                                if share.author() != &sender {
                                    warn!("Sender {} does not match share author {}", sender, share.author());
                                    return;
                                }
                            }
                            let _ = tx.unbounded_send(SecretShareRpc {
                                msg,
                                protocol: dec_msg.protocol,
                                response_sender: dec_msg.response_sender,
                            });
                        }
                    },
                    Err(e) => {
                        warn!("Invalid dec message: {}", e);
                    },
                }
            })
            .await;
    }
}
```

Remove `#[allow(unused)]` from the sender field: [7](#0-6) 

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: consensus/src/rand/secret_sharing/tests/replay_attack_test.rs

#[tokio::test]
async fn test_share_replay_from_wrong_sender() {
    // Setup: Create two validators Alice and Bob
    let alice_addr = AccountAddress::random();
    let bob_addr = AccountAddress::random();
    
    // Bob creates a legitimate share
    let bob_share = create_valid_share(bob_addr, round, epoch, block_id);
    
    // Alice intercepts Bob's share and creates a network message claiming to be Bob
    let malicious_msg = SecretShareNetworkMessage {
        epoch,
        data: bcs::to_bytes(&SecretShareMessage::Share(bob_share.clone())).unwrap(),
    };
    
    // Alice sends this message - currently there's no check that alice_addr != bob_addr
    let incoming_req = IncomingSecretShareRequest {
        req: malicious_msg,
        sender: alice_addr,  // Alice is the actual sender
        protocol: RPC[0],
        response_sender: tx,
    };
    
    // Process the message through verification_task
    // Expected: Should reject because sender (Alice) != share.author (Bob)
    // Actual: Accepts the share, logs show Bob as the sender
    
    // Verify that the share is accepted despite sender mismatch
    assert!(store.contains_share_from(bob_addr));  // Share is stored as from Bob
    // But actual network sender was Alice - no validation occurred
}
```

## Notes

The reliable broadcast path correctly implements sender validation, demonstrating that this check is intentional for security. The proactive broadcast path should maintain the same authentication requirements for consistency and defense-in-depth. While cryptographic validation prevents share forgery, network sender authentication is essential for proper attribution, Byzantine fault detection, and audit integrity in distributed consensus systems.

### Citations

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-45)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
```

**File:** consensus/src/network.rs (L154-161)
```rust
#[derive(Debug)]
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L212-225)
```rust
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L310-320)
```rust
            SecretShareMessage::Share(share) => {
                info!(LogSchema::new(LogEvent::ReceiveSecretShare)
                    .author(self.author)
                    .epoch(share.epoch())
                    .round(share.metadata().round)
                    .remote_peer(*share.author()));

                if let Err(e) = self.secret_share_store.lock().add_share(share) {
                    warn!("[SecretShareManager] Failed to add share: {}", e);
                }
            },
```

**File:** types/src/secret_sharing.rs (L136-137)
```rust
pub struct SecretShareConfig {
    _author: Author,
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L32-36)
```rust
    pub fn add_share(&mut self, share: SecretShare, weight: u64) {
        if self.shares.insert(share.author, share).is_none() {
            self.total_weight += weight;
        }
    }
```
