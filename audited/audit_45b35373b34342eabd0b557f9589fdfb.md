# Audit Report

## Title
Epoch Confusion Attack via Missing QuorumCert Epoch Validation in TwoChainTimeout

## Summary
The `TwoChainTimeout` structure fails to validate that its embedded `quorum_cert` belongs to the same epoch as the timeout itself. This allows a malicious validator to construct timeout messages claiming to be for epoch N while embedding a QuorumCert from epoch N-1, potentially enabling cross-epoch consensus attacks.

## Finding Description

The `RoundTimeout.epoch()` method correctly returns the epoch that was signed in the timeout signature. [1](#0-0) 

However, the critical security issue lies in the `TwoChainTimeout` structure, which contains two separate epoch values without cross-validation:
1. A top-level `epoch: u64` field
2. An embedded `quorum_cert: QuorumCert` containing `BlockInfo` with its own `epoch` field [2](#0-1) 

When a timeout is signed, the `signing_format()` method uses the top-level `epoch` field. [3](#0-2) 

The vulnerability exists in `TwoChainTimeout.verify()`, which validates the quorum certificate but **never checks** that the QC's epoch matches the timeout's epoch. [4](#0-3) 

**Attack Scenario:**

1. During epoch 2, a malicious validator creates a `TwoChainTimeout` with:
   - `epoch: 2` (current epoch)
   - `round: 5`
   - `quorum_cert`: A valid QC from epoch 1 with `BlockInfo.epoch = 1`

2. The validator signs this timeout, producing a valid signature for `TimeoutSigningRepr { epoch: 2, round: 5, hqc_round: <epoch1_round> }`

3. The timeout is broadcast to other validators

4. During verification:
   - `RoundTimeout.verify()` calls `timeout.verify(validator)` [5](#0-4) 
   - The QC is verified using epoch 2's `ValidatorVerifier`
   - The signature is verified against epoch 2's validator set
   - **No check exists** that `timeout.epoch == quorum_cert.certified_block().epoch()`

5. If there is sufficient validator set overlap between epochs (common during gradual validator rotations), the QC signatures may verify successfully against epoch 2's validator set even though they were created in epoch 1

6. The timeout is accepted as valid for epoch 2, but contains epoch 1 consensus state

**Broken Invariants:**
- **Epoch Isolation**: Consensus artifacts from different epochs are mixed
- **Consensus Safety**: Different validator set contexts are conflated, potentially allowing safety rule bypasses

While `SyncInfo.verify()` checks that the timeout certificate's epoch matches other certificates, it only validates the top-level `tc.epoch()` field. [6](#0-5) 

Even safety rules validation only checks the top-level epoch field. [7](#0-6) 

## Impact Explanation

**Severity: Critical**

This vulnerability enables **Consensus Safety Violations** through epoch confusion:

1. **Validator Set Bypass**: A QC signed by epoch 1 validators (who may no longer be in the active set or have reduced stake) can be used to advance consensus in epoch 2

2. **Stale State Injection**: The QC's `hqc_round` becomes part of the timeout certificate aggregation logic, but represents chain state from a different epoch context

3. **Cross-Epoch Attack Window**: During epoch transitions when validator sets overlap, malicious validators can inject old QCs to manipulate timeout certificate formation

4. **Safety Rule Circumvention**: The `safe_to_timeout()` check compares the QC round against safety data, but doesn't account for epoch boundaries [8](#0-7) 

This qualifies as **Critical Severity** under Aptos bug bounty criteria as it enables **Consensus/Safety violations** that could lead to chain forks or double-spending under specific validator set overlap conditions.

## Likelihood Explanation

**Likelihood: Medium-High during epoch transitions**

The attack is feasible when:
1. **Validator Set Overlap**: Sufficient overlap exists between consecutive epochs (common in practice for gradual rotations)
2. **Malicious Validator**: At least one validator from the overlapping set acts maliciously
3. **Timing Window**: The attack occurs during or shortly after an epoch transition

The likelihood increases because:
- Aptos designs validator set transitions to be gradual (not complete replacement)
- No additional authentication checks the embedded QC's epoch
- The vulnerability is in core consensus path, affecting all timeout processing

## Recommendation

Add epoch consistency validation in `TwoChainTimeout.verify()`:

```rust
pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
    ensure!(
        self.hqc_round() < self.round(),
        "Timeout round should be larger than the QC round"
    );
    
    // NEW: Validate QC epoch matches timeout epoch
    ensure!(
        self.epoch == self.quorum_cert.certified_block().epoch(),
        "Timeout epoch {} does not match QC epoch {}",
        self.epoch,
        self.quorum_cert.certified_block().epoch()
    );
    
    self.quorum_cert.verify(validators)?;
    Ok(())
}
```

This ensures epoch isolation by preventing QCs from one epoch from being embedded in timeouts for another epoch.

## Proof of Concept

```rust
#[test]
fn test_epoch_confusion_attack() {
    use aptos_consensus_types::{
        quorum_cert::QuorumCert,
        timeout_2chain::TwoChainTimeout,
        vote_data::VoteData,
    };
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::PartialSignatures,
        validator_verifier::random_validator_verifier,
    };
    
    let (signers, validators) = random_validator_verifier(4, None, false);
    
    // Create a valid QC for epoch 1, round 3
    let epoch1_block = BlockInfo::random_with_epoch(1, 3);
    let vote_data = VoteData::new(epoch1_block.clone(), BlockInfo::random_with_epoch(1, 2));
    let mut ledger_info_sigs = LedgerInfoWithSignatures::new(
        LedgerInfo::new(epoch1_block, vote_data.hash()),
        PartialSignatures::empty(),
    );
    
    // Sign QC with epoch 1 validators
    for signer in &signers[0..3] {
        let sig = signer.sign(ledger_info_sigs.ledger_info()).unwrap();
        ledger_info_sigs.add_signature(signer.author(), sig);
    }
    let qc_epoch1 = QuorumCert::new(
        vote_data,
        ledger_info_sigs.aggregate_signatures(&validators).unwrap(),
    );
    
    // Create timeout claiming to be for epoch 2, but with epoch 1 QC
    let malicious_timeout = TwoChainTimeout::new(
        2,  // Claim epoch 2
        5,  // Round 5
        qc_epoch1,  // But QC is from epoch 1!
    );
    
    // This should FAIL but currently might PASS if validator sets overlap
    // The verify() method doesn't check qc.certified_block().epoch() == timeout.epoch()
    let result = malicious_timeout.verify(&validators);
    
    // Currently this may pass verification due to missing epoch check
    // After fix, this should return: "Timeout epoch 2 does not match QC epoch 1"
    assert!(result.is_err(), "Epoch confusion attack should be prevented");
}
```

**Notes:**
- This validation gap is particularly critical during epoch boundaries when validator set changes occur
- The fix is straightforward but essential for maintaining epoch isolation guarantees
- Without this check, the consensus protocol assumes epoch consistency that isn't cryptographically enforced

### Citations

**File:** consensus/consensus-types/src/round_timeout.rs (L81-83)
```rust
    pub fn epoch(&self) -> u64 {
        self.timeout.epoch()
    }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L24-32)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TwoChainTimeout {
    /// Epoch number corresponds to the set of validators that are active for this round.
    epoch: u64,
    /// The consensus protocol executes proposals (blocks) in rounds, which monotonically increase per epoch.
    round: Round,
    /// The highest quorum cert the signer has seen.
    quorum_cert: QuorumCert,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L74-81)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.hqc_round() < self.round(),
            "Timeout round should be larger than the QC round"
        );
        self.quorum_cert.verify(validators)?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L148-150)
```rust
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L26-26)
```rust
        self.verify_epoch(timeout.epoch(), &safety_data)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```
