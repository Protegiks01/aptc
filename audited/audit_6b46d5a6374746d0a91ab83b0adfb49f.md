# Audit Report

## Title
Missing JWK Type Validation in Consensus Allows Unsupported Keys to Block Keyless Authentication

## Summary
The JWK consensus system in per-key mode does not validate that observed JWKs are of a supported type (RSA) before processing them through consensus and storing them on-chain. This allows `UnsupportedJWK` entries to be stored in `ObservedJWKs`, which are then rejected during keyless authentication, causing complete denial-of-service for all users of the affected OIDC provider.

## Finding Description

The JWK consensus system enables validators to observe JSON Web Keys from approved OIDC providers and reach consensus on storing them on-chain for keyless authentication. However, critical validation gaps allow unusable keys to be stored on-chain.

**Vulnerability Flow:**

1. **JWK Observation & Parsing**: When validators fetch JWKs from OIDC providers, any non-RSA key (ECDSA, EdDSA, etc.) is converted to an `UnsupportedJWK` variant. The conversion logic attempts RSA parsing first, and if that fails (e.g., for ECDSA keys lacking RSA-specific fields), it falls back to creating an `UnsupportedJWK`. [1](#0-0) 

   RSA parsing explicitly requires `kty` field to equal "RSA", which ECDSA/EdDSA keys will not satisfy. [2](#0-1) 

2. **Consensus Processing Without Validation**: In per-key consensus mode, the `process_new_observation` function creates `KeyLevelUpdate` entries with `to_upsert: Some(y.clone())` where `y` can be any `JWK` variant, including `UnsupportedJWK`. No filtering occurs at this stage. [3](#0-2) 

   The `new_rb_request()` function in `PerKeyMode` simply extracts issuer and kid from the payload without validating the JWK type. [4](#0-3) 

3. **On-Chain Storage**: The Move function `upsert_into_observed_jwks` stores JWKs without type validation. It only checks if a JWK is an `UnsupportedJWK` to determine if it's a DELETE command (by checking for a special payload), but otherwise stores any JWK type. [5](#0-4) 

4. **Authentication Rejection**: During keyless signature validation, `get_jwk_for_authenticator` explicitly rejects `UnsupportedJWK` entries with an error message stating the JWK "is not supported". [6](#0-5) 

   This rejection also occurs in both ZK and OpenID signature verification paths. [7](#0-6) 

**Design Intent vs. Implementation**: The Move module documentation clearly states that `UnsupportedJWK` "represents the JWKs which were observed but not yet supported by Aptos" and that "Observing `UnsupportedJWK`s means the providers adopted a new key type/format, and the system should be updated." [8](#0-7) 

This indicates `UnsupportedJWK` is meant as a signal for system updates, not as permanent on-chain state that blocks authentication.

**Attack Scenario**: If an approved OIDC provider migrates from RSA to ECDSA keys (or publishes only ECDSA keys), validators will observe these keys, convert them to `UnsupportedJWK`, reach consensus, and store them on-chain. All users attempting keyless authentication with that provider will then fail, experiencing complete DoS until either the provider reverts to RSA keys or Aptos governance manually removes the invalid entries.

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring manual intervention" per Aptos bug bounty criteria:

- **Complete User DoS**: All users of an affected OIDC provider lose keyless authentication capability entirely
- **State Bloat**: Unusable `UnsupportedJWK` entries consume on-chain storage indefinitely with no automatic cleanup mechanism
- **Validator Resource Waste**: Validators expend CPU, network bandwidth, and storage resources on consensus for keys that can never be used
- **Recovery Complexity**: Remediation requires either (a) OIDC provider reverting to RSA keys, or (b) Aptos governance intervention to manually remove the invalid entries

The impact is limited to the keyless authentication feature and does not directly affect consensus safety, cause fund theft, or halt the entire network, placing it at Medium rather than High/Critical severity.

## Likelihood Explanation

**Medium to High Likelihood**:

- **Realistic Scenario**: OIDC providers regularly upgrade cryptographic algorithms as part of security best practices. While many maintain backward compatibility, there is no guarantee all providers will continue supporting RSA indefinitely
- **No Attacker Required**: This vulnerability can be triggered through normal, legitimate provider operations without any malicious intent
- **Already Observable**: Some OIDC providers already publish mixed key sets containing both RSA and ECDSA keys, meaning `UnsupportedJWK` entries may already be present in the observation flow
- **Low Barrier to Trigger**: Does not require validator collusion, privileged access, or complex attack choreography - simply requires an OIDC provider to update their key configuration
- **No Mitigation Controls**: No automatic filtering, warnings, or safeguards exist to prevent this scenario

## Recommendation

Add JWK type validation at the consensus layer before processing updates:

**Option 1 - Filter in Observation Processing** (Recommended):
In `process_new_observation` at `crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs`, add filtering:

```rust
match (onchain, observed) {
    (Some(x), Some(y)) => {
        // Add validation here
        if !matches!(y, JWK::RSA(_)) {
            warn!("Ignoring unsupported JWK type for issuer {:?}, kid {:?}", 
                  String::from_utf8(issuer.clone()), String::from_utf8(kid.clone()));
            continue;
        }
        if x == y { /* ... */ }
        else { /* ... */ }
    },
    (None, Some(y)) => {
        // Add validation here
        if !matches!(y, JWK::RSA(_)) {
            warn!("Ignoring unsupported JWK type for issuer {:?}, kid {:?}",
                  String::from_utf8(issuer.clone()), String::from_utf8(kid.clone()));
            continue;
        }
        // Insert detected...
    },
    // ...
}
```

**Option 2 - Validate in new_rb_request**:
In `crates/aptos-jwk-consensus/src/mode/per_key.rs`, add type checking before creating the request.

**Option 3 - Add Governance Monitoring**:
Emit events when `UnsupportedJWK` entries are observed to alert governance for manual intervention before consensus completes.

## Proof of Concept

The following scenario demonstrates the vulnerability:

1. Configure an OIDC provider that publishes only ECDSA keys (kty="EC")
2. Add this provider to `SupportedOIDCProviders` via governance
3. Validators fetch the JWKs via `JWKObserver`
4. JWK parsing converts ECDSA keys to `UnsupportedJWK` (types/src/jwks/jwk/mod.rs:84-86)
5. `KeyLevelConsensusManager` processes the observation and creates updates with `to_upsert: Some(UnsupportedJWK)` (jwk_manager_per_key.rs:142)
6. Consensus is reached and `upsert_into_observed_jwks` stores the `UnsupportedJWK` on-chain (jwks.move:490)
7. User attempts keyless authentication with this provider
8. `get_jwk_for_authenticator` retrieves the `UnsupportedJWK` and returns error: "JWK with KID ... is not supported" (keyless_validation.rs:141-145)
9. User authentication fails permanently until manual intervention

**Note**: A full executable PoC would require setting up a dummy OIDC provider in the smoke test framework similar to existing JWK consensus tests, but the vulnerability is evident from the code path analysis above.

### Citations

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** types/src/jwks/rsa/mod.rs (L143-146)
```rust
        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L138-143)
```rust
                        let update = KeyLevelUpdate {
                            issuer: issuer.clone(),
                            base_version: effectively_onchain.version,
                            kid: kid.clone(),
                            to_upsert: Some(y.clone()),
                        };
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L68-73)
```text
    /// An JWK variant that represents the JWKs which were observed but not yet supported by Aptos.
    /// Observing `UnsupportedJWK`s means the providers adopted a new key type/format, and the system should be updated.
    struct UnsupportedJWK has copy, drop, store {
        id: vector<u8>,
        payload: vector<u8>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L479-490)
```text
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L140-146)
```rust
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L366-366)
```rust
            JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
```
