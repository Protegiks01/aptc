# Audit Report

## Title
Symlink Following Vulnerability in Validator Identity File Writing Leads to System Compromise

## Summary
Multiple file writing functions used to persist validator identity files containing sensitive cryptographic keys follow symlinks without validation. An attacker with local filesystem access can create symlinks at identity file paths before validator initialization, causing the validator to write private keys to attacker-controlled locations or overwrite critical system files.

## Finding Description

The vulnerability exists in the file writing operations used during validator genesis setup and key generation. While the security question references `IdentityBlob::to_file()`, that specific function is non-functional (uses `File::open()` instead of `File::create()`). [1](#0-0) 

The actual vulnerability exists in the functions that ARE used in practice:

**1. Genesis Builder Path**: The `write_yaml()` helper function uses `File::create()` which follows symlinks: [2](#0-1) 

This function is called during validator initialization to write identity blobs containing all validator private keys: [3](#0-2) 

**2. CLI Key Generation Path**: The `write_to_user_only_file()` function ultimately uses `OpenOptions::open()` which also follows symlinks: [4](#0-3) 

This is used by the `GenerateKeys` command to write validator identity files: [5](#0-4) 

**Critical Data at Risk**: The `IdentityBlob` structure contains highly sensitive validator cryptographic material: [6](#0-5) 

**Attack Scenario**:
1. Attacker gains local filesystem access to validator's data directory (but not root/validator privileges)
2. Before genesis initialization or key generation, attacker creates symlinks at predictable paths:
   - `validator-identity.yaml` → `/etc/shadow` (system compromise)
   - `validator-identity.yaml` → `/tmp/attacker-readable-file` (key theft)
3. When validator operator runs genesis setup or `aptos genesis generate-keys`, the code:
   - Creates the validator directory [7](#0-6) 
   - Generates cryptographic keys
   - Writes to symlink paths, following them to target files
4. Result: Validator private keys written to attacker-controlled location or critical system file overwritten

**No Symlink Protection**: The code checks if files exist using `path.exists()` but this returns true for symlinks, providing no protection: [8](#0-7) 

## Impact Explanation

**High Severity** - This vulnerability enables multiple severe attacks:

1. **Validator Key Theft**: Attacker redirects identity files to attacker-readable locations, stealing:
   - Ed25519 account private keys (validator transactions)
   - BLS12-381 consensus private keys (consensus participation)
   - x25519 network private keys (peer communication)

2. **System File Overwrite**: Attacker redirects to critical system files:
   - `/etc/shadow` → renders system authentication inoperable
   - `/root/.ssh/authorized_keys` → enables SSH access
   - System configuration files → causes service failures

3. **Validator Compromise**: Complete compromise of validator node security, enabling:
   - Unauthorized consensus participation
   - Transaction signing with validator credentials
   - Network impersonation attacks

This meets **High Severity** criteria per Aptos bug bounty: "Validator node slowdowns, API crashes, Significant protocol violations" - though the impact is arguably higher as it enables complete validator compromise.

## Likelihood Explanation

**Medium-High Likelihood**:

**Attack Requirements**:
- Local filesystem write access to validator's data directory
- Timing: must create symlinks before genesis/key generation
- No privileged (root) access required

**Realistic Scenarios**:
1. **Shared hosting**: Multiple users with filesystem access
2. **Compromised low-privilege account**: Non-root account compromise
3. **Supply chain attacks**: Malicious deployment scripts
4. **Container breakout**: Partial container escape scenarios
5. **Insider threats**: Malicious operators with limited access

**Timing Window**: Wide - any time between directory creation and first validator initialization. Validators often set up directories well before key generation.

## Recommendation

Implement symlink validation before writing sensitive files. Use platform-specific APIs to prevent symlink following:

```rust
#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

fn write_yaml_secure<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    // Check if path is a symlink
    if path.symlink_metadata()?.is_symlink() {
        return Err(anyhow::anyhow!(
            "Refusing to write to symlink: {:?}", path
        ));
    }
    
    let mut opts = OpenOptions::new();
    opts.write(true)
        .create_new(true)  // Fail if file exists (prevents TOCTOU)
        .mode(0o600);      // User read/write only
    
    #[cfg(unix)]
    opts.custom_flags(libc::O_NOFOLLOW);  // Don't follow symlinks
    
    let mut file = opts.open(path)?;
    file.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**Additional Hardening**:
1. Set restrictive permissions on validator data directories (0700)
2. Use `O_NOFOLLOW` flag on all sensitive file operations
3. Validate file metadata after opening (check inode hasn't changed)
4. Consider mandatory access control (SELinux/AppArmor) policies

## Proof of Concept

```bash
#!/bin/bash
# Symlink Attack PoC

# Setup: Create validator directory
VALIDATOR_DIR="/tmp/aptos-validator-test"
mkdir -p "$VALIDATOR_DIR"

# Attack: Create malicious symlink before key generation
SENSITIVE_TARGET="/tmp/exfiltrated-keys.yaml"
ln -s "$SENSITIVE_TARGET" "$VALIDATOR_DIR/validator-identity.yaml"
ln -s "$SENSITIVE_TARGET" "$VALIDATOR_DIR/private-keys.yaml"

# Victim: Run key generation
cd "$VALIDATOR_DIR"
aptos genesis generate-keys --output-dir . --assume-yes

# Verify: Check if keys were written to symlink target
if [ -f "$SENSITIVE_TARGET" ]; then
    echo "[+] VULNERABILITY CONFIRMED"
    echo "[+] Validator private keys written to: $SENSITIVE_TARGET"
    echo "[+] Contents:"
    head -20 "$SENSITIVE_TARGET"
    
    # Attacker can now extract:
    # - account_private_key (Ed25519)
    # - consensus_private_key (BLS12-381)
    # - network_private_key (x25519)
else
    echo "[-] Attack failed"
fi

# Alternative: Overwrite system file (requires appropriate permissions)
# ln -s /etc/issue "$VALIDATOR_DIR/validator-identity.yaml"
# This would overwrite /etc/issue with validator keys
```

## Notes

The security question specifically references `IdentityBlob::to_file()` which contains a bug (uses `File::open()` for writing) and is not used in practice. The actual vulnerability exists in `write_yaml()` and `write_to_user_only_file()` functions that perform the identity file writing operations throughout the codebase. This demonstrates that the vulnerability surface extends beyond individual functions to the broader pattern of file writing without symlink validation.

### Citations

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** config/src/config/identity_config.rs (L44-47)
```rust
    pub fn to_file(&self, path: &Path) -> anyhow::Result<()> {
        let mut file = File::open(path)?;
        Ok(file.write_all(serde_yaml::to_string(self)?.as_bytes())?)
    }
```

**File:** crates/aptos-genesis/src/builder.rs (L80-83)
```rust
        // Create the data dir and set it appropriately
        let dir = base_dir.join(&name);
        std::fs::create_dir_all(dir.as_path())?;
        config.override_config_mut().set_data_dir(dir.clone());
```

**File:** crates/aptos-genesis/src/builder.rs (L144-148)
```rust
            // Write identities in files
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** crates/aptos/src/common/utils.rs (L179-191)
```rust
pub fn check_if_file_exists(file: &Path, prompt_options: PromptOptions) -> CliTypedResult<()> {
    if file.exists() {
        prompt_yes_with_override(
            &format!(
                "{:?} already exists, are you sure you want to overwrite it?",
                file.as_os_str(),
            ),
            prompt_options,
        )?
    }

    Ok(())
}
```

**File:** crates/aptos/src/common/utils.rs (L232-246)
```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```
