# Audit Report

## Title
Genesis State Injection via Unvalidated Fast Sync Temporary Database

## Summary
The `FastSyncStorageWrapper::initialize_dbs()` function opens an existing secondary database from the file system without validating its contents. An attacker with file system write access before node startup can inject a malicious database containing fake genesis data with a compromised validator set, which gets committed to the fast sync database without waypoint verification, causing the node to sync to a completely fake blockchain.

## Finding Description

The vulnerability exists in the fast sync initialization flow where a temporary database is used to store genesis data. The attack exploits three critical weaknesses:

**Weakness 1: No validation when opening temporary DB** [1](#0-0) 

The `initialize_dbs()` function opens the secondary database from the `SECONDARY_DB_DIR` directory without any validation of its contents. If an attacker pre-populates this directory with a malicious database, it gets loaded directly into the `temporary_db_with_genesis` field.

**Weakness 2: Genesis application is skipped for pre-existing data** [2](#0-1) 

The `maybe_bootstrap()` function checks if genesis should be applied by comparing versions. If the temporary database already contains version 0 data, the condition `ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version()` evaluates to `(0 + 1) != 0` = `1 != 0` = `true`, causing genesis application to be skipped entirely. This means the waypoint verification at line 62-67 never executes.

**Weakness 3: Malicious genesis ledger info committed without waypoint validation** [3](#0-2) 

After `maybe_apply_genesis()` skips on line 77, the code retrieves the epoch 0 ledger info from the temporary database at lines 81-84 with no waypoint verification. This malicious ledger info is then committed to the fast_sync_db at line 93. [4](#0-3) 

The `commit_genesis_ledger_info()` function only validates that the epoch is 0, but does NOT validate the ledger info against the expected genesis waypoint, state root hash, transaction accumulator, or any cryptographic properties.

**Exploitation Path:**

1. Attacker creates malicious RocksDB at `<data_dir>/fast_sync_secondary/` containing:
   - Version 0 ledger state
   - Fake epoch 0 ledger info with attacker-controlled validator set in `next_epoch_state`
   - Arbitrary state root and transaction accumulator hashes

2. Node starts with fast sync enabled and empty main database

3. `initialize_dbs()` opens the malicious secondary DB and creates the wrapper

4. `maybe_apply_genesis()` is called but skips because version check fails

5. Malicious epoch 0 ledger info is retrieved and committed to fast_sync_db without waypoint verification

6. Bootstrapper initializes by fetching the latest epoch state from storage: [5](#0-4) [6](#0-5) 

The bootstrapper retrieves the malicious epoch state from the compromised genesis ledger info and uses it as the root of trust for all subsequent epoch verification.

7. All subsequent state sync and consensus operations trust the attacker-controlled validator set, causing the node to sync to a completely fake blockchain.

This breaks the fundamental security invariant that nodes must verify they are syncing to the correct chain via waypoint verification.

## Impact Explanation

**Critical Severity** - This vulnerability meets the Critical severity criteria for multiple reasons:

1. **Consensus/Safety Violation**: The node syncs to a completely fake blockchain controlled by the attacker rather than the legitimate Aptos network. This is a complete consensus safety break.

2. **Validator Set Compromise**: The attacker controls the initial validator set (the epoch state in the malicious genesis ledger info), allowing them to forge all subsequent epoch changes and block signatures.

3. **State Manipulation**: All state roots, transaction accumulators, and Merkle proofs accepted by the compromised node are under attacker control.

4. **Network Partition**: Compromised nodes participate in a fake network separate from the legitimate Aptos blockchain, potentially creating confusion and operational issues.

5. **Permanent Compromise**: Once initialized with malicious genesis, the node's entire chain history is fake. Recovery requires complete re-initialization with the correct genesis.

This vulnerability allows an attacker to completely subvert the consensus mechanism and cryptographic security guarantees that are fundamental to blockchain security.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires file system write access to the node's data directory before the node's first startup. While this is a privileged access requirement, it is realistic in several scenarios:

**High-likelihood scenarios:**
- **Cloud VM compromise**: Attacker gains access to a cloud VM before the Aptos node is deployed
- **Container/Docker attacks**: Attacker manipulates Docker volumes or container images before deployment
- **Compromised deployment pipelines**: CI/CD systems with vulnerabilities that allow file injection
- **Supply chain attacks**: Compromised node deployment tools or scripts
- **Insider threats**: Malicious operators with infrastructure access

**Attack complexity:** Low once file system access is obtained. The attacker only needs to:
1. Create a valid RocksDB structure with epoch 0 data
2. Place it in the expected directory before node startup
3. Wait for the node to start normally

**Affected deployment patterns:**
- New validator nodes joining the network
- Archive nodes being initialized
- Testnet/devnet deployments with relaxed security
- Automated node provisioning systems

The vulnerability is especially dangerous because:
- It's a one-time attack during initial setup
- No ongoing access is required after initial compromise
- The node appears to function normally while syncing to a fake chain
- Detection requires manual verification against expected waypoints

## Recommendation

Implement strict validation of the temporary database contents before using it:

**Solution 1: Always validate genesis ledger info against waypoint**

In `aptos-node/src/storage.rs`, add waypoint verification after retrieving the genesis ledger info from the temporary database:

```rust
Either::Right(fast_sync_db_wrapper) => {
    let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
    maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
    let (db_arc, db_rw) = DbReaderWriter::wrap(fast_sync_db_wrapper);
    let fast_sync_db = db_arc.get_fast_sync_db();
    
    // FastSyncDB requires ledger info at epoch 0 to establish provenance to genesis
    let ledger_info = db_arc
        .get_temporary_db_with_genesis()
        .get_epoch_ending_ledger_info(0)
        .expect("Genesis ledger info must exist");
    
    // ADD WAYPOINT VERIFICATION HERE
    let genesis_waypoint = node_config
        .execution
        .genesis_waypoint
        .as_ref()
        .unwrap_or(&node_config.base.waypoint)
        .genesis_waypoint();
    
    genesis_waypoint
        .verify(ledger_info.ledger_info())
        .map_err(|err| anyhow!("Genesis ledger info from temporary DB failed waypoint verification: {}", err))?;
    
    if fast_sync_db
        .get_latest_ledger_info_option()
        .expect("should returns Ok results")
        .is_none()
    {
        fast_sync_db.commit_genesis_ledger_info(&ledger_info)?;
    }
    ...
}
```

**Solution 2: Delete and recreate temporary DB if it exists**

In `storage/aptosdb/src/fast_sync_storage_wrapper.rs`, ensure the temporary database is always created fresh:

```rust
if config
    .state_sync
    .state_sync_driver
    .bootstrapping_mode
    .is_fast_sync()
    && (db_main
        .ledger_db
        .metadata_db()
        .get_synced_version()?
        .map_or(0, |v| v)
        == 0)
{
    db_dir.push(SECONDARY_DB_DIR);
    
    // DELETE existing secondary DB to prevent injection attacks
    if db_dir.exists() {
        std::fs::remove_dir_all(&db_dir)
            .map_err(|err| anyhow!("Failed to remove existing secondary DB: {}", err))?;
    }
    
    let secondary_db = AptosDB::open(
        StorageDirPaths::from_path(db_dir.as_path()),
        /*readonly=*/ false,
        ...
    )
    .map_err(|err| anyhow!("Secondary DB failed to open {}", err))?;
    ...
}
```

**Solution 3: Validate version is None before using temp DB**

Add validation that the temporary database is truly empty before accepting data from it:

```rust
let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
let temp_db_version = temp_db.ledger_db.metadata_db().get_synced_version()?;
ensure!(
    temp_db_version.is_none(),
    "Temporary DB already contains data (version: {:?}), possible injection attack",
    temp_db_version
);
maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
```

**Recommended approach:** Implement all three solutions for defense-in-depth:
1. Always delete and recreate the temporary DB directory
2. Validate it's empty before use
3. Verify genesis ledger info against waypoint before committing

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be a Rust integration test in storage/aptosdb/tests/

use aptos_config::config::NodeConfig;
use aptos_crypto::HashValue;
use aptos_db::{AptosDB, fast_sync_storage_wrapper::FastSyncStorageWrapper};
use aptos_types::{
    block_info::BlockInfo,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    aggregate_signature::AggregateSignature,
    epoch_state::EpochState,
};
use tempfile::TempDir;
use std::path::PathBuf;

#[test]
fn test_malicious_genesis_injection() {
    // 1. Setup: Create a temporary directory for node data
    let tmp_dir = TempDir::new().unwrap();
    let mut node_config = NodeConfig::default();
    node_config.set_data_dir(tmp_dir.path().to_path_buf());
    
    // 2. Attack: Create malicious secondary DB before node initialization
    let mut malicious_db_path = tmp_dir.path().to_path_buf();
    malicious_db_path.push("fast_sync_secondary");
    std::fs::create_dir_all(&malicious_db_path).unwrap();
    
    // Create malicious DB with fake genesis at version 0
    let malicious_db = AptosDB::open_for_test(&malicious_db_path);
    
    // Create fake genesis ledger info with attacker-controlled validator set
    let malicious_epoch_state = EpochState::empty(); // Attacker's validators
    let malicious_genesis = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                0, // epoch 0
                0, // round 0
                HashValue::zero(),
                HashValue::random(), // Fake transaction accumulator
                0, // version 0
                0,
                Some(malicious_epoch_state), // Attacker's validator set!
            ),
            HashValue::zero(),
        ),
        AggregateSignature::empty(),
    );
    
    // Commit malicious genesis to the temporary DB
    malicious_db.ledger_db.metadata_db().set_latest_ledger_info(malicious_genesis.clone());
    drop(malicious_db); // Close the DB
    
    // 3. Victim: Node starts with fast sync enabled
    let wrapper = FastSyncStorageWrapper::initialize_dbs(
        &node_config,
        None,
        None,
    ).unwrap();
    
    // 4. Verify: The wrapper contains the malicious DB
    let wrapper = match wrapper {
        either::Either::Right(w) => w,
        _ => panic!("Expected fast sync wrapper"),
    };
    
    // 5. Exploit: Genesis from temporary DB is used without waypoint validation
    let retrieved_genesis = wrapper
        .get_temporary_db_with_genesis()
        .get_epoch_ending_ledger_info(0)
        .unwrap();
    
    // The retrieved genesis matches our malicious one!
    assert_eq!(
        retrieved_genesis.ledger_info().transaction_accumulator_hash(),
        malicious_genesis.ledger_info().transaction_accumulator_hash()
    );
    
    // This malicious genesis would be committed to fast_sync_db without waypoint verification
    println!("✓ Malicious genesis successfully injected and retrieved without validation!");
    println!("✓ Node would sync to fake chain controlled by attacker's validator set");
}
```

The PoC demonstrates that:
1. An attacker can pre-create the secondary database directory
2. Populate it with malicious genesis data at version 0
3. When the node starts, this malicious data is loaded without validation
4. The fake genesis with attacker-controlled validator set gets used as the root of trust

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L78-96)
```rust
            db_dir.push(SECONDARY_DB_DIR);
            let secondary_db = AptosDB::open(
                StorageDirPaths::from_path(db_dir.as_path()),
                /*readonly=*/ false,
                config.storage.storage_pruner_config,
                config.storage.rocksdb_configs,
                config.storage.enable_indexer,
                config.storage.buffered_state_target_items,
                config.storage.max_num_nodes_per_lru_cache_shard,
                None,
                config.storage.hot_state_config,
            )
            .map_err(|err| anyhow!("Secondary DB failed to open {}", err))?;

            Ok(Either::Right(FastSyncStorageWrapper {
                temporary_db_with_genesis: Arc::new(secondary_db),
                db_for_fast_sync: Arc::new(db_main),
                fast_sync_status: Arc::new(RwLock::new(FastSyncStatus::UNKNOWN)),
            }))
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L48-71)
```rust
pub fn maybe_bootstrap<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    genesis_txn: &Transaction,
    waypoint: Waypoint,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let ledger_summary = db.reader.get_pre_committed_ledger_summary()?;
    // if the waypoint is not targeted with the genesis txn, it may be either already bootstrapped, or
    // aiming for state sync to catch up.
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }

    let committer = calculate_genesis::<V>(db, ledger_summary, genesis_txn)?;
    ensure!(
        waypoint == committer.waypoint(),
        "Waypoint verification failed. Expected {:?}, got {:?}.",
        waypoint,
        committer.waypoint(),
    );
    let ledger_info = committer.output.ledger_info_opt.clone();
    committer.commit()?;
    Ok(ledger_info)
}
```

**File:** aptos-node/src/storage.rs (L75-98)
```rust
        Either::Right(fast_sync_db_wrapper) => {
            let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
            maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
            let (db_arc, db_rw) = DbReaderWriter::wrap(fast_sync_db_wrapper);
            let fast_sync_db = db_arc.get_fast_sync_db();
            // FastSyncDB requires ledger info at epoch 0 to establish provenance to genesis
            let ledger_info = db_arc
                .get_temporary_db_with_genesis()
                .get_epoch_ending_ledger_info(0)
                .expect("Genesis ledger info must exist");

            if fast_sync_db
                .get_latest_ledger_info_option()
                .expect("should returns Ok results")
                .is_none()
            {
                // it means the DB is empty and we need to
                // commit the genesis ledger info to the DB.
                fast_sync_db.commit_genesis_ledger_info(&ledger_info)?;
            }
            let db_backup_service =
                start_backup_service(node_config.storage.backup_service_address, fast_sync_db);
            (db_arc as Arc<dyn DbReader>, db_rw, Some(db_backup_service))
        },
```

**File:** storage/aptosdb/src/db/mod.rs (L207-219)
```rust
    pub fn commit_genesis_ledger_info(&self, genesis_li: &LedgerInfoWithSignatures) -> Result<()> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let current_epoch = ledger_metadata_db
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            genesis_li.ledger_info().epoch() == current_epoch && current_epoch == 0,
            "Genesis ledger info epoch is not 0"
        );
        let mut ledger_batch = SchemaBatch::new();
        ledger_metadata_db.put_ledger_info(genesis_li, &mut ledger_batch)?;
        ledger_metadata_db.write_schemas(ledger_batch)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L341-344)
```rust
        // Load the latest epoch state from storage
        let latest_epoch_state = utils::fetch_latest_epoch_state(storage.clone())
            .expect("Unable to fetch latest epoch state!");
        let verified_epoch_states = VerifiedEpochStates::new(latest_epoch_state);
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L696-707)
```rust
    fn get_latest_epoch_state(&self) -> Result<EpochState> {
        gauged_api("get_latest_epoch_state", || {
            let latest_ledger_info = self.ledger_db.metadata_db().get_latest_ledger_info()?;
            match latest_ledger_info.ledger_info().next_epoch_state() {
                Some(epoch_state) => Ok(epoch_state.clone()),
                None => self
                    .ledger_db
                    .metadata_db()
                    .get_epoch_state(latest_ledger_info.ledger_info().epoch()),
            }
        })
    }
```
