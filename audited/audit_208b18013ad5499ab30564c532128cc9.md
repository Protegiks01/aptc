# Audit Report

## Title
Secret Sharing Aggregation Fails Due to Weight Mismatch Between Threshold Config and Peer Weight Calculation

## Summary
The `SecretShareConfig` uses a weighted threshold configuration (`FPTXWeighted` with `WeightedConfigArkworks`) that expects validators to have different weights based on their stake, but the `get_peer_weight()` method always returns 1 for all validators. This causes the share aggregation logic to never reach the weighted threshold, resulting in complete failure of secret reconstruction and randomness beacon liveness.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Weighted Threshold Configuration:** [1](#0-0) 

The `SecretShareConfig` stores a `config` field of type `<FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig`, which is `WeightedConfigArkworks<Fr>`: [2](#0-1) 

This weighted config is created from actual validator stakes through the DKG rounding process: [3](#0-2) 

For example, validators might have weights [100, 200, 50] representing their stake proportions, with a threshold of 200 (requiring ~57% of total stake).

**2. Threshold Retrieval Returns Weighted Value:** [4](#0-3) 

The `threshold()` method correctly returns the weighted threshold value (e.g., 200) from the underlying config.

**3. Weight Calculation Always Returns 1:** [5](#0-4) 

The `get_peer_weight()` method ignores the actual validator weight and always returns 1. The `weights` HashMap is initialized empty and never populated: [6](#0-5) [7](#0-6) 

**4. Aggregation Logic Compares Mismatched Values:**

In the share aggregation process: [8](#0-7) 

Each share is assigned weight 1 via `get_peer_weight()`. [9](#0-8) 

The total weight accumulates by adding 1 for each validator's share. [10](#0-9) 

Aggregation only proceeds if `total_weight >= threshold()`. With 3 validators contributing shares, `total_weight` reaches only 3, while `threshold()` returns 200, causing permanent aggregation failure.

**Exploitation Scenario:**

Given a validator set with stake-based weights [100, 200, 50] (total 350), threshold 200:
1. All three validators generate and broadcast their secret shares
2. Share aggregator receives all 3 shares
3. Aggregator counts: `total_weight = 1 + 1 + 1 = 3`
4. Comparison: `3 < 200` → aggregation does not proceed
5. Secret reconstruction never happens
6. Randomness beacon fails permanently

This breaks the **Cryptographic Correctness** invariant as the weighted threshold scheme is fundamentally broken, and causes **Total loss of liveness** for randomness-dependent consensus operations.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under Aptos bug bounty criteria:

**Total loss of liveness/network availability**: The randomness beacon is critical for leader selection and consensus protocol operation. If secret sharing fails, randomness generation fails, potentially halting consensus progress. Even if consensus can continue without randomness, the intended security properties are violated.

The impact affects:
- All validators in the network (cannot generate randomness)
- Leader selection randomness (if dependent on beacon)
- On-chain randomness availability for smart contracts
- Consensus liveness if randomness is required for critical operations

The bug is deterministic and will trigger 100% of the time when weighted validator configurations are used, making it a systemic failure rather than an edge case.

## Likelihood Explanation

**Likelihood: HIGH**

This bug will trigger automatically whenever:
1. Validators have different stake amounts (standard in proof-of-stake)
2. The DKG system creates weighted configs from validator stakes
3. Secret sharing is attempted for randomness generation

The vulnerability requires no attacker action—it's a logic bug that automatically fails. However, the actual likelihood depends on whether:
- Weighted validator configurations are enabled in production
- The randomness beacon feature is active
- The code path is exercised in the current deployment

The presence of TODO comments and "temporary" annotations suggests this may be incomplete functionality, but if deployed, it will fail immediately.

## Recommendation

**Fix 1: Populate the weights HashMap properly**

In `SecretShareConfig::new()`, populate the `weights` HashMap from the validator verifier and the weighted config:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    // Populate weights from the config
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .enumerate()
        .map(|(idx, addr)| {
            let player = Player { id: idx };
            let weight = config.get_player_weight(&player) as u64;
            (*addr, weight)
        })
        .collect();

    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

**Fix 2: Update get_peer_weight() to use the weights HashMap**

```rust
pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    *self.weights.get(peer).unwrap_or(&1)
}
```

**Alternative Fix: Use weighted shares directly**

Since `WeightedBIBEDecryptionKeyShare` already contains weight information in its vector length, modify the aggregation logic to count actual weighted shares rather than validator count.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::weighted_config::WeightedConfigArkworks;
    use aptos_batch_encryption::group::Fr;
    
    #[test]
    fn test_weight_mismatch_causes_aggregation_failure() {
        // Setup weighted config with 3 validators: weights [1, 2, 5], threshold 4
        let wconfig = WeightedConfigArkworks::<Fr>::new(4, vec![1, 2, 5]).unwrap();
        
        // Create SecretShareConfig (simplified for test)
        // ... setup code ...
        
        // Verify threshold is 4
        assert_eq!(config.threshold(), 4);
        
        // Verify get_peer_weight returns 1 for all validators
        assert_eq!(config.get_peer_weight(&validator_a), 1);
        assert_eq!(config.get_peer_weight(&validator_b), 1);
        assert_eq!(config.get_peer_weight(&validator_c), 1);
        
        // Simulate aggregation with all 3 validators
        let mut aggregator = SecretShareAggregator::new(self_author);
        aggregator.add_share(share_a, config.get_peer_weight(&validator_a));
        aggregator.add_share(share_b, config.get_peer_weight(&validator_b));
        aggregator.add_share(share_c, config.get_peer_weight(&validator_c));
        
        // Total weight is 3 (1+1+1), threshold is 4
        assert_eq!(aggregator.total_weight, 3);
        assert!(aggregator.total_weight < config.threshold());
        
        // Aggregation fails even though validators with combined weight 8 (1+2+5)
        // should be sufficient for threshold 4
        let result = aggregator.try_aggregate(&config, metadata, tx);
        assert!(result.is_left()); // Returns aggregator, not completed
    }
}
```

## Notes

The vulnerability is confirmed by examining the code structure across multiple files. The weighted threshold configuration system is properly implemented in the DKG and FPTXWeighted layers, but the integration in `SecretShareConfig` is incomplete, with uniform weight counting contradicting the weighted threshold values. This represents incomplete feature implementation that would cause immediate failure if deployed with weighted validator configurations.

### Citations

**File:** types/src/secret_sharing.rs (L143-143)
```rust
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
```

**File:** types/src/secret_sharing.rs (L145-145)
```rust
    weights: HashMap<Author, u64>,
```

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L188-190)
```rust
    pub fn threshold(&self) -> u64 {
        self.config.get_threshold_config().t as u64
    }
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L226-226)
```rust
    type ThresholdConfig = aptos_crypto::weighted_config::WeightedConfigArkworks<Fr>;
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L32-36)
```rust
    pub fn add_share(&mut self, share: SecretShare, weight: u64) {
        if self.shares.insert(share.author, share).is_none() {
            self.total_weight += weight;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L44-46)
```rust
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L260-260)
```rust
        let weight = self.secret_share_config.get_peer_weight(share.author());
```
