# Audit Report

## Title
Incomplete Pruning of OrderedTransactionByAccountSchema Creates Cross-Schema Inconsistency

## Summary
The `prune_transaction_by_account()` function is not called in all scenarios where `OrderedTransactionByAccountSchema` entries exist in transaction_db, while `prune_transaction_summaries_by_account()` is always called. This creates a schema inconsistency where ordered transaction indices remain pointing to pruned transactions, violating storage consistency invariants.

## Finding Description

The security question asks about inconsistencies where summaries exist without underlying transactions. However, the actual vulnerability is the **inverse**: `OrderedTransactionByAccountSchema` entries remain **unpruned** while their corresponding `TransactionSummariesByAccountSchema` entries and underlying transactions ARE pruned.

### Write Path Inconsistency

In the transaction write path, both schemas are written when `skip_index=false` (i.e., when `enable_storage_sharding=false`): [1](#0-0) [2](#0-1) 

The `skip_index` parameter comes from `enable_storage_sharding` configuration: [3](#0-2) 

### Prune Path Inconsistency

In the pruning path, there is a critical asymmetry: [4](#0-3) 

**Analysis of pruning logic:**

1. **Line 53**: `prune_transaction_summaries_by_account()` is **always** called, writing to the main `batch` that goes to transaction_db
2. **Lines 58-72**: `prune_transaction_by_account()` is called **conditionally**:
   - If `internal_indexer_db` exists AND `transaction_enabled()` is true: prunes from internal_indexer_db only (lines 60-67)
   - If `internal_indexer_db` exists AND `transaction_enabled()` is false: prunes from transaction_db (lines 69-70)
   - If `internal_indexer_db` does NOT exist: **never called**

### Vulnerable Scenarios

**Scenario A**: When `enable_storage_sharding=false` AND `internal_indexer_db` is None:
- Both schemas are written to transaction_db
- Only `TransactionSummariesByAccountSchema` is pruned
- `OrderedTransactionByAccountSchema` is never pruned
- **Result**: Orphaned index entries pointing to non-existent transactions

**Scenario B**: When `enable_storage_sharding=false` AND `internal_indexer_db` exists with `transaction_enabled()=true`:
- `OrderedTransactionByAccountSchema` is written to transaction_db
- Internal indexer also writes to its own db
- Pruning only removes from internal_indexer_db, not transaction_db
- **Result**: Orphaned index entries in transaction_db

### Impact on Query Operations

The orphaned indices cause query inconsistencies when accessing: [5](#0-4) [6](#0-5) 

When `get_account_ordered_transaction_version()` returns a version from the unpruned index, but the actual transaction at that version has been pruned, subsequent calls to `get_transaction_with_proof()` will fail, causing API errors.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Storage Consistency Violation**: The bug breaks the invariant that pruning should be atomic across related schemas. Old transaction index entries accumulate indefinitely while their corresponding data is deleted.

**Query Failures**: APIs that rely on `OrderedTransactionByAccountSchema` will return stale version numbers for pruned transactions, leading to subsequent lookup failures and incorrect query results.

**Storage Bloat**: Unpruned index entries accumulate without bound, causing unnecessary storage consumption over time.

**Note**: While production networks currently require `enable_storage_sharding=true` (which avoids this bug), the logic flaw exists in the codebase and could manifest if:
- Configuration policies change
- Testing/staging environments use non-default settings
- Future code refactoring inadvertently enables the vulnerable path [7](#0-6) 

## Likelihood Explanation

**Low likelihood in production**: Current mainnet/testnet configurations enforce `enable_storage_sharding=true`, which prevents the bug from manifesting.

**High likelihood in non-production environments**: Testing, development, and custom deployments that set `enable_storage_sharding=false` will experience this bug immediately upon pruning operations.

**Guaranteed occurrence when conditions met**: This is not a race condition or timing issue - when the vulnerable configuration is active, the inconsistency occurs with 100% probability during pruning.

## Recommendation

Modify the pruning logic to ensure `OrderedTransactionByAccountSchema` is pruned from transaction_db in all scenarios where it was written there:

```rust
fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
    let mut batch = SchemaBatch::new();
    let candidate_transactions =
        self.get_pruning_candidate_transactions(current_progress, target_version)?;
    self.ledger_db
        .transaction_db()
        .prune_transaction_by_hash_indices(
            candidate_transactions.iter().map(|(_, txn)| txn.hash()),
            &mut batch,
        )?;
    self.ledger_db.transaction_db().prune_transactions(
        current_progress,
        target_version,
        &mut batch,
    )?;
    self.transaction_store
        .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
    
    // FIX: Always prune OrderedTransactionByAccountSchema from transaction_db
    // when it exists there (i.e., when enable_storage_sharding=false)
    self.transaction_store
        .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
    
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionPrunerProgress,
        &DbMetadataValue::Version(target_version),
    )?;
    
    // Additionally prune from internal indexer if needed
    if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
        if indexer_db.transaction_enabled() {
            let mut index_batch = SchemaBatch::new();
            self.transaction_store
                .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
            index_batch.put::<InternalIndexerMetadataSchema>(
                &IndexerMetadataKey::TransactionPrunerProgress,
                &IndexerMetadataValue::Version(target_version),
            )?;
            indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
        }
    }
    self.ledger_db.transaction_db().write_schemas(batch)
}
```

## Proof of Concept

```rust
// Integration test demonstrating the schema inconsistency
#[test]
fn test_ordered_transaction_schema_pruning_inconsistency() {
    // Setup: Create AptosDB with enable_storage_sharding=false and no internal_indexer_db
    let tmpdir = TempPath::new();
    let mut config = RocksdbConfigs::default();
    config.enable_storage_sharding = false; // This enables OrderedTransactionByAccountSchema writes
    
    let db = AptosDB::new_for_test_with_config(&tmpdir, config, None, None);
    
    // Write test transactions
    let account = AccountAddress::random();
    let transactions: Vec<_> = (0..100).map(|seq_num| {
        let txn = create_test_signed_transaction(account, seq_num);
        Transaction::UserTransaction(txn)
    }).collect();
    
    db.save_transactions(&transactions, 0, &[], &[], None).unwrap();
    
    // Verify both schemas contain entries
    let version = db.transaction_store()
        .get_account_ordered_transaction_version(account, 50, 100).unwrap();
    assert_eq!(version, Some(50));
    
    let summary = db.transaction_store()
        .get_account_transaction_summaries_iter(account, Some(50), None, 1, 100).unwrap()
        .next().unwrap().unwrap();
    assert_eq!(summary.version(), 50);
    
    // Prune transactions up to version 60
    db.ledger_pruner().prune(60).unwrap();
    
    // BUG: OrderedTransactionByAccountSchema still contains version 50
    let stale_version = db.transaction_store()
        .get_account_ordered_transaction_version(account, 50, 100).unwrap();
    assert_eq!(stale_version, Some(50)); // Should be None but returns Some(50)!
    
    // TransactionSummariesByAccountSchema correctly returns None
    let summary_result = db.transaction_store()
        .get_account_transaction_summaries_iter(account, Some(50), Some(50), 1, 100).unwrap()
        .next();
    assert!(summary_result.is_none()); // Correctly pruned
    
    // Attempting to get the transaction at version 50 fails
    let txn_result = db.get_transaction_with_proof(50, 100, false);
    assert!(txn_result.is_err()); // Transaction was pruned but index says it exists!
}
```

## Notes

The security question asked about the inverse scenario (summaries without transactions), but the actual vulnerability is that **indices remain without summaries/transactions**. This is arguably more severe because it causes active query failures rather than just missing data.

The vulnerability only manifests in non-default configurations, but the logic flaw exists in production code and violates the atomic pruning invariant that related schemas should be kept consistent.

### Citations

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L137-146)
```rust
        if !skip_index {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    batch.put::<OrderedTransactionByAccountSchema>(
                        &(txn.sender(), seq_num),
                        &version,
                    )?;
                }
            }
        }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L150-161)
```rust
        if let Some(signed_txn) = transaction.try_as_signed_user_txn() {
            let txn_summary = IndexedTransactionSummary::V1 {
                sender: signed_txn.sender(),
                replay_protector: signed_txn.replay_protector(),
                version,
                transaction_hash,
            };
            batch.put::<TransactionSummariesByAccountSchema>(
                &(signed_txn.sender(), version),
                &txn_summary,
            )?;
        }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L148-160)
```rust
        let mut myself = Self::new_with_dbs(
            ledger_db,
            hot_state_merkle_db,
            state_merkle_db,
            state_kv_db,
            pruner_config,
            buffered_state_target_items,
            readonly,
            empty_buffered_state_for_restore,
            rocksdb_configs.enable_storage_sharding,
            internal_indexer_db,
            hot_state_config,
        );
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L52-72)
```rust
        self.transaction_store
            .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L150-162)
```rust
        gauged_api("get_account_transaction", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.transaction_store
                .get_account_ordered_transaction_version(address, seq_num, ledger_version)?
                .map(|txn_version| {
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .transpose()
        })
    }
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
