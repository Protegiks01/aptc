# Audit Report

## Title
Race Condition in `send_for_execution` Causes Validator Panic on Empty Path Vector

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition in the consensus `BlockStore::send_for_execution` method allows concurrent executions to trigger an assertion failure when `path_from_ordered_root()` returns an empty vector (`Some([])`), causing validator node crashes.

## Finding Description

The vulnerability exists in the `send_for_execution` method where a check using a stale snapshot of `ordered_root` is followed by `path_from_ordered_root()` which re-reads the current `ordered_root` value. [1](#0-0) 

The race occurs as follows:

1. **Thread 1** and **Thread 2** both call `send_for_execution` for block B3 when `ordered_root = B1`
2. Both threads pass the check at line 323: `B3.round (3) > B1.round (1)` âœ“
3. **Thread 1** completes execution and updates `ordered_root` to B3 at line 338
4. **Thread 2** calls `path_from_ordered_root(B3)` at line 328, which internally reads the **current** `ordered_root` [2](#0-1) 

5. Since `path_from_ordered_root` calls `self.ordered_root()` at line 552, it now sees `ordered_root = B3`
6. The `path_from_root_to_block` logic returns `Some([])` when `block_id == root_id`: [3](#0-2) 

7. When the block being queried equals the root (line 529: `block.round() <= root_round` is true immediately), the loop breaks with an empty `res` vector, and line 545 returns `Some([])`
8. Thread 2's `unwrap_or_default()` extracts the empty vector `[]`
9. The assertion `assert!(!blocks_to_commit.is_empty())` at line 331 fails
10. **Validator panics and crashes**

The documentation explicitly states this behavior is intended: [4](#0-3) 

However, the calling code does not account for concurrent root updates between the round check and the path retrieval, confusing `Some([])` (block equals root) with a valid non-empty path.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

- **Validator Node Crash**: The panic terminates the validator process
- **Consensus Participation Loss**: Affected validators cannot participate until manually restarted
- **Liveness Impact**: Multiple validators experiencing this simultaneously reduces network capacity
- **Availability Guarantee Violation**: Breaks the consensus liveness invariant

While not causing permanent damage or fund loss, repeated crashes under load constitute "Validator node slowdowns" and "API crashes" (High severity indicators). The assertion panic is unrecoverable without operator intervention.

## Likelihood Explanation

**Likelihood: Medium to High under concurrent load**

The vulnerability can manifest in two scenarios:

1. **Natural Race Under Load**: When multiple quorum certificates arrive concurrently and are processed by different async tasks calling `send_for_execution` simultaneously. The callers in `sync_manager.rs` show this is realistic: [5](#0-4) 

2. **Potentially Exploitable**: An attacker controlling message delivery timing might deliberately trigger concurrent QC processing for the same block to maximize race probability.

The race window is narrow (between two lock acquisitions), but async execution and high transaction throughput increase collision probability.

## Recommendation

**Solution: Hold a consistent read lock or use atomic snapshot**

The check and the path retrieval must use the same `ordered_root` value. Fix by capturing the root once:

```rust
pub async fn send_for_execution(
    &self,
    finality_proof: WrappedLedgerInfo,
) -> anyhow::Result<()> {
    let block_id_to_commit = finality_proof.commit_info().id();
    let block_to_commit = self
        .get_block(block_id_to_commit)
        .ok_or_else(|| format_err!("Committed block id not found"))?;

    // Capture ordered_root atomically with path retrieval
    let (ordered_root_round, blocks_to_commit) = {
        let tree = self.inner.read();
        let root_round = tree.ordered_root().round();
        let path = tree.path_from_ordered_root(block_id_to_commit);
        (root_round, path)
    };

    // First make sure that this commit is new.
    ensure!(
        block_to_commit.round() > ordered_root_round,
        "Committed block round lower than root"
    );

    let blocks_to_commit = blocks_to_commit.unwrap_or_default();
    assert!(!blocks_to_commit.is_empty());
    
    // ... rest of function
}
```

Alternatively, handle the empty vector case gracefully instead of asserting, since `Some([])` is documented valid behavior when `block_id == ordered_root_id`.

## Proof of Concept

**Reproduction Steps (Conceptual - requires integration test setup):**

```rust
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_concurrent_send_for_execution_race() {
    // Setup: Create block store with genesis -> B1 -> B2 -> B3
    let mut inserter = TreeInserter::default();
    let block_store = inserter.block_store();
    let genesis = block_store.ordered_root();
    
    let b1 = inserter.insert_block_with_qc(certificate_for_genesis(), &genesis, 1).await;
    let b2 = inserter.insert_block(&b1, 2, None).await;
    let b3 = inserter.insert_block(&b2, 3, None).await;
    
    // Create QC for B3
    let qc_b3 = gen_test_certificate(
        vec![&b3],
        b3.quorum_cert().certified_block().clone(),
        b3.round(),
        /* commit_info for B1 */ 
    );
    
    // Spawn two concurrent tasks both trying to commit via B3's QC
    let store1 = block_store.clone();
    let store2 = block_store.clone();
    let qc1 = qc_b3.clone();
    let qc2 = qc_b3.clone();
    
    let handle1 = tokio::spawn(async move {
        store1.send_for_execution(qc1.into_wrapped_ledger_info()).await
    });
    
    let handle2 = tokio::spawn(async move {
        store2.send_for_execution(qc2.into_wrapped_ledger_info()).await
    });
    
    // One of these will panic with "assertion failed: !blocks_to_commit.is_empty()"
    let result1 = handle1.await;
    let result2 = handle2.await;
    
    // At least one should panic (in practice, this would crash the validator)
    assert!(result1.is_err() || result2.is_err());
}
```

**Expected Outcome**: One thread panics with assertion failure when it receives `Some([])` from `path_from_ordered_root` after the other thread updates the root.

---

**Notes:**

The security question correctly identified that `path_from_*()` methods can return empty vectors (`Some([])`), which is documented behavior when the queried block equals the root. However, the vulnerability manifests not from confusion with `None` in isolation, but from the **TOCTOU race** where concurrent root updates cause the same block to be treated differently between the validation check and path retrieval, leading to the unexpected empty vector that violates the assertion's assumption.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L322-331)
```rust
        ensure!(
            block_to_commit.round() > self.ordered_root().round(),
            "Committed block round lower than root"
        );

        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();

        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/block_tree.rs (L525-545)
```rust
        let mut res = vec![];
        let mut cur_block_id = block_id;
        loop {
            match self.get_block(&cur_block_id) {
                Some(ref block) if block.round() <= root_round => {
                    break;
                },
                Some(block) => {
                    cur_block_id = block.parent_id();
                    res.push(block);
                },
                None => return None,
            }
        }
        // At this point cur_block.round() <= self.root.round()
        if cur_block_id != root_id {
            return None;
        }
        // Called `.reverse()` to get the chronically increased order.
        res.reverse();
        Some(res)
```

**File:** consensus/src/block_storage/block_tree.rs (L548-553)
```rust
    pub(super) fn path_from_ordered_root(
        &self,
        block_id: HashValue,
    ) -> Option<Vec<Arc<PipelinedBlock>>> {
        self.path_from_root_to_block(block_id, self.ordered_root_id, self.ordered_root().round())
    }
```

**File:** consensus/src/block_storage/mod.rs (L42-46)
```rust
    /// For example if a tree is b0 <- b1 <- b2 <- b3, then
    /// path_from_root(b2) -> Some([b2, b1])
    /// path_from_root(b0) -> Some([])
    /// path_from_root(a) -> None
    fn path_from_ordered_root(&self, block_id: HashValue) -> Option<Vec<Arc<PipelinedBlock>>>;
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```
