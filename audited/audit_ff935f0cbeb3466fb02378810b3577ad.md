# Audit Report

## Title
API Function Identifier Validation Bypass Allows Invalid Identifiers to Cause VM Execution Failures

## Summary
The API's `validate_entry_function_payload_format()` function only validates that function identifiers don't contain `"::"`, failing to enforce Move's strict identifier rules. This allows transactions with Unicode characters, special characters, or other invalid identifier patterns to pass API validation, enter the mempool, and only fail during VM execution with `FUNCTION_RESOLUTION_FAILURE`, wasting gas and computational resources.

## Finding Description

The vulnerability exists in the gap between API-level validation and VM-level requirements for Move identifiers.

**API Layer Validation** - The `verify_function_identifier()` function performs minimal validation: [1](#0-0) 

This only checks for the presence of `"::"` but doesn't validate against Move's identifier specification.

**Move VM Requirements** - The Move VM enforces strict identifier rules: [2](#0-1) 

Valid identifiers must be ASCII-only and follow specific patterns (start with letter, or underscore/dollar followed by valid characters, with only letters, digits, underscores, and dollars allowed).

**Deserialization Bypass** - The `Identifier` type uses `derive(Deserialize)` which bypasses validation during BCS deserialization. This is explicitly demonstrated in test code: [3](#0-2) 

**Exploitation Path**:
1. Attacker crafts a `SignedTransaction` with an `EntryFunction` containing an invalid function identifier (e.g., "transferðŸ˜€", "transfer!", "transfer\n", "123invalid") 
2. Transaction is BCS-encoded and submitted to API
3. API validates via `validate_entry_function_payload_format()` which calls `verify_function_identifier()` - this passes since identifier contains no `::` [4](#0-3) 

4. Transaction enters mempool and gets included in a block
5. VM executes transaction, loads function via `load_instantiated_function()` [5](#0-4) 

6. VM attempts HashMap lookup in module's function_map: [6](#0-5) 

7. Lookup fails (function doesn't exist with that invalid name), returns `FUNCTION_RESOLUTION_FAILURE`
8. Transaction fails but gas is charged and validator resources are consumed

## Impact Explanation

**Medium Severity** - This qualifies as Medium severity per Aptos bug bounty criteria for the following reasons:

1. **Resource Exhaustion**: Allows creation of transactions that waste validator computational resources and gas, bypassing proper validation
2. **VM Execution Errors**: Causes deterministic but avoidable VM failures that all validators must process
3. **Validation Gap**: Breaks the Transaction Validation invariant that validation should catch malformed inputs before execution

While this doesn't cause consensus violations, type confusion, or fund loss, it represents a security validation gap that allows resource waste and could potentially be used for limited DoS if exploited at scale. The attacker pays gas, but the cost to validators (execution overhead) exceeds normal failed transaction costs.

## Likelihood Explanation

**High Likelihood**:
- Easy to exploit - requires only basic understanding of BCS encoding
- No special privileges needed - any transaction sender can exploit
- Validation gap is consistent and reproducible
- Low detection risk - appears as normal failed transactions
- Existing test code demonstrates the bypass technique

## Recommendation

Implement full Move identifier validation in the API layer by using the Move core `is_valid()` check:

```rust
pub fn verify_function_identifier(function: &str) -> anyhow::Result<()> {
    use move_core_types::identifier::Identifier;
    if !Identifier::is_valid(function) {
        Err(format_err!(
            "invalid Move function name: '{}'. Function names must be valid Move identifiers \
             (ASCII only, start with letter or underscore/dollar, contain only letters, digits, \
             underscores, and dollars)",
            function
        ))
    } else {
        Ok(())
    }
}
```

Apply the same fix to `verify_module_identifier()` and `verify_field_identifier()`. This ensures API validation matches VM requirements.

## Proof of Concept

```rust
// Create invalid identifier with unicode
#[derive(serde::Serialize)]
struct IdentifierBypass(pub Box<str>);

// Bypass validation by deserializing invalid identifier
let invalid_func: Identifier = serde_json::from_str(
    &serde_json::to_string(&IdentifierBypass("transferðŸ˜€".into())).unwrap()
).unwrap();

// Create transaction with invalid identifier
let entry_fn = EntryFunction::new(
    ModuleId::new(AccountAddress::from_hex_literal("0x1").unwrap(), 
                  Identifier::new("coin").unwrap()),
    invalid_func,  // Contains unicode, violates Move identifier rules
    vec![],
    vec![]
);

let txn = account.sign_with_transaction_builder(
    context.transaction_factory()
        .entry_function(entry_fn)
        .expiration_timestamp_secs(u64::MAX)
);

// Encode as BCS and submit
let body = bcs::to_bytes(&txn).unwrap();

// Transaction passes API validation (no "::" present)
// But fails during VM execution with FUNCTION_RESOLUTION_FAILURE
// All validators waste resources processing this invalid transaction
```

## Notes

The existing test `test_post_batch_entry_function_api_validation` validates detection of `"::"` but doesn't test other invalid identifier patterns like unicode, special characters, or invalid starting characters. The validation gap allows any identifier that doesn't contain `"::"` but violates Move's identifier specification to pass through API validation.

### Citations

**File:** api/types/src/move_types.rs (L1468-1477)
```rust
pub fn verify_identifier(identifier: &str) -> anyhow::Result<()> {
    if identifier.contains("::") {
        Err(format_err!(
            "Identifier should not contain '::' {}",
            identifier
        ))
    } else {
        Ok(())
    }
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```

**File:** api/src/tests/transactions_test.rs (L486-496)
```rust
    // This is a way to get around the Identifier checks!
    #[derive(serde::Serialize)]
    struct HackStruct(pub Box<str>);

    // Identifiers check when you call new, but they don't check when you deserialize, surprise!
    let module_id: Identifier =
        serde_json::from_str(&serde_json::to_string(&HackStruct("coin".into())).unwrap()).unwrap();
    let func: Identifier = serde_json::from_str(
        &serde_json::to_string(&HackStruct("transfer::what::what".into())).unwrap(),
    )
    .unwrap();
```

**File:** api/src/transactions.rs (L1354-1390)
```rust
    fn validate_entry_function_payload_format(
        ledger_info: &LedgerInfo,
        payload: &EntryFunction,
    ) -> Result<(), SubmitTransactionError> {
        verify_module_identifier(payload.module().name().as_str())
            .context("Transaction entry function module invalid")
            .map_err(|err| {
                SubmitTransactionError::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    ledger_info,
                )
            })?;

        verify_function_identifier(payload.function().as_str())
            .context("Transaction entry function name invalid")
            .map_err(|err| {
                SubmitTransactionError::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    ledger_info,
                )
            })?;
        for arg in payload.ty_args() {
            let arg: MoveType = arg.into();
            arg.verify(0)
                .context("Transaction entry function type arg invalid")
                .map_err(|err| {
                    SubmitTransactionError::bad_request_with_code(
                        err,
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    )
                })?;
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L945-967)
```rust
    fn validate_and_execute_entry_function(
        &self,
        module_storage: &impl AptosModuleStorage,
        session: &mut SessionExt<impl AptosMoveResolver>,
        serialized_signers: &SerializedSigners,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        entry_fn: &EntryFunction,
        trace_recorder: &mut impl TraceRecorder,
    ) -> Result<(), VMStatus> {
        dispatch_loader!(module_storage, loader, {
            let legacy_loader_config = LegacyLoaderConfig {
                charge_for_dependencies: self.gas_feature_version() >= RELEASE_V1_10,
                charge_for_ty_tag_dependencies: self.gas_feature_version() >= RELEASE_V1_27,
            };
            let function = loader.load_instantiated_function(
                &legacy_loader_config,
                gas_meter,
                traversal_context,
                entry_fn.module(),
                entry_fn.function(),
                entry_fn.ty_args(),
            )?;
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L585-602)
```rust
    pub fn get_function(&self, function_name: &IdentStr) -> VMResult<Arc<Function>> {
        Ok(self
            .function_map
            .get(function_name)
            .and_then(|idx| self.function_defs.get(*idx))
            .ok_or_else(|| {
                let module_id = self.self_id();
                PartialVMError::new(StatusCode::FUNCTION_RESOLUTION_FAILURE)
                    .with_message(format!(
                        "Function {}::{}::{} does not exist",
                        module_id.address(),
                        module_id.name(),
                        function_name
                    ))
                    .finish(Location::Undefined)
            })?
            .clone())
    }
```
