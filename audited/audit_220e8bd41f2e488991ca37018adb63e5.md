# Audit Report

## Title
Transaction Loss During Validator Node Bootstrapping Due to Historical Commit Notifications

## Summary
BCS transactions submitted via the REST API during validator node synchronization are silently lost when the node processes historical blocks containing transactions with matching sender and sequence number. The mempool incorrectly removes newly submitted transactions upon receiving commit notifications for historical transactions, violating transaction delivery guarantees.

## Finding Description

During validator node bootstrapping, the REST API accepts transaction submissions while state sync simultaneously processes historical blocks, creating a critical race condition that results in permanent transaction loss.

**Validated Execution Flow:**

1. **API Accepts Transactions Without Bootstrap Check**: The REST API transaction submission endpoint only checks the `transaction_submission_enabled` flag (which defaults to true) before accepting transactions. There is no verification of whether the node has completed bootstrapping. [1](#0-0) 

2. **Transaction Validated Against Partially Synced State**: When a transaction arrives, the API fetches the latest ledger info to validate the transaction. During bootstrapping, this reflects the node's current partially-synced state, not the full network state. [2](#0-1) 

3. **Storage Synchronizer Notifies Mempool of All Commits**: The storage synchronizer spawns a commit post-processor during initialization that processes ALL committed chunks, including historical blocks being synced during bootstrapping. This post-processor notifies mempool about every committed transaction without distinguishing between historical replays and real-time commits. [3](#0-2) 

4. **Mempool Processes All Commit Notifications Identically**: When mempool receives commit notifications, it calls `process_committed_transactions` which invokes `commit_transaction` for each transaction. There is no distinction between historical commits during bootstrapping and real-time commits during normal operation. [4](#0-3) 

5. **Sequence Number Update Triggers Removal**: For sequence-number based transactions, `commit_transaction` updates the account sequence number to `max(current_account_seq_number, txn_sequence_number + 1)` and then calls `clean_committed_transactions_below_account_seq_num` with this new sequence number. [5](#0-4) 

6. **All Lower Sequence Transactions Removed**: The cleanup method removes ALL transactions with sequence numbers strictly less than the provided account sequence number, including the user's newly submitted transaction if it has a matching sequence number. [6](#0-5) 

**Attack Scenario:**

1. Validator node restarts and begins bootstrapping from version 1000 to version 2000
2. At version 1000, account A has on-chain sequence number 50
3. User queries the node and sees sequence 50 as the next expected
4. User submits a fresh, valid transaction A:50 via `/transactions` endpoint
5. Mempool validates against state at version 1000, accepts transaction, returns HTTP 202 Accepted
6. State sync continues processing historical blocks
7. At version 1500, a historical transaction A:50 (different content, already committed on network) is processed
8. Storage synchronizer sends commit notification to mempool
9. Mempool updates account A's sequence to 51 and calls cleanup
10. The cleanup removes ALL transactions with sequence < 51, including the user's newly submitted A:50
11. User's transaction is permanently lost without notification

**Why This Breaks Invariants:**
- Violates API contract: 202 Accepted response implies the transaction will be processed
- Silent failure with no error notification mechanism
- Transaction delivery guarantee broken for accepted transactions

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

**State inconsistencies requiring manual intervention**: The mempool state becomes inconsistent with user expectations. Users receive successful submission confirmations but their transactions vanish without trace.

**Limited funds loss or manipulation**: Users submitting transactions to bootstrapping nodes may lose those transactions entirely. If these were fund transfers, payments, or time-sensitive operations, the user suffers financial loss while believing the transaction succeeded.

**Silent failure without notification**: Users have no mechanism to detect transaction loss. The initial 202 Accepted response provides false confidence, and there are no subsequent notifications about removal.

The impact is not Critical because:
- Only affects individual users submitting to bootstrapping nodes
- Doesn't compromise consensus safety or network-wide state
- Temporary vulnerability window (during bootstrapping only)

However, it exceeds Low severity because:
- Results in actual transaction loss with financial implications
- Occurs during normal operations (node restarts are common)
- Affects real user transactions with no recovery mechanism

## Likelihood Explanation

**High Likelihood**:

1. **Bootstrapping is Common**: Validator nodes frequently bootstrap when new validators join, existing validators restart for maintenance, nodes recover from crashes, or nodes fall behind and catch up. This creates frequent vulnerability windows.

2. **API Enabled by Default**: The `transaction_submission_enabled` flag defaults to true and is not automatically disabled during bootstrapping. [7](#0-6) [8](#0-7) 

3. **No Bootstrap State Check**: The API does not verify bootstrap completion before accepting transactions. The only check is for the configuration flag. [1](#0-0) 

4. **Mempool Operational During Bootstrap**: Mempool is initialized and running while state sync processes historical blocks, allowing the race condition to occur throughout the entire bootstrapping period.

5. **Extended Vulnerability Window**: The vulnerability persists for the entire duration of bootstrapping, which can range from minutes to hours depending on how far behind the node has fallen.

## Recommendation

Implement one of the following solutions:

**Option 1: Disable Transaction Submission During Bootstrapping**
```rust
// In api/src/transactions.rs submit_transaction method
if !self.context.node_config.api.transaction_submission_enabled {
    return Err(api_disabled("Submit transaction"));
}

// Add bootstrap check
if !self.context.is_bootstrapped() {
    return Err(api_disabled("Node is bootstrapping"));
}
```

**Option 2: Filter Historical Commit Notifications**
Modify the commit post-processor to track whether the node is bootstrapping and avoid sending commit notifications to mempool for historical transactions:

```rust
// In storage_synchronizer.rs spawn_commit_post_processor
// Add bootstrap state tracking and only notify mempool for
// commits that occur after bootstrap completion
```

**Option 3: Mempool Ignore Historical Commits**
Add a flag to commit notifications indicating whether they are historical, and have mempool ignore cleanup for historical commits that might conflict with newly submitted transactions.

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Start a validator node that is behind the network (e.g., at version 1000 while network is at 2000)
2. Query the node's API to get account A's current sequence number (e.g., 50)
3. Submit a valid transaction A:50 via POST /transactions
4. Verify 202 Accepted response
5. Wait for state sync to process historical blocks containing a different transaction A:50
6. Query mempool for the submitted transaction - it will no longer exist
7. Query the node's state - the transaction was never executed

The code paths validated above demonstrate that this sequence will result in transaction loss without any error notification to the user.

### Citations

**File:** api/src/transactions.rs (L490-492)
```rust
        if !self.context.node_config.api.transaction_submission_enabled {
            return Err(api_disabled("Submit transaction"));
        }
```

**File:** api/src/transactions.rs (L495-498)
```rust
        let ledger_info = self.context.get_latest_ledger_info()?;
        let signed_transaction = self.get_signed_transaction(&ledger_info, data)?;
        self.create(&accept_type, &ledger_info, signed_transaction)
            .await
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L783-824)
```rust
/// Spawns a dedicated commit post-processor that handles commit notifications
fn spawn_commit_post_processor<
    MempoolNotifier: MempoolNotificationSender,
    StorageServiceNotifier: StorageServiceNotificationSender,
>(
    mut commit_post_processor_listener: mpsc::Receiver<ChunkCommitNotification>,
    event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
    mempool_notification_handler: MempoolNotificationHandler<MempoolNotifier>,
    storage_service_notification_handler: StorageServiceNotificationHandler<StorageServiceNotifier>,
    pending_data_chunks: Arc<AtomicU64>,
    runtime: Option<Handle>,
    storage: Arc<dyn DbReader>,
) -> JoinHandle<()> {
    // Create a commit post-processor
    let commit_post_processor = async move {
        while let Some(notification) = commit_post_processor_listener.next().await {
            // Start the commit post-process timer
            let _timer = metrics::start_timer(
                &metrics::STORAGE_SYNCHRONIZER_LATENCIES,
                metrics::STORAGE_SYNCHRONIZER_COMMIT_POST_PROCESS,
            );

            // Handle the committed transaction notification (e.g., notify mempool)
            let committed_transactions = CommittedTransactions {
                events: notification.subscribable_events,
                transactions: notification.committed_transactions,
            };
            utils::handle_committed_transactions(
                committed_transactions,
                storage.clone(),
                mempool_notification_handler.clone(),
                event_subscription_service.clone(),
                storage_service_notification_handler.clone(),
            )
            .await;
            decrement_pending_data_chunks(pending_data_chunks.clone());
        }
    };

    // Spawn the commit post-processor
    spawn(runtime, commit_post_processor)
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L713-743)
```rust
pub(crate) fn process_committed_transactions(
    mempool: &Mutex<CoreMempool>,
    use_case_history: &Mutex<UseCaseHistory>,
    transactions: Vec<CommittedTransaction>,
    block_timestamp_usecs: u64,
) {
    let mut pool = mempool.lock();
    let block_timestamp = Duration::from_micros(block_timestamp_usecs);

    let tracking_usecases = {
        let mut history = use_case_history.lock();
        history.update_usecases(&transactions);
        history.compute_tracking_set()
    };

    for transaction in transactions {
        pool.log_commit_transaction(
            &transaction.sender,
            transaction.replay_protector,
            tracking_usecases
                .get(&transaction.use_case)
                .map(|name| (transaction.use_case.clone(), name)),
            block_timestamp,
        );
        pool.commit_transaction(&transaction.sender, transaction.replay_protector);
    }

    if block_timestamp_usecs > 0 {
        pool.gc_by_expiration_time(block_timestamp);
    }
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L635-665)
```rust
    fn clean_committed_transactions_below_account_seq_num(
        &mut self,
        address: &AccountAddress,
        account_sequence_number: u64,
    ) {
        // Remove all previous seq number transactions for this account.
        // This can happen if transactions are sent to multiple nodes and one of the
        // nodes has sent the transaction to consensus but this node still has the
        // transaction sitting in mempool.
        if let Some(txns) = self.transactions.get_mut(address) {
            let mut active = txns.seq_num_split_off(account_sequence_number);
            let txns_for_removal = txns.clone();
            txns.clear();
            txns.append(&mut active);

            let mut rm_txns = match aptos_logger::enabled!(Level::Trace) {
                true => TxnsLog::new(),
                false => TxnsLog::new_with_max(10),
            };
            for transaction in txns_for_removal.values() {
                rm_txns.add(transaction.get_sender(), transaction.get_replay_protector());
                self.index_remove(transaction);
            }
            trace!(
                LogSchema::new(LogEntry::CleanCommittedTxn).txns(rm_txns),
                "txns cleaned with committing tx {}:{}",
                address,
                account_sequence_number
            );
        }
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L671-688)
```rust
    pub fn commit_transaction(
        &mut self,
        account: &AccountAddress,
        replay_protector: ReplayProtector,
    ) {
        match replay_protector {
            ReplayProtector::SequenceNumber(txn_sequence_number) => {
                let current_account_seq_number =
                    self.get_account_sequence_number(account).map_or(0, |v| *v);
                let new_account_seq_number =
                    max(current_account_seq_number, txn_sequence_number + 1);
                self.account_sequence_numbers
                    .insert(*account, new_account_seq_number);
                self.clean_committed_transactions_below_account_seq_num(
                    account,
                    new_account_seq_number,
                );
                self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
```

**File:** config/src/config/api_config.rs (L48-49)
```rust
    #[serde(default = "default_enabled")]
    pub transaction_submission_enabled: bool,
```

**File:** config/src/config/api_config.rs (L127-127)
```rust
            transaction_submission_enabled: default_enabled(),
```
