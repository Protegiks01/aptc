# Audit Report

## Title
DoS via Unbounded Message Length in Transaction Signature Verification

## Summary
The `verify_arbitrary_msg()` implementations across all signature schemes (Ed25519, MultiEd25519, BLS12381, Secp256k1, Secp256r1) do not validate message length before performing cryptographic verification. During transaction validation, validators must verify signatures over BCS-serialized `RawTransaction` messages that can be up to ~6MB in size, with no pre-validation length check. This allows attackers to cause validator slowdown by submitting large transactions that require expensive signature verification before being rejected.

## Finding Description
When a transaction enters the validation pipeline, the signature verification occurs BEFORE transaction size validation: [1](#0-0) 

The `check_signature()` method serializes the entire `RawTransaction` (including payload up to 6MB) and passes it to `verify_arbitrary_msg()`: [2](#0-1) [3](#0-2) 

The signature trait defines `verify_arbitrary_msg` with no length constraints: [4](#0-3) 

All implementations directly pass the message to underlying cryptographic libraries without length validation: [5](#0-4) [6](#0-5) 

The transaction size limit is 6MB: [7](#0-6) 

However, the size check occurs AFTER signature verification in `check_gas`: [8](#0-7) 

An attacker can craft transactions with payloads approaching 6MB. When validators receive these transactions, they must:
1. Deserialize the transaction
2. Verify the signature over the ~6MB serialized `RawTransaction` (expensive)
3. Check transaction size (quick)
4. Reject the oversized transaction

For Ed25519, signature verification requires SHA-512 hashing the entire message plus elliptic curve operations. For a 6MB message at ~500 MB/s hashing speed, this takes ~12ms per transaction just for hashing. BLS verification is even more expensive due to pairing operations.

## Impact Explanation
This is a **High Severity** issue per Aptos Bug Bounty criteria: "Validator node slowdowns."

An attacker can flood validators with large transactions that force expensive signature verification before rejection. While each transaction can only be submitted once due to sequence number replay protection, an attacker controlling multiple accounts can generate sustained load:
- Create accounts with increasing sequence numbers
- Craft ~6MB transactions with valid signatures
- Submit hundreds per second to validators
- Each validator must verify signatures before rejecting

This computational DoS can slow down transaction processing, increase latency, and potentially cause validators to fall behind consensus.

The vulnerability breaks the "Resource Limits" invariant: signature verification is an unbounded computational operation that executes before any resource limits are enforced.

## Likelihood Explanation
**High likelihood**. The attack requires:
- Creating transactions with large payloads (trivial)
- Valid signatures (attacker signs their own transactions)
- Network access to validators (public)
- Multiple accounts to bypass sequence number limits (easy to create)

No privileged access or complex exploit is needed. The vulnerability is in the core transaction validation path executed by all validators for all incoming transactions.

## Recommendation
Add message length validation before signature verification. Implement a pre-check in the transaction validation flow:

**Option 1**: Add length check before signature verification in `validate_transaction`:
```rust
// In aptos-move/aptos-vm/src/aptos_vm.rs, before line 3232
let txn_size = bcs::serialized_size(&transaction)
    .context("Failed to compute transaction size")?;
if txn_size > MAX_TRANSACTION_SIZE_IN_BYTES {
    return VMValidatorResult::error(StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE);
}
```

**Option 2**: Add length validation in `verify_arbitrary_msg` implementations:
```rust
// In each signature implementation
const MAX_MESSAGE_SIZE: usize = 10 * 1024 * 1024; // 10MB safety limit

fn verify_arbitrary_msg(&self, message: &[u8], public_key: &PublicKey) -> Result<()> {
    if message.len() > MAX_MESSAGE_SIZE {
        return Err(anyhow!("Message too large for signature verification"));
    }
    // ... existing verification logic
}
```

**Recommended**: Implement Option 1 to reject oversized transactions immediately without any expensive operations.

## Proof of Concept

```rust
// Rust PoC demonstrating the vulnerability
use aptos_crypto::{ed25519::*, traits::*};
use aptos_types::transaction::*;

fn main() {
    // Create a large transaction payload (~6MB)
    let large_args: Vec<Vec<u8>> = vec![vec![0u8; 6_000_000]];
    let entry_fn = EntryFunction::new(
        ModuleId::new(AccountAddress::ONE, ident_str!("test").to_owned()),
        ident_str!("large_fn").to_owned(),
        vec![],
        large_args,
    );
    
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::EntryFunction(entry_fn),
        1_000_000,
        1,
        u64::MAX,
        ChainId::test(),
    );
    
    // Sign the large transaction
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    let signature = private_key.sign(&raw_txn).unwrap();
    
    let signed_txn = SignedTransaction::new(
        raw_txn,
        public_key,
        signature,
    );
    
    // Measure signature verification time
    let start = std::time::Instant::now();
    let result = signed_txn.check_signature();
    let duration = start.elapsed();
    
    println!("Signature verification took: {:?}", duration);
    println!("Transaction size: {} bytes", bcs::to_bytes(&signed_txn).unwrap().len());
    // Expected: ~12-20ms per verification for 6MB transaction
    // Attacker can send 50-100 per second to overload validator
}
```

## Notes
While Move native signature verification functions properly charge gas proportional to message length, this does not protect the transaction validation path where signature verification occurs BEFORE mempool admission and gas metering. The vulnerability exists specifically in the validator's transaction intake pipeline, not in on-chain signature verification.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```

**File:** types/src/transaction/mod.rs (L1310-1313)
```rust
    pub fn check_signature(self) -> Result<SignatureCheckedTransaction> {
        self.authenticator.verify(&self.raw_txn)?;
        Ok(SignatureCheckedTransaction(self))
    }
```

**File:** types/src/transaction/authenticator.rs (L160-174)
```rust
    pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
        match self {
            Self::Ed25519 {
                public_key,
                signature,
            } => signature.verify(raw_txn, public_key),
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L274-278)
```rust
    fn verify_arbitrary_msg(
        &self,
        message: &[u8],
        public_key: &Self::VerifyingKeyMaterial,
    ) -> Result<()>;
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_sigs.rs (L126-140)
```rust
    fn verify_arbitrary_msg(&self, message: &[u8], public_key: &Ed25519PublicKey) -> Result<()> {
        // NOTE: ed25519::PublicKey::verify_strict already checks that the s-component of the signature
        // is not mauled, but does so via an optimistic path which fails into a slower path. By doing
        // our own (much faster) checking here, we can ensure dalek's optimistic path always succeeds
        // and the slow path is never triggered.
        Ed25519Signature::check_s_malleability(&self.to_bytes())?;

        // NOTE: ed25519::PublicKey::verify_strict checks that the signature's R-component and
        // the public key are *not* in a small subgroup.
        public_key
            .0
            .verify_strict(message, &self.0)
            .map_err(|e| anyhow!("{}", e))
            .and(Ok(()))
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L152-166)
```rust
    fn verify_arbitrary_msg(&self, message: &[u8], public_key: &PublicKey) -> Result<()> {
        let result = self.sig.verify(
            true,
            message,
            DST_BLS_SIG_IN_G2_WITH_POP,
            &[],
            &public_key.pubkey,
            false,
        );
        if result == BLST_ERROR::BLST_SUCCESS {
            Ok(())
        } else {
            Err(anyhow!("{:?}", result))
        }
    }
```

**File:** aptos-move/e2e-testsuite/src/tests/verify_txn.rs (L30-30)
```rust
pub const MAX_TRANSACTION_SIZE_IN_BYTES: u64 = 6 * 1024 * 1024;
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```
