# Audit Report

## Title
Unbounded Memory Growth in FullTraceRecorder Enables Validator Denial-of-Service via Sequential Closure Calls

## Summary
The `calls` Vec in `FullTraceRecorder` grows without bounds based on the number of closure calls during transaction execution. This memory is not tracked by the VM's memory quota system, allowing a malicious transaction to exhaust validator memory through sequential closure calls in a loop, potentially causing Out-of-Memory (OOM) crashes and validator denial-of-service.

## Finding Description

The vulnerability exists in the execution tracing system used when `async_runtime_checks_enabled` is true. The `FullTraceRecorder` struct maintains an unbounded `Vec<DynamicCall>` that records every closure call made during transaction execution. [1](#0-0) 

This vector is initialized with no capacity limit and grows with each closure call: [2](#0-1) 

The recording happens after successful gas charging but the memory consumed by the trace recorder itself is **not tracked** by the VM's memory quota system. The memory quota system only tracks VM heap values (operand stack, values, etc.): [3](#0-2) 

In the interpreter, closure calls are recorded after gas is charged and the call frame is successfully created: [4](#0-3) 

**Attack Path:**
1. Attacker submits a transaction with an entry function containing a loop
2. Each iteration creates and immediately calls a closure
3. Each closure call costs minimal gas (~3,676 internal gas units base cost)
4. With max transaction gas of 2,000,000 units (2 trillion internal gas units), attacker can make millions of calls
5. Each call adds a `DynamicCall` entry (~100-200 bytes) to the untracked `calls` Vec
6. This results in multi-gigabyte memory allocation per transaction

The vulnerability is enabled when `async_runtime_checks_enabled` is configured: [5](#0-4) [6](#0-5) 

**Broken Invariants:**
- **Move VM Safety (Invariant #3)**: Bytecode execution must respect memory constraints - violated because trace recorder memory is untracked
- **Resource Limits (Invariant #9)**: All operations must respect computational limits - violated because memory growth is only indirectly limited by gas

## Impact Explanation

**High Severity** per Aptos bug bounty criteria: "Validator node slowdowns" and "API crashes"

**Specific Impact:**
- **Memory Exhaustion**: A single malicious transaction can consume 2-10 GB of untracked memory
- **Validator DoS**: OOM conditions cause validator process termination
- **Network Disruption**: Multiple validators affected simultaneously impacts network liveness
- **Deterministic Execution at Risk**: Memory exhaustion timing may vary across validators, potentially causing consensus divergence if some validators crash while others complete execution

**Quantification:**
- Max gas: 2,000,000 external units = 2 trillion internal gas units
- Min gas per closure call: ~3,676 internal gas units
- Realistic calls (accounting for loop overhead): 10-50 million
- Memory per entry: ~200 bytes (LoadedFunction with Arc pointers + ClosureMask)
- **Total memory consumption: 2-10 GB per transaction**

This bypasses all existing memory protection mechanisms since the trace recorder's internal data structures are not subject to the memory quota enforcement that tracks VM heap allocations.

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**
- Attack is trivial to execute - simple Move loop with closures
- No special privileges required - any user can submit such transactions
- Feature exists in codebase and is configurable
- Test configurations show `async_runtime_checks = true` is actively used
- Code comments indicate intention to enable by default [7](#0-6) 

**Factors Reducing Likelihood:**
- Feature defaults to `false` in current configurations
- Requires operator to explicitly enable async runtime checks

However, the vulnerability's presence in production-ready code paths and clear intent to enable it makes this a critical issue to address before wider deployment.

## Recommendation

**Immediate Fix:** Add a size limit to the `calls` Vec and enforce it during recording:

```rust
// In FullTraceRecorder struct
const MAX_TRACE_CALLS: usize = 100_000; // Configurable limit

// In record_call_closure and record_entrypoint
fn record_call_closure(&mut self, function: &LoadedFunction, mask: ClosureMask) {
    if self.calls.len() >= MAX_TRACE_CALLS {
        // Either silently stop recording or return error
        return;
    }
    self.calls.push(DynamicCall::Closure(function.clone(), mask));
}
```

**Long-term Fix:** Integrate trace recorder memory into the VM's memory quota system by:
1. Adding `use_heap_memory()` calls when recording entries
2. Estimating memory size of each `DynamicCall` entry
3. Releasing memory when trace is consumed

**Alternative Approach:** Implement a ring buffer or sampling strategy for traces to prevent unbounded growth while maintaining sufficient diagnostic information.

## Proof of Concept

```move
// File: attack_closure_memory.move
script {
    fun attack_trace_recorder() {
        let i: u64 = 0;
        // Adjust iterations based on available gas
        // With 2M gas units, can potentially do millions of iterations
        let max_iterations: u64 = 10_000_000;
        
        while (i < max_iterations) {
            // Create and immediately call a closure
            let closure = || {};
            closure();
            i = i + 1;
        };
    }
}
```

**Execution:**
1. Deploy the script on a network with `async_runtime_checks_enabled = true`
2. Execute with maximum gas limit (2,000,000 gas units)
3. Monitor validator memory usage - should see multi-GB allocation
4. Repeat from multiple accounts to amplify impact

**Expected Result:**
- Validator memory increases by 2-10 GB during transaction execution
- Potential OOM kill if validator has insufficient memory
- Network degradation if multiple validators affected simultaneously

**Notes:**
- The exact number of achievable iterations depends on gas costs for loop overhead and closure creation
- Each `CallClosure` instruction charges gas, but the trace recorder's memory consumption is unchecked
- The vulnerability is exploitable whenever `async_runtime_checks_enabled` is true, regardless of whether it's currently enabled in default production configurations

### Citations

**File:** third_party/move/move-vm/runtime/src/execution_tracing/recorders.rs (L60-69)
```rust
pub struct FullTraceRecorder {
    /// Number of successfully executed instructions.
    ticks: u64,
    /// Records the fingerprint of the trace, for extra security.
    fingerprint_recorder: BytecodeFingerprintRecorder,
    /// Branch outcomes (taken or not taken), stored as a bit-vector.
    branch_outcomes: BitVec,
    /// Dynamic call outcomes.
    calls: Vec<DynamicCall>,
}
```

**File:** third_party/move/move-vm/runtime/src/execution_tracing/recorders.rs (L116-119)
```rust
    fn record_call_closure(&mut self, function: &LoadedFunction, mask: ClosureMask) {
        self.calls
            .push(DynamicCall::Closure(function.clone(), mask));
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L46-63)
```rust

    #[inline]
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L765-778)
```rust
                        self.set_new_call_frame::<RTTCheck, RTRCheck>(
                            &mut current_frame,
                            gas_meter,
                            callee,
                            fn_guard,
                            CallType::ClosureDynamicDispatch,
                            // Make sure the frame cache is empty for the new call.
                            frame_cache,
                            mask,
                            captured_vec,
                        )?;
                        trace_recorder
                            .record_successful_instruction(&Instruction::CallClosure(sig_idx));
                        trace_recorder.record_call_closure(current_frame.function.as_ref(), mask);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L409-423)
```rust
    fn should_perform_async_runtime_checks_for_txn(&self, txn: &SignedTransaction) -> bool {
        self.async_runtime_checks_enabled
            && match txn.payload().executable_ref() {
                Ok(TransactionExecutableRef::Script(_)) => {
                    // For now, always delay checks for scripts.
                    true
                },
                Ok(TransactionExecutableRef::EntryFunction(f)) => {
                    // If entry function is defined at special address - it is part of trusted code
                    // and so no need to delay any checks (as there are none).
                    !f.module().address().is_special()
                },
                Ok(TransactionExecutableRef::Empty) | Err(_) => false,
            }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2166-2176)
```rust
        let (status, output) = if self.should_perform_async_runtime_checks_for_txn(txn) {
            self.execute_user_transaction_impl(
                resolver,
                code_storage,
                txn,
                txn_metadata,
                is_approved_gov_script,
                log_context,
                &mut gas_meter,
                FullTraceRecorder::new(),
            )
```

**File:** testsuite/forge-cli/src/suites/realistic_environment.rs (L331-334)
```rust
            config.execution.processed_transactions_detailed_counters = true;
            // TODO(georgemitenkov): remove once features are added to default config.
            config.execution.async_runtime_checks = true;
        }))
```
