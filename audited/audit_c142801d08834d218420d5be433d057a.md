# Audit Report

## Title
Epoch Boundary Violation in RoundManager Initialization Allows Cross-Epoch Vote Pollution

## Summary
The `round_manager.init()` function fails to validate that `last_vote` belongs to the current epoch before recording it in `RoundState`. During epoch transitions, a vote from the previous epoch can be incorrectly recorded as the "last vote sent" for the new epoch, potentially blocking validators from voting in matching rounds and causing liveness issues.

## Finding Description

During epoch transitions, the consensus system initializes a new `RoundManager` for the incoming epoch. The initialization flow has a critical epoch boundary violation:

1. **Recovery Data Construction**: When `RecoveryData::new()` is called, it filters `last_vote` by comparing it to the epoch extracted from the root block in storage [1](#0-0) 

2. **Epoch Mismatch**: The root block's epoch comes from the ledger (previous epoch N-1), while the `RoundManager` is being initialized for the new epoch (N) [2](#0-1) 

3. **Filtering Passes Stale Vote**: Since both the `last_vote` and root block are from epoch N-1, the vote passes the epoch filter even though it should be rejected for epoch N [3](#0-2) 

4. **No Epoch Validation in init()**: The `round_manager.init()` function receives this epoch N-1 vote and calls `record_vote()` without any epoch validation [4](#0-3) 

5. **Round-Only Check**: The `record_vote()` method only validates round numbers, not epochs [5](#0-4) 

6. **Voting Blocked**: When the validator attempts to vote in the new epoch, the check at `vote_block()` fails because `vote_sent()` already contains the stale vote from the previous epoch [6](#0-5) 

**Root Cause**: The filtering logic compares the vote's epoch to the wrong reference point (root block epoch instead of the new epoch state), and `record_vote()` lacks epoch validation, allowing cross-epoch vote pollution.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability causes **significant protocol violations** during epoch transitions:

- **Liveness Impact**: Affected validators cannot vote in the first round(s) of a new epoch if round numbers align with their last vote from the previous epoch
- **Consensus Degradation**: If multiple validators are affected simultaneously, consensus quorum formation is delayed
- **Unpredictable Behavior**: The impact depends on the alignment of round numbers between epochs, making it intermittent but inevitable over time
- **Validator Performance**: Affected validators appear unresponsive during critical epoch transition periods

While SafetyRules would eventually catch epoch mismatches when constructing new votes, the validator has already wasted time and resources attempting to vote with stale state.

## Likelihood Explanation

**Likelihood: High**

This issue triggers automatically during normal epoch transitions under the following conditions:

1. **Frequency**: Occurs on every epoch transition (typically daily or when validator set changes)
2. **Probability**: Triggers when `last_vote.round == sync_info.highest_round() + 1`, which can happen if:
   - Previous epoch ended at round R
   - New epoch starts at round R (or R+1)
   - Round numbers are not reset between epochs (they often continue)
3. **No Attacker Required**: This is a protocol-level bug that manifests without malicious intervention
4. **Widespread Impact**: Affects all validators who voted in the previous epoch's final rounds

The issue is particularly likely because:
- Epoch transitions are frequent operational events
- Round numbers typically increment continuously across epochs
- All active validators maintain `last_vote` in persistent storage

## Recommendation

Add explicit epoch validation in `round_manager.init()` before recording the last vote:

```rust
pub async fn init(&mut self, last_vote_sent: Option<Vote>) {
    let epoch_state = self.epoch_state.clone();
    let new_round_event = self
        .round_state
        .process_certificates(self.block_store.sync_info(), &epoch_state.verifier)
        .expect("Can not jump start a round_state from existing certificates.");
    
    // ADD EPOCH VALIDATION
    if let Some(vote) = last_vote_sent {
        if vote.epoch() == epoch_state.epoch {
            self.round_state.record_vote(vote);
        } else {
            debug!(
                "Discarding last_vote from epoch {} (current epoch: {})",
                vote.epoch(),
                epoch_state.epoch
            );
        }
    }
    
    if let Err(e) = self.process_new_round_event(new_round_event).await {
        warn!(error = ?e, "[RoundManager] Error during start");
    }
}
```

Additionally, strengthen the filtering in `RecoveryData::new()` to use the expected new epoch rather than the root block's epoch. The epoch should be passed as an explicit parameter:

```rust
pub fn new(
    last_vote: Option<Vote>,
    expected_epoch: u64,  // Add explicit epoch parameter
    ledger_recovery_data: LedgerRecoveryData,
    // ... other parameters
) -> Result<Self> {
    // ... existing code ...
    
    Ok(RecoveryData {
        last_vote: match last_vote {
            Some(v) if v.epoch() == expected_epoch => Some(v),  // Use expected_epoch
            _ => None,
        },
        // ... rest of fields
    })
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_cross_epoch_vote_pollution() {
    // Setup: Epoch 1 ending
    let epoch_1_state = Arc::new(EpochState {
        epoch: 1,
        verifier: create_test_verifier(),
    });
    
    // Validator votes in epoch 1, round 100
    let vote_epoch_1 = Vote::new(
        VoteData::new(
            BlockInfo::new(1, 100, HashValue::random(), HashValue::random(), 0, 0, None),
            BlockInfo::genesis(),
        ),
        validator_address,
        placeholder_ledger_info(),
        &validator_signer,
    ).unwrap();
    
    // Store the vote (simulating normal operation)
    storage.save_vote(&vote_epoch_1).unwrap();
    
    // Epoch transition: Moving to epoch 2
    let epoch_2_state = Arc::new(EpochState {
        epoch: 2,
        verifier: create_test_verifier(),
    });
    
    // Recovery data is constructed
    let recovery_data = storage.start(false, None);
    let last_vote = recovery_data.last_vote();
    
    // BUG: last_vote is from epoch 1, but passes through
    assert_eq!(last_vote.as_ref().unwrap().epoch(), 1);
    
    // Create RoundManager for epoch 2
    let mut round_manager = RoundManager::new(
        epoch_2_state.clone(),
        block_store,
        round_state,
        proposer_election,
        proposal_generator,
        safety_rules,
        network,
        storage,
        onchain_config,
        buffered_proposal_tx,
        block_txn_filter_config,
        local_config,
        randomness_config,
        jwk_consensus_config,
        None,
        proposal_status_tracker,
        opt_proposal_loopback_tx,
    );
    
    // Initialize with epoch 1 vote
    round_manager.init(last_vote).await;
    
    // VULNERABILITY: vote_sent now contains a vote from epoch 1
    assert!(round_manager.round_state.vote_sent().is_some());
    let recorded_vote = round_manager.round_state.vote_sent().unwrap();
    
    // The recorded vote is from the wrong epoch!
    assert_eq!(recorded_vote.epoch(), 1);
    assert_eq!(epoch_2_state.epoch, 2);
    
    // If round 100 comes up in epoch 2, validator cannot vote
    // because it thinks it already voted (but that was epoch 1!)
    let proposal_round_100 = create_test_proposal(2, 100);
    let result = round_manager.vote_block(proposal_round_100).await;
    
    // FAILURE: Validator blocked from voting due to cross-epoch pollution
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Already vote on this round"));
}
```

## Notes

This vulnerability represents a fundamental epoch boundary violation in the consensus protocol. The issue is particularly insidious because:

1. **Silent Failure**: Validators don't crash or produce obvious errors; they simply fail to vote
2. **Timing Dependent**: Only manifests when round numbers align across epochs
3. **Multiple Safeguards Bypassed**: Both the storage layer filtering and the round state validation fail to catch this
4. **Production Impact**: Affects real validator operations during every epoch transition

The fix requires epoch awareness at multiple layers: filtering during recovery data construction and validation during round manager initialization. Both safeguards are necessary to fully protect against cross-epoch state pollution.

### Citations

**File:** consensus/src/persistent_liveness_storage.rs (L386-397)
```rust
        let (root_id, epoch) = match &root.window_root_block {
            None => {
                let commit_root_id = root.commit_root_block.id();
                let epoch = root.commit_root_block.epoch();
                (commit_root_id, epoch)
            },
            Some(window_root_block) => {
                let window_start_id = window_root_block.id();
                let epoch = window_root_block.epoch();
                (window_start_id, epoch)
            },
        };
```

**File:** consensus/src/persistent_liveness_storage.rs (L405-408)
```rust
            last_vote: match last_vote {
                Some(v) if v.epoch() == epoch => Some(v),
                _ => None,
            },
```

**File:** consensus/src/epoch_manager.rs (L1171-1174)
```rust
        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });
```

**File:** consensus/src/round_manager.rs (L1508-1512)
```rust
        ensure!(
            self.round_state.vote_sent().is_none(),
            "[RoundManager] Already vote on this round {}",
            self.round_state.current_round()
        );
```

**File:** consensus/src/round_manager.rs (L2018-2030)
```rust
    pub async fn init(&mut self, last_vote_sent: Option<Vote>) {
        let epoch_state = self.epoch_state.clone();
        let new_round_event = self
            .round_state
            .process_certificates(self.block_store.sync_info(), &epoch_state.verifier)
            .expect("Can not jump start a round_state from existing certificates.");
        if let Some(vote) = last_vote_sent {
            self.round_state.record_vote(vote);
        }
        if let Err(e) = self.process_new_round_event(new_round_event).await {
            warn!(error = ?e, "[RoundManager] Error during start");
        }
    }
```

**File:** consensus/src/liveness/round_state.rs (L318-322)
```rust
    pub fn record_vote(&mut self, vote: Vote) {
        if vote.vote_data().proposed().round() == self.current_round {
            self.vote_sent = Some(vote);
        }
    }
```
