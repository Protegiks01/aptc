# Audit Report

## Title
Captcha Token Exhaustion via Ignored dry_run Parameter in Google reCAPTCHA Checker

## Summary
The `GoogleCaptchaChecker::check()` method ignores the `dry_run` parameter, causing every eligibility check via the `/is_eligible` endpoint to consume single-use Google reCAPTCHA tokens. This allows attackers to exhaust valid captcha tokens without receiving any funds, effectively creating a denial-of-service condition for the faucet service.

## Finding Description
The `CheckerTrait` interface defines a `check()` method with a `dry_run` parameter intended to prevent side effects during eligibility checks. [1](#0-0)  The documentation explicitly states that when `dry_run` is true, checkers should not store or consume resources.

Other stateful checkers like `MemoryRatelimitChecker` and `RedisRatelimitChecker` properly respect this parameter by conditionally skipping state updates. [2](#0-1) [3](#0-2) 

However, the `GoogleCaptchaChecker` ignores the `dry_run` parameter entirely. [4](#0-3)  The checker proceeds to make a full HTTP POST request to Google's reCAPTCHA API regardless of the dry_run flag. [5](#0-4) 

Google reCAPTCHA tokens are single-use by designâ€”once verified with Google's API, they become invalid and cannot be reused. This is enforced server-side by Google.

**Attack Path:**
1. Attacker obtains valid reCAPTCHA tokens (by solving captcha challenges or using automated services)
2. Attacker repeatedly calls the `/is_eligible` endpoint with these tokens [6](#0-5) 
3. The `is_eligible` endpoint calls `preprocess_request()` with `dry_run=true` [7](#0-6) 
4. `preprocess_request()` invokes all checkers with the dry_run flag [8](#0-7) 
5. `GoogleCaptchaChecker` ignores dry_run and verifies the token with Google's API, consuming it
6. The token is now permanently invalid for actual funding requests
7. No funds are distributed, rate limits are not incremented (they respect dry_run), allowing repeated exploitation

The same vulnerability exists in `TapCaptchaChecker` which also ignores dry_run and consumes in-memory captcha challenges. [9](#0-8) [10](#0-9) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" or "Significant protocol violations" categories. The impact includes:

1. **Resource Exhaustion**: Attackers can systematically exhaust valid captcha tokens without any cost (beyond solving captchas)
2. **Denial of Service**: Legitimate users who solve captchas correctly find their tokens already consumed when attempting actual funding requests
3. **Operational Disruption**: The faucet service becomes unreliable or unusable, requiring manual intervention
4. **Bypassed Rate Limiting**: Since rate limiters respect dry_run, attackers can make numerous is_eligible calls without hitting rate limits

While this doesn't affect mainnet funds or consensus, it severely degrades the availability and reliability of the faucet service, which is critical infrastructure for testnet operations and developer onboarding.

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of exploitation:

1. **Easy Discovery**: The behavior is observable by any user calling the public API endpoints
2. **No Special Access Required**: Attack requires only HTTP requests to public endpoints
3. **Low Barrier to Entry**: Attacker only needs to solve reCAPTCHA challenges or use commercial solving services
4. **Clear Motivation**: Disrupting faucet services can harm testnet operations and developer experience
5. **No Authentication Needed**: The `/is_eligible` endpoint is publicly accessible
6. **Rate Limit Evasion**: Rate limiters respect dry_run, allowing sustained attacks

## Recommendation
Modify both `GoogleCaptchaChecker` and `TapCaptchaChecker` to respect the `dry_run` parameter:

**For GoogleCaptchaChecker:**
```rust
async fn check(
    &self,
    data: CheckerData,
    dry_run: bool,  // Remove underscore prefix
) -> Result<Vec<RejectionReason>, AptosTapError> {
    let captcha_token = match data.headers.get(COMPLETED_CAPTCHA_TOKEN) {
        Some(header_value) => header_value.to_str().map_err(|e| {
            AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
        })?,
        None => {
            return Ok(vec![RejectionReason::new(
                format!("Captcha header {} not found", COMPLETED_CAPTCHA_TOKEN),
                RejectionReasonCode::CaptchaInvalid,
            )])
        },
    };

    // In dry_run mode, just verify the header exists without consuming the token
    if dry_run {
        return Ok(vec![]);
    }

    // Only make the Google API call if not in dry_run mode
    let verify_result = reqwest::Client::new()
        .post(GOOGLE_CAPTCHA_ENDPOINT)
        // ... rest of verification logic
}
```

**For TapCaptchaChecker:**
```rust
async fn check(
    &self,
    data: CheckerData,
    dry_run: bool,  // Remove underscore prefix
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // ... extract captcha_key and captcha_value ...

    // In dry_run mode, verify headers exist without consuming the challenge
    if dry_run {
        let captcha_exists = self
            .captcha_manager
            .lock()
            .await
            .challenges
            .contains_key(&captcha_key);
        
        if !captcha_exists {
            return Ok(vec![RejectionReason::new(
                format!("Captcha key unknown: {}", captcha_key),
                RejectionReasonCode::CaptchaInvalid,
            )]);
        }
        return Ok(vec![]);
    }

    // Only consume the challenge if not in dry_run mode
    let captcha_correct = match self
        .captcha_manager
        .lock()
        .await
        .check_challenge(captcha_key, captcha_value)
    // ... rest of logic
}
```

## Proof of Concept

```bash
#!/bin/bash
# POC: Demonstrate captcha token exhaustion via is_eligible endpoint

FAUCET_URL="https://faucet.testnet.aptoslabs.com"
RECEIVER_ADDRESS="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"

# Step 1: Obtain a valid reCAPTCHA token (simulated here)
CAPTCHA_TOKEN="valid_recaptcha_token_from_client"

# Step 2: Call is_eligible endpoint - this consumes the token
curl -X POST "$FAUCET_URL/is_eligible" \
  -H "Content-Type: application/json" \
  -H "$COMPLETED_CAPTCHA_TOKEN: $CAPTCHA_TOKEN" \
  -d "{\"address\": \"$RECEIVER_ADDRESS\"}"

# Response: 200 OK (eligible)

# Step 3: Try to use the same token for actual funding
curl -X POST "$FAUCET_URL/fund" \
  -H "Content-Type: application/json" \
  -H "$COMPLETED_CAPTCHA_TOKEN: $CAPTCHA_TOKEN" \
  -d "{\"address\": \"$RECEIVER_ADDRESS\"}"

# Response: 403 Forbidden - "Failed to pass captcha check"
# The token was consumed by is_eligible and is now invalid

# Step 4: Repeat with fresh tokens to exhaust multiple valid tokens
for i in {1..100}; do
  NEW_TOKEN="valid_token_$i"
  curl -X POST "$FAUCET_URL/is_eligible" \
    -H "$COMPLETED_CAPTCHA_TOKEN: $NEW_TOKEN" \
    -d "{\"address\": \"$RECEIVER_ADDRESS\"}"
done

# Result: 100 valid captcha tokens consumed without receiving any funds
```

## Notes

This vulnerability breaks the documented contract of the `CheckerTrait` interface where `dry_run` should prevent resource consumption. The issue affects both Google reCAPTCHA and the in-house TapCaptcha implementations, indicating a systemic misunderstanding of the dry_run parameter's purpose for stateful checkers.

While the faucet is not part of the core blockchain consensus, it is critical infrastructure within the Aptos ecosystem for testnet operations and developer onboarding. The vulnerability enables low-cost, high-impact denial-of-service attacks against this service.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L45-52)
```rust
    /// Returns a list of rejection reasons for the request, if any. If dry_run
    /// is set, if this Checker would store anything based on the request, it
    /// instead will not. This is useful for the is_eligible endpoint.
    async fn check(
        &self,
        data: CheckerData,
        dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError>;
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L86-88)
```rust
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L263-301)
```rust
        if !dry_run {
            let incremented_limit_value = match limit_value {
                Some(_) => conn.incr(&key, 1).await.map_err(|e| {
                    AptosTapError::new_with_error_code(
                        format!("Failed to increment redis key {}: {}", key, e),
                        AptosTapErrorCode::StorageError,
                    )
                })?,
                // If the limit value doesn't exist, create it and set the
                // expiration time.
                None => {
                    let (incremented_limit_value,): (i64,) = redis::pipe()
                        .atomic()
                        .incr(&key, 1)
                        // Expire at the end of the day roughly.
                        .expire(&key, seconds_until_next_day as usize)
                        // Only set the expiration if one isn't already set.
                        // Only works with Redis 7 sadly.
                        // .arg("NX")
                        .ignore()
                        .query_async(&mut *conn)
                        .await
                        .map_err(|e| {
                            AptosTapError::new_with_error_code(
                                format!("Failed to increment value for redis key {}: {}", key, e),
                                AptosTapErrorCode::StorageError,
                            )
                        })?;
                    incremented_limit_value
                },
            };

            // Check limit again, to ensure there wasn't a get / set race.
            if let Some(rejection_reason) =
                self.check_limit_value(Some(incremented_limit_value), seconds_until_next_day)
            {
                return Ok(vec![rejection_reason]);
            }
        }
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L60-64)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L77-87)
```rust
        let verify_result = reqwest::Client::new()
            .post(GOOGLE_CAPTCHA_ENDPOINT)
            // Google captcha API only accepts form encoded payload, lol
            .form::<VerifyRequest>(&VerifyRequest {
                secret: self.config.google_captcha_api_key.0.clone(),
                response: captcha_token.to_string(),
                remoteip: data.source_ip.to_string(),
            })
            .send()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError))?;
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L133-167)
```rust
    async fn is_eligible(
        &self,
        fund_request: Json<FundRequest>,
        asset: poem_openapi::param::Query<Option<String>>,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
        header_map: &HeaderMap,
    ) -> poem::Result<(), AptosTapErrorResponse> {
        let (checker_data, bypass, _semaphore_permit) = self
            .components
            .preprocess_request(&fund_request.0, source_ip, header_map, true)
            .await?;

        if bypass {
            return Ok(());
        }

        // Call Funder.fund with `check_only` set, meaning it only does the
        // initial set of checks without actually submitting any transactions
        // to fund the account. Pass asset directly, funder will use its configured default if None.
        self.components
            .funder
            .fund(
                fund_request.amount,
                checker_data.receiver,
                asset.0,
                true,
                bypass,
            )
            .await?;

        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-270)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L50-54)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```
