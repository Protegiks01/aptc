# Audit Report

## Title
Integer Underflow Panic in Native Coin Withdrawal Path Due to Missing Balance Validation

## Summary
The `withdraw_coin_apt_from_signer()` function in the native VM benchmark executor performs unchecked subtraction of `transfer_amount + gas` from the sender's coin balance without validating sufficient funds exist, causing a panic when the balance is insufficient. This differs from the FA (FungibleAsset) path which properly validates before subtracting.

## Finding Description

The vulnerability exists in the coin withdrawal implementation used by the native benchmark executor. When processing a transaction, the system must deduct both the transfer amount and gas fees from the sender's balance. [1](#0-0) 

The critical issue is on line 711 where the code performs:
```rust
sender_coin_store.set_coin(sender_coin_store.coin() - transfer_amount - gas);
```

This uses Rust's standard subtraction operator without any preceding check to verify `sender_coin_store.coin() >= transfer_amount + gas`. The `set_coin()` method simply assigns the value without validation. [2](#0-1) 

In contrast, the FA path properly validates before performing the subtraction: [3](#0-2) 

The FA implementation checks `if fa_store.balance >= transfer_amount + gas` on line 653 before allowing the withdrawal, returning `Err(())` if insufficient funds exist.

The Aptos codebase enables overflow checks in release builds: [4](#0-3) 

With `overflow-checks = true`, the subtraction will panic when it would underflow rather than wrapping around. This panic occurs during transaction execution and crashes the benchmark executor.

The same pattern exists in parallel executor implementations: [5](#0-4) 

And in the cached implementation: [6](#0-5) 

## Impact Explanation

**Severity: Low to Medium (Benchmark Code Limitation)**

This vulnerability affects the **executor-benchmark** module, which is used for performance testing and comparing different execution strategies, not production validator nodes. 

The impact is limited to:
- **Benchmark execution failure**: The benchmark tool crashes when testing transactions with insufficient balances
- **Incorrect benchmark results**: Inability to properly measure error handling paths
- **Inconsistent behavior**: Coin and FA paths handle the same error condition differently (panic vs graceful error)

While the code implements the `VMBlockExecutor` trait (a production interface), it resides in the benchmark module and is not used in production validators. If this code were accidentally deployed to production, it would constitute a High severity issue (validator crashes causing liveness failures), but in its current benchmarking context, the production impact is minimal.

## Likelihood Explanation

**Likelihood: High (within benchmark execution context)**

The vulnerability triggers whenever a benchmark transaction attempts to withdraw more than the available balance. This can easily occur during benchmark setup or when testing edge cases. The likelihood is high within the benchmark execution context but does not affect production deployments since this code path is not used in production validators.

## Recommendation

Add balance validation before performing the subtraction, consistent with the FA path implementation:

```rust
fn withdraw_coin_apt_from_signer(
    &self,
    sender_address: AccountAddress,
    transfer_amount: u64,
    view: &(impl ExecutorView + ResourceGroupView),
    gas: u64,
    resource_write_set: &mut BTreeMap<StateKey, AbstractResourceWriteOp>,
    events: &mut Vec<(ContractEvent, Option<MoveTypeLayout>)>,
) -> Result<(), ()> {
    let sender_coin_store_key = self.db_util.new_state_key_aptos_coin(&sender_address);
    
    let sender_coin_store_opt =
        Self::get_value::<CoinStoreResource<AptosCoinType>>(&sender_coin_store_key, view)?;

    let (mut sender_coin_store, metadata) = match sender_coin_store_opt {
        None => {
            return self.withdraw_fa_apt_from_signer(
                sender_address,
                transfer_amount,
                view,
                gas,
                resource_write_set,
                events,
            )
        },
        Some((sender_coin_store, metadata)) => (sender_coin_store, metadata),
    };

    // ADD BALANCE CHECK HERE
    if sender_coin_store.coin() < transfer_amount + gas {
        return Err(());
    }

    sender_coin_store.set_coin(sender_coin_store.coin() - transfer_amount - gas);
    
    // ... rest of function
}
```

Apply the same fix to all parallel executor implementations.

## Proof of Concept

The vulnerability can be demonstrated by running the executor benchmark with a transaction that has insufficient balance:

```rust
// Create a benchmark transaction with insufficient balance
// Account has 100 coins, tries to transfer 50 with gas cost of 400
// Expected: Graceful error
// Actual: Panic due to underflow

// This would occur in executor-benchmark execution:
// 1. Account balance: 100
// 2. transfer_amount: 50  
// 3. gas: 400
// 4. Attempted subtraction: 100 - 50 - 400 = underflow
// 5. Result: Panic with overflow-checks enabled
```

## Notes

This issue is confirmed to exist in benchmarking code but **does not affect production validator nodes**. The executor-benchmark module is separate from production execution paths. However, the inconsistency between coin and FA handling should be addressed for code quality and correctness of benchmark results.

### Citations

**File:** execution/executor-benchmark/src/native/native_vm.rs (L632-681)
```rust
    fn withdraw_fa_apt_from_signer(
        &self,
        sender_address: AccountAddress,
        transfer_amount: u64,
        view: &(impl ExecutorView + ResourceGroupView),
        gas: u64,
        resource_write_set: &mut BTreeMap<StateKey, AbstractResourceWriteOp>,
        events: &mut Vec<(ContractEvent, Option<MoveTypeLayout>)>,
    ) -> Result<(), ()> {
        let sender_store_address = primary_apt_store(sender_address);
        let sender_fa_store_object_key = self
            .db_util
            .new_state_key_object_resource_group(&sender_store_address);
        let fungible_store_rg_tag = &self.db_util.common.fungible_store;

        match Self::get_value_from_group::<FungibleStoreResource>(
            &sender_fa_store_object_key,
            fungible_store_rg_tag,
            view,
        )? {
            Some(mut fa_store) => {
                if fa_store.balance >= transfer_amount + gas {
                    fa_store.balance -= transfer_amount + gas;
                    let fa_store_write = Self::create_single_resource_in_group_modification(
                        &fa_store,
                        &sender_fa_store_object_key,
                        fungible_store_rg_tag.clone(),
                        view,
                    )?;
                    resource_write_set.insert(sender_fa_store_object_key, fa_store_write);

                    if transfer_amount > 0 {
                        events.push((
                            WithdrawFAEvent {
                                store: sender_store_address,
                                amount: transfer_amount,
                            }
                            .create_event_v2()
                            .expect("Creating WithdrawFAEvent should always succeed"),
                            None,
                        ));
                    }
                    Ok(())
                } else {
                    Err(())
                }
            },
            None => Err(()),
        }
    }
```

**File:** execution/executor-benchmark/src/native/native_vm.rs (L683-732)
```rust
    fn withdraw_coin_apt_from_signer(
        &self,
        sender_address: AccountAddress,
        transfer_amount: u64,
        view: &(impl ExecutorView + ResourceGroupView),
        gas: u64,
        resource_write_set: &mut BTreeMap<StateKey, AbstractResourceWriteOp>,
        events: &mut Vec<(ContractEvent, Option<MoveTypeLayout>)>,
    ) -> Result<(), ()> {
        let sender_coin_store_key = self.db_util.new_state_key_aptos_coin(&sender_address);

        let sender_coin_store_opt =
            Self::get_value::<CoinStoreResource<AptosCoinType>>(&sender_coin_store_key, view)?;

        let (mut sender_coin_store, metadata) = match sender_coin_store_opt {
            None => {
                return self.withdraw_fa_apt_from_signer(
                    sender_address,
                    transfer_amount,
                    view,
                    gas,
                    resource_write_set,
                    events,
                )
            },
            Some((sender_coin_store, metadata)) => (sender_coin_store, metadata),
        };

        sender_coin_store.set_coin(sender_coin_store.coin() - transfer_amount - gas);

        // first need to create events, to update the handle, and then serialize sender_coin_store
        if transfer_amount > 0 {
            events.push((
                WithdrawEvent::new(transfer_amount)
                    .create_event_v1(sender_coin_store.withdraw_events_mut()),
                None,
            ));
        }

        // coin doesn't emit WithdrawEvent for gas.
        resource_write_set.insert(
            sender_coin_store_key,
            AbstractResourceWriteOp::Write(WriteOp::modification(
                Bytes::from(bcs::to_bytes(&sender_coin_store).map_err(hide_error)?),
                metadata,
            )),
        );

        Ok(())
    }
```

**File:** types/src/account_config/resources/coin_store.rs (L76-78)
```rust
    pub fn set_coin(&mut self, coin: u64) {
        self.coin = coin;
    }
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L582-624)
```rust
    fn withdraw_coin_apt_from_signer(
        &self,
        sender_address: AccountAddress,
        transfer_amount: u64,
        gas: u64,
        state_view: &(impl StateView + Sync),
        output: &mut IncrementalOutput,
    ) -> Result<()> {
        let sender_coin_store_key = self.db_util.new_state_key_aptos_coin(&sender_address);
        let sender_coin_store_opt = {
            let _timer = TIMER.timer_with(&["read_sender_coin_store"]);
            DbAccessUtil::get_apt_coin_store(&sender_coin_store_key, state_view)?
        };
        let mut sender_coin_store = match sender_coin_store_opt {
            None => {
                return self.withdraw_fa_apt_from_signer(
                    sender_address,
                    transfer_amount,
                    gas,
                    state_view,
                    output,
                )
            },
            Some(sender_coin_store) => sender_coin_store,
        };

        sender_coin_store.set_coin(sender_coin_store.coin() - transfer_amount - gas);

        if transfer_amount != 0 {
            output.events.push(
                WithdrawEvent::new(transfer_amount)
                    .create_event_v1(sender_coin_store.withdraw_events_mut()),
            );
            // Coin doesn't emit Withdraw event for gas
        }

        output.write_set.push((
            sender_coin_store_key,
            WriteOp::legacy_modification(bcs::to_bytes(&sender_coin_store)?.into()),
        ));

        Ok(())
    }
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L1114-1146)
```rust
    fn update_coin_balance(
        &self,
        account: AccountAddress,
        state_view: &(impl StateView + Sync),
        increment: u64,
        decrement: u64,
        fail_on_missing: bool,
    ) -> bool {
        let coin_store_key = self.db_util.new_state_key_aptos_coin(&account);
        let mut exists = true;

        let mut entry = self.cache_get_mut_or_init(&coin_store_key, |key| {
            CachedResource::AptCoinStore(
                match DbAccessUtil::get_apt_coin_store(key, state_view).unwrap() {
                    Some(store) => store,
                    None => {
                        exists = false;
                        assert!(!fail_on_missing);
                        DbAccessUtil::new_apt_coin_store(0, account)
                    },
                },
            )
        });

        match entry.value_mut() {
            CachedResource::AptCoinStore(coin_store) => {
                coin_store.set_coin(coin_store.coin() + increment - decrement);
            },
            _ => panic!("wrong type"),
        };

        exists
    }
```
