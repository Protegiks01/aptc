# Audit Report

## Title
Secret Sharing Deadlock with Weighted Validator Configurations

## Summary
The secret sharing reconstruction system will experience permanent liveness failure when weighted validator configurations are implemented, due to a mismatch between hardcoded weight checks and actual weight-based threshold requirements.

## Finding Description
The secret sharing system uses `SecretShareConfig` to manage threshold decryption of encrypted transaction batches. The system has a critical architectural flaw where weight-based quorum checks use hardcoded values while the underlying cryptographic reconstruction uses actual validator weights. [1](#0-0) 

This hardcoded `get_peer_weight()` method always returns 1, regardless of actual validator weights. However, the threshold stored in the config comes from the underlying `WeightedConfigArkworks` which uses real validator weights: [2](#0-1) 

The critical failure occurs in the share aggregation logic: [3](#0-2) 

When validators have non-uniform weights (e.g., weights [10, 20, 30, 40] with threshold 67):
1. Node receives shares from all 4 validators (actual weight: 100)
2. The `total_weight` calculation sums `get_peer_weight()` for each share: 4 Ã— 1 = 4
3. Check: `4 < 67` evaluates to true, preventing aggregation
4. **Permanent deadlock**: Cannot aggregate because cannot receive 67 shares from 4 validators

The underlying weighted reconstruction correctly handles weighted shares: [4](#0-3) 

But this code is never reached because the gate check in `secret_share_store.rs` fails first.

The DKG system already computes proper weighted configurations from validator stakes: [5](#0-4) 

## Impact Explanation
**Critical Severity - Total Loss of Liveness**

When weighted validators are enabled, the entire secret sharing subsystem fails permanently:
- Encrypted transaction batches cannot be decrypted
- Consensus cannot proceed with encrypted transactions
- Requires hard fork to recover

This meets the Critical severity criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Certainty: 100% when weighted validators are enabled**

The bug will trigger automatically once validator weights become non-uniform. Currently mitigated only because all validators have weight 1. The TODO comment indicates this is a known incomplete implementation: [6](#0-5) 

## Recommendation
Implement `get_peer_weight()` to return actual validator weights from the weighted config, and populate the `weights` HashMap during initialization:

```rust
pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    *self.weights.get(peer)
        .unwrap_or(&1) // fallback for safety
}
```

Initialize weights in `new()` by extracting them from the underlying `WeightedConfig`:

```rust
pub fn new(...) -> Self {
    let mut weights = HashMap::new();
    for (i, addr) in validator.get_ordered_account_addresses_iter().enumerate() {
        let player = Player { id: i };
        let weight = config.get_threshold_config().get_player_weight(&player);
        weights.insert(*addr, weight as u64);
    }
    Self { ..., weights, ... }
}
```

## Proof of Concept
```rust
#[test]
fn test_weighted_secret_sharing_deadlock() {
    // Setup 4 validators with weights [10, 20, 30, 40], threshold 67
    let weights = vec![10, 20, 30, 40];
    let threshold = 67;
    let weighted_config = WeightedConfigArkworks::new(threshold, weights).unwrap();
    
    // Create SecretShareConfig with weighted config
    let config = SecretShareConfig::new(..., weighted_config, ...);
    
    // Simulate receiving all 4 shares (actual weight: 100)
    let mut total_weight = 0;
    for i in 0..4 {
        let author = validators[i];
        total_weight += config.get_peer_weight(&author); // Returns 1, not actual weight
    }
    
    // Check fails even though we have sufficient weight
    assert!(total_weight < config.threshold()); // 4 < 67
    // Deadlock: Cannot proceed with aggregation despite having 100 weight units
}
```

## Notes
This is a forward-compatibility bug that creates a critical time bomb. While currently dormant (all weights are 1), it will cause catastrophic failure immediately upon enabling weighted validators. The issue requires urgent remediation before any weighted validator deployment.

### Citations

**File:** types/src/secret_sharing.rs (L188-190)
```rust
    pub fn threshold(&self) -> u64 {
        self.config.get_threshold_config().t as u64
    }
```

**File:** types/src/secret_sharing.rs (L196-202)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }

    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L44-46)
```rust
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L423-450)
```rust
    fn reconstruct(
        sc: &WeightedConfigArkworks<F>,
        shares: &[ShamirShare<Self::ShareValue>],
    ) -> anyhow::Result<Self> {
        let mut flattened_shares = Vec::with_capacity(sc.get_total_weight());

        // println!();
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
        }
        flattened_shares.truncate(sc.get_threshold_weight());

        SK::reconstruct(sc.get_threshold_config(), &flattened_shares)
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```
