# Audit Report

## Title
UTF-8 Character Boundary Violation in `standardize_address()` Causes Indexer-GRPC Service Panic

## Summary
The `standardize_address()` function in the indexer-grpc transaction-filter module performs an unsafe string slice operation that does not validate UTF-8 character boundaries. When processing user-provided address filters containing multi-byte UTF-8 characters, the slice operation causes a panic, resulting in a Denial of Service attack on the indexer-grpc API service.

## Finding Description

The vulnerability exists in the `standardize_address()` function which processes address strings from user-provided transaction filters. [1](#0-0) 

The critical issue occurs at line 16 where the code performs: `trimmed[..trimmed.len().saturating_sub(1)]`

This slice operation uses byte indices without validating UTF-8 character boundaries. In Rust, string slicing requires indices to fall on valid character boundaries. When the last character in `trimmed` is a multi-byte UTF-8 character (e.g., 'Ã©' encoded as 0xC3 0xA9), the expression `trimmed.len().saturating_sub(1)` calculates a byte index that points into the middle of that character, causing a panic with the error: "byte index X is not a char boundary".

**Attack Path:**

1. An attacker sends a gRPC `GetTransactionsRequest` to the indexer-grpc service
2. The request includes a `MoveStructTagFilter` with a malicious address field containing a multi-byte UTF-8 character at the end (e.g., "0x123Ã©" or "0x000000000000000000000000000000000000000000000000000000000000000Ã©")
3. The filter is deserialized from the protobuf message, which accepts any string value [2](#0-1) 

4. During filter processing, `standardize_address()` is invoked on the malicious address string [3](#0-2) 

5. The slice operation at line 16 attempts to index in the middle of the multi-byte character, triggering an immediate panic
6. The panic crashes the request handler task, disrupting service availability

The indexer-grpc service is a critical public-facing API that streams blockchain transaction data to clients. This vulnerability allows unprivileged attackers to repeatedly crash request handlers, degrading service quality and potentially causing complete service unavailability.

## Impact Explanation

This vulnerability is classified as **High Severity** per the Aptos bug bounty program criteria under "API crashes".

The indexer-grpc service is critical infrastructure that provides blockchain data access to:
- External indexers and data aggregators
- DApp backends requiring transaction filtering
- Analytics platforms monitoring on-chain activity
- Developer tools and explorers

An attacker can exploit this vulnerability to:
1. Crash individual request handlers repeatedly
2. Degrade service performance through resource exhaustion
3. Potentially cause complete service unavailability if attack volume is sustained
4. Disrupt dependent systems relying on indexer data

While this does not directly affect consensus, validator operations, or on-chain state, it breaks the availability guarantees of a critical API service, meeting the High severity threshold.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Easy to trigger**: The attack requires only sending a gRPC request with a specially-crafted string - no authentication, special permissions, or complex setup required
2. **Low attack complexity**: Any attacker can construct a malicious filter with a multi-byte UTF-8 character (e.g., using common characters like Ã©, Ã±, Ã¼, or emoji)
3. **Public attack surface**: The indexer-grpc service is designed to accept requests from external clients
4. **Deterministic behavior**: The panic occurs reliably with the specific input pattern
5. **No input validation**: The protobuf definition accepts any string, and no validation occurs before the unsafe slice operation

The only requirement is network access to the indexer-grpc service endpoint, which is typically publicly accessible.

## Recommendation

**Fix the unsafe slice operation by using character-aware string manipulation:**

```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address
    if let Some(last_char) = trimmed.chars().last() {
        // Use chars() to properly handle multi-byte characters
        let without_last: String = trimmed.chars().take(trimmed.chars().count().saturating_sub(1)).collect();
        
        if without_last.chars().all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**Alternative approach using `char_indices()`:**

```rust
pub fn standardize_address(address: &str) -> String {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    if let Some(last_char) = trimmed.chars().last() {
        // Find the byte index of the last character safely
        if let Some((last_char_start, _)) = trimmed.char_indices().last() {
            let without_last = &trimmed[..last_char_start];
            
            if without_last.chars().all(|c| c == '0')
                && last_char.is_ascii_hexdigit()
                && last_char <= 'f'
            {
                let mut result = String::with_capacity(3);
                result.push_str("0x");
                result.push(last_char);
                return result;
            }
        }
    }

    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**Additional defensive measure:** Add input validation to reject non-hexadecimal address strings before processing.

## Proof of Concept

```rust
#[cfg(test)]
mod panic_poc {
    use super::*;

    #[test]
    #[should_panic(expected = "byte index")]
    fn test_multibyte_utf8_panic() {
        // This will panic with "byte index X is not a char boundary"
        // The 'Ã©' character is encoded as 2 bytes in UTF-8: 0xC3 0xA9
        let malicious_address = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdÃ©";
        
        // This call will panic at line 16 when slicing
        let result = standardize_address(malicious_address);
        
        // This line will never be reached
        println!("Result: {}", result);
    }

    #[test]
    #[should_panic(expected = "byte index")]
    fn test_emoji_panic() {
        // Emoji characters are 4 bytes in UTF-8
        let malicious_address = "0x000000000000000000000000000000000000000000000000000000000000000ðŸ”¥";
        
        // This will also cause a panic
        standardize_address(malicious_address);
    }

    #[test]
    #[should_panic(expected = "byte index")]
    fn test_short_multibyte_panic() {
        // Even short addresses trigger the panic
        let malicious_address = "0xÃ±";
        
        standardize_address(malicious_address);
    }
}
```

**To reproduce the crash:**

1. Add the above test to `ecosystem/indexer-grpc/transaction-filter/src/utils.rs`
2. Run: `cargo test test_multibyte_utf8_panic --package aptos-transaction-filter`
3. Observe the panic: `thread 'utils::panic_poc::test_multibyte_utf8_panic' panicked at 'byte index X is not a char boundary'`

**Real-world exploitation:**

Send a gRPC request to an indexer-grpc service with:
```json
{
  "transaction_filter": {
    "api_filter": {
      "event_filter": {
        "struct_type": {
          "address": "0x000000000000000000000000000000000000000000000000000000000000000Ã©"
        }
      }
    }
  }
}
```

This will cause the service to panic when processing the filter.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L39-43)
```text
message MoveStructTagFilter {
  optional string address = 1;
  optional string module = 2;
  optional string name = 3;
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L39-45)
```rust
    fn get_standardized_address(&self) -> &Option<String> {
        self.standardized_address.get_or_init(|| {
            self.address
                .as_ref()
                .map(|address| standardize_address(address))
        })
    }
```
