# Audit Report

## Title
Information Disclosure of Network Topology Through Unfiltered Error Logging in Consensus Observer

## Summary
The consensus observer's error handling converts network errors to strings without sanitization, potentially exposing sensitive network information including IP addresses, TCP ports, DNS names, and cryptographic public keys through log files and telemetry systems.

## Finding Description

The vulnerability exists in the error conversion implementation at [1](#0-0) 

This conversion takes a network application error and converts it to a string using `to_string()`. The underlying network errors come from [2](#0-1)  which wraps lower-level errors including `PeerManagerError`.

The `PeerManagerError` type contains variants that embed sensitive network information: [3](#0-2) 

When a peer is already connected, the error includes the full network address: [4](#0-3) 

The `NetworkAddress` type's Display implementation exposes all protocol details: [5](#0-4) 

These error messages are logged throughout the codebase: [6](#0-5) 

The logs are structured using a schema that includes the error: [7](#0-6) 

These logs are collected and sent to centralized telemetry services: [8](#0-7) 

## Impact Explanation

This qualifies as **Low Severity** per the Aptos bug bounty criteria: "Minor information leaks" (up to $1,000). While the question suggests Medium severity, the actual impact aligns with Low severity because:

- It does not directly lead to loss of funds, consensus violations, or availability issues
- It requires access to logs (node file system, telemetry service, or log backend)
- It aids reconnaissance but does not directly enable attacks
- Network topology information could help attackers plan DoS or targeted attacks against specific validators

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment configuration:
- Log collection and telemetry are standard in production deployments
- Many organizations use third-party log aggregation services
- Access controls on log systems may be weaker than on validator nodes
- Multiple personnel (operations, SRE, support) typically have log access
- Logs may be stored in cloud storage with potential misconfigurations

## Recommendation

Implement error message sanitization to remove sensitive network details before logging:

```rust
impl From<aptos_network::application::error::Error> for Error {
    fn from(error: aptos_network::application::error::Error) -> Self {
        // Sanitize error message to remove sensitive network details
        let sanitized_message = match &error {
            // Only include error type, not sensitive details
            _ => format!("Network error occurred: {}", error.get_generic_type()),
        };
        Error::NetworkError(sanitized_message)
    }
}
```

Additionally:
1. Implement a centralized error sanitization function
2. Review all error logging locations for similar issues
3. Add log scrubbing for IP addresses and network identifiers
4. Implement strict access controls on log aggregation systems
5. Consider encrypting logs in transit and at rest

## Proof of Concept

```rust
// Reproduction steps (conceptual - cannot compile standalone)
// 
// 1. Deploy a validator node with log collection enabled
// 2. Trigger a connection to an already-connected peer:
//    - Peer A is connected at /ip4/192.168.1.100/tcp/6180
//    - Attempt to dial Peer A again at /ip4/192.168.1.100/tcp/6180
// 3. This triggers PeerManagerError::AlreadyConnected(NetworkAddress)
// 4. The error flows through:
//    network::Error -> application::Error -> consensus_observer::Error
// 5. At line 64, to_string() produces:
//    "Already connected at /ip4/192.168.1.100/tcp/6180/noise-ik/<pubkey>/handshake/0"
// 6. This is logged via warn!() macro
// 7. Logs are collected and sent to telemetry service
// 8. Anyone with log access can see: IP address, port, public key
//
// Expected log output:
// WARN consensus_observer network_error: "Already connected at /ip4/192.168.1.100/tcp/6180/noise-ik/0x080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0"
```

## Notes

This vulnerability follows the principle of least privilege for information disclosure. While it doesn't directly compromise consensus or funds, it violates security best practices by exposing operational network details that should remain private. The severity assessment as "Low" rather than "Medium" is based on the requirement for log access and the indirect nature of the threat. Defense-in-depth principles suggest removing unnecessary information from error messages even when they appear only in logs.

### Citations

**File:** consensus/src/consensus_observer/common/error.rs (L62-65)
```rust
impl From<aptos_network::application::error::Error> for Error {
    fn from(error: aptos_network::application::error::Error) -> Self {
        Error::NetworkError(error.to_string())
    }
```

**File:** network/framework/src/application/error.rs (L24-27)
```rust
impl From<NetworkError> for Error {
    fn from(error: NetworkError) -> Self {
        Error::NetworkError(error.to_string())
    }
```

**File:** network/framework/src/peer_manager/error.rs (L25-29)
```rust
    #[error("Not connected with Peer {0}")]
    NotConnected(PeerId),

    #[error("Already connected at {0}")]
    AlreadyConnected(NetworkAddress),
```

**File:** network/framework/src/peer_manager/mod.rs (L434-435)
```rust
                if let Some((curr_connection, _)) = self.active_peers.get(&requested_peer_id) {
                    let error = PeerManagerError::AlreadyConnected(curr_connection.addr.clone());
```

**File:** types/src/network_address/mod.rs (L598-618)
```rust
impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use self::Protocol::*;
        match self {
            Ip4(addr) => write!(f, "/ip4/{}", addr),
            Ip6(addr) => write!(f, "/ip6/{}", addr),
            Dns(domain) => write!(f, "/dns/{}", domain),
            Dns4(domain) => write!(f, "/dns4/{}", domain),
            Dns6(domain) => write!(f, "/dns6/{}", domain),
            Tcp(port) => write!(f, "/tcp/{}", port),
            Memory(port) => write!(f, "/memory/{}", port),
            NoiseIK(pubkey) => write!(
                f,
                "/noise-ik/{}",
                pubkey
                    .to_encoded_string()
                    .expect("ValidCryptoMaterialStringExt::to_encoded_string is infallible")
            ),
            Handshake(version) => write!(f, "/handshake/{}", version),
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_client.rs (L68-74)
```rust
        if let Err(error) = result {
            // Log the failed send
            warn!(LogSchema::new(LogEntry::SendDirectSendMessage)
                .event(LogEvent::NetworkError)
                .message_type(message_label)
                .peer(peer_network_id)
                .message(&format!("Failed to send message: {:?}", error)));
```

**File:** consensus/src/consensus_observer/common/logging.rs (L9-21)
```rust
#[derive(Schema)]
pub struct LogSchema<'a> {
    name: LogEntry,
    #[schema(debug)]
    error: Option<&'a Error>,
    event: Option<LogEvent>,
    message: Option<&'a str>,
    message_type: Option<&'a str>,
    #[schema(display)]
    peer: Option<&'a PeerNetworkId>,
    request_id: Option<u64>,
    request_type: Option<&'a str>,
}
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L41-81)
```rust
pub async fn handle_log_ingest(
    context: Context,
    claims: Claims,
    encoding: Option<String>,
    body: impl Buf,
) -> anyhow::Result<impl Reply, Rejection> {
    debug!("handling log ingest");

    if let Some(blacklist) = &context.log_ingest_clients().blacklist {
        if blacklist.contains(&claims.peer_id) {
            return Err(reject::custom(ServiceError::forbidden(
                LogIngestError::Forbidden(claims.peer_id).into(),
            )));
        }
    }

    let client = match claims.node_type {
        NodeType::Unknown | NodeType::UnknownValidator | NodeType::UnknownFullNode => {
            &context.log_ingest_clients().unknown_logs_ingest_client
        },
        _ => &context.log_ingest_clients().known_logs_ingest_client,
    };

    let log_messages: Vec<String> = if let Some(encoding) = encoding {
        if encoding.eq_ignore_ascii_case("gzip") {
            let decoder = GzDecoder::new(body.reader());
            serde_json::from_reader(decoder).map_err(|e| {
                debug!("unable to decode and deserialize body: {}", e);
                ServiceError::bad_request(LogIngestError::UnexpectedPayloadBody.into())
            })?
        } else {
            return Err(reject::custom(ServiceError::bad_request(
                LogIngestError::UnexpectedContentEncoding.into(),
            )));
        }
    } else {
        serde_json::from_reader(body.reader()).map_err(|e| {
            error!("unable to deserialize body: {}", e);
            ServiceError::bad_request(LogIngestError::UnexpectedPayloadBody.into())
        })?
    };
```
