# Audit Report

## Title
Cross-Epoch Block Retention Vulnerability in Consensus Observer Pending Block Management

## Summary
The `remove_ready_block()` function in the consensus observer's pending block store incorrectly retains blocks from old epochs when payloads from new epochs arrive. The function compares only round numbers instead of (epoch, round) tuples, causing blocks from previous epochs with high round numbers to be incorrectly categorized as "higher" than blocks from new epochs with low round numbers.

## Finding Description

The vulnerability exists in the `remove_ready_block()` function [1](#0-0) , specifically in the logic that determines whether a pending block should be retained or dropped.

When a payload arrives, the function:
1. Splits pending blocks at `(received_payload_epoch, received_payload_round + 1)`
2. Pops the last block from the lower partition
3. Checks if this block should be retained by comparing **only the round numbers** [2](#0-1) 

**Attack Scenario:**
1. Pending blocks from epoch 5 exist at rounds 100 and 200
2. Epoch transitions to epoch 6
3. A payload arrives for (epoch=6, round=10)
4. `remove_ready_block(6, 10, ...)` is called
5. The split at `(6, 11)` leaves blocks `(5, 100)` and `(5, 200)` in the lower partition
6. Block `(5, 200)` is popped as the last block
7. The comparison `200 > 10` evaluates to true (comparing only rounds, ignoring epochs)
8. Block `(5, 200)` is incorrectly retained as if it were from a "higher" round
9. Block `(5, 100)` is correctly dropped as out-of-date

**Invariant Violation:**
This breaks the epoch transition semantic invariant that all blocks from previous epochs should be discarded when processing blocks from new epochs. The BTreeMap ordering is based on `(epoch, round)` tuples [3](#0-2) , but the retention logic only considers rounds.

## Impact Explanation

**High Severity** - This issue qualifies as High severity under the Aptos bug bounty program for the following reasons:

1. **State Inconsistency**: Blocks from old epochs persist in the pending block store when they should have been purged, violating the expected state management semantics during epoch transitions.

2. **Potential Resource Exhaustion**: Incorrectly retained blocks accumulate in the pending block store. Over multiple epoch transitions, this could lead to unbounded growth of stale pending blocks.

3. **Observer Node Slowdowns**: The accumulation of stale blocks from old epochs can cause consensus observer nodes to:
   - Waste resources tracking obsolete blocks
   - Experience degraded performance when searching through pending blocks
   - Have inflated memory usage

4. **Protocol Violation**: While this doesn't directly break consensus safety (as the consensus observer is an optimization layer), it violates the protocol's epoch transition semantics and could lead to unexpected behavior if old blocks are later matched with payloads.

The impact aligns with "Validator node slowdowns" and "Significant protocol violations" from the High severity category.

## Likelihood Explanation

**High Likelihood** - This vulnerability will trigger automatically under normal network conditions:

1. **Automatic Occurrence**: The bug triggers during normal epoch transitions when:
   - Pending blocks from the old epoch have high round numbers (common in production)
   - The new epoch starts with low round numbers (always true as epochs start at round 0)

2. **No Attacker Required**: This is a logic bug that manifests during legitimate operation, not requiring malicious input or manipulation.

3. **Frequent Trigger**: Epoch transitions occur regularly in Aptos (approximately every few hours to days depending on configuration), making this a recurring issue.

4. **Realistic Scenario**: It's common for blocks to be pending across epoch boundaries, especially if:
   - Network delays occur
   - The observer is catching up
   - Payloads arrive out of order

## Recommendation

Fix the comparison to use (epoch, round) tuples instead of just rounds:

```rust
// In remove_ready_block() function, replace lines 223-227:
let last_pending_block_epoch_round = (
    pending_block.ordered_block().last_block().epoch(),
    last_pending_block_round
);
if last_pending_block_epoch_round > (received_payload_epoch, received_payload_round) {
    blocks_at_higher_rounds.insert(epoch_and_round, pending_block);
}
```

This ensures that blocks from old epochs are never considered "higher" than blocks from new epochs, regardless of their round numbers.

**Additional Safeguard**: Consider adding an explicit epoch check before the round comparison to make the intent clearer and prevent similar bugs:

```rust
let pending_block_epoch = pending_block.ordered_block().last_block().epoch();
if pending_block_epoch > received_payload_epoch 
    || (pending_block_epoch == received_payload_epoch 
        && last_pending_block_round > received_payload_round) {
    blocks_at_higher_rounds.insert(epoch_and_round, pending_block);
}
```

## Proof of Concept

Add this test to the test module in `pending_blocks.rs`:

```rust
#[test]
fn test_remove_ready_block_cross_epoch() {
    // Create a new pending block store
    let consensus_observer_config = ConsensusObserverConfig {
        max_num_pending_blocks: 100,
        ..ConsensusObserverConfig::default()
    };
    let pending_block_store = Arc::new(Mutex::new(PendingBlockStore::new(
        consensus_observer_config,
    )));

    // Insert blocks from epoch 5 with high round numbers
    let old_epoch = 5;
    let old_blocks = create_and_add_pending_blocks(
        pending_block_store.clone(),
        2,
        old_epoch,
        100, // Starting at round 100
        1,
    );

    // Verify blocks were inserted
    assert_eq!(pending_block_store.lock().blocks_without_payloads.len(), 2);

    // Create empty payload store
    let mut block_payload_store = BlockPayloadStore::new(consensus_observer_config);

    // Receive a payload from new epoch 6 at round 10
    let new_epoch = 6;
    let new_round = 10;
    let ready_block = pending_block_store.lock().remove_ready_block(
        new_epoch,
        new_round,
        &mut block_payload_store,
    );

    // BUG: Block from epoch 5 round 100+ should be dropped as out-of-date
    // but is incorrectly retained because round comparison ignores epoch
    assert!(ready_block.is_none());
    
    // The bug causes blocks from old epoch to remain
    let remaining_blocks = pending_block_store.lock().blocks_without_payloads.len();
    
    // EXPECTED: 0 blocks (all old epoch blocks should be dropped)
    // ACTUAL: 1 block remains (the one with higher round number)
    assert_eq!(remaining_blocks, 0, 
        "Bug detected: {} block(s) from old epoch incorrectly retained", 
        remaining_blocks
    );
}
```

This test will fail with the current implementation, demonstrating that blocks from epoch 5 are incorrectly retained when payloads from epoch 6 arrive, even though they should all be dropped as out-of-date.

## Notes

While the consensus observer has mechanisms to clear pending blocks during state sync [4](#0-3) , this vulnerability can still manifest in the window between when the new epoch begins and when the clear operation occurs. The bug represents a logic error in the fundamental epoch comparison semantics that should be fixed regardless of compensating mechanisms elsewhere.

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L65-67)
```rust
    // A map of ordered blocks that are without payloads. The key is
    // the (epoch, round) of the first block in the ordered block.
    blocks_without_payloads: BTreeMap<(u64, Round), Arc<PendingBlockWithMetadata>>,
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L200-256)
```rust
    pub fn remove_ready_block(
        &mut self,
        received_payload_epoch: u64,
        received_payload_round: Round,
        block_payload_store: &mut BlockPayloadStore,
    ) -> Option<Arc<PendingBlockWithMetadata>> {
        // Calculate the round at which to split the blocks
        let split_round = received_payload_round.saturating_add(1);

        // Split the blocks at the epoch and round
        let mut blocks_at_higher_rounds = self
            .blocks_without_payloads
            .split_off(&(received_payload_epoch, split_round));

        // Check if the last block is ready (this should be the only ready block).
        // Any earlier blocks are considered out-of-date and will be dropped.
        let mut ready_block = None;
        if let Some((epoch_and_round, pending_block)) = self.blocks_without_payloads.pop_last() {
            // If all payloads exist for the block, then the block is ready
            if block_payload_store.all_payloads_exist(pending_block.ordered_block().blocks()) {
                ready_block = Some(pending_block);
            } else {
                // Otherwise, check if we're still waiting for higher payloads for the block
                let last_pending_block_round = pending_block.ordered_block().last_block().round();
                if last_pending_block_round > received_payload_round {
                    blocks_at_higher_rounds.insert(epoch_and_round, pending_block);
                }
            }
        }

        // Check if any out-of-date blocks are going to be dropped
        if !self.blocks_without_payloads.is_empty() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Dropped {:?} out-of-date pending blocks before epoch and round: {:?}",
                    self.blocks_without_payloads.len(),
                    (received_payload_epoch, received_payload_round)
                ))
            );
        }

        // TODO: optimize this flow!

        // Clear all blocks from the pending block stores
        self.clear_missing_blocks();

        // Update the pending block stores to only include the blocks at higher rounds
        self.blocks_without_payloads = blocks_at_higher_rounds;
        for pending_block in self.blocks_without_payloads.values() {
            let first_block = pending_block.ordered_block().first_block();
            self.blocks_without_payloads_by_hash
                .insert(first_block.id(), pending_block.clone());
        }

        // Return the ready block (if one exists)
        ready_block
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L93-105)
```rust
    pub fn clear_block_data(&mut self) -> LedgerInfoWithSignatures {
        // Clear the payload store
        self.block_payload_store.clear_all_payloads();

        // Clear the ordered blocks
        self.ordered_block_store.clear_all_ordered_blocks();

        // Clear the pending blocks
        self.pending_block_store.clear_missing_blocks();

        // Return the root ledger info
        self.root()
    }
```
