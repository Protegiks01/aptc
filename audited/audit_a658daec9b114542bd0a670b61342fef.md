# Audit Report

## Title
Missing Version Range Validation in Epoch Ending Backup Metadata Enables Restore Filtering Bypass

## Summary
The `new_epoch_ending_backup()` function in `metadata/mod.rs` creates `EpochEndingBackupMeta` structures without validating that `first_version <= last_version`. When malicious metadata with inverted version ranges is loaded from backup storage, the restore controller's filtering logic incorrectly skips critical epoch-ending ledger infos, potentially causing restore failures or incomplete epoch history reconstruction.

## Finding Description

The vulnerability exists in the backup metadata creation and validation pipeline: [1](#0-0) 

This function accepts version parameters without validation. The `EpochEndingBackupMeta` struct is then serialized to JSON and stored in backup storage. [2](#0-1) 

During restore operations, metadata files are downloaded from external backup storage and deserialized without validation: [3](#0-2) 

The deserialized metadata is used by `select_epoch_ending_backups()` to filter which backups to restore: [4](#0-3) 

The critical flaw is at line 180: when `backup.first_version > target_version`, the loop breaks and skips remaining backups. If an attacker creates metadata with `first_version=1000, last_version=500` for an epoch that actually contains versions 500-1000, and the target restore version is 600, the check `1000 > 600` incorrectly breaks the loop, skipping this backup entirely.

The restore coordinator then applies an additional filter using the same unvalidated `first_version`: [5](#0-4) 

**Attack Path:**
1. Attacker gains write access to backup storage (e.g., misconfigured cloud storage permissions, compromised backup credentials)
2. Attacker crafts malicious metadata file with inverted version range: `{"EpochEndingBackup":{"first_epoch":5,"last_epoch":5,"first_version":1000,"last_version":500,"manifest":"gs://bucket/epoch_ending.manifest"}}`
3. During restore to target_version=600, `select_epoch_ending_backups()` sees 1000 > 600 and skips epoch 5
4. Epoch 5's critical ledger info is missing from restore
5. Subsequent epoch continuity validation fails, or worse, node restores with incomplete epoch history

**Contrast with Transaction Backups**: The transaction backup system properly validates version ranges in its manifest verification: [6](#0-5) 

However, epoch ending backups store version information only in metadata (not manifest), and this metadata is never validated.

## Impact Explanation

This vulnerability enables an attacker with backup storage write access to:
1. **Cause restore operation failures** by forcing epoch discontinuity errors
2. **Skip critical epoch-ending ledger infos** during disaster recovery
3. **Corrupt epoch history reconstruction** if validation is bypassed

This represents a **High Severity** vulnerability per Aptos bug bounty criteria:
- Causes "Validator node slowdowns" - nodes cannot recover from backups
- "Significant protocol violations" - breaks epoch continuity invariants during restore
- Impacts disaster recovery capabilities critical for validator operations

Not Critical because:
- Requires backup storage write access (semi-trusted component)
- Does not affect running consensus or cause fund loss
- Impact limited to restore operations, not live transaction processing

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Write access to backup storage (S3 bucket, GCS, local filesystem)
- Can occur through: misconfigured cloud storage permissions, compromised backup credentials, insider threat

**Attack Complexity: Low**
- Simple JSON file creation with inverted version numbers
- No cryptographic operations required
- No need to compromise running validator nodes

**Detection Difficulty: Medium**
- Malicious metadata appears valid JSON
- No validation warnings during metadata loading
- Only caught when restore operation fails with epoch continuity errors

## Recommendation

Add version range validation in multiple locations:

**1. Validation at metadata creation:**
```rust
pub fn new_epoch_ending_backup(
    first_epoch: u64,
    last_epoch: u64,
    first_version: Version,
    last_version: Version,
    manifest: FileHandle,
) -> Result<Self> {
    ensure!(
        first_version <= last_version,
        "Invalid version range: first_version {} > last_version {}",
        first_version,
        last_version
    );
    ensure!(
        first_epoch <= last_epoch,
        "Invalid epoch range: first_epoch {} > last_epoch {}",
        first_epoch,
        last_epoch
    );
    Ok(Self::EpochEndingBackup(EpochEndingBackupMeta {
        first_epoch,
        last_epoch,
        first_version,
        last_version,
        manifest,
    }))
}
```

**2. Validation at metadata deserialization:**
```rust
impl EpochEndingBackupMeta {
    pub fn verify(&self) -> Result<()> {
        ensure!(
            self.first_version <= self.last_version,
            "Invalid version range in metadata: [{}, {}]",
            self.first_version,
            self.last_version
        );
        ensure!(
            self.first_epoch <= self.last_epoch,
            "Invalid epoch range in metadata: [{}, {}]",
            self.first_epoch,
            self.last_epoch
        );
        Ok(())
    }
}
```

**3. Call verification after loading metadata:**
Add validation in `sync_and_load()` after deserializing each metadata entry to reject malformed metadata early.

## Proof of Concept

**Malicious Metadata File (epoch_ending_5-5.meta):**
```json
{"EpochEndingBackup":{"first_epoch":5,"last_epoch":5,"first_version":1000,"last_version":500,"manifest":"gs://aptos-backup/epoch_5/epoch_ending.manifest"}}
```

**Reproduction Steps:**
1. Create backup storage with valid backups for epochs 0-4 and 6-10
2. Insert malicious metadata file for epoch 5 with inverted versions (1000, 500) when actual range should be (500, 1000)
3. Execute restore operation with `--target-version 600`
4. Observe that `select_epoch_ending_backups()` skips epoch 5 backup when checking `1000 > 600`
5. Restore fails at `EpochHistoryRestoreController` with error: "Epoch ending backup ranges not continuous, expecting epoch 5, got 6"

**Test Case (Rust):**
```rust
#[tokio::test]
async fn test_inverted_version_metadata_skips_backup() {
    let storage = Arc::new(MockBackupStorage::new());
    let metadata = Metadata::new_epoch_ending_backup(
        5, 5, 
        1000, // first_version - malicious inverted value
        500,  // last_version - malicious inverted value
        FileHandle::new("gs://bucket/manifest")
    );
    
    storage.save_metadata_line(&metadata.name(), &metadata.to_text_line().unwrap()).await.unwrap();
    
    let metadata_view = sync_and_load(&opt, storage, 4).await.unwrap();
    let selected = metadata_view.select_epoch_ending_backups(600).unwrap();
    
    // Assertion: epoch 5 backup is incorrectly skipped due to inverted version check
    assert!(!selected.iter().any(|b| b.first_epoch == 5));
}
```

**Notes:**
- The vulnerability requires external write access to backup storage
- Existing epoch continuity checks provide partial mitigation by failing restore operations
- However, if an attacker can carefully craft metadata to maintain apparent epoch continuity while skipping specific versions, they could cause subtle state inconsistencies
- The lack of validation violates the principle of defense-in-depth for backup data integrity

### Citations

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L25-39)
```rust
    pub fn new_epoch_ending_backup(
        first_epoch: u64,
        last_epoch: u64,
        first_version: Version,
        last_version: Version,
        manifest: FileHandle,
    ) -> Self {
        Self::EpochEndingBackup(EpochEndingBackupMeta {
            first_epoch,
            last_epoch,
            first_version,
            last_version,
            manifest,
        })
    }
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L175-182)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct EpochEndingBackupMeta {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub first_version: Version,
    pub last_version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L237-246)
```rust
    async fn load_metadata_lines(&mut self) -> Result<Vec<Metadata>> {
        let mut buf = String::new();
        self.read_to_string(&mut buf)
            .await
            .err_notes((file!(), line!(), &buf))?;
        Ok(buf
            .lines()
            .map(serde_json::from_str::<Metadata>)
            .collect::<Result<_, serde_json::error::Error>>()?)
    }
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L171-196)
```rust
    pub fn select_epoch_ending_backups(
        &self,
        target_version: Version,
    ) -> Result<Vec<EpochEndingBackupMeta>> {
        // This can be more flexible, but for now we assume and check backups are continuous in
        // range (which is always true when we backup from a single backup coordinator)
        let mut next_epoch = 0;
        let mut res = Vec::new();
        for backup in self.epoch_ending_backups.iter().sorted() {
            if backup.first_version > target_version {
                break;
            }

            ensure!(
                backup.first_epoch == next_epoch,
                "Epoch ending backup ranges not continuous, expecting epoch {}, got {}.",
                next_epoch,
                backup.first_epoch,
            );
            res.push(backup.clone());

            next_epoch = backup.last_epoch + 1;
        }

        Ok(res)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L213-218)
```rust
        let epoch_ending_backups = metadata_view.select_epoch_ending_backups(target_version)?;
        let epoch_handles = epoch_ending_backups
            .iter()
            .filter(|e| e.first_version <= target_version)
            .map(|backup| backup.manifest.clone())
            .collect();
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L50-57)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );
```
