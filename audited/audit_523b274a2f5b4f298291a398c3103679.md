# Audit Report

## Title
Indexer Panic on DeleteTableItem Without Data Field Leading to Service Halt

## Summary
The indexer's `from_delete_table_item()` function contains an unchecked panic that crashes the indexer when processing `DeleteTableItem` write set changes that lack decoded table metadata. This occurs when API nodes run without table indexer capabilities, creating `DeleteTableItem` entries with `data: None`. Any transaction deleting table items triggers this panic, causing permanent indexer halt requiring manual intervention.

## Finding Description

The vulnerability exists in the indexer's table item processing logic. When a Move transaction calls `table::remove()`, the blockchain generates a `DeleteTableItem` write set change. The API node's conversion layer attempts to decode the deleted key using table metadata: [1](#0-0) 

When table metadata is unavailable (because the API node lacks an `indexer_reader` or the specific table info isn't found), this function deliberately returns `Ok(None)` to avoid crashes: [2](#0-1) 

The API node configuration accepts an optional `indexer_reader`: [3](#0-2) [4](#0-3) 

This creates a `DeleteTableItem` with `data: None`, which is explicitly marked as optional in the type definition: [5](#0-4) 

However, the separate indexer service that consumes these transactions unconditionally expects the `data` field to be present and panics when it's `None`: [6](#0-5) 

This function is called during transaction processing when the indexer encounters a `DeleteTableItem`: [7](#0-6) 

The panic is unhandled in the processing pipeline: [8](#0-7) 

**Attack Path:**
1. API node runs without table indexer enabled (`indexer_reader = None`)
2. User submits transaction calling Move function with `table::remove()` operation
3. VM executes transaction, generates `DeleteTableItem` write set change
4. API conversion creates `DeleteTableItem` with `data: None` (legitimate configuration)
5. Separate indexer service fetches transaction via API
6. Indexer calls `from_delete_table_item()` which panics
7. Indexer thread/process terminates, halting all transaction indexing

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria: "API crashes" (up to $50,000).

**Service Impact:**
- Complete indexer service halt requiring manual restart
- Loss of real-time blockchain data indexing
- API query failures for applications depending on indexed data
- Potential data gaps requiring reprocessing

**Not Affecting:**
- Core blockchain consensus (validators unaffected)
- Transaction execution (blockchain continues operating)
- Validator operations or staking
- On-chain state or fund safety

The indexer is critical infrastructure for ecosystem applications querying blockchain data, but distinct from consensus validators.

## Likelihood Explanation

**Likelihood: Medium-High**

**Triggering Conditions:**
1. API node configured without table indexer (legitimate deployment scenario)
2. Any transaction performing table deletion operations (common in Move smart contracts)
3. Table metadata not cached for the specific table being deleted

**Attacker Requirements:**
- No special privileges required
- Submit standard transaction with `table::remove()` call
- Knowledge that target API node lacks table metadata

**Real-World Scenarios:**
- New validator nodes bootstrapping without full indexer
- Lightweight API nodes optimized for transaction submission
- Any table operation on newly created tables before metadata propagates

This can occur **without malicious intent** during normal operations when configuration mismatches exist between API nodes and indexer services.

## Recommendation

Replace the panic with graceful error handling that allows indexer operation to continue:

**Option 1: Skip entries without metadata**
```rust
pub fn from_delete_table_item(
    delete_table_item: &DeleteTableItem,
    write_set_change_index: i64,
    transaction_version: i64,
    transaction_block_height: i64,
) -> Option<(Self, CurrentTableItem)> {
    let data = delete_table_item.data.as_ref()?;
    let decoded_key = data.key.clone();
    
    Some((
        Self {
            transaction_version,
            write_set_change_index,
            transaction_block_height,
            key: delete_table_item.key.to_string(),
            table_handle: standardize_address(&delete_table_item.handle.to_string()),
            decoded_key: decoded_key.clone(),
            decoded_value: None,
            is_deleted: true,
        },
        CurrentTableItem {
            table_handle: standardize_address(&delete_table_item.handle.to_string()),
            key_hash: hash_str(&delete_table_item.key.to_string()),
            key: delete_table_item.key.to_string(),
            decoded_key,
            decoded_value: None,
            last_transaction_version: transaction_version,
            is_deleted: true,
        },
    ))
}
```

**Option 2: Use default placeholder for missing metadata**
```rust
let decoded_key = delete_table_item
    .data
    .as_ref()
    .map(|d| d.key.clone())
    .unwrap_or_else(|| {
        aptos_logger::warn!(
            "Missing table metadata for DeleteTableItem at version {}, using placeholder",
            transaction_version
        );
        serde_json::json!({"_missing": "metadata unavailable"})
    });
```

Update call sites to handle `None` returns appropriately.

## Proof of Concept

**Setup:**
1. Configure API node without table indexer (`indexer_reader = None`)
2. Deploy Move module with table operations:

```move
module test_addr::table_delete_poc {
    use std::table::{Self, Table};
    use std::signer;

    struct TestTable has key {
        data: Table<u64, u64>
    }

    public entry fun init_table(account: &signer) {
        let data = table::new<u64, u64>();
        table::add(&mut data, 1, 100);
        move_to(account, TestTable { data });
    }

    public entry fun delete_entry(account: &signer) acquires TestTable {
        let table_ref = &mut borrow_global_mut<TestTable>(signer::address_of(account)).data;
        table::remove(table_ref, 1); // Generates DeleteTableItem
    }
}
```

**Reproduction Steps:**
1. Start API node with config: `indexer_reader: None`
2. Start separate indexer service consuming from API
3. Submit transaction: `init_table()` 
4. Submit transaction: `delete_entry()`
5. Observe indexer panic at `from_delete_table_item()`
6. Indexer halts, requires manual restart

**Expected Panic Message:**
```
thread 'indexer-processor' panicked at 'Could not extract data from DeletedTableItem "DeleteTableItem { state_key_hash: "...", handle: ..., key: ..., data: None }"'
```

**Verification:**
Check indexer logs show panic and service termination. Subsequent transactions won't be indexed until manual intervention.

## Notes

- This is a **compatibility issue** between API node configuration and indexer expectations, not necessarily malicious exploitation
- The vulnerability demonstrates defensive programming failure: API handles missing metadata gracefully, but indexer assumes it's always present
- Root cause is architectural: optional field treated as required by downstream consumer
- Similar patterns may exist in other indexer model conversions (token models, stake models) that should be audited

### Citations

**File:** api/types/src/convert.rs (L73-83)
```rust
    pub fn new(
        inner: &'a S,
        db: Arc<dyn DbReader>,
        indexer_reader: Option<Arc<dyn IndexerReader>>,
    ) -> Self {
        Self {
            inner: AptosValueAnnotator::new(inner),
            db,
            indexer_reader,
        }
    }
```

**File:** api/types/src/convert.rs (L580-599)
```rust
    pub fn try_delete_table_item_into_deleted_table_data(
        &self,
        handle: TableHandle,
        key: &[u8],
    ) -> Result<Option<DeletedTableData>> {
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
        };

        let key = self.try_into_move_value(&table_info.key_type, key)?;

        Ok(Some(DeletedTableData {
            key: key.json().unwrap(),
            key_type: table_info.key_type.to_canonical_string(),
        }))
    }
```

**File:** api/types/src/convert.rs (L1060-1065)
```rust
    fn get_table_info(&self, handle: TableHandle) -> Result<Option<TableInfo>> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            return Ok(indexer_reader.get_table_info(handle).unwrap_or(None));
        }
        Ok(None)
    }
```

**File:** api/types/src/transaction.rs (L1126-1134)
```rust
pub struct DeleteTableItem {
    pub state_key_hash: String,
    pub handle: HexEncodedBytes,
    pub key: HexEncodedBytes,
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DeletedTableData>,
}
```

**File:** crates/indexer/src/models/move_tables.rs (L88-98)
```rust
        let decoded_key = delete_table_item
            .data
            .as_ref()
            .unwrap_or_else(|| {
                panic!(
                    "Could not extract data from DeletedTableItem '{:?}'",
                    delete_table_item
                )
            })
            .key
            .clone();
```

**File:** crates/indexer/src/models/write_set_changes.rs (L141-159)
```rust
            APIWriteSetChange::DeleteTableItem(table_item) => {
                let (ti, cti) = TableItem::from_delete_table_item(
                    table_item,
                    index,
                    transaction_version,
                    transaction_block_height,
                );
                (
                    Self {
                        transaction_version,
                        hash: table_item.state_key_hash.clone(),
                        transaction_block_height,
                        type_,
                        address: String::default(),
                        index,
                    },
                    WriteSetChangeDetail::Table(ti, cti, None),
                )
            },
```

**File:** crates/indexer/src/processors/default_processor.rs (L486-487)
```rust
        let (txns, txn_details, events, write_set_changes, wsc_details) =
            TransactionModel::from_transactions(&transactions);
```
