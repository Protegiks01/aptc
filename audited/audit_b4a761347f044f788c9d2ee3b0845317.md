# Audit Report

## Title
Missing Version Validation Between StateSnapshotBackupMeta and StateSnapshotBackup Manifest Enables Database State Corruption via Backup Storage Compromise

## Summary
The `StateSnapshotRestoreController` fails to validate that the version specified in `StateSnapshotBackupMeta` matches the version in the `StateSnapshotBackup` manifest file, allowing state from one version to be incorrectly tagged as a different version in the restored database. If an attacker can manipulate backup storage metadata, they can cause mid-epoch validator state to be restored as epoch-ending state, breaking consensus safety invariants.

## Finding Description
During state snapshot restoration, there is a critical discrepancy in how versions are used: [1](#0-0) 

The `self.version` is set from `StateSnapshotRestoreOpt`, which originates from the `StateSnapshotBackupMeta` metadata structure: [2](#0-1) 

However, when the manifest is loaded and proofs are verified: [3](#0-2) 

The proof verification uses `manifest.version`, but **there is no validation that `self.version == manifest.version`**.

Subsequently, the state restore receiver is initialized with `self.version` from metadata: [4](#0-3) 

This receiver tags all restored key-value pairs with `self.version`: [5](#0-4) 

**Attack Scenario:**
1. Attacker gains write access to backup storage (e.g., misconfigured S3 bucket, compromised credentials)
2. Attacker creates a valid state snapshot at mid-epoch version V1 (e.g., version 1000 during validator set reconfiguration)
3. Manifest correctly contains V1 data with valid proofs
4. Attacker crafts malicious metadata claiming version V2 (e.g., version 1100, epoch-ending)
5. During restore, the system:
   - Loads manifest with V1 state data
   - Verifies proofs for V1 (succeeds)
   - Creates restore receiver for V2
   - Writes V1 state data tagged as V2 into database

**Broken Invariant:**
This violates the **Deterministic Execution** and **State Consistency** invariants. Validators restoring from this corrupted backup will have V1 validator set state (with pending_active/pending_inactive validators mid-transition) tagged as V2 (post-reconfiguration epoch-ending state). This causes different state root computations and consensus divergence.

## Impact Explanation
**Severity: High** (qualifies for up to $50,000 per bug bounty)

This vulnerability enables **Significant Protocol Violations** through:

1. **Database Corruption**: State from version V1 permanently tagged as version V2
2. **Consensus Divergence**: Nodes restoring from corrupted backup compute different state roots than honest nodes
3. **Validator Set Inconsistency**: Mid-epoch validator states (with pending transitions) incorrectly treated as finalized epoch-ending states

When mid-epoch state is restored as epoch-ending state during validator set transitions: [6](#0-5) 

The epoch change verification expects `next_epoch_state` to match local computation, but the corrupted state causes mismatches, leading to consensus failure.

While this doesn't directly cause fund loss, it creates a **non-recoverable database corruption** requiring manual intervention or network fork to resolve.

## Likelihood Explanation
**Likelihood: Medium**

Exploitation requires:
1. Write access to backup storage infrastructure
2. Knowledge of version numbers and epoch boundaries
3. Ability to create valid-looking metadata files

While backup storage is typically operator-controlled, real-world misconfigurations (public S3 buckets, weak IAM policies, compromised CI/CD pipelines) make this feasible. The lack of basic validation makes the attack trivial once storage access is obtained.

## Recommendation
Add explicit validation that metadata version matches manifest version:

```rust
async fn run_impl(self) -> Result<()> {
    if self.version > self.target_version {
        warn!(...);
        return Ok(());
    }

    let manifest: StateSnapshotBackup =
        self.storage.load_json_file(&self.manifest_handle).await?;
    
    // ADD THIS VALIDATION
    ensure!(
        self.version == manifest.version,
        "Version mismatch: metadata claims version {}, but manifest has version {}",
        self.version,
        manifest.version
    );
    
    let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
        self.storage.load_bcs_file(&manifest.proof).await?;
    // ... rest of function
}
```

Additionally, validate that the epoch field in metadata matches the epoch of the manifest version by checking against epoch history.

## Proof of Concept
**Rust Test Demonstrating the Issue:**

```rust
#[tokio::test]
async fn test_version_mismatch_vulnerability() {
    // Setup: Create backup storage with valid snapshot at version 1000
    let storage = Arc::new(MockBackupStorage::new());
    let manifest = StateSnapshotBackup {
        version: 1000,  // Actual state is at version 1000
        epoch: 5,
        root_hash: HashValue::random(),
        chunks: vec![],
        proof: FileHandle::new("proof"),
    };
    storage.save_json_file(&FileHandle::new("manifest"), &manifest).await.unwrap();
    
    // Attack: Create malicious metadata claiming version 1100
    let malicious_metadata = StateSnapshotBackupMeta {
        epoch: 5,
        version: 1100,  // Lying about version!
        manifest: FileHandle::new("manifest"),
    };
    
    // Restore controller uses metadata version (1100)
    let controller = StateSnapshotRestoreController::new(
        StateSnapshotRestoreOpt {
            manifest_handle: malicious_metadata.manifest,
            version: malicious_metadata.version,  // 1100 from metadata
            validate_modules: false,
            restore_mode: StateSnapshotRestoreMode::Default,
        },
        global_opt,
        storage,
        None,
    );
    
    // BUG: No validation that 1100 != 1000!
    // State from version 1000 will be tagged as version 1100 in database
    controller.run().await.unwrap();
    
    // Verify corruption: DB thinks state is at 1100 but it's actually 1000
    // This causes consensus divergence when replaying from version 1100
}
```

**Notes**

While this vulnerability exists in the codebase and represents a genuine security defect requiring a code fix, **exploitability by a completely unprivileged attacker is limited** by the requirement to compromise backup storage infrastructure, which is typically operator-controlled and would fall under the "privileged access" category per the trust model. However, given real-world cloud misconfigurations and the principle of defense-in-depth, this validation should absolutely be added.

The vulnerability is most concerning in scenarios where:
- Backup storage has overly permissive access controls
- Multiple parties share backup infrastructure
- Automated systems generate backups without proper authentication
- An insider threat or compromised operator credentials exist

The fix is straightforward and should be implemented regardless of exploitability assessment.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L86-86)
```rust
            version: opt.version,
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-127)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L141-145)
```rust
        let receiver = Arc::new(Mutex::new(Some(self.run_mode.get_state_restore_receiver(
            self.version,
            manifest.root_hash,
            self.restore_mode,
        )?)));
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L41-47)
```rust
    pub fn new_state_snapshot_backup(epoch: u64, version: Version, manifest: FileHandle) -> Self {
        Self::StateSnapshotBackup(StateSnapshotBackupMeta {
            epoch,
            version,
            manifest,
        })
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L117-120)
```rust
        let kv_batch: StateValueBatch<K, Option<V>> = chunk
            .into_iter()
            .map(|(k, v)| ((k, self.version), Some(v)))
            .collect();
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L106-116)
```rust
            ensure!(
                li.ends_epoch(),
                "Epoch change LI does not carry validator set. version:{}",
                li.version(),
            );
            ensure!(
                li.next_epoch_state() == next_epoch_state,
                "New validator set of a given epoch LI does not match local computation. {:?} vs {:?}",
                li.next_epoch_state(),
                next_epoch_state,
            );
```
