# Audit Report

## Title
TOCTOU Race Condition in Noise Handshake Allows Removed Peers to Maintain Authenticated Connections

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition in the Noise handshake authentication allows peers removed from `trusted_peers` to successfully complete authentication and maintain network connections for up to 5 seconds, bypassing network-level access control.

## Finding Description

The vulnerability exists in the mutual authentication handshake flow. When a peer initiates an inbound connection, the `upgrade_inbound()` function creates a **snapshot** of the `trusted_peers` set at the beginning of authentication. [1](#0-0) 

This snapshot is created by calling `get_trusted_peers()`, which loads from an `ArcSwap` and returns a **cloned** `PeerSet`. [2](#0-1) 

The critical race condition occurs when:

1. **Thread A** (handshake): Calls `get_trusted_peers()` and obtains snapshot S1 containing peer M
2. **Thread B** (configuration update): Calls `set_trusted_peers()` with a new set that excludes peer M [3](#0-2) 
3. **Thread A**: Continues authentication using snapshot S1, finds peer M in the snapshot, and successfully authenticates [4](#0-3) 
4. **Result**: Peer M has an authenticated connection despite being removed from `trusted_peers`

The inconsistent state persists until the next connectivity check, which runs every 5 seconds. [5](#0-4)  The `close_stale_connections()` function eventually disconnects peers not in `trusted_peers`, but only when it executes. [6](#0-5) 

**Attack Scenario:**

1. Validator M is detected as malicious or faulty
2. Administrator removes M from the validator set via on-chain governance
3. The `ConnectivityManager` receives `UpdateDiscoveredPeers` notification [7](#0-6) 
4. At line 993, `set_trusted_peers()` is called to remove M [8](#0-7) 
5. Simultaneously, M initiates handshakes to multiple validators
6. Due to the TOCTOU race, some handshakes succeed using stale snapshots
7. M maintains authenticated connections for up to 5 seconds
8. During this window, M floods validators with mempool transactions [9](#0-8) 

Mempool message handling has **no sender validation** beyond network authentication, allowing the removed peer to cause validator slowdowns through transaction broadcast flooding.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria:

1. **Validator node slowdowns**: During the 5-second window, a removed malicious peer can flood validators with `BroadcastTransactionsRequest` messages, causing CPU exhaustion from transaction validation and memory pressure.

2. **Significant protocol violations**: Network-level authentication is bypassed, creating an inconsistent authentication state where the handshake layer authenticates a peer that the trust management layer has rejected.

The impact is mitigated by:
- Short time window (maximum 5 seconds)
- Consensus messages undergo additional validation via `ValidatorVerifier` (though this depends on epoch state)
- Transactions still undergo VM validation

However, the resource exhaustion potential during validator set changes (epoch transitions, emergency validator removals) represents a real attack vector against network availability.

## Likelihood Explanation

**Likelihood: Medium to High**

The race condition requires precise timing but is more likely to occur during:
- Epoch transitions when validator sets are updated
- Emergency removal of malicious validators
- Network reconfigurations

The attack window is small (milliseconds to complete a handshake), but attackers can increase success probability by:
- Initiating multiple simultaneous handshakes
- Monitoring on-chain governance for validator removals
- Timing attacks around epoch boundaries

The 5-second persistence window is guaranteed once the race is won, providing ample time for exploitation.

## Recommendation

Implement **re-validation** of trusted peer status after the handshake completes but before establishing the connection:

```rust
// In upgrade_inbound(), after line 454 (timestamp storage):

// Re-validate that the peer is still in trusted_peers
if let HandshakeAuthMode::Mutual { peers_and_metadata, .. } = &self.auth_mode {
    let current_trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
    if !current_trusted_peers.contains_key(&remote_peer_id) {
        return Err(NoiseHandshakeError::UnauthenticatedClient(
            remote_peer_short,
            remote_peer_id,
        ));
    }
}
```

This creates a second check after the handshake cryptographic operations complete, closing the TOCTOU window. The cost is one additional `get_trusted_peers()` call per handshake, which is negligible compared to the cryptographic operations.

Alternative: Use the `trusted_peers` `Arc<ArcSwap<PeerSet>>` directly instead of cloning, and check membership at the latest possible moment before finalizing the connection.

## Proof of Concept

```rust
#[tokio::test]
async fn test_toctou_race_in_handshake() {
    use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
    use tokio::sync::Barrier;
    
    // Setup: Create two peers with mutual auth
    let network_ids = vec![NetworkId::Validator];
    let peers_and_metadata = PeersAndMetadata::new(&network_ids);
    
    // Add malicious peer M to trusted_peers
    let mut rng = rand::rngs::StdRng::from_seed([0u8; 32]);
    let (malicious_private_key, malicious_public_key) = 
        (x25519::PrivateKey::generate(&mut rng), ...);
    let malicious_peer_id = PeerId::random();
    
    let mut trusted_peers = PeerSet::new();
    trusted_peers.insert(malicious_peer_id, Peer::new(
        vec![],
        [malicious_public_key].into_iter().collect(),
        PeerRole::Validator,
    ));
    peers_and_metadata.set_trusted_peers(&NetworkId::Validator, trusted_peers).unwrap();
    
    // Setup victim validator
    let (victim_private_key, _) = (x25519::PrivateKey::generate(&mut rng), ...);
    let victim_upgrader = NoiseUpgrader::new(
        NetworkContext::mock(),
        victim_private_key,
        HandshakeAuthMode::mutual(peers_and_metadata.clone()),
    );
    
    // Synchronization primitives
    let barrier = Arc::new(Barrier::new(2));
    let race_flag = Arc::new(AtomicBool::new(false));
    
    // Thread A: Handshake in progress
    let barrier_clone = barrier.clone();
    let race_flag_clone = race_flag.clone();
    let handshake_task = tokio::spawn(async move {
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        
        // Signal ready to start race
        barrier_clone.wait().await;
        
        // Start handshake - this will call get_trusted_peers()
        let result = victim_upgrader.upgrade_inbound(listener_socket).await;
        
        // Check if race occurred
        if race_flag_clone.load(Ordering::SeqCst) {
            // Handshake should have failed but might succeed due to TOCTOU
            result
        } else {
            result
        }
    });
    
    // Thread B: Remove peer during handshake
    let barrier_clone = barrier.clone();
    let removal_task = tokio::spawn(async move {
        barrier_clone.wait().await;
        
        // Immediately remove malicious peer from trusted_peers
        let empty_peers = PeerSet::new();
        peers_and_metadata.set_trusted_peers(&NetworkId::Validator, empty_peers).unwrap();
        race_flag.store(true, Ordering::SeqCst);
    });
    
    // Execute race
    let (handshake_result, _) = tokio::join!(handshake_task, removal_task);
    
    // If race succeeds, handshake completes despite peer being removed
    // This demonstrates the TOCTOU vulnerability
    if handshake_result.unwrap().is_ok() {
        println!("VULNERABILITY CONFIRMED: Handshake succeeded after peer removal");
        
        // Verify peer is NOT in current trusted_peers
        assert!(peers_and_metadata.get_trusted_peers(&NetworkId::Validator)
            .unwrap()
            .is_empty());
    }
}
```

## Notes

This vulnerability demonstrates a fundamental consistency issue in distributed authentication state management. While the time window is limited by the 5-second connectivity check interval, the ability to bypass network-level access control during critical periods (validator removals, epoch transitions) represents a meaningful security risk. The recommended fix ensures that authentication decisions are based on the most current trust state rather than potentially stale snapshots.

### Citations

**File:** network/framework/src/noise/handshake.rs (L372-372)
```rust
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
```

**File:** network/framework/src/noise/handshake.rs (L373-382)
```rust
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
```

**File:** network/framework/src/application/storage.rs (L329-332)
```rust
    pub fn get_trusted_peers(&self, network_id: &NetworkId) -> Result<PeerSet, Error> {
        let trusted_peers = self.get_trusted_peer_set_for_network(network_id)?;
        Ok(trusted_peers.load().clone().deref().clone())
    }
```

**File:** network/framework/src/application/storage.rs (L361-368)
```rust
    pub fn set_trusted_peers(
        &self,
        network_id: &NetworkId,
        trusted_peer_set: PeerSet,
    ) -> Result<(), Error> {
        let trusted_peers = self.get_trusted_peer_set_for_network(network_id)?;
        trusted_peers.store(Arc::new(trusted_peer_set));
        Ok(())
```

**File:** config/src/config/network_config.rs (L41-41)
```rust
pub const CONNECTIVITY_CHECK_INTERVAL_MS: u64 = 5000;
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-490)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-893)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
```

**File:** network/framework/src/connectivity_manager/mod.rs (L991-993)
```rust
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
```

**File:** mempool/src/shared_mempool/coordinator.rs (L357-373)
```rust
        Event::Message(peer_id, msg) => {
            counters::shared_mempool_event_inc("message");
            match msg {
                MempoolSyncMsg::BroadcastTransactionsRequest {
                    message_id,
                    transactions,
                } => {
                    process_received_txns(
                        bounded_executor,
                        smp,
                        network_id,
                        message_id,
                        transactions.into_iter().map(|t| (t, None, None)).collect(),
                        peer_id,
                    )
                    .await;
                },
```
