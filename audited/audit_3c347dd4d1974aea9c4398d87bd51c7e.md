# Audit Report

## Title
Missing Cyclic Dependency Validation During Lazy Loading Module Publishing

## Summary
During lazy loading mode, the module publishing process in `create_with_compat_config()` skips cyclic dependency checks, allowing modules with circular dependencies to be published to the blockchain. While these modules cannot be executed, their presence violates the acyclic dependency invariant and wastes on-chain storage.

## Finding Description

The `immediate_dependencies_iter` at line 262 of `publishing.rs` correctly iterates over all module dependencies. However, the vulnerability lies not in the iterator itself, but in what happens during the verification loop. [1](#0-0) 

When lazy loading is enabled, the verification process explicitly skips cyclic dependency checking. The code iterates through dependencies and performs linking checks, but these checks only validate import correctness, not cycle detection: [2](#0-1) 

The linking checks call `dependencies::verify_module`, which only validates:
1. Imported modules exist
2. Imported structs match definitions  
3. Imported functions match signatures [3](#0-2) 

Crucially, cycle detection is handled separately in `visit_dependencies_and_verify` during runtime module loading, not during publishing: [4](#0-3) 

**Attack Path:**
1. Attacker creates modules A and B where A depends on B and B depends on A
2. Publishes bundle [A, B] when lazy loading is enabled
3. During publishing, each module passes linking checks (imports are valid)
4. No cycle detection occurs, so both modules are successfully committed
5. Modules remain on-chain but unusable for execution

## Impact Explanation

This issue constitutes a **Medium severity** protocol violation for the following reasons:

**Why NOT Critical:**
- Does not break consensus (all validators behave identically)
- Does not allow theft or minting of funds
- Does not enable remote code execution
- Cyclic modules cannot be executed (runtime cycle detection catches them)

**Why Medium:**
- Violates the documented invariant that module dependencies must be acyclic
- Wastes on-chain storage with unusable modules
- Creates state inconsistencies that require manual intervention to identify
- Could be used for griefing attacks to bloat state
- Represents a validation gap in the publishing process [5](#0-4) 

## Likelihood Explanation

**High likelihood** of occurrence:
- Any user can publish module bundles without special privileges
- Lazy loading is enabled in production Aptos networks
- Cycle creation requires only basic Move programming knowledge
- No additional validator access or consensus manipulation required
- Deterministic behavior makes exploitation straightforward

## Recommendation

Add cyclic dependency checking during the module publishing verification loop. Integrate the existing `cyclic_dependencies::verify_module` function:

```rust
// After line 275 in publishing.rs, add:
if is_lazy_loading_enabled {
    // ... existing code ...
    
    staged_runtime_environment.build_verified_module_with_linking_checks(
        locally_verified_code,
        &verified_dependencies,
    )?;
    
    // ADD CYCLE CHECK:
    let get_deps = |id: &ModuleId| -> PartialVMResult<Vec<ModuleId>> {
        Ok(staged_module_storage
            .unmetered_get_existing_lazily_verified_module(id)?
            .immediate_dependencies())
    };
    
    let get_friends = |id: &ModuleId| -> PartialVMResult<Vec<ModuleId>> {
        Ok(staged_module_storage
            .unmetered_get_existing_lazily_verified_module(id)?
            .immediate_friends())
    };
    
    cyclic_dependencies::verify_module(
        compiled_module,
        get_deps,
        get_friends
    )?;
}
```

## Proof of Concept

```rust
// Module A (modules/A.move)
module 0x1::A {
    use 0x1::B;
    
    public fun call_b() {
        B::call_a();
    }
}

// Module B (modules/B.move)  
module 0x1::B {
    use 0x1::A;
    
    public fun call_a() {
        A::call_b();
    }
}

// Publishing test
#[test]
fun test_cyclic_publish() {
    let module_a_bytes = compile_module("A.move");
    let module_b_bytes = compile_module("B.move");
    let bundle = vec![module_a_bytes, module_b_bytes];
    
    // This should fail but succeeds in lazy loading mode
    let result = StagingModuleStorage::create_with_compat_config(
        &sender_address,
        Compatibility::full_check(),
        &existing_storage,
        bundle
    );
    
    assert!(result.is_ok()); // Succeeds - VULNERABILITY
    
    // Later execution would fail
    let exec_result = execute_function(&result.unwrap(), "A::call_b");
    assert!(exec_result.is_err()); // Runtime cycle detection catches it
}
```

## Notes

While the iterator itself (`immediate_dependencies_iter`) cannot be manipulated to skip or incorrectly iterate dependencies due to proper bounds checking and deterministic behavior, the broader verification process has this validation gap. The iterator functions correctly; the issue is that cyclic dependency validation is deferred to runtime rather than performed during publishing.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L259-260)
```rust
                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L262-275)
```rust
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L185-195)
```rust
fn verify_module_impl<'a>(
    module: &CompiledModule,
    dependencies: impl IntoIterator<Item = &'a CompiledModule>,
) -> PartialVMResult<()> {
    let context = &Context::module(module, dependencies);

    verify_imported_modules(context)?;
    verify_imported_structs(context)?;
    verify_imported_functions(context)?;
    verify_all_script_visibility_usage(context)
}
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L409-415)
```rust
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** third_party/move/move-bytecode-verifier/src/cyclic_dependencies.rs (L68-75)
```rust
pub fn verify_module<D, F>(module: &CompiledModule, imm_deps: D, imm_friends: F) -> VMResult<()>
where
    D: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
    F: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
{
    verify_module_impl(module, imm_deps, imm_friends)
        .map_err(|e| e.finish(Location::Module(module.self_id())))
}
```
