# Audit Report

## Title
Round Skipping Vulnerability: RoundTimeout Messages Can Force Validators to Skip Legitimate Proposals via Premature Round Advancement

## Summary
When a validator receives a `RoundTimeoutMsg` for round N containing a TimeoutCertificate (TC) for round N-1, the sync mechanism causes immediate advancement to round N, permanently discarding any subsequent proposal for round N-1 as "stale". This breaks consensus completeness by preventing validators from evaluating legitimate proposals based solely on network message ordering.

## Finding Description

The vulnerability exists in the round synchronization logic where `RoundTimeoutMsg` processing can cause validators to skip rounds without attempting to process legitimate proposals for those rounds.

**Attack Flow:**

1. Validator is at round N-1 with `current_round = N-1`
2. Validator receives `RoundTimeoutMsg` for round N from a peer
3. The message's `sync_info` contains a valid TC for round N-1 (formed from 2f+1 timeout votes)
4. Message verification passes [1](#0-0) 
5. In `process_round_timeout_msg`, the system calls `ensure_round_and_sync_up(N, sync_info, author)` [2](#0-1) 
6. Since N > current_round (N-1), it proceeds to `sync_up` [3](#0-2) 
7. `sync_up` detects the TC for N-1 in sync_info, calls `add_certs` then `process_certificates` [4](#0-3) 
8. `process_certificates` advances `current_round` from N-1 to N [5](#0-4) 
9. When the legitimate proposal P for round N-1 arrives later, `process_proposal_msg` checks if the proposal round equals current_round [6](#0-5) 
10. Proposal P is rejected as "stale" because N-1 < N (current_round)

**Race Condition Exploitation:**

The vulnerability is exacerbated by the echo timeout mechanism, which allows f malicious validators to trigger cascading timeouts:

1. Attacker controls f validators
2. Leader sends valid proposal P for round N-1
3. Attacker's f validators immediately timeout without waiting for P
4. They broadcast `RoundTimeoutMsg` for round N-1
5. When honest validators receive f+1 timeout messages (f malicious + 1 honest with natural delay), echo timeout triggers [7](#0-6) 
6. This causes cascading timeouts via `process_local_timeout` [8](#0-7) 
7. Eventually 2f+1 validators timeout, forming TC for N-1
8. Honest validators receiving `RoundTimeoutMsg` for round N advance past round N-1
9. Proposal P is discarded when it arrives

**Invariant Violation:**

This breaks the implicit consensus completeness guarantee that validators should evaluate legitimate proposals before advancing rounds. The protocol allows validators to skip proposals purely due to message ordering, not proposal validity.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: Validators skip legitimate proposals without evaluation, violating consensus completeness assumptions. This affects the fundamental operation of the consensus protocol.

2. **Validator Node Slowdowns**: Repeatedly forcing validators to skip legitimate proposals causes unnecessary round transitions, degrading network throughput and increasing latency.

3. **Selective Censorship**: An attacker with f validators can strategically trigger timeouts to prevent specific leaders' proposals from being processed, potentially censoring transactions or creating liveness degradation.

4. **Resource Waste**: Unnecessary round transitions waste network bandwidth and computational resources across all validators.

The vulnerability doesn't break consensus safety (no conflicting blocks can both get QCs), but it significantly degrades the protocol's ability to process legitimate proposals efficiently.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Requirements**: Only requires f validators (minimum Byzantine threshold) to intentionally timeout early, plus natural network variance
2. **Natural Trigger**: Can occur without malicious intent due to normal network delays and message reordering
3. **Echo Timeout Amplification**: The f+1 echo timeout mechanism amplifies the effect, causing cascading timeouts
4. **No Detection**: The protocol has no mechanism to detect or prevent this attack pattern
5. **Repeatable**: Attacker can repeat this pattern across multiple rounds to persistently degrade consensus

## Recommendation

Implement a proposal buffer mechanism to prevent validators from skipping rounds with pending or recently-received proposals:

**Solution 1: Check for pending proposals before advancing rounds**

Before advancing rounds via TC in `process_certificates`, verify no valid proposal exists for the skipped round:

```rust
// In round_state.rs process_certificates()
if new_round > self.current_round {
    // Check if we have a proposal for any skipped round
    for round in self.current_round..new_round {
        if block_store.get_block_for_round(round).is_some() {
            // Proposal exists for this round, process it first
            warn!("Blocking round advancement due to pending proposal at round {}", round);
            return None;
        }
    }
    // Safe to advance
    self.current_round = new_round;
    // ... rest of logic
}
```

**Solution 2: Delay TC-based round advancement**

Add a grace period before accepting TCs to allow proposals to arrive:

```rust
// In round_manager.rs ensure_round_and_sync_up()
pub async fn ensure_round_and_sync_up(
    &mut self,
    message_round: Round,
    sync_info: &SyncInfo,
    author: Author,
) -> anyhow::Result<bool> {
    if message_round < self.round_state.current_round() {
        return Ok(false);
    }
    
    // Check if advancing multiple rounds via TC
    if sync_info.highest_round() + 1 > self.round_state.current_round() + 1 {
        // Allow time for proposals to arrive before skipping rounds
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // Check for proposals in skipped rounds
        for round in self.round_state.current_round()..sync_info.highest_round() {
            if let Some(block) = self.block_store.get_block_for_round(round) {
                self.process_proposal(block.clone()).await?;
            }
        }
    }
    
    self.sync_up(sync_info, author).await?;
    // ... rest of logic
}
```

**Solution 3: Strengthen RoundTimeoutMsg verification**

Add a check to prevent advancing multiple rounds without evidence that intermediate rounds were attempted:

```rust
// In round_timeout.rs verify()
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    ensure!(
        self.round_timeout.round() > self.sync_info.highest_round(),
        "Timeout Round should be higher than SyncInfo"
    );
    
    // NEW CHECK: Prevent skipping more than one round
    ensure!(
        self.round_timeout.round() <= self.sync_info.highest_round() + 2,
        "RoundTimeout cannot skip multiple rounds without intermediate certificates"
    );
    
    // ... rest of verification
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_round_timeout_skips_legitimate_proposal() {
    // Setup: 4 validators (f=1), at round N-1
    let mut round_manager = create_round_manager(4).await;
    assert_eq!(round_manager.round_state.current_round(), 1);
    
    // Step 1: Leader sends legitimate proposal for round 1
    let proposal = create_valid_proposal(1);
    
    // Step 2: Malicious validator sends RoundTimeoutMsg for round 2
    // with TC for round 1 (simulating that 3 validators timed out)
    let tc_round_1 = create_timeout_certificate(1, 3); // 3/4 validators
    let sync_info_with_tc = SyncInfo::new(
        create_qc(0),
        create_qc(0),
        Some(tc_round_1),
    );
    
    let round_timeout_msg = RoundTimeoutMsg::new(
        create_round_timeout(2, sync_info_with_tc.clone()),
        sync_info_with_tc,
    );
    
    // Step 3: Process RoundTimeoutMsg BEFORE proposal arrives
    round_manager.process_round_timeout_msg(round_timeout_msg).await.unwrap();
    
    // Verify: Current round advanced to 2
    assert_eq!(round_manager.round_state.current_round(), 2);
    
    // Step 4: Now proposal for round 1 arrives (delayed by network)
    let result = round_manager.process_proposal_msg(
        ProposalMsg::new(proposal, create_sync_info(0))
    ).await;
    
    // Vulnerability: Proposal is silently discarded as "stale"
    // even though it was legitimate and validator never evaluated it
    assert!(result.is_ok());
    
    // Verify proposal was not processed (not in block store)
    assert!(round_manager.block_store.get_block_for_round(1).is_none());
    
    // This demonstrates that validator skipped round 1 entirely
    // without ever attempting to vote on the legitimate proposal
}
```

## Notes

This vulnerability is particularly insidious because:

1. It can occur naturally due to network delays without malicious intent
2. The echo timeout mechanism (designed to improve liveness) actually amplifies the problem
3. Validators have no visibility that they skipped a legitimate proposal
4. The attack is deniable - malicious validators can claim network delays
5. It affects consensus completeness, a critical but often under-specified property

The fix requires careful balance between allowing legitimate round skipping (for liveness when proposals genuinely fail) versus preventing premature round advancement that bypasses legitimate proposals.

### Citations

**File:** consensus/consensus-types/src/round_timeout.rs (L153-171)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.round_timeout.epoch() == self.sync_info.epoch(),
            "RoundTimeoutV2Msg has different epoch"
        );
        ensure!(
            self.round_timeout.round() > self.sync_info.highest_round(),
            "Timeout Round should be higher than SyncInfo"
        );
        ensure!(
            self.round_timeout.two_chain_timeout().hqc_round()
                <= self.sync_info.highest_certified_round(),
            "2-chain Timeout hqc should be less or equal than the sync info hqc"
        );
        // We're not verifying SyncInfo here yet: we are going to verify it only in case we need
        // it. This way we avoid verifying O(n) SyncInfo messages while aggregating the votes
        // (O(n^2) signature verifications).
        self.round_timeout.verify(validator)
    }
```

**File:** consensus/src/round_manager.rs (L743-764)
```rust
        let in_correct_round = self
            .ensure_round_and_sync_up(
                proposal_msg.proposal().round(),
                proposal_msg.sync_info(),
                proposal_msg.proposer(),
            )
            .await
            .context("[RoundManager] Process proposal")?;
        if in_correct_round {
            self.process_proposal(proposal_msg.take_proposal()).await
        } else {
            sample!(
                SampleRate::Duration(Duration::from_secs(30)),
                warn!(
                    "[sampled] Stale proposal {}, current round {}",
                    proposal_msg.proposal(),
                    self.round_state.current_round()
                )
            );
            counters::ERROR_COUNT.inc();
            Ok(())
        }
```

**File:** consensus/src/round_manager.rs (L877-907)
```rust
    /// Sync to the sync info sending from peer if it has newer certificates.
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
    }
```

**File:** consensus/src/round_manager.rs (L916-935)
```rust
    pub async fn ensure_round_and_sync_up(
        &mut self,
        message_round: Round,
        sync_info: &SyncInfo,
        author: Author,
    ) -> anyhow::Result<bool> {
        if message_round < self.round_state.current_round() {
            return Ok(false);
        }
        self.sync_up(sync_info, author).await?;
        ensure!(
            message_round == self.round_state.current_round(),
            "After sync, round {} doesn't match local {}. Local Sync Info: {}. Remote Sync Info: {}",
            message_round,
            self.round_state.current_round(),
            self.block_store.sync_info(),
            sync_info,
        );
        Ok(true)
    }
```

**File:** consensus/src/round_manager.rs (L1843-1845)
```rust
            VoteReceptionResult::EchoTimeout(_) if !self.round_state.is_timeout_sent() => {
                self.process_local_timeout(round).await
            },
```

**File:** consensus/src/round_manager.rs (L1855-1879)
```rust
    pub async fn process_round_timeout_msg(
        &mut self,
        round_timeout_msg: RoundTimeoutMsg,
    ) -> anyhow::Result<()> {
        fail_point!("consensus::process_round_timeout_msg", |_| {
            Err(anyhow::anyhow!(
                "Injected error in process_round_timeout_msg"
            ))
        });
        // Check whether this validator is a valid recipient of the vote.
        if self
            .ensure_round_and_sync_up(
                round_timeout_msg.round(),
                round_timeout_msg.sync_info(),
                round_timeout_msg.author(),
            )
            .await
            .context("[RoundManager] Stop processing vote")?
        {
            self.process_round_timeout(round_timeout_msg.timeout())
                .await
                .context("[RoundManager] Add a new timeout")?;
        }
        Ok(())
    }
```

**File:** consensus/src/liveness/round_state.rs (L245-289)
```rust
    pub fn process_certificates(
        &mut self,
        sync_info: SyncInfo,
        verifier: &ValidatorVerifier,
    ) -> Option<NewRoundEvent> {
        if sync_info.highest_ordered_round() > self.highest_ordered_round {
            self.highest_ordered_round = sync_info.highest_ordered_round();
        }
        let new_round = sync_info.highest_round() + 1;
        if new_round > self.current_round {
            let (prev_round_votes, prev_round_timeout_votes) = self.pending_votes.drain_votes();

            // Start a new round.
            self.current_round = new_round;
            self.pending_votes = PendingVotes::new();
            self.vote_sent = None;
            self.timeout_sent = None;
            let timeout = self.setup_timeout(1);

            let (prev_round_timeout_votes, prev_round_timeout_reason) = prev_round_timeout_votes
                .map(|votes| votes.unpack_aggregate(verifier))
                .unzip();

            // The new round reason is QCReady in case both QC.round + 1 == new_round, otherwise
            // it's Timeout and TC.round + 1 == new_round.
            let new_round_reason = if sync_info.highest_certified_round() + 1 == new_round {
                NewRoundReason::QCReady
            } else {
                let prev_round_timeout_reason =
                    prev_round_timeout_reason.unwrap_or(RoundTimeoutReason::Unknown);
                NewRoundReason::Timeout(prev_round_timeout_reason)
            };

            let new_round_event = NewRoundEvent {
                round: self.current_round,
                reason: new_round_reason,
                timeout,
                prev_round_votes,
                prev_round_timeout_votes,
            };
            info!(round = new_round, "Starting new round: {}", new_round_event);
            return Some(new_round_event);
        }
        None
    }
```

**File:** consensus/src/pending_votes.rs (L255-263)
```rust
        // Echo timeout if receive f+1 timeout message.
        if !self.echo_timeout {
            let f_plus_one = validator_verifier.total_voting_power()
                - validator_verifier.quorum_voting_power()
                + 1;
            if tc_voting_power >= f_plus_one {
                self.echo_timeout = true;
                return VoteReceptionResult::EchoTimeout(tc_voting_power);
            }
```
