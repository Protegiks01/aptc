# Audit Report

## Title
Missing Signature Verification in State Snapshot Restoration Enables Validator Set Manipulation and Network Partition

## Summary
The one-shot state snapshot restoration process bypasses cryptographic signature verification on `LedgerInfoWithSignatures`, allowing attackers to craft malicious backups with arbitrary validator staking data. While this does not grant attackers true consensus control, it enables critical denial-of-service attacks that can cause network partition and break Byzantine fault tolerance assumptions if enough validators restore from compromised backups.

## Finding Description

The backup restoration system has two validation mechanisms:
1. Merkle proof verification that state values match the claimed root hash
2. Signature verification on `LedgerInfoWithSignatures` to ensure the root hash is legitimate

The signature verification is **conditionally bypassed** when restoring state snapshots without epoch history. This occurs in two scenarios:

**Scenario 1: One-shot State Snapshot Restore** [1](#0-0) 

The one-shot restore explicitly passes `None` for `epoch_history`, disabling signature verification.

**Scenario 2: Using --skip-epoch-endings Flag** [2](#0-1) 

When the `--skip-epoch-endings` flag is set, `epoch_history` is set to `None` instead of validating epoch ending data.

**The Missing Validation:** [3](#0-2) 

This signature verification is only performed if `epoch_history` exists. When it's `None`, no cryptographic validation of the `LedgerInfoWithSignatures` occurs.

**Documentation Confirms the Gap:** [4](#0-3) 

The documentation explicitly states that LedgerInfos are NOT checked during one-shot state snapshot restoration.

**The Only Validation Performed:** [5](#0-4) 

This only verifies the Merkle proof consistency, not the legitimacy of the LedgerInfo itself.

**Attack Path:**
1. Attacker crafts a malicious backup containing:
   - Modified on-chain state with manipulated `ValidatorSet` and `StakePool` resources
   - A fake `LedgerInfoWithSignatures` (with invalid or no BLS signatures)
   - Valid Merkle proofs matching the crafted state to the fake root hash

2. Attacker tricks validator operators into restoring from this backup by:
   - Compromising backup storage infrastructure
   - Social engineering (distributing "fast bootstrap" backups)
   - Man-in-the-middle attacks during backup download

3. Victims restore using one-shot command:
   ```bash
   aptos-db-tool restore oneoff state-snapshot --state-manifest <malicious_manifest>
   ```

4. The malicious state is written to the database without signature verification

5. When the restored node starts and attempts to sync:
   - It uses the incorrect validator set for signature verification
   - It rejects legitimate blocks from the real network (false negatives)
   - It may accept invalid blocks if the attacker's forged validator set is used (false positives)
   - The node becomes permanently desynchronized from the network

## Impact Explanation

This is a **Critical Severity** vulnerability under the Aptos Bug Bounty program:

**Network Partition (Non-recoverable):** If multiple validators restore from the same malicious backup, they form an isolated partition with an incompatible view of the validator set. This breaks Byzantine fault tolerance:
- If >1/3 of validators are affected, the honest partition loses safety/liveness
- The network would require manual intervention or a hard fork to recover

**Consensus Safety Violation:** Nodes with manipulated validator sets cannot properly verify quorum certificates and may make incorrect consensus decisions, violating the "Consensus Safety" invariant that AptosBFT must prevent chain splits under <1/3 Byzantine faults.

**Total Loss of Liveness:** Affected validators cannot participate in consensus, reducing the effective validator set. If enough validators are compromised, the network loses liveness entirely.

**Trust Model Violation:** The vulnerability bypasses the fundamental security guarantee that all state must be validated via cryptographic signatures from validators, breaking invariant #10 (Cryptographic Correctness).

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
1. Attacker controls or compromises backup storage (Medium difficulty)
2. Victims use one-shot restore or `--skip-epoch-endings` flag (Common in practice)
3. No additional authentication beyond storage access

The one-shot restore is a **documented, supported feature** intended for fast bootstrapping, making it likely to be used in production. The `--skip-epoch-endings` flag is described as "used for debugging" but is accessible in production builds.

Backup storage compromise is a realistic threat vector:
- Cloud storage misconfigurations
- Compromised CI/CD pipelines that generate backups
- Supply chain attacks on backup infrastructure
- Insider threats from infrastructure operators

Once backup storage is compromised, the attack is straightforward to execute and guaranteed to succeed.

## Recommendation

**Mandatory Signature Verification:**
Always verify `LedgerInfoWithSignatures` cryptographically, even in one-shot restore mode. Require trusted waypoints for fast bootstrapping instead of bypassing signature checks.

**Implementation Fix:**

In `storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs`, make epoch history or trusted waypoints mandatory:

```rust
// Around line 137-139
// BEFORE: Optional verification
if let Some(epoch_history) = self.epoch_history.as_ref() {
    epoch_history.verify_ledger_info(&li)?;
}

// AFTER: Mandatory verification
if let Some(epoch_history) = self.epoch_history.as_ref() {
    epoch_history.verify_ledger_info(&li)?;
} else {
    // Require at least a trusted waypoint for the snapshot version
    ensure!(
        !self.trusted_waypoints.is_empty(),
        "State snapshot restore requires either epoch history or trusted waypoints for signature verification"
    );
    let snapshot_waypoint = Waypoint::new_any(&li.ledger_info());
    let trusted = self.trusted_waypoints.get(&manifest.version)
        .ok_or_else(|| anyhow!("No trusted waypoint provided for snapshot version {}", manifest.version))?;
    ensure!(
        snapshot_waypoint == *trusted,
        "Snapshot waypoint {} doesn't match trusted waypoint {}",
        snapshot_waypoint,
        trusted
    );
}
```

**Additional Mitigations:**
1. Remove or restrict the `--skip-epoch-endings` flag to development builds only
2. Add warnings when using one-shot restore without trusted waypoints
3. Implement backup integrity verification (signatures on backup manifests)
4. Document the security implications of fast bootstrap methods

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// This test shows that state snapshot restore accepts invalid LedgerInfo without epoch_history

#[tokio::test]
async fn test_malicious_backup_accepted_without_epoch_history() {
    use aptos_backup_cli::backup_types::state_snapshot::restore::{
        StateSnapshotRestoreController, StateSnapshotRestoreOpt
    };
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    // Step 1: Create a malicious backup with fake LedgerInfo
    // The LedgerInfo contains no valid validator signatures
    let fake_ledger_info = create_fake_ledger_info_with_modified_validator_set();
    
    // Step 2: Create valid Merkle proofs for the malicious state
    // This is possible because we control both the state and the root hash
    let malicious_state = create_state_with_attacker_validator_having_34_percent_stake();
    let (malicious_chunks, proofs) = create_valid_merkle_proofs(malicious_state);
    
    // Step 3: Create a backup manifest pointing to our malicious data
    let manifest = create_manifest(fake_ledger_info, malicious_chunks, proofs);
    
    // Step 4: Attempt restore WITHOUT epoch_history (simulating one-shot restore)
    let controller = StateSnapshotRestoreController::new(
        StateSnapshotRestoreOpt {
            manifest_handle: manifest.handle,
            version: manifest.version,
            validate_modules: false,
            restore_mode: StateSnapshotRestoreMode::Default,
        },
        global_opts,
        storage,
        None, // epoch_history is None - THIS IS THE VULNERABILITY
    );
    
    // Step 5: Restore succeeds without signature verification
    let result = controller.run().await;
    assert!(result.is_ok(), "Malicious backup was accepted!");
    
    // Step 6: Verify that database now contains the manipulated validator set
    let restored_validator_set = db.get_latest_validator_set().unwrap();
    assert!(attacker_has_34_percent_stake(&restored_validator_set));
    
    // The node is now in an inconsistent state and will fail to sync with the real network
}
```

**Notes:**
- The vulnerability lies in the **optional** signature verification that can be bypassed
- While attackers cannot forge valid BLS signatures, they can craft backups with internally consistent but illegitimate data
- The real impact is denial of service and network partition, not direct consensus control
- Affected nodes become isolated from the honest network due to validator set mismatch
- This breaks BFT assumptions by potentially affecting >1/3 of validators through coordinated backup compromise

### Citations

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L127-136)
```rust
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```
