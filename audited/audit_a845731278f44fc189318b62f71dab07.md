# Audit Report

## Title
Man-in-the-Middle Attack on Remote Executor Network Communication Enables Consensus Divergence

## Summary

The remote executor's gRPC network communication layer lacks integrity protection, authentication, and encryption. The `NetworkMessage` protobuf structure transmits execution commands over plain HTTP without signatures or MACs, allowing MITM attackers to modify message bytes or redirect messages to unintended handlers, potentially causing consensus divergence between validators.

## Finding Description

The Aptos remote executor system uses a gRPC-based network protocol for coordinating sharded transaction execution across separate processes. The `NetworkMessage` structure contains two fields: `message` (raw bytes) and `message_type` (routing string), both transmitted without any cryptographic integrity protection. [1](#0-0) 

The gRPC network service processes incoming messages by directly extracting and routing them based on the untrusted `message_type` string: [2](#0-1) 

The client connects using plain HTTP without TLS: [3](#0-2) 

This architecture contrasts sharply with Aptos's main network layer, which uses NoiseIK protocol for authentication and full end-to-end encryption: [4](#0-3) 

The remote executor is integrated into the main execution workflow and can be enabled for production validators: [5](#0-4) 

### Attack Scenario

When remote execution is enabled, the coordinator sends `ExecuteBlock` commands containing transaction sub-blocks to executor shards: [6](#0-5) 

These commands are received by `RemoteCoordinatorClient` and deserialized without verification: [7](#0-6) 

A MITM attacker positioned between the coordinator and executor shards can:

1. **Modify execution commands**: Change the `message` bytes to alter which transactions execute, their order, or execution parameters
2. **Redirect messages**: Modify the `message_type` string to route execution commands to incorrect shard handlers (e.g., sending shard 0's transactions to shard 1)
3. **Inject malicious cross-shard messages**: Forge cross-shard state updates to corrupt execution results [8](#0-7) 

### Invariant Violations

This breaks two critical Aptos invariants:

1. **Deterministic Execution**: If different validators experience different MITM attacks, they will execute different transaction sets, producing divergent state roots
2. **Consensus Safety**: Validators will fail to reach consensus when their execution results differ, causing the chain to halt or fork

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

**Consensus/Safety Violations**: A MITM attacker can cause different validators to execute different transactions for the same block. When validators using remote execution have their network communication intercepted and modified:
- Validator A (under MITM attack) executes transactions {T1, T3, T5}
- Validator B (not under attack) executes transactions {T1, T2, T3, T4, T5}
- Their resulting state roots diverge, preventing consensus

**Non-recoverable Network Partition**: If a subset of validators consistently experiences MITM attacks while others don't, the network partitions into groups that cannot agree on state transitions. Recovery would require manual intervention or a hard fork to identify and remove compromised validators.

**Total Loss of Liveness**: In the worst case, if enough validators (>1/3) are affected by MITM attacks that cause inconsistent execution, the network cannot reach consensus on new blocks, resulting in complete chain halt.

## Likelihood Explanation

The likelihood depends on deployment configuration:

**High Likelihood Scenarios**:
- Remote executor shards deployed across different physical machines in a datacenter
- Multi-region deployments for redundancy
- Any deployment where coordinator and executors communicate over network infrastructure that isn't cryptographically isolated

**Lower Likelihood Scenarios**:
- All processes running on localhost only
- Deployment in fully isolated network segments with physical access controls

However, the code itself **does not enforce or document** any deployment restrictions. The main entry point accepts arbitrary socket addresses without warnings: [9](#0-8) 

Production validators enabling this feature could inadvertently deploy it insecurely, making the attack highly feasible.

## Recommendation

Implement cryptographic integrity protection and authentication for remote executor communication:

**Option 1: Use TLS with Mutual Authentication**
```rust
// In GRPCNetworkMessageServiceClientWrapper::get_channel()
async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
    let tls_config = ClientTlsConfig::new()
        .ca_certificate(Certificate::from_pem(CA_CERT))
        .identity(Identity::from_pem(CLIENT_CERT, CLIENT_KEY));
    
    let conn = tonic::transport::Endpoint::new(format!("https://{}", remote_addr))?
        .tls_config(tls_config)?
        .connect_lazy();
    
    NetworkMessageServiceClient::new(conn)
}
```

**Option 2: Add Message-Level Authentication**
```rust
// Add signature field to NetworkMessage protobuf
message NetworkMessage {
    bytes message = 1;
    string message_type = 2;
    bytes signature = 3;  // HMAC-SHA256 or Ed25519 signature
    bytes sender_id = 4;  // Authenticated sender identity
}

// Verify on receive
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(&self, request: Request<NetworkMessage>) 
        -> Result<Response<Empty>, Status> {
        let network_message = request.into_inner();
        
        // Verify signature before processing
        if !verify_message_signature(&network_message) {
            return Err(Status::unauthenticated("Invalid message signature"));
        }
        
        // ... existing message processing
    }
}
```

**Option 3: Reuse Aptos NoiseIK Transport**

Integrate the existing Noise protocol used by the main network layer: [10](#0-9) 

This would provide encryption, authentication, and anti-replay protection consistent with the rest of the Aptos network stack.

## Proof of Concept

```rust
// PoC: Intercept and modify remote executor messages
// This demonstrates a MITM attack using mitmproxy or similar

// 1. Setup: Deploy remote executor with coordinator at 10.0.0.1:52200
//    and executor shard at 10.0.0.2:52201

// 2. Position attacker as MITM between them

// 3. Intercept gRPC message
use prost::Message as ProstMessage;

#[test]
fn test_mitm_message_modification() {
    // Original ExecuteBlock command sent by coordinator
    let original_command = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
        sub_blocks: SubBlocksForShard::new(vec![/* transactions T1, T2, T3 */]),
        concurrency_level: 8,
        onchain_config: BlockExecutorConfigFromOnchain::default(),
    });
    
    let original_bytes = bcs::to_bytes(&original_command).unwrap();
    
    // MITM attacker intercepts NetworkMessage
    let mut intercepted = NetworkMessage {
        message: original_bytes,
        message_type: "execute_command_0".to_string(),
    };
    
    // Attack 1: Modify message_type to redirect to wrong shard
    intercepted.message_type = "execute_command_1".to_string();
    // Now shard 1 executes shard 0's transactions
    
    // Attack 2: Modify message bytes to drop transactions
    let mut modified_command = original_command.clone();
    modified_command.sub_blocks = SubBlocksForShard::new(vec![/* only T1, T3 - T2 removed */]);
    intercepted.message = bcs::to_bytes(&modified_command).unwrap();
    
    // Forward modified message to executor shard
    // Result: Shard executes different transactions than coordinator intended
    // Validators with MITM vs without MITM will have divergent state
}

// 4. Demonstrate consensus divergence
#[test]
fn test_consensus_divergence_via_mitm() {
    // Validator A: Normal execution
    let validator_a_result = execute_with_remote_executor(
        transactions,  // [T1, T2, T3, T4, T5]
        false,  // no MITM
    );
    
    // Validator B: Under MITM attack
    let validator_b_result = execute_with_remote_executor(
        transactions,  // [T1, T2, T3, T4, T5]
        true,  // MITM drops T2 and T4
    );
    
    // Assert divergence
    assert_ne!(
        validator_a_result.state_root,
        validator_b_result.state_root,
        "MITM caused consensus divergence"
    );
    
    // Consensus cannot proceed when validators disagree on state
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Architectural Inconsistency**: The remote executor uses an insecure protocol while the rest of Aptos's network layer uses NoiseIK for security. This suggests the security implications weren't fully considered during design.

2. **No Documentation**: Neither the code nor deployment documentation warns operators about the security requirements for remote executor deployment. A validator operator might deploy this across machines assuming Aptos would handle security automatically.

3. **Production Integration**: The remote executor is fully integrated into the main execution workflow and can be enabled in production validators, making this a real attack surface rather than just a testing feature.

4. **Silent Failures**: MITM attacks wouldn't immediately crash nodesâ€”they would cause subtle consensus divergence that might be difficult to diagnose, especially if only affecting a subset of validators.

The fix should prioritize adding cryptographic integrity protection (TLS or message-level signatures) and clearly documenting deployment security requirements if network isolation is assumed.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L8-13)
```rust
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-116)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** network/README.md (L22-28)
```markdown
The network component uses:

* TCP for reliable transport.
* [NoiseIK] for authentication and full end-to-end encryption.
* On-chain [`NetworkAddress`](../types/src/network_address/mod.rs) set for discovery, with
  optional seed peers in the [`NetworkConfig`]
  as a fallback.
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L180-206)
```rust
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-113)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** execution/executor-service/src/main.rs (L9-48)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}

fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```

**File:** network/framework/src/transport/mod.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
