# Audit Report

## Title
Missing Range Validation in PersistedAuxiliaryInfoPruner Enables Data Loss During Database Desynchronization

## Summary
The `PersistedAuxiliaryInfoPruner::prune()` function does not validate that `current_progress` and `target_version` are within the valid range of versions actually stored in `PersistedAuxiliaryInfoDb`. When combined with the acknowledged database inconsistency issue during parallel commits, this can cause the pruner to delete all available data, leaving the database in an inconsistent state.

## Finding Description

The vulnerability exists in the interaction between parallel database writes during transaction commit and the pruner's blind deletion logic.

During transaction commit, multiple databases are written in parallel without atomic coordination: [1](#0-0) [2](#0-1) 

This TODO comment explicitly acknowledges that database inconsistencies can occur. If a node crashes during parallel writes, some databases may have complete data while others have partial or missing data.

The pruner initialization retrieves `metadata_progress` from the ledger metadata pruner: [3](#0-2) 

Each sub-pruner then "catches up" to this progress: [4](#0-3) 

The critical flaw is in the `PersistedAuxiliaryInfoDb::prune()` function, which blindly deletes all versions in the specified range without validating that:
1. These versions exist in the database
2. The range is safe relative to the actual data available
3. The pruning won't leave the database in an inconsistent state [5](#0-4) 

**Attack Scenario:**
1. Node commits transactions 0-1000 via parallel database writes
2. `PersistedAuxiliaryInfoDb` successfully writes versions 0-500, then node crashes (power failure, OOM, etc.)
3. `LedgerCommitProgress` was written to 1000 in a parallel thread that completed before crash
4. Node restarts and pruner activates with latest_version=1000, prune_window=300
5. Pruner calculates target_version = 700 and updates `LedgerPrunerProgress`
6. `PersistedAuxiliaryInfoPruner` initializes with `metadata_progress=700`
7. It calls `prune(0, 700)` to catch up
8. All versions 0-499 are deleted from `PersistedAuxiliaryInfoDb` (all available data!)
9. Database now has no auxiliary info, but versions 700-1000 should be available
10. Queries for versions 701-1000 return `None` instead of actual data

This breaks the **State Consistency** invariant - validators should maintain consistent storage where all data within the prune window is accessible.

## Impact Explanation

This is a **Medium Severity** issue per the Aptos bug bounty criteria:

**State inconsistencies requiring intervention**: The vulnerability causes permanent loss of `PersistedAuxiliaryInfo` data that should be available based on the pruning window. This auxiliary info contains the transaction index within blocks, which is used by:
- Transaction APIs for returning block context
- State synchronization protocols
- Debugging and observability tools [6](#0-5) 

While this doesn't directly cause consensus failure or fund loss, it creates state inconsistencies that:
- Break API guarantees for transaction metadata
- May cause state sync issues between nodes
- Require manual intervention or resync to recover
- Could affect services depending on accurate transaction indexing

The impact is amplified because the data loss is silent - queries return `None` (indicating no auxiliary info) rather than an error, masking the underlying corruption: [7](#0-6) 

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires a crash during the narrow window of parallel database writes, but this is realistic in production:
- Power failures during high transaction throughput
- OOM conditions killing the process mid-write
- Disk I/O errors during commit
- Operating system crashes or forced restarts

The parallel write pattern without atomic coordination makes this window wider than it would be with coordinated transactions. The developers' TODO comment indicates they're aware this can happen but haven't implemented proper handling yet.

## Recommendation

Implement range validation in `PersistedAuxiliaryInfoPruner::prune()` before delegating to `PersistedAuxiliaryInfoDb::prune()`:

```rust
fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
    // Validate that we're not pruning beyond available data
    let latest_available = self.ledger_db
        .persisted_auxiliary_info_db()
        .get_latest_version()?;
    
    if let Some(max_version) = latest_available {
        if target_version > max_version {
            warn!(
                current_progress = current_progress,
                target_version = target_version,
                latest_available = max_version,
                "PersistedAuxiliaryInfoPruner: target_version exceeds available data, capping to available"
            );
            target_version = max_version;
        }
    }
    
    let mut batch = SchemaBatch::new();
    PersistedAuxiliaryInfoDb::prune(current_progress, target_version, &mut batch)?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::PersistedAuxiliaryInfoPrunerProgress,
        &DbMetadataValue::Version(target_version),
    )?;
    self.ledger_db
        .persisted_auxiliary_info_db()
        .write_schemas(batch)
}
```

Additionally, implement the TODO from line 272-273 of `aptosdb_writer.rs`:
- Add individual progress tracking for each sub-database
- Implement consistency checks at startup to detect and handle desyncs
- Consider using a two-phase commit pattern or write-ahead logging for critical metadata

## Proof of Concept

```rust
// Rust reproduction steps demonstrating the vulnerability:
// This would be added to storage/aptosdb/src/pruner/ledger_pruner/persisted_auxiliary_info_pruner_test.rs

#[test]
fn test_prune_beyond_available_data() {
    // Setup: Create a test database with limited auxiliary info
    let tmpdir = aptos_temppath::TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Commit transactions 0-500 with auxiliary info
    for i in 0..=500 {
        let aux_info = PersistedAuxiliaryInfo::V1 { transaction_index: i };
        db.ledger_db()
            .persisted_auxiliary_info_db()
            .commit_auxiliary_info(i, &[aux_info])
            .unwrap();
    }
    
    // Simulate desync: Set LedgerPrunerProgress to 700 (beyond available data)
    db.ledger_db()
        .metadata_db()
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerPrunerProgress,
            &DbMetadataValue::Version(700),
        )
        .unwrap();
    
    // Initialize pruner - it will try to catch up to metadata_progress=700
    let pruner = PersistedAuxiliaryInfoPruner::new(
        Arc::new(db.ledger_db().clone()),
        700, // metadata_progress
    ).unwrap();
    
    // Verify: All data 0-500 has been incorrectly deleted
    for i in 0..=500 {
        let result = db.ledger_db()
            .persisted_auxiliary_info_db()
            .get_persisted_auxiliary_info(i)
            .unwrap();
        assert!(result.is_none(), "Version {} should have been pruned", i);
    }
    
    // This demonstrates data loss: versions 0-500 deleted despite being needed
    // if the prune window would normally retain versions 401-700
}
```

## Notes

This vulnerability is a direct consequence of the acknowledged database consistency issue. The lack of validation allows the pruner to act on potentially incorrect metadata, causing cascading data loss. While `PersistedAuxiliaryInfo` is not critical for consensus, the loss of this metadata degrades node functionality and API reliability, justifying Medium severity.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L272-273)
```rust
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L276-318)
```rust
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L129-146)
```rust
        let metadata_progress = ledger_metadata_pruner.progress()?;

        info!(
            metadata_progress = metadata_progress,
            "Created ledger metadata pruner, start catching up all sub pruners."
        );

        let transaction_store = Arc::new(TransactionStore::new(Arc::clone(&ledger_db)));

        let event_store_pruner = Box::new(EventStorePruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
            internal_indexer_db.clone(),
        )?);
        let persisted_auxiliary_info_pruner = Box::new(PersistedAuxiliaryInfoPruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
        )?);
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/persisted_auxiliary_info_pruner.rs (L39-59)
```rust
    pub(in crate::pruner) fn new(
        ledger_db: Arc<LedgerDb>,
        metadata_progress: Version,
    ) -> Result<Self> {
        let progress = get_or_initialize_subpruner_progress(
            ledger_db.persisted_auxiliary_info_db_raw(),
            &DbMetadataKey::PersistedAuxiliaryInfoPrunerProgress,
            metadata_progress,
        )?;

        let myself = PersistedAuxiliaryInfoPruner { ledger_db };

        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up PersistedAuxiliaryInfoPruner."
        );
        myself.prune(progress, metadata_progress)?;

        Ok(myself)
    }
```

**File:** storage/aptosdb/src/ledger_db/persisted_auxiliary_info_db.rs (L121-126)
```rust
    pub(crate) fn prune(begin: Version, end: Version, batch: &mut SchemaBatch) -> Result<()> {
        for version in begin..end {
            batch.delete::<PersistedAuxiliaryInfoSchema>(&version)?;
        }
        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L3307-3318)
```rust
pub enum PersistedAuxiliaryInfo {
    None,
    // The index of the transaction in a block (after shuffler, before execution).
    // Note that this would be slightly different from the index of transactions that get committed
    // onchain, as this considers transactions that may get discarded.
    V1 { transaction_index: u32 },
    // When we are doing a simulation or validation of transactions, the transaction is not executed
    // within the context of a block. The timestamp is not yet assigned, but we still track the
    // transaction index for multi-transaction simulations. For single transaction simulation or
    // validation, the transaction index is set to 0.
    TimestampNotYetAssignedV1 { transaction_index: u32 },
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L115-122)
```rust
        gauged_api("get_persisted_auxiliary_info_by_version", || {
            self.error_if_ledger_pruned("PersistedAuxiliaryInfo", version)?;
            Ok(self
                .ledger_db
                .persisted_auxiliary_info_db()
                .get_persisted_auxiliary_info(version)?
                .unwrap_or(PersistedAuxiliaryInfo::None))
        })
```
