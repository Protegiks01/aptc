# Audit Report

## Title
DAG Consensus Node Crash on Schema Evolution Due to Missing BCS Serialization Migration

## Summary
Adding new fields to `Node`, `Vote`, or `CertifiedNode` types causes validator crashes on restart due to BCS deserialization failures when loading persisted consensus data. The `DagDriver` initialization uses `.expect()` when reading pending nodes from storage, causing a panic instead of graceful degradation.

## Finding Description

The DAG consensus database schemas use BCS (Binary Canonical Serialization) for `Node`, `Vote`, and `CertifiedNode` types without any schema migration support or backward compatibility mechanisms. [1](#0-0) 

The type definitions lack `Option<T>` fields or `#[serde(default)]` attributes that would enable backward-compatible deserialization: [2](#0-1) 

During validator startup, the `DagDriver::new()` function attempts to load pending node data from storage using `.expect()`, which panics on deserialization errors rather than handling them gracefully: [3](#0-2) 

**Attack Scenario:**
1. Developers add a new field to the `Node` struct (e.g., adding metadata or consensus extensions)
2. Code is deployed to validators as an upgrade
3. Validators restart with the new code
4. ConsensusDB contains old serialized `Node` data from before the upgrade
5. `DagDriver::new()` calls `storage.get_pending_node()`
6. BCS deserialization fails due to field count mismatch between old data and new schema
7. `.expect()` causes validator process to panic and crash
8. Validator cannot restart until database is manually cleared
9. If enough validators crash simultaneously, network loses liveness

**Broken Invariants:**
- **Consensus Safety**: Network-wide validator crashes can break liveness (though not safety)
- **Operational Continuity**: Validators should gracefully handle upgrades without manual intervention

## Impact Explanation

This is a **HIGH Severity** vulnerability per Aptos bug bounty criteria:
- **Validator node slowdowns/crashes**: All validators with pending DAG consensus data will crash on restart after schema changes
- **Significant protocol violations**: Breaks the expectation that validators can upgrade without manual database intervention
- **Potential liveness impact**: If coordinated upgrades cause simultaneous crashes across >1/3 of validators, the network loses liveness until operators manually clear databases

While not reaching Critical severity (no permanent data loss or hardfork required), this represents a serious operational risk that could manifest during routine upgrades.

## Likelihood Explanation

**HIGH likelihood** of occurrence:
- Happens automatically during any upgrade that modifies `Node`, `Vote`, or `CertifiedNode` struct definitions
- No attacker action required - this is a deterministic failure mode
- DAG consensus actively persists these objects to disk during normal operation
- The codebase shows no schema versioning or migration framework for these types
- Common software evolution pattern (adding fields) directly triggers the bug

**Mitigating factors:**
- `Vote` and `CertifiedNode` have graceful fallback via `.unwrap_or_default()` in other code paths: [4](#0-3)  and [5](#0-4) 
- Only `Node` deserialization via `get_pending_node()` uses panic-inducing `.expect()`
- Operators can preemptively clear databases before upgrades (though undocumented)

## Recommendation

Implement one of the following solutions:

**Option 1: Graceful Degradation (Immediate Fix)**
Replace `.expect()` with `.unwrap_or(None)` to match the pattern used for other deserialization calls:

```rust
// In consensus/src/dag/dag_driver.rs around line 90-92
let pending_node = storage
    .get_pending_node()
    .unwrap_or(None); // Returns None on deserialization error instead of panicking
```

**Option 2: Schema Versioning (Long-term Fix)**
Add version tags to serialized data and implement migration logic:

```rust
#[derive(Serialize, Deserialize)]
struct VersionedNode {
    version: u32,
    #[serde(flatten)]
    data: Node,
}

impl ValueCodec<NodeSchema> for Node {
    fn decode_value(data: &[u8]) -> Result<Self> {
        // Try new version first, fallback to old versions
        match bcs::from_bytes::<VersionedNode>(data) {
            Ok(versioned) => Ok(versioned.data),
            Err(_) => {
                // Try legacy deserialization
                bcs::from_bytes::<NodeV1>(data).map(|old| old.upgrade())
            }
        }
    }
}
```

**Option 3: Database Clearing on Upgrade**
Document that operators must clear ConsensusDB before schema-changing upgrades, or automate this via upgrade scripts.

## Proof of Concept

```rust
// Reproduction steps:

// 1. Start with original Node definition
#[derive(Serialize, Deserialize)]
pub struct Node {
    metadata: NodeMetadata,
    validator_txns: Vec<ValidatorTransaction>,
    payload: Payload,
    parents: Vec<NodeCertificate>,
    extensions: Extensions,
}

// 2. Serialize and persist a Node
let node = Node::new(...);
db.put::<NodeSchema>(&(), &node).unwrap();

// 3. Upgrade code with new field added
#[derive(Serialize, Deserialize)]
pub struct Node {
    metadata: NodeMetadata,
    validator_txns: Vec<ValidatorTransaction>,
    payload: Payload,
    parents: Vec<NodeCertificate>,
    extensions: Extensions,
    new_field: u64, // NEW FIELD ADDED
}

// 4. Attempt to read old data with new schema
let result = db.get::<NodeSchema>(&());
// BCS deserialization fails: "trailing bytes" or "missing field" error

// 5. In DagDriver::new(), this causes panic:
let pending_node = storage
    .get_pending_node()
    .expect("should be able to read dag storage"); // PANICS HERE
```

**Test case to verify the vulnerability:**
```rust
#[test]
fn test_node_schema_evolution_crash() {
    let tmp_dir = TempPath::new();
    let db = ConsensusDB::new(&tmp_dir);
    
    // Serialize Node with old schema
    let old_node_bytes = bcs::to_bytes(&create_old_node()).unwrap();
    
    // Manually write to DB
    db.put_raw(NodeSchema::COLUMN_FAMILY_NAME, &[], &old_node_bytes).unwrap();
    
    // Try to deserialize with new schema expecting additional field
    let result = db.get::<NodeSchema>(&());
    
    assert!(result.is_err()); // Deserialization fails
    
    // This would panic in production code:
    // let node = result.expect("should be able to read dag storage");
}
```

## Notes

The vulnerability is **partially mitigated** for `Vote` and `CertifiedNode` types because their loading paths use `.unwrap_or_default()` for graceful fallback. However, the `Node` type's loading path in `DagDriver::new()` remains vulnerable to panic-on-deserialization, creating a validator crash scenario during schema evolution.

### Citations

**File:** consensus/src/consensusdb/schema/dag/mod.rs (L35-43)
```rust
impl ValueCodec<NodeSchema> for Node {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** consensus/src/dag/types.rs (L152-159)
```rust
#[derive(Clone, Serialize, Deserialize, CryptoHasher, Debug, PartialEq)]
pub struct Node {
    metadata: NodeMetadata,
    validator_txns: Vec<ValidatorTransaction>,
    payload: Payload,
    parents: Vec<NodeCertificate>,
    extensions: Extensions,
}
```

**File:** consensus/src/dag/dag_driver.rs (L90-92)
```rust
        let pending_node = storage
            .get_pending_node()
            .expect("should be able to read dag storage");
```

**File:** consensus/src/dag/dag_store.rs (L461-461)
```rust
        let mut all_nodes = storage.get_certified_nodes().unwrap_or_default();
```

**File:** consensus/src/dag/rb_handler.rs (L194-194)
```rust
    let all_votes = storage.get_votes().unwrap_or_default();
```
