# Audit Report

## Title
Missing Threshold Validation Allows Governance to DoS Randomness Feature via Extreme DKG Parameters

## Summary
The Move-based `randomness_config` module lacks validation of cryptographic threshold parameters, allowing governance proposals to set extreme or inverted values (e.g., secrecy=99%, reconstruction=1%) that bypass intended constraints and render the randomness feature unusable without causing validator nodes to reject the configuration.

## Finding Description

The Aptos randomness system relies on Distributed Key Generation (DKG) with two critical threshold parameters: `secrecy_threshold` and `reconstruction_threshold`. These must satisfy cryptographic constraints where `secrecy_threshold < reconstruction_threshold ≤ 2/3` (66.67%).

The vulnerability exists in the configuration update path: [1](#0-0) 

This Move function accepts arbitrary `FixedPoint64` threshold values without any validation. A malicious governance proposal can set:
- Inverted thresholds: secrecy=75%, reconstruction=60%
- Extreme thresholds: secrecy=99%, reconstruction=1%
- Values exceeding the 66.67% cryptographic upper bound

When these invalid configurations are applied during epoch transitions, the Rust DKG initialization attempts automatic correction: [2](#0-1) 

For inverted thresholds (e.g., secrecy=99%, reconstruction=1%), this adjusts to secrecy=99%, reconstruction=99%+DELTA. However, this violates the cryptographic upper bound check: [3](#0-2) 

When the upper bound check fails, the system falls back to the "infallible" method: [4](#0-3) 

The infallible method accepts the extreme values, resulting in a DKG configuration that requires >99% of validators to be online to reconstruct randomness—making the feature practically unusable in normal operation.

**Attack Path:**
1. Attacker submits governance proposal calling `randomness_config::set_for_next_epoch()` with secrecy=99%, reconstruction=1%
2. Move validation passes (no checks exist)
3. Configuration stored on-chain via config buffer: [5](#0-4) 
4. At epoch boundary, configuration applied: [6](#0-5) 
5. DKG initialization reads extreme thresholds and uses infallible fallback
6. Randomness becomes unavailable due to impractical liveness requirements

## Impact Explanation

This qualifies as **Medium severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The actual DKG parameters differ from governance-approved values due to silent auto-correction
- **Protocol violation**: Randomness feature becomes unavailable, impacting any dApps or protocol features depending on on-chain randomness
- Not Critical severity because consensus continues normally and no funds are at risk
- Not High severity because validator nodes don't crash, only the randomness subsystem is affected

The impact is significant because Aptos randomness is used for security-critical operations, and its unavailability could affect the entire ecosystem of randomness-dependent applications.

## Likelihood Explanation

**High likelihood** of exploitation:
- Governance proposals are public and can be submitted by any participant meeting voting requirements
- No special technical knowledge required—attacker only needs to call Move functions with invalid parameters
- The vulnerability is persistent once exploited until corrected by another governance proposal
- No detection mechanisms exist at the Move level to alert governance participants to invalid parameters

The attack is straightforward: generate a governance proposal using the standard release builder infrastructure with modified threshold values outside safe ranges.

## Recommendation

Add validation to the Move-level configuration functions to reject invalid threshold combinations before they are stored on-chain:

```move
public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
    // Validate thresholds are within cryptographically safe bounds
    assert!(
        fixed_point64::less_or_equal(secrecy_threshold, reconstruction_threshold),
        error::invalid_argument(EINVALID_THRESHOLD_ORDER)
    );
    
    // Enforce upper bound: reconstruction_threshold <= 2/3
    let two_thirds = fixed_point64::create_from_rational(2, 3);
    assert!(
        fixed_point64::less_or_equal(reconstruction_threshold, two_thirds),
        error::invalid_argument(EINVALID_THRESHOLD_UPPER_BOUND)
    );
    
    // Enforce lower bound: secrecy_threshold >= 1/3
    let one_third = fixed_point64::create_from_rational(1, 3);
    assert!(
        fixed_point64::greater_or_equal(secrecy_threshold, one_third),
        error::invalid_argument(EINVALID_THRESHOLD_LOWER_BOUND)
    );
    
    RandomnessConfig {
        variant: copyable_any::pack( ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold
        } )
    }
}
```

Add corresponding error constants at the module level and apply similar validation to `new_v2()`.

## Proof of Concept

```move
#[test(framework = @0x1)]
#[expected_failure(abort_code = EINVALID_THRESHOLD_ORDER)]
fun test_inverted_thresholds(framework: signer) {
    use aptos_std::fixed_point64;
    
    // Attempt to create config with secrecy > reconstruction
    let bad_config = randomness_config::new_v1(
        fixed_point64::create_from_rational(75, 100),  // 75% secrecy
        fixed_point64::create_from_rational(60, 100)   // 60% reconstruction
    );
}

#[test(framework = @0x1)]
#[expected_failure(abort_code = EINVALID_THRESHOLD_UPPER_BOUND)]
fun test_extreme_thresholds(framework: signer) {
    use aptos_std::fixed_point64;
    
    // Attempt to create config exceeding 2/3 upper bound
    let bad_config = randomness_config::new_v1(
        fixed_point64::create_from_rational(50, 100),  // 50% secrecy
        fixed_point64::create_from_rational(80, 100)   // 80% reconstruction (> 2/3)
    );
}
```

The current implementation allows both test cases to pass without validation, demonstrating the vulnerability.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L53-56)
```text
    public fun set_for_next_epoch(framework: &signer, new_config: RandomnessConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(new_config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L59-68)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires RandomnessConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<RandomnessConfig>()) {
            let new_config = config_buffer::extract_v2<RandomnessConfig>();
            if (exists<RandomnessConfig>(@aptos_framework)) {
                *borrow_global_mut<RandomnessConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-99)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L67-70)
```rust
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L198-199)
```rust
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-266)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );
```
