# Audit Report

## Title
Incomplete Epoch History Allows Unverified Ledger Info Acceptance During Backup Restore

## Summary
The `EpochHistory::verify_ledger_info()` function contains inconsistent validation logic that allows ledger infos from epochs beyond available epoch history to bypass cryptographic verification during backup restore operations, potentially leading to state corruption.

## Finding Description
The vulnerability exists in the epoch ending restore verification logic. When verifying ledger infos during backup restoration, the function exhibits asymmetric behavior: [1](#0-0) 

This check prevents verification when `epoch_endings` is completely empty by returning an error. However, the subsequent check exhibits different behavior: [2](#0-1) 

When the epoch being verified exceeds the length of available epoch history, the function returns `Ok()` with only a warning, allowing unverified ledger infos to proceed. The TODO comment indicates this is a known design limitation.

This creates an exploitable inconsistency: an `EpochHistory` with minimal epoch history (e.g., only epoch 0) will accept ledger infos from much later epochs (e.g., epoch 100) without performing BLS signature verification or validator set verification.

**Attack Path:**

1. An `EpochHistory` can be created with insufficient history: [3](#0-2) 

2. During transaction restore, this insufficient epoch history is used: [4](#0-3) 

3. When transaction chunks are loaded, verification is called but bypassed: [5](#0-4) 

4. Unverified ledger infos are saved to the database: [6](#0-5) 

An attacker providing a malicious backup with valid epoch 0 data but fabricated ledger infos for later epochs could inject unverified state into a restored node, breaking the **Cryptographic Correctness** invariant that requires proper BLS signature validation.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria ("State inconsistencies requiring intervention") because:

- Corrupted ledger infos in the database lead to state inconsistencies
- Affected nodes may experience consensus disagreement with honest validators
- Node recovery requires manual intervention to identify and fix corrupted state
- Does not directly cause fund loss but compromises data integrity
- Limited to nodes restoring from malicious backup sources

The vulnerability breaks the fundamental assumption that all ledger infos in storage have been cryptographically verified against the validator set.

## Likelihood Explanation
Likelihood is **Medium** because:

- Requires the node operator to restore from an attacker-controlled backup source
- Attackers would need to compromise backup storage infrastructure or conduct social engineering
- The vulnerability is documented via TODO comment, suggesting developers are aware but haven't prioritized fixing it
- Restoration from untrusted backups is a realistic scenario in disaster recovery situations
- No validator privileges required for exploitation

## Recommendation
Implement consistent verification logic that either:

**Option 1 (Strict):** Reject ledger infos that cannot be verified due to insufficient epoch history:
```rust
pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
    let epoch = li_with_sigs.ledger_info().epoch();
    ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.");
    
    // Reject instead of accepting unverifiable epochs
    ensure!(
        epoch <= self.epoch_endings.len() as u64,
        "Epoch {} is beyond available epoch history ({}). Cannot verify.",
        epoch,
        self.epoch_endings.len()
    );
    
    // ... rest of verification logic
}
```

**Option 2 (Permissive):** Make the behavior explicit and require trusted waypoints for unverifiable epochs:
```rust
if epoch > self.epoch_endings.len() as u64 {
    // Only accept if we have a trusted waypoint for this exact version
    if let Some(wp_trusted) = self.trusted_waypoints.get(&li_with_sigs.ledger_info().version()) {
        let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
        ensure!(
            *wp_trusted == wp_li,
            "Waypoints don't match. In backup: {}, trusted: {}",
            wp_li,
            wp_trusted
        );
        return Ok(());
    }
    
    bail!(
        "Epoch {} is too new (history until epoch {}) and no trusted waypoint available. \
        Provide trusted waypoint or restore epoch history first.",
        epoch,
        self.epoch_endings.len()
    );
}
```

Additionally, ensure epoch history restoration completes before transaction restoration, or require explicit operator acknowledgment when restoring with incomplete epoch history.

## Proof of Concept
```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_insufficient_epoch_history_bypass() {
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_types::block_info::BlockInfo;
    use aptos_crypto::HashValue;
    
    // Create EpochHistory with only epoch 0
    let genesis_li = LedgerInfo::new(
        BlockInfo::genesis(HashValue::zero(), ValidatorSet::empty()),
        HashValue::zero(),
    );
    let epoch_history = EpochHistory {
        epoch_endings: vec![genesis_li],
        trusted_waypoints: Arc::new(HashMap::new()),
    };
    
    // Create a malicious ledger info from epoch 100 with invalid signatures
    let malicious_li = LedgerInfo::new(
        BlockInfo::new(
            100, // epoch 100
            0,
            HashValue::random(),
            HashValue::random(),
            0,
            0,
            None,
        ),
        HashValue::random(),
    );
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        malicious_li,
        AggregateSignature::empty(), // Invalid/empty signatures
    );
    
    // This should fail but returns Ok() due to the vulnerability
    let result = epoch_history.verify_ledger_info(&malicious_li_with_sigs);
    
    // BUG: Verification succeeds despite invalid signatures and insufficient history
    assert!(result.is_ok(), "Malicious ledger info bypassed verification!");
}
```

This test demonstrates that ledger infos with invalid signatures from epochs beyond available history are accepted without proper verification, confirming the vulnerability.

## Notes
The vulnerability specifically manifests when:
- Backup restoration includes transaction chunks from epochs not covered by epoch ending backups
- The `skip_epoch_endings` flag causes minimal or no epoch history to be available
- Operators restore from untrusted or compromised backup sources

The inconsistency between returning an error for completely empty history (line 278) versus returning `Ok()` for insufficient history (line 287) creates confusion about the security guarantees and allows exploitation.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L249-249)
```rust
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L278-278)
```rust
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L353-358)
```rust
        if self.manifest_handles.is_empty() {
            return Ok(EpochHistory {
                epoch_endings: Vec::new(),
                trusted_waypoints: Arc::new(HashMap::new()),
            });
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```
