# Audit Report

## Title
UTF-8 Character Boundary Panic in Indexer String Truncation Causes Denial of Service

## Summary
The indexer's `truncate_str` function uses `String::truncate()` which operates on byte indices, not character boundaries. When combined with a mismatch between Move contract limits (32 bytes for coin symbols) and indexer truncation limits (10 bytes), an attacker can create a coin with a symbol containing multi-byte UTF-8 characters positioned to cause a panic when truncated at byte 10, crashing the indexer service.

## Finding Description
The vulnerability exists in the string truncation mechanism used throughout the Aptos indexer. The core issue is in the `truncate_str` utility function: [1](#0-0) 

This function uses Rust's `String::truncate(max_chars)` which truncates to a **byte length**, not a character length. According to Rust documentation, `String::truncate()` **panics** if the truncation index does not lie on a UTF-8 character boundary.

The critical vulnerability occurs due to a **limit mismatch** for coin symbols:

**Move Contract Limits:** [2](#0-1) 

The Move contract validates symbols up to 32 bytes: [3](#0-2) 

**Indexer Truncation:** [4](#0-3) 

The indexer truncates coin symbols to only **10 bytes**, while the Move contract allows up to 32 bytes.

**Attack Path:**
1. Attacker creates a coin with symbol like "ABCðŸ”¥ðŸ”¥" (3 ASCII bytes + 8 emoji bytes = 11 total bytes)
2. Each ðŸ”¥ emoji is 4 bytes in UTF-8: `[0xF0, 0x9F, 0x94, 0xA5]`
3. Byte layout: `A(0x41) B(0x42) C(0x43) [0xF0 0x9F 0x94 0xA5] [0xF0 0x9F 0x94...]`
4. When indexer processes this coin and calls `get_symbol_trunc()`, it attempts `truncate_str(&symbol, 10)`
5. Truncating at byte 10 splits the second emoji after its 3rd byte
6. Byte 10 is NOT on a valid UTF-8 character boundary â†’ **panic!**
7. Indexer service crashes

The truncation is used when storing coin info data: [5](#0-4) 

Similar vulnerabilities exist for token names/URIs but the limits match (128/512 bytes), making exploitation less likely unless the strings are exactly at the limit with multi-byte characters at boundaries.

## Impact Explanation
This vulnerability falls under **High Severity** per the Aptos bug bounty program, specifically the "API crashes" category (up to $50,000).

**Impact:**
- **Denial of Service**: The indexer service crashes repeatedly when processing the malicious coin data
- **Infrastructure Disruption**: The indexer is critical infrastructure that processes blockchain events and makes them queryable
- **dApp Disruption**: Applications relying on indexed data lose functionality
- **Manual Intervention Required**: Operators must manually skip or fix the problematic transaction data
- **Persistent Attack**: Once the malicious coin is created on-chain, every indexer that processes it will crash

While this does not affect blockchain consensus or validator nodes (which continue operating normally), the indexer is essential infrastructure for the Aptos ecosystem. The vulnerability allows any unprivileged user to take down indexer services.

## Likelihood Explanation
**Likelihood: HIGH**

- **No Special Permissions Required**: Any user can create a coin with arbitrary metadata
- **Low Complexity**: Attack requires only basic understanding of UTF-8 encoding
- **Easy to Execute**: Creating a coin with the exploit string is straightforward
- **Guaranteed Impact**: The panic is deterministic when the conditions are met
- **Low Cost**: Creating a coin is relatively inexpensive on-chain

**Concrete Example:**
A coin symbol of "ABCðŸ”¥ðŸ”¥" (or any string >10 bytes with multi-byte character at byte boundary) will reliably crash the indexer.

## Recommendation
Fix the `truncate_str` function to properly handle UTF-8 character boundaries:

```rust
pub fn truncate_str(val: &str, max_bytes: usize) -> String {
    if val.len() <= max_bytes {
        return val.to_string();
    }
    
    // Find the last valid character boundary at or before max_bytes
    let mut idx = max_bytes;
    while idx > 0 && !val.is_char_boundary(idx) {
        idx -= 1;
    }
    
    val[..idx].to_string()
}
```

**Alternative Recommendation:**
Align the indexer truncation limits with the Move contract limits to avoid truncation in the first place:
- Change coin symbol truncation from 10 to 32 bytes
- Adjust database schema if necessary to accommodate the full length

**Database Schema Update:**
If database columns are limiting factors, increase VARCHAR sizes to match Move contract limits and adjust truncation accordingly.

## Proof of Concept

**Move Script to Create Malicious Coin:**

```move
script {
    use std::string;
    use aptos_framework::coin;
    use aptos_framework::managed_coin;
    
    fun exploit_coin_symbol_truncation(account: &signer) {
        // Create a coin with symbol that will cause indexer panic
        // "ABCðŸ”¥ðŸ”¥" = 3 bytes ASCII + 4 bytes emoji + 4 bytes emoji = 11 bytes
        // Truncating at byte 10 splits the second emoji
        let name = string::utf8(b"Exploit Coin");
        let symbol = string::utf8(b"ABC\xF0\x9F\x94\xA5\xF0\x9F\x94\xA5"); // ABCðŸ”¥ðŸ”¥
        
        managed_coin::initialize<ExploitCoin>(
            account,
            name,
            symbol,
            8, // decimals
            true // monitor_supply
        );
    }
}
```

**Rust Test to Verify Panic:**

```rust
#[test]
#[should_panic(expected = "byte index 10 is not a char boundary")]
fn test_truncate_str_panic() {
    use crate::util::truncate_str;
    
    // Create a string with multi-byte character at byte 10
    let symbol = "ABCðŸ”¥ðŸ”¥"; // 3 + 4 + 4 = 11 bytes
    
    // This will panic because byte 10 is inside the second emoji
    let _ = truncate_str(symbol, 10);
}
```

**Expected Behavior:**
1. User creates coin with the malicious symbol
2. Transaction succeeds and is included in a block
3. Indexer processes the transaction
4. When storing coin info, it calls `get_symbol_trunc()`
5. `truncate_str(&symbol, 10)` is called
6. `String::truncate(10)` panics with: "byte index 10 is not a char boundary"
7. Indexer thread crashes
8. Indexer cannot progress past this transaction without manual intervention

## Notes
This vulnerability specifically affects the coin symbol truncation due to the mismatch between Move contract limits (32 bytes) and indexer limits (10 bytes). While similar truncation functions exist for token names/URIs, those have matching limits (128/512 bytes) making exploitation require the string to be exactly at the limit, which is less likely but still theoretically possible. The coin symbol case is the most exploitable due to the significant gap between validation and truncation limits.

### Citations

**File:** crates/indexer/src/util.rs (L23-27)
```rust
pub fn truncate_str(val: &str, max_chars: usize) -> String {
    let mut trunc = val.to_string();
    trunc.truncate(max_chars);
    trunc
}
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L125-126)
```text
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    const MAX_COIN_SYMBOL_LENGTH: u64 = 32;
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1074-1077)
```text
        assert!(
            string::length(&symbol) <= MAX_COIN_SYMBOL_LENGTH,
            error::invalid_argument(ECOIN_SYMBOL_TOO_LONG)
        );
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L30-36)
```rust
    pub fn get_name_trunc(&self) -> String {
        truncate_str(&self.name, 32)
    }

    pub fn get_symbol_trunc(&self) -> String {
        truncate_str(&self.symbol, 10)
    }
```
