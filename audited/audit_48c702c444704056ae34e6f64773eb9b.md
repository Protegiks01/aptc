# Audit Report

## Title
Tokio-Console Network Exposure Vulnerability: Unauthenticated Debugging Server Bound to All Network Interfaces on Validator Nodes

## Summary
The tokio-console debugging feature, when compiled into production validator binaries, opens an unauthenticated network server on port 6669 (default) bound to `0.0.0.0` (all network interfaces). This exposes sensitive real-time task execution metrics, timing information, and internal system state to potential attackers, enabling information disclosure attacks that could facilitate consensus timing attacks or validator profiling. [1](#0-0) 

## Finding Description

The tokio-console feature is designed as a debugging tool for monitoring async task execution. When enabled at compile time and configured at runtime, the `set_global_logger` function initializes a `ConsoleLayer` server that binds to all network interfaces rather than localhost. [2](#0-1) 

The critical security flaw is on the server binding address: the code explicitly binds to `([0, 0, 0, 0], tokio_console_port)` which translates to `0.0.0.0:6669`. This makes the debugging server accessible from ANY network interface, not just localhost. [3](#0-2) 

**Attack Path:**

1. A validator operator builds aptos-node with the `tokio-console` feature enabled (either intentionally for debugging or inadvertently through build scripts)
2. The configuration optimizer automatically sets `tokio_console_port` to 6669 if the feature is enabled but no explicit port is configured [4](#0-3) 

3. The validator node starts and opens port 6669 on all network interfaces with no authentication
4. The port is not protected by HAProxy or Kubernetes NetworkPolicy (verified by examining production configurations) [5](#0-4) 

5. An attacker on the same network or internet (if firewall rules permit) connects to `validator_ip:6669` using the tokio-console client
6. The attacker gains real-time access to:
   - Task execution timing and scheduling information
   - Task names revealing internal consensus operations
   - Resource utilization patterns
   - Async runtime state

**Information Exposed:**

The tokio-console protocol exposes detailed instrumentation data including task spawn times, execution durations, waker counts, and task locations in source code. For a consensus-critical system like Aptos, this information could be leveraged to:
- Profile consensus round timing to predict block proposals
- Identify resource bottlenecks for targeted DoS attacks  
- Map internal validator state machine transitions
- Extract timing side-channels for cryptographic operations

## Impact Explanation

This vulnerability qualifies as **HIGH severity** according to Aptos bug bounty criteria:

**Impact Category: Information Disclosure Leading to Validator Security Compromise**

While this is not a direct consensus violation or fund theft, it enables sophisticated attacks through information disclosure:

1. **Consensus Timing Attacks**: Real-time visibility into consensus task scheduling could allow adversaries to predict when specific validators will propose blocks, enabling targeted network attacks at critical moments.

2. **Validator Profiling**: Attackers can build detailed profiles of validator performance characteristics, identifying weaker nodes for targeted attacks.

3. **Side-Channel Information Leakage**: Task timing information could expose cryptographic operation timing, enabling side-channel attacks on signature generation or verification.

4. **Attack Surface Reconnaissance**: Task names and execution patterns reveal internal implementation details that could aid in discovering other vulnerabilities.

The lack of authentication means ANY network-accessible attacker can exploit this vulnerability. The binding to `0.0.0.0` instead of `127.0.0.1` demonstrates a failure to follow the security principle of least privilege for debugging interfaces.

## Likelihood Explanation

**Likelihood: MEDIUM**

While this vulnerability requires the `tokio-console` feature to be compiled into production binaries (not included in default features), several factors increase the likelihood: [6](#0-5) 

1. **No Security Warnings**: The codebase contains no explicit warnings against using tokio-console in production environments. The only documentation describes it as a "debugging" feature without security implications.

2. **Automatic Port Assignment**: The config optimizer silently enables the port when the feature is present, making it easy to accidentally expose.

3. **Global tokio_unstable Flag**: The `.cargo/config.toml` sets `tokio_unstable` globally for all builds, making tokio-console functionality available if the feature flag is set. [7](#0-6) 

4. **Plausible Deployment Scenarios**:
   - Developer builds with debugging features for troubleshooting then forgets to rebuild without them
   - CI/CD pipelines that enable "all features" for maximum flexibility
   - Validator operators who enable debugging features "just in case" they need them later

5. **No Network Policy Protection**: Production HAProxy and NetworkPolicy configurations don't explicitly block port 6669, meaning network-level defenses may not prevent exploitation.

## Recommendation

Implement defense-in-depth protections for the tokio-console feature:

**1. Bind to Localhost Only (Critical Fix):**

Modify `crates/aptos-logger/src/logger.rs` to bind to `127.0.0.1` instead of `0.0.0.0`:

```rust
let console_layer = console_subscriber::ConsoleLayer::builder()
    .server_addr(([127, 0, 0, 1], tokio_console_port))  // Changed from [0,0,0,0]
    .spawn();
```

**2. Add Explicit Production Warning:**

Add configuration validation that errors on production builds:

```rust
// In config/src/config/logger_config.rs sanitizer
if is_tokio_console_enabled() && node_type == NodeType::Validator {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "SECURITY WARNING: tokio-console feature must not be enabled on production validators. \
         This debugging feature exposes sensitive runtime information without authentication. \
         Rebuild without --features tokio-console".into(),
    ));
}
```

**3. Require Explicit Opt-In:**

Remove the automatic port assignment in the config optimizer to require explicit configuration.

**4. Add Authentication Layer:**

Consider wrapping the console server with authentication (e.g., API token) if remote debugging is genuinely needed.

**5. Update Documentation:**

Add prominent security warnings in relevant documentation and code comments explaining the security implications.

## Proof of Concept

**Step 1: Build with tokio-console feature**
```bash
cd aptos-core
cargo build --release --features tokio-console -p aptos-node
```

**Step 2: Run validator with default configuration**
```bash
./target/release/aptos-node -f validator_config.yaml
# The node will automatically set tokio_console_port to 6669
```

**Step 3: From attacker machine on same network**
```bash
# Install tokio-console client
cargo install tokio-console

# Connect to exposed validator (no authentication required)
tokio-console http://VALIDATOR_IP:6669

# Observe real-time task execution, timing, and internal state
# Task names reveal consensus operations: "consensus_round_manager", 
# "block_executor", "state_sync", etc.
```

**Expected Observation:**
The attacker gains full visibility into the validator's async runtime, observing task scheduling patterns, execution durations, and resource usage in real-time without any authentication challenge.

**Verification:**
To verify the vulnerability exists, check if port 6669 is listening on all interfaces:
```bash
# On the validator node
netstat -tlnp | grep 6669
# Should show: tcp 0.0.0.0:6669 LISTEN
# Vulnerable: bound to all interfaces
# Secure would show: 127.0.0.1:6669
```

---

**Notes**

This vulnerability represents a defense-in-depth failure where a debugging feature lacks proper security controls for production deployment. While exploitation requires the feature to be compiled in (reducing likelihood), the complete absence of authentication, binding to all interfaces, and lack of security warnings creates an unacceptable risk for validator infrastructure. The exposed timing and state information could enable sophisticated attacks against consensus or cryptographic operations, making this a legitimate HIGH severity security issue despite not being a direct exploit of consensus or execution logic.

### Citations

**File:** crates/aptos-logger/src/logger.rs (L54-64)
```rust
    #[cfg(feature = "tokio-console")]
    {
        if let Some(tokio_console_port) = tokio_console_port {
            let console_layer = console_subscriber::ConsoleLayer::builder()
                .server_addr(([0, 0, 0, 0], tokio_console_port))
                .spawn();

            tracing_subscriber::registry().with(console_layer).init();
            return;
        }
    }
```

**File:** config/src/config/logger_config.rs (L17-17)
```rust
const DEFAULT_TOKIO_CONSOLE_PORT: u16 = 6669;
```

**File:** config/src/config/logger_config.rs (L109-118)
```rust
        if local_logger_config_yaml["tokio_console_port"].is_null() {
            // If the tokio-console feature is enabled, set the default port.
            // Otherwise, disable the tokio console port.
            if is_tokio_console_enabled() {
                logger_config.tokio_console_port = Some(DEFAULT_TOKIO_CONSOLE_PORT);
            } else {
                logger_config.tokio_console_port = None;
            }
            modified_config = true;
        }
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L27-60)
```yaml
    ports:
      # AptosNet from HAproxy
    - protocol: TCP
      port: 6180
    - protocol: TCP
      port: 9101
  {{- if $.Values.service.validator.enableRestApi }}
      # REST API from HAproxy
    - protocol: TCP
      port: 8080
  {{- end }}
  # Monitoring metrics port
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: monitoring
    ports:
    - protocol: TCP
      port: 9101
  # Node Health Checker accesses these ports
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: node-health-checker
    ports:
    - protocol: TCP
      port: 9101
    - protocol: TCP
      port: 8080
    - protocol: TCP
      port: 6180

```

**File:** aptos-node/Cargo.toml (L94-97)
```text
default = []
failpoints = ["fail/failpoints", "aptos-consensus/failpoints", "aptos-executor/failpoints", "aptos-mempool/failpoints", "aptos-api/failpoints", "aptos-config/failpoints"]
indexer = ["aptos-indexer"]
tokio-console = ["aptos-logger/tokio-console", "aptos-config/tokio-console"]
```

**File:** .cargo/config.toml (L25-26)
```text
[build]
rustflags = ["--cfg", "tokio_unstable", "-C", "force-frame-pointers=yes", "-C", "force-unwind-tables=yes"]
```
