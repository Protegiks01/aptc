# Audit Report

## Title
State Version Inconsistency in REST Client Pagination Functions Causes Mixed-Version Data to Appear Atomic

## Summary
The REST client's pagination functions (`paginate_with_cursor` and `paginate_with_cursor_bcs`) combine data from multiple API calls but only return the `State` metadata from the final call. When the blockchain advances between paginated requests, clients receive a `Response` containing data from multiple ledger versions while the `State.version` field reports only the latest version, violating atomicity guarantees and potentially causing indexers and clients to process inconsistent state data.

## Finding Description

The vulnerability exists in two pagination functions in the REST client: [1](#0-0) [2](#0-1) 

These functions make multiple API calls in a loop to retrieve paginated data. The critical flaw is:

1. **When `ledger_version` parameter is NOT specified** (most common case): Each API call returns data from whatever the latest blockchain version is at that moment. If the blockchain advances between calls (which is normal in a live network), the function combines data from version N, version N+10, version N+25, etc., into a single result vector/map.

2. **Only the last call's State is returned**: Lines 1878-1881 and 1913-1916 show that only the State from the final paginated call is returned to the caller, discarding all previous State metadata.

3. **Result**: Clients receive `Response<Vec<T>>` where the data is from multiple versions, but `State.version` reports only the final version, creating the false impression that all data is from a single atomic blockchain state.

The API server correctly handles individual requests by setting response headers from `latest_ledger_info`: [3](#0-2) 

However, this means each pagination call gets different version headers as the chain progresses. The client combines the data but only keeps the last State.

This also affects `get_full_block_by_height_bcs`: [4](#0-3) 

This function fetches a block and then additional transaction pages, discarding the State from subsequent calls (line 235 uses `.into_inner()` which drops the State), then returns a Response with only the initial State despite combining transaction data from multiple calls.

The State structure contains the version information that clients rely on: [5](#0-4) 

## Impact Explanation

**Severity: Medium to High**

This vulnerability breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." While the blockchain itself maintains atomicity, the REST API client presents non-atomic, mixed-version data to applications as if it were atomic.

**Real-world impacts:**

1. **Indexer Data Corruption**: Blockchain indexers that use these pagination functions will store mixed-version data labeled with a single version number. Future historical queries will return incorrect state, affecting any applications relying on historical data (governance voting, reward calculations, analytics).

2. **Incorrect Application Logic**: Applications calculating account balances, checking resource states, or making decisions based on multiple resources will process inconsistent data. For example:
   - Get account resources for an address
   - Page 1: Token balance = 100 (at version 1000)
   - Blockchain advances, user transfers tokens
   - Page 2: Token metadata (at version 1010, after transfer)
   - Application sees State.version=1010 and calculates total based on mixed data

3. **Governance and Staking Errors**: Applications checking validator states, stake amounts, or governance proposal data across pagination could observe inconsistent states that don't reflect any actual point in blockchain history.

Per the Aptos bug bounty severity categories, this qualifies as **Medium Severity**: "State inconsistencies requiring intervention" - indexers and critical applications would need to re-sync their data if they've processed mixed-version states.

## Likelihood Explanation

**Likelihood: High**

This issue occurs automatically in normal operation:

- The blockchain produces new blocks every few seconds
- Any paginated API call taking more than a few seconds will span multiple versions
- The `paginate_with_cursor` functions are used by commonly-called methods like `get_account_resources()` and `get_account_modules()`
- No version parameter is specified by default in most client usage

The vulnerability requires no attacker action - it's an inherent design flaw that affects all clients using pagination without explicitly specifying a `ledger_version`.

## Recommendation

**Fix 1: Capture and validate version consistency**

Modify pagination functions to capture the State from the first call and validate that subsequent calls return the same version (when no explicit version is specified), or use the first call's version for all subsequent calls:

```rust
pub async fn paginate_with_cursor<T: for<'a> Deserialize<'a>>(
    &self,
    base_path: &str,
    limit_per_request: u64,
    ledger_version: Option<u64>,
) -> AptosResult<Response<Vec<T>>> {
    let mut result = Vec::new();
    let mut cursor: Option<String> = None;
    let mut first_state: Option<State> = None;
    let fixed_version: Option<u64>;

    loop {
        let url = self.build_url_for_pagination(
            base_path,
            limit_per_request,
            // Use the first call's version for subsequent calls
            fixed_version.or(ledger_version),
            &cursor,
        )?;
        let raw_response = self.inner.get(url).send().await?;
        let response: Response<Vec<T>> = self.json(raw_response).await?;
        
        // Capture first state and version
        if first_state.is_none() {
            first_state = Some(response.state().clone());
            fixed_version = Some(response.state().version);
        }
        
        cursor.clone_from(&response.state().cursor);
        if cursor.is_none() {
            // Return with the FIRST state, not the last
            break Ok(Response::new(
                {
                    result.extend(response.into_inner());
                    result
                },
                first_state.unwrap()
            ));
        } else {
            result.extend(response.into_inner());
        }
    }
}
```

**Fix 2: Document the behavior**

At minimum, add clear documentation warning users about version consistency when using pagination without specifying `ledger_version`, and recommend always specifying a version for atomic reads.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_pagination_version_inconsistency() {
    use aptos_rest_client::Client;
    use url::Url;
    
    // Setup: Create client pointing to live network or testnet
    let client = Client::new(Url::parse("https://fullnode.testnet.aptoslabs.com/v1").unwrap());
    
    // Get account resources with pagination (no version specified)
    // This will make multiple API calls as pagination occurs
    let response = client.get_account_resources(
        "0x1".parse().unwrap()
    ).await.unwrap();
    
    let state = response.state();
    let resources = response.inner();
    
    // Vulnerability: If pagination occurred across multiple versions,
    // some resources are from version X, others from version Y,
    // but state.version reports only the last version
    
    // In a real scenario, this could be:
    // - Resource 1-10: from version 1000
    // - Resource 11-20: from version 1005  
    // - Resource 21-30: from version 1010
    // But state.version = 1010, making the client think all 30 resources
    // are from version 1010, violating atomicity
    
    println!("Received {} resources at reported version {}", 
             resources.len(), state.version);
    println!("WARNING: These resources may be from different blockchain versions!");
}
```

**Notes**

This vulnerability is particularly insidious because:
- It occurs silently without any error or warning
- Clients have no way to detect when they've received mixed-version data
- The Response type's API contract implicitly suggests data atomicity
- Widely-used client methods like `get_account_resources()` are affected

The issue violates the fundamental expectation that a `Response<T>` with `State.version=X` contains data exclusively from ledger version X. This breaks state consistency guarantees that clients and indexers rely upon for correct operation.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L201-243)
```rust
    pub async fn get_full_block_by_height_bcs(
        &self,
        height: u64,
        page_size: u16,
    ) -> AptosResult<Response<BcsBlock>> {
        let (mut block, state) = self
            .get_block_by_height_bcs(height, true)
            .await?
            .into_parts();

        let mut current_version = block.first_version;

        // Set the current version to the last known transaction
        if let Some(ref txns) = block.transactions {
            if let Some(txn) = txns.last() {
                current_version = txn.version + 1;
            }
        } else {
            return Err(RestError::Unknown(anyhow!(
                "No transactions were returned in the block"
            )));
        }

        // Add in all transactions by paging through the other transactions
        while current_version <= block.last_version {
            let page_end_version =
                std::cmp::min(block.last_version, current_version + page_size as u64 - 1);

            let transactions = self
                .get_transactions_bcs(
                    Some(current_version),
                    Some((page_end_version - current_version + 1) as u16),
                )
                .await?
                .into_inner();
            if let Some(txn) = transactions.last() {
                current_version = txn.version + 1;
            };
            block.transactions.as_mut().unwrap().extend(transactions);
        }

        Ok(Response::new(block, state))
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1858-1886)
```rust
    pub async fn paginate_with_cursor<T: for<'a> Deserialize<'a>>(
        &self,
        base_path: &str,
        limit_per_request: u64,
        ledger_version: Option<u64>,
    ) -> AptosResult<Response<Vec<T>>> {
        let mut result = Vec::new();
        let mut cursor: Option<String> = None;

        loop {
            let url = self.build_url_for_pagination(
                base_path,
                limit_per_request,
                ledger_version,
                &cursor,
            )?;
            let raw_response = self.inner.get(url).send().await?;
            let response: Response<Vec<T>> = self.json(raw_response).await?;
            cursor.clone_from(&response.state().cursor);
            if cursor.is_none() {
                break Ok(response.map(|mut v| {
                    result.append(&mut v);
                    result
                }));
            } else {
                result.extend(response.into_inner());
            }
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1891-1921)
```rust
    pub async fn paginate_with_cursor_bcs<T: for<'a> Deserialize<'a> + Ord>(
        &self,
        base_path: &str,
        limit_per_request: u64,
        ledger_version: Option<u64>,
    ) -> AptosResult<Response<BTreeMap<T, Vec<u8>>>> {
        let mut result = BTreeMap::new();
        let mut cursor: Option<String> = None;

        loop {
            let url = self.build_url_for_pagination(
                base_path,
                limit_per_request,
                ledger_version,
                &cursor,
            )?;
            let response: Response<BTreeMap<T, Vec<u8>>> = self
                .get_bcs(url)
                .await?
                .and_then(|inner| bcs::from_bytes(&inner))?;
            cursor.clone_from(&response.state().cursor);
            if cursor.is_none() {
                break Ok(response.map(|mut v| {
                    result.append(&mut v);
                    result
                }));
            } else {
                result.extend(response.into_inner());
            }
        }
    }
```

**File:** api/src/response.rs (L376-390)
```rust
                match status {
                    $(
                    [<$enum_name Status>]::$name => {
                        $enum_name::$name(
                            value,
                            ledger_info.chain_id,
                            ledger_info.ledger_version.into(),
                            ledger_info.oldest_ledger_version.into(),
                            ledger_info.ledger_timestamp.into(),
                            ledger_info.epoch.into(),
                            ledger_info.block_height.into(),
                            ledger_info.oldest_block_height.into(),
                            None,
                            None,
                        )
```

**File:** crates/aptos-rest-client/src/state.rs (L10-20)
```rust
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct State {
    pub chain_id: u8,
    pub epoch: u64,
    pub version: u64,
    pub timestamp_usecs: u64,
    pub oldest_ledger_version: u64,
    pub oldest_block_height: u64,
    pub block_height: u64,
    pub cursor: Option<String>,
}
```
