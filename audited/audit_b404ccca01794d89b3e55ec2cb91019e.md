# Audit Report

## Title
Config Sanitization Bypass via Missing Genesis Transaction Allows Mainnet Validators to Run with Insecure Configurations

## Summary
A mainnet validator operator can bypass all chain-specific configuration security checks by omitting the genesis.blob file from their node configuration. This causes the config sanitization to execute with `chain_id = None`, which skips all mainnet-specific security validations, allowing the node to operate with critically unsafe configurations including in-memory SafetyRules storage, disabled VM paranoid checks, exposed configuration endpoints, and enabled failpoints. [1](#0-0) 

## Finding Description
The vulnerability exists in the config loading and sanitization flow. When `get_chain_id()` fails to extract a chain ID from the genesis transaction (because no genesis.blob file is provided), the error is caught and sanitization continues with `chain_id = None`: [2](#0-1) 

All config sanitizers use an `if let Some(chain_id) = chain_id` pattern to check mainnet status. When `chain_id = None`, these checks are completely bypassed:

**InspectionServiceConfig sanitization bypass:** [3](#0-2) 

**SafetyRulesConfig sanitization bypass (CRITICAL):** [4](#0-3) 

**ExecutionConfig sanitization bypass:** [5](#0-4) 

A node without genesis.blob can still sync to mainnet and participate in consensus because:
1. Genesis application is optional during bootstrap: [6](#0-5) 

2. The node can sync from a waypoint without genesis: [7](#0-6) 

This breaks multiple security invariants:
- **Consensus Safety**: SafetyRules with InMemoryStorage doesn't persist last voted round to disk, risking double-signing on restart
- **Deterministic Execution**: Disabled paranoid_type_verification and paranoid_hot_potato_verification bypass critical VM safety checks
- **Access Control**: Exposed configuration reveals network topology and security settings

## Impact Explanation
This vulnerability has **HIGH to CRITICAL** severity per Aptos bug bounty criteria:

**CRITICAL - Consensus Safety Violation**: SafetyRules with `backend: InMemoryStorage` means consensus safety state is not persisted to disk. If the validator restarts, it could:
- Violate safety rules by voting on conflicting blocks
- Double-sign blocks for the same round
- Break Byzantine fault tolerance if multiple validators are affected
- This directly threatens consensus safety invariant #2

**HIGH - VM Safety Bypass**: Disabled `paranoid_hot_potato_verification` and `paranoid_type_verification` remove critical runtime checks that ensure:
- Type safety during Move execution
- Linear type (hot potato) correctness
- This could lead to non-deterministic execution across validators (invariant #1 violation)

**MEDIUM - Information Disclosure**: Exposed configuration endpoints reveal sensitive validator information including network configuration, security settings, and operational details.

## Likelihood Explanation
**Likelihood: MEDIUM to HIGH**

**Requirements:**
- Validator operator control over their own node configuration
- Basic understanding of Aptos node setup
- No special privileges beyond normal validator operator access

**Ease of exploitation:**
- Trivial to execute: simply omit `genesis_file_location` from node config or provide invalid path
- No complex attack chains or timing requirements
- Works on any node syncing from a waypoint rather than genesis

**Realistic scenario:**
- Validator operators syncing from recent snapshots/waypoints commonly don't need genesis
- Documentation may not emphasize genesis requirement for config validation
- Operators might unknowingly deploy with this misconfiguration

## Recommendation

**Immediate Fix:** Enforce chain_id validation during config sanitization by requiring genesis.blob or fetching chain_id from a trusted source.

**Recommended Implementation:**

1. Make chain_id extraction mandatory during sanitization:

```rust
// In config/src/config/node_config_loader.rs
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    // Make chain_id required instead of optional
    let chain_id = get_chain_id(node_config)?;
    
    Ok((node_type, chain_id))
}
```

2. Update sanitize functions to fail-closed when chain_id is unavailable:

```rust
// In config/src/config/safety_rules_config.rs
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: ChainId, // No longer Option
    ) -> Result<(), Error> {
        // Checks always execute
        if node_type.is_validator() && chain_id.is_mainnet() 
            && safety_rules_config.backend.is_in_memory() 
        {
            return Err(Error::ConfigSanitizerFailed(...));
        }
        // ...
    }
}
```

3. Alternative: Fetch chain_id from trusted source (well-known mainnet peers, hardcoded endpoint) if genesis.blob is unavailable.

## Proof of Concept

**Setup to demonstrate vulnerability:**

1. Create a mainnet validator node config without genesis.blob:

```yaml
# validator_config.yaml
base:
  role: Validator
  waypoint:
    from_config: "1:abc123..." # Recent mainnet waypoint

execution:
  # genesis_file_location omitted or empty
  genesis_file_location: ""
  paranoid_type_verification: false  # Would be rejected if chain_id=mainnet
  paranoid_hot_potato_verification: false

consensus:
  safety_rules:
    backend:
      type: "in_memory_storage"  # Would be rejected if chain_id=mainnet
    test:
      author: "0x123"  # Would be rejected if chain_id=mainnet

inspection_service:
  expose_configuration: true  # Would be rejected if chain_id=mainnet

api:
  failpoints_enabled: true  # Would be rejected if chain_id=mainnet
```

2. Run node config loader:
```rust
// Demonstrates sanitization bypass
let node_config = NodeConfig::load_config("validator_config.yaml")?;
let mut node_config = node_config;
node_config.execution.load_from_path(&RootPath::new("validator_config.yaml"))?;

// This should fail but succeeds because chain_id=None
let result = optimize_and_sanitize_node_config(&mut node_config, local_config_yaml);
assert!(result.is_ok()); // Sanitization passes incorrectly
```

3. Verify unsafe configs are accepted:
```rust
assert_eq!(node_config.consensus.safety_rules.backend, SecureBackend::InMemoryStorage);
assert_eq!(node_config.execution.paranoid_type_verification, false);
assert_eq!(node_config.inspection_service.expose_configuration, true);
assert_eq!(node_config.api.failpoints_enabled, true);
// All unsafe configs accepted despite being mainnet-bound validator
```

**Notes**
The vulnerability exploits a fundamental assumption that genesis.blob is always present for proper chain identification. However, nodes syncing from waypoints may legitimately omit genesis, creating a security gap where mainnet-specific protections are silently disabled. The fix must ensure chain_id is obtained from a trusted source even when genesis is unavailable, or require genesis for all mainnet validators.

### Citations

**File:** config/src/config/node_config_loader.rs (L117-122)
```rust
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
```

**File:** config/src/config/node_config_loader.rs (L156-164)
```rust
/// Get the chain ID for the node from the genesis transaction.
/// If the chain ID cannot be extracted, an error is returned.
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;
```

**File:** config/src/config/inspection_service_config.rs (L55-65)
```rust
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/safety_rules_config.rs (L85-113)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/execution_config.rs (L167-183)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** aptos-node/src/storage.rs (L34-42)
```rust
    if let Some(genesis) = get_genesis_txn(node_config) {
        let ledger_info_opt =
            maybe_bootstrap::<AptosVMBlockExecutor>(db_rw, genesis, genesis_waypoint)
                .map_err(|err| anyhow!("DB failed to bootstrap {}", err))?;
        Ok(ledger_info_opt)
    } else {
        info ! ("Genesis txn not provided! This is fine only if you don't expect to apply it. Otherwise, the config is incorrect!");
        Ok(None)
    }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L56-59)
```rust
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```
