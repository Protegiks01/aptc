# Audit Report

## Title
World-Readable Backup Files Expose Blockchain State and Consensus Data via Insecure File Permissions

## Summary
The `LocalFs` backup storage backend creates backup files with default Unix permissions (typically 0644), making them world-readable on multi-user systems. This exposes complete blockchain state, transaction history, and consensus metadata to any local user on the system where backups are stored.

## Finding Description

The `create_for_write()` function in the LocalFs backup storage implementation creates files without setting secure permissions: [1](#0-0) 

On Unix systems, `OpenOptions::new().write(true).create_new(true).open()` without an explicit `.mode()` call creates files with default permissions determined by the umask (typically 0666 & ~0022 = 0644, i.e., `rw-r--r--`), making them readable by all users on the system.

The same issue exists in `save_metadata_lines()`: [2](#0-1) 

**Sensitive Data Exposed:**

The backup files contain highly detailed blockchain information:

1. **State Snapshot Backups** - Complete blockchain state including all account resources and Move modules: [3](#0-2) 

2. **Transaction Backups** - All transaction data and proofs: [4](#0-3) 

3. **Epoch Ending Backups** - LedgerInfoWithSignatures containing consensus state and validator signatures: [5](#0-4) 

**Established Security Pattern:**

The codebase has an established pattern for creating secure files with restricted permissions: [6](#0-5) 

And: [7](#0-6) 

The LocalFs backup implementation fails to follow this pattern.

## Impact Explanation

This is an **information disclosure vulnerability** that violates defense-in-depth security principles. However, the actual security impact is **Low severity** according to Aptos bug bounty criteria: [8](#0-7) 

While the documentation indicates LocalFs is "used mainly for tests," it remains a valid production option. On multi-user systems, this allows:

- Any local user to read complete blockchain state
- Access to all historical transaction data
- Exposure of consensus metadata and validator signatures
- Potential reconnaissance for targeted attacks

However, this data is already "public" and accessible via RPC APIs, limiting the practical security impact. The issue is primarily about following least-privilege principles and defense-in-depth rather than exposing truly secret information.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability is exploitable when:
1. Operators choose LocalFs over cloud storage backends (CommandAdapter)
2. The system hosts multiple user accounts
3. An attacker gains access as a non-privileged user

Production deployments typically use cloud storage (GCS, S3, Azure) via CommandAdapter: [9](#0-8) 

## Recommendation

Apply the established secure file creation pattern used elsewhere in the codebase. Modify both `create_for_write()` and `save_metadata_lines()` to set restrictive permissions:

```rust
async fn create_for_write(
    &self,
    backup_handle: &BackupHandleRef,
    name: &ShellSafeName,
) -> Result<(FileHandle, Box<dyn AsyncWrite + Send + Unpin>)> {
    let file_handle = Path::new(backup_handle)
        .join(name.as_ref())
        .path_to_string()?;
    let abs_path = self.dir.join(&file_handle).path_to_string()?;
    
    let mut opts = OpenOptions::new();
    opts.write(true).create_new(true);
    
    #[cfg(unix)]
    opts.mode(0o600);  // User read/write only
    
    let file = opts
        .open(&abs_path)
        .await
        .err_notes(&abs_path)?;
    Ok((file_handle, Box::new(file)))
}
```

Apply the same fix to `save_metadata_lines()` at line 162.

## Proof of Concept

```rust
// Test to verify insecure permissions
#[cfg(unix)]
#[tokio::test]
async fn test_backup_file_permissions_insecure() {
    use std::fs;
    use std::os::unix::fs::PermissionsExt;
    use tempfile::TempDir;
    
    let tmpdir = TempDir::new().unwrap();
    let storage = LocalFs::new(tmpdir.path().to_path_buf());
    
    let backup_handle = storage.create_backup(&ShellSafeName::from_str("test_backup").unwrap())
        .await
        .unwrap();
    
    let (file_handle, mut file) = storage.create_for_write(
        &backup_handle,
        &ShellSafeName::from_str("test.chunk").unwrap()
    ).await.unwrap();
    
    use tokio::io::AsyncWriteExt;
    file.write_all(b"sensitive data").await.unwrap();
    file.shutdown().await.unwrap();
    
    let file_path = tmpdir.path().join(&file_handle);
    let metadata = fs::metadata(&file_path).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    // Current behavior: world-readable (0o644 or similar)
    assert_ne!(mode & 0o044, 0, "File should be world-readable (current insecure behavior)");
    
    // Expected secure behavior:
    // assert_eq!(mode & 0o077, 0, "File should NOT be readable by group/others");
    // assert_eq!(mode & 0o600, 0o600, "File should be user read/write only");
}
```

## Notes

While this is a valid security improvement, it does **not** meet the Medium/High severity threshold required by the validation checklist. The data exposed (blockchain state, transactions, consensus signatures) is already publicly accessible via RPC APIs. The issue is primarily about following security best practices (least privilege, defense-in-depth) rather than exposing truly confidential information.

According to Aptos bug bounty criteria, this would qualify as **Low severity** ("Minor information leaks") rather than High severity, despite the question's classification. LocalFs is documented as "mainly for tests," and production deployments use cloud storage backends that handle permissions differently.

### Citations

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L89-92)
```rust
        let file = OpenOptions::new()
            .write(true)
            .create_new(true)
            .open(&abs_path)
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L162-165)
```rust
        let file = OpenOptions::new()
            .write(true)
            .create_new(true)
            .open(&path)
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L419-424)
```rust
        let (chunk_handle, mut chunk_file) = self
            .storage
            .create_for_write(backup_handle, &Self::chunk_name(first_idx))
            .await?;
        chunk_file.write_all(&bytes).await?;
        chunk_file.shutdown().await?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/backup.rs (L173-178)
```rust
        let (chunk_handle, mut chunk_file) = self
            .storage
            .create_for_write(backup_handle, &Self::chunk_name(first_version))
            .await?;
        chunk_file.write_all(chunk_bytes).await?;
        chunk_file.shutdown().await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L158-163)
```rust
        let (chunk_handle, mut chunk_file) = self
            .storage
            .create_for_write(backup_handle, &Self::chunk_name(first_epoch))
            .await?;
        chunk_file.write_all(chunk_bytes).await?;
        chunk_file.shutdown().await?;
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** storage/README.md (L228-229)
```markdown
        --local-fs-dir <LOCAL_FS_DIR>
            Select the LocalFs backup storage type, which is used mainly for tests.
```

**File:** terraform/helm/fullnode/README.md (L16-20)
```markdown
| backup.config.gcs.bucket | string | `nil` |  |
| backup.config.location | string | `nil` | Which of the below backup configurations to use |
| backup.config.r2.bucket | string | `nil` |  |
| backup.config.r2.endpoint_url | string | `nil` |  |
| backup.config.s3.bucket | string | `nil` |  |
```
