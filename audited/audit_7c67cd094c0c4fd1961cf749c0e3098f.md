# Audit Report

## Title
Unauthorized Master Election Takeover in Indexer GRPC Manager Leading to File Store Data Corruption

## Summary
The indexer-grpc-manager lacks proper authorization for master election, allowing malicious instances to claim master status and concurrently write to the shared file store. This can lead to race conditions, metadata corruption, and data integrity violations.

## Finding Description

The indexer-grpc-manager system uses a static configuration-based master election mechanism without any runtime validation or authorization. The vulnerability exists in the heartbeat handling logic where any grpc-manager instance can override the `master_address` field of other instances. [1](#0-0) 

When a grpc-manager instance receives a heartbeat from another instance, it unconditionally accepts and overwrites its local view of who the master is. There is no validation that:
1. The sender is authorized to be master
2. The sender has won any election process
3. The master_address being claimed is legitimate

The master role is critical because only the master instance starts the FileStoreUploader: [2](#0-1) 

The IS_MASTER metric is set purely based on the configuration file: [3](#0-2) 

**Attack Scenario:**
1. Attacker deploys a malicious grpc-manager instance
2. Sets `is_master: true` in the configuration file
3. Configures `grpc_manager_addresses` to include legitimate instances
4. Starts the instance, which begins sending heartbeats claiming to be master
5. Legitimate instances receive these heartbeats and update their `master_address`
6. The malicious instance starts its own FileStoreUploader
7. Multiple FileStoreUploaders now write concurrently to the same file store

The file store implementations (GCS and Local) have no distributed locking mechanism: [4](#0-3) [5](#0-4) 

Both implementations perform simple file writes without coordination, leading to race conditions when multiple FileStoreUploaders write simultaneously. The critical metadata file is particularly vulnerable: [6](#0-5) 

## Impact Explanation

This vulnerability represents **High Severity** according to the Aptos bug bounty criteria:
- **Significant Protocol Violations**: The indexer infrastructure maintains critical blockchain transaction history
- **Data Integrity Compromise**: Concurrent writes corrupt metadata and transaction batch files
- **Service Degradation**: Corrupted file store causes indexer service failures affecting downstream applications

While this doesn't directly affect consensus or the core blockchain, the indexer infrastructure is critical for:
- Block explorers and analytics platforms
- DApp backends querying historical data
- Auditing and compliance systems
- Developer tooling and debugging

Data corruption in the file store can cause:
1. Incorrect transaction history served to clients
2. Version mismatches requiring manual recovery
3. Cascading failures across the indexer ecosystem
4. Loss of historical data requiring full re-indexing

## Likelihood Explanation

**Likelihood: High**

The attack requires:
- Network access to grpc-manager instances (typically internal/private networks)
- Ability to deploy and configure a grpc-manager instance
- Knowledge of legitimate grpc-manager addresses

However:
- No authentication or authorization checks exist
- The vulnerability is exploitable with standard configuration files
- The attack is fully deterministic once the malicious instance connects
- Cloud misconfigurations or insider threats make this realistic

The code explicitly documents this limitation: [7](#0-6) 

## Recommendation

Implement proper master election with authorization:

1. **Add Mutual TLS Authentication**: Require all grpc-manager instances to authenticate using certificates
2. **Implement Distributed Consensus**: Use a proper leader election algorithm (e.g., Raft, Paxos) with health checks
3. **Add Master Authorization**: Validate that only authorized instances can claim master status
4. **File Store Locking**: Implement distributed locks (e.g., using cloud-native locking primitives) to prevent concurrent writes
5. **Heartbeat Validation**: Verify sender identity before accepting master_address updates

**Code Fix Example:**

```rust
fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
    // Validate sender is authorized
    if !self.is_authorized_master(&address) {
        warn!("Unauthorized master claim from {}", address);
        return Ok(());
    }
    
    // Only update if sender is actually the current master or has higher priority
    let mut master_addr = self.master_address.lock().unwrap();
    if self.should_accept_master_claim(&address, &info, &master_addr) {
        *master_addr = info.master_address;
    }
    
    // ... rest of function
}
```

## Proof of Concept

**Setup:**
1. Deploy legitimate grpc-manager with `is_master: true` at `http://legit:50051`
2. Deploy malicious grpc-manager with identical configuration

**Malicious Config (malicious.yaml):**
```yaml
health_check_port: 8081
server_config:
  chain_id: 1
  service_config:
    listen_address: "0.0.0.0:50052"
  file_store_config:
    type: "local"
    local_path: "/shared/filestore"
  self_advertised_address: "http://malicious:50052"
  grpc_manager_addresses: ["http://legit:50051"]
  fullnode_addresses: ["http://fullnode:50051"]
  is_master: true  # Malicious claim
  allow_fn_fallback: true
```

**Execution:**
```bash
# Start malicious instance
./indexer-grpc-manager --config-path malicious.yaml

# Observe logs showing:
# - IS_MASTER metric set to 1
# - FileStoreUploader starting
# - Concurrent writes to /shared/filestore/metadata.json
# - Version conflicts and data corruption
```

**Expected Result:**
- Both instances have IS_MASTER=1
- Both instances run FileStoreUploader
- Race conditions occur in file store writes
- metadata.json version field becomes inconsistent
- Transaction batches may be corrupted or overwritten

**Notes**

This vulnerability is specific to the indexer-grpc-manager component and does not directly affect blockchain consensus or validator operations. However, it represents a significant infrastructure security issue that can compromise data integrity for all services depending on the indexer.

The root cause is the lack of authentication and authorization in the grpc-manager heartbeat protocol, combined with the absence of distributed coordination mechanisms for master election and file store access control.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L135-136)
```rust
    // NOTE: We assume the master is statically configured for now.
    master_address: Mutex<Option<GrpcAddress>>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-568)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);

        let mut entry = self
            .grpc_managers
            .entry(address.clone())
            .or_insert(Peer::new(address));
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L80-80)
```rust
        IS_MASTER.set(config.is_master as i64);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L112-121)
```rust
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/gcs.rs (L120-136)
```rust
    async fn save_raw_file(&self, file_path: PathBuf, data: Vec<u8>) -> Result<()> {
        let path = self.get_path(file_path);
        trace!(
            "Uploading object to {}/{}.",
            self.bucket_name,
            path.as_str()
        );
        Object::create(
            self.bucket_name.as_str(),
            data,
            path.as_str(),
            JSON_FILE_TYPE,
        )
        .await
        .map_err(anyhow::Error::msg)?;

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/local.rs (L61-69)
```rust
    async fn save_raw_file(&self, file_path: PathBuf, data: Vec<u8>) -> Result<()> {
        let file_path = self.path.join(file_path);
        if let Some(parent) = file_path.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }
        tokio::fs::write(file_path, data)
            .await
            .map_err(anyhow::Error::msg)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L262-274)
```rust
    async fn update_file_store_metadata(&self, version: u64) -> Result<()> {
        FILE_STORE_VERSION.set(version as i64);
        let metadata = FileStoreMetadata {
            chain_id: self.chain_id,
            num_transactions_per_folder: NUM_TXNS_PER_FOLDER,
            version,
        };

        let raw_data = serde_json::to_vec(&metadata).map_err(anyhow::Error::msg)?;
        self.writer
            .save_raw_file(PathBuf::from(METADATA_FILE_NAME), raw_data)
            .await
    }
```
