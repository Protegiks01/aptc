# Audit Report

## Title
Round Number Attack: Malicious Peers Can Fill Pending Block Store with High-Round Blocks to Evict Legitimate Blocks

## Summary
A malicious network peer can exploit missing round number validation in the consensus observer to fill the pending block store with blocks containing extremely high round numbers (approaching u64::MAX). Due to the BTreeMap ordering and garbage collection strategy that removes lowest rounds first, legitimate blocks are evicted while attacker blocks persist indefinitely, causing memory exhaustion and denial of service on consensus observer nodes.

## Finding Description

The consensus observer's pending block management system contains a critical validation gap that allows blocks with arbitrarily high round numbers to be inserted without verification.

The `PendingBlockStore` uses a `BTreeMap<(u64, Round), Arc<PendingBlockWithMetadata>>` to store blocks awaiting payloads. [1](#0-0) 

The `Round` type is a `u64` alias, permitting values from 0 to 18,446,744,073,709,551,615. [2](#0-1) 

When processing `OrderedBlock` messages, the `verify_ordered_blocks()` method only validates structural properties (non-empty blocks, proper chaining, matching block IDs) but critically does NOT check if round numbers are reasonable. [3](#0-2) 

The "out of date" check uses `<=` comparison, meaning it only filters blocks with rounds lower than or equal to the current round - high rounds pass this check. [4](#0-3) 

When payloads don't exist, blocks are inserted into the pending store WITHOUT cryptographic proof verification, which only occurs later in `process_ordered_block()`. [5](#0-4) [6](#0-5) 

The garbage collection mechanism uses `pop_first()` on the BTreeMap, removing entries with the LOWEST `(epoch, round)` keys first. [7](#0-6) 

**Attack Execution:**
1. Attacker connects to consensus observer network
2. Sends `Subscribe` request to publisher (accepted without restrictions) [8](#0-7) 
3. Crafts `OrderedBlock` messages with rounds like `u64::MAX - 1000`, `u64::MAX - 999`, etc.
4. Messages pass subscription verification [9](#0-8) 
5. Blocks pass structural validation (no round sanity check)
6. Blocks not filtered as "out of date" (high rounds > current round)
7. Blocks inserted into pending store without proof verification (payloads don't exist)
8. BTreeMap orders blocks by (epoch, round) - attacker's blocks positioned at END
9. When store exceeds `max_num_pending_blocks`, GC removes from BEGINNING
10. Legitimate blocks evicted while attacker blocks persist

## Impact Explanation

This vulnerability qualifies as **HIGH Severity** under the Aptos bug bounty program:

**Validator Node Slowdowns**: Consensus observer nodes experience significant performance degradation as the pending block store fills with malicious entries, preventing proper buffering of legitimate pending blocks. This aligns with the "Validator Node Slowdowns (High)" category explicitly listed in the bounty program.

**Resource Exhaustion**: The attack can consume up to `max_num_pending_blocks` entries (default 150, up to 300 on test networks) with useless high-round blocks. [10](#0-9) [11](#0-10)  Each entry can contain multiple pipelined blocks, significantly amplifying memory consumption.

**Operational Disruption**: Node operators may need to restart nodes or manually clear state to recover, causing service interruptions.

**Wide Attack Surface**: Consensus observers are enabled by default on validators (publisher mode) and VFNs (observer + publisher mode), making many critical nodes potential targets. [12](#0-11) 

This does not reach Critical severity because it affects the consensus observer layer rather than core consensus protocol, and does not result in fund loss or consensus violations.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Low Complexity**: Attack requires only network connectivity and sending a subscription request - no special privileges needed
2. **No Cryptographic Requirements**: Proof verification is bypassed because blocks without payloads are inserted before verification occurs
3. **Deterministic Effect**: The BTreeMap ordering and GC strategy guarantee the attack succeeds
4. **No Rate Limiting**: Code shows no per-peer rate limiting for this attack vector
5. **Open Subscription Model**: Any network peer can subscribe to publishers without restrictions

## Recommendation

Implement round number sanity checking in the ordered block validation path:

1. **Add Round Bounds Validation**: In `verify_ordered_blocks()`, check that round numbers are within a reasonable range of the current epoch's expected rounds (e.g., current_round + max_blocks_ahead).

2. **Validate Against Expected Progress**: Compare received rounds against known consensus progress to detect abnormally high values.

3. **Enhance Out-of-Date Check**: Modify the out-of-date logic to also reject blocks with rounds far exceeding current progress.

4. **Add Subscription Controls**: Implement per-peer rate limiting or reputation scoring to mitigate abuse.

Example fix for `verify_ordered_blocks()`:
```rust
pub fn verify_ordered_blocks(&self, current_round: Round, max_round_ahead: u64) -> Result<(), Error> {
    // Existing validations...
    
    // NEW: Validate round numbers are within reasonable bounds
    let first_round = self.first_block().round();
    if first_round > current_round.saturating_add(max_round_ahead) {
        return Err(Error::InvalidMessageError(
            format!("Block round {} exceeds reasonable bounds (current: {}, max ahead: {})",
                first_round, current_round, max_round_ahead)
        ));
    }
    
    Ok(())
}
```

## Proof of Concept

This vulnerability can be demonstrated by:
1. Setting up a consensus observer node
2. Connecting as a network peer and subscribing
3. Sending `OrderedBlock` messages with rounds set to `u64::MAX - i` for i in 0..150
4. Observing that these blocks are inserted into pending store
5. Sending legitimate blocks and observing they are evicted by GC while malicious blocks persist
6. Monitoring memory consumption and node performance degradation

The attack exploits the combination of missing round validation, deferred proof verification, and the GC strategy to achieve persistent resource exhaustion on consensus observer nodes.

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L67-67)
```rust
    blocks_without_payloads: BTreeMap<(u64, Round), Arc<PendingBlockWithMetadata>>,
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L178-179)
```rust
            if let Some((oldest_epoch_round, pending_block)) =
                self.blocks_without_payloads.pop_first()
```

**File:** consensus/consensus-types/src/common.rs (L1-20)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    payload::{OptBatches, OptQuorumStorePayload, PayloadExecutionLimit, TxnAndGasLimits},
    proof_of_store::{BatchInfo, BatchInfoExt, ProofCache, ProofOfStore, TBatchInfo},
};
use anyhow::{bail, ensure};
use aptos_crypto::{
    hash::{CryptoHash, CryptoHasher},
    HashValue,
};
use aptos_crypto_derive::CryptoHasher;
use aptos_logger::prelude::*;
use aptos_types::{
    account_address::AccountAddress,
    transaction::{ReplayProtector, SignedTransaction},
    validator_verifier::ValidatorVerifier,
    vm_status::DiscardedVMStatus,
    PeerId,
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L227-266)
```rust
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L579-594)
```rust
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L679-680)
```rust
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L706-713)
```rust
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L728-752)
```rust
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
        } else {
            // Drop the block and log an error (the block should always be for the current epoch)
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block for a different epoch! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L181-192)
```rust
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
```

**File:** config/src/config/consensus_observer_config.rs (L17-17)
```rust
const MAX_NUM_PENDING_BLOCKS_FOR_TEST_NETWORKS: u64 = 300;
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```

**File:** config/src/config/consensus_observer_config.rs (L112-128)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
            },
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
