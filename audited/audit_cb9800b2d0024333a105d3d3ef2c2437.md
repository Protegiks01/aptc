# Audit Report

## Title
Unauthenticated Cross-Shard Messages Enable State Manipulation in Remote Sharded Block Execution

## Summary
The remote sharded block executor accepts cross-shard transaction write messages (`RemoteTxnWrite`) without cryptographic authentication or verification. A Byzantine shard process can send false messages claiming transactions succeeded when they aborted (or vice versa), causing dependent transactions on other shards to execute with incorrect state assumptions, potentially leading to validator-level state inconsistencies.

## Finding Description

The sharded block executor supports distributed execution across remote shard processes via `RemoteCrossShardClient`. When a transaction completes on one shard and writes to a state key that another shard's transaction depends on, a `RemoteTxnWrite` message is sent cross-shard containing the write operation. [1](#0-0) 

The critical vulnerability is that these messages are transmitted over the network without any cryptographic signature or authentication: [2](#0-1) 

Messages are simply BCS-serialized and sent, then deserialized on receipt with zero verification of sender authenticity or message integrity. A Byzantine shard can exploit this by:

1. **Claiming success for aborted transactions**: Send `RemoteTxnWrite { state_key: K, write_op: Some(fake_value) }` when transaction actually aborted
2. **Claiming abort for successful transactions**: Send `RemoteTxnWrite { state_key: K, write_op: None }` when transaction actually wrote a value

The receiving shard blindly trusts this data: [3](#0-2) 

Dependent transactions then execute using this false state through the `CrossShardStateView`: [4](#0-3) 

This breaks the **Deterministic Execution** invariant - different shard configurations could produce different state roots for identical blocks.

Additionally, the abort handling is not implemented, leaving a `todo!()` macro: [5](#0-4) 

## Impact Explanation

**Severity Assessment: Medium to High (conditional on deployment)**

The impact depends critically on the deployment model:

**If used for intra-validator horizontal scaling** (multiple processes owned by one validator):
- A compromised shard process can manipulate cross-shard messages
- Causes that validator to compute incorrect state roots
- Validator fails consensus verification with honest validators
- **Impact**: Validator-level availability/liveness degradation (High Severity - API crashes, node slowdowns)

**If hypothetically used for inter-validator distributed execution**:
- Byzantine validators could send false cross-shard messages to honest validators' shards
- Different validators compute different state roots
- **Impact**: Consensus safety violation (Critical Severity)
- However, this deployment model contradicts AptosBFT's design requirement for independent execution

The feature is enabled when remote addresses are configured: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability is **real and exploitable**, but likelihood depends on:

1. **Deployment uncertainty**: Remote sharded execution appears primarily used in benchmarking [7](#0-6) , not confirmed in production validators

2. **Attack prerequisites**:
   - Requires remote executor addresses to be configured (optional feature)
   - Requires either: (a) compromising a shard process via RCE, or (b) being a Byzantine validator running malicious shard software
   
3. **Detection**: State root mismatches would be caught by consensus verification in the honest validator majority, preventing chain-level compromise but causing liveness issues

## Recommendation

**Implement cryptographic authentication for cross-shard messages:**

1. **Add message signing**: Each shard should sign `RemoteTxnWrite` messages with a shard-specific key
2. **Add message verification**: Receiving shards must verify signatures before accepting messages
3. **Add message sequence numbers**: Prevent replay attacks
4. **Implement abort handling**: Replace `todo!()` with proper abort message handling

**Proposed fix** for `RemoteCrossShardClient`:

```rust
// Add to RemoteTxnWrite struct
pub struct RemoteTxnWrite {
    state_key: StateKey,
    write_op: Option<WriteOp>,
    sequence_number: u64,  // NEW: prevent replay
    signature: Signature,   // NEW: cryptographic proof
}

// In send_cross_shard_msg
fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
    let serialized = bcs::to_bytes(&msg).unwrap();
    let signature = self.shard_key.sign(&serialized);  // NEW
    let authenticated_msg = AuthenticatedMsg { msg, signature };
    let input_message = bcs::to_bytes(&authenticated_msg).unwrap();
    // ... rest of send logic
}

// In receive_cross_shard_msg  
fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
    let message = rx.recv().unwrap();
    let authenticated: AuthenticatedMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
    // NEW: Verify signature before trusting message
    if !authenticated.verify(&self.expected_shard_keys) {
        panic!("Invalid cross-shard message signature");
    }
    authenticated.msg
}
```

## Proof of Concept

**Scenario**: Malicious shard manipulates cross-shard dependency

```rust
// Setup: Two shards, S1 has transaction T1 writing to key K, 
//        S2 has transaction T2 reading K

// On Byzantine Shard S1:
let malicious_client = RemoteCrossShardClient::new(/* ... */);

// T1 actually aborted due to insufficient funds
let actual_txn_output = TransactionOutput {
    write_set: WriteSet::empty(),  // No writes - aborted
    status: TransactionStatus::Abort(/* ... */),
    // ...
};

// BUT: Send false success message to S2
let fake_write_op = WriteOp::Value(/* fake balance */);
let malicious_msg = CrossShardMsg::RemoteTxnWriteMsg(
    RemoteTxnWrite::new(state_key_K, Some(fake_write_op))
);
malicious_client.send_cross_shard_msg(shard_id_2, round, malicious_msg);

// On Honest Shard S2:
// Receives message, no verification occurs
let received_msg = honest_client.receive_cross_shard_msg(round);
// Blindly trusts the fake write_op
cross_shard_state_view.set_value(&state_key_K, Some(fake_value));

// T2 executes using false state from K
// Computes wrong state root â†’ Validator consensus failure
```

**Validation**: Run `executor-benchmark` with `--remote-executor-addresses` configured, inject malicious shard process that sends false `RemoteTxnWrite` messages, observe state root divergence.

## Notes

While this vulnerability exists in the codebase, its **real-world exploitability is conditional** on the remote sharded execution feature being enabled in production validators. The code review reveals it's primarily used in benchmarking contexts. However, the presence of unauthenticated network communication in execution-critical paths represents a significant security design flaw that should be addressed before any production deployment of this feature.

The incomplete abort handling (`todo!()` macro) compounds the issue and indicates this feature may still be under development.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L13-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-66)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L31-45)
```rust
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L77-82)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** execution/executor-benchmark/src/main.rs (L632-648)
```rust
        remote_executor_client::set_remote_addresses(
            opt.pipeline_opt
                .sharding_opt
                .remote_executor_addresses
                .clone()
                .unwrap(),
        );
        assert_eq!(
            execution_shards,
            remote_executor_client::get_remote_addresses().len(),
            "Number of execution shards ({}) must be equal to the number of remote addresses ({}).",
            execution_shards,
            remote_executor_client::get_remote_addresses().len()
        );
        remote_executor_client::set_coordinator_address(
            opt.pipeline_opt.sharding_opt.coordinator_address.unwrap(),
        );
```
