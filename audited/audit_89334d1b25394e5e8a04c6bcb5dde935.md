# Audit Report

## Title
BlockTree State Poisoning via Incomplete Execution Output Causes Permanent Execution Failures

## Summary
When block execution succeeds but the subsequent ledger_update phase fails, the block remains in the BlockExecutor's BlockTree with incomplete state (missing `ledger_update_output`). All child blocks that attempt to execute will fail when trying to access the parent's `ledger_update_output`, causing a permanent denial of service until the executor is manually reset via state sync.

## Finding Description

The vulnerability occurs in the block execution pipeline, specifically in how the BlockExecutor manages partially-executed blocks in its BlockTree:

1. **Block Execution is Two-Phase**: Execution consists of two separate phases:
   - **Execute Phase**: Calls `execute_and_update_state()` which runs VM execution and adds the block to BlockTree with `PartialStateComputeResult` containing only `execution_output` [1](#0-0) 

   - **Ledger Update Phase**: Calls `ledger_update()` which computes state checkpoint and ledger update outputs, setting them via `OnceCell` [2](#0-1) 

2. **State Stored in OnceCell**: The `PartialStateComputeResult` uses `OnceCell` for outputs that are populated lazily: [3](#0-2) 

3. **Parent State Required**: Child block execution requires the parent's `ledger_update_output`: [4](#0-3) 

4. **No Cleanup on Failure**: When execution fails, the BufferManager logs the error and returns without cleaning up the BlockTree: [5](#0-4) 

5. **No Automatic Reset**: The `executor.reset()` which would clear poisoned state is only called during state sync operations, not on execution failures: [6](#0-5) 

**Attack Scenario**:
1. Block B_i's execute phase succeeds â†’ B_i added to BlockTree with only `execution_output`
2. Block B_i's ledger_update phase fails (via fail point injection, resource exhaustion, or bug)
3. BufferManager receives error, logs it, block stays in "Ordered" state
4. BlockTree still contains B_i with incomplete `PartialStateComputeResult`
5. Child block B_{i+1} ordered for execution
6. Child's ledger_update calls `parent_out.ensure_ledger_update_output()`
7. This fails with error "LedgerUpdateOutput not set"
8. All subsequent child blocks fail identically
9. Pipeline is permanently stalled until manual `executor.reset()` via state sync

Even the code contains a TODO acknowledging this: [7](#0-6) 

## Impact Explanation

This is a **Critical Severity** vulnerability per Aptos bug bounty criteria:

- **Total loss of liveness/network availability**: Once state is poisoned, no new blocks can be executed until manual intervention via state sync
- **Non-recoverable without manual intervention**: Requires calling `executor.reset()` which only happens during state sync
- **Network-wide impact**: If multiple validators hit the same execution failure (deterministic error), all nodes would stall
- **Denial of Service**: The pipeline stalls and cannot process new transactions

The vulnerability violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." Partial execution results that cannot be completed violate atomicity.

## Likelihood Explanation

**Likelihood: Medium-High**

This can occur through multiple vectors:

1. **Resource Exhaustion**: Heavy computational load during state checkpoint could cause timeouts or OOM errors
2. **Edge Cases**: Certain block patterns might trigger bugs in `DoStateCheckpoint` or `DoLedgerUpdate`
3. **Fail Points**: The code already has a fail point for testing this scenario, indicating developers are aware of failure modes
4. **Cascading Failures**: Once one block is poisoned, all subsequent blocks fail, amplifying the impact

While not trivially exploitable, the presence of fail points and the TODO comment "no known strategy to recover from this failure" indicates this is a real concern.

## Recommendation

Implement automatic BlockTree cleanup when execution phases fail:

```rust
async fn process_execution_response(&mut self, response: ExecutionResponse) {
    let ExecutionResponse { block_id, inner } = response;
    let current_cursor = self.buffer.find_elem_by_key(self.execution_root, block_id);
    if current_cursor.is_none() {
        return;
    }

    let executed_blocks = match inner {
        Ok(result) => result,
        Err(e) => {
            log_executor_error_occurred(
                e,
                &counters::BUFFER_MANAGER_RECEIVED_EXECUTOR_ERROR_COUNT,
                block_id,
            );
            
            // NEW: Reset executor to clear poisoned BlockTree state
            if let Err(reset_err) = self.executor.reset() {
                error!("Failed to reset executor after execution error: {:?}", reset_err);
            }
            
            return;
        },
    };
    // ... rest of processing
}
```

Additionally, make `PartialStateComputeResult::ensure_ledger_update_output()` more defensive by checking parent state validity before child execution begins.

## Proof of Concept

The vulnerability can be demonstrated using the existing fail point:

```rust
// In a test environment with fail points enabled
use fail::FailScenario;

#[test]
fn test_state_poisoning_via_ledger_update_failure() {
    let scenario = FailScenario::setup();
    
    // Setup: Create parent block B_i and child block B_{i+1}
    let mut executor = create_test_executor();
    let parent_block_id = execute_block(&mut executor, create_test_block(1));
    
    // Inject failure during ledger_update phase for parent block
    fail::cfg("executor::block_state_checkpoint", "return").unwrap();
    
    // Execute parent block - execute phase succeeds, ledger_update fails
    let result = executor.ledger_update(parent_block_id, genesis_id);
    assert!(result.is_err()); // ledger_update fails
    
    // Parent is now in BlockTree with incomplete state
    
    // Attempt to execute child block
    let child_block_id = create_test_block(2);
    let exec_result = executor.execute_and_update_state(
        child_block_id, 
        parent_block_id,  // depends on poisoned parent
        default_config()
    );
    assert!(exec_result.is_ok()); // execute succeeds
    
    // But ledger_update will fail trying to access parent's ledger_update_output
    let ledger_result = executor.ledger_update(child_block_id, parent_block_id);
    assert!(ledger_result.is_err());
    assert!(ledger_result.unwrap_err().to_string().contains("LedgerUpdateOutput not set"));
    
    // All subsequent blocks will fail the same way
    // Requires executor.reset() to recover
    
    scenario.teardown();
}
```

The test demonstrates that once a block's ledger_update fails after execute succeeds, the BlockTree is poisoned and all child blocks fail when trying to access the parent's incomplete state.

## Notes

The vulnerability is particularly concerning because:

1. The TODO comment at line 311 explicitly states "no known strategy to recover from this failure"
2. There's already a fail point for testing this scenario, indicating developers are aware of potential failures
3. The BufferManager doesn't implement any retry or cleanup logic for execution failures
4. The only recovery mechanism is manual state sync, which is not automatic

This represents a significant availability risk that could be exploited through resource exhaustion attacks or triggered by legitimate edge cases during execution.

### Citations

**File:** execution/executor/src/block_executor/mod.rs (L90-95)
```rust
    fn reset(&self) -> Result<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "reset"]);

        *self.inner.write() = Some(BlockExecutorInner::new(self.db.clone())?);
        Ok(())
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L191-258)
```rust
    fn execute_and_update_state(
        &self,
        block: ExecutableBlock,
        parent_block_id: HashValue,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> ExecutorResult<()> {
        let _timer = BLOCK_EXECUTION_WORKFLOW_WHOLE.start_timer();
        let ExecutableBlock {
            block_id,
            transactions,
            auxiliary_info,
        } = block;
        let mut block_vec = self
            .block_tree
            .get_blocks_opt(&[block_id, parent_block_id])?;
        let parent_block = block_vec
            .pop()
            .expect("Must exist.")
            .ok_or(ExecutorError::BlockNotFound(parent_block_id))?;
        let parent_output = &parent_block.output;
        info!(
            block_id = block_id,
            first_version = parent_output.execution_output.next_version(),
            "execute_block"
        );
        let committed_block_id = self.committed_block_id();
        let execution_output =
            if parent_block_id != committed_block_id && parent_output.has_reconfiguration() {
                // ignore reconfiguration suffix, even if the block is non-empty
                info!(
                    LogSchema::new(LogEntry::BlockExecutor).block_id(block_id),
                    "reconfig_descendant_block_received"
                );
                parent_output.execution_output.reconfig_suffix()
            } else {
                let state_view = {
                    let _timer = OTHER_TIMERS.timer_with(&["get_state_view"]);
                    CachedStateView::new(
                        StateViewId::BlockExecution { block_id },
                        Arc::clone(&self.db.reader),
                        parent_output.result_state().latest().clone(),
                    )?
                };

                let _timer = GET_BLOCK_EXECUTION_OUTPUT_BY_EXECUTING.start_timer();
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
                });

                DoGetExecutionOutput::by_transaction_execution(
                    &self.block_executor,
                    transactions,
                    auxiliary_info,
                    parent_output.result_state(),
                    state_view,
                    onchain_config.clone(),
                    TransactionSliceMetadata::block(parent_block_id, block_id),
                )?
            };

        let output = PartialStateComputeResult::new(execution_output);
        let _ = self
            .block_tree
            .add_block(parent_block_id, block_id, output)?;
        Ok(())
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L260-334)
```rust
    fn ledger_update(
        &self,
        block_id: HashValue,
        parent_block_id: HashValue,
    ) -> ExecutorResult<StateComputeResult> {
        let _timer = UPDATE_LEDGER.start_timer();
        info!(
            LogSchema::new(LogEntry::BlockExecutor).block_id(block_id),
            "ledger_update"
        );
        let committed_block_id = self.committed_block_id();
        let mut block_vec = self
            .block_tree
            .get_blocks_opt(&[block_id, parent_block_id])?;
        let parent_block = block_vec
            .pop()
            .expect("Must exist.")
            .ok_or(ExecutorError::BlockNotFound(parent_block_id))?;
        // At this point of time two things must happen
        // 1. The block tree must also have the current block id with or without the ledger update output.
        // 2. We must have the ledger update output of the parent block.
        // Above is not ture if the block is on a forked branch.
        let block = block_vec
            .pop()
            .expect("Must exist")
            .ok_or(ExecutorError::BlockNotFound(parent_block_id))?;
        parent_block.ensure_has_child(block_id)?;
        let output = &block.output;
        let parent_out = &parent_block.output;

        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }

        if parent_block_id != committed_block_id && parent_out.has_reconfiguration() {
            info!(block_id = block_id, "ledger_update for reconfig suffix.");

            // Parent must have done all state checkpoint and ledger update since this method
            // is being called.
            output.set_state_checkpoint_output(
                parent_out
                    .ensure_state_checkpoint_output()?
                    .reconfig_suffix(),
            );
            output.set_ledger_update_output(
                parent_out.ensure_ledger_update_output()?.reconfig_suffix(),
            );
        } else {
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
        }

        Ok(block.output.expect_complete_result())
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L17-31)
```rust
#[derive(Clone, Debug)]
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}

impl PartialStateComputeResult {
    pub fn new(execution_output: ExecutionOutput) -> Self {
        Self {
            execution_output,
            state_checkpoint_output: OnceCell::new(),
            ledger_update_output: OnceCell::new(),
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L617-626)
```rust
        let executed_blocks = match inner {
            Ok(result) => result,
            Err(e) => {
                log_executor_error_occurred(
                    e,
                    &counters::BUFFER_MANAGER_RECEIVED_EXECUTOR_ERROR_COUNT,
                    block_id,
                );
                return;
            },
```
