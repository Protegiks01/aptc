# Audit Report

## Title
Sequence Number Desynchronization in CoinClient Due to Async Cancellation Without Rollback

## Summary
The `CoinClient::transfer()` method in `sdk/src/coin_client.rs` increments the local account's sequence number during transaction signing but fails to roll back this increment if the subsequent transaction submission fails or the async operation is cancelled. This creates a permanent desynchronization between the SDK's local state and the blockchain's on-chain state, rendering the account unusable for future transactions until manual intervention.

## Finding Description

The vulnerability occurs in the interaction between two methods: [1](#0-0) 

The `transfer()` method calls `get_signed_transfer_txn()` which internally calls `sign_with_transaction_builder()`: [2](#0-1) 

The critical issue is at line 364 where `increment_sequence_number()` atomically increments the local sequence number: [3](#0-2) 

**Attack Sequence:**

1. User calls `CoinClient::transfer()` with `from_account` having sequence_number = N
2. `get_signed_transfer_txn()` is awaited, which calls `sign_with_transaction_builder()`
3. `increment_sequence_number()` is called, changing local state to N+1, returning N for the transaction
4. Transaction is signed with sequence_number = N
5. **If cancellation or error occurs here** (before or during `submit().await`):
   - The `?` operator propagates the error upward
   - Local account's sequence_number remains at N+1
   - On-chain account's sequence_number remains at N
   - No rollback mechanism exists

6. Next transaction attempt will use sequence_number = N+1
7. On-chain validation enforces strict equality: [4](#0-3) 

8. Transaction fails with `PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW`
9. Account becomes unusable until sequence number is manually corrected

**Trigger Conditions:**
- Network timeout during `submit().await`
- API error returned by `submit()`
- Async task cancellation (via `tokio::select!`, timeout wrappers, or dropping the Future)
- Connection failures
- Any error propagated by the `?` operator on line 50

**Contrast with Proper Implementation:**

Other parts of the codebase correctly handle this scenario: [5](#0-4) 

The faucet code explicitly calls `decrement_sequence_number()` on transaction submission failure, but `coin_client.rs` lacks this protection.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

1. **State Inconsistencies Requiring Intervention**: The local SDK state diverges from blockchain state, requiring manual correction via `set_sequence_number()` or `decrement_sequence_number()`

2. **Account-Level Denial of Service**: All subsequent transactions from the affected account fail until manual recovery

3. **No Direct Fund Loss**: Funds are not lost or stolen, but account functionality is disrupted

4. **Breaks State Consistency Invariant**: Violates the requirement that "State transitions must be atomic and verifiable"

5. **Cascading Failures in Automated Systems**: In dApps, bots, or automated trading systems, this can cause chain reactions of failures that are difficult to debug

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurring in production:

1. **Common Network Conditions**: Network timeouts and connection failures are routine in blockchain applications
2. **Async Cancellation Patterns**: Modern Rust applications frequently use timeout wrappers (`tokio::time::timeout`) and cancellation patterns (`tokio::select!`)
3. **No Special Privileges Required**: Any SDK user can trigger this
4. **Silent Failure Mode**: The sequence number increment happens before the error, making debugging non-obvious
5. **Production Evidence**: The faucet and transaction emitter codebases include explicit sequence number rollback, indicating this is a known concern

## Recommendation

Add error handling with sequence number rollback in `CoinClient::transfer()`:

```rust
pub async fn transfer(
    &self,
    from_account: &mut LocalAccount,
    to_account: AccountAddress,
    amount: u64,
    options: Option<TransferOptions<'_>>,
) -> Result<PendingTransaction> {
    let signed_txn = self
        .get_signed_transfer_txn(from_account, to_account, amount, options)
        .await?;
    
    // Submit with error handling
    match self.api_client.submit(&signed_txn).await {
        Ok(response) => Ok(response.into_inner()),
        Err(e) => {
            // Roll back sequence number on submission failure
            from_account.decrement_sequence_number();
            Err(e).context("Failed to submit transfer transaction")
        }
    }
}
```

This pattern should be applied to all transaction-building methods in the SDK that increment sequence numbers.

## Proof of Concept

```rust
use aptos_sdk::{
    coin_client::CoinClient,
    rest_client::Client,
    types::LocalAccount,
};
use tokio::time::{timeout, Duration};

#[tokio::test]
async fn test_sequence_number_desync_on_timeout() {
    // Setup: Create a client and account
    let client = Client::new(url::Url::parse("https://fullnode.testnet.aptoslabs.com").unwrap());
    let mut account = LocalAccount::generate(&mut rand::thread_rng());
    let initial_seq = account.sequence_number();
    
    let coin_client = CoinClient::new(&client);
    let receiver = LocalAccount::generate(&mut rand::thread_rng()).address();
    
    // Trigger cancellation via timeout during transfer
    // This will cancel after get_signed_transfer_txn completes but before submit completes
    let result = timeout(
        Duration::from_nanos(1), // Very short timeout to force cancellation
        coin_client.transfer(&mut account, receiver, 1000, None)
    ).await;
    
    // Verify: Timeout occurred
    assert!(result.is_err());
    
    // BUG: Local sequence number was incremented but transaction was never submitted
    assert_eq!(account.sequence_number(), initial_seq + 1);
    
    // Next transaction will fail with SEQUENCE_NUMBER_TOO_NEW
    // because blockchain expects initial_seq but we'll try to use initial_seq + 1
    println!("Desynchronization detected!");
    println!("Local sequence number: {}", account.sequence_number());
    println!("Expected on-chain: {}", initial_seq);
}

#[tokio::test] 
async fn test_sequence_number_desync_on_api_error() {
    // Setup with invalid URL to force API error
    let client = Client::new(url::Url::parse("https://invalid.example.com").unwrap());
    let mut account = LocalAccount::generate(&mut rand::thread_rng());
    let initial_seq = account.sequence_number();
    
    let coin_client = CoinClient::new(&client);
    let receiver = LocalAccount::generate(&mut rand::thread_rng()).address();
    
    // This will fail during get_index() but after sequence number increment
    let result = coin_client.transfer(&mut account, receiver, 1000, None).await;
    
    // Verify: Error occurred
    assert!(result.is_err());
    
    // BUG: If error occurred after signing, sequence number is desynchronized
    // (depends on exact point of failure in execution flow)
}
```

**Notes**

This vulnerability specifically affects the SDK layer and does not compromise blockchain consensus or validator security. However, it breaks the atomicity guarantee for state transitions in client applications and can cause operational disruptions requiring manual intervention. The fix is straightforward: implement proper error handling with sequence number rollback, following the pattern already established in the faucet and transaction emitter components.

### Citations

**File:** sdk/src/coin_client.rs (L36-53)
```rust
    pub async fn transfer(
        &self,
        from_account: &mut LocalAccount,
        to_account: AccountAddress,
        amount: u64,
        options: Option<TransferOptions<'_>>,
    ) -> Result<PendingTransaction> {
        let signed_txn = self
            .get_signed_transfer_txn(from_account, to_account, amount, options)
            .await?;
        Ok(self
            .api_client
            .submit(&signed_txn)
            .await
            .context("Failed to submit transfer transaction")?
            .into_inner())
        // <:!:section_1
    }
```

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L238-241)
```text
            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L377-398)
```rust
    // If there was an issue submitting a transaction we should just reset
    // our sequence numbers to what it was before.
    match result {
        Ok(_) => {
            info!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = event_on_success,
            );
            Ok(signed_transaction)
        },
        Err(e) => {
            faucet_account.write().await.decrement_sequence_number();
            warn!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = "transaction_failure",
                error_message = format!("{:#}", e)
            );
            Err(e)
        },
    }
```
