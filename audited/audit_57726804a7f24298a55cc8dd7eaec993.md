# Audit Report

## Title
Epoch Transition Deadlock and State Inconsistency When DKG Fails During Version Upgrade

## Summary
When DKG (Distributed Key Generation) is enabled, a failed DKG session creates a deadlock that prevents all future epoch transitions. Version upgrade proposals and other configuration changes execute successfully but their staged configurations never activate because the epoch never advances. The blockchain remains stuck until governance manually intervenes with a `force_end_epoch()` proposal, causing complete liveness failure of the epoch transition mechanism.

## Finding Description

The vulnerability occurs in the DKG-based reconfiguration flow implemented in the Aptos Framework. When a governance proposal stages a configuration change (such as a version upgrade), it calls `reconfigure()` which initiates an asynchronous DKG process instead of immediately transitioning to the next epoch.

**The Critical Deadlock Logic:**

The `try_start()` function contains an early return condition that creates the deadlock: [1](#0-0) 

When `try_start()` detects an incomplete DKG session where `dealer_epoch == current_epoch()`, it returns early without starting a new DKG session or completing the epoch transition. This creates a permanent deadlock because:

1. **Initial Trigger**: A version upgrade proposal calls `set_for_next_epoch()` which stages the configuration in a buffer: [2](#0-1) 

2. **DKG Start**: The proposal then calls `reconfigure()`, which (when DKG is enabled) calls `try_start()`: [3](#0-2) 

3. **DKG Failure**: The DKG session starts but fails to complete due to network issues, insufficient validator participation, or validator software bugs. The session remains marked as "in progress" for the current epoch.

4. **Deadlock**: All subsequent reconfiguration attempts (from new governance proposals or block prologues) call `try_start()`, which sees the incomplete session for the current epoch and returns early. No new DKG starts, and no epoch transition occurs.

5. **Stuck Configurations**: The staged version configuration never activates because `on_new_epoch()` is only called during `finish()`: [4](#0-3) 

The epoch counter is only incremented in `reconfiguration::reconfigure()`, which is called from `finish()` but never from `try_start()`: [5](#0-4) 

**No Timeout Mechanism:**

The `DKGSessionState` structure records `start_time_us` but no code checks this value to detect and recover from stale sessions: [6](#0-5) 

**Recovery Requires Manual Intervention:**

The only recovery path is for governance to pass another proposal calling `force_end_epoch()`: [7](#0-6) 

This function calls `finish()` which clears the incomplete DKG session and forces the epoch transition, but requires days for governance voting to complete.

**Security Invariants Broken:**
- **State Consistency**: Governance records indicate successful proposals, but on-chain state doesn't reflect the changes
- **Governance Integrity**: Governance actions fail to take effect as expected
- **Liveness**: Epoch transitions are indefinitely blocked

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty program criteria:

**Validator Node/Network Impacts**: All validator nodes become stuck at the same epoch, unable to progress to the next epoch. Block production continues, but epoch-sensitive operations are frozen.

**State Inconsistencies Requiring Intervention**: A critical divergence exists between:
- Governance proposal records (showing successful execution)
- Actual on-chain configuration state (unchanged)
- Staged configurations accumulating in buffers (never applied)

Recovery requires manual intervention through governance to call `force_end_epoch()`, which itself requires multi-day voting periods.

**Liveness Failure**: While block production continues, the epoch transition mechanism - a core protocol component - is completely deadlocked. This prevents:
- Configuration updates from activating
- Validator set changes based on staking
- Reward distribution at epoch boundaries
- Any protocol upgrades requiring epoch transitions

**Governance Ineffectiveness**: Multiple governance proposals can execute successfully during the deadlock, each staging their configurations, but none take effect. This undermines governance legitimacy and creates operational confusion.

The impact stops short of CRITICAL severity because:
- No permanent network partition (validators agree on blocks)
- No fund loss or theft
- Recoverable through governance action (though costly and slow)

## Likelihood Explanation

The likelihood is **MEDIUM to HIGH** because:

**DKG Can Fail Naturally**: DKG is a distributed cryptographic protocol requiring coordination among validators. The transcript aggregation requires a quorum threshold (typically 2/3 voting power). Realistic failure scenarios include:
- Network partitions between validator nodes
- Validator software bugs in the DKG implementation
- Insufficient validator participation (< 2/3 threshold)
- State synchronization issues
- Resource exhaustion during cryptographic computation
- Validator downtime during the DKG window

**No Automatic Recovery**: The codebase has no timeout mechanism or automatic retry logic. Once a DKG session fails, it remains stuck until manual intervention. The `start_time_us` field is recorded but never checked.

**Natural Occurrence**: This is not a malicious attack scenario - DKG failures can occur through normal network and operational issues without any Byzantine behavior.

**Detection Lag**: If the first DKG failure goes unnoticed, multiple governance proposals could execute before the deadlock is discovered, compounding the problem with accumulated staged configurations.

**Production Environment Complexity**: Real-world validator networks have diverse geographic distribution, varying network conditions, and operational variability that increase the probability of coordination failures.

## Recommendation

**Implement a Timeout and Automatic Recovery Mechanism:**

1. **Add timeout logic to `try_start()`**: Check if the incomplete session's `start_time_us` exceeds a reasonable threshold (e.g., 24 hours). If stale, clear it automatically and start a new DKG session:

```move
public(friend) fun try_start() {
    let incomplete_dkg_session = dkg::incomplete_session();
    if (option::is_some(&incomplete_dkg_session)) {
        let session = option::borrow(&incomplete_dkg_session);
        let session_epoch = dkg::session_dealer_epoch(session);
        let current_epoch = reconfiguration::current_epoch();
        
        if (session_epoch == current_epoch) {
            // Check if session is stale (e.g., > 24 hours old)
            let start_time = dkg::session_start_time(session);
            let current_time = timestamp::now_microseconds();
            let timeout_threshold = 86400000000; // 24 hours in microseconds
            
            if (current_time - start_time > timeout_threshold) {
                // Stale session - clear it and proceed with force end epoch
                let framework = &create_signer(@aptos_framework);
                reconfiguration_with_dkg::finish(framework);
                return
            };
            // Session still active, return early
            return
        }
    };
    // Proceed with normal DKG start
    reconfiguration_state::on_reconfig_start();
    let cur_epoch = reconfiguration::current_epoch();
    dkg::start(cur_epoch, ...);
}
```

2. **Add monitoring and alerting**: Emit events when DKG sessions fail to complete within expected timeframes.

3. **Implement exponential backoff**: If DKG repeatedly fails, gradually increase the timeout before automatic recovery to avoid thrashing.

4. **Add governance override capability**: Allow a faster emergency governance path specifically for `force_end_epoch()` when deadlock is detected.

## Proof of Concept

```move
#[test_only]
module aptos_framework::dkg_deadlock_test {
    use aptos_framework::aptos_governance;
    use aptos_framework::version;
    use aptos_framework::reconfiguration;
    use aptos_framework::dkg;
    use std::option;
    
    #[test(aptos_framework = @aptos_framework)]
    fun test_dkg_failure_deadlock(aptos_framework: signer) {
        // Setup: Initialize framework with DKG enabled
        setup_test_environment(&aptos_framework);
        
        // Step 1: Execute version upgrade proposal
        let initial_epoch = reconfiguration::current_epoch();
        version::set_for_next_epoch(&aptos_framework, 2);
        aptos_governance::reconfigure(&aptos_framework);
        
        // Step 2: Verify DKG session started
        let incomplete = dkg::incomplete_session();
        assert!(option::is_some(&incomplete), 0);
        
        // Step 3: Simulate DKG failure (session never completes)
        // In production, this happens when validators fail to coordinate
        
        // Step 4: Attempt another governance proposal
        version::set_for_next_epoch(&aptos_framework, 3);
        aptos_governance::reconfigure(&aptos_framework);
        
        // Step 5: Verify deadlock - epoch never advanced
        let current_epoch = reconfiguration::current_epoch();
        assert!(current_epoch == initial_epoch, 1);
        
        // Step 6: Verify version never upgraded (still at version 1)
        let current_version = version::get_current_version();
        assert!(current_version == 1, 2);
        
        // Step 7: Only force_end_epoch can recover
        aptos_governance::force_end_epoch(&aptos_framework);
        let recovered_epoch = reconfiguration::current_epoch();
        assert!(recovered_epoch == initial_epoch + 1, 3);
    }
}
```

**Notes:**

This vulnerability is a critical design issue in the asynchronous DKG-based reconfiguration mechanism. While the async nature is documented in comments, the severity of the failure mode (complete epoch transition deadlock requiring governance intervention) was not adequately addressed. The lack of timeout and automatic recovery mechanisms transforms what could be a transient coordination failure into a permanent deadlock requiring costly manual intervention.

The vulnerability affects the core epoch transition mechanism and breaks fundamental blockchain invariants around state consistency and governance effectiveness. Although recovery is possible through `force_end_epoch()`, the multi-day governance delay and operational complexity make this a significant production risk.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-31)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L59-64)
```text
    public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
        config_buffer::upsert(Version {major});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L700-703)
```text
    public entry fun force_end_epoch(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        reconfiguration_with_dkg::finish(aptos_framework);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L106-143)
```text
    public(friend) fun reconfigure() acquires Configuration {
        // Do not do anything if genesis has not finished.
        if (chain_status::is_genesis() || timestamp::now_microseconds() == 0 || !reconfiguration_enabled()) {
            return
        };

        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);
        let current_time = timestamp::now_microseconds();

        // Do not do anything if a reconfiguration event is already emitted within this transaction.
        //
        // This is OK because:
        // - The time changes in every non-empty block
        // - A block automatically ends after a transaction that emits a reconfiguration event, which is guaranteed by
        //   VM spec that all transactions comming after a reconfiguration transaction will be returned as Retry
        //   status.
        // - Each transaction must emit at most one reconfiguration event
        //
        // Thus, this check ensures that a transaction that does multiple "reconfiguration required" actions emits only
        // one reconfiguration event.
        //
        if (current_time == config_ref.last_reconfiguration_time) {
            return
        };

        reconfiguration_state::on_reconfig_start();

        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
        storage_gas::on_reconfig();

        assert!(current_time > config_ref.last_reconfiguration_time, error::invalid_state(EINVALID_BLOCK_TIME));
        config_ref.last_reconfiguration_time = current_time;
        spec {
            assume config_ref.epoch + 1 <= MAX_U64;
        };
        config_ref.epoch = config_ref.epoch + 1;

```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L33-37)
```text
    struct DKGSessionState has copy, store, drop {
        metadata: DKGSessionMetadata,
        start_time_us: u64,
        transcript: vector<u8>,
    }
```
