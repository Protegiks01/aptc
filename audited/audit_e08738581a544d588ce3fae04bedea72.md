# Audit Report

## Title
Gas-Price-Based Front-Running of Limited Supply NFT Mints via Mempool Transaction Ordering

## Summary
Aptos mempool orders transactions by gas price, allowing attackers to observe pending mint transactions for limited-supply NFTs and front-run them by submitting their own mint transactions with higher gas prices. This breaks fairness guarantees in NFT drops and limited token sales, enabling attackers with capital to consistently outbid legitimate users.

## Finding Description

The vulnerability stems from the interaction between three components:

**1. Mempool Transaction Broadcasting & Visibility**

Transactions are broadcast to other validators through the mempool's shared mempool mechanism. [1](#0-0) 

Full transaction details (including the target NFT/token being minted) are visible to any node receiving these broadcasts, enabling attackers running validator or fullnode infrastructure to monitor pending mint transactions.

**2. Gas-Price-Based Priority Ordering**

The mempool uses a `PriorityIndex` that orders transactions by gas price, with higher gas prices receiving priority. [2](#0-1) 

The mempool README explicitly confirms: "This queue is ordered by gas price so that if a client is willing to pay more (than other clients) per unit of execution, then they can enter consensus earlier." [3](#0-2) 

When consensus pulls transactions via `get_batch()`, it iterates through this gas-price-ordered queue. [4](#0-3) 

**3. Race Condition in Token Minting**

The `mint_token` function in the Aptos Token framework has a check-then-act pattern that creates a race condition for limited supply tokens. [5](#0-4) 

Multiple transactions can pass the supply check, but only those executed first will succeed before the maximum is reached.

**Attack Scenario:**
1. NFT project announces a limited drop (e.g., 1000 NFTs at maximum supply)
2. Legitimate user submits mint transaction with standard gas price (e.g., 100 gas units)
3. Attacker monitors mempool broadcasts and observes the pending mint
4. Attacker submits identical mint transaction with higher gas price (e.g., 1000 gas units)
5. Consensus pulls transactions from mempool in gas-price order
6. Attacker's transaction executes first, incrementing the supply counter
7. If supply approaches maximum, legitimate user's transaction may fail with `EMINT_WOULD_EXCEED_TOKEN_MAXIMUM`

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria for "Limited funds loss or manipulation."

**Direct Impact:**
- Users lose mint opportunities in limited NFT drops to attackers with more capital for gas
- Breaks fairness guarantees in first-come-first-serve token sales
- Creates MEV (Maximal Extractable Value) opportunities that disadvantage regular users

**Scope:**
- Affects all limited-supply token mints using the standard Token V1 framework
- Impacts NFT projects, gaming tokens, and any token with maximum supply constraints
- Does not affect consensus safety or cause total fund loss

The impact is limited to competitive scenarios where supply is constrained and demand exceeds supply, making it a Medium rather than High severity issue.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Ability to monitor mempool (requires running a validator/fullnode or observing public mempool endpoints)
- Capital to pay higher gas fees
- Basic automation to detect and respond to mint transactions

**Complexity: LOW**

The attack requires no special cryptographic knowledge, consensus manipulation, or validator collusion. Any sophisticated actor with infrastructure can:
1. Monitor mempool transaction broadcasts
2. Parse mint transaction payloads
3. Construct and submit competing transactions with higher gas prices
4. Automate this process for popular NFT drops

**Real-World Feasibility:**
This is a well-known MEV pattern in other blockchains (Ethereum, BSC). The technical barrier is low, and the economic incentive is high for valuable NFT drops.

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Commit-Reveal Scheme for Sensitive Mints**
Add a two-phase minting process where users first commit to a hash of their mint request, then reveal it after a delay period. This prevents attackers from observing the mint target before commitment.

**Option 2: Fair Ordering via Timestamps**
Modify token minting to record transaction submission timestamps and enforce FIFO ordering regardless of gas price for transactions within the same block. This requires consensus-level changes.

**Option 3: Randomized Selection**
For limited drops, use VRF-based randomization to select winners from a pool of valid mint requests rather than relying on execution order.

**Option 4: Application-Level Protection**
NFT projects should implement their own access controls (whitelists, signature verification, time-locked mints) rather than relying solely on supply limits.

**Code Fix Example (Application-Level):**
```move
// Add nonce-based commitment to prevent front-running
struct MintCommitment has key {
    commitments: Table<address, vector<u8>>, // commitment hash
    revealed: Table<address, bool>,
}

public entry fun commit_mint(user: &signer, commitment_hash: vector<u8>) {
    // Store commitment hash, preventing front-running observation
}

public entry fun reveal_and_mint(user: &signer, nonce: vector<u8>, token_data_id: TokenDataId) {
    // Verify commitment matches hash(nonce + token_data_id)
    // Then execute mint
}
```

## Proof of Concept

```move
#[test_only]
module test_frontrun::mint_race {
    use aptos_framework::timestamp;
    use aptos_token::token;
    use std::string;
    use std::signer;
    
    #[test(framework = @aptos_framework, creator = @0x123, user1 = @0x456, attacker = @0x789)]
    fun test_frontrun_limited_mint(
        framework: &signer,
        creator: &signer,
        user1: &signer,
        attacker: &signer,
    ) {
        // Setup
        timestamp::set_time_has_started_for_testing(framework);
        
        // Create limited collection (max 1 token)
        token::create_collection(
            creator,
            string::utf8(b"Limited NFT"),
            string::utf8(b"Only 1 available"),
            string::utf8(b"https://example.com"),
            1, // maximum = 1
            vector[false, false, false],
        );
        
        token::create_tokendata(
            creator,
            string::utf8(b"Limited NFT"),
            string::utf8(b"Rare Token"),
            string::utf8(b"Very rare"),
            1, // maximum = 1
            string::utf8(b"https://example.com/token"),
            signer::address_of(creator),
            100,
            0,
            token::create_token_mutability_config(&vector[false, false, false, false, false]),
            vector[],
            vector[],
            vector[],
        );
        
        let token_data_id = token::create_token_data_id(
            signer::address_of(creator),
            string::utf8(b"Limited NFT"),
            string::utf8(b"Rare Token"),
        );
        
        // Simulate race condition:
        // In real scenario with gas ordering, attacker's higher-gas tx executes first
        // Here we demonstrate the race by explicit ordering
        
        // Attacker mints first (simulating higher gas priority)
        let attacker_token_id = token::mint_token(attacker, token_data_id, 1);
        
        // User1's mint fails due to supply exhaustion
        // This would throw EMINT_WOULD_EXCEED_TOKEN_MAXIMUM in production
        // token::mint_token(user1, token_data_id, 1); // Would abort here
        
        // Verify attacker got the token while user1 got nothing
        assert!(token::balance_of(signer::address_of(attacker), attacker_token_id) == 1, 0);
    }
}
```

**To demonstrate the gas-ordering aspect:**
1. Submit two transactions to a live Aptos network targeting the same limited NFT
2. Transaction A: Standard gas price (100 units)
3. Transaction B: 10x gas price (1000 units)  
4. Observe Transaction B executes first despite being submitted after Transaction A
5. Transaction A fails with supply exceeded error

## Notes

**Important Context:**

1. **OrderVote Mechanism Does Not Prevent This**: The consensus layer's OrderVote mechanism is for block-level ordering (determining which block gets committed), not transaction-level ordering within blocks. [6](#0-5) 

2. **This Is Not a Consensus Bug**: The mempool and consensus are working as designed. The vulnerability arises from the *intended* gas-price prioritization interacting with race-sensitive smart contract logic.

3. **Application vs Protocol Responsibility**: While the protocol allows gas-based ordering, NFT projects must implement their own fairness mechanisms rather than relying on execution order guarantees.

4. **Nonce-based Transactions**: Orderless transactions using nonces [7](#0-6)  can execute in any order but still don't prevent this attack since attackers can submit nonce-based mints with higher gas prices.

### Citations

**File:** mempool/src/shared_mempool/network.rs (L46-54)
```rust
/// Container for exchanging transactions with other Mempools.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum MempoolSyncMsg {
    /// Broadcast request issued by the sender.
    BroadcastTransactionsRequest {
        /// Unique id of sync request. Can be used by sender for rebroadcast analysis
        message_id: MempoolMessageId,
        transactions: Vec<SignedTransaction>,
    },
```

**File:** mempool/src/core_mempool/index.rs (L192-215)
```rust
impl Ord for OrderedQueueKey {
    fn cmp(&self, other: &OrderedQueueKey) -> Ordering {
        // Higher gas preferred
        match self.gas_ranking_score.cmp(&other.gas_ranking_score) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Lower insertion time preferred
        match self.insertion_time.cmp(&other.insertion_time).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Higher address preferred
        match self.address.cmp(&other.address) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        match self.replay_protector.cmp(&other.replay_protector).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        self.hash.cmp(&other.hash)
    }
}
```

**File:** mempool/src/core_mempool/index.rs (L499-505)
```rust

    pub(crate) fn size(&self) -> usize {
        let mut size = 0;
        for timeline in &self.timelines {
            size += timeline.size()
        }
        size
```

**File:** mempool/README.md (L36-37)
```markdown
The main index - PriorityIndex is an ordered queue of transactions that are “consensus-ready” (i.e., they have a sequence number which is sequential to the current sequence number for the account). This queue is ordered by gas price so that if a client is willing to pay more (than other clients) per unit of execution, then they can enter consensus earlier.

```

**File:** mempool/src/core_mempool/mempool.rs (L425-507)
```rust
    pub(crate) fn get_batch(
        &self,
        max_txns: u64,
        max_bytes: u64,
        return_non_full: bool,
        exclude_transactions: BTreeMap<TransactionSummary, TransactionInProgress>,
    ) -> Vec<SignedTransaction> {
        let start_time = Instant::now();
        let exclude_size = exclude_transactions.len();
        let mut inserted = HashSet::new();

        let gas_end_time = start_time.elapsed();

        let mut result = vec![];
        // Helper DS. Helps to mitigate scenarios where account submits several transactions
        // with increasing gas price (e.g. user submits transactions with sequence number 1, 2
        // and gas_price 1, 10 respectively)
        // Later txn has higher gas price and will be observed first in priority index iterator,
        // but can't be executed before first txn. Once observed, such txn will be saved in
        // `skipped` DS and rechecked once it's ancestor becomes available
        let mut skipped = HashSet::new();
        let mut total_bytes = 0;
        let mut txn_walked = 0usize;
        // iterate over the queue of transactions based on gas price
        'main: for txn in self.transactions.iter_queue() {
            txn_walked += 1;
            let txn_ptr = TxnPointer::from(txn);

            // TODO: removed gas upgraded logic. double check if it's needed
            if exclude_transactions.contains_key(&txn_ptr) {
                continue;
            }
            let txn_replay_protector = txn.replay_protector;
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(txn_seq) => {
                    let txn_in_sequence = txn_seq > 0
                        && Self::txn_was_chosen(
                            txn.address,
                            txn_seq - 1,
                            &inserted,
                            &exclude_transactions,
                        );
                    let account_sequence_number =
                        self.transactions.get_account_sequence_number(&txn.address);
                    // include transaction if it's "next" for given account or
                    // we've already sent its ancestor to Consensus.
                    if txn_in_sequence || account_sequence_number == Some(&txn_seq) {
                        inserted.insert((txn.address, txn_replay_protector));
                        result.push((txn.address, txn_replay_protector));
                        if (result.len() as u64) == max_txns {
                            break;
                        }
                        // check if we can now include some transactions
                        // that were skipped before for given account
                        let (skipped_txn_sender, mut skipped_txn_seq_num) =
                            (txn.address, txn_seq + 1);
                        while skipped.remove(&(skipped_txn_sender, skipped_txn_seq_num)) {
                            inserted.insert((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            result.push((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            if (result.len() as u64) == max_txns {
                                break 'main;
                            }
                            skipped_txn_seq_num += 1;
                        }
                    } else {
                        skipped.insert((txn.address, txn_seq));
                    }
                },
                ReplayProtector::Nonce(_) => {
                    inserted.insert((txn.address, txn_replay_protector));
                    result.push((txn.address, txn_replay_protector));
                    if (result.len() as u64) == max_txns {
                        break;
                    }
                },
            };
        }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1455-1458)
```text
        if (token_data.maximum > 0) {
            assert!(token_data.supply + amount <= token_data.maximum, error::invalid_argument(EMINT_WOULD_EXCEED_TOKEN_MAXIMUM));
            token_data.supply += amount;
        };
```

**File:** consensus/consensus-types/src/order_vote.rs (L15-23)
```rust
#[derive(Deserialize, Serialize, Clone)]
pub struct OrderVote {
    /// The identity of the voter.
    author: Author,
    /// LedgerInfo of a block that is going to be ordered in case this vote gathers QC.
    ledger_info: LedgerInfo,
    /// Signature on the LedgerInfo along with a status on whether the signature is verified.
    signature: SignatureWithStatus,
}
```
