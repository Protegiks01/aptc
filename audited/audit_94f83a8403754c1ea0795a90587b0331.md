# Audit Report

## Title
Critical Public Key Trust Violation: Malicious Peer Injection via Discovery Source Union

## Summary
The Aptos network discovery system unions public keys from multiple discovery sources (OnChainValidatorSet, File, Rest, Config) without precedence, allowing any discovery source to inject trusted public keys for any peer. This enables peer impersonation attacks where an attacker who can influence a low-trust discovery source can authenticate as a legitimate validator, potentially causing consensus violations.

## Finding Description

The Aptos network discovery system maintains separate buckets for peer information from different sources with the following priority order: [1](#0-0) 

When peer addresses need to be dialed, the system correctly prioritizes addresses by source (OnChainValidatorSet addresses are tried first). However, for public keys used in authentication, the system unions ALL keys from ALL sources without any precedence mechanism: [2](#0-1) 

The union operation combines keys indiscriminately: [3](#0-2) 

When discovery information changes, the system updates trusted peers by calling `get_eligible_peers()`, which converts each `DiscoveredPeer` to a `Peer` using the union of all keys: [4](#0-3) 

During Noise protocol handshake authentication, the system accepts any connection where the remote peer's public key exists in the trusted peer's key set: [5](#0-4) 

**Attack Scenario:**

1. OnChainValidatorSet (authoritative source) indicates Validator V has public key `K_legitimate` and PeerId `P_V`
2. Attacker compromises or influences a REST-based discovery endpoint configured on victim nodes
3. Attacker returns discovery data claiming Validator V (PeerId `P_V`) also has public key `K_malicious`
4. The ConnectivityManager unions both keys: `{K_legitimate, K_malicious}`
5. The trusted peers set is updated with both keys
6. Attacker connects to victim nodes using `K_malicious` and is authenticated as Validator V
7. Attacker can now send malicious consensus messages, participate in voting with Validator V's identity, and potentially cause consensus safety violations

This breaks the fundamental security invariant that only the on-chain validator set should determine which public keys are trusted for validator authentication.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria as defined in the Aptos bug bounty:

- **Consensus/Safety violations**: An attacker impersonating a legitimate validator can participate in consensus with false identity, potentially causing conflicting votes, equivocation, or consensus failures
- **Validator node compromise**: Victim nodes will accept and process messages from the impersonated validator, allowing the attacker to inject malicious blocks, votes, or network messages
- **Trust boundary violation**: The on-chain validator set, which should be the single source of truth for validator identities, can be overridden by external discovery sources

The impact is severe because:
1. It allows complete peer identity spoofing in mutual authentication networks
2. Attackers can inject themselves into the consensus protocol without being actual validators
3. Multiple nodes accepting the malicious keys creates a network-wide vulnerability
4. The attack can affect any validator network using REST or file-based discovery alongside on-chain discovery

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is realistic when:

1. **REST-based discovery is enabled**: Nodes configured with `DiscoveryMethod::Rest` pull peer information from HTTP endpoints. If these endpoints are compromised, external attackers can inject malicious keys without any node-level access. [6](#0-5) 

2. **File-based discovery with weak security**: If seed files are on shared filesystems, automatically generated from external sources, or have weak permissions, they can be modified to inject malicious keys.

3. **Configuration complexity**: Operators may not realize that discovery sources beyond on-chain can inject trusted keys, leading to misconfiguration.

The attack requires:
- Ability to influence at least one non-authoritative discovery source (REST endpoint compromise, file system access, or configuration service compromise)
- Knowledge of target validator PeerIds
- Ability to generate valid x25519 key pairs for the malicious keys

The attack does NOT require:
- Direct compromise of validator nodes
- Access to legitimate validator private keys
- Majority stake or consensus participation

## Recommendation

Implement strict precedence for public key trust, where only the highest-priority authoritative source (OnChainValidatorSet) can determine trusted keys:

```rust
// In connectivity_manager/mod.rs, modify PublicKeys implementation:

impl PublicKeys {
    /// Returns the highest-priority non-empty key set.
    /// OnChainValidatorSet keys take absolute precedence over all other sources.
    fn get_authoritative(&self) -> HashSet<x25519::PublicKey> {
        // Try each source in priority order, return first non-empty set
        for source_keys in &self.0 {
            if !source_keys.is_empty() {
                return source_keys.clone();
            }
        }
        HashSet::new()
    }
}

// Modify the From<&DiscoveredPeer> for Peer implementation:
impl From<&DiscoveredPeer> for Peer {
    fn from(peer: &DiscoveredPeer) -> Self {
        // Use authoritative keys instead of union
        Peer::new(peer.addrs.union(), peer.keys.get_authoritative(), peer.role)
    }
}
```

Additionally:
1. Add validation that non-authoritative sources cannot add keys for peers that exist in authoritative sources
2. Log warnings when different sources provide conflicting keys for the same peer
3. Implement configuration options to restrict which discovery sources can contribute trusted keys
4. Consider making OnChainValidatorSet the ONLY source for validator public keys in production networks

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability

#[test]
fn test_malicious_key_injection_via_rest_discovery() {
    use aptos_config::config::{Peer, PeerRole, PeerSet};
    use aptos_crypto::x25519;
    use aptos_types::PeerId;
    use std::collections::HashSet;
    
    // Setup: Legitimate validator from on-chain discovery
    let legitimate_private_key = x25519::PrivateKey::generate(&mut rand::thread_rng());
    let legitimate_public_key = legitimate_private_key.public_key();
    let validator_peer_id = PeerId::random();
    
    let mut onchain_peer_set = PeerSet::new();
    let mut legit_keys = HashSet::new();
    legit_keys.insert(legitimate_public_key);
    onchain_peer_set.insert(
        validator_peer_id,
        Peer::new(vec![], legit_keys.clone(), PeerRole::Validator)
    );
    
    // Attack: Malicious REST discovery adds different key for same peer
    let malicious_private_key = x25519::PrivateKey::generate(&mut rand::thread_rng());
    let malicious_public_key = malicious_private_key.public_key();
    
    let mut rest_peer_set = PeerSet::new();
    let mut malicious_keys = HashSet::new();
    malicious_keys.insert(malicious_public_key);
    rest_peer_set.insert(
        validator_peer_id,
        Peer::new(vec![], malicious_keys, PeerRole::Validator)
    );
    
    // Simulate ConnectivityManager processing both sources
    // (simplified version of handle_update_discovered_peers)
    let mut discovered_peer = DiscoveredPeer::new(PeerRole::Validator);
    
    // Update from OnChainValidatorSet (source 0)
    discovered_peer.keys.update(DiscoverySource::OnChainValidatorSet, legit_keys);
    
    // Update from Rest (source 2)  
    discovered_peer.keys.update(DiscoverySource::Rest, malicious_keys);
    
    // Convert to Peer (this calls union())
    let trusted_peer: Peer = (&discovered_peer).into();
    
    // VULNERABILITY: Both keys are now trusted!
    assert!(trusted_peer.keys.contains(&legitimate_public_key));
    assert!(trusted_peer.keys.contains(&malicious_public_key)); // MALICIOUS KEY IS TRUSTED!
    
    // Attacker can now authenticate using malicious_private_key
    // and be accepted as validator_peer_id
    println!("VULNERABILITY CONFIRMED: Malicious key {} injected alongside legitimate key {}",
             hex::encode(malicious_public_key.as_slice()),
             hex::encode(legitimate_public_key.as_slice()));
}
```

## Notes

This vulnerability demonstrates a fundamental design flaw in the trust model for peer discovery. While address precedence is correctly implemented through ordered iteration, public key precedence is completely absent. The union-based approach treats all discovery sources as equally authoritative for authentication, which violates the principle that on-chain governance should be the single source of truth for validator identities in a blockchain network.

The issue is particularly concerning for production validator networks where:
- REST endpoints might be served by CDNs or third-party infrastructure that could be compromised
- File-based configuration might be managed by external orchestration systems
- Multiple discovery methods are enabled simultaneously for redundancy

The recommended fix implements strict key precedence where only the highest-priority source determines trusted keys, preventing lower-trust sources from injecting malicious authentication credentials.

### Citations

**File:** network/framework/src/connectivity_manager/mod.rs (L136-144)
```rust
/// Config=lowest).
#[repr(u8)]
#[derive(Copy, Clone, Eq, Hash, PartialEq, Ord, PartialOrd, NumVariants, Serialize)]
pub enum DiscoverySource {
    OnChainValidatorSet,
    File,
    Rest,
    Config,
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L305-309)
```rust
impl From<&DiscoveredPeer> for Peer {
    fn from(peer: &DiscoveredPeer) -> Self {
        Peer::new(peer.addrs.union(), peer.keys.union(), peer.role)
    }
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L984-1001)
```rust
        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1320-1322)
```rust
    fn union(&self) -> HashSet<x25519::PublicKey> {
        self.0.iter().flatten().copied().collect()
    }
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** network/discovery/src/lib.rs (L106-125)
```rust
    pub fn rest(
        network_context: NetworkContext,
        update_channel: aptos_channels::Sender<ConnectivityRequest>,
        rest_url: url::Url,
        interval_duration: Duration,
        time_service: TimeService,
    ) -> Self {
        let source_stream = DiscoveryChangeStream::Rest(RestStream::new(
            network_context,
            rest_url,
            interval_duration,
            time_service,
        ));
        DiscoveryChangeListener {
            discovery_source: DiscoverySource::Rest,
            network_context,
            update_channel,
            source_stream,
        }
    }
```
