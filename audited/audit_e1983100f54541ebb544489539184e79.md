# Audit Report

## Title
Type Confusion Vulnerability in Network Protocol Routing Allows Message Misrouting

## Summary
The `SerializedRequest` abstraction fails to prevent type confusion between DirectSend and RPC message types. Both ConsensusDirectSend* and ConsensusRpc* protocols are registered to the same upstream handler, allowing malicious peers to send RPC-intended messages via DirectSendMsg or vice versa, causing critical consensus messages to be silently dropped.

## Finding Description

The network layer's `add_service` method in the PeerManager builder registers both DirectSend and RPC protocols to a single upstream handler without any type safety enforcement: [1](#0-0) 

This causes all consensus protocols (ConsensusDirectSendBcs, ConsensusDirectSendJson, ConsensusDirectSendCompressed, ConsensusRpcBcs, ConsensusRpcJson, ConsensusRpcCompressed) to map to the same handler. When a message arrives, the Peer actor routes it based on `protocol_id`: [2](#0-1) [3](#0-2) 

The critical issue is that a malicious peer can send:
1. **DirectSendMsg** with `protocol_id = ConsensusRpcBcs` containing BlockRetrievalRequest data
2. **RpcRequest** with `protocol_id = ConsensusDirectSendBcs` containing ProposalMsg data

The consensus NetworkTask processes these events but expects specific message types on specific event variants: [4](#0-3) [5](#0-4) 

When messages arrive with mismatched types, consensus logs warnings and drops them: [6](#0-5) [7](#0-6) 

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria as it enables:

1. **Consensus Liveness Attack**: A Byzantine validator can send critical ProposalMsg, VoteMsg, or BlockRetrievalRequest messages with mismatched message types (e.g., ProposalMsg as RpcRequest instead of DirectSendMsg). These messages will be dropped, potentially stalling consensus if the Byzantine validator is the designated proposer.

2. **Validator Node Slowdowns**: Legitimate requests sent with wrong message types cause unnecessary deserialization, logging, and dropping, consuming validator resources.

3. **Protocol Violation**: The type safety guarantee that DirectSend protocols only carry DirectSendMsg and RPC protocols only carry RpcRequest is violated, breaking the protocol abstraction.

## Likelihood Explanation

**Likelihood: High**

Any authenticated network peer (including Byzantine validators, which Aptos must tolerate up to 1/3 of stake) can exploit this by:
1. Sending messages with arbitrary protocol_id/message type combinations
2. No special privileges beyond network authentication required
3. Attack is trivial to execute - simply mismatching wire message type with protocol_id
4. Difficult to detect without analyzing network logs across all validators

## Recommendation

Add validation in the Peer message handler to enforce type safety between protocol_id and message type:

```rust
// In network/framework/src/peer/mod.rs, handle_inbound_network_message method
match &message {
    NetworkMessage::DirectSendMsg(direct) => {
        // ADDED: Validate DirectSend protocols only used with DirectSendMsg
        if !is_direct_send_protocol(direct.protocol_id) {
            warn!(
                "Received DirectSendMsg with RPC protocol_id: {:?}",
                direct.protocol_id
            );
            return Ok(()); // Drop invalid message
        }
        // ... existing code ...
    },
    NetworkMessage::RpcRequest(request) => {
        // ADDED: Validate RPC protocols only used with RpcRequest
        if !is_rpc_protocol(request.protocol_id) {
            warn!(
                "Received RpcRequest with DirectSend protocol_id: {:?}",
                request.protocol_id
            );
            return Ok(()); // Drop invalid message
        }
        // ... existing code ...
    },
    // ... rest of match ...
}

// Helper functions
fn is_direct_send_protocol(protocol: ProtocolId) -> bool {
    matches!(protocol,
        ProtocolId::ConsensusDirectSendBcs |
        ProtocolId::ConsensusDirectSendJson |
        ProtocolId::ConsensusDirectSendCompressed |
        ProtocolId::MempoolDirectSend |
        // ... other DirectSend protocols ...
    )
}

fn is_rpc_protocol(protocol: ProtocolId) -> bool {
    matches!(protocol,
        ProtocolId::ConsensusRpcBcs |
        ProtocolId::ConsensusRpcJson |
        ProtocolId::ConsensusRpcCompressed |
        // ... other RPC protocols ...
    )
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_protocol_type_confusion() {
    use aptos_types::PeerId;
    use network::protocols::wire::messaging::v1::{NetworkMessage, DirectSendMsg, RpcRequest};
    use network::ProtocolId;
    
    // Attacker creates DirectSendMsg with RPC protocol
    let malicious_msg = NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::ConsensusRpcBcs, // RPC protocol!
        priority: 0,
        raw_msg: serialize_block_retrieval_request(), // RPC message data
    });
    
    // When peer receives this:
    // 1. Looks up handler for ConsensusRpcBcs -> finds consensus handler
    // 2. Pushes as Event::Message instead of Event::RpcRequest
    // 3. Consensus receives Event::Message for a BlockRetrievalRequest
    // 4. Consensus drops it as "Unexpected direct send msg"
    
    // Similarly, attacker can send RPC with DirectSend protocol:
    let malicious_rpc = NetworkMessage::RpcRequest(RpcRequest {
        protocol_id: ProtocolId::ConsensusDirectSendBcs, // DirectSend protocol!
        request_id: 1,
        priority: 0,
        raw_request: serialize_proposal_msg(), // DirectSend message data
    });
    
    // This arrives as Event::RpcRequest when consensus expects Event::Message
    // Result: Proposal is dropped, consensus may stall
}
```

## Notes

The vulnerability exists because the `SerializedRequest` trait provides a common interface for both DirectSend and RPC messages, but the network layer doesn't enforce that DirectSend ProtocolIds are only used with DirectSendMsg wire types and RPC ProtocolIds are only used with RpcRequest wire types. This breaks the type safety guarantee and enables message misrouting attacks.

### Citations

**File:** network/framework/src/peer_manager/builder.rs (L423-429)
```rust
        for protocol in config
            .direct_send_protocols_and_preferences
            .iter()
            .chain(&config.rpc_protocols_and_preferences)
        {
            pm_context.add_upstream_handler(*protocol, network_notifs_tx.clone());
        }
```

**File:** network/framework/src/peer/mod.rs (L459-466)
```rust
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
```

**File:** network/framework/src/peer/mod.rs (L506-518)
```rust
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
```

**File:** consensus/src/network.rs (L863-901)
```rust
                        consensus_msg @ (ConsensusMsg::ProposalMsg(_)
                        | ConsensusMsg::OptProposalMsg(_)
                        | ConsensusMsg::VoteMsg(_)
                        | ConsensusMsg::RoundTimeoutMsg(_)
                        | ConsensusMsg::OrderVoteMsg(_)
                        | ConsensusMsg::SyncInfo(_)
                        | ConsensusMsg::EpochRetrievalRequest(_)
                        | ConsensusMsg::EpochChangeProof(_)) => {
                            if let ConsensusMsg::ProposalMsg(proposal) = &consensus_msg {
                                observe_block(
                                    proposal.proposal().timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED,
                                );
                                info!(
                                    LogSchema::new(LogEvent::NetworkReceiveProposal)
                                        .remote_peer(peer_id),
                                    block_round = proposal.proposal().round(),
                                    block_hash = proposal.proposal().id(),
                                );
                            }
                            if let ConsensusMsg::OptProposalMsg(proposal) = &consensus_msg {
                                observe_block(
                                    proposal.timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED,
                                );
                                observe_block(
                                    proposal.timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED_OPT_PROPOSAL,
                                );
                                info!(
                                    LogSchema::new(LogEvent::NetworkReceiveOptProposal)
                                        .remote_peer(peer_id),
                                    block_author = proposal.proposer(),
                                    block_epoch = proposal.epoch(),
                                    block_round = proposal.round(),
                                );
                            }
                            Self::push_msg(peer_id, consensus_msg, &self.consensus_messages_tx);
                        },
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/network.rs (L943-976)
```rust
                Event::RpcRequest(peer_id, msg, protocol, callback) => {
                    counters::CONSENSUS_RECEIVED_MSGS
                        .with_label_values(&[msg.name()])
                        .inc();
                    let req = match msg {
                        // TODO @bchocho @hariria revisit deprecation later once BlockRetrievalRequest enum is released
                        ConsensusMsg::DeprecatedBlockRetrievalRequest(request) => {
                            debug!(
                                remote_peer = peer_id,
                                event = LogEvent::ReceiveBlockRetrieval,
                                "{}",
                                request
                            );
                            IncomingRpcRequest::DeprecatedBlockRetrieval(
                                DeprecatedIncomingBlockRetrievalRequest {
                                    req: *request,
                                    protocol,
                                    response_sender: callback,
                                },
                            )
                        },
                        ConsensusMsg::BlockRetrievalRequest(request) => {
                            debug!(
                                remote_peer = peer_id,
                                event = LogEvent::ReceiveBlockRetrieval,
                                "{:?}",
                                request
                            );
                            IncomingRpcRequest::BlockRetrieval(IncomingBlockRetrievalRequest {
                                req: *request,
                                protocol,
                                response_sender: callback,
                            })
                        },
```

**File:** consensus/src/network.rs (L1015-1018)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected msg: {:?}", msg);
                            continue;
                        },
```
