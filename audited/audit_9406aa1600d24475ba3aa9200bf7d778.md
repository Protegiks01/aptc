# Audit Report

## Title
Critical State Corruption in SafetyRules Epoch Initialization Leading to Consensus Safety Violation

## Summary
The `retry()` logic in `MetricsSafetyRules` can cause permanent state divergence when `guarded_initialize()` fails after partially updating persistent storage. Safety data is unconditionally reset to a new epoch before verifying validator membership, causing irreversible corruption of consensus-critical state that leaves validators unable to participate in either the old or new epoch.

## Finding Description

The vulnerability exists in a critical ordering flaw between state persistence and validation in the epoch initialization process.

**Execution Flow:**

When a validator receives a proposal for a different epoch, the epoch mismatch triggers the retry mechanism. The `retry()` function in `MetricsSafetyRules` catches `IncorrectEpoch` errors and attempts reinitialization: [1](#0-0) 

The `perform_initialize()` method retrieves epoch change proofs from local storage and calls `initialize()`: [2](#0-1) 

Within `guarded_initialize()`, there is a critical ordering flaw. When transitioning to a new epoch (`Ordering::Less` case), the safety data is **immediately and permanently persisted** with reset values: [3](#0-2) 

**The Critical Flaw:** After persisting the new epoch state, validator membership verification occurs. If this verification fails (validator not in new validator set or key retrieval failure), these errors are returned: [4](#0-3) 

These errors (`ValidatorNotInSet` and `ValidatorKeyNotFound`) are **NOT** in the retry-eligible list, which only includes `NotInitialized`, `IncorrectEpoch`, and `WaypointOutOfDate`: [5](#0-4) 

The `set_safety_data()` operation provides no rollback mechanism, making the corruption permanent: [6](#0-5) 

**Attack Scenario:**

1. Validator is in epoch 100, has voted through round 50
2. Network transitions to epoch 101, validator receives proposal for new epoch
3. `IncorrectEpoch` error triggers `retry()` → `perform_initialize()` → `guarded_initialize()`
4. Safety data is persisted: `SafetyData(epoch=101, last_voted_round=0, preferred_round=0, one_chain_round=0)`
5. Validator membership check fails (validator rotated out of set) or key retrieval fails (temporary storage issue)
6. `ValidatorNotInSet` or `ValidatorKeyNotFound` error returned (not retry-eligible)
7. **Validator now corrupted:**
   - Persistent storage shows epoch 101 with reset safety data
   - Cannot participate in epoch 100 (storage shows wrong epoch)
   - Cannot participate in epoch 101 (not in validator set or missing keys)
   - All previous voting history permanently lost

The error handling sets `validator_signer = None` but does not roll back the persisted safety data: [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability breaks fundamental consensus safety guarantees:

1. **Validator Liveness Loss**: Validator permanently locked out from consensus participation. Cannot process proposals for any epoch without manual intervention.

2. **Safety Data Corruption**: Critical consensus state (`last_voted_round`, `preferred_round`, `one_chain_round`) reset to 0, erasing voting history that prevents double-voting.

3. **Consensus Safety Violation**: If validator later becomes available for the new epoch, it starts with `last_voted_round=0`, potentially enabling double-voting for rounds it already voted on before corruption occurred.

4. **Network Stability Risk**: During epoch transitions, multiple validators experiencing this corruption simultaneously could cause consensus failures requiring manual intervention or network partition.

This meets Critical Severity criteria per Aptos bug bounty program:
- **Consensus/Safety Violations**: State corruption that can enable double-voting
- **Non-recoverable Network Partition**: Multiple affected validators could cause consensus failure
- **State Inconsistency**: Breaks consensus guarantees that prevent equivocation

## Likelihood Explanation

**High Likelihood** - This vulnerability can be triggered through normal network operations:

1. **Regular Occurrence**: Epoch transitions occur periodically (~2 hours in production networks)

2. **Legitimate Triggers**:
   - Validator rotation (planned removal from validator set)
   - Temporary storage unavailability (network issues, vault token expiry - system panics on permission errors per error handling)
   - Key management issues (key not yet synced to storage)

3. **No Privileged Access Required**: Triggered by receiving normal epoch transition proposals from network peers

4. **No Recovery Mechanism**: Once corrupted, validator requires manual database intervention to recover

5. **Production Reality**: Storage failures and key management issues occur in real deployments, especially during epoch transitions when validators are being rotated

The vulnerability is triggered by the combination of: (a) normal epoch transitions, and (b) either planned validator rotation OR transient failures (storage/key issues), both of which are expected in production environments.

## Recommendation

Implement transactional semantics for epoch initialization with proper rollback:

```rust
fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
    // ... validation logic ...
    
    let current_epoch = self.persistent_storage.safety_data()?.epoch;
    match current_epoch.cmp(&epoch_state.epoch) {
        Ordering::Less => {
            // FIRST: Verify validator membership BEFORE persisting
            let author = self.persistent_storage.author()?;
            let expected_key = epoch_state.verifier.get_public_key(&author);
            
            let validator_signer = match expected_key {
                None => return Err(Error::ValidatorNotInSet(author.to_string())),
                Some(expected_key) => {
                    // ... key reconciliation logic ...
                }
            }?;
            
            // THEN: Persist only after validation succeeds
            self.persistent_storage.set_safety_data(SafetyData::new(
                epoch_state.epoch, 0, 0, 0, None, 0
            ))?;
            
            self.validator_signer = Some(validator_signer);
            info!(SafetyLogSchema::new(LogEntry::Epoch, LogEvent::Update)
                .epoch(epoch_state.epoch));
        },
        // ... other cases ...
    }
}
```

Alternatively, make `ValidatorNotInSet` and `ValidatorKeyNotFound` errors retry-eligible with exponential backoff to allow transient storage issues to resolve.

## Proof of Concept

The existing test suite demonstrates this vulnerability: [8](#0-7) 

This test shows that after `initialize()` returns `ValidatorNotInSet` error, the validator state has `in_validator_set() = false`, but the test does not verify whether the safety data epoch was already persisted (it was, per line 296-303 in safety_rules.rs).

To demonstrate the full corruption, extend this test to verify:
1. Initial state: epoch 0, last_voted_round > 0
2. Call `initialize()` with validator not in new epoch set
3. Verify error returned: `ValidatorNotInSet`
4. Check persistent storage: epoch updated to 1, last_voted_round reset to 0
5. Attempt to vote on old epoch: fails with `IncorrectEpoch(0, 1)`
6. Attempt to vote on new epoch: fails with `ValidatorNotInSet`
7. Validator is permanently corrupted with no recovery path

## Notes

The vulnerability is exacerbated by the fact that epoch change proofs come from the validator's own local storage (not from malicious network peers), meaning any validator that has synced to a new epoch but is being rotated out will experience this corruption when it receives its first proposal for the new epoch.

### Citations

**File:** consensus/src/metrics_safety_rules.rs (L40-69)
```rust
    pub fn perform_initialize(&mut self) -> Result<(), Error> {
        let consensus_state = self.consensus_state()?;
        let mut waypoint_version = consensus_state.waypoint().version();
        loop {
            let proofs = self
                .storage
                .retrieve_epoch_change_proof(waypoint_version)
                .map_err(|e| {
                    Error::InternalError(format!(
                        "Unable to retrieve Waypoint state from storage, encountered Error:{}",
                        e
                    ))
                })?;
            // We keep initializing safety rules as long as the waypoint continues to increase.
            // This is due to limits in the number of epoch change proofs that storage can provide.
            match self.initialize(&proofs) {
                Err(Error::WaypointOutOfDate(
                    prev_version,
                    curr_version,
                    current_epoch,
                    provided_epoch,
                )) if prev_version < curr_version => {
                    waypoint_version = curr_version;
                    info!("Previous waypoint version {}, updated version {}, current epoch {}, provided epoch {}", prev_version, curr_version, current_epoch, provided_epoch);
                    continue;
                },
                result => return result,
            }
        }
    }
```

**File:** consensus/src/metrics_safety_rules.rs (L71-85)
```rust
    fn retry<T, F: FnMut(&mut Box<dyn TSafetyRules + Send + Sync>) -> Result<T, Error>>(
        &mut self,
        mut f: F,
    ) -> Result<T, Error> {
        let result = f(&mut self.inner);
        match result {
            Err(Error::NotInitialized(_))
            | Err(Error::IncorrectEpoch(_, _))
            | Err(Error::WaypointOutOfDate(_, _, _, _)) => {
                self.perform_initialize()?;
                f(&mut self.inner)
            },
            _ => result,
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L284-310)
```rust
        match current_epoch.cmp(&epoch_state.epoch) {
            Ordering::Greater => {
                // waypoint is not up to the current epoch.
                return Err(Error::WaypointOutOfDate(
                    waypoint.version(),
                    new_waypoint.version(),
                    current_epoch,
                    epoch_state.epoch,
                ));
            },
            Ordering::Less => {
                // start new epoch
                self.persistent_storage.set_safety_data(SafetyData::new(
                    epoch_state.epoch,
                    0,
                    0,
                    0,
                    None,
                    0,
                ))?;

                info!(SafetyLogSchema::new(LogEntry::Epoch, LogEvent::Update)
                    .epoch(epoch_state.epoch));
            },
            Ordering::Equal => (),
        };
        self.epoch_state = Some(epoch_state.clone());
```

**File:** consensus/safety-rules/src/safety_rules.rs (L312-343)
```rust
        let author = self.persistent_storage.author()?;
        let expected_key = epoch_state.verifier.get_public_key(&author);
        let initialize_result = match expected_key {
            None => Err(Error::ValidatorNotInSet(author.to_string())),
            Some(expected_key) => {
                let current_key = self.signer().ok().map(|s| s.public_key());
                if current_key == Some(expected_key.clone()) {
                    info!(
                        SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Success),
                        "in set",
                    );
                    Ok(())
                } else {
                    // Try to export the consensus key directly from storage.
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
                        },
                        Err(Error::SecureStorageMissingDataError(error)) => {
                            Err(Error::ValidatorKeyNotFound(error))
                        },
                        Err(error) => Err(error),
                    }
                }
            },
        };
        initialize_result.inspect_err(|error| {
            info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
            self.validator_signer = None;
        })
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-169)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L596-639)
```rust
fn test_validator_not_in_set(safety_rules: &Callback) {
    // Testing for a validator missing from the validator set
    // It does so by updating the safey rule to an epoch state, which does not contain the
    // current validator and check the consensus state

    let (mut safety_rules, signer) = safety_rules();

    let (mut proof, genesis_qc) = test_utils::make_genesis(&signer);
    let round = genesis_qc.certified_block().round();

    safety_rules.initialize(&proof).unwrap();

    // validator_signer is set during initialization
    let state = safety_rules.consensus_state().unwrap();
    assert!(state.in_validator_set());

    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);

    // remove the validator_signer in next epoch
    let mut next_epoch_state = EpochState::empty();
    next_epoch_state.epoch = 1;
    let rand_signer = ValidatorSigner::random([0xFu8; 32]);
    next_epoch_state.verifier =
        ValidatorVerifier::new_single(rand_signer.author(), rand_signer.public_key()).into();
    let a2 = test_utils::make_proposal_with_parent_and_overrides(
        Payload::empty(false, true),
        round + 2,
        &a1,
        Some(&a1),
        &signer,
        Some(1),
        Some(next_epoch_state),
    );
    proof
        .ledger_info_with_sigs
        .push(a2.block().quorum_cert().ledger_info().clone());
    assert!(matches!(
        safety_rules.initialize(&proof),
        Err(Error::ValidatorNotInSet(_))
    ));

    let state = safety_rules.consensus_state().unwrap();
    assert!(!state.in_validator_set());
}
```
