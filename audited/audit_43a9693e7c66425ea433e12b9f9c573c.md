# Audit Report

## Title
Panic-Based Denial of Service via Unsupported StorageLocation Variants in Remote Executor Service

## Summary
The `StorageLocation::state_key()` method unconditionally panics when called on `WildCardStruct` or `WildCardTable` variants. This panic can be triggered by deserializing a crafted `RemoteExecutionRequest` containing transactions with wildcard storage locations, causing the executor shard to crash.

## Finding Description

The `StorageLocation` enum defines three variants: `Specific`, `WildCardStruct`, and `WildCardTable`. However, the `state_key()` method only handles the `Specific` variant and panics on wildcards: [1](#0-0) 

This method is called in two critical locations:

1. **Block Partitioner**: During initialization when processing transaction hints: [2](#0-1) 

2. **Remote Executor Service**: When extracting state keys from execution commands: [3](#0-2) 

The remote executor service deserializes `RemoteExecutionRequest` messages from the network without validating storage location variants: [4](#0-3) 

Since `StorageLocation` derives `Deserialize`, an attacker can craft a serialized message containing wildcard variants: [5](#0-4) 

The remote executor service uses unauthenticated gRPC over plain HTTP: [6](#0-5) 

**Attack Path:**
1. Attacker gains network access to executor service (either through misconfiguration exposing the service publicly, or via internal network compromise)
2. Attacker crafts a `RemoteExecutionRequest::ExecuteBlock` containing `AnalyzedTransaction` with `WildCardStruct` or `WildCardTable` storage locations
3. Message is serialized and sent via gRPC to the executor service
4. Service deserializes the request without validation
5. `extract_state_keys()` is called, which invokes `state_key()` on wildcard variants
6. Panic occurs, crashing the executor shard process

## Impact Explanation

This vulnerability falls under **High Severity** per Aptos bug bounty criteria:
- **"API crashes"**: The executor shard process terminates due to panic
- **"Validator node slowdowns"**: If sharded execution is in use, block execution fails, requiring restart and causing performance degradation

The panic breaks the **Deterministic Execution** invariant by causing non-deterministic failures based on external network input. While normal transaction processing never creates wildcard variants, the deserialization path bypasses this safety.

However, the impact is **limited** by deployment constraints:
- The remote executor service is designed for internal-only communication between a coordinator and its shards
- There is no evidence this service is exposed to public networks in production deployments
- The service is likely colocated with the validator operator's infrastructure

## Likelihood Explanation

The likelihood is **LOW to MEDIUM** depending on deployment:

**Low** if:
- Service is deployed on private networks with proper firewall rules
- Only used for internal testing/benchmarking, not production validators
- Network access is restricted to trusted components

**Medium** if:
- Service is misconfigured and exposed to public internet
- Internal network is compromised
- Deployed in shared infrastructure where other tenants could access the service

The current codebase shows no instantiation of wildcard variants in normal transaction processing: [7](#0-6) 

Only specific transaction types are supported, and wildcard variants appear to be defined for future use but not currently implemented.

## Recommendation

**Immediate Fix**: Replace panic with error handling:

```rust
pub fn state_key(&self) -> Result<&StateKey, StorageLocationError> {
    match self {
        StorageLocation::Specific(state_key) => Ok(state_key),
        StorageLocation::WildCardStruct(_) => Err(StorageLocationError::UnsupportedWildcard),
        StorageLocation::WildCardTable(_) => Err(StorageLocationError::UnsupportedWildcard),
    }
}
```

**Defense in Depth**:
1. Add validation when deserializing `RemoteExecutionRequest` to reject wildcard variants
2. Implement authentication/authorization for the remote executor service
3. Add TLS encryption for network communication
4. Document deployment security requirements clearly

**Validation at Deserialization**: [8](#0-7) 

Add validation after deserialization to verify all storage locations are `Specific` variants.

## Proof of Concept

```rust
use aptos_types::transaction::analyzed_transaction::{AnalyzedTransaction, StorageLocation};
use aptos_executor_service::{RemoteExecutionRequest, ExecuteBlockCommand};
use move_core_types::language_storage::StructTag;

#[test]
#[should_panic(expected = "Cannot convert wildcard storage location to state key")]
fn test_wildcard_storage_location_panic() {
    // Create a crafted AnalyzedTransaction with wildcard storage location
    let wildcard_struct_tag = StructTag {
        address: AccountAddress::ONE,
        module: Identifier::new("test").unwrap(),
        name: Identifier::new("Resource").unwrap(),
        type_params: vec![],
    };
    
    let wildcard_location = StorageLocation::WildCardStruct(wildcard_struct_tag);
    
    // This will panic when state_key() is called
    let _ = wildcard_location.state_key();
}

#[test]
fn test_remote_execution_request_with_wildcard() {
    // Demonstrates that wildcard variants can be serialized/deserialized
    let wildcard_location = StorageLocation::WildCardStruct(/* ... */);
    
    // Create AnalyzedTransaction with wildcard hints
    let analyzed_txn = /* construct with wildcard_location in read_hints */;
    
    // Create RemoteExecutionRequest
    let request = RemoteExecutionRequest::ExecuteBlock(
        ExecuteBlockCommand { /* with analyzed_txn */ }
    );
    
    // Serialize and deserialize
    let serialized = bcs::to_bytes(&request).unwrap();
    let deserialized: RemoteExecutionRequest = bcs::from_bytes(&serialized).unwrap();
    
    // Processing this request would cause panic in extract_state_keys()
}
```

## Notes

While this is a real code defect, its exploitability is **contingent on deployment configuration**:

1. **Current Production Status Unclear**: There is no clear evidence the remote executor service is deployed on mainnet production validators
   
2. **Internal-Only Design**: The service architecture assumes trusted internal communication: [9](#0-8) 

3. **Forward Compatibility Issue**: The wildcard variants appear to be defined for future functionality but are not currently used in transaction processing

4. **Defense Assumptions**: The code assumes network-level protection (firewalls, VPNs) rather than application-level authentication

This represents a **defense-in-depth violation** and **poor error handling practice** rather than a directly exploitable vulnerability in typical deployments. The severity would escalate to High if the service is exposed to untrusted networks.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L39-49)
```rust
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
// TODO(skedia): Evaluate if we need to cache the HashValue for efficiency reasons.
pub enum StorageLocation {
    // A specific storage location denoted by an address and a struct tag.
    Specific(StateKey),
    // Storage location denoted by a struct tag and any arbitrary address.
    // Example read<T>(*), write<T>(*) in Move
    WildCardStruct(StructTag),
    // Storage location denoted by a table handle and any arbitrary item in the table.
    WildCardTable(TableHandle),
}
```

**File:** types/src/transaction/analyzed_transaction.rs (L59-64)
```rust
    pub fn state_key(&self) -> &StateKey {
        match self {
            StorageLocation::Specific(state_key) => state_key,
            _ => panic!("Cannot convert wildcard storage location to state key"),
        }
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L244-270)
```rust
impl AnalyzedTransactionProvider for Transaction {
    fn get_read_write_hints(&self) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
        let process_entry_function = |func: &EntryFunction,
                                      sender_address: AccountAddress|
         -> (Vec<StorageLocation>, Vec<StorageLocation>) {
            match (
                *func.module().address(),
                func.module().name().as_str(),
                func.function().as_str(),
            ) {
                (AccountAddress::ONE, "coin", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, true)
                },
                (AccountAddress::ONE, "aptos_account", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, false)
                },
                (AccountAddress::ONE, "aptos_account", "create_account") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_create_account(sender_address, receiver_address)
                },
                _ => todo!(
                    "Only coin transfer and create account transactions are supported for now"
                ),
            }
        };
```

**File:** execution/block-partitioner/src/v2/init.rs (L28-33)
```rust
                    let reads = txn.read_hints.iter().map(|loc| (loc, false));
                    let writes = txn.write_hints.iter().map(|loc| (loc, true));
                    reads
                        .chain(writes)
                        .for_each(|(storage_location, is_write)| {
                            let key_idx = state.add_key(storage_location.state_key());
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L62-68)
```rust
                        for storage_location in txn
                            .txn()
                            .read_hints()
                            .iter()
                            .chain(txn.txn().write_hints().iter())
                        {
                            state_keys.push(storage_location.state_key().clone());
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L89-98)
```rust
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
```

**File:** secure/net/src/grpc_network_service/mod.rs (L92-115)
```rust
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/main.rs (L20-24)
```rust
    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
```
