# Audit Report

## Title
Missing Gas Deposit Enforcement for Randomness Transactions Enables Test-and-Abort Attacks

## Summary
The Aptos randomness API lacks enforcement of required gas deposits for transactions using randomness, allowing attackers to perform test-and-abort attacks by setting artificially low `max_gas_units` values while still accessing randomness APIs through the `#[randomness]` annotation.

## Finding Description

The randomness system is designed to prevent "test-and-abort" attacks where users observe random values and abort transactions with unfavorable outcomes. The intended protection mechanism involves requiring transactions to pre-charge or commit to paying a maximum gas amount, even if they abort early. [1](#0-0) 

However, the actual enforcement is missing. When a transaction with a `#[randomness]` annotation is processed: [2](#0-1) 

The code only verifies that the annotation EXISTS, but never validates that the transaction's `txn_max_gas_units` matches the annotation's `max_gas` value or the on-chain `RequiredGasDeposit` configuration.

Infrastructure exists for this validation:
- On-chain configs: [3](#0-2) 
- Config fetching: [4](#0-3) 
- Error codes: [5](#0-4) 

But no code actually uses these to validate transactions before execution.

**Attack Path:**
1. Attacker deploys a module with `#[randomness(max_gas = 1000000)]` on an entry function
2. Attacker submits transaction calling this function with `txn_max_gas_units = 5000` (much lower)
3. Prologue checks balance >= `txn_gas_price * 5000` (passes easily)
4. Transaction executes and is marked as unbiasable (annotation exists)
5. Function calls `randomness::u64_integer()` to get random value
6. If value is unfavorable, function calls `abort()`
7. Epilogue charges only for gas actually used before abort (e.g., 1000 gas units)
8. Attacker pays minimal cost and can retry many times until favorable outcome

The standard gas charging only bills for actual usage: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability completely undermines the security of the randomness API, enabling:

1. **Biased Randomness**: Attackers can filter for favorable random outcomes in any randomness-dependent application (lotteries, NFT mints, games, etc.)
2. **Economic Loss**: Legitimate users of randomness-based protocols lose to attackers who can cherry-pick outcomes
3. **Consensus Invariant Violation**: Breaks the fundamental guarantee that randomness is unbiasable
4. **Protocol Trust Failure**: Any protocol built on Aptos randomness becomes exploitable

The impact meets Critical severity under "Loss of Funds" and "Consensus/Safety violations" categories, as it allows systematic extraction of value from randomness-dependent protocols.

## Likelihood Explanation

**High Likelihood** - The attack is:
- **Easy to execute**: Requires only setting a lower max_gas parameter when submitting transactions
- **Low cost**: Failed attempts cost minimal gas (only up to abort point)
- **High reward**: Can extract significant value from randomness-dependent applications
- **Already documented**: The comment in the code explicitly acknowledges the need for protection that isn't implemented
- **No special privileges required**: Any transaction sender can exploit this

## Recommendation

Implement validation that enforces the required gas deposit matches transaction max_gas before execution. The validation should occur before the transaction executes:

```rust
// In aptos_vm.rs, after getting the randomness annotation:
if function.is_friend_or_private() {
    let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
        entry_fn,
        &function.owner_as_module()?.metadata,
    );
    if let Some(annotation) = maybe_randomness_annotation {
        session.mark_unbiasable();
        
        // NEW: Validate required gas deposit
        let randomness_config = RandomnessConfig::fetch(resolver);
        let required_gas = if randomness_config.allow_rand_contract_custom_max_gas {
            annotation.max_gas.unwrap_or(randomness_config.randomness_api_v0_required_deposit.unwrap_or(0))
        } else {
            randomness_config.randomness_api_v0_required_deposit.unwrap_or(0)
        };
        
        if required_gas > 0 && txn_metadata.max_gas_amount().into() != required_gas {
            return Err(VMStatus::error(
                StatusCode::REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS,
                None,
            ));
        }
    }
}
```

Additionally, consider pre-charging the full max_gas amount in the prologue for randomness transactions, or implementing a mechanism to charge the full max_gas even if the transaction aborts early.

## Proof of Concept

Create a Move module:
```move
module attacker::lottery {
    use aptos_framework::randomness;
    
    #[randomness(max_gas = 100000)]
    entry fun try_win_lottery(player: &signer) {
        let rand = randomness::u64_integer();
        
        // Abort if not winning number
        assert!(rand % 100 == 42, 1); // Only accept 1% outcomes
        
        // Transfer prize to player (if we reach here)
        // ... prize logic
    }
}
```

Attack execution:
1. Submit transaction calling `try_win_lottery` with `max_gas = 1000` (NOT the declared 100000)
2. Transaction aborts 99% of the time, costing only ~200 gas each
3. Eventually succeeds with favorable random number
4. Total cost: ~200 * 100 = 20,000 gas vs declared 100,000 gas per attempt
5. Attacker wins lottery while paying 5x less than intended deterrent

This allows the attacker to bias randomness by retrying at minimal cost until favorable outcomes occur.

### Citations

**File:** aptos-move/framework/src/natives/randomness.rs (L105-107)
```rust
    // Because we need to run a special transaction prologue to pre-charge maximum
    // amount of gas, we require all callers to have an annotation that the entry
    // function call is unbiasable. This property is only checked at runtime here.
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L983-991)
```rust
            if function.is_friend_or_private() {
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
            }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_api_v0_config.move (L8-15)
```text
    struct RequiredGasDeposit has key, drop, store {
        gas_amount: Option<u64>,
    }

    /// If this flag is set, `max_gas` specified inside `#[randomness()]` will be used as the required deposit.
    struct AllowCustomMaxGasFlag has key, drop, store {
        value: bool,
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L278-298)
```rust
/// A collection of on-chain randomness API configs that VM needs to be aware of.
pub struct RandomnessConfig {
    pub randomness_api_v0_required_deposit: Option<u64>,
    pub allow_rand_contract_custom_max_gas: bool,
}

impl RandomnessConfig {
    /// Returns randomness config based on the current state.
    pub fn fetch(state_view: &impl StateView) -> Self {
        let randomness_api_v0_required_deposit = RequiredGasDeposit::fetch_config(state_view)
            .unwrap_or_else(RequiredGasDeposit::default_if_missing)
            .gas_amount;
        let allow_rand_contract_custom_max_gas = AllowCustomMaxGasFlag::fetch_config(state_view)
            .unwrap_or_else(AllowCustomMaxGasFlag::default_if_missing)
            .value;
        Self {
            randomness_api_v0_required_deposit,
            allow_rand_contract_custom_max_gas,
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/errors.rs (L37-38)
```rust
// Insufficient balance to cover the required deposit.
pub const EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT: u64 = 1011;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L596-603)
```text
        assert!(txn_max_gas_units >= gas_units_remaining, error::invalid_argument(EOUT_OF_GAS));
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;
```
