# Audit Report

## Title
Division by Zero in RotatingProposer Causes Total Network Liveness Failure via Malicious Governance Proposal

## Summary
The `RotatingProposer` implementation contains an unvalidated division operation that panics when `contiguous_rounds` is set to zero. This can be exploited through a governance proposal to cause all validators to crash when determining the valid proposer, resulting in complete network liveness failure requiring a hardfork to recover. RoundProposer's HashMap-based approach prevents this vulnerability by avoiding mathematical operations entirely.

## Finding Description
The `RotatingProposer::get_valid_proposer()` method uses a rigid mathematical formula to determine the proposer for each round. [1](#0-0) 

This formula divides the round number by `contiguous_rounds` without any validation that `contiguous_rounds` is non-zero. The constructor accepts this parameter without validation. [2](#0-1) 

**Attack Path:**

1. A governance proposal is submitted to update the consensus configuration with `ProposerElectionType::RotatingProposer(0)` or `ProposerElectionType::FixedProposer(0)`. [3](#0-2) 

2. The Move framework's `consensus_config::set_for_next_epoch()` function only validates that the config bytes vector is non-empty, not the actual parameter values. [4](#0-3) 

3. Upon epoch transition, `EpochManager::create_proposer_election()` instantiates `RotatingProposer` with the malicious zero value directly from the onchain config. [5](#0-4) 

4. When any validator attempts to determine the valid proposer for any round, the division by zero causes a panic, crashing the validator process.

5. Since all validators receive the same onchain configuration, all validators crash simultaneously when attempting consensus operations.

**Why RoundProposer Prevents This:**

`RoundProposer` uses a simple HashMap lookup with a `default_proposer` fallback, avoiding any division operations. [6](#0-5) 

This flexible approach cannot panic from mathematical edge cases, demonstrating how RoundProposer's design prevents vulnerabilities inherent in RotatingProposer's rigid formula.

## Impact Explanation
This vulnerability meets **Critical Severity** criteria under the Aptos bug bounty program:

- **Total loss of liveness/network availability**: All validators crash when determining proposers, preventing any block proposals or consensus progress
- **Non-recoverable network partition (requires hardfork)**: The network cannot self-recover because the malicious configuration persists across restarts. A hardfork with a patched validator binary or manual configuration override is required
- **Consensus violations**: Violates the fundamental consensus liveness invariant that the network must make progress

The impact affects 100% of validators and requires extraordinary intervention (hardfork) to restore network operation.

## Likelihood Explanation
**Likelihood: Medium to High**

**Attacker Requirements:**
- Ability to submit and pass a governance proposal (requires stake or coordination with governance participants)
- No special validator privileges required
- No technical sophistication beyond crafting the malicious configuration

**Complexity:**
- Low: The exploit is a single-parameter modification in a governance proposal
- The vulnerability is deterministic and guaranteed to work

**Realistic Scenarios:**
- Malicious governance participant with sufficient voting power
- Compromised governance proposal system
- Accidental misconfiguration during legitimate consensus upgrades (human error with zero value)

The lack of any validation at any layer (Move framework, Rust constructor, governance proposal generation) makes this trivially exploitable once governance access is obtained.

## Recommendation
Implement validation at multiple defense layers:

**1. Rust Constructor Validation:**
```rust
impl RotatingProposer {
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        assert!(contiguous_rounds > 0, "contiguous_rounds must be greater than 0");
        assert!(!proposers.is_empty(), "proposers list cannot be empty");
        Self {
            proposers,
            contiguous_rounds,
        }
    }
}
```

**2. Move Framework Validation:**
Add native validation function to check consensus config parameters before accepting them:
```move
native fun validate_consensus_config(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(validate_consensus_config(copy config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**3. Onchain Config Type Safety:**
Consider using a validated newtype wrapper for `contiguous_rounds` that enforces non-zero invariants at the type level.

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::account_address::AccountAddress;

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_rotating_proposer_division_by_zero() {
        // Create RotatingProposer with zero contiguous_rounds
        let proposers = vec![AccountAddress::random(), AccountAddress::random()];
        let pe = RotatingProposer::new(proposers, 0);
        
        // Attempting to get valid proposer for any round causes panic
        let _ = pe.get_valid_proposer(1);
    }

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_fixed_proposer_division_by_zero() {
        // FixedProposer also uses RotatingProposer internally with single proposer
        let proposer = AccountAddress::random();
        let pe = RotatingProposer::new(vec![proposer], 0);
        
        // Same panic occurs with FixedProposer pattern
        let _ = pe.get_valid_proposer(100);
    }
}
```

**Integration Test Scenario:**
```rust
// In consensus integration test
#[test]
fn test_malicious_governance_proposal_zero_contiguous_rounds() {
    // 1. Setup test network with governance
    // 2. Submit governance proposal with:
    //    ProposerElectionType::RotatingProposer(0)
    // 3. Execute proposal through governance
    // 4. Trigger epoch transition
    // 5. Observe: All validators panic on first proposer election attempt
    // 6. Verify: Network cannot make progress
}
```

## Notes
This vulnerability directly answers the security question about RotatingProposer's rigid formula being exploitable in ways that RoundProposer's flexibility prevents. The mathematical formula's dependency on division creates an edge case that HashMap-based lookup inherently avoids. Additional rigid formula vulnerabilities could include modulo-by-zero if the proposers list is empty, though this is less likely in production as validators must exist.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L25-32)
```rust
impl RotatingProposer {
    /// With only one proposer in the vector, it behaves the same as a fixed proposer strategy.
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L510-523)
```rust
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
    // Committed history based proposer election
    LeaderReputation(LeaderReputationType),
    // Pre-specified proposers for each round,
    // or default proposer if round proposer not
    // specified
    RoundProposer(HashMap<Round, AccountAddress>),
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/epoch_manager.rs (L296-304)
```rust
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
            },
```

**File:** consensus/src/liveness/round_proposer_election.rs (L26-32)
```rust
impl ProposerElection for RoundProposer {
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            None => self.default_proposer,
            Some(round_proposer) => *round_proposer,
        }
    }
```
