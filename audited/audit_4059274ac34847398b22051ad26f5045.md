# Audit Report

## Title
Aggregator V1 Delta Operations Bypass Storage Fee Charging, Enabling Cheap State Bloat Attacks

## Summary
Aggregator V1 delta operations (increments/decrements) are not charged storage fees during transaction execution because they are materialized into write operations AFTER `process_storage_fee_for_all()` has already completed. This allows attackers to modify aggregator state slots repeatedly at zero storage cost, enabling cheap state bloat attacks and potential denial-of-service.

## Finding Description

The vulnerability exists in the transaction execution flow where storage fees are charged before aggregator deltas are materialized into concrete write operations.

**Execution Flow:**

1. User transaction executes and creates aggregator delta operations (add/subtract operations on aggregators)
2. Session finishes producing a `VMChangeSet` with `aggregator_v1_delta_set` populated
3. `charge_change_set()` is called on the `UserSessionChangeSet` [1](#0-0) 

4. `process_storage_fee_for_all()` iterates over write operations to charge fees [2](#0-1) 

5. The iteration uses `write_op_info_iter_mut()` which only includes `resource_write_set` and `aggregator_v1_write_set`, but NOT `aggregator_v1_delta_set` [3](#0-2) 

6. Epilogue session is created preserving the unmaterialized `aggregator_v1_delta_set` [4](#0-3) 

7. Final `VMOutput` is created with deltas still unmaterialized [5](#0-4) 

8. Later, `try_materialize_aggregator_v1_delta_set()` converts deltas into `WriteOp` objects with `StateValueMetadata::none()` (zero metadata) [6](#0-5) 

9. When materialized, deltas become `WriteOp::legacy_modification()` with no metadata [7](#0-6) 

10. These operations create `StateValue::new_legacy()` with `StateValueMetadata::none()` [8](#0-7) 

**The Critical Gap:**
Storage fees are calculated in `process_storage_fee_for_all()` which is called only ONCE during `charge_change_set()`, but aggregator deltas are materialized AFTER this point. The materialization happens when `try_materialize()` is called on the `VMOutput`, but by then storage fees have already been charged and finalized. [9](#0-8) 

## Impact Explanation

**Severity: High to Medium**

This vulnerability allows attackers to:

1. **Cheap State Bloat**: Repeatedly modify aggregator values without paying storage fees for the modifications, bloating state storage
2. **DoS via State Growth**: Accumulate state changes that nodes must process and store, degrading network performance
3. **Storage Fee Evasion**: Modify existing aggregator slots (which were initially paid for) indefinitely at zero marginal cost
4. **Consensus Strain**: Force validators to process and synchronize state changes that were undercharged

The impact qualifies as **High Severity** per the Aptos bug bounty criteria because it enables "significant protocol violations" - specifically, the invariant that "all operations must respect gas, storage, and computational limits" is violated. While it doesn't directly cause loss of funds, it allows cheap state manipulation that could degrade network performance and increase operational costs for validators.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploitable because:

1. **No Special Privileges Required**: Any transaction sender can use aggregator operations
2. **Simple Attack Vector**: Standard aggregator increment/decrement operations trigger the vulnerability
3. **Aggregators are Common**: Aggregator V1 is used throughout the Aptos framework for counters and accumulators
4. **No Detection**: The bypass is structural - no runtime checks detect this undercharging
5. **Repeatable**: Attackers can repeatedly exploit this in every transaction

The only limiting factor is that aggregators must already exist (creation is charged normally), but once created, they can be modified indefinitely at zero storage cost.

## Recommendation

**Solution: Materialize aggregator deltas BEFORE charging storage fees**

The fix requires materializing `aggregator_v1_delta_set` into `aggregator_v1_write_set` before `charge_change_set()` is called:

```rust
// In charge_change_set_and_respawn_session or before calling it:
fn charge_change_set_and_respawn_session<'r>(
    &self,
    mut user_session_change_set: UserSessionChangeSet,
    resolver: &'r impl AptosMoveResolver,
    module_storage: &impl AptosModuleStorage,
    gas_meter: &mut impl AptosGasMeter,
    txn_data: &TransactionMetadata,
) -> Result<EpilogueSession<'r>, VMStatus> {
    // CRITICAL FIX: Materialize aggregator deltas BEFORE charging storage fees
    let (mut change_set, module_write_set) = user_session_change_set.unpack();
    change_set.try_materialize_aggregator_v1_delta_set(resolver)?;
    user_session_change_set = UserSessionChangeSet::new(
        change_set,
        module_write_set,
        change_set_configs,
    )?;
    
    // Now charge storage fees with materialized deltas included
    let storage_refund = self.charge_change_set(
        &mut user_session_change_set,
        gas_meter,
        txn_data,
        resolver,
        module_storage,
    )?;
    
    Ok(EpilogueSession::on_user_session_success(
        self,
        txn_data,
        resolver,
        user_session_change_set,
        storage_refund,
    ))
}
```

Additionally, ensure materialized write operations have proper metadata rather than `StateValueMetadata::none()`.

## Proof of Concept

```move
// PoC demonstrating aggregator modification without storage fee charging
module attacker::state_bloat {
    use aptos_framework::aggregator_v2;
    use std::signer;
    
    struct BloatResource has key {
        counter: aggregator_v2::Aggregator<u64>,
    }
    
    // Initial setup - this WILL be charged storage fees
    public entry fun setup(account: &signer) {
        move_to(account, BloatResource {
            counter: aggregator_v2::create_aggregator(1000000000),
        });
    }
    
    // This function can be called repeatedly to modify state
    // WITHOUT paying storage fees for the modifications
    public entry fun bloat_state(account: &signer) acquires BloatResource {
        let addr = signer::address_of(account);
        let resource = borrow_global_mut<BloatResource>(addr);
        
        // These operations create aggregator deltas
        // Deltas bypass storage fee charging!
        aggregator_v2::add(&mut resource.counter, 1);
        // Each call modifies state but pays zero storage fees
    }
}
```

**Attack Execution:**
1. Attacker calls `setup()` once (pays normal storage fees)
2. Attacker calls `bloat_state()` thousands of times in separate transactions
3. Each call creates aggregator deltas that modify state
4. Storage fees are not charged for these modifications
5. Network accumulates state changes at fraction of intended cost

## Notes

This vulnerability specifically affects **Aggregator V1** operations. The code comments indicate Aggregator V1 is marked for deprecation, but it remains active in the current codebase. The vulnerability exists because the architecture separates delta operations from concrete writes to enable better concurrency, but the storage fee charging logic was not updated to handle this separation correctly.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1090-1096)
```rust
        let epilogue_session = self.charge_change_set_and_respawn_session(
            user_session_change_set,
            resolver,
            code_storage,
            gas_meter,
            txn_data,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1128-1134)
```rust
        let mut storage_refund = gas_meter.process_storage_fee_for_all(
            change_set,
            txn_data.transaction_size,
            txn_data.gas_unit_price,
            resolver.as_executor_view(),
            module_storage,
        )?;
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L367-399)
```rust
    pub fn try_materialize_aggregator_v1_delta_set(
        &mut self,
        resolver: &impl AggregatorV1Resolver,
    ) -> VMResult<()> {
        let into_write =
            |(state_key, delta): (StateKey, DeltaOp)| -> VMResult<(StateKey, WriteOp)> {
                // Materialization is needed when committing a transaction, so
                // we need precise mode to compute the true value of an
                // aggregator.
                let write = resolver
                    .try_convert_aggregator_v1_delta_into_write_op(&state_key, &delta)
                    .map_err(|e| {
                        // We need to set abort location for Aggregator V1 to ensure correct VMStatus can
                        // be constructed.
                        const AGGREGATOR_V1_ADDRESS: AccountAddress = CORE_CODE_ADDRESS;
                        const AGGREGATOR_V1_MODULE_NAME: &IdentStr = ident_str!("aggregator");
                        e.finish(Location::Module(ModuleId::new(
                            AGGREGATOR_V1_ADDRESS,
                            AGGREGATOR_V1_MODULE_NAME.into(),
                        )))
                    })?;
                Ok((state_key, write))
            };

        let aggregator_v1_delta_set = std::mem::take(&mut self.aggregator_v1_delta_set);
        let materialized_aggregator_delta_set = aggregator_v1_delta_set
            .into_iter()
            .map(into_write)
            .collect::<VMResult<BTreeMap<StateKey, WriteOp>>>()?;
        self.aggregator_v1_write_set
            .extend(materialized_aggregator_delta_set);
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L873-903)
```rust
    fn write_op_info_iter_mut<'a>(
        &'a mut self,
        executor_view: &'a dyn ExecutorView,
        _module_storage: &'a impl AptosModuleStorage,
        fix_prev_materialized_size: bool,
    ) -> impl Iterator<Item = PartialVMResult<WriteOpInfo<'a>>> {
        let resources = self.resource_write_set.iter_mut().map(move |(key, op)| {
            Ok(WriteOpInfo {
                key,
                op_size: op.materialized_size(),
                prev_size: op.prev_materialized_size(
                    key,
                    executor_view,
                    fix_prev_materialized_size,
                )?,
                metadata_mut: op.metadata_mut(),
            })
        });
        let v1_aggregators = self.aggregator_v1_write_set.iter_mut().map(|(key, op)| {
            Ok(WriteOpInfo {
                key,
                op_size: op.write_op_size(),
                prev_size: executor_view
                    .get_aggregator_v1_state_value_size(key)?
                    .unwrap_or(0),
                metadata_mut: op.metadata_mut(),
            })
        });

        resources.chain(v1_aggregators)
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L40-56)
```rust
    pub fn on_user_session_success(
        vm: &AptosVM,
        txn_meta: &TransactionMetadata,
        resolver: &'r impl AptosMoveResolver,
        user_session_change_set: UserSessionChangeSet,
        storage_refund: Fee,
    ) -> Self {
        let (change_set, module_write_set) = user_session_change_set.unpack();
        Self::new(
            vm,
            txn_meta,
            resolver,
            change_set,
            module_write_set,
            storage_refund,
        )
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L102-127)
```rust
    pub fn finish(
        self,
        fee_statement: FeeStatement,
        execution_status: ExecutionStatus,
        change_set_configs: &ChangeSetConfigs,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<VMOutput, VMStatus> {
        let Self {
            session,
            storage_refund: _,
            module_write_set,
        } = self;

        let change_set =
            session.finish_with_squashed_change_set(change_set_configs, module_storage, true)?;
        let epilogue_session_change_set =
            UserSessionChangeSet::new(change_set, module_write_set, change_set_configs)?;

        let (change_set, module_write_set) = epilogue_session_change_set.unpack();
        Ok(VMOutput::new(
            change_set,
            module_write_set,
            fee_statement,
            TransactionStatus::Keep(execution_status),
        ))
    }
```

**File:** aptos-move/aptos-aggregator/src/resolver.rs (L80-106)
```rust
    fn try_convert_aggregator_v1_delta_into_write_op(
        &self,
        id: &Self::Identifier,
        delta_op: &DeltaOp,
    ) -> PartialVMResult<WriteOp> {
        let base = self.get_aggregator_v1_value(id)?.ok_or_else(|| {
            PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                .with_message("Cannot convert delta for deleted aggregator".to_string())
        })?;
        delta_op
            .apply_to(base)
            .map_err(|e| match &e {
                PanicOr::Or(DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Overflow,
                    ..
                }) => addition_v1_error(e),
                PanicOr::Or(DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Underflow,
                    ..
                }) => subtraction_v1_error(e),
                // Because aggregator V1 never underflows or overflows, all other
                // application errors are bugs.
                _ => code_invariant_error(format!("Unexpected delta application error: {:?}", e))
                    .into(),
            })
            .map(|result| WriteOp::legacy_modification(serialize(&result).into()))
    }
```

**File:** types/src/state_store/state_value.rs (L259-261)
```rust
    pub fn new_legacy(bytes: Bytes) -> Self {
        Self::new_with_metadata(bytes, StateValueMetadata::none())
    }
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L155-212)
```rust
    fn process_storage_fee_for_all(
        &mut self,
        change_set: &mut impl ChangeSetInterface,
        txn_size: NumBytes,
        gas_unit_price: FeePerGasUnit,
        executor_view: &dyn ExecutorView,
        module_storage: &impl AptosModuleStorage,
    ) -> VMResult<Fee> {
        // The new storage fee are only active since version 7.
        if self.feature_version() < 7 {
            return Ok(0.into());
        }

        // TODO(Gas): right now, some of our tests use a unit price of 0 and this is a hack
        // to avoid causing them issues. We should revisit the problem and figure out a
        // better way to handle this.
        if gas_unit_price.is_zero() {
            return Ok(0.into());
        }

        let pricing = self.disk_space_pricing();
        let params = &self.vm_gas_params().txn;

        // Write set
        let mut write_fee = Fee::new(0);
        let mut total_refund = Fee::new(0);
        let fix_prev_materialized_size = self.feature_version() > RELEASE_V1_30;
        for res in change_set.write_op_info_iter_mut(
            executor_view,
            module_storage,
            fix_prev_materialized_size,
        ) {
            let ChargeAndRefund { charge, refund } = pricing.charge_refund_write_op(
                params,
                res.map_err(|err| err.finish(Location::Undefined))?,
            );
            write_fee += charge;
            total_refund += refund;
        }

        // Events (no event fee in v2)
        let event_fee = change_set.events_iter().fold(Fee::new(0), |acc, event| {
            acc + pricing.legacy_storage_fee_per_event(params, event)
        });
        let event_discount = pricing.legacy_storage_discount_for_events(params, event_fee);
        let event_net_fee = event_fee
            .checked_sub(event_discount)
            .expect("event discount should always be less than or equal to total amount");

        // Txn (no txn fee in v2)
        let txn_fee = pricing.legacy_storage_fee_for_transaction_storage(params, txn_size);

        let fee = write_fee + event_net_fee + txn_fee;
        self.charge_storage_fee(fee, gas_unit_price)
            .map_err(|err| err.finish(Location::Undefined))?;

        Ok(total_refund)
    }
```
