# Audit Report

## Title
Missing Accumulator Extension Verification in Commit Vote Signing Allows Unverified Execution State Signatures

## Summary
The `guarded_sign_commit_vote` function in safety rules lacks accumulator extension proof verification when signing commit votes. This missing validation is explicitly noted in TODO comments and could allow validators to sign execution results without cryptographic verification of state transition correctness, weakening the defense-in-depth guarantees of consensus safety.

## Finding Description

The safety rules module is responsible for enforcing consensus safety guarantees by validating all proposals and votes before signing. During the decoupled execution flow, validators first sign order votes (which include accumulator extension proof verification) and then sign commit votes after execution completes. [1](#0-0) 

The `guarded_sign_commit_vote` function contains explicit TODO comments indicating missing validation: [2](#0-1) 

In contrast, the voting phase properly verifies accumulator extension proofs: [3](#0-2) 

The `gen_vote_data` method performs cryptographic verification: [4](#0-3) 

However, when signing commit votes, the only checks performed are: [5](#0-4) 

This `match_ordered_only` function only validates that epoch, round, id, and timestamp match - it does NOT validate the `executed_state_id` or verify the accumulator extension. This means safety rules signs commit votes without cryptographic proof that the execution state correctly extends from the parent state. [6](#0-5) 

Additionally, metrics counters are updated before the storage write completes, creating a monitoring inconsistency if writes fail.

## Impact Explanation

**Severity Assessment: Medium**

This issue falls under "State inconsistencies requiring intervention" (Medium Severity, up to $10,000) because:

1. **Defense-in-depth weakness**: Safety rules should provide an independent verification layer. The missing check means validators rely solely on local execution correctness without safety rules validation.

2. **Non-determinism detection failure**: If execution bugs cause non-deterministic state transitions, safety rules won't detect this before signing, potentially allowing divergent states to accumulate signatures.

3. **Requires validator-level conditions**: Direct exploitation requires either:
   - A bug in the execution engine producing incorrect state
   - A compromised validator node with malicious execution

4. **Consensus still protected by Byzantine threshold**: Even with this weakness, consensus safety holds as long as >2/3 validators have correct execution, as only matching commit votes aggregate into valid certificates.

The issue does NOT reach Critical severity because it cannot be directly exploited by external attackers without validator access, and the Byzantine fault tolerance of the protocol provides defense even when some validators sign incorrect states.

## Likelihood Explanation

**Likelihood: Low to Medium**

This issue manifests when:
1. Execution engine has a non-deterministic bug OR
2. Validator node is compromised/malicious AND
3. The buggy/malicious execution produces incorrect state

The TODO comments indicate developers are aware of this limitation. However, the issue could materialize through:
- Subtle non-determinism bugs in execution (e.g., due to timing, floating point, or platform differences)
- Future changes to execution that introduce bugs
- Memory corruption or hardware faults affecting execution

The metrics inconsistency issue occurs on any storage write failure, which is rare but possible during disk failures, permission issues, or storage quota exhaustion.

## Recommendation

### Fix 1: Add Accumulator Extension Verification in Commit Vote Signing

Modify `guarded_sign_commit_vote` to verify the accumulator extension proof similar to how `gen_vote_data` works: [1](#0-0) 

The function should:
1. Accept an `AccumulatorExtensionProof` parameter
2. Verify the proof against the ordered ledger info's state
3. Validate that the new executed_state_id matches the verified accumulator root
4. Add a new error variant for invalid commit accumulator extension

### Fix 2: Add Safety Checks for Unhappy Paths

Implement the missing guarding rules mentioned in the TODO:
1. Verify version progression is monotonic
2. Check that next_epoch_state transitions are valid
3. Validate timestamp consistency
4. Add bounds checking on state values

### Fix 3: Fix Metrics Consistency

Move counter updates in `set_safety_data` to occur AFTER successful storage write: [6](#0-5) 

Update counters only in the `Ok(_)` branch after line 162 to ensure metrics always reflect successfully persisted state.

### Fix 4: Add New Error Variants

Extend the Error enum to represent these conditions: [7](#0-6) 

Add variants like:
- `InvalidCommitAccumulatorExtension(String)` 
- `InvalidVersionProgression(u64, u64)`
- `InvalidEpochStateTransition(String)`

## Proof of Concept

This vulnerability cannot be demonstrated through a standard Move test because it requires validator-level access and specific execution engine behavior. However, here's a conceptual Rust integration test approach:

```rust
// In consensus/safety-rules/src/tests/suite.rs (conceptual - for illustration)

#[test]
fn test_commit_vote_missing_accumulator_verification() {
    // Setup: Initialize safety rules with valid epoch and state
    let mut safety_rules = make_safety_rules();
    
    // Create an ordered block with 2f+1 signatures
    let ordered_block = make_ordered_block();
    let ordered_ledger_info = make_ledger_info_with_sigs(ordered_block);
    
    // Create execution results with INCORRECT executed_state_id
    // (simulating buggy or malicious execution)
    let mut wrong_commit_info = ordered_block.block_info().clone();
    wrong_commit_info.set_executed_state_id(HashValue::random()); // Wrong state!
    let commit_ledger_info = LedgerInfo::new(wrong_commit_info, HashValue::zero());
    
    // Current behavior: safety rules ACCEPTS and signs the wrong state
    // because there's no accumulator extension verification
    let result = safety_rules.sign_commit_vote(
        ordered_ledger_info,
        commit_ledger_info,
    );
    
    // BUG: This should fail but currently succeeds
    assert!(result.is_ok()); // Currently passes - this is the bug!
    
    // Expected behavior after fix: Should reject with InvalidCommitAccumulatorExtension
    // assert!(matches!(result, Err(Error::InvalidCommitAccumulatorExtension(_))));
}
```

**Notes:**

The TODO comments explicitly acknowledge these missing checks, indicating this is a known limitation rather than an undiscovered vulnerability. However, the absence of these checks represents a weakening of defense-in-depth that could amplify the impact of execution bugs or compromise scenarios.

The primary mitigation is that consensus safety ultimately relies on Byzantine fault tolerance - even if individual validators sign incorrect states due to local execution bugs, the protocol prevents commitment unless >2/3 validators agree on the same state. Nevertheless, adding these verification layers would strengthen overall system resilience and improve detection of non-deterministic execution issues.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L82-84)
```rust
        vote_proposal
            .gen_vote_data()
            .map_err(|error| Error::InvalidAccumulatorExtension(error.to_string()))
```

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L87-101)
```rust
    /// Generate vote data depends on the config.
    pub fn gen_vote_data(&self) -> anyhow::Result<VoteData> {
        if self.decoupled_execution {
            Ok(self.vote_data_ordering_only())
        } else {
            let proposed_block = self.block();
            let new_tree = self.accumulator_extension_proof().verify(
                proposed_block
                    .quorum_cert()
                    .certified_block()
                    .executed_state_id(),
            )?;
            Ok(self.vote_data_with_extension_proof(&new_tree))
        }
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/safety-rules/src/error.rs (L8-63)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
/// Different reasons for proposal rejection
pub enum Error {
    #[error("Provided epoch, {0}, does not match expected epoch, {1}")]
    IncorrectEpoch(u64, u64),
    #[error("block has next round that wraps around: {0}")]
    IncorrectRound(u64),
    #[error("Provided round, {0}, is incompatible with last voted round, {1}")]
    IncorrectLastVotedRound(u64, u64),
    #[error("Provided round, {0}, is incompatible with preferred round, {1}")]
    IncorrectPreferredRound(u64, u64),
    #[error("Unable to verify that the new tree extends the parent: {0}")]
    InvalidAccumulatorExtension(String),
    #[error("Invalid EpochChangeProof: {0}")]
    InvalidEpochChangeProof(String),
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("No next_epoch_state specified in the provided Ledger Info")]
    InvalidLedgerInfo,
    #[error("Invalid proposal: {0}")]
    InvalidProposal(String),
    #[error("Invalid QC: {0}")]
    InvalidQuorumCertificate(String),
    #[error("{0} is not set, SafetyRules is not initialized")]
    NotInitialized(String),
    #[error("Does not satisfy order vote rule. Block Round {0}, Highest Timeout Round {1}")]
    NotSafeForOrderVote(u64, u64),
    #[error("Data not found in secure storage: {0}")]
    SecureStorageMissingDataError(String),
    #[error("Unexpected error returned by secure storage: {0}")]
    SecureStorageUnexpectedError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
    #[error("Validator key not found: {0}")]
    ValidatorKeyNotFound(String),
    #[error("The validator is not in the validator set. Address not in set: {0}")]
    ValidatorNotInSet(String),
    #[error("Vote proposal missing expected signature")]
    VoteProposalSignatureNotFound,
    #[error("Does not satisfy 2-chain voting rule. Round {0}, Quorum round {1}, TC round {2},  HQC round in TC {3}")]
    NotSafeToVote(u64, u64, u64, u64),
    #[error("Does not satisfy 2-chain timeout rule. Round {0}, Quorum round {1}, TC round {2}, one-chain round {3}")]
    NotSafeToTimeout(u64, u64, u64, u64),
    #[error("Invalid TC: {0}")]
    InvalidTimeoutCertificate(String),
    #[error("Inconsistent Execution Result: Ordered BlockInfo doesn't match executed BlockInfo. Ordered: {0}, Executed: {1}")]
    InconsistentExecutionResult(String, String),
    #[error("Invalid Ordered LedgerInfoWithSignatures: Empty or at least one of executed_state_id, version, or epoch_state are not dummy value: {0}")]
    InvalidOrderedLedgerInfo(String),
    #[error("Waypoint out of date: Previous waypoint version {0}, updated version {1}, current epoch {2}, provided epoch {3}")]
    WaypointOutOfDate(u64, u64, u64, u64),
    #[error("Invalid Timeout: {0}")]
    InvalidTimeout(String),
    #[error("Incorrect 1-chain Quorum Certificate provided for signing order votes. Quorum Certificate: {0}, block id: {1}")]
    InvalidOneChainQuorumCertificate(HashValue, HashValue),
}
```
