# Audit Report

## Title
Silent Storage Error Swallowing in Gas Schedule Fallback Causes Non-Deterministic Consensus Failure

## Summary
The `get_gas_config_from_storage()` function silently converts storage errors to `None` via the `.ok()?` operator, causing the fallback logic to treat transient database errors identically to missing configurations. This enables validators experiencing different storage errors to use different gas schedules (GasScheduleV2 vs GasSchedule vs zeros), violating deterministic execution and causing consensus failures.

## Finding Description

The vulnerability exists in the gas schedule retrieval logic where storage errors are indistinguishable from missing configurations. [1](#0-0) 

The `fetch_config_bytes` implementation uses `.ok()?` to convert `Result<Option<StateValue>, StateViewError>` to `Option<Bytes>`. This conflates two fundamentally different scenarios:
1. Configuration doesn't exist in state (`Ok(None)`) - expected during upgrades
2. Storage error occurred while reading (`Err(StateViewError)`) - critical failure [2](#0-1) 

The `get_gas_config_from_storage()` function implements a fallback chain: GasScheduleV2 → GasSchedule → Error. When `fetch_config_and_bytes` returns `None`, it cannot distinguish whether the config is missing (triggering legitimate fallback) or a storage error occurred (should fail immediately).

Storage errors can include: [3](#0-2) 

These errors (Corruption, IOError, TimedOut, etc.) are converted to `StateViewError::Other`: [4](#0-3) 

**Consensus Failure Scenario:**

Block N execution with GasScheduleV2 at feature_version=10:

**Validator A** (healthy storage):
1. Fetches GasScheduleV2 successfully
2. Updates environment hash with GasScheduleV2 bytes
3. Uses feature_version=10 for gas calculations
4. Executes transactions with correct gas metering

**Validator B** (experiencing I/O error):
1. Attempts to fetch GasScheduleV2, RocksDB returns `IOError`
2. `.ok()?` converts error to `None`
3. Falls back to GasSchedule (v1) with feature_version=0
4. Updates environment hash with GasSchedule bytes
5. Uses feature_version=0 for gas calculations (different parameters)

The gas feature version affects gas calculation logic: [5](#0-4) 

**Result:** Validators produce different state roots for identical blocks, violating the **Deterministic Execution** invariant.

## Impact Explanation

**Critical Severity** - This vulnerability causes **Consensus/Safety violations**, which is explicitly listed as Critical (up to $1,000,000) in the Aptos bug bounty program.

**Specific impacts:**
1. **Consensus Safety Break**: Validators produce different state roots for the same block, violating AptosBFT safety guarantees
2. **Network Partition Risk**: Disagreement on state roots can cause chain splits requiring manual intervention or hardfork
3. **Unpredictable Failures**: Silent error handling makes diagnosis extremely difficult, as storage errors appear as configuration mismatches

The vulnerability violates Critical Invariant #1: "All validators must produce identical state roots for identical blocks."

## Likelihood Explanation

**Likelihood: Low but Non-Zero**

While storage errors are relatively rare in production systems, they can occur due to:
- Hardware failures (disk errors, memory corruption)
- Resource exhaustion (disk full, memory pressure)
- Database corruption
- Concurrent access issues in RocksDB
- Network latency in distributed storage scenarios

The vulnerability is more likely during:
- Gas schedule upgrade transitions (when both v1 and v2 exist)
- High load periods increasing timeout probability
- Validator infrastructure degradation

**Triggering Factors:**
- Natural hardware/software failures: Medium probability over network lifetime
- Resource exhaustion attacks: Could artificially increase error rates
- Network-wide upgrade events: Higher risk window when validators sync new configs

Although individual storage errors are rare, with hundreds of validators and thousands of blocks per day, the cumulative probability of at least one validator experiencing an error during critical operations becomes significant over time.

## Recommendation

**Fix: Propagate storage errors instead of silently converting to `None`**

Modify `fetch_config_bytes` to distinguish between missing configs and errors:

```rust
// In types/src/on_chain_config/mod.rs
pub trait ConfigStorage {
    // Change signature to propagate errors
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Result<Option<Bytes>, StateViewError>;
}

impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Result<Option<Bytes>, StateViewError> {
        // Remove .ok()? - propagate errors
        Ok(self.get_state_value(state_key)?.map(|s| s.bytes().clone()))
    }
}
```

Update `fetch_config_and_bytes` to handle errors:

```rust
fn fetch_config_and_bytes<T>(storage: &T) -> Result<Option<(Self, Bytes)>, StateViewError>
where
    T: ConfigStorage + ?Sized,
{
    let state_key = StateKey::on_chain_config::<Self>()?;
    let bytes = match storage.fetch_config_bytes(&state_key)? {
        Some(b) => b,
        None => return Ok(None), // Config genuinely doesn't exist
    };
    let config = Self::deserialize_into_config(&bytes)
        .map_err(|e| StateViewError::Other(format!("Deserialization failed: {}", e)))?;
    Ok(Some((config, bytes)))
}
```

Update `get_gas_config_from_storage` to fail fast on errors:

```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> Result<(Result<AptosGasParameters, String>, u64), StateViewError> {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Ok(Some((gas_schedule, bytes))) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            Ok((
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            ))
        },
        Ok(None) => {
            // GasScheduleV2 doesn't exist, try v1
            match GasSchedule::fetch_config_and_bytes(state_view) {
                Ok(Some((gas_schedule, bytes))) => {
                    sha3_256.update(&bytes);
                    let map = gas_schedule.into_btree_map();
                    Ok((AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0))
                },
                Ok(None) => Ok((Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0)),
                Err(e) => Err(e), // Propagate error - don't fall back!
            }
        },
        Err(e) => Err(e), // Propagate error - don't fall back!
    }
}
```

This ensures storage errors are immediately visible and cause deterministic failures across all validators rather than silent non-deterministic fallback.

## Proof of Concept

```rust
#[cfg(test)]
mod test_gas_schedule_error_handling {
    use super::*;
    use aptos_types::state_store::{StateView, StateViewError, StateViewResult};
    use std::collections::HashMap;

    // Mock StateView that returns errors for specific keys
    struct ErrorInjectingStateView {
        error_on_v2: bool,
        has_v1: bool,
    }

    impl StateView for ErrorInjectingStateView {
        type Key = StateKey;
        
        fn id(&self) -> StateViewId {
            StateViewId::Miscellaneous
        }

        fn get_state_value(&self, state_key: &StateKey) -> StateViewResult<Option<StateValue>> {
            // Simulate error when fetching GasScheduleV2
            if self.error_on_v2 && state_key.to_string().contains("GasScheduleV2") {
                return Err(StateViewError::Other("Simulated I/O Error".to_string()));
            }
            
            // Return GasSchedule v1 if configured
            if self.has_v1 && state_key.to_string().contains("GasSchedule") {
                let v1_config = GasSchedule { entries: vec![] };
                return Ok(Some(StateValue::new_legacy(
                    bcs::to_bytes(&v1_config).unwrap().into()
                )));
            }
            
            Ok(None)
        }

        fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
            Ok(StateStorageUsage::new_untracked())
        }
    }

    #[test]
    fn test_storage_error_causes_silent_fallback() {
        let mut sha3_256 = Sha3_256::new();
        
        // Validator with error on V2 but V1 available
        let error_view = ErrorInjectingStateView {
            error_on_v2: true,
            has_v1: true,
        };
        
        let (gas_params, feature_version) = get_gas_config_from_storage(&mut sha3_256, &error_view);
        
        // BUG: Storage error silently falls back to V1
        assert_eq!(feature_version, 0); // Should have failed, not fallen back!
        
        // This validator will use different gas parameters than one that successfully
        // fetched V2, causing consensus divergence
    }

    #[test]
    fn test_different_validators_different_results() {
        // Validator A: No error, fetches V2
        let healthy_view = MockStateViewWithV2 { /* ... */ };
        let mut sha3_a = Sha3_256::new();
        let (params_a, version_a) = get_gas_config_from_storage(&mut sha3_a, &healthy_view);
        
        // Validator B: Error on V2, falls back to V1
        let error_view = ErrorInjectingStateView {
            error_on_v2: true,
            has_v1: true,
        };
        let mut sha3_b = Sha3_256::new();
        let (params_b, version_b) = get_gas_config_from_storage(&mut sha3_b, &error_view);
        
        // BUG: Different feature versions lead to different gas calculations
        assert_ne!(version_a, version_b);
        assert_ne!(sha3_a.finalize(), sha3_b.finalize());
        
        // This causes consensus failure!
    }
}
```

## Notes

This vulnerability demonstrates a critical failure in error handling for consensus-critical configuration. While storage errors are relatively rare, the consensus layer must handle them deterministically. The current implementation violates this by treating errors as missing data, allowing validators to silently diverge in their gas metering calculations. This is particularly dangerous during gas schedule upgrades when both old and new configurations coexist on-chain.

### Citations

**File:** types/src/on_chain_config/mod.rs (L204-210)
```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.get_state_value(state_key)
            .ok()?
            .map(|s| s.bytes().clone())
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L69-93)
```rust
            match gas_feature_version {
                0..=1 => (),
                2..=6 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_base_new = 0.into();
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                7..=9 => {
                    if let IoPricing::V2(pricing) = &storage_gas_params.io_pricing {
                        g.common_load_base_legacy = 0.into();
                        g.common_load_base_new = pricing.per_item_read * NumArgs::new(1);
                        g.common_load_per_byte = pricing.per_byte_read;
                        g.common_load_failure = 0.into();
                    }
                }
                10.. => {
                    g.common_load_base_legacy = 0.into();
                    g.common_load_base_new = gas_params.vm.txn.storage_io_per_state_slot_read * NumArgs::new(1);
                    g.common_load_per_byte = gas_params.vm.txn.storage_io_per_state_byte_read;
                    g.common_load_failure = 0.into();
                }
            };
```

**File:** storage/schemadb/src/lib.rs (L389-407)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
```

**File:** storage/storage-interface/src/errors.rs (L69-77)
```rust
impl From<AptosDbError> for StateViewError {
    fn from(error: AptosDbError) -> Self {
        match error {
            AptosDbError::NotFound(msg) => StateViewError::NotFound(msg),
            AptosDbError::Other(msg) => StateViewError::Other(msg),
            _ => StateViewError::Other(format!("{}", error)),
        }
    }
}
```
