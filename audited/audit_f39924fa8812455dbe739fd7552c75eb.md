# Audit Report

## Title
Unrestricted Database Access Through Production Debug Tools Enables Complete State Exfiltration and Destructive Operations

## Summary

The Aptos validator production images ship with `aptos-debugger` binary that provides unrestricted access to the complete blockchain database through db_debugger commands. These commands have no authentication, authorization, or privilege checks beyond basic file system permissions, allowing anyone with shell access to a validator node to read all blockchain state, create database checkpoints, or destructively truncate the database. This violates access control principles for critical infrastructure. [1](#0-0) 

## Finding Description

The db_debugger module exposes powerful database inspection and manipulation tools that are compiled into production validator binaries. The `aptos-debugger` tool includes the complete `DBTool` interface which provides access to all debugging subcommands without any security controls: [2](#0-1) [3](#0-2) 

The db_debugger commands provide comprehensive access to blockchain data:

1. **State Reading Commands**:
   - `state-kv get-value`: Read any state value by account address and struct tag
   - `state-kv scan-snapshot`: Scan complete state snapshots at any version
   - `state-tree get-leaf`: Read Jellyfish Merkle tree leaves
   - `examine print-raw-data-by-version`: Read transactions, events, write sets [4](#0-3) [5](#0-4) 

2. **Destructive Commands**:
   - `truncate`: Deletes all blockchain data after a specified version [6](#0-5) 

The truncate command opens the database in read-write mode and can permanently delete blockchain history: [7](#0-6) 

**No Security Controls**: The database access only requires a `--db_dir` path parameter with no authentication checks: [8](#0-7) 

The db-debugger feature is enabled in production builds through the aptos-db-tool dependency: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Critical Severity** - This issue enables multiple high-impact attack scenarios:

1. **Complete State Exfiltration**: Anyone with shell access (compromised SSH credentials, container escape, malicious insider, supply chain attack) can exfiltrate the entire blockchain state including all account balances, smart contract state, and transaction history.

2. **Database Destruction**: The truncate command can permanently delete blockchain data, causing validator unavailability and requiring restoration from backups or re-syncing from genesis.

3. **Privacy Violations**: Sensitive on-chain data can be accessed without any audit trail, violating data protection requirements and user privacy expectations.

4. **Operational Security Bypass**: Standard security practices like role-based access control (RBAC), principle of least privilege, and audit logging are completely bypassed.

While RocksDB provides file locks preventing concurrent writes, the readonly mode allows unlimited concurrent reads even while the validator is running: [11](#0-10) 

## Likelihood Explanation

**High Likelihood** - This vulnerability is highly likely to be exploited because:

1. **Large Attack Surface**: Any compromise of validator node access (SSH keys, container security, insider threat, supply chain attack) immediately grants full database access.

2. **Production Deployment**: The tools are shipped in standard production validator images by default, not as optional debug builds.

3. **No Defense in Depth**: There are zero additional security layers once shell access is obtained - no authentication, no privilege elevation required, no rate limiting, no audit logging.

4. **Operator Error**: Legitimate operators might accidentally run destructive commands (truncate) without sufficient safeguards or confirmation prompts.

5. **Compliance Requirements**: Organizations subject to SOC2, ISO 27001, or GDPR requirements need audit trails for sensitive data access, which are completely absent.

## Recommendation

Implement defense-in-depth security controls for database debugging tools:

1. **Authentication Layer**: Add authentication mechanism requiring operator credentials before allowing database access:
   - Integrate with OS-level authentication (sudo/doas)
   - Require cryptographic proof of authorized operator identity
   - Support integration with enterprise IAM systems

2. **Authorization Checks**: Implement role-based access control:
   - Read-only operators: Can run examination commands
   - Admin operators: Can run destructive commands with additional confirmation
   - Separate binaries for read vs write operations

3. **Audit Logging**: Log all database access:
   ```rust
   // Example audit logging
   fn log_database_access(cmd: &str, user: &str, db_path: &Path) {
       audit_log::record(AuditEvent {
           timestamp: Utc::now(),
           user,
           command: cmd,
           database_path: db_path.display().to_string(),
       });
   }
   ```

4. **Safety Confirmations**: Add confirmation prompts for destructive operations:
   ```rust
   // In truncate command
   if !self.opt_out_backup_checkpoint && !confirm_destructive_operation()? {
       return Err(anyhow!("Operation cancelled by user"));
   }
   ```

5. **Separate Debug Builds**: Remove db_debugger from production validator images:
   - Create separate debug-enabled validator images for troubleshooting
   - Use feature flags to completely exclude debug tools from production builds
   - Document when and how to use debug images

6. **File System Permissions**: Enforce strict file permissions on database directories (0700) with documentation on proper security hardening.

## Proof of Concept

**Scenario 1: Complete State Exfiltration**

```bash
# Attacker gains shell access to validator node
ssh compromised-validator

# Read complete blockchain state at version 1000000
aptos-debugger aptos-db debug state-kv scan-snapshot \
    --db_dir /opt/aptos/data \
    --version 1000000 \
    > complete_state_dump.txt

# Exfiltrate specific account balances
aptos-debugger aptos-db debug state-kv get-value \
    --db_dir /opt/aptos/data \
    --address 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef \
    --struct-tag "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>" \
    --version 1000000
```

**Scenario 2: Database Destruction**

```bash
# Destroy all blockchain data after version 100
aptos-debugger aptos-db debug truncate \
    --db_dir /opt/aptos/data \
    --target_version 100 \
    --opt_out_backup_checkpoint

# Result: Validator becomes non-functional, requires full re-sync or restore
```

**Verification**: Run these commands on a test validator node to confirm unrestricted access.

## Notes

This vulnerability breaks the **Access Control** invariant (#8: "System addresses must be protected") by failing to protect the underlying database that stores all system state. While the invariant focuses on on-chain access control, the principle extends to off-chain infrastructure security.

The issue is particularly severe because:
- The blockchain state contains all account balances, smart contract code, and private transaction data
- Validators are high-value targets for sophisticated attackers
- Compliance frameworks require audit trails for sensitive data access
- Defense-in-depth is a fundamental security principle for critical infrastructure

Standard database systems (PostgreSQL, MySQL) also rely on file permissions for local access, but they typically run as isolated services with minimal exposed attack surface. Validator nodes have larger attack surfaces (SSH access, remote management, monitoring agents) making additional security layers essential.

### Citations

**File:** docker/builder/validator.Dockerfile (L26-26)
```dockerfile
COPY --link --from=tools-builder /aptos/dist/aptos-debugger /usr/local/bin/
```

**File:** crates/aptos-debugger/src/lib.rs (L7-18)
```rust
#[derive(Parser)]
pub enum Cmd {
    #[clap(subcommand)]
    AptosDb(aptos_db_tool::DBTool),

    Decode(aptos_move_debugger::bcs_txn_decoder::Command),

    DumpPendingTxns(aptos_consensus::util::db_tool::Command),

    #[clap(subcommand)]
    Move(aptos_move_debugger::common::Command),
}
```

**File:** storage/db-tool/src/lib.rs (L22-44)
```rust
#[derive(Parser)]
#[clap(name = "Aptos db tool", author, disable_version_flag = true)]
pub enum DBTool {
    #[clap(subcommand)]
    Backup(backup::Command),

    #[clap(subcommand)]
    BackupMaintenance(backup_maintenance::Command),

    Bootstrap(bootstrap::Command),

    #[clap(subcommand)]
    Debug(db_debugger::Cmd),

    ReplayVerify(replay_verify::Opt),

    GenReplayVerifyJobs(gen_replay_verify_jobs::Opt),

    #[clap(subcommand)]
    Restore(restore::Command),

    ReplayOnArchive(replay_on_archive::Opt),
}
```

**File:** storage/aptosdb/src/db_debugger/state_kv/get_value.rs (L34-92)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        /*
        let key_vec = hex::decode(&self.key_hex).unwrap();
        let key: StateKey = bcs::from_bytes(&key_vec)?;
        println!(
            "{}",
            format!(
                "* Get state value for key {:?} at version {}. \n",
                key, self.version,
            )
            .yellow()
        );*/

        let address = AccountAddress::from_hex_literal(&self.address).unwrap();
        let struct_tag = StructTag::from_str(&self.struct_tag)?;
        let key = StateKey::resource(&address, &struct_tag)?;

        let ledger_db = self.db_dir.open_ledger_db()?;
        let db = self.db_dir.open_state_kv_db()?;
        let latest_version = ledger_db
            .metadata_db()
            .get_synced_version()?
            .expect("DB is empty.");
        println!("latest version: {latest_version}");
        if self.version != Version::MAX && self.version > latest_version {
            println!(
                "{}",
                format!(
                    "warning: version {} is greater than latest version {}",
                    self.version, latest_version
                )
                .red()
            );
        }

        let mut start_version = self.version;
        let mut count = 0;
        while count < 10 {
            match db.get_state_value_with_version_by_version(&key, start_version)? {
                None => {
                    if count == 0 {
                        println!("{}", "Value not found.".to_string().yellow());
                    }
                    break;
                },
                Some((version, value)) => {
                    Self::print_value(version, value);
                    count += 1;
                    if version == 0 {
                        break;
                    }
                    start_version = version - 1;
                },
            }
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/db_debugger/state_kv/scan_snapshot.rs (L38-90)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        println!(
            "{}",
            format!(
                "* Scan all key values in snapshot at version {} in the key hash value order. \n",
                self.version,
            )
            .yellow()
        );

        let state_kv_db = Arc::new(self.db_dir.open_state_kv_db()?);
        let state_merkle_db = Arc::new(self.db_dir.open_state_merkle_db()?);
        let total_leaves = state_merkle_db.get_leaf_count(self.version)?;
        println!("total leaves: {}", total_leaves);

        let (range_tx, range_rx) = crossbeam_channel::bounded::<(usize, usize)>(1024);
        let (result_tx, result_rx) = mpsc::channel();

        let workers: Vec<_> = (0..self.concurrency)
            .map(|_| {
                let range_rx = range_rx.clone();
                let state_merkle_db = state_merkle_db.clone();
                let state_kv_db = state_kv_db.clone();
                let result_tx = result_tx.clone();
                thread::spawn(move || {
                    while let Ok((start, len)) = range_rx.recv() {
                        let range_iter = JellyfishMerkleIterator::new_by_index(
                            state_merkle_db.clone(),
                            self.version,
                            start,
                        )
                        .unwrap()
                        .take(len);

                        for (n, leaf_res) in range_iter.enumerate() {
                            let (_key_hash, (key, key_version)) = leaf_res.unwrap();
                            let index = start + n;

                            let t = Instant::now();

                            let mut read_opts = ReadOptions::default();
                            // We want `None` if the state_key changes in iteration.
                            read_opts.set_prefix_same_as_start(true);

                            let enable_sharding = state_kv_db.enabled_sharding();

                            let (value_version, value) = if enable_sharding {
                                let mut iter = state_kv_db
                                    .db_shard(key.get_shard_id())
                                    .iter::<StateValueByKeyHashSchema>()
                                    .unwrap();
                                iter.seek(&(key.hash(), key_version)).unwrap();
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L20-48)
```rust
#[derive(Parser)]
#[clap(about = "Delete all data after the provided version.")]
#[clap(group(clap::ArgGroup::new("backup")
        .required(true)
        .args(&["backup_checkpoint_dir", "opt_out_backup_checkpoint"]),
))]
pub struct Cmd {
    // TODO(grao): Support db_path_overrides here.
    #[clap(long, value_parser)]
    db_dir: PathBuf,

    #[clap(long)]
    target_version: u64,

    #[clap(long, default_value_t = 1000)]
    ledger_db_batch_size: usize,

    #[clap(long, value_parser, group = "backup")]
    backup_checkpoint_dir: Option<PathBuf>,

    #[clap(long, group = "backup")]
    opt_out_backup_checkpoint: bool,

    #[clap(flatten)]
    sharding_config: ShardingConfig,
}

impl Cmd {
    pub fn run(self) -> Result<()> {
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L74-82)
```rust
        let (ledger_db, hot_state_merkle_db, state_merkle_db, state_kv_db) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&self.db_dir),
            rocksdb_config,
            env,
            block_cache,
            /*readonly=*/ false,
            /*max_num_nodes_per_lru_cache_shard=*/ 0,
            /*reset_hot_state=*/ true,
        )?;
```

**File:** storage/aptosdb/src/db_debugger/common/mod.rs (L17-44)
```rust
#[derive(Parser, Clone)]
pub struct DbDir {
    // TODO(grao): Support path override here.
    #[clap(long, value_parser)]
    db_dir: PathBuf,

    #[clap(flatten)]
    pub sharding_config: ShardingConfig,
}

impl DbDir {
    pub fn open_state_merkle_db(&self) -> Result<StateMerkleDb> {
        let env = None;
        let block_cache = None;
        StateMerkleDb::new(
            &StorageDirPaths::from_path(&self.db_dir),
            RocksdbConfigs {
                enable_storage_sharding: self.sharding_config.enable_storage_sharding,
                ..Default::default()
            },
            env,
            block_cache,
            /* read_only = */ false,
            /* max_nodes_per_lru_cache_shard = */ 0,
            /* is_hot = */ false,
            /* delete_on_restart = */ false,
        )
    }
```

**File:** storage/db-tool/Cargo.toml (L18-19)
```text
aptos-config = { workspace = true }
aptos-db = { workspace = true, features = ["db-debugger"] }
```

**File:** storage/aptosdb/Cargo.toml (L78-78)
```text
db-debugger = ["aptos-temppath", "clap", "crossbeam-channel", "owo-colors", "indicatif"]
```

**File:** storage/aptosdb/src/db_debugger/examine/print_db_versions.rs (L47-55)
```rust
        let (ledger_db, _hot_state_merkle_db, state_merkle_db, state_kv_db) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&self.db_dir),
            rocksdb_config,
            env,
            block_cache,
            /*readonly=*/ true,
            /*max_num_nodes_per_lru_cache_shard=*/ 0,
            /*reset_hot_state=*/ false,
        )?;
```
