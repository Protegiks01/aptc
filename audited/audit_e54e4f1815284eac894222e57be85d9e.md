# Audit Report

## Title
Window Size Bypass in Block Retrieval Allows Arbitrary Historical Block Access

## Summary
The `process_block_retrieval_inner()` function in `consensus/src/block_storage/sync_manager.rs` fails to validate the `target_round` parameter in `BlockRetrievalRequestV2`, allowing external peers to bypass window_size restrictions and retrieve arbitrary historical blocks beyond the intended execution window.

## Finding Description

When the consensus system is configured with a `window_size` parameter to limit the execution pool window, this restriction is properly enforced when the BlockStore **initiates** block retrieval but is completely bypassed when **responding** to external block retrieval requests. [1](#0-0) 

When initiating retrieval during fast-forward sync, the system correctly calculates the window start round using `calculate_window_start_round()` to ensure only blocks within the window are retrieved.

However, when responding to external requests, the code blindly uses the `target_round` provided by the requester: [2](#0-1) 

The `is_window_start_block()` check at line 573 only validates whether a block **matches** the provided target_round, not whether that target_round is **within the allowed window**: [3](#0-2) 

The only validation performed before processing the request is checking `num_blocks`: [4](#0-3) 

**Attack Flow:**
1. Attacker observes network sync messages to obtain a recent block ID (e.g., block at round 10000)
2. System has `window_size = 1000`, so legitimate window should be rounds [9001-10000]
3. Attacker crafts `BlockRetrievalRequestV2`:
   - `block_id`: Recent block hash
   - `num_blocks`: 100 (maximum allowed)
   - `target_round`: 1 (far outside the intended window)
4. Node's `process_block_retrieval_inner()` walks backwards from block 10000
5. Node returns up to 100 blocks going back to round ~9900, which are outside the intended window if those blocks happen to still be in memory
6. Attacker successfully retrieves historical blocks that should be restricted by the window mechanism

This breaks the **Resource Limits** invariant as window_size is designed to limit memory usage and restrict which blocks are actively maintained. It also represents an **Access Control** bypass where the intended restriction is circumvented.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per Aptos bug bounty classification:

1. **Information Disclosure**: Attackers can access blocks outside the configured execution window, potentially retrieving pruned blocks kept in the `pruned_block_ids` buffer (up to `max_pruned_blocks_in_mem = 100` blocks): [5](#0-4) 

2. **Resource Exhaustion**: Malicious peers can force nodes to repeatedly traverse their block trees by sending requests with varying `target_round` values, consuming CPU and memory resources.

3. **Access Control Bypass**: The window_size mechanism is explicitly designed to limit block accessibility, but this validation is missing when responding to external requests, creating an asymmetric security boundary.

4. **State Inconsistency Risk**: If window_size is relied upon for consistency guarantees in the execution pool, bypassing it could lead to unexpected state access patterns.

While not Critical (no direct funds loss or consensus safety violation), this represents a clear bypass of an intended access control mechanism that could be exploited for reconnaissance and resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially exploitable:
- No special permissions required (any network peer can send RPC requests)
- No cryptographic challenges (no signature verification needed for retrieval requests)
- Attacker only needs knowledge of a recent block ID (easily obtained from normal sync_info broadcast messages)
- The vulnerability is deterministic - it always allows the bypass when `window_size` is configured
- Maximum impact limited only by blocks still in memory and `max_blocks_per_receiving_request` limit

The attack can be executed repeatedly by different peers or the same peer with different parameters, making resource exhaustion attacks particularly feasible.

## Recommendation

Add validation in `process_block_retrieval_inner()` to ensure the requested `target_round` is within the allowed window when `window_size` is configured:

```rust
pub async fn process_block_retrieval_inner(
    &self,
    request: &BlockRetrievalRequest,
) -> Box<BlockRetrievalResponse> {
    let mut blocks = vec![];
    let mut status = BlockRetrievalStatus::Succeeded;
    let mut id = request.block_id();

    match &request {
        BlockRetrievalRequest::V1(req) => {
            // ... existing V1 logic ...
        },
        BlockRetrievalRequest::V2(req) => {
            // SECURITY FIX: Validate target_round is within allowed window
            if let Some(window_size) = self.window_size {
                let commit_round = self.commit_root().round();
                let min_allowed_round = calculate_window_start_round(commit_round, window_size).max(1);
                
                if req.target_round() < min_allowed_round {
                    warn!(
                        "Rejecting block retrieval request with target_round {} below window start {}",
                        req.target_round(),
                        min_allowed_round
                    );
                    return Box::new(BlockRetrievalResponse::new(
                        BlockRetrievalStatus::NotEnoughBlocks,
                        vec![],
                    ));
                }
            }
            
            // ... existing retrieval logic ...
        },
    }
    // ... rest of function ...
}
```

This ensures external requests are subject to the same window_size restrictions that the system enforces when initiating its own block retrievals.

## Proof of Concept

```rust
// Reproduction steps (conceptual - would require test harness):

// 1. Setup: Create a BlockStore with window_size = 100
let window_size = Some(100);
let block_store = create_test_block_store_with_window(window_size);

// 2. Populate with 200 blocks (rounds 1-200)
for round in 1..=200 {
    insert_test_block(&block_store, round);
}

// 3. Commit up to round 200
commit_blocks_up_to(&block_store, 200);

// 4. Calculate legitimate window (should be rounds 101-200)
let commit_round = 200;
let window_start = calculate_window_start_round(commit_round, 100); // Returns 101

// 5. Attacker sends malicious request
let malicious_request = BlockRetrievalRequest::V2(BlockRetrievalRequestV2 {
    block_id: get_block_id_for_round(200),  // Recent block
    num_blocks: 100,
    target_round: 1,  // WAY outside the window [101-200]
});

// 6. Process the request
let response = block_store.process_block_retrieval_inner(&malicious_request).await;

// 7. Verify vulnerability: Response contains blocks outside window
assert_eq!(response.status(), BlockRetrievalStatus::SucceededWithTarget);
assert!(response.blocks().len() > 0);

// The oldest block retrieved should have round >= 101 (window start)
// But due to the vulnerability, it can have round much less than 101
let oldest_block_round = response.blocks().last().unwrap().round();
assert!(oldest_block_round < window_start, 
    "Vulnerability: Retrieved block at round {} which is outside window starting at round {}", 
    oldest_block_round, window_start);
```

**Note**: The exact blocks retrievable depend on which blocks remain in `id_to_block` after pruning, but the vulnerability allows requesting blocks outside the intended window without validation.

### Citations

**File:** consensus/src/block_storage/sync_manager.rs (L329-363)
```rust
    pub(crate) fn generate_target_block_retrieval_payload_and_num_blocks<'a>(
        highest_quorum_cert: &'a QuorumCert,
        highest_commit_cert: &'a WrappedLedgerInfo,
        window_size: Option<u64>,
    ) -> (TargetBlockRetrieval, u64) {
        match window_size {
            None => {
                let num_blocks = highest_quorum_cert.certified_block().round()
                    - highest_commit_cert.ledger_info().ledger_info().round()
                    + 1;
                let target_block_id = highest_commit_cert.commit_info().id();
                info!(
                    "[FastForwardSync] with window_size: None, target_block_id: {}, num_blocks: {}",
                    target_block_id, num_blocks
                );
                (
                    TargetBlockRetrieval::TargetBlockId(target_block_id),
                    num_blocks,
                )
            },
            Some(window_size) => {
                let target_round = calculate_window_start_round(
                    highest_commit_cert.ledger_info().ledger_info().round(),
                    window_size,
                )
                .max(1); // Never retrieve genesis block
                let num_blocks = highest_quorum_cert.certified_block().round() - target_round + 1;
                info!(
                    "[FastForwardSync] with window_size: {}, target_round: {}, num_blocks: {}",
                    window_size, target_round, num_blocks
                );
                (TargetBlockRetrieval::TargetRound(target_round), num_blocks)
            },
        }
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L567-583)
```rust
            BlockRetrievalRequest::V2(req) => {
                while (blocks.len() as u64) < req.num_blocks() {
                    if let Some(executed_block) = self.get_block(id) {
                        if !executed_block.block().is_genesis_block() {
                            blocks.push(executed_block.block().clone());
                        }
                        if req.is_window_start_block(executed_block.block()) {
                            status = BlockRetrievalStatus::SucceededWithTarget;
                            break;
                        }
                        id = executed_block.parent_id();
                    } else {
                        status = BlockRetrievalStatus::NotEnoughBlocks;
                        break;
                    }
                }
            },
```

**File:** consensus/consensus-types/src/block_retrieval.rs (L150-156)
```rust
    /// The window start block is either exactly at the target round, or it is at a higher round
    /// and its parent is at a lower round than the target round.
    pub fn is_window_start_block(&self, block: &Block) -> bool {
        block.round() == self.target_round()
            || (block.round() > self.target_round()
                && block.quorum_cert().certified_block().round() < self.target_round())
    }
```

**File:** consensus/src/epoch_manager.rs (L608-615)
```rust
                    BlockRetrievalRequest::V2(v2) => {
                        if v2.num_blocks() > max_blocks_allowed {
                            warn!(
                                "Ignore block retrieval with too many blocks: {}",
                                v2.num_blocks()
                            );
                            continue;
                        }
```

**File:** config/src/config/consensus_config.rs (L232-232)
```rust
            max_pruned_blocks_in_mem: 100,
```
