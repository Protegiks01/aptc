# Audit Report

## Title
Indexer Fails to Capture V2 Token Events from ConcurrentSupply Collections

## Summary
The PostgreSQL indexer's `V2TokenEvent::from_event()` function only handles legacy event types (`MintEvent`, `BurnEvent`, etc.) but does not handle the new event types (`Mint`, `Burn`, `Mutation`, `Transfer`, `SetMaxSupply`) emitted by modern collections using `ConcurrentSupply`. This causes all token activity for newly created collections to be invisible to indexer-dependent services.

## Finding Description

The Token V2 framework in Aptos uses different event emission patterns based on the supply tracking mechanism: [1](#0-0) 

All new collections created via `create_fixed_collection()` and `create_unlimited_collection()` use `ConcurrentSupply` by default. When minting tokens, `ConcurrentSupply` collections always emit the new `Mint` event format: [2](#0-1) 

However, the indexer only handles the legacy `MintEvent` format: [3](#0-2) 

The match statement only covers:
- `0x4::collection::MintEvent` (legacy)
- `0x4::token::MutationEvent` (legacy)  
- `0x4::collection::BurnEvent` (legacy)
- `0x1::object::TransferEvent` (legacy)

Missing event types that return `None`:
- `0x4::collection::Mint` (new format, always emitted by ConcurrentSupply)
- `0x4::collection::Burn` (new format, always emitted by ConcurrentSupply)
- `0x4::token::Mutation` (new format)
- `0x4::collection::Mutation` (collection metadata changes)
- `0x1::object::Transfer` (new format)
- `0x4::collection::SetMaxSupply` (max supply changes)

When these events are not matched, the indexer skips them: [4](#0-3) 

## Impact Explanation

This is classified as **Low severity** because:

1. **No blockchain security is compromised** - consensus, state consistency, and on-chain data remain secure
2. **No funds can be stolen** - all token operations execute correctly on-chain
3. **Data is still accessible** - events are properly emitted and can be queried directly from blockchain nodes

However, it enables **deception through information hiding**:
- Explorers and dapps show incomplete token activity history
- Users cannot track mints, burns, and transfers through standard indexer APIs
- Malicious actors can hide token minting/burning activities
- Collection creators can secretly change max supply without indexer visibility
- Token scarcity and supply information appears incorrect

## Likelihood Explanation

This occurs with **100% probability** for all collections created using the standard APIs since:
- `create_fixed_collection()` and `create_unlimited_collection()` both create `ConcurrentSupply` collections by default
- `ConcurrentSupply` always emits new event formats regardless of feature flags
- The indexer has no fallback mechanism to handle these events

## Recommendation

Add support for new event types to the `V2TokenEvent` enum and `from_event()` function:

```rust
pub enum V2TokenEvent {
    MintEvent(MintEvent),
    Mint(Mint),  // Add new format
    BurnEvent(BurnEvent), 
    Burn(Burn),  // Add new format
    TokenMutationEvent(TokenMutationEvent),
    TokenMutation(TokenMutation),  // Add new format
    CollectionMutation(CollectionMutation),  // Add new event type
    TransferEvent(TransferEvent),
    Transfer(Transfer),  // Add new format
    SetMaxSupply(SetMaxSupply),  // Add new event type
}
```

Update the match statement to handle all event types: [5](#0-4) 

## Proof of Concept

```move
#[test(creator = @0x123)]
fun test_concurrent_mint_not_indexed(creator: &signer) {
    use aptos_framework::event;
    
    // Create a collection using standard API (creates ConcurrentSupply)
    let collection_name = string::utf8(b"Test Collection");
    collection::create_fixed_collection(
        creator,
        string::utf8(b"Description"),
        100,
        collection_name,
        option::none(),
        string::utf8(b"https://example.com")
    );
    
    let collection_addr = collection::create_collection_address(
        &signer::address_of(creator),
        &collection_name
    );
    let collection_obj = object::address_to_object<Collection>(collection_addr);
    
    // Mint a token - this emits Mint (new format), not MintEvent
    collection::increment_supply(&collection_obj, @0x456);
    
    // Verify the NEW Mint event was emitted (not MintEvent)
    assert!(event::emitted_events<Mint>().length() == 1, 0);
    assert!(event::emitted_events<MintEvent>().length() == 0, 1);
    
    // The indexer's V2TokenEvent::from_event() would return None for this event
    // causing it to be skipped in token_activities_v2 table
}
```

## Notes

While this is categorized as Low severity per the indexing layer's scope, it represents a critical gap in data transparency that undermines user trust in Aptos explorers and analytics tools. The issue affects **all newly created collections** on the network, making it pervasive despite its low direct security impact.

### Citations

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L188-214)
```text
    public fun create_fixed_collection(
        creator: &signer,
        description: String,
        max_supply: u64,
        name: String,
        royalty: Option<Royalty>,
        uri: String,
    ): ConstructorRef {
        assert!(max_supply != 0, error::invalid_argument(EMAX_SUPPLY_CANNOT_BE_ZERO));
        let collection_seed = create_collection_seed(&name);
        let constructor_ref = object::create_named_object(creator, collection_seed);

        let supply = ConcurrentSupply {
            current_supply: aggregator_v2::create_aggregator(max_supply),
            total_minted: aggregator_v2::create_unbounded_aggregator(),
        };

        create_collection_internal(
            creator,
            constructor_ref,
            description,
            name,
            royalty,
            uri,
            option::some(supply),
        )
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L378-392)
```text
        if (exists<ConcurrentSupply>(collection_addr)) {
            let supply = &mut ConcurrentSupply[collection_addr];
            assert!(
                aggregator_v2::try_add(&mut supply.current_supply, 1),
                error::out_of_range(ECOLLECTION_SUPPLY_EXCEEDED),
            );
            aggregator_v2::add(&mut supply.total_minted, 1);
            event::emit(
                Mint {
                    collection: collection_addr,
                    index: aggregator_v2::snapshot(&supply.total_minted),
                    token,
                },
            );
            option::some(aggregator_v2::snapshot(&supply.total_minted))
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L514-539)
```rust
impl V2TokenEvent {
    pub fn from_event(
        data_type: &str,
        data: &serde_json::Value,
        txn_version: i64,
    ) -> Result<Option<Self>> {
        match data_type {
            "0x4::collection::MintEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::MintEvent(inner)))
            },
            "0x4::token::MutationEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(Self::TokenMutationEvent(inner))),
            "0x4::collection::BurnEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::BurnEvent(inner)))
            },
            "0x1::object::TransferEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::TransferEvent(inner)))
            },
            _ => Ok(None),
        }
        .context(format!(
            "version {} failed! failed to parse type {}, data {:?}",
            txn_version, data_type, data
        ))
    }
}
```

**File:** crates/indexer/src/models/token_models/v2_token_activities.rs (L148-161)
```rust
        let event_type = event.typ.to_string();
        if let Some(token_event) =
            &V2TokenEvent::from_event(event_type.as_str(), &event.data, txn_version)?
        {
            let event_account_address =
                standardize_address(&event.guid.account_address.to_string());
            // burn and mint events are attached to the collection. The rest should be attached to the token
            let token_data_id = match token_event {
                V2TokenEvent::MintEvent(inner) => inner.get_token_address(),
                V2TokenEvent::BurnEvent(inner) => inner.get_token_address(),
                V2TokenEvent::TransferEvent(inner) => inner.get_object_address(),
                _ => event_account_address.clone(),
            };

```
