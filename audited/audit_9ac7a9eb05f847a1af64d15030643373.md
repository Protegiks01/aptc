# Audit Report

## Title
Missing TLS Certificate Pinning for OIDC Provider JWK Fetches Enables Potential MITM Attacks

## Summary
The JWK consensus system fetches JSON Web Keys from OIDC providers over HTTPS without implementing certificate pinning. An attacker possessing a fraudulent CA certificate trusted by validator nodes could perform man-in-the-middle attacks to inject malicious JWKs, potentially compromising keyless account authentication if they can affect more than 2/3 of validators by voting power.

## Finding Description

The Aptos blockchain implements a keyless authentication system where validators periodically fetch JWKs (JSON Web Keys) from OIDC providers and reach consensus on them. These on-chain JWKs are subsequently used to validate keyless transactions.

The JWK fetching implementation uses a default `reqwest::Client` without any TLS certificate pinning configuration: [1](#0-0) [2](#0-1) 

This client trusts the system's default CA store without restricting trust to specific certificates for OIDC providers. The JWKObserver spawns periodic fetch tasks using these functions: [3](#0-2) 

The `OIDCProvider` configuration structure only contains the provider name and config URL, with no field for pinned certificates: [4](#0-3) 

**Attack Scenario:**

1. Attacker obtains a fraudulent CA certificate that is trusted by the system trust store on validator nodes (through CA compromise, supply chain attack, or other means)
2. Attacker positions themselves as a network MITM between validators and OIDC providers
3. Attacker intercepts HTTPS connections and presents fraudulent certificates signed by the compromised CA
4. Validators accept the fraudulent certificates and fetch malicious JWKs provided by the attacker
5. If the attacker compromises >2/3 of validators by voting power, malicious JWKs reach consensus: [5](#0-4) 

6. Malicious JWKs are stored on-chain and used to validate keyless transactions: [6](#0-5) 

7. Attacker can now forge signatures for keyless accounts using the malicious private keys corresponding to the injected JWKs

The system does implement certificate pinning for Vault connections, demonstrating that the capability exists in the codebase: [7](#0-6) 

However, this pattern is not applied to OIDC provider connections.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "Significant protocol violations."

**Potential Impacts:**
- **Keyless Account Takeover**: Attackers could forge valid signatures for keyless accounts, gaining unauthorized access to user funds and capabilities
- **Protocol Trust Violation**: The system's trust model assumes authentic JWKs from OIDC providers; this vulnerability breaks that assumption
- **Consensus Integrity**: While consensus itself isn't broken (requires >2/3 Byzantine behavior), the external dependency on OIDC provider authenticity becomes a single point of failure if certificate infrastructure is compromised

However, this does NOT reach Critical severity because:
- Consensus safety mechanisms still function (requires >2/3 validator compromise)
- The attack requires extraordinary capabilities beyond typical attackers
- No direct funds loss occurs without additional steps (account takeover)

## Likelihood Explanation

The likelihood is **LOW to MODERATE** due to high attacker capability requirements:

**Required Attacker Capabilities:**
1. **CA Compromise**: Obtain fraudulent CA certificate trusted by validators (nation-state capability, historical precedent: DigiNotar 2011, Comodo 2011, Symantec issues)
2. **Network Position**: Achieve MITM position on >2/3 validators' connections to OIDC providers
3. **Persistent Compromise**: Maintain this position across consensus rounds

**Mitigating Factors:**
- Validators typically operate in secure datacenter environments with monitored network egress
- Multiple major OIDC providers (Google, Facebook) are used; attacking all simultaneously is difficult
- The >2/3 consensus threshold provides Byzantine fault tolerance
- Certificate transparency logs and monitoring may detect fraudulent certificates

**Aggravating Factors:**
- Supply chain attacks on validator deployments could inject trusted CA certificates
- State-level adversaries have demonstrated CA compromise capabilities
- The impact if successful is severe (account takeover)

## Recommendation

Implement TLS certificate pinning for OIDC provider connections by:

1. **Extend OIDCProvider Configuration** to include pinned certificate information:
```move
// In jwks.move
struct OIDCProvider has store, copy, drop {
    name: vector<u8>,
    config_url: vector<u8>,
    // Add pinned certificate (PEM or DER encoded, or certificate fingerprint)
    pinned_cert: Option<vector<u8>>,
}
```

2. **Configure reqwest with custom TLS connector**:
```rust
// In jwk-utils/src/lib.rs
pub async fn fetch_jwks_uri_from_openid_config(
    config_url: &str,
    pinned_cert: Option<&[u8]>
) -> Result<String> {
    let mut client_builder = reqwest::Client::builder();
    
    if let Some(cert_bytes) = pinned_cert {
        let cert = reqwest::Certificate::from_pem(cert_bytes)?;
        client_builder = client_builder.add_root_certificate(cert);
        // Optionally disable system CA store when pinning is configured
        client_builder = client_builder.tls_built_in_root_certs(false);
    }
    
    let client = client_builder.build()?;
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

3. **Update governance process** to allow configuring pinned certificates when adding OIDC providers

4. **Implement certificate rotation mechanism** for when OIDC providers update their certificates

5. **Add monitoring and alerting** for certificate validation failures

## Proof of Concept

A complete PoC would require extensive infrastructure (fraudulent CA, network MITM setup, multiple validators). Instead, here's a simplified demonstration showing the vulnerability:

```rust
#[tokio::test]
#[ignore] // Requires network access and MITM setup
async fn test_missing_certificate_pinning() {
    use crate::{fetch_jwks_uri_from_openid_config, fetch_jwks_from_jwks_uri};
    
    // Setup: Attacker runs a fake OIDC server with certificate 
    // signed by a fraudulent CA that's been added to system trust store
    let fake_oidc_url = "https://attacker-controlled-oidc.example.com/.well-known/openid-configuration";
    
    // The current implementation will accept the fraudulent certificate
    // because it trusts all system CAs
    let jwks_uri = fetch_jwks_uri_from_openid_config(fake_oidc_url)
        .await
        .expect("Should succeed with fraudulent but trusted cert");
    
    let malicious_jwks = fetch_jwks_from_jwks_uri(None, &jwks_uri)
        .await
        .expect("Should fetch attacker's malicious JWKs");
    
    // At this point, the validator has accepted malicious JWKs
    // If >2/3 validators fall victim, these will reach consensus
    assert!(!malicious_jwks.is_empty());
    
    // With certificate pinning, this attack would fail:
    // Error: "certificate verify failed: certificate signature failure"
}
```

To demonstrate the issue practically, one would need to:
1. Set up a local CA and add it to the validator's trust store
2. Generate certificates for test OIDC domains
3. Configure validators to fetch from these domains
4. Show that malicious JWKs are accepted
5. Show that with certificate pinning, the same attack fails

**Notes**

While the codebase demonstrates the capability for certificate pinning in Vault client connections, this security measure has not been extended to OIDC provider integrations. The lack of pinning creates a dependency on the entire system CA infrastructure's security, rather than limiting trust to specific, verified certificates for critical authentication providers.

The consensus mechanism provides defense-in-depth by requiring >2/3 validator agreement, preventing single-validator compromise from affecting on-chain JWKs. However, this does not eliminate the vulnerability if an attacker can compromise the TLS trust store across multiple validators through supply chain or infrastructure attacks.

This finding represents a significant security hardening opportunity, particularly given that keyless authentication is a core feature affecting user account security. The recommendation should be prioritized for implementation before widespread production use of keyless accounts.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L29-29)
```rust
    let client = reqwest::Client::new();
```

**File:** crates/jwk-utils/src/lib.rs (L41-41)
```rust
    let client = reqwest::Client::new();
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-109)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
```

**File:** types/src/jwks/mod.rs (L59-72)
```rust
#[derive(Default, Serialize, Deserialize)]
pub struct OIDCProvider {
    pub name: Issuer,
    pub config_url: Vec<u8>,
}

impl OIDCProvider {
    pub fn new(name: String, config_url: String) -> Self {
        Self {
            name: name.as_bytes().to_vec(),
            config_url: config_url.as_bytes().to_vec(),
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L94-97)
```rust
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(voters.iter(), true);
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-220)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;
```

**File:** secure/storage/vault/src/lib.rs (L133-143)
```rust
        let mut tls_builder = native_tls::TlsConnector::builder();
        tls_builder.min_protocol_version(Some(native_tls::Protocol::Tlsv12));
        if let Some(certificate) = ca_certificate {
            // First try the certificate as a PEM encoded cert, then as DER, and then panic.
            let mut cert = native_tls::Certificate::from_pem(certificate.as_bytes());
            if cert.is_err() {
                cert = native_tls::Certificate::from_der(certificate.as_bytes());
            }
            tls_builder.add_root_certificate(cert.unwrap());
        }
        let tls_connector = Arc::new(tls_builder.build().unwrap());
```
