# Audit Report

## Title
State Inconsistency in Stream Termination: Feedback Processing Failure After Stream Removal

## Summary
In `process_terminate_stream_request()`, the data stream is removed from active streams before processing notification feedback. If `handle_notification_feedback()` subsequently fails, the stream remains removed while the feedback is not processed, creating an inconsistent state where the data client is never notified about bad peer responses. This allows malicious peers to avoid reputation penalties.

## Finding Description

The vulnerability exists in the stream termination logic where the order of operations creates an unrecoverable failure state. [1](#0-0) 

The stream is removed from `self.data_streams` at line 220, but notification feedback processing occurs afterward at lines 233-234. When `handle_notification_feedback()` is called with the `?` operator, any error causes immediate function return.

The problem is that `handle_notification_feedback()` can fail for legitimate feedback types used in production: [2](#0-1) 

This function calls `extract_response_error()` which only handles three specific feedback types: [3](#0-2) 

The `NotificationFeedback` enum contains five variants, but `extract_response_error()` only handles three (InvalidPayloadData, PayloadTypeIsIncorrect, PayloadProofFailed). The other variants (EmptyPayloadData, EndOfStream) fall through to the error case.

Critically, `EmptyPayloadData` is actively used in production code: [4](#0-3) [5](#0-4) 

**Attack Flow:**
1. Malicious peer sends empty payload to syncing node
2. Bootstrapper/continuous syncer detects empty payload
3. Calls `terminate_stream_with_feedback()` with `EmptyPayloadData` feedback
4. `process_terminate_stream_request()` removes stream at line 220
5. `handle_notification_feedback()` fails at line 234 because `extract_response_error()` doesn't handle `EmptyPayloadData`
6. Error propagates up, but stream is already removed
7. Data client never receives `notify_bad_response()` call (line 260 in data_stream.rs never executes)
8. Peer reputation tracking bypassed - malicious peer can repeat attack [6](#0-5) 

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **State Inconsistency**: Stream removed but feedback not processed, violating atomicity of stream termination operations
2. **Peer Reputation Bypass**: Malicious peers sending empty payloads avoid detection and reputation penalties in the data client's peer scoring system
3. **Degraded Sync Performance**: Without proper peer feedback, the system cannot learn from failures and may repeatedly request data from bad peers
4. **Resource Inefficiency**: Failed feedback processing means wasted bandwidth and computational resources on repeated requests to malicious peers

This breaks the **State Consistency** invariant (invariant #4): state transitions must be atomic. The stream termination is partially complete (stream removed) but the feedback notification is not atomic (feedback not processed).

While not directly affecting consensus safety, this degrades the network's ability to synchronize state efficiently and allows malicious actors to disrupt sync operations without consequence.

## Likelihood Explanation

**High Likelihood:**

1. **Production Code Path**: `EmptyPayloadData` feedback is used in active production code paths in both bootstrapper and continuous syncer components
2. **No Special Permissions Required**: Any network peer can trigger this by sending empty payloads
3. **Simple Attack**: Attacker only needs to respond to data requests with empty payloads
4. **Repeatable**: Attack can be executed continuously without detection due to feedback bypass
5. **Natural Occurrence**: Can happen legitimately if peers have data gaps, making it harder to distinguish from attacks

The test suite only tests `InvalidPayloadData` feedback (which works correctly): [7](#0-6) 

No test exists for the `EmptyPayloadData` failure case, indicating this vulnerability was overlooked.

## Recommendation

Process notification feedback **before** removing the stream, or ensure idempotent cleanup on failure. The fix should move feedback processing before stream removal:

```rust
fn process_terminate_stream_request(
    &mut self,
    terminate_request: &TerminateStreamRequest,
) -> Result<(), Error> {
    let data_stream_id = &terminate_request.data_stream_id;
    let notification_and_feedback = &terminate_request.notification_and_feedback;

    // Increment the stream termination counter
    let feedback_label = match notification_and_feedback {
        Some(notification_and_feedback) => {
            notification_and_feedback.notification_feedback.get_label()
        },
        None => TERMINATE_NO_FEEDBACK,
    };
    metrics::increment_counter(&metrics::TERMINATE_DATA_STREAM, feedback_label);

    // Get the data stream (but don't remove yet)
    let data_stream = self.data_streams.get(data_stream_id).ok_or_else(|| {
        Error::UnexpectedErrorEncountered(format!(
            "Unable to find data stream with ID: {:?}. Notification and feedback: {:?}",
            data_stream_id, notification_and_feedback,
        ))
    })?;

    // Handle any notification feedback BEFORE removing stream
    if let Some(notification_and_feedback) = notification_and_feedback {
        let notification_id = &notification_and_feedback.notification_id;
        let feedback = &notification_and_feedback.notification_feedback;
        if data_stream.sent_notification(notification_id) {
            data_stream.handle_notification_feedback(notification_id, feedback)?;
        } else {
            return Err(Error::UnexpectedErrorEncountered(format!(
                "Data stream ID: {:?} did not appear to send notification ID: {:?}",
                data_stream_id, notification_id,
            )));
        }
    }

    // NOW remove the data stream after feedback is processed
    self.data_streams.remove(data_stream_id);
    
    info!(LogSchema::new(LogEntry::HandleTerminateRequest)
        .stream_id(*data_stream_id)
        .event(LogEvent::Success)
        .message(&format!(
            "Terminated data stream with ID: {:?}. Notification and feedback: {:?}",
            data_stream_id, notification_and_feedback,
        )));

    Ok(())
}
```

Additionally, fix `extract_response_error()` to handle all feedback types:

```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        NotificationFeedback::EmptyPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::EndOfStream => Ok(ResponseError::InvalidData), // Or dedicated error type
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_terminate_with_empty_payload_feedback() {
    // Create streaming service
    let (_, mut streaming_service) = 
        tests::streaming_service::create_streaming_client_and_server(
            None, false, false, true, false
        );

    // Create a data stream
    let (new_stream_request, response_receiver) = create_new_stream_request();
    streaming_service.handle_stream_request_message(
        new_stream_request,
        create_stream_update_notifier(),
    );
    let data_stream_listener = response_receiver.now_or_never().unwrap().unwrap().unwrap();
    let data_stream_id = data_stream_listener.data_stream_id;

    // Verify stream exists
    assert!(streaming_service.get_all_data_stream_ids().contains(&data_stream_id));

    // Get a notification from the stream
    let timeout_deadline = Instant::now().add(Duration::from_secs(60));
    let mut notification_id = None;
    while Instant::now() < timeout_deadline {
        streaming_service.check_progress_of_all_data_streams().await;
        if let Ok(data_notification) = timeout(
            Duration::from_secs(1),
            data_stream_listener.select_next_some(),
        ).await {
            notification_id = Some(data_notification.notification_id);
            break;
        }
    }
    let notification_id = notification_id.expect("Should receive notification");

    // Attempt to terminate with EmptyPayloadData feedback
    let notification_and_feedback = Some(NotificationAndFeedback {
        notification_id,
        notification_feedback: NotificationFeedback::EmptyPayloadData,
    });
    let (terminate_stream_request, _) = create_terminate_stream_request(
        data_stream_id,
        notification_and_feedback,
    );
    
    streaming_service.handle_stream_request_message(
        terminate_stream_request,
        create_stream_update_notifier(),
    );

    // BUG: Stream is removed even though feedback processing failed
    assert!(!streaming_service.get_all_data_stream_ids().contains(&data_stream_id));
    // The data client was never notified about the bad response
    // Peer reputation not updated - malicious peer can continue attacking
}
```

This test demonstrates that streams are removed even when feedback processing fails with `EmptyPayloadData`, confirming the state inconsistency vulnerability.

### Citations

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L220-234)
```rust
        if let Some(data_stream) = self.data_streams.remove(data_stream_id) {
            info!(LogSchema::new(LogEntry::HandleTerminateRequest)
                .stream_id(*data_stream_id)
                .event(LogEvent::Success)
                .message(&format!(
                    "Terminating the data stream with ID: {:?}. Notification and feedback: {:?}",
                    data_stream_id, notification_and_feedback,
                )));

            // Handle any notification feedback
            if let Some(notification_and_feedback) = notification_and_feedback {
                let notification_id = &notification_and_feedback.notification_id;
                let feedback = &notification_and_feedback.notification_feedback;
                if data_stream.sent_notification(notification_id) {
                    data_stream.handle_notification_feedback(notification_id, feedback)?;
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L776-779)
```rust
                            let notification_and_feedback = Some(NotificationAndFeedback {
                                notification_id,
                                notification_feedback: NotificationFeedback::InvalidPayloadData,
                            });
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L234-262)
```rust
    pub fn handle_notification_feedback(
        &self,
        notification_id: &NotificationId,
        notification_feedback: &NotificationFeedback,
    ) -> Result<(), Error> {
        if self.stream_end_notification_id == Some(*notification_id) {
            return if matches!(notification_feedback, NotificationFeedback::EndOfStream) {
                Ok(())
            } else {
                Err(Error::UnexpectedErrorEncountered(format!(
                    "Invalid feedback given for stream end: {:?}",
                    notification_feedback
                )))
            };
        }

        let response_context = self
            .notifications_to_responses
            .get(notification_id)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered(format!(
                    "Response context missing for notification ID: {:?}",
                    notification_id
                ))
            })?;
        let response_error = extract_response_error(notification_feedback)?;
        self.notify_bad_response(response_context, response_error);

        Ok(())
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L746-764)
```rust
    /// Notifies the Aptos data client of a bad client response
    fn notify_bad_response(
        &self,
        response_context: &ResponseContext,
        response_error: ResponseError,
    ) {
        let response_id = response_context.id;
        info!(LogSchema::new(LogEntry::ReceivedDataResponse)
            .stream_id(self.data_stream_id)
            .event(LogEvent::Error)
            .message(&format!(
                "Notifying the data client of a bad response. Response id: {:?}, error: {:?}",
                response_id, response_error
            )));

        response_context
            .response_callback
            .notify_bad_response(response_error);
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1383-1395)
```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid notification feedback given: {:?}",
            notification_feedback
        ))),
    }
}
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1080-1090)
```rust
        // Verify the payload isn't empty
        if epoch_ending_ledger_infos.is_empty() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(
                "The epoch ending payload was empty!".into(),
            ));
        }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L411-420)
```rust
        } else {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            Err(Error::VerificationError(
                "The playload starting version is missing!".into(),
            ))
        }
```
