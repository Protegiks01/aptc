# Audit Report

## Title
Fragment Reassembly Memory Exhaustion via Unchecked Cumulative Size Validation

## Summary
The network layer's fragment reassembly mechanism fails to validate that the cumulative size of reassembled messages stays within `MAX_MESSAGE_SIZE` (64 MiB). An attacker can send a valid `StreamHeader` with `num_fragments=16` followed by 16 maximal fragments, causing the victim node to reassemble a message exceeding 68 MiB—approximately 7% larger than the intended limit—leading to memory exhaustion and potential node degradation.

## Finding Description

The fragment reassembly logic in the Aptos network layer allows large messages (>4 MiB) to be split into a header followed by multiple fragments for transmission. The vulnerability exists in the `InboundStream::append_fragment` function, which blindly appends fragment data without validating the cumulative reassembled size. [1](#0-0) 

The attack flow:

1. **Attacker sends malicious `StreamHeader`**: The header specifies `num_fragments=16` and contains a `NetworkMessage` with ~4 MiB of raw data.

2. **Header validation passes**: The `InboundStream::new` function validates that `num_fragments <= max_fragments`, where `max_fragments = MAX_MESSAGE_SIZE / MAX_FRAME_SIZE = 64 MiB / 4 MiB = 16`. [2](#0-1) 

3. **Attacker sends 16 maximal fragments**: Each `StreamFragment` contains approximately 4 MiB of `raw_data` (constrained only by the per-frame codec limit, not cumulative size).

4. **Unchecked reassembly**: Each fragment's `raw_data` is appended to the message via `Vec::append` without checking if the total size exceeds `MAX_MESSAGE_SIZE`. [3](#0-2) 

5. **Memory overflow**: Total reassembled size ≈ 4 MiB (header) + (16 × 4 MiB) = 68 MiB, exceeding the 64 MiB limit by ~7%.

The `max_fragments` calculation in the peer initialization only prevents having too many fragments, but does not enforce that the sum of all fragment sizes stays within bounds: [4](#0-3) 

In contrast, the legitimate `OutboundStream` enforces the limit before sending: [5](#0-4) 

However, malicious peers are not bound by this client-side validation and can craft arbitrary messages that bypass it.

This breaks **Invariant #9: Resource Limits** - "All operations must respect gas, storage, and computational limits." The network layer's MAX_MESSAGE_SIZE constant is defined precisely to prevent excessive memory allocations: [6](#0-5) [7](#0-6) 

## Impact Explanation

**Severity: High** (Validator Node Slowdowns / Resource Exhaustion)

Each malicious stream forces a victim validator to allocate approximately 4-8 MiB more memory than intended. While a single oversized message may not crash a node, an attacker can:

1. **Open multiple concurrent connections** to the same validator
2. **Send multiple malicious streams simultaneously** across these connections  
3. **Cause cumulative memory pressure** leading to:
   - Increased memory allocation failures
   - GC pressure and performance degradation
   - Potential OOM conditions if system memory is constrained
   - Validator slowdowns affecting consensus participation

The attack requires no validator privileges—any network peer can exploit this. The impact qualifies as **High Severity** per the Aptos bug bounty: "Validator node slowdowns" caused by resource exhaustion attacks that degrade validator performance without requiring Byzantine collusion.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to succeed because:

1. **No authentication barrier**: Any peer can connect to validator nodes and send stream messages
2. **Simple exploit**: Requires only crafting a `StreamHeader` with `num_fragments=16` and sending 16 fragments
3. **No detection**: The fragments pass all existing validations (sequential IDs, request ID matching, fragment count)
4. **Repeatable**: An attacker can sustain the attack by continuously opening new connections and sending malicious streams
5. **Amplification**: Multiple concurrent streams multiply the memory impact

The only constraint is the per-frame size limit enforced by the `LengthDelimitedCodec`, which still allows each fragment to carry ~4 MiB of data—enough to exceed the cumulative limit.

## Recommendation

Add cumulative size validation in `InboundStream::append_fragment` to ensure the reassembled message does not exceed `MAX_MESSAGE_SIZE`:

```rust
fn append_fragment(&mut self, mut fragment: StreamFragment) -> anyhow::Result<bool> {
    // ... existing validations ...

    // NEW: Validate cumulative size before appending
    let current_size = self.message.data_len();
    let fragment_size = fragment.raw_data.len();
    let new_total_size = current_size.checked_add(fragment_size)
        .ok_or_else(|| anyhow::anyhow!("Fragment size overflow"))?;
    
    ensure!(
        new_total_size <= MAX_MESSAGE_SIZE,
        "Cumulative message size {} exceeds MAX_MESSAGE_SIZE {}",
        new_total_size,
        MAX_MESSAGE_SIZE
    );

    // Append the fragment data to the message
    let raw_data = &mut fragment.raw_data;
    match &mut self.message {
        NetworkMessage::Error(_) => {
            panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
        },
        NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
        NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
        NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
    }

    // ... rest of function ...
}
```

Additionally, pass `max_message_size` to `InboundStreamBuffer::new()` and store it for validation:

```rust
pub struct InboundStreamBuffer {
    stream: Option<InboundStream>,
    max_fragments: usize,
    max_message_size: usize,  // NEW
}

impl InboundStreamBuffer {
    pub fn new(max_fragments: usize, max_message_size: usize) -> Self {
        Self {
            stream: None,
            max_fragments,
            max_message_size,
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_tests {
    use super::*;
    use crate::protocols::wire::messaging::v1::{DirectSendMsg, NetworkMessage};
    use crate::protocols::wire::handshake::v1::ProtocolId;

    #[test]
    fn test_fragment_reassembly_exceeds_max_message_size() {
        // Configuration matching production defaults
        let max_frame_size = 4 * 1024 * 1024; // 4 MiB
        let max_message_size = 64 * 1024 * 1024; // 64 MiB
        let max_fragments = max_message_size / max_frame_size; // 16

        // Create inbound stream buffer
        let mut buffer = InboundStreamBuffer::new(max_fragments);

        // Attacker sends header with num_fragments=16
        let request_id = 1;
        let num_fragments = 16_u8;
        
        // Header message contains ~4 MiB of data
        let header_data_size = max_frame_size - 100; // Accounting for overhead
        let header = StreamHeader {
            request_id,
            num_fragments,
            message: NetworkMessage::DirectSendMsg(DirectSendMsg {
                protocol_id: ProtocolId::ConsensusDirectSend,
                priority: 0,
                raw_msg: vec![0u8; header_data_size],
            }),
        };

        // Initialize stream
        assert!(buffer.new_stream(header).is_ok());

        // Attacker sends 16 fragments, each with ~4 MiB
        let fragment_data_size = max_frame_size - 100;
        let mut total_size = header_data_size;

        for fragment_id in 1..=num_fragments {
            let fragment = StreamFragment {
                request_id,
                fragment_id,
                raw_data: vec![0u8; fragment_data_size],
            };

            total_size += fragment_data_size;

            let result = buffer.append_fragment(fragment);
            assert!(result.is_ok(), "Fragment {} should be accepted", fragment_id);

            // After all fragments, check total size
            if fragment_id == num_fragments {
                if let Some(message) = result.unwrap() {
                    let final_size = message.data_len();
                    
                    // VULNERABILITY: Final size exceeds MAX_MESSAGE_SIZE
                    assert!(
                        final_size > max_message_size,
                        "Expected size {} to exceed MAX_MESSAGE_SIZE {}",
                        final_size,
                        max_message_size
                    );
                    
                    println!("EXPLOIT SUCCESS:");
                    println!("  MAX_MESSAGE_SIZE: {} bytes ({} MiB)", 
                        max_message_size, max_message_size / (1024 * 1024));
                    println!("  Reassembled size: {} bytes ({} MiB)", 
                        final_size, final_size / (1024 * 1024));
                    println!("  Overflow: {} bytes ({} MiB)",
                        final_size - max_message_size,
                        (final_size - max_message_size) / (1024 * 1024));
                }
            }
        }
    }
}
```

**Notes:**

The vulnerability is real and exploitable. The fragment reassembly mechanism trusts that malicious peers will respect the same size limits that legitimate `OutboundStream` enforces client-side, but there is no server-side validation during reassembly. This allows an attacker to exceed `MAX_MESSAGE_SIZE` by constructing maximally-sized fragments that individually pass validation but collectively violate the cumulative size constraint. The fix requires adding cumulative size tracking and validation in `InboundStream::append_fragment`.

### Citations

**File:** network/framework/src/protocols/stream/mod.rs (L145-153)
```rust
        let header_num_fragments = header.num_fragments;
        ensure!(
            header_num_fragments > 0,
            "Stream header must specify at least one fragment!"
        );
        ensure!(
            (header_num_fragments as usize) <= max_fragments,
            "Stream header exceeds max fragments limit!"
        );
```

**File:** network/framework/src/protocols/stream/mod.rs (L163-214)
```rust
    /// Append a fragment to the stream (returns true if the stream is complete)
    fn append_fragment(&mut self, mut fragment: StreamFragment) -> anyhow::Result<bool> {
        // Verify the stream request ID and fragment request ID
        ensure!(
            self.request_id == fragment.request_id,
            "Stream fragment from a different request! Expected {}, got {}.",
            self.request_id,
            fragment.request_id
        );

        // Verify the fragment ID
        let fragment_id = fragment.fragment_id;
        ensure!(fragment_id > 0, "Fragment ID must be greater than zero!");
        ensure!(
            fragment_id <= self.num_fragments,
            "Fragment ID {} exceeds number of fragments {}!",
            fragment_id,
            self.num_fragments
        );

        // Verify the fragment ID is the expected next fragment
        let expected_fragment_id = self.received_fragment_id.checked_add(1).ok_or_else(|| {
            anyhow::anyhow!(
                "Current fragment ID overflowed when adding 1: {}",
                self.received_fragment_id
            )
        })?;
        ensure!(
            expected_fragment_id == fragment_id,
            "Unexpected fragment ID, expected {}, got {}!",
            expected_fragment_id,
            fragment_id
        );

        // Update the received fragment ID
        self.received_fragment_id = expected_fragment_id;

        // Append the fragment data to the message
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            NetworkMessage::Error(_) => {
                panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
            },
            NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
            NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
            NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
        }

        // Return whether the stream is complete
        let is_stream_complete = self.received_fragment_id == self.num_fragments;
        Ok(is_stream_complete)
    }
```

**File:** network/framework/src/protocols/stream/mod.rs (L266-273)
```rust
        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );
```

**File:** network/framework/src/peer/mod.rs (L168-194)
```rust
        let max_fragments = max_message_size / max_frame_size;
        Self {
            network_context,
            executor,
            time_service: time_service.clone(),
            connection_metadata,
            connection: Some(socket),
            connection_notifs_tx,
            peer_reqs_rx,
            upstream_handlers,
            inbound_rpcs: InboundRpcs::new(
                network_context,
                time_service.clone(),
                remote_peer_id,
                inbound_rpc_timeout,
                max_concurrent_inbound_rpcs,
            ),
            outbound_rpcs: OutboundRpcs::new(
                network_context,
                time_service,
                remote_peer_id,
                max_concurrent_outbound_rpcs,
            ),
            state: State::Connected,
            max_frame_size,
            max_message_size,
            inbound_stream: InboundStreamBuffer::new(max_fragments),
```

**File:** network/framework/src/constants.rs (L21-21)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
