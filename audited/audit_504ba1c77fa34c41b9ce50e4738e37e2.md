# Audit Report

## Title
Missing Protocol ID Validation in Message Reception Allows Byzantine Nodes to Send Messages on Unauthorized Protocols

## Summary
The Peer message handler fails to validate that incoming network messages use protocol IDs that were negotiated during the connection handshake. This allows Byzantine nodes to send consensus messages on any protocol for which the receiving node has registered a handler, completely bypassing the protocol negotiation mechanism established during the handshake phase.

## Finding Description

During connection establishment, peers exchange `HandshakeMsg` and negotiate which application protocols they mutually support through `perform_handshake()`. The negotiated protocols are stored in `ConnectionMetadata.application_protocols` as a `ProtocolIdSet`. [1](#0-0) 

The handshake negotiation computes the intersection of supported protocols to ensure both peers agree on valid communication channels: [2](#0-1) 

When sending messages, `NetworkClient.get_preferred_protocol_for_peer()` validates that the target peer supports the desired protocol by checking against the negotiated `application_protocols`: [3](#0-2) 

However, **when receiving messages**, the `Peer.handle_inbound_network_message()` function only checks if a handler exists for the protocol ID—it does not validate whether the protocol was actually negotiated during the handshake: [4](#0-3) 

For both `DirectSendMsg` and `RpcRequest`, the code only verifies `self.upstream_handlers.get(&protocol_id)` exists, but never checks if `self.connection_metadata.application_protocols.contains(protocol_id)`.

**Attack Scenario:**
1. Byzantine validator connects to honest node
2. During handshake, advertises support only for `ConsensusRpcBcs`  
3. Honest node stores `ProtocolIdSet { ConsensusRpcBcs }` in `ConnectionMetadata.application_protocols`
4. Byzantine validator sends consensus message with `protocol_id = ConsensusRpcJson` or any other protocol
5. Honest node's `handle_inbound_network_message()` receives the message
6. Code checks only if handler exists for `ConsensusRpcJson`, not if it was negotiated
7. Message is processed even though the protocol was never authorized

This breaks the fundamental invariant that "messages must only be sent on protocols negotiated during handshake."

## Impact Explanation

This qualifies as **High Severity** under the Aptos Bug Bounty criteria for "Significant protocol violations."

The vulnerability undermines the protocol negotiation security model by allowing Byzantine nodes to:

1. **Bypass Protocol-Specific Security Controls**: If different protocols have different security properties, rate limits, or processing costs, attackers can choose the most advantageous protocol regardless of what was negotiated.

2. **Exploit Protocol-Specific Vulnerabilities**: Different serialization formats (BCS, JSON, Compressed) have different attack surfaces. A Byzantine node could target less-tested or more vulnerable protocol handlers.

3. **Violate Network Security Assumptions**: The handshake mechanism exists to establish trust boundaries. Bypassing it weakens defense-in-depth and could enable more complex multi-stage attacks.

4. **Affect All Consensus Validators**: Every honest validator is vulnerable to receiving unauthorized protocol messages from Byzantine peers, directly impacting consensus safety assumptions.

While this vulnerability alone may not directly cause funds loss or consensus failure, it represents a fundamental protocol violation that weakens the security model and could be chained with other vulnerabilities to achieve more severe impacts.

## Likelihood Explanation

**Likelihood: High**

- **No authentication required**: Any peer that can establish a network connection can exploit this
- **Trivial to exploit**: Simply send messages with different `protocol_id` than what was negotiated
- **Affects all connections**: Every peer connection is vulnerable
- **No special conditions needed**: Works on any network message type (DirectSend or RPC)

The attack requires zero sophisticated techniques—just sending network messages with arbitrary protocol IDs.

## Recommendation

Add validation in `handle_inbound_network_message()` to verify that incoming messages use protocols that were negotiated during the handshake:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    // Extract protocol_id from the message
    let protocol_id = match &message {
        NetworkMessage::DirectSendMsg(direct) => direct.protocol_id,
        NetworkMessage::RpcRequest(request) => request.protocol_id,
        NetworkMessage::RpcResponse(response) => response.protocol_id,
        NetworkMessage::Error(_) => return Ok(()), // Errors don't need validation
    };
    
    // Validate protocol was negotiated during handshake
    if !self.connection_metadata.application_protocols.contains(protocol_id) {
        warn!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata(&self.connection_metadata),
            protocol_id = ?protocol_id,
            negotiated_protocols = ?self.connection_metadata.application_protocols,
            "Peer {} sent message on unauthorized protocol {:?}. Dropping message.",
            self.remote_peer_id().short_str(),
            protocol_id
        );
        counters::direct_send_messages(&self.network_context, "unauthorized_protocol").inc();
        return Ok(());
    }
    
    // Continue with existing handler dispatch logic...
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // ... existing code ...
        }
        // ... rest of existing code ...
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_unauthorized_protocol_accepted() {
    use aptos_network::protocols::wire::handshake::v1::ProtocolIdSet;
    use aptos_network::ProtocolId;
    
    // Setup: Create a peer connection with negotiated protocols
    let mut connection_metadata = ConnectionMetadata::mock(PeerId::random());
    
    // During handshake, only ConsensusRpcBcs was negotiated
    connection_metadata.application_protocols = 
        ProtocolIdSet::from_iter(vec![ProtocolId::ConsensusRpcBcs]);
    
    // Byzantine node sends message on ConsensusRpcJson (not negotiated!)
    let unauthorized_msg = NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::ConsensusRpcJson,  // NOT in application_protocols!
        priority: 0,
        raw_msg: vec![0xde, 0xad, 0xbe, 0xef].into(),
    });
    
    // Create peer with this connection metadata
    let (peer, mut handler_rx) = create_test_peer_with_metadata(connection_metadata);
    
    // Send the unauthorized message
    peer.handle_inbound_network_message(unauthorized_msg).unwrap();
    
    // VULNERABILITY: Message is processed even though protocol wasn't negotiated!
    // The handler receives the message without any validation error
    let received = handler_rx.try_recv();
    assert!(received.is_ok(), "Unauthorized protocol message was accepted!");
    
    // Expected behavior: Message should be rejected with an error
    // Actual behavior: Message is accepted and forwarded to handler
}
```

## Notes

The vulnerability exists because the protocol negotiation during handshake establishes a security contract that is not enforced during message reception. The `application_protocols` field in `ConnectionMetadata` is populated but never consulted when validating incoming messages. This represents a gap between the security model (protocols must be negotiated) and the implementation (no validation of negotiated protocols).

### Citations

**File:** network/framework/src/transport/mod.rs (L297-317)
```rust
    // exchange HandshakeMsg
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket)
        .await
        .map_err(|err| add_pp_addr(proxy_protocol_enabled, err, &addr))?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/application/interface.rs (L132-158)
```rust
    /// Identify the supported protocols from the specified peer's connection
    fn get_supported_protocols(&self, peer: &PeerNetworkId) -> Result<ProtocolIdSet, Error> {
        let peers_and_metadata = self.get_peers_and_metadata();
        peers_and_metadata
            .get_metadata_for_peer(*peer)
            .map(|peer_metadata| peer_metadata.get_supported_protocols())
    }

    /// Selects the preferred protocol for the specified peer. The preferred protocols
    /// should be sorted from most to least preferable.
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/peer/mod.rs (L447-541)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
            },
            NetworkMessage::Error(error_msg) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    error_msg = ?error_msg,
                    "{} Peer {} sent an error message: {:?}",
                    self.network_context,
                    self.remote_peer_id().short_str(),
                    error_msg,
                );
            },
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
            },
            NetworkMessage::RpcResponse(_) => {
                // non-reference cast identical to this match case
                let NetworkMessage::RpcResponse(response) = message else {
                    unreachable!("NetworkMessage type changed between match and let")
                };
                self.outbound_rpcs.handle_inbound_response(response)
            },
        };
        Ok(())
    }
```
