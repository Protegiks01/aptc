# Audit Report

## Title
Orphaned Epoch Data in LedgerInfoSchema During Database Truncation

## Summary
The `delete_per_epoch_data()` function in `truncation_helper.rs` contains a logic flaw where only the latest epoch in `LedgerInfoSchema` is checked for deletion, leaving intermediate non-epoch-ending epochs orphaned when multiple epochs require truncation. This violates the State Consistency invariant and can cause database corruption during backup/restore operations.

## Finding Description

The vulnerability exists in the `delete_per_epoch_data()` function which has two deletion phases: [1](#0-0) 

**Phase 1 (lines 399-411)**: Seeks to the **last** epoch in `LedgerInfoSchema`, retrieves exactly **one** epoch via a single `iter.next()` call, and deletes it only if its version >= `start_version`. This is NOT a loop—it processes only the latest epoch.

**Phase 2 (lines 413-425)**: Iterates through `EpochByVersionSchema` starting from `start_version` and deletes those epochs from both schemas. However, `EpochByVersionSchema` only contains **epoch-ending** entries. [2](#0-1) 

As shown above, `put_ledger_info()` stores every `LedgerInfo` in `LedgerInfoSchema` (epoch → LedgerInfo mapping), but only stores epoch-ending entries in `EpochByVersionSchema` when `ledger_info.ends_epoch()` returns true. [3](#0-2) [4](#0-3) 

**The Bug**: If multiple non-epoch-ending epochs exist with versions >= `start_version` (possible during backup/restore or data recovery), only the latest one is deleted by Phase 1, while intermediate ones remain orphaned because:
1. They're not in `EpochByVersionSchema` (haven't ended)
2. Phase 1 only processes one epoch
3. Phase 2 cannot find them

**Concrete Scenario**:
- Epoch 11 ended at version 2000 (in both schemas)
- Epoch 12 in-progress at version 2500 (only in `LedgerInfoSchema`)
- Epoch 13 in-progress at version 3000 (only in `LedgerInfoSchema`)
- Truncate from `start_version = 2200`

**Execution**:
- Phase 1: Seeks last → finds epoch 13 @ v3000 → deletes epoch 13 (3000 >= 2200)
- Phase 2: Seeks v2200 in `EpochByVersionSchema` → finds nothing (last entry is epoch 11 @ v2000)
- **Result**: Epoch 12 remains orphaned in `LedgerInfoSchema` [5](#0-4) 

The test above expects consistency between the schemas after truncation—it would fail if orphaned epochs exist, but the test data doesn't generate the problematic scenario of multiple non-epoch-ending epochs.

## Impact Explanation

**Severity: Medium** ($10,000 range per Aptos Bug Bounty)

This qualifies as "State inconsistencies requiring intervention" because:

1. **Database Corruption**: Orphaned `LedgerInfoSchema` entries create inconsistency between `LedgerInfoSchema` and `EpochByVersionSchema`, violating the State Consistency invariant.

2. **Epoch Lookup Failures**: Queries using `get_latest_ledger_info_in_epoch()` may return stale data for orphaned epochs. [6](#0-5) 

3. **State Sync Issues**: During state synchronization, nodes may encounter inconsistent epoch metadata, causing sync failures or incorrect epoch state validation.

4. **Manual Intervention Required**: Recovery requires manual database repair or restoration from backup, as the inconsistency cannot be automatically resolved.

5. **Not Critical**: Does not directly enable fund theft, consensus violations, or network partition. The impact is limited to state consistency within the storage layer.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific preconditions:

1. **Multiple Non-Epoch-Ending Epochs**: The database must contain multiple epochs (≥ 2) that haven't ended yet, all with versions >= `start_version`.

2. **Triggering Scenarios**:
   - **Backup/Restore Operations**: Restoring from multiple backup sources or partial backups can create this state
   - **Data Recovery**: Manual database reconstruction or migration
   - **Abnormal Shutdowns**: Rare race conditions during write operations (though unlikely with proper transaction handling)

3. **Operator Actions**: Most commonly triggered by database administrators using the truncation tool during recovery operations. [7](#0-6) 

4. **Not Exploitable by External Attackers**: Requires privileged access to database administration tools, so unprivileged attackers cannot trigger this directly.

While the conditions are somewhat rare in normal operation, they're realistic in operational scenarios (backup/restore, disaster recovery), making this a legitimate robustness issue.

## Recommendation

Replace the single-epoch deletion in Phase 1 with a loop that processes **all** epochs in `LedgerInfoSchema` with versions >= `start_version`:

```rust
fn delete_per_epoch_data(
    ledger_db: &DB,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    // Phase 1: Delete ALL epochs from LedgerInfoSchema with version >= start_version
    let mut epochs_to_delete = Vec::new();
    let mut iter = ledger_db.iter::<LedgerInfoSchema>()?;
    iter.seek_to_first();
    
    for item in iter {
        let (epoch, ledger_info) = item?;
        let version = ledger_info.commit_info().version();
        if version >= start_version {
            epochs_to_delete.push(epoch);
        }
    }
    
    for epoch in epochs_to_delete {
        info!(
            epoch = epoch,
            "Truncate epoch data from LedgerInfoSchema."
        );
        batch.delete::<LedgerInfoSchema>(&epoch)?;
    }

    // Phase 2: Delete epoch-ending data from EpochByVersionSchema
    let mut iter = ledger_db.iter::<EpochByVersionSchema>()?;
    iter.seek(&start_version)?;

    for item in iter {
        let (version, epoch) = item?;
        info!(
            version = version,
            epoch = epoch,
            "Truncate epoch ending data."
        );
        batch.delete::<EpochByVersionSchema>(&version)?;
        // Note: No need to delete from LedgerInfoSchema again, already done above
    }

    Ok(())
}
```

**Alternative**: If performance is a concern with full iteration, use reverse iteration from the end until `version < start_version`:

```rust
let mut iter = ledger_db.rev_iter::<LedgerInfoSchema>()?;
iter.seek_to_last();

for item in iter {
    let (epoch, ledger_info) = item?;
    let version = ledger_info.commit_info().version();
    if version < start_version {
        break; // Stop when we reach epochs before start_version
    }
    batch.delete::<LedgerInfoSchema>(&epoch)?;
}
```

## Proof of Concept

```rust
#[test]
fn test_orphaned_epoch_data_during_truncation() {
    use aptos_temppath::TempPath;
    use crate::db::AptosDB;
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    use aptos_types::block_info::BlockInfo;
    use aptos_schemadb::SchemaBatch;
    
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Setup: Create epoch-ending LedgerInfo for epoch 11 at version 2000
    let li_11 = create_epoch_ending_ledger_info(11, 2000);
    db.ledger_db().metadata_db().put_ledger_info(&li_11, &mut SchemaBatch::new()).unwrap();
    
    // Create non-epoch-ending LedgerInfo for epoch 12 at version 2500
    let li_12 = create_non_epoch_ending_ledger_info(12, 2500);
    db.ledger_db().metadata_db().put_ledger_info(&li_12, &mut SchemaBatch::new()).unwrap();
    
    // Create non-epoch-ending LedgerInfo for epoch 13 at version 3000
    let li_13 = create_non_epoch_ending_ledger_info(13, 3000);
    db.ledger_db().metadata_db().put_ledger_info(&li_13, &mut SchemaBatch::new()).unwrap();
    
    // Verify initial state: epochs 11, 12, 13 in LedgerInfoSchema
    assert!(db.ledger_db().metadata_db().get_latest_ledger_info_in_epoch(11).is_ok());
    assert!(db.ledger_db().metadata_db().get_latest_ledger_info_in_epoch(12).is_ok());
    assert!(db.ledger_db().metadata_db().get_latest_ledger_info_in_epoch(13).is_ok());
    
    // Truncate from version 2200 (between epoch 11 and 12)
    let mut batch = SchemaBatch::new();
    delete_per_epoch_data(
        db.ledger_db().metadata_db().db(),
        2200,
        &mut batch
    ).unwrap();
    db.ledger_db().metadata_db().write_schemas(batch).unwrap();
    
    // Expected: epochs 12 and 13 should be deleted
    assert!(db.ledger_db().metadata_db().get_latest_ledger_info_in_epoch(11).is_ok());
    
    // BUG: Epoch 12 is orphaned (not deleted)
    assert!(db.ledger_db().metadata_db().get_latest_ledger_info_in_epoch(12).is_ok(), 
            "Epoch 12 should be deleted but remains orphaned!");
    
    // Epoch 13 is correctly deleted
    assert!(db.ledger_db().metadata_db().get_latest_ledger_info_in_epoch(13).is_err());
}
```

## Notes

This vulnerability represents a **data consistency bug** in the storage layer rather than a direct security exploit. While it cannot be triggered by external attackers without database access, it poses a real risk during operational scenarios like disaster recovery, backup restoration, or database migrations.

The root cause is the assumption that only one non-epoch-ending epoch exists at any time, which holds true during normal blockchain operation but breaks during abnormal scenarios. The fix ensures complete cleanup by iterating through all epochs rather than checking only the latest one.

The test in `truncate/mod.rs` would catch this bug if it generated test data with multiple non-epoch-ending epochs, but the current test data generation doesn't create this scenario, allowing the bug to remain undetected.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L394-428)
```rust
fn delete_per_epoch_data(
    ledger_db: &DB,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let mut iter = ledger_db.iter::<LedgerInfoSchema>()?;
    iter.seek_to_last();
    if let Some((epoch, ledger_info)) = iter.next().transpose()? {
        let version = ledger_info.commit_info().version();
        if version >= start_version {
            info!(
                version = version,
                epoch = epoch,
                "Truncate latest epoch data."
            );
            batch.delete::<LedgerInfoSchema>(&epoch)?;
        }
    }

    let mut iter = ledger_db.iter::<EpochByVersionSchema>()?;
    iter.seek(&start_version)?;

    for item in iter {
        let (version, epoch) = item?;
        info!(
            version = version,
            epoch = epoch,
            "Truncate epoch ending data."
        );
        batch.delete::<EpochByVersionSchema>(&version)?;
        batch.delete::<LedgerInfoSchema>(&epoch)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L113-120)
```rust
    pub(crate) fn get_latest_ledger_info_in_epoch(
        &self,
        epoch: u64,
    ) -> Result<LedgerInfoWithSignatures> {
        self.db
            .get::<LedgerInfoSchema>(&epoch)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Last LedgerInfo of epoch {epoch}")))
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L186-198)
```rust
    pub(crate) fn put_ledger_info(
        &self,
        ledger_info_with_sigs: &LedgerInfoWithSignatures,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let ledger_info = ledger_info_with_sigs.ledger_info();

        if ledger_info.ends_epoch() {
            // This is the last version of the current epoch, update the epoch by version index.
            batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
        }
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
    }
```

**File:** storage/aptosdb/src/schema/ledger_info/mod.rs (L26-31)
```rust
define_schema!(
    LedgerInfoSchema,
    u64, /* epoch num */
    LedgerInfoWithSignatures,
    LEDGER_INFO_CF_NAME
);
```

**File:** storage/aptosdb/src/schema/epoch_by_version/mod.rs (L27-32)
```rust
define_schema!(
    EpochByVersionSchema,
    Version,
    u64, // epoch_num
    EPOCH_BY_VERSION_CF_NAME
);
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L137-142)
```rust
        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L293-300)
```rust
            let mut iter = ledger_metadata_db.iter::<EpochByVersionSchema>().unwrap();
            iter.seek_to_last();
            let (version, epoch) = iter.next().transpose().unwrap().unwrap();
            prop_assert!(version <= target_version);

            let mut iter = ledger_metadata_db.iter::<LedgerInfoSchema>().unwrap();
            iter.seek_to_last();
            prop_assert_eq!(iter.next().transpose().unwrap().unwrap().0, epoch);
```
