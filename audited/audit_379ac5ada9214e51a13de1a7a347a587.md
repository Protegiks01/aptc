# Audit Report

## Title
Race Condition in Order Vote Creation Causes Consensus Liveness Failure Due to Non-Deterministic Block Info

## Summary
A critical race condition exists in the order vote creation flow where `PipelinedBlock::order_vote_proposal()` reads block execution results without synchronizing with the asynchronous execution pipeline. This causes different validators to sign order votes with different `BlockInfo` values (placeholder vs. actual execution results) depending on execution timing, preventing order vote aggregation and causing consensus liveness failure.

## Finding Description

The vulnerability occurs in the order vote creation flow when a QC is aggregated. The round manager immediately broadcasts order votes without waiting for block execution to complete. [1](#0-0) 

When `broadcast_order_vote` is called, it retrieves the block and creates an order vote without any synchronization with execution: [2](#0-1) 

The `create_order_vote` function calls `block.order_vote_proposal(qc)`: [3](#0-2) 

Which reads the current `block_info()`: [4](#0-3) 

The `block_info()` method reads from `state_compute_result` which contains execution-dependent fields: [5](#0-4) 

The `state_compute_result` is initially set to a dummy value with placeholder hash when blocks are created: [6](#0-5) [7](#0-6) 

Block execution happens asynchronously and `set_compute_result()` is called to update with real execution results: [8](#0-7) [9](#0-8) 

The `BlockInfo` contains execution-dependent fields that differ based on timing: [10](#0-9) 

Order votes embed this `BlockInfo` in their `LedgerInfo`: [11](#0-10) 

When order votes are aggregated, they are grouped by `LedgerInfo` hash: [12](#0-11) 

**The Attack Path:**

1. Block is proposed and inserted into the block store
2. Execution pipeline starts asynchronously for all validators
3. QC is formed from regular votes (which correctly use placeholders)
4. Validators begin creating order votes when QC is aggregated:
   - **Fast validators**: Execution hasn't completed yet, `block_info()` returns placeholder hash (`ACCUMULATOR_PLACEHOLDER_HASH`) and version 0
   - **Slow validators**: Execution completed, `block_info()` returns actual execution hash and version
5. Order votes split across different `LedgerInfo` hashes
6. Neither group reaches quorum threshold
7. Consensus cannot order the block â†’ liveness failure

This contrasts with commit votes which properly wait for execution: [13](#0-12) 

## Impact Explanation

This vulnerability causes **Total loss of liveness/network availability**, which is a **Critical Severity** issue per Aptos bug bounty criteria (up to $1,000,000):

- Blocks cannot be ordered despite having valid QCs
- Consensus progression halts
- Network becomes unable to process transactions
- Requires manual intervention or network restart to recover
- Violates the **Deterministic Execution** invariant where all validators must produce identical signatures for consensus

The vulnerability can be triggered:
- **Naturally**: Due to normal timing variations in validator execution speeds, network latency, or system load differences
- **Maliciously**: An attacker creating blocks with varying computational complexity can amplify timing differences

## Likelihood Explanation

**High likelihood** - This can occur in normal operation:

- Validators have different hardware specifications and system loads
- Network conditions vary across validators  
- Execution time varies based on transaction complexity
- The window between QC formation and order vote creation provides opportunity for timing misalignment
- No synchronization mechanism exists to prevent the race condition
- The code path is executed in every round where order votes are enabled

Decoupled execution is always enabled per the configuration: [14](#0-13) 

And order votes are enabled in default configurations: [15](#0-14) 

## Recommendation

Add synchronization to ensure execution completes before creating order votes. Either:

1. **Wait for execution before broadcasting order votes** (similar to commit votes):
   - Have `broadcast_order_vote` await `block.wait_for_compute_result()` before calling `create_order_vote`

2. **Use placeholder values consistently** (similar to regular votes):
   - Modify `order_vote_proposal()` to always use placeholder BlockInfo regardless of execution state

The first approach is recommended as it ensures order votes contain deterministic execution results.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a network with validators having different execution speeds
2. Proposing a block with moderate transaction complexity
3. Observing QC formation from regular votes
4. Monitoring order vote aggregation - votes will split based on execution completion timing
5. Observing consensus halt when no order vote group reaches quorum

The race condition is inherent in the code flow where `broadcast_order_vote` is called immediately upon QC formation without any execution synchronization, while execution completes asynchronously at different times across validators.

### Citations

**File:** consensus/src/round_manager.rs (L1626-1639)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
        let order_vote_result = self
            .safety_rules
            .lock()
            .construct_and_sign_order_vote(&order_vote_proposal);
        let order_vote = order_vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {} for order vote",
            block.block()
        ))?;
```

**File:** consensus/src/round_manager.rs (L1653-1662)
```rust
    async fn broadcast_order_vote(
        &mut self,
        vote: &Vote,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<()> {
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
```

**File:** consensus/src/round_manager.rs (L1795-1815)
```rust
                if self.onchain_config.order_vote_enabled() {
                    // This check is already done in safety rules. As printing the "failed to broadcast order vote"
                    // in humio logs could sometimes look scary, we are doing the same check again here.
                    if let Some(last_sent_vote) = self.round_state.vote_sent() {
                        if let Some((two_chain_timeout, _)) = last_sent_vote.two_chain_timeout() {
                            if round <= two_chain_timeout.round() {
                                return Ok(());
                            }
                        }
                    }
                    // Broadcast order vote if the QC is successfully aggregated
                    // Even if broadcast order vote fails, the function will return Ok
                    if let Err(e) = self.broadcast_order_vote(vote, qc.clone()).await {
                        warn!(
                            "Failed to broadcast order vote for QC {:?}. Error: {:?}",
                            qc, e
                        );
                    } else {
                        self.broadcast_fast_shares(qc.certified_block()).await;
                    }
                }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L277-307)
```rust
    pub fn set_compute_result(
        &self,
        state_compute_result: StateComputeResult,
        execution_time: Duration,
    ) {
        let mut to_commit = 0;
        let mut to_retry = 0;
        for txn in state_compute_result.compute_status_for_input_txns() {
            match txn {
                TransactionStatus::Keep(_) => to_commit += 1,
                TransactionStatus::Retry => to_retry += 1,
                _ => {},
            }
        }

        let execution_summary = ExecutionSummary {
            payload_len: self
                .block
                .payload()
                .map_or(0, |payload| payload.len_for_execution()),
            to_commit,
            to_retry,
            execution_time,
            root_hash: state_compute_result.root_hash(),
            gas_used: state_compute_result
                .execution_output
                .block_end_info
                .as_ref()
                .map(|info| info.block_effective_gas_units()),
        };
        *self.state_compute_result.lock() = state_compute_result;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L394-397)
```rust
    pub fn new_ordered(block: Block, window: OrderedBlockWindow) -> Self {
        let input_transactions = Vec::new();
        let state_compute_result = StateComputeResult::new_dummy();
        Self::new(block, input_transactions, state_compute_result).with_block_window(window)
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L74-76)
```rust
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```

**File:** consensus/src/pipeline/execution_schedule_phase.rs (L70-76)
```rust
        let fut = async move {
            for b in ordered_blocks.iter_mut() {
                let (compute_result, execution_time) = b.wait_for_compute_result().await?;
                b.set_compute_result(compute_result, execution_time);
            }
            Ok(ordered_blocks)
        }
```

**File:** types/src/block_info.rs (L36-39)
```rust
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-118)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
```

**File:** consensus/src/pending_order_votes.rs (L67-81)
```rust
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L978-1006)
```rust
    async fn sign_and_broadcast_commit_vote(
        ledger_update_fut: TaskFuture<LedgerUpdateResult>,
        order_vote_rx: oneshot::Receiver<()>,
        order_proof_fut: TaskFuture<WrappedLedgerInfo>,
        commit_proof_fut: TaskFuture<LedgerInfoWithSignatures>,
        signer: Arc<ValidatorSigner>,
        block: Arc<Block>,
        order_vote_enabled: bool,
        network_sender: Arc<NetworkSender>,
    ) -> TaskResult<CommitVoteResult> {
        let mut tracker = Tracker::start_waiting("sign_commit_vote", &block);
        let (compute_result, _, epoch_end_timestamp) = ledger_update_fut.await?;
        let mut consensus_data_hash = select! {
            Ok(_) = order_vote_rx => {
                HashValue::zero()
            }
            Ok(li) = order_proof_fut => {
                li.ledger_info().ledger_info().consensus_data_hash()
            }
            Ok(li) = commit_proof_fut => {
                li.ledger_info().consensus_data_hash()
            }
            else => {
                return Err(anyhow!("all receivers dropped"))?;
            }
        };
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
```

**File:** types/src/on_chain_config/consensus_config.rs (L30-36)
```rust
    pub fn default_for_genesis() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L238-241)
```rust
    /// Decouple execution from consensus or not.
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```
