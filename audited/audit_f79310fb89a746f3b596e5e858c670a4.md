# Audit Report

## Title
Path Traversal Vulnerability in Transaction Backup Manifest Validation Allows Arbitrary File Access During Restore

## Summary
The `TransactionBackup::verify()` method fails to validate FileHandle paths in chunk descriptors, allowing an attacker who controls backup manifests to trigger path traversal attacks. This enables reading arbitrary files on validator nodes during backup restoration, potentially causing denial of service or information disclosure.

## Finding Description

The vulnerability exists in the backup manifest verification flow. When a transaction backup manifest is loaded and verified, the system performs insufficient validation of the FileHandle fields within chunk descriptors. [1](#0-0) 

At this line, `TransactionBackup::verify()` is called to validate the manifest. However, examining the implementation: [2](#0-1) 

The `verify()` method only validates:
1. Version range validity (first â‰¤ last)
2. Non-empty chunks
3. Chunk continuity and version alignment

**Critically, it does NOT validate the FileHandle paths themselves.** The `TransactionChunk` structure contains FileHandle fields for `transactions` and `proof` files: [3](#0-2) 

FileHandle is simply a String alias with no inherent validation: [4](#0-3) 

When chunks are loaded, the FileHandles are used directly to open files: [5](#0-4) 

In the LocalFs storage implementation, this results in unsafe path joining: [6](#0-5) 

The code performs `self.dir.join(file_handle)` without any path sanitization. This allows path traversal sequences like `"../../../../etc/passwd"` to escape the backup directory.

**Attack Flow:**
1. Attacker compromises backup storage or provides malicious manifest to operator
2. Manifest contains valid version ranges (passes `verify()`)
3. Chunk descriptors contain FileHandles with path traversal: `"../../../../sensitive/file"`
4. During restore, `LoadedChunk::load()` opens arbitrary files
5. While cryptographic verification prevents state corruption, the read operation itself causes:
   - DoS if large files or device files are read (`/dev/zero`, `/dev/random`)
   - Resource exhaustion and node slowdown
   - Potential information disclosure through error messages

## Impact Explanation

This qualifies as **HIGH severity** under Aptos Bug Bounty criteria:

**Validator Node Slowdowns**: Reading large files or infinite device files during restore causes significant resource consumption and operational disruption.

**API/Process Crashes**: Unhandled errors during file access or deserialization could crash the restore process, requiring manual intervention.

**Significant Protocol Violations**: While not a consensus violation, compromising validator availability during critical restore operations undermines network reliability.

The vulnerability does NOT allow:
- Direct consensus/safety violations (cryptographic verification prevents this)
- Funds theft or minting
- State corruption (Merkle proofs and signatures must still be valid)

However, validator node compromise during restore operations is a serious availability issue, especially since validators often restore from backups during network upgrades or disaster recovery.

## Likelihood Explanation

**Prerequisites:**
- Attacker must compromise backup storage (S3 bucket, cloud storage) OR
- Operator must be tricked into using attacker-controlled storage OR  
- Man-in-the-middle attack on backup retrieval

**Likelihood: MEDIUM**

While requiring prior compromise of backup infrastructure, this is realistic because:
1. Backup storage is often less secured than production validator nodes
2. Misconfigured S3 buckets are common
3. Operators may use untrusted storage during testing or migration
4. Supply chain attacks could compromise backup pipelines

Once backup storage is controlled, exploitation is trivial - simply modify manifest JSON with malicious FileHandles.

## Recommendation

Add FileHandle path validation to prevent path traversal:

```rust
// In storage/backup/backup-cli/src/backup_types/transaction/manifest.rs
impl TransactionBackup {
    pub fn verify(&self) -> Result<()> {
        // ... existing version validation ...
        
        // Add FileHandle validation
        for chunk in &self.chunks {
            Self::validate_file_handle(&chunk.transactions)?;
            Self::validate_file_handle(&chunk.proof)?;
        }
        
        Ok(())
    }
    
    fn validate_file_handle(handle: &str) -> Result<()> {
        // Prevent path traversal
        ensure!(
            !handle.contains(".."),
            "FileHandle contains path traversal sequence: {}",
            handle
        );
        
        // Ensure relative path
        ensure!(
            !Path::new(handle).is_absolute(),
            "FileHandle must be relative path: {}",
            handle
        );
        
        Ok(())
    }
}
```

Additionally, in `LocalFs::open_for_read()`, add defensive canonicalization:

```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    let path = self.dir.join(file_handle);
    
    // Verify path stays within backup directory
    let canonical_path = path.canonicalize()
        .context("Failed to canonicalize path")?;
    let canonical_dir = self.dir.canonicalize()
        .context("Failed to canonicalize backup dir")?;
    
    ensure!(
        canonical_path.starts_with(&canonical_dir),
        "Path traversal attempt detected: {:?} escapes {:?}",
        canonical_path,
        canonical_dir
    );
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical_path)
        .await
        .err_notes(&canonical_path)?;
    Ok(Box::new(file))
}
```

## Proof of Concept

```rust
// Test demonstrating path traversal in manifest
#[tokio::test]
async fn test_path_traversal_in_manifest() {
    use std::fs;
    use tempfile::TempDir;
    
    // Setup: Create backup directory and a sensitive file outside it
    let temp_dir = TempDir::new().unwrap();
    let backup_dir = temp_dir.path().join("backups");
    let sensitive_dir = temp_dir.path().join("sensitive");
    
    fs::create_dir_all(&backup_dir).unwrap();
    fs::create_dir_all(&sensitive_dir).unwrap();
    fs::write(sensitive_dir.join("secret.txt"), "CONFIDENTIAL DATA").unwrap();
    
    // Create malicious manifest
    let malicious_manifest = serde_json::json!({
        "first_version": 0,
        "last_version": 10,
        "chunks": [{
            "first_version": 0,
            "last_version": 10,
            "transactions": "../sensitive/secret.txt", // PATH TRAVERSAL
            "proof": "valid_proof.bin",
            "format": "V1"
        }]
    });
    
    // Save malicious manifest
    let manifest_path = backup_dir.join("manifest.json");
    fs::write(&manifest_path, malicious_manifest.to_string()).unwrap();
    
    // Verify manifest passes TransactionBackup::verify()
    let manifest: TransactionBackup = serde_json::from_str(
        &fs::read_to_string(&manifest_path).unwrap()
    ).unwrap();
    
    assert!(manifest.verify().is_ok()); // VULNERABILITY: Passes verification!
    
    // Create LocalFs storage
    let storage = LocalFs::new(backup_dir.clone());
    
    // Attempt to open file - will access sensitive file outside backup dir
    let chunk = &manifest.chunks[0];
    let result = storage.open_for_read(&chunk.transactions).await;
    
    // VULNERABILITY: Successfully opens file outside backup directory
    // In real attack, this reads /etc/passwd, private keys, or causes DoS
    if let Ok(mut file) = result {
        let mut contents = Vec::new();
        file.read_to_end(&mut contents).await.unwrap();
        assert_eq!(contents, b"CONFIDENTIAL DATA");
        println!("EXPLOITED: Read sensitive file via path traversal!");
    }
}
```

**Notes**

This vulnerability demonstrates insufficient input validation in a critical backup/restore pathway. While cryptographic verification prevents direct state corruption, the ability to read arbitrary files on validator nodes during restore operations poses serious availability and confidentiality risks. The fix requires defense-in-depth: validation at both the manifest verification layer and the storage access layer.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L105-105)
```rust
        let mut file = BufReader::new(storage.open_for_read(&manifest.transactions).await?);
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L353-353)
```rust
            .and_then(|m: TransactionBackup| future::ready(m.verify().map(|_| m)));
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L19-34)
```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L50-88)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");

        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_version == next_version,
                "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
                next_version,
                chunk.first_version,
            );
            ensure!(
                chunk.last_version >= chunk.first_version,
                "Chunk range invalid. [{}, {}]",
                chunk.first_version,
                chunk.last_version,
            );
            next_version = chunk.last_version + 1;
        }

        // check last version in chunk matches manifest
        ensure!(
            next_version - 1 == self.last_version, // okay to -1 because chunks is not empty.
            "Last version in chunks: {}, in manifest: {}",
            next_version - 1,
            self.last_version,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```
