# Audit Report

## Title
Incomplete Error Enumeration in Rosetta API Causes Specification Compliance Violation

## Summary
The `ApiError::all()` method in `crates/aptos-rosetta/src/error.rs` omits the `RejectedByFilter` error variant from the enumeration returned to the `/network/options` endpoint, violating the Rosetta API specification requirement that all possible errors must be declared. This causes Rosetta client integrations to fail when encountering undeclared error code 35.

## Finding Description

The Rosetta API specification requires that all possible errors be enumerated in the `/network/options` endpoint response. This is explicitly documented in the code comments: [1](#0-0) 

The `ApiError` enum defines 35 error variants, including `RejectedByFilter` at line 55: [2](#0-1) 

This error is assigned code 35 and has proper message and retriability implementations: [3](#0-2) [4](#0-3) 

However, the `all()` method (lines 68-106) which returns all errors for the network/options endpoint omits `RejectedByFilter`: [5](#0-4) 

The list ends at `MempoolIsFull(None)` on line 104 without including `RejectedByFilter(None)`.

This error is actively used in the codebase when transactions are rejected by filters: [6](#0-5) 

The `/network/options` endpoint calls this incomplete `all()` method: [7](#0-6) 

**Attack Scenario:**
1. A Rosetta client calls `/network/options` and receives the list of 34 allowed errors (codes 1-34)
2. The client validates that only these errors are expected per Rosetta specification
3. A transaction is submitted that gets rejected by the transaction filter
4. The API returns `RejectedByFilter` error with code 35
5. The client encounters an unexpected error code 35 that was not in the allowed list
6. The client fails validation, throws an exception, or enters an error state
7. The integration is broken due to specification non-compliance

## Impact Explanation

This constitutes a **Medium severity** issue under "State inconsistencies requiring intervention" because:

1. **Rosetta Specification Violation**: The Rosetta API specification mandates complete error enumeration. The implementation explicitly acknowledges this requirement but fails to fulfill it.

2. **Client Integration Failures**: Rosetta clients that perform strict validation against the allowed error list will fail when encountering error code 35. This breaks the API contract and can cause:
   - Client application crashes
   - Transaction processing failures
   - Integration test failures
   - Compliance check failures with Rosetta CLI validation tools

3. **API State Inconsistency**: The network/options endpoint declares one set of errors while the actual API can return additional errors, creating an inconsistent API state that violates client expectations.

4. **Intervention Required**: Fixing this requires a code update and clients may need to refresh their error mappings.

The README explicitly states error codes must be static and complete: [8](#0-7) 

## Likelihood Explanation

**Likelihood: Medium to High**

1. **Error is Actually Used**: The `RejectedByFilter` error is actively used when the transaction filter rejects transactions, making this a real-world scenario. [9](#0-8) 

2. **No Special Privileges Required**: Any user submitting transactions can trigger this error if the transaction filter is active.

3. **Client Validation Common**: Many Rosetta clients perform strict validation against the allowed error list as required by the specification, making failures likely when code 35 appears.

4. **Rosetta CLI Testing**: The automated Rosetta CLI validation tool could detect this discrepancy if it encounters the error during testing. [10](#0-9) 

## Recommendation

Add `RejectedByFilter(None)` to the `all()` method's return vector:

```rust
pub fn all() -> Vec<ApiError> {
    use ApiError::*;
    vec![
        TransactionIsPending,
        NetworkIdentifierMismatch,
        ChainIdMismatch,
        DeserializationFailed(None),
        InvalidTransferOperations(None),
        InvalidSignatureType,
        InvalidMaxGasFees,
        MaxGasFeeTooLow(None),
        InvalidGasMultiplier,
        GasEstimationFailed(None),
        InvalidOperations(None),
        MissingPayloadMetadata,
        UnsupportedCurrency(None),
        UnsupportedSignatureCount(None),
        NodeIsOffline,
        TransactionParseError(None),
        InternalError(None),
        CoinTypeFailedToBeFetched(None),
        AccountNotFound(None),
        ResourceNotFound(None),
        ModuleNotFound(None),
        StructFieldNotFound(None),
        VersionNotFound(None),
        TransactionNotFound(None),
        TableItemNotFound(None),
        BlockNotFound(None),
        StateValueNotFound(None),
        VersionPruned(None),
        BlockPruned(None),
        InvalidInput(None),
        InvalidTransactionUpdate(None),
        SequenceNumberTooOld(None),
        VmError(None),
        MempoolIsFull(None),
        RejectedByFilter(None),  // ADD THIS LINE
    ]
}
```

## Proof of Concept

**Step 1: Verify the omission**
```bash
# Query the network options endpoint
curl -X POST http://localhost:8080/network/options \
  -H "Content-Type: application/json" \
  -d '{"network_identifier": {"blockchain": "aptos", "network": "testnet"}}'

# Count the errors in the response - should be 34 instead of 35
# Error code 35 (RejectedByFilter) will not be present
```

**Step 2: Trigger the RejectedByFilter error**
```bash
# Submit a transaction that will be rejected by the filter
# (specific parameters depend on filter configuration)
curl -X POST http://localhost:8080/construction/submit \
  -H "Content-Type: application/json" \
  -d '{"network_identifier": {...}, "signed_transaction": "..."}'

# Response will include error code 35 which was not in the allowed list
```

**Step 3: Rosetta client validation failure**
```rust
// Pseudocode for a strict Rosetta client
let options = rosetta_client.network_options().await?;
let allowed_error_codes: HashSet<u32> = options.allow.errors
    .iter()
    .map(|e| e.code)
    .collect();

// Later when receiving an error
let error = rosetta_client.submit_transaction(...).await.unwrap_err();
if !allowed_error_codes.contains(&error.code) {
    panic!("Received unexpected error code {} not in allowed list", error.code);
    // Client fails here when encountering code 35
}
```

## Notes

This vulnerability represents a clear specification violation where the implementation fails to fulfill its documented contract. While the Rosetta API is a separate interface layer from the core blockchain consensus, compliance with the Rosetta specification is critical for ecosystem integration. The omission of `RejectedByFilter` from the error enumeration can cause real-world client failures and requires immediate correction.

### Citations

**File:** crates/aptos-rosetta/src/error.rs (L15-16)
```rust
/// All Rosetta API errors.  Note that all details must be `Option<T>` to make it easier to list all
/// error messages in the `ApiError::all()` call required by the Rosetta spec.
```

**File:** crates/aptos-rosetta/src/error.rs (L55-55)
```rust
    RejectedByFilter(Option<String>),
```

**File:** crates/aptos-rosetta/src/error.rs (L68-106)
```rust
    pub fn all() -> Vec<ApiError> {
        use ApiError::*;
        vec![
            TransactionIsPending,
            NetworkIdentifierMismatch,
            ChainIdMismatch,
            DeserializationFailed(None),
            InvalidTransferOperations(None),
            InvalidSignatureType,
            InvalidMaxGasFees,
            MaxGasFeeTooLow(None),
            InvalidGasMultiplier,
            GasEstimationFailed(None),
            InvalidOperations(None),
            MissingPayloadMetadata,
            UnsupportedCurrency(None),
            UnsupportedSignatureCount(None),
            NodeIsOffline,
            TransactionParseError(None),
            InternalError(None),
            CoinTypeFailedToBeFetched(None),
            AccountNotFound(None),
            ResourceNotFound(None),
            ModuleNotFound(None),
            StructFieldNotFound(None),
            VersionNotFound(None),
            TransactionNotFound(None),
            TableItemNotFound(None),
            BlockNotFound(None),
            StateValueNotFound(None),
            VersionPruned(None),
            BlockPruned(None),
            InvalidInput(None),
            InvalidTransactionUpdate(None),
            SequenceNumberTooOld(None),
            VmError(None),
            MempoolIsFull(None),
        ]
    }
```

**File:** crates/aptos-rosetta/src/error.rs (L146-146)
```rust
            RejectedByFilter(_) => 35,
```

**File:** crates/aptos-rosetta/src/error.rs (L206-206)
```rust
            ApiError::RejectedByFilter(_) => "Transaction was rejected by the transaction filter",
```

**File:** api/src/transactions.rs (L1486-1489)
```rust
            MempoolStatusCode::RejectedByFilter => Err(AptosError::new_with_error_code(
                mempool_status.message,
                AptosErrorCode::RejectedByFilter,
            )),
```

**File:** crates/aptos-rosetta/src/network.rs (L104-107)
```rust
    let errors = ApiError::all()
        .into_iter()
        .map(|err| err.into_error())
        .collect();
```

**File:** crates/aptos-rosetta/README.md (L85-88)
```markdown

All errors are 500s and have error codes that are static and must not change.  To add more errors,
add new codes and associated data.  The error details must not show in the network options call and
are all provided as Option<String> for that reason.
```

**File:** crates/aptos-rosetta/README.md (L99-104)
```markdown
## CLI testing

The [Rosetta CLI](https://www.rosetta-api.org/docs/rosetta_cli.html) can be run with the [rosetta_cli.json](./rosetta_cli.json)
file to run the automated checks.  Additionally, the [aptos.ros](./aptos.ros)
file uses the Rosetta CLI DSL to describe the possible operations that
can be run.
```

**File:** types/src/mempool_status.rs (L66-67)
```rust
    // The transaction filter has rejected the transaction
    RejectedByFilter = 7,
```
