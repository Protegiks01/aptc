# Audit Report

## Title
CLI Update Mechanism Lacks Pre-release Filtering Allowing Supply Chain Attack Vector

## Summary
The `get_update_info()` function in the Aptos CLI update mechanism fetches GitHub releases without filtering pre-releases, taking the first release matching the "aptos-cli-" prefix. This creates a supply chain attack vector where a compromised maintainer account could publish malicious pre-releases that would be automatically downloaded and executed by users running `aptos update`.

## Finding Description

The vulnerability exists in the CLI update mechanism's release fetching logic. [1](#0-0) 

The code builds a `ReleaseList` configuration and calls `fetch()` to retrieve releases from GitHub. [2](#0-1) 

The critical issue is that the code iterates through releases and selects the FIRST one with a version starting with "aptos-cli-", without checking the `prerelease` field that GitHub's API returns for each release.

According to GitHub's API specification, the `/repos/:owner/:repo/releases` endpoint returns both stable releases and pre-releases by default. Releases are typically sorted by creation date (newest first). The code does not filter by the `prerelease` boolean field, meaning:

1. A pre-release with tag `aptos-cli-v999.0.0` created after the latest stable release would appear first in the list
2. The loop would match this pre-release and break immediately
3. Users would download and execute the pre-release binary

The official release workflow explicitly sets `prerelease: false`: [3](#0-2) 

However, this only controls legitimate releases. Nothing prevents a malicious actor with repository write access from creating a pre-release.

**Attack Scenario:**
1. Attacker compromises a maintainer GitHub account through credential theft (realistic supply chain attack vector)
2. Attacker creates a pre-release with:
   - Tag: `aptos-cli-v999.0.0` 
   - `prerelease: true`
   - Malicious binary attached
3. User runs `aptos update` (standard operation)
4. CLI fetches all releases including the malicious pre-release
5. CLI selects the first "aptos-cli-*" match (the malicious pre-release)
6. Malicious binary is downloaded and executed on user's machine

## Impact Explanation

This vulnerability presents a **supply chain attack** vector with potential for **Remote Code Execution** on client machines. The severity assessment is complex:

**If this were a validator node vulnerability**: This would be **Critical Severity** ($1M bounty) as "Remote Code Execution on validator node."

**As a CLI client vulnerability**: The impact depends on who uses the CLI:
- General users: RCE on client machines, potential theft of private keys stored locally
- Validator operators: If they use the CLI for validator management, could lead to validator key compromise
- Developers: Could compromise development environments and lead to further supply chain attacks

The vulnerability maps most closely to **High Severity** ($50K bounty) under "Significant protocol violations" as it compromises the integrity of the official update mechanism, though it's a client-side rather than protocol-level issue.

## Likelihood Explanation

**Likelihood: Medium to Low (within allowed threat model)**

The exploitation requires:
1. **GitHub repository write access**: Either through:
   - Compromised maintainer account (realistic but involves credential theft)
   - Insider threat (explicitly trusted per instructions)
   
2. **User action**: Users must run `aptos update`

**Critical Limitation**: The prompt explicitly excludes "Social engineering, phishing, or key theft" from scope. Since exploiting this vulnerability requires either:
- Phishing/credential theft to compromise a maintainer account (out of scope)
- Social engineering users to use `--repo-owner` flag pointing to malicious repository (out of scope)

The vulnerability, while technically present, may not meet the exploitability criteria under the restricted threat model.

## Recommendation

Add explicit filtering to exclude pre-releases and draft releases:

```rust
// In get_update_info() function after line 70
let releases = config
    .fetch()
    .map_err(|e| anyhow!("Failed to fetch releases: {:#}", e))?;

// Filter out pre-releases and drafts
let releases = releases.into_iter()
    .filter(|release| !release.prerelease && !release.draft);

// Find the latest release of the CLI
let mut releases = releases;
let latest_release = loop {
    let release = match releases.next() {
        Some(release) => release,
        None => return Err(anyhow!("Failed to find latest CLI release")),
    };
    if release.version.starts_with("aptos-cli-") {
        break release;
    }
};
```

Additionally, consider:
1. **Version validation**: Verify version numbers follow expected patterns
2. **Signature verification**: Sign releases and verify signatures before installation
3. **Checksum validation**: Verify binary checksums against published values
4. **User confirmation**: Require confirmation before installing pre-releases if filtering is optional

## Proof of Concept

**Test Setup:**
1. Create a test repository with releases
2. Create a pre-release with tag "aptos-cli-v999.0.0"
3. Run the update command

```bash
# Demonstrate the vulnerability
# 1. Set up test repository with both stable and pre-releases
# 2. Run update command pointing to test repo
cargo run --bin aptos -- update --repo-owner test-account --repo-name test-repo --check

# The CLI will fetch the pre-release if it appears first in the list
# Expected: Should filter pre-releases and only consider stable releases
# Actual: Takes first release matching "aptos-cli-*" regardless of prerelease status
```

**Code-level PoC** (demonstrating the issue):
The `self_update` crate's `ReleaseList::fetch()` returns `Release` objects from GitHub's API. Each `Release` has a `prerelease: bool` field that should be checked but isn't.

---

## Notes

**CRITICAL CAVEAT**: Upon strict validation against the provided criteria, this vulnerability has significant limitations:

1. **Threat Model Restrictions**: The attack requires compromising a maintainer account (credential theft), which is explicitly excluded: "Social engineering, phishing, or key theft" are out of scope.

2. **Privileged Access Required**: Creating GitHub releases requires repository write access, which is a form of privileged access similar to "validator insider access" that the instructions say to focus on bugs exploitable without.

3. **Not a Core Protocol Vulnerability**: This affects the CLI client tool, not the blockchain consensus, execution, storage, or other core protocol components that are the primary focus.

4. **No Relevant Invariant Violation**: The 10 listed critical invariants all relate to blockchain protocol behavior (consensus, execution, state, etc.), not CLI tooling.

While the **technical finding is valid** (the code objectively does not filter pre-releases), whether this constitutes an **exploitable vulnerability within scope** is questionable given:
- Required attack vectors are excluded
- Impact is on client machines, not core protocol
- Requires privileged repository access

The finding represents a **defense-in-depth opportunity** and **supply chain security hardening**, but may not meet the strict "exploitable by unprivileged attacker" criterion for bounty eligibility.

### Citations

**File:** crates/aptos/src/update/aptos.rs (L61-70)
```rust
        let config = ReleaseList::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .build()
            .map_err(|e| anyhow!("Failed to build configuration to fetch releases: {:#}", e))?;

        // Get the most recent releases.
        let releases = config
            .fetch()
            .map_err(|e| anyhow!("Failed to fetch releases: {:#}", e))?;
```

**File:** crates/aptos/src/update/aptos.rs (L72-84)
```rust
        // Find the latest release of the CLI, in which we filter for the CLI tag.
        // If the release isn't in the last 30 items (the default API page size)
        // this will fail. See https://github.com/aptos-labs/aptos-core/issues/6411.
        let mut releases = releases.into_iter();
        let latest_release = loop {
            let release = match releases.next() {
                Some(release) => release,
                None => return Err(anyhow!("Failed to find latest CLI release")),
            };
            if release.version.starts_with("aptos-cli-") {
                break release;
            }
        };
```

**File:** .github/workflows/cli-release.yaml (L177-177)
```yaml
          prerelease: false
```
