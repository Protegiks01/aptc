# Audit Report

## Title
Stack Overflow Vulnerability in Value Serialization When Depth Checks Are Disabled

## Summary
When the `ENABLE_FUNCTION_VALUES` feature flag is disabled through governance, the codebase enters a vulnerable state where BOTH type-based and runtime value depth checks are disabled. This allows attackers to create deeply nested values that trigger unbounded recursion during BCS serialization, causing stack overflow and validator node crashes.

## Finding Description

This vulnerability stems from a **critical design flaw** in the feature flag architecture that ties runtime depth checking to function value support.

**The Vulnerability Chain:**

When `ENABLE_FUNCTION_VALUES` is disabled via governance, `enable_depth_checks` is set to `false`: [1](#0-0) 

This causes `max_value_nest_depth()` to return `None` even though the config contains a depth limit: [2](#0-1) 

The `None` value propagates to serialization contexts where it's used to create `ValueSerDeContext`: [3](#0-2) 

When `max_value_nested_depth` is `None`, the depth check becomes a no-op: [4](#0-3) 

**Critical Architectural Flaw:**

The code comments reveal the design intent: [5](#0-4) 

The developers intended that disabling function values would fall back to type-based depth checks. However, type depth checks are ALSO disabled in production due to `propagate_dependency_limit_error = true` (when `gas_feature_version >= RELEASE_V1_38`): [6](#0-5) 

This means when `ENABLE_FUNCTION_VALUES` is disabled, the system has **NO depth protection whatsoever**.

**Exploitation Path:**

During serialization in `finish()`, values are recursively traversed: [7](#0-6) 

Depth is incremented at each recursion level: [8](#0-7) 

An attacker can:
1. Deploy a Move module that constructs deeply nested vectors (e.g., 300+ levels via loop)
2. Execute the transaction (pays gas for creation)
3. During transaction finalization in `finish()`, BCS serialization recurses unboundedly
4. Stack overflow occurs, triggering Rust panic
5. Global panic handler terminates validator process: [9](#0-8) 

The panic protection ONLY applies to verifier/deserializer contexts, NOT to serialization during transaction finalization.

## Impact Explanation

**High Severity ($50,000 category)**

This vulnerability enables **Remote Denial of Service** against validator nodes:

- **Validator Node Crashes**: Stack overflow causes process termination (exit code 12), directly meeting the "Validator node slowdowns" and "API crashes" criteria under High Severity
- **Consensus Disruption**: If multiple validators are targeted, network liveness is impacted
- **Non-Deterministic Execution**: Different stack configurations across validators could cause inconsistent crash timing
- **No Privilege Required**: Any user can deploy Move modules and submit transactions
- **Repeatable**: Low-cost attack (only gas fees) that can be executed repeatedly

## Likelihood Explanation

**Likelihood: Medium-Low**

**Current State:**
`ENABLE_FUNCTION_VALUES` is enabled by default in production: [10](#0-9) 

**Preconditions for Exploitation:**
- Requires governance to disable `ENABLE_FUNCTION_VALUES`
- This is unlikely during normal operation
- Could occur during:
  - Feature rollback due to discovered issues
  - Temporary disablement during upgrades
  - Emergency governance actions

**Key Consideration:**
While the precondition is unlikely, this represents a **latent design flaw**. The architecture incorrectly assumes that disabling function values would preserve type-based depth checks, but both protection mechanisms are disabled simultaneously. Per the validation framework: "if a vulnerability cant be triggered then its invalid, **except there is a logic vuln**" - this qualifies as a logic vulnerability in the feature flag design.

## Recommendation

Decouple depth checking from function value support:

```rust
// In prod_configs.rs
let enable_depth_checks = true; // Always enable, regardless of function values

// Or implement fallback logic:
let enable_depth_checks = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES)
    || !vm_config.propagate_dependency_limit_error; // Fall back to type checks when available
```

Additionally, ensure `TypeDepthChecker` remains enabled when function values are disabled by reconsidering the `propagate_dependency_limit_error` gating in `ty_depth_checker.rs`.

## Proof of Concept

```move
module attacker::deep_nesting {
    use std::vector;
    
    public entry fun create_deep_nesting() {
        let v = vector::empty<vector<u8>>();
        
        // Create 300 levels of nesting within gas limits
        let i = 0;
        while (i < 300) {
            let inner = vector::empty<u8>();
            vector::push_back(&mut inner, 1);
            let wrapper = vector::empty<vector<u8>>();
            vector::push_back(&mut wrapper, inner);
            v = wrapper;
            i = i + 1;
        };
        
        // Store or return the deeply nested value
        // During serialization in finish(), this will cause stack overflow
        // if ENABLE_FUNCTION_VALUES is disabled
    }
}
```

When `ENABLE_FUNCTION_VALUES` is disabled, executing this module will crash the validator during the `finish()` call's serialization phase.

## Notes

This vulnerability highlights a critical gap in the defense-in-depth strategy. The codebase currently has three potential depth protection layers:
1. Bytecode verification type depth checks (disabled via `propagate_dependency_limit_error`)
2. Runtime type depth checks (disabled via `propagate_dependency_limit_error`)
3. Runtime value depth checks (disabled when `enable_depth_checks = false`)

When function values are disabled, all three layers are bypassed, leaving the system vulnerable to stack overflow attacks. The latest gas feature version is V1_41: [11](#0-10) , which is well beyond V1_38, confirming that `propagate_dependency_limit_error` is enabled in production.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L221-226)
```rust
    // Value runtime depth checks have been introduced together with function values and are only
    // enabled when the function values are enabled. Previously, checks were performed over types
    // to bound the value depth (checking the size of a packed struct type bounds the value), but
    // this no longer applies once function values are enabled. With function values, types can be
    // shallow while the value can be deeply nested, thanks to captured arguments not visible in a
    // type. Hence, depth checks have been adjusted to operate on values.
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L227-227)
```rust
    let enable_depth_checks = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L174-186)
```rust
    pub fn max_value_nest_depth(&self) -> Option<u64> {
        self.module_storage()
            .runtime_environment()
            .vm_config()
            .enable_depth_checks
            .then(|| {
                self.module_storage()
                    .runtime_environment()
                    .vm_config()
                    .max_value_nest_depth
            })
            .flatten()
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L181-193)
```rust
                ValueSerDeContext::new(function_extension.max_value_nest_depth())
                    .with_delayed_fields_serde()
                    .with_func_args_deserialization(&function_extension)
                    .serialize(&value, &layout)?
                    .map(|bytes| (bytes.into(), Some(layout)))
            } else {
                // Otherwise, there should be no native values so ensure
                // serialization fails here if there are any.
                ValueSerDeContext::new(function_extension.max_value_nest_depth())
                    .with_func_args_deserialization(&function_extension)
                    .serialize(&value, &layout)?
                    .map(|bytes| (bytes.into(), None))
            };
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L149-157)
```rust
    pub(crate) fn check_depth(&self, depth: u64) -> PartialVMResult<()> {
        if self
            .max_value_nested_depth
            .is_some_and(|max_depth| depth > max_depth)
        {
            return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L57-61)
```rust
        let maybe_max_depth = if vm_config.propagate_dependency_limit_error {
            None
        } else {
            vm_config.max_value_nest_depth
        };
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4838-4838)
```rust
        self.ctx.check_depth(self.depth).map_err(S::Error::custom)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4906-4906)
```rust
                                depth: self.depth + 1,
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** types/src/on_chain_config/aptos_features.rs (L258-258)
```rust
            FeatureFlag::ENABLE_FUNCTION_VALUES,
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L76-76)
```rust
pub const LATEST_GAS_FEATURE_VERSION: u64 = gas_feature_versions::RELEASE_V1_41;
```
