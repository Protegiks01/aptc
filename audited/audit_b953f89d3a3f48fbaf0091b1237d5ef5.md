# Audit Report

## Title
Fast Path Randomness Configuration Accepts Invalid Thresholds Violating Cryptographic Invariants

## Summary
The randomness configuration system lacks validation for `fast_path_secrecy_threshold` values, allowing governance proposals to set thresholds exceeding 1.0 (100%). This violates fundamental threshold cryptography invariants and renders the fast path randomness feature unusable, forcing all randomness generation through the slow path.

## Finding Description

**Vulnerability Flow:**

The Move-side `randomness_config::new_v2` function accepts arbitrary `FixedPoint64` values for `fast_path_secrecy_threshold` without validation: [1](#0-0) 

The function directly packs values into the config without checking if they represent valid threshold ratios (must be in [0, 1] range). When a governance proposal calls this with `create_from_rational(200, 100)`, it creates a FixedPoint64 representing 2.0 (200%). [2](#0-1) 

The Rust unpacking code similarly lacks validation when deserializing the on-chain config: [3](#0-2) 

**Critical Failure in DKG Rounding:**

When this invalid threshold reaches the DKG rounding logic, the `infallible` fallback method clamps the main thresholds but **not** the fast path threshold: [4](#0-3) 

Notice lines 261-262 clamp `secrecy_threshold` and `reconstruct_threshold` to maximum 1.0, but `fast_secrecy_threshold_in_stake_ratio` at line 258 and 280 is passed through unclamped to `compute_profile_fixed_point`.

This results in computing an invalid fast path configuration where: [5](#0-4) 

With `fast_secrecy_threshold_in_stake_ratio = 2.0`, line 339 computes `recon_threshold = 2.0 + stake_gap_fixed > 1.0`, which violates the cryptographic invariant that reconstruction thresholds must be ≤ 1.0.

While validation exists for the binary search path, it's bypassed when falling back to the `infallible` method: [6](#0-5) 

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria:

1. **Significant Protocol Violation**: Violates Cryptographic Correctness invariant (#10). Threshold cryptography fundamentally requires thresholds in the [0, 1] range. A threshold > 1.0 means requiring > 100% of stake to reconstruct, which is mathematically impossible.

2. **Denial of Service on Fast Path Randomness**: The fast path becomes permanently unusable. Any attempt to use it would fail because no validator subset can meet a > 100% stake requirement. The system must fall back to the slow path for all randomness generation.

3. **Performance Degradation**: Forces all randomness operations through the slower reconstruction path, impacting validator performance and transaction throughput for randomness-dependent operations.

4. **Network-Wide Impact**: All validators receive the invalid configuration during epoch transitions, affecting the entire network's randomness generation capability.

## Likelihood Explanation

**Medium-High Likelihood:**

- **Attack Requirements**: Only requires governance approval, which is the standard mechanism for configuration changes. No special validator access needed.

- **Feasibility**: Simple to execute - a governance proposal with a single parameter `fast_path_secrecy_threshold_in_percentage: 200` (or any value > 100).

- **Detection Difficulty**: The configuration appears to succeed (no panic/revert), making the attack subtle. The impact only manifests when the fast path is attempted.

- **Persistence**: Once deployed via epoch change, the invalid configuration persists until fixed by another governance action.

## Recommendation

**Immediate Fix Required:**

Add validation in the Move-side `new_v2` function to ensure thresholds are in valid range:

```move
public fun new_v2(
    secrecy_threshold: FixedPoint64,
    reconstruction_threshold: FixedPoint64,
    fast_path_secrecy_threshold: FixedPoint64,
): RandomnessConfig {
    // Validate all thresholds are in [0, 1] range
    let one = fixed_point64::create_from_u128(1);
    assert!(
        fixed_point64::less_or_equal(fast_path_secrecy_threshold, one),
        EINVALID_THRESHOLD
    );
    assert!(
        fixed_point64::less_or_equal(secrecy_threshold, one),
        EINVALID_THRESHOLD
    );
    assert!(
        fixed_point64::less_or_equal(reconstruction_threshold, one),
        EINVALID_THRESHOLD
    );
    
    RandomnessConfig {
        variant: copyable_any::pack( ConfigV2 {
            secrecy_threshold,
            reconstruction_threshold,
            fast_path_secrecy_threshold,
        } )
    }
}
```

**Additional Defense-in-Depth:**

Add clamping in the `infallible` method (line 258 in rounding/mod.rs):

```rust
pub fn infallible(
    validator_stakes: &Vec<u64>,
    mut secrecy_threshold_in_stake_ratio: U64F64,
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
) -> Self {
    let one = U64F64::from_num(1);
    secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
    reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
    
    // ADD THIS: Clamp fast path threshold as well
    let fast_secrecy_threshold_in_stake_ratio = 
        fast_secrecy_threshold_in_stake_ratio.map(|t| min(one, t));
    
    // ... rest of function
}
```

## Proof of Concept

**Move Script to Demonstrate Vulnerability:**

```move
script {
    use aptos_framework::randomness_config;
    use aptos_std::fixed_point64;
    use aptos_framework::aptos_governance;
    
    fun exploit_invalid_threshold(framework: &signer) {
        // Create config with fast_path_secrecy_threshold = 200% (2.0)
        let invalid_config = randomness_config::new_v2(
            fixed_point64::create_from_rational(50, 100),   // 0.5 - valid
            fixed_point64::create_from_rational(67, 100),   // 0.67 - valid
            fixed_point64::create_from_rational(200, 100),  // 2.0 - INVALID!
        );
        
        // This succeeds without validation
        randomness_config::set_for_next_epoch(framework, invalid_config);
        
        // On epoch change, all validators receive invalid config
        aptos_governance::reconfigure(framework);
    }
}
```

**Rust Reproduction Steps:**

1. Deploy governance proposal with `fast_path_secrecy_threshold_in_percentage: 200`
2. Execute via `aptos_governance::get_signer_testnet_only` → `randomness_config::set_for_next_epoch`
3. Trigger epoch change
4. Observe in DKG logs: `DKGRounding` falls back to `infallible` method
5. Resulting config has `fast_reconstruct_threshold_in_stake_ratio > 1.0`
6. Fast path reconstruction always fails (requires impossible > 100% stake)

**Expected Behavior:** Move validation should reject the transaction with an abort.

**Actual Behavior:** Transaction succeeds, deploying cryptographically invalid configuration network-wide.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L103-115)
```text
    public fun new_v2(
        secrecy_threshold: FixedPoint64,
        reconstruction_threshold: FixedPoint64,
        fast_path_secrecy_threshold: FixedPoint64,
    ): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV2 {
                secrecy_threshold,
                reconstruction_threshold,
                fast_path_secrecy_threshold,
            } )
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/fixed_point64.move (L129-141)
```text
    public fun create_from_rational(numerator: u128, denominator: u128): FixedPoint64 {
        // If the denominator is zero, this will abort.
        // Scale the numerator to have 64 fractional bits, so that the quotient will have 64
        // fractional bits.
        let scaled_numerator = (numerator as u256) << 64;
        assert!(denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / (denominator as u256);
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        // Return the quotient as a fixed-point number. We first need to check whether the cast
        // can succeed.
        assert!(quotient <= MAX_U128, ERATIO_OUT_OF_RANGE);
        FixedPoint64 { value: (quotient as u128) }
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L167-170)
```rust
            ConfigV2::MOVE_TYPE_NAME => {
                let v2 = MoveAny::unpack(ConfigV2::MOVE_TYPE_NAME, variant)
                    .map_err(|e| anyhow!("unpack as v2 failed: {e}"))?;
                Ok(OnChainRandomnessConfig::V2(v2))
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L285-293)
```rust
fn is_valid_profile(
    profile: &DKGRoundingProfile,
    reconstruct_threshold_in_stake_ratio: U64F64,
) -> bool {
    // ensure the reconstruction is below threshold, and the fast path threshold is valid
    profile.reconstruct_threshold_in_stake_ratio <= reconstruct_threshold_in_stake_ratio
        && (profile.fast_reconstruct_threshold_in_stake_ratio.is_none()
            || profile.fast_reconstruct_threshold_in_stake_ratio.unwrap() <= U64F64::from_num(1))
}
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L335-351)
```rust
    let (fast_reconstruct_threshold_in_stake_ratio, fast_reconstruct_threshold_in_weights) =
        if let Some(fast_secrecy_threshold_in_stake_ratio) =
            maybe_fast_secrecy_threshold_in_stake_ratio
        {
            let recon_threshold = fast_secrecy_threshold_in_stake_ratio + stake_gap_fixed;
            let recon_weight = min(
                weight_total,
                ((fast_secrecy_threshold_in_stake_ratio * stake_sum_fixed / stake_per_weight
                    + delta_up_fixed)
                    .ceil()
                    + one)
                    .to_num::<u64>(),
            );
            (Some(recon_threshold), Some(recon_weight))
        } else {
            (None, None)
        };
```
