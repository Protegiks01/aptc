# Audit Report

## Title
Validator Node Crash Due to Panic in ValidatorSet Deserialization During Discovery Update

## Summary
The network discovery process uses `.expect()` when deserializing the `ValidatorSet` on-chain configuration, causing the entire validator node to crash (via global panic handler) if the payload is malformed or missing. This violates the documented design expectation that "reconfig subscribers must be able to handle on-chain configs not existing."

## Finding Description

The vulnerability exists in the `extract_updates()` function where ValidatorSet extraction uses `.expect()` instead of proper error handling: [1](#0-0) 

When a reconfiguration notification arrives, the payload's `get()` method can fail in two scenarios:
1. ValidatorSet config not found in the database
2. BCS deserialization fails on corrupted bytes [2](#0-1) 

The explicit design documentation states that configs may not exist: [3](#0-2) 

However, ValidatorSet extraction violates this principle by using `.expect()`, while other configs use proper error handling with defaults: [4](#0-3) [5](#0-4) 

When the panic occurs, it triggers the global panic handler which terminates the entire node process: [6](#0-5) [7](#0-6) 

## Impact Explanation

**High Severity**: Entire validator node crash affecting network availability. This exceeds the "Validator node slowdowns" category in the Aptos Bug Bounty High Severity classification. The crash impacts:
- Loss of consensus participation
- Network degradation if multiple validators affected
- Requires manual operator intervention to restart

This is NOT directly exploitable via network messages but represents a critical robustness failure where database corruption or state-sync bugs can cause cascading validator failures.

## Likelihood Explanation

**Low-to-Medium Likelihood**:
- **Low** under normal operation (ValidatorSet exists after genesis)
- **Medium** during exceptional circumstances:
  - Database corruption from disk failures
  - Software bugs in state-sync writing malformed data
  - Consensus bugs committing invalid state
  - Memory corruption scenarios

The same pattern exists in multiple critical components (consensus, DKG), amplifying the risk surface.

## Recommendation

Replace `.expect()` with proper error handling matching other on-chain configs:

```rust
fn extract_updates(&mut self, payload: OnChainConfigPayload<P>) -> Result<PeerSet, DiscoveryError> {
    let _process_timer = EVENT_PROCESSING_LOOP_BUSY_DURATION_S.start_timer();

    let node_set: ValidatorSet = match payload.get() {
        Ok(set) => set,
        Err(e) => {
            warn!(
                NetworkSchema::new(&self.network_context),
                "Failed to get ValidatorSet from payload: {:?}", e
            );
            // Return empty peer set or use cached validator set
            return Err(DiscoveryError::Parsing(format!("ValidatorSet unavailable: {}", e)));
        }
    };

    // ... rest of function
}
```

Update the call site to handle the Result type appropriately.

## Proof of Concept

**Scenario**: Database corruption during epoch transition

```rust
// Test demonstrating panic path (would need database corruption simulation)
#[test]
#[should_panic(expected = "failed to get ValidatorSet from payload")]
fn test_malformed_validator_set_panics() {
    // Setup: Create OnChainConfigPayload with missing ValidatorSet
    let configs = HashMap::new(); // Empty - no ValidatorSet
    let payload = OnChainConfigPayload::new(1, InMemoryOnChainConfig::new(configs));
    
    // This will panic with .expect()
    let _validator_set: ValidatorSet = payload.get().expect("failed to get ValidatorSet from payload");
}
```

**Impact demonstration**: In production, this would trigger:
1. Panic in discovery task
2. Global panic handler activation  
3. Node process exit with code 12
4. Validator offline until manual restart

## Notes

This vulnerability fails the **exploitability** requirement for direct remote attacks - it requires pre-existing database corruption or a separate bug in state management. However, it represents a significant **defense-in-depth failure** where:

1. The codebase explicitly documents that configs may not exist
2. Other configs implement proper error handling 
3. ValidatorSet extraction uses panic-inducing `.expect()` across multiple components
4. The impact is amplified by the global panic handler causing full node crashes

This is a **robustness/availability issue** rather than a directly exploitable vulnerability, but warrants fixing given the critical nature of validator stability and the documented design expectations for graceful config handling.

### Citations

**File:** network/discovery/src/validator_set.rs (L68-73)
```rust
    fn extract_updates(&mut self, payload: OnChainConfigPayload<P>) -> PeerSet {
        let _process_timer = EVENT_PROCESSING_LOOP_BUSY_DURATION_S.start_timer();

        let node_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L277-280)
```rust
    /// Fetches the configs on-chain at the specified version.
    /// Note: We cannot assume that all configs will exist on-chain. As such, we
    /// must fetch each resource one at a time. Reconfig subscribers must be able
    /// to handle on-chain configs not existing in a reconfiguration notification.
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L398-412)
```rust
    fn get<T: OnChainConfig>(&self) -> Result<T> {
        let bytes = self
            .reader
            .get_state_value_by_version(&StateKey::on_chain_config::<T>()?, self.version)?
            .ok_or_else(|| {
                anyhow!(
                    "no config {} found in aptos root account state",
                    T::CONFIG_ID
                )
            })?
            .bytes()
            .clone();

        T::deserialize_into_config(&bytes)
    }
```

**File:** consensus/src/epoch_manager.rs (L1165-1167)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
```

**File:** consensus/src/epoch_manager.rs (L1178-1203)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** crates/crash-handler/src/lib.rs (L26-57)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```
