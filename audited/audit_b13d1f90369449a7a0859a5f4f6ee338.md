# Audit Report

## Title
Indexer GRPC Fullnode Service Panic on Pruned Version Request Leading to Service Disruption

## Summary
The `get_transactions_from_node()` function in the indexer-grpc fullnode service does not validate whether the requested `starting_version` is within the pruned range before attempting to fetch transactions. When a client requests a pruned version, the service panics instead of returning a graceful error, causing the connection to terminate abruptly and potentially enabling denial-of-service attacks.

## Finding Description

The vulnerability exists in the request handling flow of the indexer-grpc fullnode data service. When a client sends a `GetTransactionsFromNodeRequest` with a `starting_version` that points to a pruned ledger version, the following sequence occurs:

1. The `get_transactions_from_node()` function accepts the `starting_version` without validation against the minimum readable version (pruning window). [1](#0-0) 

2. An `IndexerStreamCoordinator` is created with this unvalidated starting version. [2](#0-1) 

3. When the coordinator attempts to process transactions via `process_next_batch()`, it calls `fetch_transactions_from_storage()` which spawns tasks to fetch transaction batches. [3](#0-2) 

4. Each task calls `fetch_raw_txns_with_retries()` which invokes `context.get_transactions()` to retrieve transactions from the database. [4](#0-3) 

5. The database layer's `get_transactions()` method checks if the requested version is pruned using `error_if_ledger_pruned()`. [5](#0-4) 

6. The `error_if_ledger_pruned()` function returns an error if the version is below the minimum readable version maintained by the ledger pruner. [6](#0-5) 

7. Back in `fetch_raw_txns_with_retries()`, when the error is encountered, the function retries 3 times with delays, then **panics** with an unrecoverable error. [7](#0-6) 

8. This panic propagates through `try_join_all`, causing another panic in `fetch_transactions_from_storage()`. [8](#0-7) 

Additionally, even if transaction fetching somehow succeeded, subsequent calls to `get_block_info_by_version()` would also fail for pruned versions, causing more panics. [9](#0-8) 

The database provides a `get_first_txn_version()` method that returns the minimum readable version, which could be used for validation but is not utilized. [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category:

1. **Service Availability Impact**: Any unauthenticated client can cause the indexer-grpc fullnode service to panic by requesting pruned versions. While tokio tasks don't crash the entire process, they terminate the connection abruptly, disrupting service for legitimate clients.

2. **Denial of Service Potential**: An attacker can repeatedly send requests with pruned versions to cause continuous service disruptions, degrading the availability of the indexer infrastructure.

3. **Operational Impact**: Fullnode operators running pruned nodes (a common production configuration) are particularly vulnerable, as any client requesting historical data beyond the pruning window will trigger this panic.

4. **Poor Error Handling**: Instead of returning a proper GRPC error status (e.g., `Status::out_of_range` or `Status::unavailable`), the service crashes the connection, preventing clients from handling the error gracefully.

## Likelihood Explanation

**Likelihood: High**

1. **Easy Exploitation**: Any client can trigger this vulnerability by sending a single GRPC request with `starting_version` set to a value below the minimum readable version (e.g., version 0 on a pruned node).

2. **Common Scenario**: Ledger pruning is a standard practice in production environments to manage storage costs. Most fullnodes prune old transaction data, making this vulnerability exploitable in typical deployments.

3. **No Authentication Required**: The GRPC endpoint is accessible to any client without authentication or rate limiting at the application level.

4. **Minimal Attack Complexity**: The attacker only needs to:
   - Determine that the node has pruned data (query current ledger version and assume pruning)
   - Send a `GetTransactionsFromNodeRequest` with a low `starting_version`
   - Repeat to cause sustained disruption

## Recommendation

Implement input validation to check if the requested `starting_version` is within the readable range before processing:

```rust
async fn get_transactions_from_node(
    &self,
    req: Request<GetTransactionsFromNodeRequest>,
) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
    let r = req.into_inner();
    let starting_version = match r.starting_version {
        Some(version) => version,
        None => return Err(Status::invalid_argument("Starting version must be set")),
    };
    
    // Validate that starting_version is not pruned
    let min_readable_version = match self.service_context.context.db.get_first_txn_version() {
        Ok(Some(min_version)) => min_version,
        Ok(None) => 0, // No pruning
        Err(e) => return Err(Status::internal(format!("Failed to get min readable version: {}", e))),
    };
    
    if starting_version < min_readable_version {
        return Err(Status::out_of_range(format!(
            "Requested starting_version {} is pruned. Minimum available version is {}",
            starting_version, min_readable_version
        )));
    }
    
    // Continue with existing logic...
}
```

Additionally, replace panic calls with proper error propagation in `fetch_raw_txns_with_retries()` and `process_next_batch()` to handle database errors gracefully.

## Proof of Concept

**Setup:**
1. Start an Aptos fullnode with pruning enabled (e.g., `ledger_prune_window=100000`)
2. Let the node sync and prune old ledger data

**Attack Steps:**
```rust
// Client code to trigger the vulnerability
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_client::FullnodeDataClient,
    GetTransactionsFromNodeRequest,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = FullnodeDataClient::connect("http://[fullnode-ip]:50051").await?;
    
    // Request transactions from version 0 (which will be pruned on any active node)
    let request = Request::new(GetTransactionsFromNodeRequest {
        starting_version: Some(0), // Pruned version
        transactions_count: Some(100),
    });
    
    // This will cause the server to panic instead of returning an error
    let response = client.get_transactions_from_node(request).await;
    
    match response {
        Ok(_) => println!("Unexpected success"),
        Err(e) => println!("Error (expected): {:?}", e), // Connection will be abruptly closed
    }
    
    Ok(())
}
```

**Expected Behavior:** Server returns `Status::out_of_range` with a clear error message

**Actual Behavior:** Server panics with "Could not fetch transactions after retries", terminating the connection and logging panic messages

## Notes

This vulnerability affects the indexer-grpc fullnode service specifically and does not impact consensus or core blockchain functionality. However, it represents a significant availability issue for infrastructure components that rely on the indexer GRPC interface. The fix should include both input validation at the API boundary and replacing panic-based error handling with proper error propagation throughout the transaction fetching pipeline.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L73-78)
```rust
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L103-117)
```rust
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L101-108)
```rust
    pub async fn process_next_batch(&mut self) -> Vec<Result<EndVersion, Status>> {
        let fetching_start_time = std::time::Instant::now();
        // Stage 1: fetch transactions from storage.
        let sorted_transactions_from_storage_with_size =
            self.fetch_transactions_from_storage().await;
        if sorted_transactions_from_storage_with_size.is_empty() {
            return vec![];
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L119-128)
```rust
        let (_, _, block_event) = self
            .context
            .db
            .get_block_info_by_version(end_version as u64)
            .unwrap_or_else(|_| {
                panic!(
                    "[Indexer Fullnode] Could not get block_info for version {}",
                    end_version,
                )
            });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L253-261)
```rust

        let transactions_from_storage =
            match futures::future::try_join_all(storage_fetch_tasks).await {
                Ok(res) => res,
                Err(err) => panic!(
                    "[Indexer Fullnode] Error fetching transaction batches: {:?}",
                    err
                ),
            };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L320-332)
```rust
    pub async fn fetch_raw_txns_with_retries(
        context: Arc<Context>,
        ledger_version: u64,
        batch: TransactionBatchInfo,
    ) -> Vec<TransactionOnChainData> {
        let mut retries = 0;
        loop {
            match context.get_transactions(
                batch.start_version,
                batch.num_transactions_to_fetch,
                ledger_version,
            ) {
                Ok(raw_txns) => return raw_txns,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L333-347)
```rust
                Err(err) => {
                    UNABLE_TO_FETCH_TRANSACTION.inc();
                    retries += 1;

                    if retries >= DEFAULT_NUM_RETRIES {
                        error!(
                            starting_version = batch.start_version,
                            num_transactions = batch.num_transactions_to_fetch,
                            error = format!("{:?}", err),
                            "Could not fetch transactions: retries exhausted",
                        );
                        panic!(
                            "Could not fetch {} transactions after {} retries, starting at {}: {:?}",
                            batch.num_transactions_to_fetch, retries, batch.start_version, err
                        );
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L267-280)
```rust
    fn get_transactions(
        &self,
        start_version: Version,
        limit: u64,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<TransactionListWithProofV2> {
        gauged_api("get_transactions", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;

            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionListWithProofV2::new_empty());
            }
            self.error_if_ledger_pruned("Transaction", start_version)?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L329-333)
```rust
    fn get_first_txn_version(&self) -> Result<Option<Version>> {
        gauged_api("get_first_txn_version", || {
            Ok(Some(self.ledger_pruner.get_min_readable_version()))
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```
