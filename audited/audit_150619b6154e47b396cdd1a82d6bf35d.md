# Audit Report

## Title
Information Disclosure via Debug Formatting in Rosetta API Rejection Handler

## Summary
The `handle_rejection()` function in the Aptos Rosetta API exposes internal error details through debug formatting, allowing attackers to probe the API structure and gather information about system architecture through deliberate malformed requests.

## Finding Description
The Aptos Rosetta API uses the warp web framework for HTTP request handling. When requests fail validation at the framework level (wrong HTTP method, malformed JSON, missing required fields), warp generates `Rejection` objects that contain internal implementation details. [1](#0-0) 

The vulnerability occurs because the rejection handler uses `{:?}` debug formatting to directly expose the warp `Rejection` type in error responses returned to clients. This leaks:

1. **Expected request structure**: When JSON deserialization fails, the error reveals expected field names, types, and validation requirements
2. **Routing information**: Path matching failures expose internal route structure
3. **HTTP method restrictions**: MethodNotAllowed rejections reveal which methods are accepted
4. **Content-type requirements**: Unsupported media type errors expose expected content types

**Attack Path:**
1. Attacker sends requests with deliberately malformed payloads to Rosetta endpoints like `/account/balance`, `/network/status`, or `/construction/*`
2. Warp framework generates typed rejections (e.g., `BodyDeserializeError`, `MethodNotAllowed`, `MissingHeader`)
3. `handle_rejection()` formats the rejection with `{:?}` and includes it in the JSON error response
4. Attacker receives detailed internal error information including struct names, field requirements, and validation logic
5. This information aids in mapping the complete API surface and understanding internal architecture

For example, sending a POST request with invalid JSON to `/account/balance` will expose the expected structure of `AccountBalanceRequest`, including all required fields and their types. [2](#0-1) 

The routes use `warp::body::json()` which will generate detailed deserialization errors: [3](#0-2) 

## Impact Explanation
This is a **Low Severity** information disclosure vulnerability per Aptos bug bounty criteria, specifically falling under "Minor information leaks."

The vulnerability does NOT:
- Compromise funds, consensus, or network availability
- Enable direct exploitation of critical systems
- Expose sensitive data like private keys or account balances
- Allow unauthorized state modifications
- Break any consensus or execution invariants

It DOES:
- Aid attacker reconnaissance by revealing API structure
- Expose implementation details that should remain opaque
- Violate the principle of least information disclosure
- Provide detailed error messages useful for crafting targeted attacks

This information disclosure does not directly threaten the blockchain's core security properties but reduces the security margin by making it easier for attackers to understand the system's attack surface.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is trivially exploitable by any attacker with network access to the Rosetta API:
- No authentication or special permissions required
- Attack requires only basic HTTP client (curl, browser, etc.)
- Can be executed repeatedly to probe different endpoints
- Works against any publicly exposed Rosetta API endpoint
- No rate limiting prevents information gathering

The Rosetta API is typically exposed to external clients (wallets, exchanges, analytics platforms), making this a realistic attack vector. Any security researcher or malicious actor can trigger these detailed error messages within minutes.

## Recommendation
Replace the debug formatting with a generic error message that does not expose internal implementation details:

```rust
async fn handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {
    debug!("Failed with: {:?}", err);
    
    // Map common rejections to user-friendly messages
    let (status_code, message) = if err.is_not_found() {
        (StatusCode::NOT_FOUND, "Endpoint not found")
    } else if err.find::<warp::filters::body::BodyDeserializeError>().is_some() {
        (StatusCode::BAD_REQUEST, "Invalid request body")
    } else if err.find::<warp::reject::MethodNotAllowed>().is_some() {
        (StatusCode::METHOD_NOT_ALLOWED, "Method not allowed")
    } else {
        (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error")
    };
    
    let body = reply::json(&Error::new(status_code, message.to_string()));
    let mut rep = reply::with_status(body, status_code).into_response();
    rep.headers_mut()
        .insert("access-control-allow-origin", HeaderValue::from_static("*"));
    Ok(rep)
}
```

This approach:
- Logs full error details internally for debugging (preserves `debug!()` call)
- Returns only generic, safe error messages to clients
- Maintains appropriate HTTP status codes
- Prevents information leakage while remaining usable

## Proof of Concept

```bash
# Test 1: Trigger deserialization error to expose AccountBalanceRequest structure
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d '{"invalid": "data"}'

# Expected current behavior (vulnerable):
# Response will contain detailed error like:
# "unexpected error: BodyDeserializeError { cause: Error(\"missing field `network_identifier`\", line: 1, column: 18) }"
# This exposes that AccountBalanceRequest requires a "network_identifier" field

# Test 2: Trigger method not allowed error
curl -X GET http://localhost:8080/account/balance

# Expected current behavior (vulnerable):
# Response will expose which methods are actually allowed (e.g., POST)

# Test 3: Probe with completely malformed JSON
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d 'not json at all'

# Expected current behavior (vulnerable):
# Response will contain JSON parsing error details exposing parser implementation
```

**Verification Steps:**
1. Deploy Aptos Rosetta API locally or against testnet
2. Send malformed requests to various endpoints
3. Observe detailed error messages in responses containing internal type information
4. Compare with recommended fix which returns only generic messages
5. Confirm that internal details are logged but not exposed to clients

## Notes

**Scope Context:**
- This vulnerability is limited to the Rosetta API component
- Does NOT affect core consensus, Move VM, or state management
- Does NOT impact validator operations or blockchain security
- Rosetta API is a read-mostly interface for external integrations
- The underlying blockchain remains secure regardless of this disclosure

**Defense in Depth:**
While Low severity, fixing this issue follows security best practices by:
- Reducing information available to potential attackers
- Making API behavior consistent with other production systems
- Implementing proper error handling hygiene
- Following principle of least privilege for information disclosure

### Citations

**File:** crates/aptos-rosetta/src/lib.rs (L192-202)
```rust
async fn handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {
    debug!("Failed with: {:?}", err);
    let body = reply::json(&Error::new(
        StatusCode::INTERNAL_SERVER_ERROR,
        format!("unexpected error: {:?}", err),
    ));
    let mut rep = reply::with_status(body, StatusCode::INTERNAL_SERVER_ERROR).into_response();
    rep.headers_mut()
        .insert("access-control-allow-origin", HeaderValue::from_static("*"));
    Ok(rep)
}
```

**File:** crates/aptos-rosetta/src/account.rs (L38-44)
```rust
    warp::post().and(
        warp::path!("account" / "balance")
            .and(warp::body::json())
            .and(with_context(server_context))
            .and_then(handle_request(account_balance)),
    )
}
```

**File:** crates/aptos-rosetta/src/account.rs (L49-52)
```rust
async fn account_balance(
    request: AccountBalanceRequest,
    server_context: RosettaContext,
) -> ApiResult<AccountBalanceResponse> {
```
