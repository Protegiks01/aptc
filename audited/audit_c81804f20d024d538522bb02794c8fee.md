# Audit Report

## Title
Event Store Pruner State Inconsistency Leading to API Failures Due to Configuration Mismatch

## Summary
The EventStorePruner fails to prune event indices from the internal indexer database when `internal_indexer_db` is present but `event_enabled()` is false. This creates stale indices pointing to pruned events, causing API crashes when event indexing is later re-enabled and queries attempt to fetch non-existent events.

## Finding Description
The vulnerability exists in the pruning logic where event indices are conditionally deleted based on the `event_enabled()` configuration flag. When a node operator has an internal indexer database configured but disables event indexing, the pruner enters an inconsistent state.

At lines 47-54, the code determines where to store index deletion operations: [1](#0-0) 

When `internal_indexer_db` is Some but `event_enabled()` returns false, `indexer_batch` remains None, causing `indices_batch` to also be None. This None value is passed to `prune_event_indices`: [2](#0-1) 

The `prune_event_indices` function accepts `Option<&mut SchemaBatch>` and only deletes indices when the batch is Some: [3](#0-2) 

At lines 206-217, when `indices_batch` is None, the deletion loop is skipped entirely, leaving stale indices in the indexer database even though the actual events are pruned from the ledger database at lines 60-65.

**Attack Scenario:**
1. Node operator configures `internal_indexer_db` with `enable_event = true`
2. Events and indices accumulate normally (versions 1-1000)
3. Operator changes configuration to `enable_event = false`
4. Pruning runs, deleting events from ledger_db but NOT indices from indexer_db
5. Stale indices remain for versions 1-500 after pruning
6. Operator later changes configuration back to `enable_event = true`
7. User queries events via the indexer API
8. The query path finds stale indices and attempts to fetch events: [4](#0-3) 

9. The `get_event_by_version_and_index` call fails with NotFound error: [5](#0-4) 

10. API call crashes, breaking event querying functionality

This violates the **State Consistency** invariant: "State transitions must be atomic and verifiable." The indexer database and ledger database are in an inconsistent state where indices exist for pruned events.

## Impact Explanation
This issue qualifies as **High Severity** under the Aptos bug bounty criteria for "API crashes." When event indexing is re-enabled after being disabled, all event queries that fall within the range of stale indices will fail with NotFound errors, effectively breaking the event querying API. This affects:

- Full nodes providing indexer services
- API endpoints relying on event queries
- Applications and wallets depending on event data
- Any service using the internal indexer for event retrieval

The impact is immediate and deterministic once the configuration toggle sequence occurs, causing complete API failure for affected event ranges.

## Likelihood Explanation
The likelihood is **Medium**. This requires a specific configuration change sequence:
1. Operator must have internal_indexer_db configured
2. Operator must toggle event_enabled from true → false → true
3. Pruning must occur while event_enabled is false

This is not a malicious attack but an operational scenario that node operators may encounter when:
- Testing different indexer configurations
- Optimizing resource usage by temporarily disabling features
- Troubleshooting indexer-related issues
- Migrating between indexer configurations

Once the configuration sequence occurs, the issue is guaranteed to manifest, making it a deterministic bug rather than a race condition or timing-dependent issue.

## Recommendation
The pruner must handle event indices consistently regardless of the `event_enabled()` flag when `internal_indexer_db` is present. Modified logic at lines 47-54:

```rust
let indices_batch = if let Some(indexer_db) = self.indexer_db() {
    // Always prune indices from indexer_db when it exists, regardless of event_enabled()
    // This prevents stale indices from accumulating
    indexer_batch = Some(SchemaBatch::new());
    indexer_batch.as_mut()
} else {
    Some(&mut batch)
};
```

Additionally, at lines 71-79, always update the progress metadata when indexer_db exists:

```rust
if let Some(mut indexer_batch) = indexer_batch {
    indexer_batch.put::<InternalIndexerMetadataSchema>(
        &IndexerMetadataKey::EventPrunerProgress,
        &IndexerMetadataValue::Version(target_version),
    )?;
    self.expect_indexer_db()
        .get_inner_db_ref()
        .write_schemas(indexer_batch)?;
}
```

Alternative approach: Add validation during pruner initialization to detect and warn about configuration mismatches, or automatically clean up stale indices when event indexing is re-enabled.

## Proof of Concept
```rust
// Test demonstrating the vulnerability
#[test]
fn test_event_pruner_indexer_mismatch() {
    // Setup: Create ledger_db and internal_indexer_db
    let ledger_db = create_test_ledger_db();
    let indexer_db = create_test_indexer_db();
    
    // Step 1: Enable event indexing and write events
    let config = InternalIndexerDBConfig {
        enable_event: true,
        ..Default::default()
    };
    let internal_indexer = InternalIndexerDB::new(indexer_db.clone(), config);
    
    // Write events at versions 100-200
    write_test_events(&ledger_db, &internal_indexer, 100, 200);
    
    // Verify indices exist in indexer_db
    assert!(indexer_has_event_indices(&indexer_db, 100, 200));
    
    // Step 2: Disable event indexing
    let config_disabled = InternalIndexerDBConfig {
        enable_event: false,
        ..Default::default()
    };
    let internal_indexer_disabled = InternalIndexerDB::new(indexer_db.clone(), config_disabled);
    
    // Step 3: Run pruner with event indexing disabled
    let pruner = EventStorePruner::new(
        ledger_db.clone(),
        200,
        Some(internal_indexer_disabled),
    ).unwrap();
    
    pruner.prune(100, 150).unwrap();
    
    // Step 4: Verify events are pruned but indices remain (BUG!)
    assert!(!ledger_db_has_events(100, 150)); // Events gone
    assert!(indexer_has_event_indices(&indexer_db, 100, 150)); // Indices remain (stale!)
    
    // Step 5: Re-enable event indexing
    let internal_indexer_reenabled = InternalIndexerDB::new(indexer_db.clone(), config);
    let db_indexer = DBIndexer::new(internal_indexer_reenabled, ledger_db.clone());
    
    // Step 6: Query events - this will FAIL
    let event_key = test_event_key();
    let result = db_indexer.get_events(&event_key, 0, Order::Ascending, 100, 200);
    
    // Expected: NotFound error when trying to fetch pruned events using stale indices
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err().downcast_ref::<AptosDbError>(), 
                     Some(AptosDbError::NotFound(_))));
}
```

This test demonstrates that stale indices cause API failures when event indexing is re-enabled after being disabled during pruning operations.

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs (L47-54)
```rust
        let indices_batch = if let Some(indexer_db) = self.indexer_db() {
            if indexer_db.event_enabled() {
                indexer_batch = Some(SchemaBatch::new());
            }
            indexer_batch.as_mut()
        } else {
            Some(&mut batch)
        };
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs (L55-59)
```rust
        let num_events_per_version = self.ledger_db.event_db().prune_event_indices(
            current_progress,
            target_version,
            indices_batch,
        )?;
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L192-222)
```rust
    pub(crate) fn prune_event_indices(
        &self,
        start: Version,
        end: Version,
        mut indices_batch: Option<&mut SchemaBatch>,
    ) -> Result<Vec<usize>> {
        let mut ret = Vec::new();

        let mut current_version = start;

        for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
            let events = events?;
            ret.push(events.len());

            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
            current_version += 1;
        }

        Ok(ret)
    }
```

**File:** storage/indexer/src/db_indexer.rs (L692-704)
```rust
        let mut events_with_version = event_indices
            .into_iter()
            .map(|(seq, ver, idx)| {
                let event = match self
                    .main_db_reader
                    .get_event_by_version_and_index(ver, idx)?
                {
                    event @ ContractEvent::V1(_) => event,
                    ContractEvent::V2(_) => ContractEvent::V1(
                        self.indexer_db
                            .get_translated_v1_event_by_version_and_index(ver, idx)?,
                    ),
                };
```

**File:** storage/aptosdb/src/event_store/mod.rs (L42-50)
```rust
    pub fn get_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEvent> {
        self.event_db
            .get::<EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```
