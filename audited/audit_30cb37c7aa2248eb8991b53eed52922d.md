# Audit Report

## Title
Verifier-Executor Depth Limit Inconsistency in Constant Deserialization

## Summary
There is a mismatch between the maximum allowed nesting depth for constants during bytecode verification versus VM execution. The bytecode verifier allows type signatures up to depth 256 and uses `MoveValue::simple_deserialize()` without explicit depth checking, while the VM executor enforces a depth limit of 128. This allows modules with deeply nested constants (depth 129-256) to pass verification but fail deterministically at execution time, violating the invariant that verified code should be executable.

## Finding Description

The vulnerability stems from inconsistent depth validation across two critical code paths:

**Verification Path:**

During module verification, the bytecode verifier calls `constants::verify_module()` [1](#0-0)  which iterates through all constants and calls `verify_constant_data()` [2](#0-1) . 

This verification uses `Constant::deserialize_constant()` [3](#0-2)  which calls `MoveValue::simple_deserialize(&self.data, &ty)` [4](#0-3) . This method only performs `bcs::from_bytes_seed(ty, blob)` [5](#0-4)  with **no depth checking on the value itself** - only validates that BCS deserialization succeeds.

The type signature depth is limited to 256 levels [6](#0-5) .

**Execution Path:**

During execution, the `LdConst` instruction loads constants [7](#0-6)  and calls `Value::deserialize_constant()` [8](#0-7) . 

This execution path explicitly uses `ValueSerDeContext::new(Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))` [9](#0-8)  where `DEFAULT_MAX_VM_VALUE_NESTED_DEPTH` is **128** [10](#0-9) .

The depth checking is enforced through `check_depth()` [11](#0-10)  which returns `VM_MAX_VALUE_DEPTH_REACHED` error if the depth exceeds the limit. When deserialization fails, the interpreter returns `VERIFIER_INVARIANT_VIOLATION` [12](#0-11) .

The code explicitly documents this as an invariant [13](#0-12)  stating that constant depth should be bounded, but the verifier fails to enforce this bound.

**Attack Scenario:**
1. Attacker creates a module with a constant of type `vector<vector<...vector<u8>...>>` with nesting depth between 129-256
2. Submits transaction to publish the module
3. Verifier accepts it (type depth â‰¤ 256, no value depth check during verification)
4. Module gets published successfully
5. Any transaction attempting to execute code that loads this constant fails with `VERIFIER_INVARIANT_VIOLATION`
6. The module becomes permanently unexecutable despite passing verification

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program as it creates "State inconsistencies requiring intervention."

**Specific Impacts:**
- **Invariant Violation**: Breaks the fundamental assumption that bytecode-verified modules are executable
- **Resource Waste**: Attackers can publish modules that consume storage but are unusable
- **Deterministic DoS**: Creates permanently broken code that passed verification
- **Gas Inefficiency**: Users waste gas attempting to call functions that will always fail

**Not Critical Because:**
- All validators behave identically (deterministic failure, no consensus break)
- No fund loss or theft occurs
- Verifier has `catch_unwind` protection preventing crashes [14](#0-13) 
- Limited to DoS of specific modules, not network-wide impact

## Likelihood Explanation

**High Likelihood** due to:
- Any user can publish modules (no special privileges required)
- Attack is straightforward - just requires crafting deeply nested type signatures
- Constant size limit of 65535 bytes [15](#0-14)  easily accommodates deeply nested structures
- Gap between limits is significant (128 vs 256)

## Recommendation

Add explicit value depth checking during constant verification. Modify `verify_constant_data()` to use the same depth limit as the executor:

```rust
fn verify_constant_data(idx: usize, constant: &Constant) -> PartialVMResult<()> {
    // Use ValueSerDeContext with the same depth limit as execution
    match Value::deserialize_constant(constant) {
        Some(_) => Ok(()),
        None => Err(verification_error(
            StatusCode::MALFORMED_CONSTANT_DATA,
            IndexKind::ConstantPool,
            idx as TableIndex,
        )),
    }
}
```

Alternatively, ensure that the type signature depth limit matches the value depth limit (both should be 128).

## Proof of Concept

To demonstrate this vulnerability, create a Move module with a deeply nested constant:

```move
module 0x1::DeepConstant {
    // Create a constant with depth 150 (between 128 and 256)
    const DEEP_VECTOR: vector<vector<vector<...>>> = /* 150 levels of nesting */;
    
    public fun load_constant(): vector<u8> {
        DEEP_VECTOR  // This will fail at execution with VERIFIER_INVARIANT_VIOLATION
    }
}
```

The module will pass verification but any attempt to execute `load_constant()` will fail deterministically across all validators.

## Notes

This vulnerability demonstrates a gap between verification-time and execution-time guarantees in the Move VM. The issue is deterministic and affects all validators identically, preventing consensus issues but creating unusable modules that waste storage space. The fix should align the depth limits or add explicit depth checking during verification to maintain the invariant that verified code is executable.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L139-170)
```rust
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
```

**File:** third_party/move/move-bytecode-verifier/src/constants.rs (L55-63)
```rust
fn verify_constant_data(idx: usize, constant: &Constant) -> PartialVMResult<()> {
    match constant.deserialize_constant() {
        Some(_) => Ok(()),
        None => Err(verification_error(
            StatusCode::MALFORMED_CONSTANT_DATA,
            IndexKind::ConstantPool,
            idx as TableIndex,
        )),
    }
```

**File:** third_party/move/move-binary-format/src/constant.rs (L71-74)
```rust
    pub fn deserialize_constant(&self) -> Option<MoveValue> {
        let ty = sig_to_ty(&self.type_)?;
        MoveValue::simple_deserialize(&self.data, &ty).ok()
    }
```

**File:** third_party/move/move-core/types/src/value.rs (L294-296)
```rust
    pub fn simple_deserialize(blob: &[u8], ty: &MoveTypeLayout) -> AResult<Self> {
        Ok(bcs::from_bytes_seed(ty, blob)?)
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L69-69)
```rust
pub const CONSTANT_SIZE_MAX: u64 = 65535;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L88-88)
```rust
pub const SIGNATURE_TOKEN_DEPTH_MAX: usize = 256;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2138-2156)
```rust
                    Instruction::LdConst(idx) => {
                        let constant = self.constant_at(*idx);

                        gas_meter.charge_create_ty(NumTypeNodes::new(
                            constant.type_.num_nodes() as u64,
                        ))?;
                        gas_meter.charge_ld_const(NumBytes::new(constant.data.len() as u64))?;

                        let val = Value::deserialize_constant(constant).ok_or_else(|| {
                            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                                .with_message(
                                    "Verifier failed to verify the deserialization of constants"
                                        .to_owned(),
                                )
                        })?;

                        gas_meter.charge_ld_const_after_deserialization(&val)?;
                        interpreter.operand_stack.push(val)?;
                    },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L57-57)
```rust
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5444-5446)
```rust
        // INVARIANT:
        //   For constants, layout depth is bounded and cannot contain function values. Hence,
        //   serialization depth is bounded. We still enable depth checks as a precaution.
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5447-5448)
```rust
        ValueSerDeContext::new(Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))
            .deserialize(&constant.data, &layout)
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L149-157)
```rust
    pub(crate) fn check_depth(&self, depth: u64) -> PartialVMResult<()> {
        if self
            .max_value_nested_depth
            .is_some_and(|max_depth| depth > max_depth)
        {
            return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
        }
        Ok(())
    }
```
