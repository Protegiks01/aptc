# Audit Report

## Title
V2 Batch Storage Leak: Unbounded Database Growth from Missing Schema-Specific Deletion

## Summary
The QuorumStore batch cleanup logic fails to distinguish between V1 and V2 batch schemas when performing deletions, causing all V2 batches to remain permanently in the database. This results in unbounded storage growth that can lead to validator node failures.

## Finding Description

The collision domains are properly separated - `BatchSchema` and `BatchV2Schema` use distinct column families (`"batch"` and `"batch_v2"` respectively), preventing key collisions at the storage layer. [1](#0-0) [2](#0-1) [3](#0-2) 

However, the cleanup implementation contains critical bugs that cause cross-schema deletion attempts:

**Bug #1 - Wrong Schema Deletion in Epoch GC:**

The `gc_previous_epoch_batches_from_db_v2` function reads V2 batches from the V2 schema but attempts to delete them from the V1 schema: [4](#0-3) [5](#0-4) 

The `delete_batches` method only operates on `BatchSchema` (V1): [6](#0-5) 

This should call `delete_batches_v2()` instead, which targets `BatchV2Schema`: [7](#0-6) 

**Bug #2 - V2 Batches Never Deleted During Normal Operation:**

The `update_certified_timestamp` function, responsible for removing expired batches during consensus, only deletes from the V1 schema: [8](#0-7) 

The expired keys come from a unified cache containing both V1 and V2 batches: [9](#0-8) 

V2 batches are never deleted during normal operation because `delete_batches_v2()` is only called once during initialization: [10](#0-9) [11](#0-10) 

**Root Cause:**

The system uses a unified in-memory cache for both versions but split database schemas. The deletion logic doesn't track which schema each digest belongs to, defaulting to V1 deletion only. When V2 batches are enabled [12](#0-11) [13](#0-12) , they are properly saved to the V2 schema [14](#0-13)  but never properly deleted.

## Impact Explanation

**Severity: HIGH** (up to $50,000)

This vulnerability causes **validator node slowdowns** through unbounded storage growth, meeting the High severity criteria defined in the Aptos bug bounty program. Specifically:

1. **Storage Exhaustion**: V2 batches accumulate indefinitely in QuorumStoreDB, growing without bound
2. **Performance Degradation**: Large database sizes slow down RocksDB operations (reads, writes, compaction)
3. **Node Failures**: Eventually, disk space exhaustion can crash validator nodes
4. **Network Impact**: If multiple validators run V2, consensus could be disrupted when nodes fail

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

While not immediately catastrophic like consensus safety violations, the impact escalates over time and affects network availability when validators using V2 batches experience storage-related failures.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically whenever V2 batches are enabled [15](#0-14) :

1. **No special attack needed**: Simply operating with `enable_batch_v2 = true` causes the leak
2. **Continuous accumulation**: Every V2 batch created persists forever
3. **No cleanup path**: There is no code path that correctly deletes V2 batches during normal operation
4. **Deterministic outcome**: Storage exhaustion is inevitable given enough time

The only reason this might not manifest immediately is if V2 batches haven't been widely deployed yet. However, once enabled, the leak is guaranteed.

## Recommendation

Fix the two deletion bugs to properly handle V2 batches:

**Fix #1**: In `gc_previous_epoch_batches_from_db_v2` (line 241), change:
```rust
db.delete_batches(expired_keys)
```
to:
```rust
db.delete_batches_v2(expired_keys)
```

**Fix #2**: In `update_certified_timestamp`, track which batches are V1 vs V2 and call the appropriate deletion method. The cache should either:
- Store version metadata with each entry, OR
- Maintain separate expiration tracking for V1 and V2 batches, OR
- Call both `delete_batches()` and `delete_batches_v2()` with the appropriate subset of keys

The recommended approach is to extend the cache to track batch versions and route deletions accordingly.

## Proof of Concept

To reproduce:
1. Configure a validator with `enable_batch_v2 = true` in QuorumStoreConfig
2. Run the validator normally and monitor QuorumStoreDB size
3. Observe that the `batch_v2` column family grows unboundedly
4. Use RocksDB tools to verify V2 batches are never deleted
5. Eventually, disk space will be exhausted

The bug can also be verified through code inspection by tracing the deletion paths for V2 batches and confirming that `delete_batches_v2()` is never called during normal operation (only during initialization when `is_new_epoch = false`).

## Notes

This is a logic bug in the resource cleanup code that causes a storage leak. While the immediate impact depends on whether `enable_batch_v2` is currently enabled in production, the bug represents a clear violation of resource management invariants that would cause validator failures if the feature is deployed without this fix.

### Citations

**File:** consensus/src/quorum_store/schema.rs (L14-16)
```rust
pub(crate) const BATCH_CF_NAME: ColumnFamilyName = "batch";
pub(crate) const BATCH_ID_CF_NAME: ColumnFamilyName = "batch_ID";
pub(crate) const BATCH_V2_CF_NAME: ColumnFamilyName = "batch_v2";
```

**File:** consensus/src/quorum_store/schema.rs (L25-25)
```rust
    const COLUMN_FAMILY_NAME: aptos_schemadb::ColumnFamilyName = BATCH_CF_NAME;
```

**File:** consensus/src/quorum_store/schema.rs (L55-55)
```rust
    const COLUMN_FAMILY_NAME: aptos_schemadb::ColumnFamilyName = BATCH_V2_CF_NAME;
```

**File:** consensus/src/quorum_store/batch_store.rs (L116-116)
```rust
    db_cache: DashMap<HashValue, PersistedValue<BatchInfoExt>>,
```

**File:** consensus/src/quorum_store/batch_store.rs (L169-175)
```rust
            Self::populate_cache_and_gc_expired_batches_v2(
                db_clone,
                epoch,
                last_certified_time,
                expiration_buffer_usecs,
                &batch_store,
            );
```

**File:** consensus/src/quorum_store/batch_store.rs (L213-215)
```rust
        let db_content = db
            .get_all_batches_v2()
            .expect("failed to read data from db");
```

**File:** consensus/src/quorum_store/batch_store.rs (L241-242)
```rust
        db.delete_batches(expired_keys)
            .expect("Deletion of expired keys should not fail");
```

**File:** consensus/src/quorum_store/batch_store.rs (L332-335)
```rust
        tokio::task::spawn_blocking(move || {
            db.delete_batches_v2(expired_keys)
                .expect("Deletion of expired keys should not fail");
        });
```

**File:** consensus/src/quorum_store/batch_store.rs (L508-512)
```rust
                    } else {
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
```

**File:** consensus/src/quorum_store/batch_store.rs (L530-539)
```rust
    pub fn update_certified_timestamp(&self, certified_time: u64) {
        trace!("QS: batch reader updating time {:?}", certified_time);
        self.last_certified_time
            .fetch_max(certified_time, Ordering::SeqCst);

        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L93-101)
```rust
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchSchema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L123-131)
```rust
    fn delete_batches_v2(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchV2Schema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-200)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
```
