# Audit Report

## Title
Progress Metadata Race Condition in Concurrent Restore Operations Leading to Incorrect Validator Sync Status

## Summary
The `save_transactions_impl()` function in `storage/aptosdb/src/backup/restore_utils.rs` updates `LedgerCommitProgress` and `OverallCommitProgress` metadata without synchronization, allowing concurrent restore operations to race and overwrite each other's progress values. This can cause validators to report incorrect sync status to the network.

## Finding Description

The vulnerability exists in the progress metadata update logic at lines 280-291 of `restore_utils.rs`: [1](#0-0) 

This function is called from multiple restore code paths:

1. **Backup restore operations** via `save_transactions()`: [2](#0-1) 

2. **State sync snapshot finalization** via `finalize_state_snapshot()`: [3](#0-2) 

The critical issue is that while normal transaction commits are protected by locks: [4](#0-3) [5](#0-4) 

**Restore operations completely bypass these locks**. The `RestoreHandler` is cloneable and shareable: [6](#0-5) 

### Race Condition Scenario:

If two concurrent restore operations execute:
- **Operation A**: Restoring transactions 0-9,999 (sets progress to 9,999)
- **Operation B**: Restoring transactions 10,000-19,999 (sets progress to 19,999)

If Operation B completes its `write_schemas()` call first, then Operation A completes second, the final state will show progress at version 9,999 despite transactions up to 19,999 being committed. This violates the monotonic progress invariant.

The progress metadata is consumed by: [7](#0-6) 

This incorrect sync status propagates throughout the system, affecting state sync decisions, consensus observer checks, monitoring systems, and API responses.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria because it causes:

1. **Significant protocol violations**: Validators reporting incorrect sync status breaks the assumption that nodes can accurately report their ledger state
2. **State sync coordination failures**: Incorrect progress metadata causes state sync to make wrong decisions about which data to fetch
3. **Validator node operational issues**: Monitoring systems receive false information, potentially triggering incorrect operational responses
4. **Network health degradation**: If multiple validators report wrong sync status, peer selection and data availability suffer

While this doesn't directly cause fund loss or consensus violations, it creates significant operational and protocol integrity issues that meet the "significant protocol violations" criteria for High severity.

## Likelihood Explanation

**Likelihood: Low-to-Medium in operational scenarios**

This vulnerability requires concurrent restore operations, which can occur in these realistic scenarios:

1. **State sync + backup restore overlap**: A node performing backup restore while state sync simultaneously calls `finalize_state_snapshot()`
2. **Multiple backup restore processes**: Operational error spawning multiple restore CLI instances
3. **Automated restore scripts**: CI/CD or recovery automation triggering overlapping restore operations
4. **Node recovery scenarios**: Complex recovery procedures where multiple restore mechanisms are active

While individual restore operations use `try_buffered_x` with concurrency control: [8](#0-7) 

This only prevents concurrency **within** a single restore operation, not **between** separate restore operations or different restore code paths.

## Recommendation

Add synchronization to protect progress metadata updates in restore operations. Implement one of these solutions:

**Option 1: Extend existing locks to cover restore operations**
```rust
// In save_transactions_impl, before updating metadata:
let _lock = ledger_db.aptosdb().commit_lock.try_lock()
    .expect("Concurrent restore operation detected");

// Then update progress metadata
ledger_db_batch.ledger_metadata_db_batches.put::<DbMetadataSchema>(
    &DbMetadataKey::LedgerCommitProgress,
    &DbMetadataValue::Version(last_version),
)?;
```

**Option 2: Add dedicated restore lock**
```rust
// In AptosDB struct:
restore_lock: std::sync::Mutex<()>,

// In save_transactions_impl:
let _lock = ledger_db.aptosdb().restore_lock.lock()
    .expect("Failed to acquire restore lock");
```

**Option 3: Use atomic compare-and-swap for progress updates**
```rust
// Only update if new version is greater than current
let current = get_progress(&db, &DbMetadataKey::OverallCommitProgress)?
    .unwrap_or(0);
if last_version > current {
    ledger_db_batch.put::<DbMetadataSchema>(...)?;
}
```

**Recommended approach**: Option 1 (extend commit_lock) provides the strongest consistency guarantee and aligns with existing concurrency control patterns.

## Proof of Concept

```rust
// Proof of concept demonstrating the race condition
use std::sync::Arc;
use std::thread;
use aptos_db::AptosDB;
use aptos_db::backup::restore_handler::RestoreHandler;

fn test_concurrent_restore_race() {
    // Setup: Create AptosDB instance and RestoreHandler
    let db = Arc::new(AptosDB::open(...).unwrap());
    let handler1 = db.get_restore_handler();
    let handler2 = handler1.clone(); // Clone for concurrent use
    
    // Thread 1: Restore transactions 0-9999
    let h1 = handler1.clone();
    let t1 = thread::spawn(move || {
        h1.save_transactions(
            0,
            &txns_0_9999,
            &aux_info,
            &txn_infos,
            &events,
            write_sets,
        ).unwrap();
    });
    
    // Thread 2: Restore transactions 10000-19999  
    let h2 = handler2.clone();
    let t2 = thread::spawn(move || {
        h2.save_transactions(
            10000,
            &txns_10000_19999,
            &aux_info,
            &txn_infos,
            &events,
            write_sets,
        ).unwrap();
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
    
    // Verify: Progress metadata may show version 9999 even though
    // transactions up to 19999 were saved
    let synced_version = db.get_synced_version().unwrap();
    
    // Race condition manifests as: synced_version could be 9999 or 19999
    // depending on which thread's write_schemas() completed last
    assert!(synced_version == 9999 || synced_version == 19999);
    
    // Expected: synced_version should always be 19999 (highest version)
    // Actual: Can be 9999 if thread 1 completes after thread 2
}
```

## Notes

While individual restore operations within the `TransactionRestoreBatchController` use sequential processing via `try_buffered_x(..., 1)`, this only prevents concurrency within that specific restore operation. The vulnerability manifests when multiple independent restore operations (from different controllers, code paths, or processes) execute concurrently against the same database.

The lack of synchronization in `save_transactions_impl()` creates a time-of-check-to-time-of-use (TOCTOU) race condition where the last writer wins, potentially setting progress metadata to an older version than what's actually committed to the database.

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L280-291)
```rust
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L24-30)
```rust
/// Provides functionalities for AptosDB data restore.
#[derive(Clone)]
pub struct RestoreHandler {
    pub aptosdb: Arc<AptosDB>,
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
}
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L78-99)
```rust
    pub fn save_transactions(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            false,
        )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L89-92)
```rust
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L183-198)
```rust
            restore_utils::save_transactions(
                self.state_store.clone(),
                self.ledger_db.clone(),
                version,
                &transactions,
                &persisted_aux_info,
                &transaction_infos,
                &events,
                wsets,
                Some((
                    &mut ledger_db_batch,
                    &mut sharded_kv_batch,
                    &mut state_kv_metadata_batch,
                )),
                false,
            )?;
```

**File:** storage/aptosdb/src/db/mod.rs (L34-37)
```rust
    /// This is just to detect concurrent calls to `pre_commit_ledger()`
    pre_commit_lock: std::sync::Mutex<()>,
    /// This is just to detect concurrent calls to `commit_ledger()`
    commit_lock: std::sync::Mutex<()>,
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L76-78)
```rust
    pub(crate) fn get_synced_version(&self) -> Result<Option<Version>> {
        get_progress(&self.db, &DbMetadataKey::OverallCommitProgress)
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L536-536)
```rust
            .try_buffered_x(self.global_opt.concurrent_downloads, 1)
```
