# Audit Report

## Title
Timing and Response Size Oracle in Quorum Store Database Dump Endpoint Reveals Batch Digest Existence

## Summary
The `/debug/consensus/quorumstoredb` admin endpoint contains a response size oracle that allows attackers with network access to determine which batch digests exist in the quorum store database without requiring database access or authentication (on testnet/devnet). [1](#0-0) 

## Finding Description

The `dump_quorum_store_db()` function exposes a deterministic oracle through response size differences when querying batch digests. When a digest parameter is provided, the function performs a database lookup at line 168: [2](#0-1) 

The oracle manifests through two distinct response patterns:

**When a batch exists:**
1. The database retrieves the `PersistedValue<BatchInfo>` structure [3](#0-2) 

2. This structure contains BatchInfo metadata and optionally a vector of SignedTransactions [4](#0-3) 

3. The SchemaDB performs BCS deserialization of the entire structure [5](#0-4) 

4. The result is formatted with Debug formatting, producing a large response body containing all batch details

**When a batch doesn't exist:**
1. The database returns `None` without deserialization
2. The response body simply contains "None" (~40 bytes)

The authentication mechanism on testnet/devnet is bypassed by default when `authentication_configs` is empty: [6](#0-5) 

The configuration explicitly allows unauthenticated access on non-mainnet chains: [7](#0-6) 

## Impact Explanation

This vulnerability falls under **Low Severity** per the Aptos bug bounty criteria ("Minor information leaks"). While the security question suggests Medium severity, the actual impact is limited to information disclosure:

**What is disclosed:**
- Existence of specific batch digests in the quorum store
- Network activity patterns (which batches were stored)
- Consensus state mapping

**What is NOT compromised:**
- No fund loss or theft capability
- No consensus safety violations
- No state corruption or manipulation
- No validator availability impact
- Batch contents remain protected (hash preimage resistance)

The admin service is designed for operator debugging and is expected to be protected at the network level (firewall port 9102). However, on testnet/devnet deployments, it's enabled by default without authentication, expanding the attack surface.

## Likelihood Explanation

**On Testnet/Devnet:** High likelihood if an attacker gains network access to port 9102
- Admin service enabled by default [8](#0-7) 

- No authentication required
- No rate limiting at application layer

**On Mainnet:** Very low likelihood
- Admin service disabled by default
- Configuration sanitizer enforces authentication if enabled [9](#0-8) 

## Recommendation

Implement the following defense-in-depth measures:

1. **Constant-time responses:** Return consistent response sizes regardless of batch existence
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();
    
    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        match quorum_store_db.get_batch(&digest).map_err(Error::msg)? {
            Some(batch) => body.push_str(&format!("{:?}", batch)),
            None => body.push_str(&format!("{:?}", "Batch not found")),
        }
    } else {
        // ... existing code ...
    }
    Ok(body)
}
```

2. **Require authentication on all chains:** Remove the exemption for testnet/devnet in the configuration sanitizer

3. **Add rate limiting:** Implement request throttling on admin endpoints to prevent enumeration attacks

4. **Network-level protection:** Document that port 9102 must be firewalled and only accessible to authorized operators

## Proof of Concept

```rust
// Test demonstrating the oracle
#[tokio::test]
async fn test_batch_existence_oracle() {
    use hyper::Client;
    use hyper::Uri;
    
    // Assume admin service running on localhost:9102 (testnet/devnet config)
    let client = Client::new();
    
    // Test with a known non-existent digest
    let fake_digest = "0x0000000000000000000000000000000000000000000000000000000000000000";
    let uri: Uri = format!("http://localhost:9102/debug/consensus/quorumstoredb?digest={}", fake_digest)
        .parse()
        .unwrap();
    
    let response = client.get(uri).await.unwrap();
    let body_size_nonexistent = hyper::body::to_bytes(response.into_body())
        .await
        .unwrap()
        .len();
    
    // Test with a real batch digest (obtained through other means)
    // Real digest would be obtained from consensus observation or block data
    let real_digest = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
    let uri: Uri = format!("http://localhost:9102/debug/consensus/quorumstoredb?digest={}", real_digest)
        .parse()
        .unwrap();
    
    let response = client.get(uri).await.unwrap();
    let body_size_existent = hyper::body::to_bytes(response.into_body())
        .await
        .unwrap()
        .len();
    
    // Oracle: Response sizes differ significantly
    // Non-existent: ~40 bytes ("HashValue(...):\nNone")
    // Existent: >100 bytes (full batch info with metadata)
    assert!(body_size_existent > body_size_nonexistent * 2);
    
    println!("Non-existent batch response size: {} bytes", body_size_nonexistent);
    println!("Existent batch response size: {} bytes", body_size_existent);
    println!("Oracle successfully distinguishes batch existence!");
}
```

## Notes

This vulnerability requires network access to the admin service port (9102), which should be protected by network-level access controls in production deployments. However, the default testnet/devnet configuration enables the service without authentication, creating an unnecessarily broad attack surface for information disclosure. While this doesn't lead to direct fund loss or consensus violations, it violates defense-in-depth principles by unnecessarily exposing internal state information.

### Citations

**File:** aptos-core-059/crates/aptos-admin-service/src/server/consensus/mod.rs (L158-177)
```rust

```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L119-121)
```rust
    fn get_batch(&self, digest: &HashValue) -> Result<Option<PersistedValue<BatchInfo>>, DbError> {
        Ok(self.db.get::<BatchSchema>(digest)?)
    }
```

**File:** consensus/src/quorum_store/types.rs (L21-25)
```rust
#[derive(Clone, Eq, Deserialize, Serialize, PartialEq, Debug)]
pub struct PersistedValue<T> {
    info: T,
    maybe_payload: Option<Vec<SignedTransaction>>,
}
```

**File:** storage/schemadb/src/lib.rs (L216-232)
```rust
    pub fn get<S: Schema>(&self, schema_key: &S::Key) -> DbResult<Option<S::Value>> {
        let _timer = APTOS_SCHEMADB_GET_LATENCY_SECONDS.timer_with(&[S::COLUMN_FAMILY_NAME]);

        let k = <S::Key as KeyCodec<S>>::encode_key(schema_key)?;
        let cf_handle = self.get_cf_handle(S::COLUMN_FAMILY_NAME)?;

        let result = self.inner.get_cf(cf_handle, k).into_db_res()?;
        APTOS_SCHEMADB_GET_BYTES.observe_with(
            &[S::COLUMN_FAMILY_NAME],
            result.as_ref().map_or(0.0, |v| v.len() as f64),
        );

        result
            .map(|raw_value| <S::Value as ValueCodec<S>>::decode_value(&raw_value))
            .transpose()
            .map_err(Into::into)
    }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-157)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
```

**File:** config/src/config/admin_service_config.rs (L21-22)
```rust
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
```

**File:** config/src/config/admin_service_config.rs (L67-78)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/admin_service_config.rs (L94-96)
```rust
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
```
