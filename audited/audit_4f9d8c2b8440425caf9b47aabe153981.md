# Audit Report

## Title
Missing Authorization Verification for ObservedJWKUpdate Validator Transactions at Consensus Layer

## Summary
Validator transactions of type `ObservedJWKUpdate` bypass signature verification during consensus proposal validation. Authorization checks only occur during execution, allowing malicious proposers to include invalid JWK updates that waste network resources and violate the principle of validating proposals before voting.

## Finding Description
The Aptos consensus protocol processes validator transactions through two distinct phases: consensus validation and execution. For security, validator transactions should be verified during consensus before validators vote on proposals. However, `ObservedJWKUpdate` transactions skip this critical authorization check.

When a proposal is received and processed in `round_manager.rs`, the code calls `vtxn.verify(verifier)` for each validator transaction: [1](#0-0) 

The `verify()` implementation treats different validator transaction types differently: [2](#0-1) 

For `DKGResult` transactions, verification includes checking voting power through `verify_transcript_extra()`: [3](#0-2) 

However, for `ObservedJWKUpdate`, the verify method returns `Ok()` **without any verification**. The actual signature verification only happens later during execution in the VM: [4](#0-3) 

**Attack Path:**
1. Malicious validator becomes proposer through normal leader election
2. Creates a `QuorumCertifiedUpdate` with arbitrary JWK data and forged/empty `multi_sig`
3. Inserts it into their local validator transaction pool
4. Creates proposal including this invalid validator transaction via `new_proposal_ext()`
5. Broadcasts proposal to network
6. Other validators receive proposal, call `verify()` which returns `Ok()` without checking signature
7. Validators vote for the block (since all checks passed)
8. Block achieves quorum and is committed
9. During execution, signature verification fails and transaction is discarded
10. Attacker can repeat this attack every time they become proposer

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for "Significant protocol violations."

**Security Guarantees Broken:**
1. **Transaction Validation Invariant**: Proposals should be fully validated before validators vote on them
2. **Resource Limits**: Network and computational resources are wasted processing invalid transactions that pass consensus but fail execution
3. **Access Control**: The consensus layer fails to enforce authorization requirements for system transactions

**Potential Impacts:**
- **Resource Exhaustion**: Malicious validators can continuously propose invalid JWK updates, forcing all validators to waste resources processing, broadcasting, voting, and executing transactions that will ultimately be discarded
- **Protocol Violation**: Authorization checks occur at the wrong layer (execution instead of consensus), violating defense-in-depth principles
- **Risk of State Divergence**: If execution-time signature verification has any non-determinism or bugs, different validators might handle the invalid transaction differently, potentially causing state divergence
- **Validator Node Slowdowns**: Continuous injection of invalid validator transactions could degrade network performance

While the deterministic execution layer prevents direct consensus safety violations, this flaw creates unnecessary attack surface and violates the fundamental principle that consensus should only commit valid transactions.

## Likelihood Explanation
**Likelihood: Medium to High**

**Attacker Requirements:**
- Must be part of the active validator set (achievable with minimum stake)
- Must become proposer through normal leader election (happens regularly in round-robin fashion)
- No additional resources or sophisticated attacks required

**Feasibility:**
- The attack is trivial to execute - simply craft an `ObservedJWKUpdate` with invalid signature
- Can be repeated every time the attacker becomes proposer
- No rate limiting or detection mechanisms at consensus layer
- Attack is "free" for the attacker once they have validator status

The only barrier is validator status, but once achieved, exploitation is straightforward and repeatable.

## Recommendation
Add signature verification for `ObservedJWKUpdate` transactions at the consensus layer, similar to how `DKGResult` transactions are verified.

**Recommended Fix:**

Modify `types/src/validator_txn.rs` to verify the multi-signature before accepting the validator transaction:

```rust
pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
    match self {
        ValidatorTransaction::DKGResult(dkg_result) => dkg_result
            .verify(verifier)
            .context("DKGResult verification failed"),
        ValidatorTransaction::ObservedJWKUpdate(jwk_update) => {
            // Verify the multi-signature against the update
            let authors = jwk_update.multi_sig.get_signers_addresses(
                &verifier.get_ordered_account_addresses()
            );
            
            // Check voting power
            verifier
                .check_voting_power(authors.iter(), true)
                .context("ObservedJWKUpdate: insufficient voting power")?;
            
            // Verify the aggregate signature
            verifier
                .verify_multi_signatures(&jwk_update.update, &jwk_update.multi_sig)
                .context("ObservedJWKUpdate: multi-signature verification failed")?;
            
            Ok(())
        },
    }
}
```

This ensures that:
1. Only validator transactions with valid quorum signatures pass consensus validation
2. Invalid transactions are rejected before voting, saving network resources
3. Authorization checks happen at the appropriate layer (consensus, not just execution)
4. The attack surface for state divergence is eliminated

## Proof of Concept

Create a malicious validator transaction with an invalid signature:

```rust
use aptos_types::{
    aggregate_signature::AggregateSignature,
    jwks::{ProviderJWKs, QuorumCertifiedUpdate, issuer_from_str},
    validator_txn::ValidatorTransaction,
};

// Create a fake JWK update with empty/forged signature
let fake_update = QuorumCertifiedUpdate {
    update: ProviderJWKs {
        issuer: issuer_from_str("https://malicious.attacker"),
        version: 999,
        jwks: vec![],
    },
    multi_sig: AggregateSignature::empty(), // Invalid signature!
};

let malicious_vtxn = ValidatorTransaction::ObservedJWKUpdate(fake_update);

// During consensus in round_manager.rs:
// This will pass verification at consensus layer
let verify_result = malicious_vtxn.verify(&epoch_state.verifier);
assert!(verify_result.is_ok()); // âŒ SHOULD FAIL BUT PASSES!

// The invalid transaction will only be caught during execution,
// after consensus has already committed the block containing it
```

To test this in practice:
1. Set up a local testnet with multiple validators
2. Modify a validator's `jwk_manager` to inject a `QuorumCertifiedUpdate` with an empty `multi_sig` into the validator transaction pool
3. Wait for that validator to become proposer
4. Observe that other validators vote for the proposal (consensus accepts it)
5. Observe that during execution, all validators discard the transaction
6. Confirm that network resources were wasted processing an invalid transaction that should have been rejected at consensus time

**Notes**

This vulnerability represents a defense-in-depth failure where authorization checks are deferred from the consensus layer to the execution layer. While the execution layer does provide a safety net by verifying signatures, this creates unnecessary risk and resource waste. The proper security architecture requires validation at the earliest possible point (consensus) rather than relying solely on later layers (execution). The inconsistency between `DKGResult` (which verifies at consensus) and `ObservedJWKUpdate` (which doesn't) suggests this may be an oversight rather than an intentional design decision.

### Citations

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L318-322)
```rust
        if checks_voting_power {
            verifier
                .check_voting_power(dealer_set.iter(), true)
                .context("not enough power")?;
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L139-142)
```rust
        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```
