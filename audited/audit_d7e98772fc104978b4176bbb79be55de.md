# Audit Report

## Title
JWK Consensus State Pollution via Unbounded Issuer Creation in process_peer_request()

## Summary
The `process_peer_request()` function in the JWK consensus manager creates HashMap entries for any issuer included in `ObservationRequest` messages without validation, allowing memory exhaustion through state pollution.

## Finding Description

The vulnerability exists in the `IssuerLevelConsensusManager::process_peer_request()` function where an `ObservationRequest` containing an arbitrary issuer unconditionally creates a new HashMap entry: [1](#0-0) 

The code uses `entry(request.issuer).or_default()` which creates a new `PerProviderState` entry for any issuer, even non-existent ones. The `PerProviderState::default()` implementation creates an empty state: [2](#0-1) 

The `Issuer` type is defined as an unbounded `Vec<u8>`: [3](#0-2) 

Network messages can be up to 64 MiB in size: [4](#0-3) 

A malicious validator can send `ObservationRequest` messages through the validator network: [5](#0-4) 

**Attack Path:**
1. Attacker sends multiple `ObservationRequest` messages with unique, large issuers (up to ~60 MB each)
2. Each request creates a new HashMap entry in `states_by_issuer`
3. Memory consumption grows: 100 requests Ã— 60 MB = 6 GB of memory
4. The pollution persists until `reset_with_on_chain_state()` is called (cleanup occurs on JWK updates)

The cleanup mechanism exists but is periodic: [6](#0-5) 

## Impact Explanation

**Severity: Medium** - This qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty categories. The attack can cause:
- Validator node memory exhaustion (multiple gigabytes with large issuers)
- Performance degradation as HashMap grows
- Potential node instability under memory pressure
- Does not directly cause consensus failure or fund loss, but impacts node availability

## Likelihood Explanation

**Likelihood: Medium-to-Low**

**Requirements:**
- Attacker must be a validator OR have compromised validator network credentials
- This is an **insider threat scenario** requiring privileged access

**Ease of Exploitation:**
- Simple to execute once validator access is obtained
- No rate limiting on RPC requests visible in the code
- Can craft large issuers within network message limits

**Mitigation Factors:**
- Periodic cleanup on JWK updates reduces persistence
- Requires compromised validator (trusted actor in the security model)

## Recommendation

Add validation to reject `ObservationRequest` messages for issuers not in the supported OIDC providers list:

```rust
pub fn process_peer_request(&mut self, rpc_req: IncomingRpcRequest) -> Result<()> {
    let IncomingRpcRequest {
        msg,
        mut response_sender,
        ..
    } = rpc_req;
    match msg {
        JWKConsensusMsg::ObservationRequest(request) => {
            // Validate issuer exists in known state before creating entry
            if !self.states_by_issuer.contains_key(&request.issuer) {
                response_sender.send(Err(anyhow!("unknown issuer")));
                return Ok(());
            }
            
            let state = self.states_by_issuer.get(&request.issuer).unwrap();
            let response: Result<JWKConsensusMsg> = match &state.consensus_state {
                ConsensusState::NotStarted => Err(anyhow!("observed update unavailable")),
                ConsensusState::InProgress { my_proposal, .. }
                | ConsensusState::Finished { my_proposal, .. } => Ok(
                    JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                        epoch: self.epoch_state.epoch,
                        update: my_proposal.clone(),
                    }),
                ),
            };
            response_sender.send(response);
            Ok(())
        },
        _ => {
            bail!("unexpected rpc: {}", msg.name());
        },
    }
}
```

Additionally, add size limits for issuer fields to prevent excessively large allocations, similar to the keyless module's `MAX_ISSUER_UTF8_BYTES_LENGTH` of 120 bytes.

## Proof of Concept

This vulnerability requires validator network access to exploit. A test demonstrating the issue:

```rust
#[cfg(test)]
mod state_pollution_test {
    use super::*;
    use aptos_types::jwks::issuer_from_str;
    
    #[test]
    fn test_issuer_state_pollution() {
        // Setup manager
        let mut manager = create_test_manager();
        
        // Create requests with non-existent issuers
        for i in 0..1000 {
            let fake_issuer = format!("https://fake-issuer-{}.com", i).into_bytes();
            let request = ObservationRequest {
                epoch: 1,
                issuer: fake_issuer.clone(),
            };
            
            // Process request - this creates an entry
            let rpc_req = create_test_rpc_request(JWKConsensusMsg::ObservationRequest(request));
            manager.process_peer_request(rpc_req).unwrap();
            
            // Verify entry was created even for non-existent issuer
            assert!(manager.states_by_issuer.contains_key(&fake_issuer));
        }
        
        // Verify 1000 fake entries were created
        assert_eq!(manager.states_by_issuer.len(), 1000);
    }
}
```

**Note:** This vulnerability **requires validator network access**, which places it in the **insider threat category**. Per the validation checklist requirement that vulnerabilities must be "exploitable by unprivileged attacker (no validator insider access required)," this issue does not meet the specified threat model criteria.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L231-253)
```rust
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );
        let onchain_issuer_set: HashSet<Issuer> = on_chain_state
            .entries
            .iter()
            .map(|entry| entry.issuer.clone())
            .collect();
        let local_issuer_set: HashSet<Issuer> = self.states_by_issuer.keys().cloned().collect();

        for issuer in local_issuer_set.difference(&onchain_issuer_set) {
            info!(
                epoch = self.epoch_state.epoch,
                op = "delete",
                issuer = issuer.clone(),
                "reset_with_on_chain_state"
            );
        }

        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L294-320)
```rust
    pub fn process_peer_request(&mut self, rpc_req: IncomingRpcRequest) -> Result<()> {
        let IncomingRpcRequest {
            msg,
            mut response_sender,
            ..
        } = rpc_req;
        match msg {
            JWKConsensusMsg::ObservationRequest(request) => {
                let state = self.states_by_issuer.entry(request.issuer).or_default();
                let response: Result<JWKConsensusMsg> = match &state.consensus_state {
                    ConsensusState::NotStarted => Err(anyhow!("observed update unavailable")),
                    ConsensusState::InProgress { my_proposal, .. }
                    | ConsensusState::Finished { my_proposal, .. } => Ok(
                        JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                            epoch: self.epoch_state.epoch,
                            update: my_proposal.clone(),
                        }),
                    ),
                };
                response_sender.send(response);
                Ok(())
            },
            _ => {
                bail!("unexpected rpc: {}", msg.name());
            },
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L361-382)
```rust
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct PerProviderState {
    pub on_chain: Option<ProviderJWKs>,
    pub observed: Option<Vec<JWKMoveStruct>>,
    pub consensus_state: ConsensusState<ObservedUpdate>,
}

impl PerProviderState {
    pub fn new(provider_jwks: ProviderJWKs) -> Self {
        Self {
            on_chain: Some(provider_jwks),
            observed: None,
            consensus_state: ConsensusState::NotStarted,
        }
    }

    pub fn on_chain_version(&self) -> u64 {
        self.on_chain
            .as_ref()
            .map_or(0, |provider_jwks| provider_jwks.version)
    }
}
```

**File:** types/src/jwks/mod.rs (L36-38)
```rust
pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;
```

**File:** config/src/config/network_config.rs (L45-50)
```rust
pub const MAX_MESSAGE_METADATA_SIZE: usize = 128 * 1024; /* 128 KiB: a buffer for metadata that might be added to messages by networking */
pub const MESSAGE_PADDING_SIZE: usize = 2 * 1024 * 1024; /* 2 MiB: a safety buffer to allow messages to get larger during serialization */
pub const MAX_APPLICATION_MESSAGE_SIZE: usize =
    (MAX_MESSAGE_SIZE - MAX_MESSAGE_METADATA_SIZE) - MESSAGE_PADDING_SIZE; /* The message size that applications should check against */
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L169-175)
```rust
        let (rpc_tx, rpc_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);

        let network_and_events = network_service_events.into_network_and_events();
        if (network_and_events.values().len() != 1)
            || !network_and_events.contains_key(&NetworkId::Validator)
        {
            panic!("The network has not been setup correctly for JWK consensus!");
```
