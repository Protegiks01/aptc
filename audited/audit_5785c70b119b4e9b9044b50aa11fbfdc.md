# Audit Report

## Title
Peer ID Mismatch in Identity Configuration Can Cause Validator Isolation from Consensus

## Summary
Validators can configure mismatched `peer_id` and `identity_key` values in their local identity configuration, causing authentication failures during network handshakes. This prevents the validator from establishing connections with other validators, completely isolating them from consensus operations and making them unable to receive blocks or votes.

## Finding Description

The Aptos network layer uses a two-part identity system where validators are identified by both a `peer_id` (AccountAddress) and an x25519 network `identity_key`. During the Noise protocol handshake, peers authenticate each other by validating that the presented public key matches the expected key for the claimed peer_id.

**The Vulnerability:** The identity configuration system allows `peer_id` and `identity_key` to be set independently without validating that they match. Specifically:

1. **No Validation in FromConfig Identity**: [1](#0-0) 
   The `from_config()` method accepts any peer_id without checking if it matches the identity_key.

2. **Incomplete Validation in prepare_identity()**: [2](#0-1) 
   The `prepare_identity()` function only derives peer_id from the public key when `peer_id == PeerId::ZERO`. If a non-zero peer_id is manually configured, it's never validated against the identity_key.

3. **Separate Storage of peer_id and key**: [3](#0-2) 
   The `peer_id()` method retrieves peer_id independently from the identity_key, with no cross-validation.

**How Authentication Fails:**

When a validator attempts to connect to peers, the Noise handshake performs strict authentication: [4](#0-3) 

If the presented `remote_public_key` is not in the trusted peer's key set, authentication fails with `UnauthenticatedClientPubkey` error.

**Attack Scenario:**

1. **On-chain Configuration**: Validator with account address `0xAAA` has network addresses containing public key `PubKey_Onchain` in the ValidatorSet: [5](#0-4) 

2. **Misconfigured Local Identity**: Operator sets local configuration with `peer_id = 0xAAA` but `identity_key = PrivKey_Local` (which generates `PubKey_Local ≠ PubKey_Onchain`)

3. **Trusted Peers Population**: Other validators extract the ValidatorSet and populate:
   ```
   trusted_peers[0xAAA] = Peer {
       keys: {PubKey_Onchain},
       role: Validator
   }
   ```

4. **Connection Attempt**: When the misconfigured validator initiates a connection:
   - Sends `peer_id = 0xAAA` in handshake prologue
   - Presents `PubKey_Local` during Noise key exchange
   - Remote validator checks: `PubKey_Local ∈ trusted_peers[0xAAA].keys`
   - **Check fails** because only `PubKey_Onchain` is in the set
   - Connection rejected

5. **Complete Isolation**: The validator cannot establish connections in either direction (as initiator or responder), preventing it from participating in consensus, receiving blocks, or voting.

**Key Mismatch Detection**: While the system does detect mismatches: [6](#0-5) 
This only logs an error and sets a metric—it does **not** prevent the node from starting or force configuration correction.

## Impact Explanation

**Severity: High**

This vulnerability causes:

1. **Validator Isolation**: The affected validator cannot participate in consensus, violating the Consensus Safety and Liveness invariants
2. **Loss of Rewards**: The isolated validator cannot propose blocks or vote, losing all staking rewards
3. **Network Liveness Risk**: If multiple validators are misconfigured (especially during coordinated upgrades), the network could lose enough validators to affect liveness
4. **Slashing Risk**: Extended downtime may trigger performance-based penalties in the staking system
5. **Silent Failure**: The validator node starts successfully but fails to connect, making the issue difficult to diagnose

This meets **High Severity** criteria from the Aptos bug bounty:
- "Validator node slowdowns" (validator becomes completely non-functional)
- "Significant protocol violations" (validator cannot fulfill consensus obligations)

## Likelihood Explanation

**Likelihood: Medium-High**

This misconfiguration can occur through several realistic scenarios:

1. **Manual Configuration Errors**: Operators manually editing YAML configs may set inconsistent values
2. **Key Rotation Failures**: When rotating network keys on-chain, operators may forget to update local configuration or vice versa
3. **Secure Storage Mismatches**: With `FromStorage` identity type, `peer_id` and `identity_key` are stored as separate entries in Vault/secure storage, allowing them to diverge
4. **Migration/Upgrade Errors**: During validator migrations or upgrades, configuration files may be partially updated
5. **Copy-Paste Errors**: Operators copying configurations between validators may accidentally use mismatched values

The lack of any validation makes this error **easy to introduce** and **hard to detect** until the validator fails to participate in consensus.

## Recommendation

Implement strict validation of peer_id and identity_key consistency at configuration load time:

```rust
// In config/src/config/network_config.rs, modify prepare_identity():

fn prepare_identity(&mut self) {
    match &mut self.identity {
        Identity::FromStorage(_) => {
            // Validate that stored peer_id matches the key
            let actual_peer_id = from_identity_public_key(self.identity_key().public_key());
            let configured_peer_id = self.peer_id();
            if actual_peer_id != configured_peer_id {
                panic!(
                    "FATAL: peer_id mismatch! Configured peer_id {} does not match \
                    identity_key-derived peer_id {}. This would cause authentication \
                    failures. Fix your configuration.",
                    configured_peer_id.short_str(),
                    actual_peer_id.short_str()
                );
            }
        },
        Identity::None => {
            let mut rng = StdRng::from_seed(OsRng.r#gen());
            let key = x25519::PrivateKey::generate(&mut rng);
            let peer_id = from_identity_public_key(key.public_key());
            self.identity = Identity::from_config_auto_generated(key, peer_id);
        },
        Identity::FromConfig(config) => {
            // Always validate, not just when peer_id == ZERO
            let derived_peer_id = from_identity_public_key(config.key.public_key());
            if config.peer_id == PeerId::ZERO {
                config.peer_id = derived_peer_id;
            } else if config.peer_id != derived_peer_id {
                panic!(
                    "FATAL: peer_id mismatch! Configured peer_id {} does not match \
                    identity_key-derived peer_id {}. This would cause authentication \
                    failures. Fix your configuration.",
                    config.peer_id.short_str(),
                    derived_peer_id.short_str()
                );
            }
        },
        Identity::FromFile(_) => {
            // Validate file-based identity as well
            let actual_peer_id = from_identity_public_key(self.identity_key().public_key());
            let configured_peer_id = self.peer_id();
            if actual_peer_id != configured_peer_id {
                panic!(
                    "FATAL: peer_id mismatch in identity file! Configured peer_id {} \
                    does not match identity_key-derived peer_id {}. This would cause \
                    authentication failures. Fix your identity file.",
                    configured_peer_id.short_str(),
                    actual_peer_id.short_str()
                );
            }
        },
    };
}
```

Additionally, enhance the `find_key_mismatches()` check to fail node startup rather than just logging: [6](#0-5) 

Change the warning to a fatal error that prevents node startup when the local key doesn't match on-chain configuration.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_peer_id_mismatch_causes_auth_failure() {
    use aptos_config::config::{Identity, NetworkConfig};
    use aptos_crypto::x25519;
    use aptos_types::account_address::from_identity_public_key;
    use rand::{rngs::StdRng, SeedableRng};
    
    // Create a validator with correct configuration
    let mut rng = StdRng::from_seed([0u8; 32]);
    let correct_key = x25519::PrivateKey::generate(&mut rng);
    let correct_peer_id = from_identity_public_key(correct_key.public_key());
    
    // Misconfigure: Use a DIFFERENT peer_id than what the key derives to
    let wrong_key = x25519::PrivateKey::generate(&mut rng);
    let wrong_peer_id = from_identity_public_key(wrong_key.public_key());
    
    // Create identity with MISMATCHED peer_id and key
    let mismatched_identity = Identity::from_config(correct_key, wrong_peer_id);
    
    let mut network_config = NetworkConfig::default();
    network_config.identity = mismatched_identity;
    
    // This configuration will pass prepare_identity() because wrong_peer_id != ZERO
    network_config.prepare_identity();
    
    // But when this validator tries to connect, it will present correct_key's public key
    // while claiming to be wrong_peer_id, causing authentication failure
    let presented_pubkey = network_config.identity_key().public_key();
    let claimed_peer_id = network_config.peer_id();
    let actual_peer_id_from_key = from_identity_public_key(presented_pubkey);
    
    // This assertion demonstrates the mismatch that causes auth failure
    assert_ne!(claimed_peer_id, actual_peer_id_from_key,
        "Misconfiguration not detected! peer_id {} doesn't match key-derived {}",
        claimed_peer_id, actual_peer_id_from_key
    );
    
    // In real operation, when other validators check:
    // if presented_pubkey ∈ trusted_peers[claimed_peer_id].keys
    // This check will FAIL because they have correct_pubkey stored for wrong_peer_id
    // or completely different keys, causing connection rejection
}
```

## Notes

The vulnerability exists because the identity configuration system treats `peer_id` and `identity_key` as independent values that can be set separately, without enforcing the cryptographic relationship between them. The `peer_id` should always be derived from the `identity_key` using `from_identity_public_key()`, but the current implementation only enforces this in limited cases (when `peer_id == ZERO`).

For validators, the situation is particularly critical because their `peer_id` in the on-chain ValidatorSet is their account address, which may have no relationship to their network identity key. The system assumes operators will correctly configure their local identity to match their on-chain configuration, but provides no validation to ensure this assumption holds.

The `find_key_mismatches()` function attempts to detect this issue at runtime but only logs a warning, allowing the misconfigured node to continue running in an isolated state rather than failing fast at startup.

### Citations

**File:** config/src/config/identity_config.rs (L75-82)
```rust
    pub fn from_config(key: x25519::PrivateKey, peer_id: PeerId) -> Self {
        let key = ConfigKey::new(key);
        Identity::FromConfig(IdentityFromConfig {
            key,
            peer_id,
            source: IdentitySource::UserProvided,
        })
    }
```

**File:** config/src/config/network_config.rs (L244-270)
```rust
    pub fn peer_id(&self) -> PeerId {
        match &self.identity {
            Identity::FromConfig(config) => Some(config.peer_id),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let peer_id = storage
                    .get::<PeerId>(&config.peer_id_name)
                    .expect("Unable to read peer id")
                    .value;
                Some(peer_id)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();

                // If account is not specified, generate peer id from public key
                if let Some(address) = identity_blob.account_address {
                    Some(address)
                } else {
                    Some(from_identity_public_key(
                        identity_blob.network_private_key.public_key(),
                    ))
                }
            },
            Identity::None => None,
        }
        .expect("peer id should be present")
    }
```

**File:** config/src/config/network_config.rs (L272-288)
```rust
    fn prepare_identity(&mut self) {
        match &mut self.identity {
            Identity::FromStorage(_) => (),
            Identity::None => {
                let mut rng = StdRng::from_seed(OsRng.r#gen());
                let key = x25519::PrivateKey::generate(&mut rng);
                let peer_id = from_identity_public_key(key.public_key());
                self.identity = Identity::from_config_auto_generated(key, peer_id);
            },
            Identity::FromConfig(config) => {
                if config.peer_id == PeerId::ZERO {
                    config.peer_id = from_identity_public_key(config.key.public_key());
                }
            },
            Identity::FromFile(_) => (),
        };
    }
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** network/discovery/src/validator_set.rs (L44-66)
```rust
    fn find_key_mismatches(&self, onchain_keys: Option<&HashSet<x25519::PublicKey>>) {
        let mismatch = onchain_keys.map_or(0, |pubkeys| {
            if !pubkeys.contains(&self.expected_pubkey) {
                error!(
                    NetworkSchema::new(&self.network_context),
                    "Onchain pubkey {:?} differs from local pubkey {}",
                    pubkeys,
                    self.expected_pubkey
                );
                1
            } else {
                0
            }
        });

        NETWORK_KEY_MISMATCH
            .with_label_values(&[
                self.network_context.role().as_str(),
                self.network_context.network_id().as_str(),
                self.network_context.peer_id().short_str().as_str(),
            ])
            .set(mismatch);
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```
