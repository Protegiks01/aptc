# Audit Report

## Title
Unauthenticated Failpoint Configuration Endpoint Enables Consensus and API Denial-of-Service on Non-Mainnet Networks

## Summary
The failpoint testing infrastructure exposes an unauthenticated HTTP endpoint `/v1/set_failpoint` that allows arbitrary failpoint configuration when the `failpoints` feature is compiled in and `failpoints_enabled` is set to true. While mainnet nodes are protected by a config sanitizer check, testnet and devnet nodes lack this protection, enabling external attackers to trigger intentional crashes in API endpoints, consensus processing, and block execution, causing total loss of liveness.

## Finding Description

The Aptos API includes a failpoint testing mechanism intended for internal debugging. The implementation has multiple protection layers, but a critical gap exists for non-mainnet networks.

**The Failpoint Architecture:**

The `fail_point_poem()` function wraps the `fail::fail_point!` macro to inject controlled failures at various points in the codebase. [1](#0-0) 

Failpoints are injected throughout critical code paths including:
- All major API endpoints (accounts, transactions, blocks, events, state) [2](#0-1) 
- Consensus message processing [3](#0-2) 
- Block execution [4](#0-3) 

**The Vulnerability:**

An HTTP GET endpoint `/v1/set_failpoint` is exposed that accepts arbitrary failpoint names and actions via query parameters. [5](#0-4) 

The endpoint handler calls `fail::cfg()` directly with user-supplied input without validation or authentication. [6](#0-5) 

**The Protection Gap:**

The config sanitizer only blocks failpoints on mainnet specifically. [7](#0-6) 

For testnet and devnet networks, if the node is accidentally built with `--features=failpoints` (as test builders do), and the config has `failpoints_enabled: true`, the endpoint becomes fully functional without authentication.

**Attack Scenario:**

1. Attacker identifies a testnet/devnet node built with failpoints enabled
2. Attacker sends: `GET /v1/set_failpoint?name=consensus::process::any&actions=return`
3. The node's consensus engine begins failing all message processing
4. Validator loses liveness and stops participating in consensus
5. Alternatively: `GET /v1/set_failpoint?name=api::endpoint_get_account&actions=return` crashes the account query endpoint

The attacker can configure ANY failpoint in the entire codebase, including those in consensus, execution, and storage layers, without authentication.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

**Total Loss of Liveness**: By triggering consensus failpoints like `consensus::process::any` or `consensus::start_new_epoch::disable_qs`, an attacker can prevent validators from processing blocks, causing complete network halt for affected nodes.

**API Crashes**: Triggering API endpoint failpoints causes all API queries to fail with internal errors, meeting the **High Severity** "API crashes" category.

**Consensus Protocol Violation**: Selectively triggering execution failpoints like `executor::block_executor_execute_block` can cause validators to fail block execution, violating consensus safety invariants.

The impact depends on how many nodes in the network are misconfigured with failpoints enabled, but even a single public RPC node compromise creates service disruption.

## Likelihood Explanation

**Moderate to Low Likelihood**, but **high impact when it occurs**:

**Factors increasing likelihood:**
- The forge test builder explicitly enables failpoints for local testing [8](#0-7) 
- If this build configuration is mistakenly used for testnet deployment, vulnerability activates
- No authentication barrier prevents external exploitation
- The endpoint is accessible via simple HTTP GET requests

**Factors decreasing likelihood:**
- Requires TWO misconfigurations: feature flag at build time AND config setting
- Default production builds don't enable failpoints
- Default API binding is localhost-only [9](#0-8) 
- The feature is clearly labeled for testing purposes

However, the question specifically asks about misconfigured builds, and the vulnerability is **guaranteed to exist** in that scenario.

## Recommendation

**Immediate Fixes:**

1. **Extend Config Sanitizer Protection**: Block failpoints on ALL networks, not just mainnet:

```rust
// config/src/config/config_sanitizer.rs, line 82-91
fn sanitize_failpoints_config(...) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints_enabled = are_failpoints_enabled();
    
    // Block failpoints on ALL production networks
    if let Some(chain_id) = chain_id {
        if failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on production networks!".into(),
            ));
        }
    }
    // ... rest of validation
}
```

2. **Add Authentication to Failpoint Endpoint**: Require authentication token or restrict to localhost-only access:

```rust
// api/src/set_failpoints.rs, line 23-40
pub fn set_failpoint_poem(...) -> poem::Result<String> {
    // Reject if not from localhost
    if !is_localhost_request(request) {
        return Err(poem::Error::from(anyhow::anyhow!(
            "Failpoint configuration only allowed from localhost"
        )));
    }
    
    if context.failpoints_enabled() {
        // ... existing logic
    }
}
```

3. **Implement Failpoint Allowlist**: Only allow configuration of approved failpoints, not arbitrary ones.

## Proof of Concept

**Setup:**
```bash
# Build node with failpoints (simulating misconfiguration)
cargo build --release --features=failpoints -p aptos-node

# Configure node with failpoints enabled
cat > node.yaml <<EOF
api:
  enabled: true
  address: "0.0.0.0:8080"  # Exposed to network
  failpoints_enabled: true  # Misconfigured
EOF

# Start testnet node (chain_id != 1 for mainnet)
./target/release/aptos-node --config node.yaml
```

**Exploitation:**
```bash
# Crash the get_account API endpoint
curl "http://<node-ip>:8080/v1/set_failpoint?name=api::endpoint_get_account&actions=return"

# Verify API is broken
curl "http://<node-ip>:8080/v1/accounts/0x1"
# Returns: {"message":"Failpoint unexpected internal error for endpoint_get_account",...}

# Disrupt consensus processing (if node is validator)
curl "http://<node-ip>:8080/v1/set_failpoint?name=consensus::process::any&actions=return"

# Node stops processing consensus messages, loses liveness
```

**Expected Result**: The node's API endpoints return failpoint errors, and consensus processing fails if targeted, causing loss of liveness.

---

**Notes:**

The vulnerability is **conditional** on build and configuration mismanagement, but when present, it's **fully exploitable** without authentication. The primary security failure is that the config sanitizer's mainnet-only check creates a false sense of security for testnet/devnet operators, who may inadvertently deploy test builds to production testnet environments. The lack of authentication on the endpoint compounds the risk by removing any access control barrier.

### Citations

**File:** api/src/failpoint.rs (L14-23)
```rust
pub fn fail_point_poem<E: InternalError>(name: &str) -> Result<(), E> {
    fail::fail_point!(format!("api::{}", name).as_str(), |_| {
        Err(E::internal_with_code_no_info(
            format!("Failpoint unexpected internal error for {}", name),
            AptosErrorCode::InternalError,
        ))
    });

    Ok(())
}
```

**File:** api/src/accounts.rs (L66-66)
```rust
        fail_point_poem("endpoint_get_account")?;
```

**File:** consensus/src/epoch_manager.rs (L1533-1535)
```rust
        fail_point!("consensus::process::any", |_| {
            Err(anyhow::anyhow!("Injected error in process_message"))
        });
```

**File:** execution/executor/src/block_executor/mod.rs (L236-240)
```rust
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
                });
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L27-29)
```rust
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
```

**File:** config/src/config/config_sanitizer.rs (L82-91)
```rust
    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
```

**File:** testsuite/forge/src/backend/local/cargo.rs (L168-170)
```rust
        vec!["build", "--features=failpoints,smoke-test"]
    } else {
        vec!["build", "--features=failpoints,indexer,smoke-test"]
```

**File:** config/src/config/api_config.rs (L95-96)
```rust
const DEFAULT_ADDRESS: &str = "127.0.0.1";
const DEFAULT_PORT: u16 = 8080;
```
