# Audit Report

## Title
Governance Proposals Race Condition Causes JWK Patch State Corruption via Complete Replacement

## Summary
Multiple governance proposals that modify JWK patches can execute in the same block due to Aptos's BlockSTM parallel execution. The `set_patches` function performs a complete replacement of the global `Patches` resource rather than a merge operation, causing the last proposal to commit to completely overwrite previous proposals' patches. This results in loss of approved governance decisions and corruption of the JWK state.

## Finding Description

The vulnerability exists in the `set_patches` function which is called by governance proposals to update JWK patches: [1](#0-0) 

This function performs a **complete replacement** of the `Patches` resource, not an append or merge operation. The critical line is: [2](#0-1) 

The `Patches` resource is a singleton stored at `@aptos_framework`: [3](#0-2) 

**Attack Scenario:**

1. **Two Independent Governance Proposals**: Governance Proposal A (ID=100) is approved to add patches `[PatchA1, PatchA2]` to address a security issue. Governance Proposal B (ID=101) is approved to add patches `[PatchB1]` for a separate JWK update.

2. **Concurrent Resolution**: Both proposals are resolved (executed) in the same block. Each proposal has its own independent `is_resolved` flag: [4](#0-3) 

3. **BlockSTM Parallel Execution**: Aptos uses BlockSTM for parallel transaction execution within blocks: [5](#0-4) 

Both resolution transactions execute speculatively:
- Transaction A executes: `set_patches(fx, [PatchA1, PatchA2])` → sets `Patches.patches = [PatchA1, PatchA2]`
- Transaction B executes: `set_patches(fx, [PatchB1])` → sets `Patches.patches = [PatchB1]`

4. **Validation and Commit**: One transaction commits first (say A), then B validates. If B's read-set is invalidated, it re-executes after seeing A's changes. Regardless, when B commits, it performs a complete replacement:
   - Final state: `Patches.patches = [PatchB1]`
   - **Lost**: `[PatchA1, PatchA2]` from Proposal A

5. **State Corruption**: The `regenerate_patched_jwks()` function only applies the patches from Proposal B: [6](#0-5) 

Proposal A's approved governance decision is completely lost, corrupting the JWK state.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** based on Aptos bug bounty criteria:

1. **Governance Integrity Violation**: Approved governance proposals lose their effect, undermining the democratic decision-making process.

2. **State Inconsistency**: The final JWK state does not reflect all approved governance decisions, violating the "State Consistency" invariant that state transitions should preserve all committed operations.

3. **Security Implications**: If Proposal A was critical (e.g., removing a compromised JWK) and Proposal B was routine (e.g., adding a new provider), the security-critical operation could be lost while the routine operation succeeds.

4. **Consensus Impact**: While execution is deterministic (based on transaction order), the semantic correctness is violated - validators agree on wrong state that doesn't reflect governance intent.

This meets the "Significant protocol violations" criterion for High severity, as it breaks fundamental governance guarantees.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

- **Frequency**: Governance proposals that modify JWK patches are relatively common for managing OIDC provider keys.
- **Concurrency Window**: Proposals can accumulate while waiting for voting periods to complete, then multiple proposals may be ready to resolve simultaneously.
- **No Coordination Mechanism**: There is no locking, queuing, or serialization mechanism to prevent concurrent `set_patches` calls.
- **Natural Occurrence**: This can happen without malicious intent - two legitimate governance participants resolving approved proposals in the same block period.
- **Validator Behavior**: With BlockSTM's parallel execution enabled by default, this race condition can manifest in production.

## Recommendation

Replace the complete replacement pattern with a merge/append operation. Modify `set_patches` to:

1. **Option 1: Append Operation** - Add new patches to existing patches:
```move
public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    let existing_patches = &mut borrow_global_mut<Patches>(@aptos_framework).patches;
    vector::append(existing_patches, patches);
    regenerate_patched_jwks();
}
```

2. **Option 2: Versioning/Sequencing** - Add a version counter to prevent overwrites:
```move
struct Patches has key {
    patches: vector<Patch>,
    version: u64,
}

public fun set_patches(fx: &signer, patches: vector<Patch>, expected_version: u64) acquires Patches, PatchedJWKs, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    let patches_resource = borrow_global_mut<Patches>(@aptos_framework);
    assert!(patches_resource.version == expected_version, ERROR_VERSION_MISMATCH);
    vector::append(&mut patches_resource.patches, patches);
    patches_resource.version = patches_resource.version + 1;
    regenerate_patched_jwks();
}
```

3. **Option 3: Proposal-Level Tracking** - Track which proposals have contributed patches to prevent duplicates while preserving all approved changes.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_concurrent_set_patches_data_loss(aptos_framework: signer) acquires Patches, PatchedJWKs, ObservedJWKs {
    use std::string::utf8;
    initialize_for_test(&aptos_framework);
    
    // Initial state: empty patches
    assert!(vector::length(&borrow_global<Patches>(@aptos_framework).patches) == 0, 1);
    
    // Governance Proposal A: Add critical security patches
    let security_jwk = new_rsa_jwk(
        utf8(b"security_key"),
        utf8(b"RS256"),
        utf8(b"AQAB"),
        utf8(b"security_modulus")
    );
    let security_patches = vector[
        new_patch_remove_issuer(b"compromised_issuer"),
        new_patch_upsert_jwk(b"secure_issuer", security_jwk)
    ];
    
    // Simulate Proposal A execution
    set_patches(&aptos_framework, security_patches);
    
    // Verify Proposal A's patches are applied
    assert!(vector::length(&borrow_global<Patches>(@aptos_framework).patches) == 2, 2);
    
    // Governance Proposal B: Add routine JWK update (simulating concurrent execution)
    let routine_jwk = new_rsa_jwk(
        utf8(b"routine_key"),
        utf8(b"RS256"),
        utf8(b"AQAB"),
        utf8(b"routine_modulus")
    );
    let routine_patches = vector[new_patch_upsert_jwk(b"routine_issuer", routine_jwk)];
    
    // Simulate Proposal B execution (overwrites Proposal A)
    set_patches(&aptos_framework, routine_patches);
    
    // BUG DEMONSTRATED: Proposal A's patches are lost!
    let final_patches = &borrow_global<Patches>(@aptos_framework).patches;
    assert!(vector::length(final_patches) == 1, 3); // Only Proposal B's patch remains
    
    // CRITICAL: The security-critical removal of compromised_issuer is lost
    // The secure_issuer addition is also lost
    // Only the routine update remains - GOVERNANCE CORRUPTION!
}
```

**Notes**

This vulnerability is a **design flaw** in the `set_patches` function, not a Move VM or BlockSTM bug. The complete replacement pattern combined with Aptos's parallel execution creates a critical race condition. While BlockSTM ensures deterministic execution order, the semantic correctness is violated because approved governance decisions are lost. This breaks the fundamental "Governance Integrity" invariant that all succeeded proposals should have their intended effects applied to chain state.

The issue is exacerbated by the fact that JWK patches are security-critical - they control which cryptographic keys are trusted for keyless account authentication. Loss of security-critical patches (e.g., removing compromised keys) while preserving routine patches creates a serious security risk beyond mere governance integrity violations.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L160-162)
```text
    struct Patches has key {
        patches: vector<Patch>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L379-383)
```text
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L523-531)
```text
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L440-440)
```text
        assert!(!proposal.is_resolved, error::invalid_state(EPROPOSAL_ALREADY_RESOLVED));
```

**File:** aptos-move/block-executor/src/lib.rs (L5-40)
```rust
The high level parallel execution logic is implemented in 'executor.rs'. The
input of parallel executor is a block of transactions, containing a sequence
of n transactions tx_1, tx_2, ..., tx_n (this defines the preset serialization
order tx_1< tx_2< ...<tx_n).

Each transaction might be executed several times and we refer to the i-th
execution as incarnation i of a transaction. We say that an incarnation is
aborted when the system decides that a subsequent re-execution with an incremented
incarnation number is needed. A version is a pair of a transaction index and
an incarnation number. To support reads and writes by transactions that may
execute concurrently, parallel execution maintains an in-memory multi-version
data structure that separately stores for each memory location the latest value
written per transaction, along with the associated transaction version.
This data structure is implemented in: '../../mvhashmap/src/lib.rs'.
When transaction tx reads a memory location, it obtains from the multi-version
data-structure the value written to this location by the highest transaction
that appears before tx in the preset serialization order, along with the
associated version. For example, transaction tx_5 can read a value written
by transaction tx_3 even if transaction tx_6 has written to same location.
If no smaller transaction has written to a location, then the read
(e.g. all reads by tx_1) is resolved from storage based on the state before
the block execution.

For each incarnation, parallel execution maintains a write-set and a read-set
in 'txn_last_input_output.rs'. The read-set contains the memory locations that
are read during the incarnation, and the corresponding versions. The write-set
describes the updates made by the incarnation as (memory location, value) pairs.
The write-set of the incarnation is applied to shared memory (the multi-version
data-structure) at the end of execution. After an incarnation executes it needs
to pass validation. The validation re-reads the read-set and compares the
observed versions. Intuitively, a successful validation implies that writes
applied by the incarnation are still up-to-date, while a failed validation implies
that the incarnation has to be aborted. For instance, if the transaction was
speculatively executed and read value x=2, but later validation observes x=3,
the results of the transaction execution are no longer applicable and must
be discarded, while the transaction is marked for re-execution.
```
