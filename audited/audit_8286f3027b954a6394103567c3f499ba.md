# Audit Report

## Title
Safety Rules Service Memory Exhaustion via Unbounded OrderVoteProposal Deserialization

## Summary
The safety rules service deserializes `OrderVoteProposal` messages from the consensus node without any size validation, allowing memory exhaustion attacks when processing legitimately-large blocks, potentially causing validator node slowdowns and consensus disruption.

## Finding Description

The safety rules service receives `OrderVoteProposal` messages via JSON deserialization with no size limits. When a consensus node sends an `OrderVoteProposal` containing a Block with maximum allowed transactions (10,000 by default), the JSON representation can exceed 100MB. The deserialization process allocates memory without bounds, potentially exhausting available memory.

**Attack Flow:**

1. A Byzantine validator proposes a block with 10,000 transactions (within `max_receiving_block_txns` limit)
2. Honest validators receive and validate this block in `process_proposal()` [1](#0-0) 
3. Each validator creates an `OrderVoteProposal` containing the full Block [2](#0-1) 
4. The `OrderVoteProposal` is serialized to JSON and sent to the remote safety rules service [3](#0-2) 
5. Safety rules service calls `serde_json::from_slice(&input_message)` with no size validation [4](#0-3) 
6. Large memory allocation during deserialization causes slowdown or OOM

**Key Vulnerability Points:**

The `OrderVoteProposal` struct contains a full `Block` with `Payload` [5](#0-4) 

The `Payload` enum can contain `DirectMempool(Vec<SignedTransaction>)` with up to 10,000 transactions [6](#0-5) 

The network layer only rejects messages >= 4GB [7](#0-6) 

The safety rules service performs no size validation before JSON deserialization [8](#0-7) 

The safety rules verification only checks epoch, QC consistency, and signatures - not payload size [9](#0-8) 

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria ("Validator node slowdowns"). When multiple validators receive maximally-sized blocks:

- Each validator's safety rules service experiences memory pressure during deserialization
- Memory exhaustion causes service slowdowns or crashes
- Without safety rules, validators cannot sign votes
- Consensus liveness degrades or halts if sufficient validators are affected
- Recovery requires restarting affected safety rules services

The impact is limited to resource exhaustion rather than consensus safety violations, but can significantly disrupt network operation.

## Likelihood Explanation

**Medium-High Likelihood:**

- Any validator can propose blocks up to `max_receiving_block_txns` (10,000) legitimately
- High transaction throughput scenarios naturally create large blocks
- No malicious intent required - normal operation with maximum load triggers the issue
- JSON serialization amplifies size (text encoding, field names, whitespace)
- All validators using remote safety rules are affected simultaneously
- The default configuration is vulnerable with no size limits

## Recommendation

Add size validation before deserializing `OrderVoteProposal` messages in the safety rules service:

```rust
// In consensus/safety-rules/src/serializer.rs
pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
    // Add maximum message size check (e.g., 50MB)
    const MAX_MESSAGE_SIZE: usize = 50 * 1024 * 1024;
    if input_message.len() > MAX_MESSAGE_SIZE {
        return Err(Error::SerializationError(format!(
            "Message size {} exceeds maximum allowed {}",
            input_message.len(),
            MAX_MESSAGE_SIZE
        )));
    }
    
    let input = serde_json::from_slice(&input_message)?;
    // ... rest of handling
}
```

Additionally, consider:
1. Using binary serialization (BCS) instead of JSON for better efficiency
2. Implementing streaming deserialization for large messages  
3. Adding recursion depth limits to prevent stack overflow
4. Monitoring and alerting on large message sizes

## Proof of Concept

```rust
// Reproduction steps:
// 1. Configure safety rules in remote service mode
// 2. Create a block with max_receiving_block_txns transactions (10,000)
// 3. Each transaction ~500 bytes = 5MB raw data
// 4. JSON serialization amplifies to ~20-50MB
// 5. Send OrderVoteProposal containing this block
// 6. Observe memory allocation spike in safety rules service

use aptos_consensus_types::{
    block::Block,
    block_data::BlockData,
    common::Payload,
    order_vote_proposal::OrderVoteProposal,
    quorum_cert::QuorumCert,
};
use aptos_types::transaction::SignedTransaction;

// Create maximally-sized payload
let mut txns = Vec::new();
for _ in 0..10000 {
    txns.push(SignedTransaction::dummy()); // ~500 bytes each
}
let payload = Payload::DirectMempool(txns);

// Create block with maximum payload
let block_data = BlockData::new_proposal(
    payload,
    author,
    vec![],
    round,
    timestamp,
    quorum_cert.clone(),
);
let block = Block::new_proposal_from_block_data(block_data, &signer)?;

// Create OrderVoteProposal
let order_vote_proposal = OrderVoteProposal::new(
    block,
    block_info,
    Arc::new(quorum_cert),
);

// Serialize to JSON - this will be 20-50MB
let json_bytes = serde_json::to_vec(&order_vote_proposal)?;
println!("OrderVoteProposal JSON size: {} MB", json_bytes.len() / 1024 / 1024);

// Send to safety rules service - causes memory exhaustion
// safety_rules_client.construct_and_sign_order_vote(&order_vote_proposal)?;
```

**Note:** This issue requires validator privileges to propose large blocks through normal consensus, limiting exploitability by truly unprivileged attackers. However, it represents a defense-in-depth issue that should be addressed to prevent resource exhaustion under legitimate high-load scenarios.

### Citations

**File:** consensus/src/round_manager.rs (L1111-1193)
```rust
    async fn process_proposal(&mut self, proposal: Block) -> anyhow::Result<()> {
        let author = proposal
            .author()
            .expect("Proposal should be verified having an author");

        if !self.vtxn_config.enabled()
            && matches!(
                proposal.block_data().block_type(),
                BlockType::ProposalExt(_)
            )
        {
            counters::UNEXPECTED_PROPOSAL_EXT_COUNT.inc();
            bail!("ProposalExt unexpected while the vtxn feature is disabled.");
        }

        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }

        let (num_validator_txns, validator_txns_total_bytes): (usize, usize) =
            proposal.validator_txns().map_or((0, 0), |txns| {
                txns.iter().fold((0, 0), |(count_acc, size_acc), txn| {
                    (count_acc + 1, size_acc + txn.size_in_bytes())
                })
            });

        let num_validator_txns = num_validator_txns as u64;
        let validator_txns_total_bytes = validator_txns_total_bytes as u64;
        let vtxn_count_limit = self.vtxn_config.per_block_limit_txn_count();
        let vtxn_bytes_limit = self.vtxn_config.per_block_limit_total_bytes();
        let author_hex = author.to_hex();
        PROPOSED_VTXN_COUNT
            .with_label_values(&[&author_hex])
            .inc_by(num_validator_txns);
        PROPOSED_VTXN_BYTES
            .with_label_values(&[&author_hex])
            .inc_by(validator_txns_total_bytes);
        info!(
            vtxn_count_limit = vtxn_count_limit,
            vtxn_count_proposed = num_validator_txns,
            vtxn_bytes_limit = vtxn_bytes_limit,
            vtxn_bytes_proposed = validator_txns_total_bytes,
            proposer = author_hex,
            "Summarizing proposed validator txns."
        );

        ensure!(
            num_validator_txns <= vtxn_count_limit,
            "process_proposal failed with per-block vtxn count limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_txn_count(),
            num_validator_txns
        );
        ensure!(
            validator_txns_total_bytes <= vtxn_bytes_limit,
            "process_proposal failed with per-block vtxn bytes limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_total_bytes(),
            validator_txns_total_bytes
        );
        let payload_len = proposal.payload().map_or(0, |payload| payload.len());
        let payload_size = proposal.payload().map_or(0, |payload| payload.size());
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L72-81)
```rust
impl TSerializerClient for RemoteClient {
    fn request(&mut self, input: SafetyRulesInput) -> Result<Vec<u8>, Error> {
        let input_message = serde_json::to_vec(&input)?;
        loop {
            match self.process_one_message(&input_message) {
                Err(err) => warn!("Failed to communicate with SafetyRules service: {}", err),
                Ok(value) => return Ok(value),
            }
        }
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L45-52)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;

        let output = match input {
            SafetyRulesInput::ConsensusState => {
                serde_json::to_vec(&self.internal.consensus_state())
            },
            SafetyRulesInput::Initialize(li) => serde_json::to_vec(&self.internal.initialize(&li)),
```

**File:** consensus/consensus-types/src/order_vote_proposal.rs (L14-22)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderVoteProposal {
    #[serde(bound(deserialize = "Block: Deserialize<'de>"))]
    block: Block,
    /// BlockInfo for the above block
    block_info: BlockInfo,
    /// QuorumCert for the above block
    quorum_cert: Arc<QuorumCert>,
}
```

**File:** consensus/consensus-types/src/common.rs (L207-224)
```rust
/// The payload in block.
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub enum Payload {
    DirectMempool(Vec<SignedTransaction>),
    InQuorumStore(ProofWithData),
    InQuorumStoreWithLimit(ProofWithDataWithTxnLimit),
    QuorumStoreInlineHybrid(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        Option<u64>,
    ),
    OptQuorumStore(OptQuorumStorePayload),
    QuorumStoreInlineHybridV2(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        PayloadExecutionLimit,
    ),
}
```

**File:** secure/net/src/lib.rs (L459-464)
```rust
    pub fn write(&mut self, data: &[u8]) -> Result<(), Error> {
        let u32_max = u32::MAX as usize;
        if u32_max <= data.len() {
            return Err(Error::DataTooLarge(data.len()));
        }
        let data_len = data.len() as u32;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```
