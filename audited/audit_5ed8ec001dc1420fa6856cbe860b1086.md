# Audit Report

## Title
Indexer Crash Due to Unhandled Deserialization Errors in Stake Transaction Processing

## Summary
The stake processor's `process_transactions()` function uses `.unwrap()` on potentially-failing parsing operations, causing the indexer to panic and crash when encountering malformed stake pool data in blockchain transactions, resulting in a complete denial of service for the indexer API.

## Finding Description

The vulnerability exists in the stake processor's transaction processing pipeline where multiple `.unwrap()` calls are used on `Result` types that can fail when deserializing malformed stake pool resources. [1](#0-0) 

The critical code path flows as follows:

1. **Entry point**: The processor calls `CurrentStakingPoolVoter::from_transaction(txn).unwrap()` which panics if an error is returned.

2. **Parsing layer**: The function attempts to deserialize WriteResource data into a specific `StakePoolResource` struct: [2](#0-1) 

3. **Expected structure**: The deserialization requires specific fields: [3](#0-2) 

**Attack Scenario:**

If a blockchain transaction contains a WriteResource with type `0x1::stake::StakePool` but the data is malformed (missing `delegated_voter` or `operator_address` fields, or they have incorrect types), the following occurs:

1. The REST API layer successfully deserializes the WriteResource into a generic `MoveResource` (since it uses permissive JSON object parsing): [4](#0-3) 

2. The indexer's stake processor attempts to deserialize this into the specific `StakePoolResource` struct via `serde_json::from_value()`, which fails

3. The error propagates through the call stack: [5](#0-4) 

4. When the error reaches line 337's `.unwrap()`, a **panic** occurs, crashing the indexer process

**Malformed Data Sources:**
- Genesis transaction with incorrectly configured stake pools
- Move VM bug allowing invalid stake pool resource writes  
- Storage corruption or network transmission errors
- Malicious fullnode serving corrupted data to indexer

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty "API crashes" category)

The indexer is a critical infrastructure component that:
- Provides the REST API for querying blockchain state
- Enables wallet applications, explorers, and DApps to function
- Processes all on-chain transactions sequentially

A crash results in:
1. **Complete indexer unavailability** - the process terminates or hangs at the problematic transaction version
2. **Inability to progress** - the indexer cannot skip the malformed transaction and remains stuck
3. **API service disruption** - all dependent applications lose access to blockchain data
4. **Manual intervention required** - operators must identify, patch, and restart the indexer

While this does not affect consensus or validator operations, it breaks a critical availability invariant for the blockchain's query infrastructure.

## Likelihood Explanation

**Likelihood: MEDIUM-LOW**

The attack requires one of these conditions:
- A bug in the Move VM or genesis generation that writes malformed stake pool data (LOW probability in production)
- Storage/network corruption affecting transaction data (VERY LOW probability with checksums/validation)
- Malicious fullnode serving corrupted data to indexer (MEDIUM probability if indexer trusts untrusted nodes)

However, if malformed data does exist on-chain (e.g., from a genesis configuration error or VM bug), the vulnerability is **guaranteed** to trigger, causing immediate and persistent indexer failure.

The presence of similar `.unwrap()` calls on lines 339, 343, 348, and 353 amplifies the attack surface: [6](#0-5) 

## Recommendation

Replace all `.unwrap()` calls with proper error handling that returns `TransactionProcessingError`:

```rust
async fn process_transactions(
    &self,
    transactions: Vec<APITransaction>,
    start_version: u64,
    end_version: u64,
) -> Result<ProcessingResult, TransactionProcessingError> {
    let mut conn = self.get_conn();
    // ... initialization ...

    for txn in &transactions {
        // Add votes data - handle errors gracefully
        let current_stake_pool_voter = CurrentStakingPoolVoter::from_transaction(txn)
            .map_err(|e| TransactionProcessingError::TransactionCommitError((
                e,
                start_version,
                end_version,
                self.name(),
            )))?;
        all_current_stake_pool_voters.extend(current_stake_pool_voter);
        
        let mut proposal_votes = ProposalVote::from_transaction(txn)
            .map_err(|e| TransactionProcessingError::TransactionCommitError((
                e,
                start_version,
                end_version,
                self.name(),
            )))?;
        all_proposal_votes.append(&mut proposal_votes);
        
        // Apply same pattern to lines 343, 348, 353
        // ...
    }
    // ... rest of function ...
}
```

The error handling framework already exists: [7](#0-6) 

This allows the indexer to log the error, mark the transaction as failed in the database, and potentially implement retry or skip logic rather than crashing.

## Proof of Concept

```rust
#[cfg(test)]
mod test_malformed_stake_pool {
    use super::*;
    use aptos_api_types::{
        Transaction as APITransaction, UserTransaction, TransactionInfo,
        WriteSetChange, WriteResource, MoveResource as APIMoveResource,
        MoveStructTag, MoveStructValue, Address,
    };
    use std::collections::BTreeMap;
    
    #[test]
    #[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
    fn test_malformed_stake_pool_causes_panic() {
        // Create a malformed StakePool resource missing required fields
        let mut malformed_data = BTreeMap::new();
        // Missing 'delegated_voter' and 'operator_address' fields
        malformed_data.insert(
            IdentifierWrapper::from_str("invalid_field").unwrap(),
            serde_json::json!("some_value")
        );
        
        let write_resource = WriteResource {
            address: Address::from_str("0x1").unwrap(),
            state_key_hash: "0xabc123".to_string(),
            data: APIMoveResource {
                typ: MoveStructTag::from_str("0x1::stake::StakePool").unwrap(),
                data: MoveStructValue(malformed_data),
            },
        };
        
        let txn_info = TransactionInfo {
            version: 1000.into(),
            hash: "0xdef456".parse().unwrap(),
            state_change_hash: "0x789abc".parse().unwrap(),
            event_root_hash: "0x012def".parse().unwrap(),
            state_checkpoint_hash: None,
            gas_used: 100.into(),
            success: true,
            vm_status: "Executed successfully".to_string(),
            accumulator_root_hash: "0x345678".parse().unwrap(),
            changes: vec![WriteSetChange::WriteResource(write_resource)],
            epoch: None,
            block_height: None,
            timestamp: None,
        };
        
        let user_txn = UserTransaction {
            info: txn_info,
            // ... other required fields ...
        };
        
        let api_txn = APITransaction::UserTransaction(Box::new(user_txn));
        
        // This will panic due to .unwrap() on line 337
        let _ = CurrentStakingPoolVoter::from_transaction(&api_txn).unwrap();
    }
}
```

## Notes

To answer the security question directly: **`CurrentStakingPoolVoter::from_transaction()` DOES return `Err()` when encountering malformed WriteSetChanges**, but the `.unwrap()` call at line 337 converts this error into a **panic**, crashing the indexer instead of allowing graceful error handling.

This vulnerability affects not just line 337, but also lines 339, 343, 348, and 353 in the same function, all of which use `.unwrap()` on potentially-failing parsing operations. All should be fixed to use proper error propagation via the `?` operator or `.map_err()`.

### Citations

**File:** crates/indexer/src/processors/stake_processor.rs (L337-337)
```rust
            let current_stake_pool_voter = CurrentStakingPoolVoter::from_transaction(txn).unwrap();
```

**File:** crates/indexer/src/processors/stake_processor.rs (L339-353)
```rust
            let mut proposal_votes = ProposalVote::from_transaction(txn).unwrap();
            all_proposal_votes.append(&mut proposal_votes);

            // Add delegator activities
            let mut delegator_activities = DelegatedStakingActivity::from_transaction(txn).unwrap();
            all_delegator_activities.append(&mut delegator_activities);

            // Add delegator balances
            let delegator_balances =
                CurrentDelegatorBalance::from_transaction(txn, &mut conn).unwrap();
            all_delegator_balances.extend(delegator_balances);

            // Add delegator pools
            let (delegator_pools, mut delegator_pool_balances, current_delegator_pool_balances) =
                DelegatorPool::from_transaction(txn).unwrap();
```

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L10-14)
```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StakePoolResource {
    pub delegated_voter: String,
    pub operator_address: String,
}
```

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L128-144)
```rust
    fn from_resource(data_type: &str, data: &serde_json::Value, txn_version: i64) -> Result<Self> {
        match data_type {
            "0x1::stake::StakePool" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeResource::StakePool(inner))),
            "0x1::delegation_pool::DelegationPool" => serde_json::from_value(data.clone())
                .map(|inner| Some(StakeResource::DelegationPool(inner))),
            _ => Ok(None),
        }
        .context(format!(
            "version {} failed! failed to parse type {}, data {:?}",
            txn_version, data_type, data
        ))?
        .context(format!(
            "Resource unsupported! Call is_resource_supported first. version {} type {}",
            txn_version, data_type
        ))
    }
```

**File:** crates/indexer/src/models/move_resources.rs (L36-56)
```rust
    pub fn from_write_resource(
        write_resource: &WriteResource,
        write_set_change_index: i64,
        transaction_version: i64,
        transaction_block_height: i64,
    ) -> Self {
        let parsed_data = Self::convert_move_struct_tag(&write_resource.data.typ);
        Self {
            transaction_version,
            transaction_block_height,
            write_set_change_index,
            type_: write_resource.data.typ.to_string(),
            name: parsed_data.name.clone(),
            address: standardize_address(&write_resource.address.to_string()),
            module: parsed_data.module.clone(),
            generic_type_params: parsed_data.generic_type_params,
            data: Some(serde_json::to_value(&write_resource.data.data).unwrap()),
            is_deleted: false,
            state_key_hash: standardize_address(write_resource.state_key_hash.as_str()),
        }
    }
```

**File:** crates/indexer/src/models/stake_models/staking_pool_voter.rs (L28-61)
```rust
    pub fn from_transaction(transaction: &APITransaction) -> anyhow::Result<StakingPoolVoterMap> {
        let mut staking_pool_voters = HashMap::new();
        let empty_change = vec![];
        let (txn_version, changes) = match transaction {
            APITransaction::UserTransaction(txn) => (txn.info.version.0 as i64, &txn.info.changes),
            APITransaction::GenesisTransaction(txn) => {
                (txn.info.version.0 as i64, &txn.info.changes)
            },
            APITransaction::BlockMetadataTransaction(txn) => {
                (txn.info.version.0 as i64, &txn.info.changes)
            },
            _ => (0, &empty_change),
        };
        for wsc in changes {
            if let APIWriteSetChange::WriteResource(write_resource) = wsc {
                if let Some(StakeResource::StakePool(inner)) =
                    StakeResource::from_write_resource(write_resource, txn_version)?
                {
                    let staking_pool_address =
                        standardize_address(&write_resource.address.to_string());
                    let operator_address = standardize_address(&inner.operator_address);
                    let voter_address = standardize_address(&inner.delegated_voter);
                    staking_pool_voters.insert(staking_pool_address.clone(), Self {
                        staking_pool_address,
                        voter_address,
                        last_transaction_version: txn_version,
                        operator_address,
                    });
                }
            }
        }

        Ok(staking_pool_voters)
    }
```

**File:** crates/indexer/src/indexer/transaction_processor.rs (L133-143)
```rust
    /// Writes that a version has errored for this `TransactionProcessor` to the DB
    fn update_status_err(&self, tpe: &TransactionProcessingError) {
        aptos_logger::debug!(
            "[{}] Marking processing version Err: {:?}",
            self.name(),
            tpe
        );
        PROCESSOR_ERRORS.with_label_values(&[self.name()]).inc();
        let psm = ProcessorStatusModel::from_transaction_processing_err(tpe);
        self.apply_processor_status(&psm);
    }
```
