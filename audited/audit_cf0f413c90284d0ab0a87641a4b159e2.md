# Audit Report

## Title
EventKey Structure Modification Causes Consensus Split During Partial Protocol Upgrades

## Summary
The `EventKey` Rust struct lacks versioning and backward compatibility mechanisms. If its field structure is modified during a protocol upgrade, validators running different binary versions will deserialize on-chain EventKey GUIDs differently, producing different event hashes and causing a consensus split requiring a hard fork to resolve.

## Finding Description

The vulnerability exists in the interaction between EventKey serialization and the event emission system during protocol upgrades.

**Core Issue Location:**

The `EventKey` struct is defined without versioning: [1](#0-0) 

Unlike `ContractEvent` which has explicit V1/V2 variants for compatibility, `EventKey` has no such protection: [2](#0-1) 

**Attack Chain:**

1. **EventKey Storage**: EventKey instances are stored on-chain as BCS-serialized bytes within GUID fields of EventHandle resources, which are widely used across critical framework modules: [3](#0-2) [4](#0-3) 

2. **Deserialization During Event Emission**: When a transaction emits an event, the native function deserializes the GUID bytes: [5](#0-4) 

3. **Event Hashing**: The deserialized EventKey becomes part of `ContractEventV1`, which is then hashed: [6](#0-5) 

4. **Consensus Integration**: Event hashes contribute to `event_root_hash` in `TransactionInfo`, which is part of the consensus-critical state commitment.

**Consensus Split Scenario:**

During a protocol upgrade where EventKey fields are modified (e.g., adding a field):

- **Old validators**: Deserialize existing on-chain GUIDs using old EventKey definition → Success → Compute event_hash_A → Transaction succeeds with state_root_A

- **New validators**: Attempt to deserialize with new EventKey definition → Either:
  - Deserialization fails with `EVENT_KEY_MISMATCH` error → Transaction aborts
  - Deserialization succeeds but produces different EventKey values → Compute event_hash_B → Transaction succeeds with state_root_B

This violates the **Deterministic Execution** invariant: validators must produce identical state roots for identical blocks.

**Critical Framework Usage:**

EventHandle (containing EventKey) is used in over 67 Move source files, including:
- Staking operations (`stake.move` - 48 matches)
- Governance voting (`aptos_governance.move` - 13 matches)  
- Account management (`account.move` - 13 matches)
- Coin operations (`coin.move` - 7 matches)

Any transaction interacting with these modules during a partial upgrade triggers the vulnerability.

## Impact Explanation

**Severity: CRITICAL** ($1,000,000 tier per Aptos Bug Bounty)

This meets the Critical severity criteria:

1. **Consensus/Safety Violations**: Different validators compute different state roots for the same block, breaking consensus safety guarantees.

2. **Non-Recoverable Network Partition**: Once validators diverge on transaction outcomes, they cannot reconcile without a coordinated hard fork to:
   - Agree on which chain is canonical
   - Force all validators to upgrade to compatible binaries
   - Potentially revert transactions

3. **Widespread Impact**: Affects ALL validators during any partial upgrade period where EventKey structure changes. Given EventHandle's pervasive use across critical framework modules, the issue is triggered immediately by normal network operations.

4. **Breaks Fundamental Invariants**: Violates both "Deterministic Execution" (identical blocks → identical state roots) and "Consensus Safety" (prevents chain splits).

The lack of any versioning mechanism on EventKey (unlike ContractEvent's V1/V2 system) means there is NO safe way to modify its structure during protocol evolution without introducing this vulnerability.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Preconditions:**
1. Protocol upgrade that modifies EventKey Rust struct (developer action)
2. Staggered validator upgrades (standard procedure)
3. Event-emitting transaction during partial upgrade (happens constantly)

**Likelihood Factors:**

- **Current Stability**: EventKey has remained stable with 2 fields (`creation_number`, `account_address`), suggesting low historical change frequency.

- **Future Risk**: Any protocol enhancement requiring EventKey modifications (e.g., adding security metadata, optimization fields, or versioning support itself) would trigger this vulnerability.

- **Upgrade Windows**: Aptos validators typically upgrade gradually over hours/days during protocol updates, creating extended windows of vulnerability.

- **Transaction Frequency**: Events are emitted continuously by staking, governance, coin transfers, and account operations. First relevant transaction during partial upgrade guarantees triggering.

- **No Safeguards**: Unlike Move module upgrades which have compatibility checks, Rust protocol type changes have no automated validation preventing this scenario.

The vulnerability is not currently exploited because EventKey hasn't been modified, but the absence of protective mechanisms means any future modification creates an immediate critical risk.

## Recommendation

**Immediate Mitigation:**

1. **Add EventKey Versioning**: Introduce an enum wrapper similar to ContractEvent:

```rust
// types/src/event.rs
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum EventKey {
    V1(EventKeyV1),
    // Future versions can be added without breaking compatibility
}

#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct EventKeyV1 {
    creation_number: u64,
    account_address: AccountAddress,
}
```

2. **Feature Flag Protection**: Add a feature flag that must be enabled network-wide before new EventKey versions can be used: [7](#0-6) 

3. **Migration Path**: For existing on-chain GUIDs:
   - Deserialize old bytes as EventKey::V1
   - Serialize back using versioned format on next write
   - Ensure all validators support EventKey::V1 before enabling new versions

4. **Compatibility Validation**: Add compile-time or genesis checks ensuring EventKey deserialization compatibility across protocol versions.

**Long-term Solution:**

Implement comprehensive protocol type versioning infrastructure with automated compatibility testing during CI/CD, preventing similar issues with other consensus-critical Rust types.

## Proof of Concept

**Reproduction Steps:**

1. **Setup**: Deploy 4 validators running current Aptos binaries

2. **Modify EventKey**: In `types/src/event.rs`, add a new field:
```rust
pub struct EventKey {
    creation_number: u64,
    account_address: AccountAddress,
    epoch: u64,  // NEW FIELD
}
```

3. **Partial Upgrade**: Upgrade 2 validators to the modified binary, leaving 2 on original binary

4. **Trigger Event**: Submit a transaction that emits an event using an existing EventHandle (e.g., governance vote, coin transfer):
```move
// Example: Simple coin transfer which emits withdraw/deposit events
aptos_framework::coin::transfer<AptosCoin>(sender, recipient, 100);
```

5. **Observe Split**:
   - Old validators: Transaction succeeds, computes state_root_A
   - New validators: bcs::from_bytes fails on old GUID bytes → EVENT_KEY_MISMATCH error → Transaction fails OR produces state_root_B
   - Validators cannot reach consensus on block commitment
   - Network partition occurs

**Expected Result**: Consensus stalls or splits, validators on different versions reject each other's blocks due to mismatched state roots.

**Alternative Test** (without actual deployment): Create a Rust integration test that:
1. Serializes EventKey with original structure
2. Modifies EventKey definition
3. Attempts deserialization of old bytes
4. Demonstrates BCS deserialization failure or data corruption

## Notes

This vulnerability specifically affects the **Rust protocol types**, not Move smart contracts. Move module compatibility is protected by the compatibility checker [8](#0-7) , but no equivalent protection exists for core Rust types like EventKey.

The issue is particularly insidious because:
- It's silent until triggered (no compile-time warnings)
- Testing with uniform validator versions won't expose it
- The window for exploitation is any partial upgrade period
- Recovery requires coordinated hard fork intervention

The distinction between `ContractEvent` (versioned with V1/V2) and `EventKey` (unversioned) suggests this may have been an oversight in the original design, where event structure evolution was planned but EventKey modification was not anticipated.

### Citations

**File:** types/src/event.rs (L13-16)
```rust
pub struct EventKey {
    creation_number: u64,
    account_address: AccountAddress,
}
```

**File:** types/src/contract_event.rs (L44-48)
```rust
#[derive(Hash, Clone, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum ContractEvent {
    V1(ContractEventV1),
    V2(ContractEventV2),
}
```

**File:** types/src/contract_event.rs (L178-190)
```rust
#[derive(Hash, Clone, Eq, PartialEq, Serialize, Deserialize, CryptoHasher)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ContractEventV1 {
    /// The unique key that the event was emitted to
    key: EventKey,
    /// The number of messages that have been emitted to the path previously
    sequence_number: u64,
    /// The type of the data
    type_tag: TypeTag,
    /// The data payload of the event
    #[serde(with = "serde_bytes")]
    event_data: Vec<u8>,
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1-1)
```text
///
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1-1)
```text
///
```

**File:** aptos-move/framework/src/natives/event.rs (L136-138)
```rust
    let key = bcs::from_bytes(guid.as_slice()).map_err(|_| {
        SafeNativeError::InvariantViolation(PartialVMError::new(StatusCode::EVENT_KEY_MISMATCH))
    })?;
```

**File:** types/src/on_chain_config/aptos_features.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```

**File:** third_party/move/move-binary-format/src/compatibility.rs (L1-1)
```rust
// Copyright © Aptos Foundation
```
