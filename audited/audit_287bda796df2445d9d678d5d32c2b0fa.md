# Audit Report

## Title
BytesSender Missing Drop Implementation Causes Silent Data Loss in Backup Service

## Summary
The `BytesSender` struct in the backup service lacks a `Drop` implementation, allowing buffered data (up to 10KB in production) to be silently lost if the sender is dropped before explicitly calling `finish()` or `abort()`. This can result in incomplete backups being delivered to clients without any error indication when abnormal termination occurs (e.g., panics, task cancellation).

## Finding Description

The `BytesSender` struct maintains an internal buffer (`BytesMut`) to accumulate data before sending it through an mpsc channel. [1](#0-0) 

The struct provides `finish()` and `abort()` methods for proper cleanup, where `finish()` flushes remaining buffered data and `abort()` sends an error. [2](#0-1) 

The primary usage pattern wraps backup operations with `abort_on_error`, which attempts to call either `finish()` on success or `abort()` on error. [3](#0-2) 

**Critical Gap**: There is no `Drop` implementation for `BytesSender`. If the struct is dropped due to a panic or other abnormal termination before the `match` statement in `abort_on_error` executes, any buffered data is silently discarded without flushing or error notification.

**Attack Scenarios**:

1. **Panic-induced data loss**: If the backup handler code panics (e.g., from OOM during large state iteration, assertion failures in database layer, or lock poisoning), the stack unwinds before `finish()` or `abort()` can be called, dropping `BytesSender` and losing buffered data.

2. **Task cancellation**: If the tokio runtime shuts down or the spawned task is cancelled, `BytesSender` gets dropped mid-stream.

3. **Silent stream termination**: When `BytesSender` is dropped, the mpsc sender closes, the HTTP stream ends, but the client receives incomplete backup data without explicit error indication about the missing bytes.

The backup service is used for critical disaster recovery operations. All backup endpoints use this pattern: [4](#0-3) 

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos bug bounty program's category of "State inconsistencies requiring intervention":

- **Backup integrity violation**: Operators receive incomplete backup data that appears successful (HTTP 200 response with partial data stream)
- **Silent failure**: No explicit error indicates data loss occurred
- **Disaster recovery risk**: If operators rely on these corrupted backups for node restoration, they will discover incompleteness only during recovery, potentially causing:
  - Extended downtime during validator restoration
  - Network liveness issues if multiple validators have bad backups
  - State synchronization problems requiring manual intervention
  
While this doesn't directly affect live consensus or funds on the active chain, it violates the backup completeness guarantee and could impact network resilience during disaster recovery scenarios. The buffered data loss (up to 10KB) could include critical state information or transaction records.

## Likelihood Explanation

**Likelihood: Medium to Low**

While the code path exists and the vulnerability is confirmed:

- **Natural occurrence**: More likely to manifest under stress conditions (large backups causing OOM) than deliberate exploitation
- **Environmental factors**: Panics in production Rust code are relatively rare due to Result-based error handling
- **Existing safeguards**: The `abort_on_error` wrapper handles normal error paths correctly
- **Triggering difficulty**: Deliberately causing panics in the backup handler requires environmental manipulation (memory pressure, etc.) rather than crafted malicious inputs

However, under high load or resource-constrained environments, this could occur naturally and go undetected.

## Recommendation

Implement a `Drop` trait for `BytesSender` that attempts to flush remaining buffered data or logs a warning about incomplete transmission:

```rust
impl Drop for BytesSender {
    fn drop(&mut self) {
        if !self.buffer.is_empty() {
            // Attempt to flush remaining data if channel is still open
            // If this fails, at least log the data loss
            let remaining_bytes = self.buffer.len();
            aptos_logger::warn!(
                "BytesSender dropped with {} bytes of unflushed data for endpoint {}",
                remaining_bytes,
                self.endpoint
            );
            
            // Attempt best-effort flush
            let _ = self.flush_buffer();
        }
    }
}
```

Additionally, consider using `std::panic::catch_unwind` around the backup handler execution to ensure graceful degradation even during panics.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_bytes_sender_drop_data_loss() {
    use storage::backup::backup_service::handlers::bytes_sender::BytesSender;
    use bytes::Bytes;
    
    // Create a BytesSender
    let (mut sender, mut stream) = BytesSender::new("test_endpoint");
    
    // Send data that doesn't exceed TARGET_BATCH_SIZE (remains buffered)
    let test_data = Bytes::from(vec![1u8; 5]); // Less than TARGET_BATCH_SIZE
    sender.send_bytes(test_data.clone()).unwrap();
    
    // Simulate panic by dropping without calling finish() or abort()
    drop(sender);
    
    // Attempt to read from stream
    let received: Vec<_> = stream.collect().await;
    
    // Verify: Stream closes without sending buffered data
    assert!(received.is_empty(), "Expected no data, but got {:?}", received);
    // In production, this means 5 bytes were silently lost
}

// Demonstrate panic scenario
#[tokio::test]
#[should_panic(expected = "simulated panic")]
async fn test_bytes_sender_panic_data_loss() {
    let (mut sender, _stream) = BytesSender::new("test_endpoint");
    sender.send_bytes(Bytes::from(vec![1u8; 5])).unwrap();
    
    // Simulate panic during backup operation
    panic!("simulated panic");
    // BytesSender is dropped via stack unwinding, losing buffered data
}
```

## Notes

The vulnerability is confirmed through code analysis. While the `abort_on_error` wrapper provides safeguards for normal error paths, it cannot protect against panics or abnormal termination scenarios where the `Drop` trait would be the last line of defense. The lack of `Drop` implementation creates a gap in the error handling strategy for the backup service.

### Citations

**File:** storage/backup/backup-service/src/handlers/bytes_sender.rs (L13-19)
```rust
pub(super) struct BytesSender {
    /// Buffers bytes instead of relying on the channel's backlog to provide backpressure, so
    /// the max pending bytes are more predictable.
    buffer: BytesMut,
    bytes_tx: tokio::sync::mpsc::Sender<BytesResult>,
    endpoint: &'static str,
}
```

**File:** storage/backup/backup-service/src/handlers/bytes_sender.rs (L75-81)
```rust
    pub fn finish(mut self) -> DbResult<()> {
        self.flush_buffer()
    }

    pub fn abort<E: std::error::Error + Send + Sync + 'static>(self, err: E) -> DbResult<()> {
        self.send_res(Err(Box::new(err)))
    }
```

**File:** storage/backup/backup-service/src/handlers/utils.rs (L67-80)
```rust
pub(super) fn abort_on_error<F>(
    f: F,
) -> impl FnOnce(BackupHandler, bytes_sender::BytesSender) + Send + 'static
where
    F: FnOnce(BackupHandler, &mut bytes_sender::BytesSender) -> DbResult<()> + Send + 'static,
{
    move |bh: BackupHandler, mut sender: bytes_sender::BytesSender| {
        // ignore error from finish() and abort()
        let _res = match f(bh, &mut sender) {
            Ok(()) => sender.finish(),
            Err(e) => sender.abort(e),
        };
    }
}
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L48-56)
```rust
    let bh = backup_handler.clone();
    let state_snapshot = warp::path!(Version)
        .map(move |version| {
            reply_with_bytes_sender(&bh, STATE_SNAPSHOT, move |bh, sender| {
                bh.get_state_item_iter(version, 0, usize::MAX)?
                    .try_for_each(|record_res| sender.send_size_prefixed_bcs_bytes(record_res?))
            })
        })
        .recover(handle_rejection);
```
