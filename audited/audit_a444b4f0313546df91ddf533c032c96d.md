# Audit Report

## Title
Indexer Processor Crash Due to Unchecked Array Access in CoinInfo Processing

## Summary
The `CoinInfo::from_write_resource()` function in the indexer accesses `generic_type_params[0]` without bounds checking, which can cause an index out of bounds panic that crashes the indexer processor if a `WriteResource` with an empty `generic_type_params` array is received. [1](#0-0) 

## Finding Description
The indexer processes blockchain transactions by extracting coin-related data from `WriteResource` changes. When processing `CoinInfo` resources, the code assumes that `generic_type_params` always contains at least one element (the coin type parameter like `AptosCoin`).

The `MoveStructTag` type defines `generic_type_params` as a `Vec<MoveType>`: [2](#0-1) 

In the protobuf definition used for gRPC transaction streaming, `generic_type_params` is a repeated field that can be empty: [3](#0-2) 

The vulnerability occurs in the call chain:
1. `CoinTransactionProcessor::process_transactions()` receives transactions via gRPC
2. `CoinActivity::from_transaction()` iterates through write set changes
3. `CoinInfo::from_write_resource()` is called and unwrapped: [4](#0-3) 

If a `WriteResource` representing `0x1::coin::CoinInfo` arrives with an empty `generic_type_params` vector, the indexer panics and crashes.

The same vulnerability exists in `coin_balances.rs`: [5](#0-4) 

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. When the indexer processor crashes:

- The indexer stops processing new transactions
- API queries that depend on indexed data become stale or fail
- Block explorers and developer tools lose real-time data access
- Manual intervention is required to restart the processor
- There is a loss of service availability for blockchain data consumers

While this does not affect consensus, validator operations, or funds, it represents a significant service disruption affecting the broader Aptos ecosystem's data infrastructure.

## Likelihood Explanation
**Likelihood: Low to Medium**

Under normal operation, this vulnerability cannot occur because:
- The Move VM ensures `CoinInfo<CoinType>` always has exactly one type parameter [6](#0-5) 

However, the vulnerability can be triggered through:

1. **Malformed protobuf data**: If data corruption occurs during gRPC transmission between node and indexer
2. **Serialization bugs**: If a bug exists in the protobuf serialization/deserialization layer
3. **Malicious node**: If an indexer connects to a compromised or malicious fullnode that sends invalid data
4. **Data injection**: If an attacker can inject malformed data into the gRPC stream

The indexer receives data from external sources without validating the structure, making it vulnerable to malformed input even though such input should never occur in normal operation.

## Recommendation
Add bounds checking before accessing array elements:

```rust
pub fn from_write_resource(
    write_resource: &APIWriteResource,
    txn_version: i64,
    txn_timestamp: chrono::NaiveDateTime,
) -> anyhow::Result<Option<Self>> {
    match &CoinResource::from_write_resource(write_resource, txn_version)? {
        Some(CoinResource::CoinInfoResource(inner)) => {
            // Add bounds checking
            if write_resource.data.typ.generic_type_params.is_empty() {
                return Err(anyhow::anyhow!(
                    "CoinInfo resource at version {} has no generic type parameters",
                    txn_version
                ));
            }
            
            let coin_info_type = &CoinInfoType::from_move_type(
                &write_resource.data.typ.generic_type_params[0],
                txn_version,
            )?;
            // ... rest of the function
```

Apply the same fix to `coin_balances.rs` at line 56.

Additionally, consider adding validation at the gRPC deserialization layer to reject `WriteResource` messages for known generic structs that have incorrect type parameter counts.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_api_types::{
        Address, MoveStructTag, MoveStructValue, IdentifierWrapper, WriteResource, MoveResource
    };
    use std::str::FromStr;

    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_empty_generic_type_params_panic() {
        // Create a malformed WriteResource with CoinInfo type but no generic params
        let write_resource = WriteResource {
            address: Address::from_str("0x1").unwrap(),
            state_key_hash: "test_hash".to_string(),
            data: MoveResource {
                typ: MoveStructTag {
                    address: Address::from_str("0x1").unwrap(),
                    module: IdentifierWrapper::from_str("coin").unwrap(),
                    name: IdentifierWrapper::from_str("CoinInfo").unwrap(),
                    generic_type_params: vec![], // Empty - this is the vulnerability
                },
                data: serde_json::json!({
                    "name": "Test Coin",
                    "symbol": "TEST",
                    "decimals": 8,
                    "supply": {"vec": []}
                }).into(),
            },
        };

        // This will panic with index out of bounds
        let result = CoinInfo::from_write_resource(
            &write_resource,
            1,
            chrono::NaiveDateTime::from_timestamp_opt(0, 0).unwrap(),
        );
        
        // The panic occurs before we can check the result
        assert!(result.is_err());
    }
}
```

This test demonstrates that a `WriteResource` with empty `generic_type_params` causes a panic when processed by the indexer, crashing the processor thread.

**Notes:**
The vulnerability also exists in a second location where `CoinStore` resources are processed, indicating a pattern of missing bounds checks in the indexer's coin processing logic.

### Citations

**File:** crates/indexer/src/models/coin_models/coin_infos.rs (L57-60)
```rust
                let coin_info_type = &CoinInfoType::from_move_type(
                    &write_resource.data.typ.generic_type_params[0],
                    txn_version,
                )?;
```

**File:** api/types/src/move_types.rs (L503-509)
```rust
pub struct MoveStructTag {
    pub address: Address,
    pub module: IdentifierWrapper,
    pub name: IdentifierWrapper,
    /// Generic type parameters associated with the struct
    pub generic_type_params: Vec<MoveType>,
}
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L903-912)
```rust
pub struct MoveStructTag {
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub module: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub generic_type_params: ::prost::alloc::vec::Vec<MoveType>,
}
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L129-144)
```rust
        for wsc in writesets {
            let (maybe_coin_info, maybe_coin_balance_data) =
                if let APIWriteSetChange::WriteResource(write_resource) = wsc {
                    (
                        CoinInfo::from_write_resource(write_resource, txn_version, txn_timestamp)
                            .unwrap(),
                        CoinBalance::from_write_resource(
                            write_resource,
                            txn_version,
                            txn_timestamp,
                        )
                        .unwrap(),
                    )
                } else {
                    (None, None)
                };
```

**File:** crates/indexer/src/models/coin_models/coin_balances.rs (L55-58)
```rust
                let coin_info_type = &CoinInfoType::from_move_type(
                    &write_resource.data.typ.generic_type_params[0],
                    txn_version,
                )?;
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L163-175)
```text
    /// Information about a specific coin type. Stored on the creator of the coin's account.
    struct CoinInfo<phantom CoinType> has key {
        name: String,
        /// Symbol of the coin, usually a shorter version of the name.
        /// For example, Singapore Dollar is SGD.
        symbol: String,
        /// Number of decimals used to get its user representation.
        /// For example, if `decimals` equals `2`, a balance of `505` coins should
        /// be displayed to a user as `5.05` (`505 / 10 ** 2`).
        decimals: u8,
        /// Amount of this coin type in existence.
        supply: Option<OptionalAggregator>
    }
```
