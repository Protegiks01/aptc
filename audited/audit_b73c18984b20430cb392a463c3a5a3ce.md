# Audit Report

## Title
Gas Feature Version Race Condition Causes Consensus Failure During Asynchronous Validator Upgrades

## Summary
A critical race condition exists in the cryptography algebra serialization native function that allows validators running different binary versions to charge different gas amounts for identical transactions, breaking consensus determinism and causing network halts or chain forks.

## Finding Description

The vulnerability exists in the conditional gas charging logic for elliptic curve point serialization operations. [1](#0-0) 

This code charges additional gas for the `into_affine()` operation only when the on-chain `gas_feature_version` (from `GasScheduleV2`) is greater than or equal to `RELEASE_V1_16` (value 21). [2](#0-1) 

The `gas_feature_version` is read from on-chain state at block execution time: [3](#0-2) [4](#0-3) 

The gas schedule is updated via governance proposals: [5](#0-4) 

**The Race Condition:**

When a new Aptos release adds conditional gas charging code (like lines 106-108), there's no enforcement mechanism to ensure ALL validators upgrade their binaries BEFORE the on-chain `GasScheduleV2.feature_version` can be incremented via governance.

During asynchronous validator upgrades:
- **Validators on old binary (e.g., v1.15):** Do NOT have lines 106-108, never charge `into_affine_gas`
- **Validators on new binary (e.g., v1.16):** HAVE lines 106-108, charge `into_affine_gas` when `gas_feature_version >= 21`

If a governance proposal updates `GasScheduleV2.feature_version` to 21 while validators are still upgrading:
1. All validators read the same on-chain state (feature_version = 21)
2. Old binary validators execute serialize operations WITHOUT extra gas charge
3. New binary validators execute serialize operations WITH extra gas charge
4. **Result:** Different total gas consumed → Different transaction outcomes (if near gas limit) → Different state roots → **Consensus breaks**

This violates the fundamental consensus invariant: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This meets the highest severity criteria:

- **Consensus/Safety Violation:** Breaks AptosBFT's fundamental guarantee that all validators produce identical state roots for identical blocks
- **Non-recoverable Network Partition:** When validators diverge on state roots, the network cannot progress. Validators running different binaries will fork into incompatible chains, requiring emergency hardfork intervention
- **Total Loss of Liveness:** Network halts entirely when consensus cannot be achieved due to state root mismatches

Any transaction using algebra serialization operations (BLS12-381 or BN254 curve operations) during the vulnerable window would trigger the divergence. Given that these operations are used in cryptographic protocols, the probability of network-wide impact is HIGH during validator upgrade periods.

## Likelihood Explanation

**High Likelihood** during any release that adds new conditional gas charging:

1. **Inevitable Async Upgrades:** Validators cannot all upgrade simultaneously due to operational constraints (different time zones, maintenance windows, testing requirements)
2. **No Technical Safeguards:** The code lacks any mechanism to prevent gas schedule upgrades before binary upgrades complete
3. **Governance Process Gap:** No validation in the governance proposal system checks validator binary versions before allowing `GasScheduleV2` updates
4. **Historical Precedent:** Lines 106-108 represent exactly this pattern - new conditional gas charging added in a release

The vulnerability triggers automatically once:
1. Any release adds conditional gas charging code
2. Governance updates `gas_feature_version` before 100% validator adoption
3. A transaction uses the affected native function

## Recommendation

**Immediate Fix:** Implement validator version consensus checks before allowing gas feature version upgrades.

**Solution 1 - Governance-level Enforcement:**
Add validator version tracking and require minimum version threshold before `GasScheduleV2` updates:

```move
// In gas_schedule.move
public fun set_for_next_epoch_with_version_check(
    aptos_framework: &signer,
    gas_schedule_blob: vector<u8>,
    required_validator_version: u64
) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // Check that sufficient validators are at required version
    let validator_set = stake::get_validator_set();
    let validators_on_version = version::count_validators_at_version(required_validator_version);
    assert!(
        validators_on_version * 100 / vector::length(&validator_set) >= 90,
        error::invalid_state(EINSUFFICIENT_VALIDATOR_UPGRADES)
    );
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    // ... existing validation ...
    config_buffer::upsert(new_gas_schedule);
}
```

**Solution 2 - Safe Feature Rollout Pattern:**
Require TWO-PHASE upgrades for any new conditional gas charging:

```rust
// Phase 1: Add code but keep it disabled
if context.gas_feature_version() >= RELEASE_V1_16 
    && context.timed_feature_enabled(TimedFeatureFlag::CHARGE_INTO_AFFINE_GAS) {
    context.charge($into_affine_gas)?;
}

// Phase 2: After all validators upgrade, enable timed feature via governance
```

This decouples binary deployment from feature activation, allowing safe coordination.

## Proof of Concept

**Scenario Reproduction:**

1. **Setup:** Network with 4 validators (V1, V2, V3, V4)

2. **Initial State:**
   - All validators on binary v1.15 (no lines 106-108)
   - `GasScheduleV2.feature_version = 20`

3. **Upgrade Begins:**
   - Day 1: V1, V2 upgrade to v1.16 (has lines 106-108)
   - Day 3: V3, V4 still on v1.15

4. **Governance Proposal Executes:**
   - Block N: Governance proposal updates `GasScheduleV2.feature_version = 21`

5. **Consensus Failure Trigger:**
   - Block N+1: Transaction TX calls `crypto_algebra::serialize<G1, Compressed>(point)`
   
   **Validator Execution Divergence:**
   - V1 (v1.16): Reads `gas_feature_version = 21`, executes lines 106-108, charges extra gas → StateRoot_A
   - V2 (v1.16): Reads `gas_feature_version = 21`, executes lines 106-108, charges extra gas → StateRoot_A
   - V3 (v1.15): Reads `gas_feature_version = 21`, but lines 106-108 don't exist, no extra charge → StateRoot_B
   - V4 (v1.15): Reads `gas_feature_version = 21`, but lines 106-108 don't exist, no extra charge → StateRoot_B

6. **Result:** 
   - 50% validators produce StateRoot_A
   - 50% validators produce StateRoot_B
   - No quorum possible (need >2/3 agreement)
   - **Network halts**

**Test Reproduction (Pseudocode):**

```rust
#[test]
fn test_gas_version_race_consensus_break() {
    // Create 4 validator nodes
    let old_binary_validators = vec![validator_3, validator_4];
    let new_binary_validators = vec![validator_1, validator_2];
    
    // Block N: Update gas schedule
    let proposal = update_gas_schedule_to_v21();
    execute_governance_proposal(proposal);
    
    // Block N+1: Execute algebra serialization transaction
    let txn = create_algebra_serialize_transaction();
    
    // Execute on all validators
    let results_old = old_binary_validators.execute_block(txn);
    let results_new = new_binary_validators.execute_block(txn);
    
    // Verify consensus failure
    assert_ne!(results_old.state_root, results_new.state_root);
    assert_ne!(results_old.gas_used, results_new.gas_used);
    // Network cannot progress - no quorum
}
```

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L106-108)
```rust
            if $context.gas_feature_version() >= RELEASE_V1_16 {
                $context.charge($into_affine_gas)?;
            }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L88-88)
```rust
    pub const RELEASE_V1_16: u64 = 21;
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L15-19)
```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0)
}
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L212-213)
```rust
        let storage_environment =
            AptosEnvironment::new_with_delayed_field_optimization_enabled(&state_view);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L39-41)
```rust
    pub fn new(state_view: &impl StateView) -> Self {
        Self(TriompheArc::new(Environment::new(state_view, false, None)))
    }
```
