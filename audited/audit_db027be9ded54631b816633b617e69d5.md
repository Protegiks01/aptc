# Audit Report

## Title
Database Validation Tool Fails to Verify Cryptographic Commitment to Event Ordering

## Summary
The `verify_events()` function in the database debugger validation tool does not verify events against their cryptographic commitment (event_root_hash) in TransactionInfo, allowing database corruption to go undetected if both the main database and indexer database are tampered with simultaneously.

## Finding Description

During transaction execution, Aptos computes a cryptographic commitment to event ordering through the `event_root_hash` field in TransactionInfo. This hash is the root of a Merkle accumulator built from event hashes in their execution order: [1](#0-0) 

The event_root_hash is stored in TransactionInfo and provides a tamper-proof commitment to both the events and their ordering: [2](#0-1) 

The codebase includes a function to verify events against this commitment: [3](#0-2) 

However, the database validation tool's `verify_events()` function does NOT use this verification: [4](#0-3) 

This function only verifies that events exist in the indexer database at the expected indices, but does not verify the cryptographic commitment. An attacker with database write access could reorder events in both the EventSchema and indexer schemas, and this validation would pass despite the event_root_hash mismatch.

Events are stored using sequential indices: [5](#0-4) 

And retrieved by iterating over these indices: [6](#0-5) 

When the API serves transactions, events are converted without verification against event_root_hash: [7](#0-6) 

## Impact Explanation

**Severity: Medium** - This constitutes a "State inconsistency requiring intervention" under the bug bounty program.

While this vulnerability requires local database write access (filesystem-level privilege), it represents a failure of the validation tool's core purpose: detecting database corruption. The impact includes:

1. **Validation Tool Failure**: The db_debugger cannot detect event reordering attacks
2. **API Data Integrity**: APIs serve reordered events without detection
3. **Application Impact**: Smart contract dApps depending on event ordering would receive incorrect data
4. **Semantic Violation**: Breaks the invariant that "State transitions must be atomic and verifiable via Merkle proofs"

Note: State sync between nodes WOULD detect this because it calls `.verify()`, preventing network-wide propagation.

## Likelihood Explanation

**Likelihood: Low-Medium** 

This vulnerability requires:
- Local filesystem write access to a validator's database
- Knowledge of RocksDB schema internals
- Coordinated modification of both main DB and indexer DB

This limits exploitation to:
- Compromised validator nodes
- Malicious insiders with server access
- Post-breach scenarios where attackers have established persistence

The likelihood is elevated by the fact that the validation tool specifically designed to detect such corruption would fail to identify it.

## Recommendation

Add cryptographic verification to the `verify_events()` function:

```rust
fn verify_events(
    transaction_list: &TransactionListWithProofV2,
    internal_indexer_db: &DB,
    start_version: u64,
) -> Result<()> {
    let mut version = start_version;
    match &transaction_list.get_transaction_list_with_proof().events {
        None => {
            return Ok(());
        },
        Some(event_vec) => {
            // Get transaction infos for verification
            let txn_infos = &transaction_list.get_transaction_list_with_proof().proof.transaction_infos;
            
            for (txn_idx, events) in event_vec.iter().enumerate() {
                // ADDED: Verify events against event_root_hash
                let txn_info = &txn_infos[txn_idx];
                verify_events_against_root_hash(events, txn_info)?;
                
                // Existing indexer verification
                for (idx, event) in events.iter().enumerate() {
                    match event {
                        ContractEvent::V1(event) => {
                            let seq_num = event.sequence_number();
                            let event_key = event.key();
                            verify_event_by_version(
                                event_key,
                                seq_num,
                                internal_indexer_db,
                                version,
                                idx,
                            )?;
                            verify_event_by_key(
                                event_key,
                                seq_num,
                                internal_indexer_db,
                                idx,
                                version,
                            )?;
                        },
                        _ => continue,
                    }
                }
                version += 1;
            }
        },
    }
    Ok(())
}
```

Import the verification function at the top of the file:
```rust
use aptos_types::transaction::verify_events_against_root_hash;
```

## Proof of Concept

```rust
// Test demonstrating the validation gap
#[test]
fn test_event_ordering_validation_bypass() {
    use aptos_crypto::hash::CryptoHash;
    use aptos_types::contract_event::ContractEvent;
    use aptos_types::proof::accumulator::InMemoryEventAccumulator;
    
    // Create two events in original order
    let event_a = create_test_event(0);
    let event_b = create_test_event(1);
    let original_events = vec![event_a.clone(), event_b.clone()];
    
    // Compute original event_root_hash
    let original_hashes: Vec<_> = original_events.iter().map(CryptoHash::hash).collect();
    let original_root = InMemoryEventAccumulator::from_leaves(&original_hashes).root_hash();
    
    // Create reordered events
    let reordered_events = vec![event_b.clone(), event_a.clone()];
    
    // Compute reordered event_root_hash
    let reordered_hashes: Vec<_> = reordered_events.iter().map(CryptoHash::hash).collect();
    let reordered_root = InMemoryEventAccumulator::from_leaves(&reordered_hashes).root_hash();
    
    // Verify that root hashes differ
    assert_ne!(original_root, reordered_root, "Root hashes should differ for different orderings");
    
    // Current verify_events() would pass if indexer DB is also tampered
    // But verify_events_against_root_hash() would fail:
    let txn_info = create_test_transaction_info(original_root);
    let result = verify_events_against_root_hash(&reordered_events, &txn_info);
    assert!(result.is_err(), "Should detect event reordering");
}
```

## Notes

This vulnerability specifically affects the database validation tooling rather than the core consensus or execution paths. The cryptographic commitment mechanism itself is sound - the issue is that the validation tool designed to verify database integrity doesn't utilize this commitment. This creates a blind spot where database corruption through event reordering would not be detected by the validation suite, potentially allowing corrupted state to persist unnoticed on individual nodes.

### Citations

**File:** execution/executor/src/workflow/do_ledger_update.rs (L69-75)
```rust
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
```

**File:** types/src/transaction/mod.rs (L2037-2038)
```rust
    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,
```

**File:** types/src/transaction/mod.rs (L2629-2642)
```rust
fn verify_events_against_root_hash(
    events: &[ContractEvent],
    transaction_info: &TransactionInfo,
) -> Result<()> {
    let event_hashes: Vec<_> = events.iter().map(CryptoHash::hash).collect();
    let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
    ensure!(
        event_root_hash == transaction_info.event_root_hash(),
        "The event root hash calculated doesn't match that carried on the \
                         transaction info! Calculated hash {:?}, transaction info hash {:?}",
        event_root_hash,
        transaction_info.event_root_hash()
    );
    Ok(())
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L276-316)
```rust
fn verify_events(
    transaction_list: &TransactionListWithProofV2,
    internal_indexer_db: &DB,
    start_version: u64,
) -> Result<()> {
    let mut version = start_version;
    match &transaction_list.get_transaction_list_with_proof().events {
        None => {
            return Ok(());
        },
        Some(event_vec) => {
            for events in event_vec {
                for (idx, event) in events.iter().enumerate() {
                    match event {
                        ContractEvent::V1(event) => {
                            let seq_num = event.sequence_number();
                            let event_key = event.key();
                            verify_event_by_version(
                                event_key,
                                seq_num,
                                internal_indexer_db,
                                version,
                                idx,
                            )?;
                            verify_event_by_key(
                                event_key,
                                seq_num,
                                internal_indexer_db,
                                idx,
                                version,
                            )?;
                        },
                        _ => continue,
                    }
                }
                version += 1;
            }
        },
    }
    Ok(())
}
```

**File:** storage/aptosdb/src/schema/event/mod.rs (L4-11)
```rust
//! This module defines physical storage schema for the contract events.
//!
//! An event is keyed by the version of the transaction it belongs to and the index of it among all
//! events yielded by the same transaction.
//! ```text
//! |<-------key----->|<---value--->|
//! | version | index | event bytes |
//! ```
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L67-81)
```rust
    pub(crate) fn get_events_by_version(&self, version: Version) -> Result<Vec<ContractEvent>> {
        let mut events = vec![];

        let mut iter = self.db.iter::<EventSchema>()?;
        // Grab the first event and then iterate until we get all events for this version.
        iter.seek(&version)?;
        while let Some(((ver, _index), event)) = iter.next().transpose()? {
            if ver != version {
                break;
            }
            events.push(event);
        }

        Ok(events)
    }
```

**File:** api/types/src/convert.rs (L192-192)
```rust
        let events = self.try_into_events(&data.events)?;
```
