# Audit Report

## Title
Missing Epoch Validation in CommitVote Verification Allows Cross-Epoch Vote Acceptance

## Summary
The `CommitVote::verify()` method fails to validate that incoming commit votes match the current epoch, allowing votes from previous epochs to pass cryptographic verification. This violates consensus safety invariants at epoch boundaries and deviates from the established validation pattern used in other vote types.

## Finding Description

The `CommitVote` struct is used in the pipelined consensus execution to vote on committed blocks. When a `CommitVote` is received from the network, it undergoes verification in the `BufferManager` before being processed. [1](#0-0) 

The verification only checks that the author matches the sender and validates the signature, but **does not verify that the vote's epoch matches the current epoch state**. 

In contrast, the similar `VoteMsg::verify()` method explicitly validates epoch matching: [2](#0-1) 

Similarly, `EpochState::verify()` for `LedgerInfoWithSignatures` includes epoch validation: [3](#0-2) 

**Attack Scenario:**

1. An epoch-ending block B in epoch N contains reconfiguration (has `next_epoch_state`): [4](#0-3) 

2. A validator creates a `CommitVote` for block B with `vote.ledger_info.epoch() = N`

3. Block B is committed, triggering epoch transition to N+1: [5](#0-4) 

4. A new `BufferManager` is created for epoch N+1 with updated `epoch_state`

5. The attacker (or delayed network) sends the old `CommitVote` from epoch N

6. The verification process uses the new epoch's verifier but doesn't check epoch: [6](#0-5) 

7. If the validator is in both epoch N and N+1 validator sets, the signature validates successfully despite the epoch mismatch

This violates the **Consensus Safety** invariant (#2) which requires proper epoch boundary handling to prevent chain splits and consensus confusion.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria due to "Significant protocol violations":

1. **Protocol Deviation**: The missing epoch check is inconsistent with established patterns (`VoteMsg`, `EpochState`), creating an asymmetric security model where some votes are epoch-validated and others are not.

2. **Defense-in-Depth Violation**: Stale votes should be rejected at verification time, not after passing cryptographic checks. This creates unnecessary processing overhead and potential attack surface.

3. **Epoch Boundary Confusion**: During epoch transitions, the system could temporarily accept and process votes from the wrong epoch, potentially causing validators to disagree about vote validity.

4. **Resource Exhaustion Vector**: An attacker could repeatedly send old votes that pass verification but fail later, consuming verification resources.

While the practical impact is somewhat mitigated by buffer clearing after epoch transitions (old votes won't find matching blocks), the fundamental security issue remains: **votes from epoch N should never pass verification in epoch N+1**.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is exploitable whenever:
1. An epoch transition occurs (happens regularly in Aptos)
2. A validator participates in consecutive epochs (common case)
3. Network delays or intentional withholding causes votes to arrive late

The conditions are realistic and occur during normal network operation. Any validator that participates in both epoch N and N+1 could inadvertently or maliciously trigger this issue.

## Recommendation

Add epoch validation to `CommitVote::verify()` to match the pattern used in `VoteMsg::verify()`:

```rust
pub fn verify(&self, sender: Author, validator: &ValidatorVerifier, expected_epoch: u64) -> anyhow::Result<()> {
    ensure!(
        self.author() == sender,
        "Commit vote author {:?} doesn't match with the sender {:?}",
        self.author(),
        sender
    );
    ensure!(
        self.epoch() == expected_epoch,
        "CommitVote has unexpected epoch {}, expected {}",
        self.epoch(),
        expected_epoch
    );
    validator
        .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
        .context("Failed to verify Commit Vote")
}
```

Update the call site in `CommitMessage::verify()`: [7](#0-6) 

The method should be updated to pass the expected epoch from the `EpochState`.

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
#[test]
fn test_commit_vote_cross_epoch_acceptance() {
    use aptos_consensus_types::pipeline::commit_vote::CommitVote;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
        validator_signer::ValidatorSigner,
        validator_verifier::{ValidatorConsensusInfo, ValidatorVerifier},
        epoch_state::EpochState,
    };
    use aptos_crypto::HashValue;

    // Create validator that exists in both epochs
    let validator = ValidatorSigner::random([1; 32]);
    let validator_info = ValidatorConsensusInfo::new(
        validator.author(),
        validator.public_key(),
        1,
    );

    // Create verifiers for epoch 1 and epoch 2 (same validator)
    let verifier_epoch_1 = ValidatorVerifier::new(vec![validator_info.clone()]);
    let verifier_epoch_2 = ValidatorVerifier::new(vec![validator_info]);

    // Create a commit vote in epoch 1
    let block_info_epoch_1 = BlockInfo::new(
        1, // epoch 1
        100,
        HashValue::random(),
        HashValue::random(),
        0,
        0,
        None,
    );
    let ledger_info_epoch_1 = LedgerInfo::new(block_info_epoch_1, HashValue::zero());
    let commit_vote = CommitVote::new(
        validator.author(),
        ledger_info_epoch_1,
        &validator,
    ).unwrap();

    // Verify that epoch 1 vote INCORRECTLY passes verification with epoch 2 verifier
    // This should fail but currently succeeds
    let result = commit_vote.verify(validator.author(), &verifier_epoch_2);
    
    assert!(result.is_ok(), "BUG: Vote from epoch 1 accepted in epoch 2!");
    assert_eq!(commit_vote.epoch(), 1, "Vote is from epoch 1");
    // Expected epoch should be 2, but no check exists
}
```

**Notes:**

This vulnerability represents a clear deviation from consensus security best practices. While buffer clearing provides a secondary defense, the primary verification layer should enforce epoch boundaries. The absence of this check creates an inconsistent security model and potential attack surface during epoch transitions, particularly for blocks containing `next_epoch_state` (reconfiguration blocks).

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```

**File:** consensus/consensus-types/src/vote_msg.rs (L63-66)
```rust
        ensure!(
            self.vote().epoch() == self.sync_info.epoch(),
            "VoteMsg has different epoch"
        );
```

**File:** types/src/epoch_state.rs (L42-47)
```rust
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
```

**File:** types/src/ledger_info.rs (L141-147)
```rust
    pub fn next_epoch_state(&self) -> Option<&EpochState> {
        self.commit_info.next_epoch_state()
    }

    pub fn ends_epoch(&self) -> bool {
        self.next_epoch_state().is_some()
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L530-534)
```rust
                if commit_proof.ledger_info().ends_epoch() {
                    // the epoch ends, reset to avoid executing more blocks, execute after
                    // this persisting request will result in BlockNotFound
                    self.reset().await;
                }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L925-930)
```rust
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
```

**File:** consensus/src/pipeline/commit_reliable_broadcast.rs (L37-54)
```rust
    pub fn verify(&self, sender: Author, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            CommitMessage::Vote(vote) => {
                let _timer = counters::VERIFY_MSG
                    .with_label_values(&["commit_vote"])
                    .start_timer();
                vote.verify(sender, verifier)
            },
            CommitMessage::Decision(decision) => {
                let _timer = counters::VERIFY_MSG
                    .with_label_values(&["commit_decision"])
                    .start_timer();
                decision.verify(verifier)
            },
            CommitMessage::Ack(_) => bail!("Unexpected ack in incoming commit message"),
            CommitMessage::Nack => bail!("Unexpected NACK in incoming commit message"),
        }
    }
```
