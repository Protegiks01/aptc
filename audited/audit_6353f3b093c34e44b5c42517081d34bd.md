# Audit Report

## Title
Insufficient Auditing and Wildcard Policy Vulnerability in Vault Export Permission System

## Summary
Services with `Capability::Export` permission can potentially export all private keys from Vault storage due to lack of input validation on policy paths and complete absence of audit logging. The `set_policy` function accepts unsanitized key parameters that can include Vault wildcard operators, and `export_private_key` operations generate no logs, metrics, or alerts.

## Finding Description

The Vault storage policy system has two critical security gaps:

**1. Wildcard Policy Injection (Input Validation)**

The `VaultPolicy::set_policy` function constructs Vault policy paths by directly interpolating the `key` parameter without validation: [1](#0-0) 

HashiCorp Vault supports wildcards (`*`, `+`) in policy paths. If an administrator or compromised service calls `set_policy` with `key = "*"`, it creates the policy path `transit/export/signing-key/*`, granting export access to ALL keys in the transit backend, not just a specific key.

**2. Complete Absence of Audit Logging**

The `export_private_key` implementations contain no logging, metrics, or audit trails: [2](#0-1) [3](#0-2) 

An attacker with access to a service token that has Export capability can:
1. Call `list_keys()` to enumerate all key names: [4](#0-3) 

2. Export each key one-by-one with no detection

3. If the token has a wildcard policy, export all keys systematically

The only logging in the entire vault.rs file is for token renewal failures, not security-critical operations: [5](#0-4) 

## Impact Explanation

**Critical Severity** - This meets the Critical severity criteria for multiple reasons:

1. **Consensus/Safety Violations**: Validator consensus keys are stored in this system. If exported, an attacker can:
   - Sign malicious blocks pretending to be legitimate validators
   - Violate AptosBFT safety guarantees
   - Cause chain splits and double-spending

2. **Loss of Funds**: With validator keys, attackers can:
   - Manipulate governance proposals
   - Steal staked funds
   - Compromise the entire network's security model

3. **Cryptographic Correctness Invariant Broken**: The secure storage system is designed to protect private keys. Mass export capability violates the fundamental security guarantee.

Validator keys are explicitly meant to remain in secure storage: [6](#0-5) 

## Likelihood Explanation

**High Likelihood** in specific scenarios:

1. **Compromised Service Credentials**: If an attacker gains access to a service's Vault token that has Export capability (e.g., through service compromise, leaked credentials, or supply chain attack), they can immediately begin mass export with zero detection.

2. **Misconfiguration**: Administrators setting up policies might inadvertently use wildcards for convenience during testing or initial setup, leaving production systems vulnerable.

3. **Insider Threat**: Malicious insiders with policy configuration access can deliberately set wildcard policies.

The lack of any detection mechanism (logs, metrics, alerts) means this attack would go completely unnoticed until keys are actively misused.

## Recommendation

**1. Add Input Validation for Policy Paths**

```rust
pub fn set_policy(
    &self,
    policy_name: &str,
    engine: &VaultEngine,
    key: &str,
    capabilities: &[Capability],
) -> Result<(), Error> {
    // Validate key parameter - reject wildcards and special characters
    if key.contains('*') || key.contains('+') || key.contains("..") {
        return Err(Error::InvalidInput(format!(
            "Key parameter cannot contain wildcards or path traversal: {}", key
        )));
    }
    
    // Rest of existing implementation...
}
```

**2. Add Comprehensive Audit Logging**

```rust
fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
    let name = self.crypto_name(name);
    
    // Log before export attempt
    aptos_logger::warn!(
        security_event = "private_key_export",
        key_name = name,
        timestamp = self.time_service.now_secs(),
        "SECURITY: Private key export requested"
    );
    
    let result = self.client().export_ed25519_key(&name, None);
    
    // Log result
    match &result {
        Ok(_) => aptos_logger::error!(
            security_event = "private_key_export_success",
            key_name = name,
            "CRITICAL: Private key successfully exported"
        ),
        Err(e) => aptos_logger::info!(
            security_event = "private_key_export_failed",
            key_name = name,
            error = %e,
            "Private key export failed"
        ),
    }
    
    result
}
```

**3. Add Metrics and Rate Limiting**

- Implement Prometheus counters for export operations per service
- Add rate limiting to detect and block mass export attempts
- Alert on any export activity for production keys

## Proof of Concept

```rust
#[test]
fn test_wildcard_export_vulnerability() {
    // Setup vault with multiple keys
    let mut storage = create_vault_policy_with_namespace(None);
    
    let key1 = "validator_key_1";
    let key2 = "validator_key_2";
    let key3 = "validator_key_3";
    
    // Create multiple keys
    storage.create_key(key1).unwrap();
    storage.create_key(key2).unwrap();
    storage.create_key(key3).unwrap();
    
    // VULNERABILITY: Set policy with wildcard
    let wildcard_policy = Policy::new(vec![
        Permission::new(Identity::User("attacker".into()), vec![Capability::Export]),
    ]);
    
    // Setting policy with "*" as key name grants access to ALL keys
    storage.set_policy(
        "attacker",
        &VaultEngine::Transit,
        "*",  // WILDCARD - grants access to all keys!
        &[Capability::Export]
    ).unwrap();
    
    // Create attacker token
    let attacker_token = storage.create_token(vec!["attacker"]).unwrap();
    let mut attacker_storage = create_vault_storage(attacker_token, None, true);
    
    // EXPLOIT: Attacker can now export ALL keys
    let exported_key1 = attacker_storage.export_private_key(key1).unwrap();
    let exported_key2 = attacker_storage.export_private_key(key2).unwrap();
    let exported_key3 = attacker_storage.export_private_key(key3).unwrap();
    
    // NO LOGS were generated for any of these exports
    
    // Verify keys were actually exported
    assert!(exported_key1.to_bytes().len() > 0);
    assert!(exported_key2.to_bytes().len() > 0);
    assert!(exported_key3.to_bytes().len() > 0);
}
```

## Notes

This vulnerability requires an attacker to either:
1. Compromise a service with existing Export capability credentials
2. Have administrative access to configure Vault policies

While it's not exploitable by a completely unprivileged external attacker, it represents a critical security gap in the defense-in-depth model. The lack of auditing means even authorized exports cannot be monitored for abuse, and the wildcard policy issue creates a single point of catastrophic failure if policies are misconfigured or an authorized service is compromised.

### Citations

**File:** secure/storage/src/vault.rs (L79-79)
```rust
                    aptos_logger::error!("Unable to renew lease: {}", e.to_string());
```

**File:** secure/storage/src/vault.rs (L206-209)
```rust
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        let name = self.crypto_name(name);
        Ok(self.client().export_ed25519_key(&name, None)?)
    }
```

**File:** secure/storage/src/vault.rs (L386-389)
```rust
                    Capability::Export => {
                        let export_capability = vec![vault::Capability::Read];
                        let export_policy = format!("transit/export/signing-key/{}", key);
                        vault_policy.add_policy(&export_policy, export_capability);
```

**File:** secure/storage/vault/src/lib.rs (L293-305)
```rust
    pub fn export_ed25519_key(
        &self,
        name: &str,
        version: Option<u32>,
    ) -> Result<Ed25519PrivateKey, Error> {
        let request = self.agent.get(&format!(
            "{}/v1/transit/export/signing-key/{}",
            self.host, name
        ));
        let resp = self.upgrade_request(request).call();

        process_transit_export_response(name, version, resp)
    }
```

**File:** secure/storage/vault/src/lib.rs (L319-326)
```rust
    pub fn list_keys(&self) -> Result<Vec<String>, Error> {
        let request = self
            .agent
            .request("LIST", &format!("{}/v1/transit/keys", self.host));
        let resp = self.upgrade_request(request).call();

        process_transit_list_response(resp)
    }
```

**File:** config/src/config/secure_backend_config.rs (L16-22)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum SecureBackend {
    InMemoryStorage,
    Vault(VaultConfig),
    OnDiskStorage(OnDiskStorageConfig),
}
```
