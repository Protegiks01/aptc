# Audit Report

## Title
TC-QC Conflict Bypass in 2-Chain Safety Rules Allows Voting on Inconsistent Forks

## Summary
The `safe_to_vote` function in the 2-chain consensus safety rules fails to enforce the invariant `block.qc.round >= tc.highest_hqc_round` when the block directly extends its QC (`block.round == block.qc.round + 1`). This allows validators who received timeout certificates via sync (without voting) to vote on old blocks that conflict with known network state, potentially enabling consensus safety violations.

## Finding Description

The vulnerability exists in the `safe_to_vote` function which validates whether it's safe for a validator to vote on a block: [1](#0-0) 

The function checks two conditions using OR logic:
1. **Condition 1**: `block.round == block.qc.round + 1` (normal progression)
2. **Condition 2**: `block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc_round` (after timeout)

The critical issue is that when Condition 1 is TRUE, the vote passes **regardless of the timeout certificate's contents**. The invariant `qc_round >= hqc_round` is only checked when Condition 1 is FALSE.

**Attack Scenario:**

1. A validator V falls behind at round 50 (`last_voted_round = 50`)
2. Network progresses to round 105 which times out, creating `TC_105` with `highest_hqc_round = 104`
3. V receives sync info containing `TC_105` from peers via the sync mechanism: [2](#0-1) 

4. V's block store updates its highest timeout certificate: [3](#0-2) 

5. A Byzantine attacker sends V a block `B_60` at round 60 with QC for round 59 (on an old/forked chain)
6. V calls `construct_and_sign_vote_two_chain` passing the highest TC it knows (TC_105): [4](#0-3) 

7. In `safe_to_vote(B_60, TC_105)`:
   - `round = 60, qc_round = 59, tc_round = 105, hqc_round = 104`
   - Condition 1: `60 == next_round(59)?` â†’ **TRUE**
   - Vote passes **without checking** `59 >= 104`

8. The `verify_and_update_last_vote_round(60, ...)` check passes since `60 > 50`: [5](#0-4) 

9. V votes on `B_60` despite `qc_round (59) < hqc_round (104)`, violating the TC-QC consistency invariant

The fundamental issue is that a validator can receive a TC via sync without having participated in that round's voting. The TC represents knowledge that 2f+1 validators saw a QC for round 104 at round 105, but the validator votes on a block with a QC for round 59, which is far behind and potentially on a conflicting fork.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability breaks the fundamental **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

**Concrete Impacts:**

1. **Safety Violation**: Validators vote on blocks inconsistent with the network's actual progress, potentially creating QCs on old/forked chains
2. **Chain Fork Risk**: If enough validators (f+1 or more) are in this inconsistent state after sync, they could form a QC for an old block, enabling two conflicting chains
3. **Double-Spend Potential**: Different validators could commit different transaction histories at the same height
4. **Consensus Split**: The network could permanently split into incompatible forks requiring manual intervention/hardfork

The TC contains authoritative information about network state (the highest QC known to 2f+1 validators). Ignoring this information when voting enables validators to participate in outdated or malicious forks, undermining the 2-chain protocol's safety guarantees.

According to Aptos bug bounty criteria, this qualifies as **Critical Severity** (up to $1,000,000) as a "Consensus/Safety violation" that could lead to "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability can occur in realistic network conditions:

**Required Conditions:**
1. Validator falls behind and receives sync info with newer TCs (common during network partitions, node restarts, or high latency)
2. Byzantine attacker controls block proposals for old rounds (feasible with <1/3 Byzantine validators)
3. Multiple validators in similar sync state receive the old block proposal

**Occurrence Probability:**
- **Sync Events**: Validators regularly sync when catching up, making TC receipt without voting common
- **Network Partitions**: Temporary partitions naturally create scenarios where some validators are behind
- **Attack Cost**: Requires Byzantine control of block proposer role but not quorum, staying within <1/3 threshold
- **Exploitability**: No special privileges needed beyond normal Byzantine assumptions

The attack doesn't require collusion beyond normal Byzantine threshold and can occur during routine network operations, making it a realistic threat.

## Recommendation

**Fix**: Enforce the TC-QC consistency invariant **regardless** of which voting condition is met. When a timeout certificate is provided, always validate that `block.qc.round >= tc.highest_hqc_round`:

```rust
fn safe_to_vote(
    &self,
    block: &Block,
    maybe_tc: Option<&TwoChainTimeoutCertificate>,
) -> Result<(), Error> {
    let round = block.round();
    let qc_round = block.quorum_cert().certified_block().round();
    let tc_round = maybe_tc.map_or(0, |tc| tc.round());
    let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
    
    // ADDED: Always enforce TC-QC consistency when TC is provided
    if let Some(_tc) = maybe_tc {
        if qc_round < hqc_round {
            return Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round));
        }
    }
    
    if round == next_round(qc_round)?
        || (round == next_round(tc_round)? && qc_round >= hqc_round)
    {
        Ok(())
    } else {
        Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
    }
}
```

**Alternative Fix**: Don't pass the TC to `safe_to_vote` when Condition 1 is satisfied, or add explicit validation in `guarded_construct_and_sign_vote_two_chain` before calling `safe_to_vote`.

## Proof of Concept

```rust
#[test]
fn test_tc_qc_conflict_bypass() {
    use crate::safety_rules::SafetyRules;
    use aptos_consensus_types::{
        block::Block,
        block_data::BlockData,
        quorum_cert::QuorumCert,
        timeout_2chain::{TwoChainTimeout, TwoChainTimeoutCertificate},
        vote_proposal::VoteProposal,
    };
    use aptos_types::block_info::BlockInfo;
    
    // Setup: Create a validator at round 50
    let mut safety_rules = create_safety_rules_for_test();
    update_safety_data_last_voted_round(&mut safety_rules, 50);
    
    // Step 1: Create TC for round 105 with highest_hqc_round = 104
    let tc_timeout = TwoChainTimeout::new(
        1, // epoch
        105, // round
        create_qc_for_round(104), // highest QC at round 104
    );
    let tc_105 = create_and_aggregate_tc(tc_timeout);
    
    // Step 2: Create old block at round 60 with QC for round 59
    let qc_59 = create_qc_for_round(59);
    let block_60 = Block::new(
        BlockData::new(
            60, // round
            0,  // timestamp
            qc_59,
            create_block_info(60),
        ),
        None,
    );
    let vote_proposal = VoteProposal::new(block_60.clone());
    
    // Step 3: Attempt to vote - should FAIL but currently PASSES
    let result = safety_rules.construct_and_sign_vote_two_chain(
        &vote_proposal,
        Some(&tc_105), // TC with hqc_round=104, but block has qc_round=59
    );
    
    // BUG: This should fail because qc_round (59) < hqc_round (104)
    // but it passes because condition 1 (60 == next_round(59)) is true
    assert!(result.is_err(), "Should reject vote due to TC-QC conflict");
    
    // After fix, verify the error is NotSafeToVote
    match result {
        Err(Error::NotSafeToVote(r, qc_r, tc_r, hqc_r)) => {
            assert_eq!(r, 60);
            assert_eq!(qc_r, 59);
            assert_eq!(tc_r, 105);
            assert_eq!(hqc_r, 104);
        }
        _ => panic!("Expected NotSafeToVote error"),
    }
}
```

**Note**: This PoC requires test harness functions (`create_safety_rules_for_test`, `create_qc_for_round`, etc.) from the existing safety rules test suite to construct the necessary consensus types with valid signatures.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L169-171)
```rust
        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
```

**File:** consensus/src/block_storage/block_store.rs (L560-575)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L1520-1523)
```rust
        let vote_result = self.safety_rules.lock().construct_and_sign_vote_two_chain(
            &vote_proposal,
            self.block_store.highest_2chain_timeout_cert().as_deref(),
        );
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```
