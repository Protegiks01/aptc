# Audit Report

## Title
Missing BLS12-381 Subgroup Validation in Epoch Change Verification Enables Small-Subgroup Attacks

## Summary
The `verify()` function in `epoch_change.rs` accepts validator public keys from `next_epoch_state()` without validating that they are in the prime-order subgroup of the BLS12-381 curve. This violates the security assumptions of BLS signature verification and could enable small-subgroup attacks if invalid keys are introduced into the validator set through database corruption or serialization vulnerabilities.

## Finding Description

When the `EpochChangeProof::verify()` function processes epoch transitions, it extracts the next epoch's validator set from the ledger info and uses it as the verifier for subsequent epoch changes. [1](#0-0) 

However, the `EpochState` deserialization process does not validate that validator public keys are in the prime-order subgroup. When `ValidatorConsensusInfo` is deserialized from bytes, it uses `PublicKey::try_from()` [2](#0-1) , which explicitly does NOT perform subgroup checking according to its documentation. [3](#0-2) 

The BLS signature verification functions (`PublicKey::aggregate()` and `Signature::verify_aggregate_arbitrary_msg()`) explicitly assume that public keys have been subgroup-checked via proof-of-possession verification. [4](#0-3) [5](#0-4) 

This creates a gap: while on-chain validator registration validates keys with proof-of-possession [6](#0-5) , the deserialized keys used in epoch change verification are not re-validated, violating defense-in-depth principles.

## Impact Explanation

This qualifies as **High Severity** because:

1. **Cryptographic Security Violation**: Using public keys outside the prime-order subgroup can enable small-subgroup attacks where an attacker could forge signatures or cause signature verification to behave incorrectly
2. **Consensus Impact**: If different nodes accept different validator sets due to corrupted keys, it could cause consensus failures or chain splits
3. **Protocol Violation**: Breaks the "Cryptographic Correctness" invariant that BLS signatures must be secure

While the upstream on-chain validation provides protection, the lack of validation at the deserialization layer means that database corruption, serialization bugs, or future vulnerabilities in the validator registration flow could introduce invalid keys that would be accepted without detection.

## Likelihood Explanation

**Likelihood: Medium-Low**

The attack is mitigated by:
- Keys are validated with proof-of-possession during on-chain registration
- EpochState must be signed by 2f+1 honest validators
- No direct path for unprivileged attackers to inject invalid keys

However, the vulnerability could be triggered by:
- Database corruption (disk errors, memory corruption)
- Bugs in serialization/deserialization code
- Future vulnerabilities in the validator registration flow
- Race conditions or state inconsistencies during epoch transitions

The defense-in-depth principle dictates that cryptographic inputs should always be validated, even when expected to be pre-validated by upstream components.

## Recommendation

Add explicit subgroup checking when deserializing `EpochState` in the epoch change verification path. Modify the `ValidatorVerifier` deserialization or construction to validate all public keys:

```rust
impl<'de> Deserialize<'de> for ValidatorVerifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(rename = "ValidatorVerifier")]
        struct RawValidatorVerifier {
            validator_infos: Vec<ValidatorConsensusInfo>,
        }

        let RawValidatorVerifier { validator_infos } =
            RawValidatorVerifier::deserialize(deserializer)?;

        // Add subgroup validation for all public keys
        for info in &validator_infos {
            info.public_key()
                .subgroup_check()
                .map_err(|e| serde::de::Error::custom(format!("Invalid public key: {}", e)))?;
        }

        Ok(ValidatorVerifier::new(validator_infos))
    }
}
```

Alternatively, validate keys when creating `EpochState` in the executor or when processing epoch changes.

## Proof of Concept

```rust
#[cfg(test)]
mod subgroup_attack_test {
    use super::*;
    use aptos_crypto::bls12381::PublicKey;
    
    #[test]
    fn test_invalid_pubkey_in_epoch_state() {
        // Create a point on curve but not in prime-order subgroup
        // (This would need to be crafted using low-level blst functions)
        let invalid_pk_bytes = [0u8; 48]; // Simplified - actual attack would use crafted bytes
        
        // This succeeds even though key might be invalid
        let pk = PublicKey::try_from(&invalid_pk_bytes[..]);
        
        // subgroup_check would fail if key is in small subgroup
        if let Ok(key) = pk {
            assert!(key.subgroup_check().is_err(), 
                "Invalid key should fail subgroup check");
        }
    }
}
```

## Notes

This is a defense-in-depth issue where multiple protection layers exist (on-chain PoP validation, 2f+1 signatures), but the epoch change verification path lacks independent validation of cryptographic inputs. While direct exploitation by an unprivileged attacker is difficult, the missing validation could amplify the impact of other bugs or corruption scenarios, and represents a violation of cryptographic best practices.

### Citations

**File:** types/src/epoch_change.rs (L111-114)
```rust
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
```

**File:** types/src/validator_verifier.rs (L124-124)
```rust
        let public_key = bls12381_keys::PublicKey::try_from(pk_bytes.as_slice())?;
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L74-86)
```rust
    /// WARNING: This function assumes all public keys have had their proofs-of-possession verified
    /// and have thus been group-checked.
    pub fn aggregate(pubkeys: Vec<&Self>) -> Result<PublicKey> {
        let blst_pubkeys: Vec<_> = pubkeys.iter().map(|pk| &pk.pubkey).collect();

        // CRYPTONOTE(Alin): We assume the PKs have had their PoPs verified and thus have also been subgroup-checked
        let aggpk = blst::min_pk::AggregatePublicKey::aggregate(&blst_pubkeys[..], false)
            .map_err(|e| anyhow!("{:?}", e))?;

        Ok(PublicKey {
            pubkey: aggpk.to_public_key(),
        })
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L227-247)
```rust
impl TryFrom<&[u8]> for PublicKey {
    type Error = CryptoMaterialError;

    /// Deserializes a PublicKey from a sequence of bytes.
    ///
    /// WARNING: Does NOT subgroup-check the public key! Instead, the caller is responsible for
    /// verifying the public key's proof-of-possession (PoP) via `ProofOfPossession::verify`,
    /// which implicitly subgroup-checks the public key.
    ///
    /// NOTE: This function will only check that the PK is a point on the curve:
    ///  - `blst::min_pk::PublicKey::from_bytes(bytes)` calls `blst::min_pk::PublicKey::deserialize(bytes)`,
    ///    which calls `$pk_deser` in <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/bindings/rust/src/lib.rs#L734>,
    ///    which is mapped to `blst_p1_deserialize` in <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/bindings/rust/src/lib.rs#L1652>
    ///  - `blst_p1_deserialize` eventually calls `POINTonE1_Deserialize_BE`, which checks
    ///    the point is on the curve: <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/src/e1.c#L296>
    fn try_from(bytes: &[u8]) -> std::result::Result<Self, CryptoMaterialError> {
        Ok(Self {
            pubkey: blst::min_pk::PublicKey::from_bytes(bytes)
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
        })
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L83-93)
```rust
    /// WARNING: This function assumes that the public keys have been subgroup-checked by the caller
    /// implicitly when verifying their proof-of-possession (PoP) in `ProofOfPossession::verify`.
    pub fn verify_aggregate_arbitrary_msg(&self, msgs: &[&[u8]], pks: &[&PublicKey]) -> Result<()> {
        let pks = pks
            .iter()
            .map(|&pk| &pk.pubkey)
            .collect::<Vec<&blst::min_pk::PublicKey>>();

        let result = self
            .sig
            .aggregate_verify(true, msgs, DST_BLS_SIG_IN_G2_WITH_POP, &pks, false);
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L152-161)
```rust
/// Checks prime-order subgroup membership on a bls12381::PublicKey struct.
fn bls12381_pk_subgroub_check(
    pk: &bls12381::PublicKey,
    context: &mut SafeNativeContext,
) -> SafeNativeResult<bool> {
    // NOTE(Gas): constant-time; around 39 microseconds on Apple M1
    context.charge(BLS12381_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;

    Ok(pk.subgroup_check().is_ok())
}
```
