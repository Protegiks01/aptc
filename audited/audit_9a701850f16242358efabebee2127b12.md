# Audit Report

## Title
Genesis Initialization Accepts Empty Validator Set Leading to Guaranteed Network Failure and Total Loss of Liveness

## Summary
The `GenesisInfo::new()` function in `aptos-genesis/src/lib.rs` accepts an empty validators vector without validation, allowing creation of a genesis state with zero validators. This results in immediate consensus engine panic on network startup, causing total and permanent loss of liveness requiring a hard fork to recover.

## Finding Description

The Aptos genesis initialization process lacks critical input validation, allowing a genesis state to be created with zero validators. This breaks the fundamental consensus invariant that AptosBFT requires at least one validator to achieve liveness.

**Attack Path:**

1. **Genesis Creation Phase**: The `GenesisInfo::new()` function accepts an empty `configs: Vec<ValidatorConfiguration>` parameter without validation [1](#0-0) 

2. **Genesis Transaction Generation**: The empty validators vector is serialized and passed to the Move `genesis::create_initialize_validators` function [2](#0-1) 

3. **Move-Side Processing**: The Move genesis code iterates over the empty vector (performing no operations) and calls `stake::on_new_epoch()` [3](#0-2) 

4. **Validator Set Initialization**: The `on_new_epoch()` function creates a ValidatorSet with empty `active_validators` vector and `total_voting_power = 0` [4](#0-3) 

5. **Consensus Initialization Failure**: When nodes attempt to start consensus, the `create_proposer_election()` function extracts proposers from the epoch state verifier, resulting in an empty proposers vector [5](#0-4) 

6. **Guaranteed Panic**: Depending on the configured proposer election type:
   - **RoundProposer**: Explicit panic with "INVARIANT VIOLATION: proposers is empty" [6](#0-5) 
   - **FixedProposer**: Panic in `choose_leader()` with "No trusted peers found!" [7](#0-6) 
   - **RotatingProposer**: Division by zero when computing `% self.proposers.len()` in `get_valid_proposer()` [8](#0-7) 

The ValidatorVerifier accepts empty validator sets and sets `quorum_voting_power = 0`, providing no protection [9](#0-8) 

## Impact Explanation

**Critical Severity - Total Loss of Liveness/Network Availability**

This vulnerability causes immediate and complete network failure:

- **All validator nodes panic on startup** with invariant violation or division by zero errors
- **Zero blocks can be produced** - consensus cannot begin without proposers
- **Network is permanently halted** - no transaction processing possible
- **Requires hard fork to recover** - genesis must be regenerated with valid validators
- **Complete economic shutdown** - all user funds inaccessible until recovery

This meets the Aptos Bug Bounty **Critical Severity** criteria for "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Low to Medium**

While genesis generation is typically a carefully controlled process, this vulnerability can manifest through:

1. **Configuration Errors**: Incorrect genesis configuration files or deployment scripts
2. **Testing/Development Mistakes**: Accidentally deploying test configurations to production
3. **Automated Tooling Bugs**: Errors in genesis generation automation
4. **Malicious Insider**: Compromised genesis coordinator (though trusted roles are assumed non-malicious per the threat model)

The absence of defensive validation makes this a "time bomb" - a single configuration mistake causes catastrophic, irrecoverable failure. Production-grade systems should validate even trusted inputs, especially for operations as critical as genesis initialization.

## Recommendation

**Add mandatory validation that the validators vector is non-empty:**

```rust
pub fn new(
    chain_id: ChainId,
    root_key: Ed25519PublicKey,
    configs: Vec<ValidatorConfiguration>,
    framework: ReleaseBundle,
    genesis_config: &GenesisConfiguration,
) -> anyhow::Result<GenesisInfo> {
    // CRITICAL: Validate non-empty validator set
    anyhow::ensure!(
        !configs.is_empty(),
        "Cannot create genesis with empty validator set. At least one validator is required for network liveness."
    );
    
    let mut validators = Vec::new();
    for config in configs {
        validators.push(config.try_into()?)
    }
    
    // ... rest of function
}
```

**Additional defense-in-depth recommendations:**

1. Add validation in `encode_genesis_change_set()` before calling `create_and_initialize_validators()` [10](#0-9) 

2. Add assertion in Move `create_initialize_validators()` function:
   ```move
   assert!(!vector::is_empty(&validators), error::invalid_argument(EEMPTY_VALIDATORS));
   ```

3. Add check in `create_proposer_election()` as last line of defense [11](#0-10) 

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Cannot create genesis with empty validator set")]
fn test_empty_validator_set_rejected() {
    use aptos_genesis::{builder::GenesisConfiguration, GenesisInfo};
    use aptos_crypto::ed25519::Ed25519PublicKey;
    use aptos_types::chain_id::ChainId;
    use aptos_framework::ReleaseBundle;
    
    // Attempt to create genesis with zero validators
    let chain_id = ChainId::test();
    let root_key = Ed25519PublicKey::try_from(&[0u8; 32][..]).unwrap();
    let empty_configs = vec![]; // EMPTY VALIDATOR SET
    let framework = ReleaseBundle::current();
    let genesis_config = GenesisConfiguration::default();
    
    // This should panic with validation error, but currently succeeds
    let result = GenesisInfo::new(
        chain_id,
        root_key,
        empty_configs, // BUG: No validation prevents this
        framework,
        &genesis_config,
    );
    
    // If we reach here, genesis creation succeeded with zero validators
    // When nodes try to start, consensus will panic
    let mut genesis_info = result.unwrap();
    let _waypoint = genesis_info.generate_waypoint(); // Succeeds
    
    // Network startup will panic in create_proposer_election()
    // with "INVARIANT VIOLATION: proposers is empty"
}
```

**Notes:**

The vulnerability is confirmed across multiple code layers with no validation preventing empty validator sets. The consensus engine explicitly treats this as an "INVARIANT VIOLATION" but this check only triggers at runtime during node startup, not during genesis creation. Proper defensive programming requires rejecting invalid inputs at the earliest possible point - during genesis construction.

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L86-97)
```rust
    pub fn new(
        chain_id: ChainId,
        root_key: Ed25519PublicKey,
        configs: Vec<ValidatorConfiguration>,
        framework: ReleaseBundle,
        genesis_config: &GenesisConfiguration,
    ) -> anyhow::Result<GenesisInfo> {
        let mut validators = Vec::new();

        for config in configs {
            validators.push(config.try_into()?)
        }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L262-271)
```rust
pub fn encode_genesis_change_set(
    core_resources_key: &Ed25519PublicKey,
    validators: &[Validator],
    framework: &ReleaseBundle,
    chain_id: ChainId,
    genesis_config: &GenesisConfiguration,
    consensus_config: &OnChainConsensusConfig,
    execution_config: &OnChainExecutionConfig,
    gas_schedule: &GasScheduleV2,
) -> ChangeSet {
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1045-1063)
```rust
fn create_and_initialize_validators(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl AptosModuleStorage,
    traversal_context: &mut TraversalContext,
    validators: &[Validator],
) {
    let validators_bytes = bcs::to_bytes(validators).expect("Validators can be serialized");
    let mut serialized_values = serialize_values(&vec![MoveValue::Signer(CORE_CODE_ADDRESS)]);
    serialized_values.push(validators_bytes);
    exec_function(
        session,
        module_storage,
        traversal_context,
        GENESIS_MODULE_NAME,
        "create_initialize_validators",
        vec![],
        serialized_values,
    );
}
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L324-336)
```text
    fun create_initialize_validators(aptos_framework: &signer, validators: vector<ValidatorConfiguration>) {
        let validators_with_commission = vector::empty();
        vector::for_each_reverse(validators, |validator| {
            let validator_with_commission = ValidatorConfigurationWithCommission {
                validator_config: validator,
                commission_percentage: 0,
                join_during_genesis: true,
            };
            vector::push_back(&mut validators_with_commission, validator_with_commission);
        });

        create_initialize_validators_with_commission(aptos_framework, false, validators_with_commission);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1344-1403)
```text
    public(friend) fun on_new_epoch(
    ) acquires AptosCoinCapabilities, PendingTransactionFee, StakePool, TransactionFeeConfig, ValidatorConfig, ValidatorPerformance, ValidatorSet {
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let config = staking_config::get();
        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);

        // Process pending stake and distribute transaction fees and rewards for each currently active validator.
        vector::for_each_ref(&validator_set.active_validators, |validator| {
            let validator: &ValidatorInfo = validator;
            update_stake_pool(validator_perf, validator.addr, &config);
        });

        // Process pending stake and distribute transaction fees and rewards for each currently pending_inactive validator
        // (requested to leave but not removed yet).
        vector::for_each_ref(&validator_set.pending_inactive, |validator| {
            let validator: &ValidatorInfo = validator;
            update_stake_pool(validator_perf, validator.addr, &config);
        });

        // Activate currently pending_active validators.
        append(&mut validator_set.active_validators, &mut validator_set.pending_active);

        // Officially deactivate all pending_inactive validators. They will now no longer receive rewards.
        validator_set.pending_inactive = vector::empty();

        // Update active validator set so that network address/public key change takes effect.
        // Moreover, recalculate the total voting power, and deactivate the validator whose
        // voting power is less than the minimum required stake.
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
        validator_set.total_joining_power = 0;
```

**File:** consensus/src/epoch_manager.rs (L287-295)
```rust
    fn create_proposer_election(
        &self,
        epoch_state: &EpochState,
        onchain_config: &OnChainConsensusConfig,
    ) -> Arc<dyn ProposerElection + Send + Sync> {
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
```

**File:** consensus/src/epoch_manager.rs (L398-400)
```rust
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L20-23)
```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```
