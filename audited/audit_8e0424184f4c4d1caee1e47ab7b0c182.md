# Audit Report

## Title
Bytecode Version Mismatch Between Prebuilt Packages and Runtime VM Causes Transaction Generator Initialization Failures

## Summary
Prebuilt packages for transaction workloads are compiled at build time with fixed bytecode versions (VERSION_9 for regular packages, VERSION_10 for experimental packages), but the runtime Move VM's maximum supported bytecode version is determined dynamically by on-chain feature flags. This mismatch causes transaction generator initialization to panic when experimental packages compiled with VERSION_10 are deployed to networks where the `VM_BINARY_FORMAT_V10` feature flag is disabled.

## Finding Description

The vulnerability exists in the transaction workload generation system, which uses prebuilt Move packages for benchmarking and performance testing. The issue manifests through the following mechanism:

**Build-Time Bytecode Version Selection:** [1](#0-0) 

Regular packages use `BuildOptions::move_2()` which sets bytecode version to VERSION_DEFAULT (9), while experimental packages call `set_latest_language()`: [2](#0-1) 

This explicitly sets the bytecode version to VERSION_MAX (10): [3](#0-2) 

**Runtime VM Version Determination:** [4](#0-3) 

The deserializer config uses the on-chain feature flags: [5](#0-4) 

**Deserialization Failure:**
When a module with VERSION_10 bytecode is deserialized on a VM configured with max_binary_format_version = VERSION_9, the version check fails: [6](#0-5) 

This returns `StatusCode::UNKNOWN_VERSION`, as demonstrated in the integration tests: [7](#0-6) 

**Panic on Publishing Failure:**
The transaction generator's error handling unwraps the publishing result, causing a panic: [8](#0-7) 

## Impact Explanation

This issue meets the **High Severity** criteria from the Aptos Bug Bounty program for "Validator node slowdowns" and "API crashes":

1. **Validator Node Slowdowns**: Validator operators running performance benchmarks with transaction generators will experience crashes when experimental packages fail to publish, preventing performance testing and capacity planning.

2. **API Crashes**: If transaction generation APIs integrate prebuilt experimental packages for load testing, they will crash during initialization.

3. **Operational Impact**: The issue prevents benchmarking infrastructure from functioning during:
   - Feature rollout periods (when new bytecode versions are being deployed)
   - Emergency rollbacks (when bytecode version feature flags are disabled)
   - Cross-version testing scenarios (newer build against older network)

## Likelihood Explanation

**Likelihood: Medium**

This issue occurs in the following realistic scenarios:

1. **Feature Rollout Period**: When VM_BINARY_FORMAT_V10 is being rolled out from devnet → testnet → mainnet, transaction generators built with experimental packages will fail on networks that haven't enabled the flag yet.

2. **Emergency Feature Rollback**: If a critical bug is discovered in VERSION_10 bytecode and `VM_BINARY_FORMAT_V10` must be disabled via governance, all transaction generators using experimental packages immediately break.

3. **Development/Testing Environments**: Developers building from the latest codebase (with VERSION_10 experimental packages) and testing against older network configurations will encounter crashes.

4. **Currently Active**: The experimental_usecases package is used by the OrderBook entry point: [9](#0-8) 

## Recommendation

Implement runtime bytecode version compatibility checking before attempting to publish prebuilt packages:

1. **Add version validation** in `create_prebuilt_packages_bundle()` to embed version metadata
2. **Check compatibility** before publishing in `publish_package_to_accounts()`:

```rust
pub async fn publish_package_to_accounts(
    init_txn_factory: TransactionFactory,
    txn_executor: &dyn ReliableTransactionSubmitter,
    pre_built: &'static dyn PreBuiltPackages,
    package_name: &str,
    accounts: &[LocalAccount],
) -> Vec<Package> {
    // NEW: Query current max bytecode version from on-chain features
    let features = Features::fetch_config(txn_executor.get_state_view())
        .unwrap_or_else(Features::default);
    let max_runtime_version = features.get_max_binary_format_version();
    
    // NEW: Extract and check package bytecode version
    let package_bundle = pre_built.package_bundle();
    let package = package_bundle.get_package(package_name);
    for (_name, module_bytes) in &package.modules {
        let module_version = extract_bytecode_version(module_bytes)?;
        if module_version > max_runtime_version {
            error!(
                "Package {} compiled with bytecode version {} but runtime supports max version {}. Skipping publication.",
                package_name, module_version, max_runtime_version
            );
            return vec![]; // Return empty instead of panicking
        }
    }
    
    // Continue with existing publishing logic...
}
```

3. **Graceful degradation**: Return empty package lists instead of panicking, allowing transaction generators to skip unsupported packages

4. **Build-time warnings**: Add warnings during `create_prebuilt_packages_bundle()` when experimental packages use VERSION_MAX

## Proof of Concept

**Reproduction Steps:**

1. Build Aptos Core with experimental packages (uses VERSION_10)
2. Deploy to a test network with `VM_BINARY_FORMAT_V10` feature flag disabled
3. Attempt to initialize transaction generator with OrderBook entry point:

```rust
// In forge test or benchmark context
let entry_point = EntryPoints::OrderBook { num_orders: 100 };
let package_name = entry_point.package_name(); // Returns "experimental_usecases"

// This will panic due to version mismatch
let generator = CustomModulesDelegationGeneratorCreator::new(
    txn_factory,
    init_txn_factory,
    root_account,
    txn_executor,
    10, // num_modules
    &PreBuiltPackagesImpl, // Contains VERSION_10 experimental packages
    package_name,
    &mut workload,
).await;
```

**Expected Result**: Panic with error message containing "Failed to publish test package experimental_usecases" and underlying UNKNOWN_VERSION status code.

**Actual Network Impact**: This prevents validator operators from running benchmarks during the period between when a new bytecode version is compiled into releases and when it's enabled on-chain via governance.

## Notes

While VM_BINARY_FORMAT_V10 is currently in the default feature set, this vulnerability remains relevant because: [10](#0-9) 

1. Feature flags can be disabled via governance for emergency rollbacks
2. Different networks (devnet/testnet/mainnet) may have different feature flag states during rollouts
3. The gap between build-time version selection and runtime version enforcement creates operational fragility

The lack of version compatibility validation violates the principle of defensive programming and creates brittle tooling infrastructure.

### Citations

**File:** crates/transaction-generator-lib/src/publishing/prebuild_packages.rs (L73-87)
```rust
    /// Returns built options corresponding to the prebuilt config.
    pub fn build_options(&self) -> BuildOptions {
        let mut build_options = BuildOptions::move_2();
        build_options.dev = true;
        if self.latest_language {
            build_options = build_options.set_latest_language();
        }
        if self.use_local_std {
            build_options.override_std = Some(StdVersion::Local(get_local_framework_path()));
        }
        for exp in &self.experiments {
            build_options = build_options.with_experiment(exp);
        }
        build_options
    }
```

**File:** aptos-move/framework/src/built_package.rs (L165-171)
```rust
    pub fn set_latest_language(self) -> Self {
        BuildOptions {
            language_version: Some(LanguageVersion::latest()),
            bytecode_version: Some(file_format_common::VERSION_MAX),
            ..self
        }
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L565-565)
```rust
pub const VERSION_MAX: u32 = VERSION_10;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L617-620)
```rust
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
            } else {
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L137-142)
```rust
pub fn aptos_prod_deserializer_config(features: &Features) -> DeserializerConfig {
    DeserializerConfig::new(
        features.get_max_binary_format_version(),
        features.get_max_identifier_size(),
    )
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L274-274)
```rust
            FeatureFlag::VM_BINARY_FORMAT_V10,
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** third_party/move/move-vm/integration-tests/src/tests/binary_format_version.rs (L56-71)
```rust
    // Should reject the module with newer version with max binary format version being set to VERSION_MAX - 1
    {
        let storage = initialize_storage_with_binary_format_version(old_version);
        let module_storage = storage.as_unsync_module_storage();

        let result_new = StagingModuleStorage::create(m.self_addr(), &module_storage, vec![b_new
            .clone()
            .into()]);
        if let Err(err) = result_new {
            assert_eq!(err.major_status(), StatusCode::UNKNOWN_VERSION);
        } else {
            panic!("New module should not be publishable")
        }
        StagingModuleStorage::create(m.self_addr(), &module_storage, vec![b_old.clone().into()])
            .expect("Old module should be publishable");
    }
```

**File:** crates/transaction-generator-lib/src/call_custom_modules.rs (L344-348)
```rust
        txn_executor
            .execute_transactions(&requests_publish)
            .await
            .inspect_err(|err| error!("Failed to publish test package {}: {:#}", package_name, err))
            .unwrap();
```

**File:** crates/transaction-workloads-lib/src/move_workloads.rs (L366-366)
```rust
            EntryPoints::OrderBook { .. } => "experimental_usecases",
```
