# Audit Report

## Title
Critical Validator Crash via Native Struct Publishing Bypass

## Summary
An attacker can crash any Aptos validator node by publishing a Move module containing a native struct definition. The bytecode verifier allows native structs to bypass validation checks, but the runtime loader explicitly panics when encountering such structs, causing immediate validator termination and network disruption.

## Finding Description

The vulnerability exists in a validation gap between four components that creates a complete attack path:

**1. Module Builder allows native structs without field validation:**

The `declare_struct()` function creates structs with `StructFieldInformation::Native` as an initial placeholder value, accepting arbitrary `abilities` parameters. [1](#0-0) 

**2. Bytecode Verifier skips validation for native structs:**

The `verify_struct_def()` function explicitly returns `Ok(())` early for native structs without performing any ability constraint validation against fields, since native structs have no Move-level fields to validate. [2](#0-1) 

**3. Native validation only checks functions, not structs:**

The `validate_module_natives()` function in module publishing validation only iterates over `function_defs()` to check native functions for special address restrictions, completely missing native struct validation. [3](#0-2) 

**4. Runtime loader panics on native structs:**

When the VM attempts to load a module with a native struct during publishing, the `make_struct_type()` function matches on `StructFieldInformation::Native` and hits an `unreachable!()` macro that immediately panics the validator process. [4](#0-3) 

**5. Bytecode deserializer allows native structs:**

The bytecode deserializer explicitly supports deserializing native structs from bytecode by matching `SerializedNativeStructFlag::NATIVE` and creating `StructFieldInformation::Native`. [5](#0-4) 

**Complete Attack Path:**

1. Attacker crafts malicious bytecode with a native struct (manually editing compiled bytecode to set the native struct flag)
2. Attacker submits transaction calling `code::publish_package()` with this module
3. During `validate_publish_request()`, the validation calls `validate_module_natives()` which only checks native functions [6](#0-5) 
4. Native structs pass through all validation checks
5. The module proceeds to `finish_with_module_publishing_and_initialization()` [7](#0-6) 
6. `StagingModuleStorage::create_with_compat_config()` is called which eventually invokes `build_verified_module_with_linking_checks()` [8](#0-7) 
7. This calls `Module::new()` to construct the verified module [9](#0-8) 
8. `Module::new()` calls `make_struct_type()` for each struct definition
9. The native struct triggers the `unreachable!()` panic
10. The panic occurs AFTER VMState::VERIFIER/DESERIALIZER are restored, so the crash handler does NOT protect it [10](#0-9) 
11. Validator process terminates via `process::exit(12)`

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000)

This vulnerability causes **Total loss of liveness/network availability**, which aligns with the Aptos bug bounty CRITICAL severity category #4:

- Any validator processing the malicious transaction will immediately crash via panic
- All validators that attempt to execute the block containing this transaction will crash deterministically
- The network becomes partitioned as validators crash one by one during block execution
- Recovery requires manual intervention to remove the malicious transaction from mempool/blocks
- In worst case, this could require a hard fork if the transaction is already committed to validator state

The attack breaks the **Deterministic Execution** invariant: validators should produce identical state transitions, but instead they crash before completing state computation, creating consensus failure.

It violates the **Move VM Safety** invariant: the panic bypasses all normal error handling, gas metering, and transaction rollback mechanisms, causing undefined behavior in the validator process.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable by any network participant:

- **No special permissions required** - any user can submit module publishing transactions through `code::publish_package()`
- **No resource requirements** - the malicious module can be minimal in size
- **No timing constraints** - the attack works at any time during normal network operation
- **No prior state requirements** - doesn't depend on existing on-chain state or specific blockchain conditions
- **Simple execution** - requires only editing compiled bytecode to set the native struct flag (single byte modification)
- **Low economic cost** - only requires transaction gas fees (~0.001 APT)
- **No coordination needed** - single transaction is sufficient

The only requirement is creating bytecode with a native struct, which can be done by:
1. Compiling a normal Move module
2. Using a hex editor to change a struct's field information flag from `0x2` (Declared) to `0x1` (Native)
3. Submitting via standard transaction API

## Recommendation

Add native struct validation in the `validate_module_natives()` function to reject any modules with native structs from non-special addresses:

```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        
        // Check native functions
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message("Cannot publish native function to non-special address".to_string())
                        .finish(Location::Module(module.self_id())),
                );
            }
        }
        
        // ADD: Check native structs
        for struct_def in module.struct_defs() {
            if matches!(struct_def.field_information, StructFieldInformation::Native) {
                if !module_address.is_special() {
                    return Err(
                        PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                            .with_message("Cannot publish native struct to non-special address".to_string())
                            .finish(Location::Module(module.self_id())),
                    );
                }
            }
        }
    }
    Ok(())
}
```

Alternatively, replace the `unreachable!()` with proper error handling that returns a `PartialVMError`.

## Proof of Concept

```rust
// Proof of concept demonstrating the vulnerability
// Create a minimal module with native struct using bytecode manipulation

use move_binary_format::{CompiledModule, file_format::*};
use move_core_types::{account_address::AccountAddress, identifier::Identifier};

fn create_malicious_module() -> Vec<u8> {
    // Start with a valid compiled module
    let mut module = create_minimal_module();
    
    // Modify struct definition to set field_information to Native
    module.struct_defs[0].field_information = StructFieldInformation::Native;
    
    // Serialize to bytecode
    let mut bytecode = vec![];
    module.serialize(&mut bytecode).unwrap();
    bytecode
}

// Submit this via code::publish_package() transaction
// All validators processing this transaction will crash
```

## Notes

The vulnerability specifically affects the module publishing flow during transaction execution. While the bytecode deserializer and verifier allow native structs for backward compatibility, the runtime loader explicitly treats them as removed features via `unreachable!()`. This creates a exploitable gap where malicious bytecode can pass all validation checks but crash during actual loading.

The panic occurs in the module loading phase which happens AFTER the protected VMState::VERIFIER and VMState::DESERIALIZER states are restored, meaning the crash handler will terminate the process rather than catching and recovering from the panic.

### Citations

**File:** third_party/move/tools/move-asm/src/module_builder.rs (L313-317)
```rust
        let sdef = StructDefinition {
            struct_handle: shdl_idx,
            // Will be later set by `define_struct_layout`
            field_information: StructFieldInformation::Native,
        };
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1084-1086)
```rust
        match &struct_def.field_information {
            StructFieldInformation::Native => Ok(()),
            StructFieldInformation::Declared(fields) => self.verify_fields_of_struct(
```

**File:** aptos-move/aptos-vm/src/verifier/native_validation.rs (L12-27)
```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message(
                            "Cannot publish native function to non-special address".to_string(),
                        )
                        .finish(Location::Module(module.self_id())),
                );
            }
        }
    }
    Ok(())
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L452-453)
```rust
        let layout = match &struct_def.field_information {
            StructFieldInformation::Native => unreachable!("native structs have been removed"),
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L1511-1512)
```rust
    let field_information = match field_information_flag {
        SerializedNativeStructFlag::NATIVE => StructFieldInformation::Native,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1689-1690)
```rust
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L81-102)
```rust
    pub(crate) fn finish_with_module_publishing_and_initialization(
        mut self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        features: &Features,
        gas_feature_version: u64,
        change_set_configs: &ChangeSetConfigs,
        destination: AccountAddress,
        bundle: ModuleBundle,
        modules: &[CompiledModule],
        compatability_checks: Compatibility,
    ) -> Result<UserSessionChangeSet, VMStatus> {
        // Stage module bundle on top of module storage. In case modules cannot be added (for
        // example, fail compatibility checks, create cycles, etc.), we return an error here.
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L272-275)
```rust
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L217-224)
```rust
        let result = Module::new(
            &self.natives,
            locally_verified_module.1,
            locally_verified_module.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        );
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
