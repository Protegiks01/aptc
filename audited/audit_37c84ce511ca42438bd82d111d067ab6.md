# Audit Report

## Title
Feature Flag Bypass: Nested Function Types in Struct Fields Evade Bytecode Verification

## Summary
The Move bytecode verifier's `FeatureVerifier::verify_field_definition()` function only validates the top-level signature token of struct fields, failing to recursively check nested types. When the `ENABLE_FUNCTION_VALUES` feature flag is disabled, attackers can bypass verification by embedding function types within composite types (e.g., `Vector<Function<>>`, `StructInstantiation<Function<>>`), allowing prohibited function types to be published and loaded at runtime, potentially causing consensus divergence.

## Finding Description

The vulnerability exists in the `verify_field_definition()` method: [1](#0-0) 

This function only checks the immediate field signature token without recursively traversing nested types, unlike the secure implementation in `verify_signatures()`: [2](#0-1) 

The critical difference is that `verify_signatures()` uses `preorder_traversal()` to recursively examine all nested signature tokens, while `verify_field_definition()` only validates the outermost token.

**SignatureToken Structure:**
Move's type system supports complex nested structures: [3](#0-2) 

The `preorder_traversal()` iterator properly handles nested types: [4](#0-3) 

**Attack Path:**

1. When `ENABLE_FUNCTION_VALUES` is disabled in production via feature flag 89: [5](#0-4) 

2. This disables function values in the verifier config: [6](#0-5) 

3. Attacker crafts a module with struct fields like:
   - `field: vector<function()>`
   - `field: MyStruct<function()>`  
   - `field: &function()`

4. During verification, `FeatureVerifier` runs before `SignatureChecker`: [7](#0-6) 

5. The struct field check at line 73 calls `verify_field_definition()`: [8](#0-7) 

6. Only the outer type (`Vector`, `StructInstantiation`, `Reference`) is checked - the nested `Function` token passes undetected

7. Module is published successfully

8. At runtime, the type loader unconditionally converts `SignatureToken::Function` to `Type::Function`: [9](#0-8) 

9. Function types now exist in the VM when the feature is disabled, violating the security invariant

## Impact Explanation

**Severity: CRITICAL**

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution Violation**: If different validator nodes have different states of the feature flag or handle the invalid type differently, they will produce different state roots for the same block, causing consensus divergence.

2. **Move VM Safety Violation**: Function types that should not exist can lead to:
   - Unexpected VM behavior when operating on invalid types
   - Type system inconsistencies 
   - Potential crashes or undefined behavior
   - Memory safety issues if function type handling is incomplete

3. **Consensus Safety Violation**: Different validators may:
   - Reject or accept transactions differently based on local feature state
   - Produce divergent state during module loading
   - Fail to reach consensus on blocks containing the malicious module

4. **Feature Flag Security Bypass**: The entire purpose of feature flags is to gate experimental features until they are production-ready. This bypass allows attackers to force premature activation of unstable features.

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and potential "Non-recoverable network partition (requires hardfork)" if widespread consensus divergence occurs.

## Likelihood Explanation

**Likelihood: HIGH**

1. **No Special Privileges Required**: Any user with the ability to publish Move modules can exploit this vulnerability

2. **Simple Attack Vector**: Constructing a module with nested function types requires basic Move knowledge and standard bytecode generation tools

3. **Feature Flag Commonly Disabled**: New features like function values are often disabled initially or during rollback, making this attack surface active in production

4. **No Detection Mechanism**: The bypass is silent - there are no warnings or errors, making it difficult to detect until runtime failures occur

5. **Wide Attack Window**: The vulnerability exists from module publication until potential runtime execution, giving attackers flexibility in timing

## Recommendation

**Fix**: Modify `verify_field_definition()` to recursively check all nested types using `preorder_traversal()`, matching the pattern in `verify_signatures()`:

```rust
fn verify_field_definition(
    &self,
    struct_idx: usize,
    field: &FieldDefinition,
) -> PartialVMResult<()> {
    // Check all nested types, not just the top level
    for tok in field.signature.0.preorder_traversal() {
        self.verify_signature_token(tok)
            .map_err(|e| e.at_index(IndexKind::StructDefinition, struct_idx as u16))?;
    }
    Ok(())
}
```

**Additional Recommendations:**

1. Add comprehensive unit tests for nested function types in struct fields when feature flags are disabled

2. Review all other uses of `verify_signature_token()` to ensure they properly traverse nested types

3. Consider adding a fuzzer that generates deeply nested type structures to catch similar issues

4. Document the requirement that feature flag checks must recursively validate all nested types

## Proof of Concept

**Rust Test (add to `third_party/move/move-bytecode-verifier/tests/`):**

```rust
use move_binary_format::{
    file_format::*,
    CompiledModule,
};
use move_bytecode_verifier::{VerifierConfig, verify_module_with_config};
use move_core_types::{identifier::Identifier, account_address::AccountAddress};

#[test]
fn test_nested_function_type_bypass() {
    // Create a module with Vector<Function<>>
    let mut module = CompiledModule::default();
    
    // Add struct with field containing nested function type
    let struct_handle = StructHandle {
        module: ModuleHandleIndex(0),
        name: IdentifierIndex(0),
        abilities: AbilitySet::EMPTY,
        type_parameters: vec![],
    };
    
    let field = FieldDefinition {
        name: IdentifierIndex(1),
        signature: TypeSignature(
            SignatureToken::Vector(Box::new(
                SignatureToken::Function(
                    vec![], // no args
                    vec![], // no return
                    AbilitySet::EMPTY
                )
            ))
        ),
    };
    
    let struct_def = StructDefinition {
        struct_handle: StructHandleIndex(0),
        field_information: StructFieldInformation::Declared(vec![field]),
    };
    
    // Configure verifier with function values DISABLED
    let config = VerifierConfig {
        enable_function_values: false,
        ..Default::default()
    };
    
    // This should FAIL but currently PASSES due to the vulnerability
    let result = verify_module_with_config(&config, &module);
    
    // Expected: Err (feature not enabled)
    // Actual: Ok (bypass successful)
    assert!(result.is_err(), "Nested function type should be rejected when feature disabled");
}
```

**Move Module Example:**

```move
module attacker::exploit {
    // When ENABLE_FUNCTION_VALUES is disabled, this should fail verification
    // but bypasses the check due to nested function type
    struct MaliciousStruct has drop {
        // Vector containing function types
        exploit_field: vector<|u64| u64>,
    }
    
    // Or using generic structs
    struct GenericWrapper<T> has drop {
        inner: T,
    }
    
    struct AnotherExploit has drop {
        // Nested generic with function type
        wrapped: GenericWrapper<|bool| bool>,
    }
}
```

The attack succeeds because `verify_field_definition()` only checks `Vector` or `GenericWrapper`, not the nested `Function` token inside them.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L65-97)
```rust
    fn verify_struct_defs(&self) -> PartialVMResult<()> {
        if !self.config.enable_enum_types || !self.config.enable_function_values {
            if let Some(defs) = self.code.struct_defs() {
                for (idx, sdef) in defs.iter().enumerate() {
                    match &sdef.field_information {
                        StructFieldInformation::Declared(fields) => {
                            if !self.config.enable_function_values {
                                for field in fields {
                                    self.verify_field_definition(idx, field)?
                                }
                            }
                        },
                        StructFieldInformation::DeclaredVariants(variants) => {
                            if !self.config.enable_enum_types {
                                return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                                    .at_index(IndexKind::StructDefinition, idx as u16)
                                    .with_message("enum type feature not enabled".to_string()));
                            }
                            if !self.config.enable_function_values {
                                for variant in variants {
                                    for field in &variant.fields {
                                        self.verify_field_definition(idx, field)?
                                    }
                                }
                            }
                        },
                        StructFieldInformation::Native => {},
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L99-106)
```rust
    fn verify_field_definition(
        &self,
        struct_idx: usize,
        field: &FieldDefinition,
    ) -> PartialVMResult<()> {
        self.verify_signature_token(&field.signature.0)
            .map_err(|e| e.at_index(IndexKind::StructDefinition, struct_idx as u16))
    }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L159-171)
```rust
    fn verify_signatures(&self) -> PartialVMResult<()> {
        if !self.config.enable_function_values {
            for (idx, sig) in self.code.signatures().iter().enumerate() {
                for tok in &sig.0 {
                    for t in tok.preorder_traversal() {
                        self.verify_signature_token(t)
                            .map_err(|e| e.at_index(IndexKind::Signature, idx as u16))?
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L932-971)
```rust
pub enum SignatureToken {
    /// Boolean, `true` or `false`.
    Bool,
    /// Unsigned integers, 8 bits length.
    U8,
    /// Unsigned integers, 64 bits length.
    U64,
    /// Unsigned integers, 128 bits length.
    U128,
    /// Address, a 16 bytes immutable type.
    Address,
    /// Signer, a 16 bytes immutable type representing the capability to publish at an address
    Signer,
    /// Vector
    Vector(Box<SignatureToken>),
    /// Function, with n argument types and m result types, and an associated ability set.
    Function(Vec<SignatureToken>, Vec<SignatureToken>, AbilitySet),
    /// User defined type
    Struct(StructHandleIndex),
    StructInstantiation(StructHandleIndex, Vec<SignatureToken>),
    /// Reference to a type.
    Reference(Box<SignatureToken>),
    /// Mutable reference to a type.
    MutableReference(Box<SignatureToken>),
    /// Type parameter.
    TypeParameter(TypeParameterIndex),
    /// Unsigned integers, 16 bits length.
    U16,
    /// Unsigned integers, 32 bits length.
    U32,
    /// Unsigned integers, 256 bits length.
    U256,
    /// Signed integers
    I8,
    I16,
    I32,
    I64,
    I128,
    I256,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L977-1011)
```rust
pub struct SignatureTokenPreorderTraversalIter<'a> {
    stack: Vec<&'a SignatureToken>,
}

impl<'a> Iterator for SignatureTokenPreorderTraversalIter<'a> {
    type Item = &'a SignatureToken;

    fn next(&mut self) -> Option<Self::Item> {
        use SignatureToken::*;

        match self.stack.pop() {
            Some(tok) => {
                match tok {
                    Reference(inner_tok) | MutableReference(inner_tok) | Vector(inner_tok) => {
                        self.stack.push(inner_tok)
                    },

                    StructInstantiation(_, inner_toks) => {
                        self.stack.extend(inner_toks.iter().rev())
                    },

                    Function(args, result, _) => {
                        self.stack.extend(result.iter().rev());
                        self.stack.extend(args.iter().rev());
                    },

                    Signer | Bool | Address | U8 | U16 | U32 | U64 | U128 | U256 | I8 | I16
                    | I32 | I64 | I128 | I256 | Struct(_) | TypeParameter(_) => (),
                }
                Some(tok)
            },
            None => None,
        }
    }
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L138-139)
```rust
    /// Whether function values are enabled.
    ENABLE_FUNCTION_VALUES = 89,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-152)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L141-150)
```rust
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;
```

**File:** third_party/move/move-vm/runtime/src/loader/type_loader.rs (L78-89)
```rust
        SignatureToken::Function(args, results, abilities) => {
            let (args, args_fully_instantiated) =
                convert_toks_to_types_impl(module, args, struct_name_table)?;
            let (results, results_fully_instantiated) =
                convert_toks_to_types_impl(module, results, struct_name_table)?;
            let ty = Type::Function {
                args,
                results,
                abilities: *abilities,
            };
            (ty, args_fully_instantiated && results_fully_instantiated)
        },
```
