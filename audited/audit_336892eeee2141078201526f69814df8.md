# Audit Report

## Title
Unauthenticated DoS via Unlimited Invalid Requests to VFN Network Storage Service

## Summary
The storage service's request moderator fails to enforce rate limiting on VFN (Validator Full Node) network peers, allowing any unauthenticated attacker to connect to a validator's VFN endpoint and send unlimited invalid requests, causing resource exhaustion without ever being ignored or rate-limited. This violates the system's resource limit invariants and can degrade or disable critical state synchronization services.

## Finding Description

The storage service implements a `RequestModerator` that tracks invalid requests per peer and ignores peers that exceed a threshold (`max_invalid_requests_per_peer`, default 500). However, the ignore mechanism only applies to peers on the public network. [1](#0-0) 

The critical check at line 56 uses `peer_network_id.network_id().is_public_network()`, which only returns `true` for `NetworkId::Public`. [2](#0-1) 

VFN peers use `NetworkId::Vfn`, not `NetworkId::Public`, meaning they are never ignored despite accumulating invalid request counts. This is confirmed by the test case: [3](#0-2) 

**The Attack Vector:**

By default, VFN networks use non-mutual authentication (`mutual_authentication = false`): [4](#0-3) 

This results in `AuthenticationMode::MaybeMutual`: [5](#0-4) 

When an unauthenticated peer connects to a validator's VFN network endpoint, the handshake logic infers the peer role as `ValidatorFullNode`: [6](#0-5) 

**Exploitation Flow:**
1. Attacker establishes NoiseIK connection to validator's VFN endpoint (default port 6181)
2. Connection is accepted in `MaybeMutual` mode without mutual authentication
3. Peer is inferred as `PeerRole::ValidatorFullNode` with `NetworkId::Vfn`
4. Attacker sends invalid storage service requests (e.g., requesting non-existent data ranges)
5. Each request is validated by `RequestModerator.validate_request()`: [7](#0-6) 
6. Invalid requests increment the peer's invalid count but peer is never ignored
7. Each request consumes CPU for validation, logging, and metrics
8. Attack can continue indefinitely without rate limiting

## Impact Explanation

**Severity: Critical** (meets "Total loss of liveness/network availability" criteria)

This vulnerability enables:
- **Resource Exhaustion:** Each invalid request consumes CPU cycles for storage summary validation, request processing, error handling, and metrics recording
- **Service Degradation:** Unlimited invalid requests can saturate the storage service's request processing capacity, delaying or preventing legitimate state sync operations
- **Validator Node Impact:** Since validators rely on storage service for state synchronization, degraded performance can affect consensus participation and block production
- **No Rate Limiting:** Unlike public network peers that get ignored after 500 invalid requests with 5-minute exponential backoff, VFN attackers face no consequences

The impact is amplified because:
- Storage service is critical for validator operations and network health
- Default VFN configuration is vulnerable (no code changes required)
- Attack requires no authentication or special privileges
- Multiple attackers can simultaneously exploit different validators

## Likelihood Explanation

**Likelihood: High**

- **Trivial Exploitation:** Attacker only needs to establish a network connection using standard NoiseIK protocol
- **No Authentication Required:** Default VFN network configuration accepts unauthenticated connections
- **Public Endpoint:** VFN network endpoints are discoverable (default port 6181, often listed in discovery)
- **Sustained Attack:** Single attacker can maintain persistent connection sending invalid requests indefinitely
- **Default Vulnerable:** No configuration changes needed; vulnerability exists in default validator setup
- **Low Detection:** Invalid requests appear as normal protocol errors in logs; difficult to distinguish from legitimate sync issues

## Recommendation

**Immediate Fix:** Extend rate limiting to all network types, not just public networks.

Modify `UnhealthyPeerState::increment_invalid_request_count` to ignore peers regardless of network type:

```rust
pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
    // Increment the invalid request count
    self.invalid_request_count += 1;

    // If the peer has sent too many invalid requests, start ignoring it
    if self.ignore_start_time.is_none()
        && self.invalid_request_count >= self.max_invalid_requests
    {
        // Start ignoring the peer
        self.ignore_start_time = Some(self.time_service.now());

        // Log the fact that we're now ignoring the peer
        warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
            .peer_network_id(peer_network_id)
            .message("Ignoring peer due to too many invalid requests!"));
    }
}
```

**Additional Hardening:**
1. Enable mutual authentication for VFN networks by default for production validators
2. Add separate rate limiting configuration for different network types
3. Implement connection-level rate limiting (requests per second) in addition to cumulative invalid count
4. Add alerting when peers exceed invalid request thresholds on non-public networks
5. Consider implementing proof-of-work or other anti-abuse mechanisms for VFN connections

## Proof of Concept

```rust
// Integration test demonstrating unlimited VFN exploitation
#[tokio::test]
async fn test_vfn_unlimited_invalid_requests_dos() {
    use crate::tests::{mock::MockClient, utils};
    use aptos_config::config::StorageServiceConfig;
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_storage_service_types::{
        requests::{DataRequest, StorageServiceRequest, TransactionsWithProofRequest},
        StorageServiceError,
    };
    use aptos_types::PeerId;
    
    // Create storage service with low threshold for testing
    let max_invalid_requests = 10;
    let config = StorageServiceConfig {
        max_invalid_requests_per_peer: max_invalid_requests,
        ..Default::default()
    };
    
    let (mut mock_client, mut service, _, _, _) = MockClient::new(None, Some(config));
    utils::update_storage_server_summary(&mut service, 1000, 10);
    
    // Spawn service
    tokio::spawn(service.start());
    
    // Simulate attacker connecting as VFN peer
    let attacker_peer = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
    
    // Send far more than max_invalid_requests
    let attack_count = max_invalid_requests * 100; // 1000 requests
    for i in 0..attack_count {
        // Send invalid request (requesting beyond available data)
        let response = mock_client
            .send_request(
                attacker_peer,
                StorageServiceRequest {
                    data_request: DataRequest::GetTransactionsWithProof(
                        TransactionsWithProofRequest {
                            proof_version: 999999, // Beyond available data
                            start_version: 999999,
                            end_version: 1000000,
                            include_events: false,
                        }
                    ),
                    use_compression: false,
                }
            )
            .await;
        
        // Attacker continues to receive InvalidRequest, never TooManyInvalidRequests
        match response {
            Err(StorageServiceError::InvalidRequest(_)) => {
                // Expected for all requests - no rate limiting!
                continue;
            },
            Err(StorageServiceError::TooManyInvalidRequests(_)) => {
                panic!("VFN peer should never receive TooManyInvalidRequests! \
                        Got blocked at request {}", i);
            },
            _ => panic!("Unexpected response"),
        }
    }
    
    // Verify attacker sent 1000 invalid requests without being blocked
    println!("Successfully sent {} invalid requests as VFN without rate limiting", 
             attack_count);
}
```

**To exploit in practice:**
1. Identify validator VFN endpoint (typically port 6181)
2. Establish NoiseIK connection using any peer identity
3. Send invalid storage service requests in a loop:
   - Request non-existent version ranges
   - Request data with invalid proof versions
   - Request state at non-existent versions
4. Monitor validator's CPU usage and storage service latency metrics
5. Scale attack across multiple validators simultaneously

**Notes:**
- Test demonstrates VFN peers can send 100x the threshold without being blocked
- In production, sustained attack could continue indefinitely until manual intervention
- Validator operators would observe high CPU, degraded sync performance, and elevated error logs but no automatic mitigation occurs
- The vulnerability breaks the documented invariant: "Resource Limits: All operations must respect gas, storage, and computational limits"

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-196)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
    }
```

**File:** config/src/network_id.rs (L159-162)
```rust
impl NetworkId {
    pub fn is_public_network(&self) -> bool {
        self == &NetworkId::Public
    }
```

**File:** state-sync/storage-service/server/src/tests/request_moderator.rs (L89-117)
```rust
    // Process many invalid requests from a VFN and verify it is never ignored
    let vfn_peer_network_id = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
    for _ in 0..max_invalid_requests_per_peer * 2 {
        // Send the invalid request
        let response = send_invalid_transaction_request(
            highest_synced_version,
            &mut mock_client,
            vfn_peer_network_id,
        )
        .await;

        // Verify we get an invalid request error
        assert_matches!(
            response.unwrap_err(),
            StorageServiceError::InvalidRequest(_)
        );
    }

    // Verify the unhealthy peer states
    assert_eq!(unhealthy_peer_states.len(), 2);

    // Verify the unhealthy peer state for the PFN
    let unhealthy_pfn_state = unhealthy_peer_states.get(&pfn_peer_network_id).unwrap();
    assert!(unhealthy_pfn_state.is_ignored());

    // Verify the unhealthy peer state for the VFN
    let unhealthy_vfn_state = unhealthy_peer_states.get(&vfn_peer_network_id).unwrap();
    assert!(!unhealthy_vfn_state.is_ignored());
}
```

**File:** config/src/config/network_config.rs (L134-143)
```rust
impl NetworkConfig {
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
            network_id,
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/noise/handshake.rs (L407-416)
```rust
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
```
