# Audit Report

## Title
SignatureAggregator State Corruption on Aggregation Failure Prevents QC Formation

## Summary
When signature aggregation fails with `FailedToAggregateSignature` error, the `SignatureAggregator` is left in a corrupted state with the invalid signature still present. This prevents all subsequent valid votes from forming a Quorum Certificate for that block, causing consensus liveness issues.

## Finding Description

The vulnerability exists in the error handling path of `SignatureAggregator::aggregate_and_verify()` method. When processing votes in `pending_votes.rs`, signatures are optimistically added to the `SignatureAggregator` without individual verification. [1](#0-0) 

When sufficient voting power is reached, the system attempts to aggregate all signatures. [2](#0-1) 

The critical flaw is in `aggregate_and_verify()`'s error handling. If `try_aggregate()` fails during the initial aggregation attempt, the method returns immediately without cleaning up invalid signatures. [3](#0-2) 

The `filter_invalid_signatures()` cleanup is only called if aggregation succeeds but verification fails (line 530). When aggregation itself fails (line 521 returns error via `?` operator), the invalid signature remains in the `SignatureAggregator`'s internal `signatures` BTreeMap. [4](#0-3) 

**Attack Scenario:**
1. Malicious validator crafts a vote with a BLS signature that deserializes successfully but causes `bls12381::Signature::aggregate()` to fail (e.g., invalid group element)
2. Vote passes initial validation checks (author is known, voting power exists) [5](#0-4) 
3. Signature is added to `SignatureAggregator` at line 368
4. When quorum is reached, `try_aggregate()` calls `verifier.aggregate_signatures()` [6](#0-5) 
5. BLS aggregation fails, returning `FailedToAggregateSignature` [7](#0-6) 
6. Error propagates to `pending_votes.rs` line 399, returning `ErrorAggregatingSignature` [8](#0-7) 
7. The corrupted `SignatureAggregator` remains in `li_digest_to_votes` HashMap [9](#0-8) 
8. All subsequent valid votes for the same block are added to the SAME corrupted aggregator
9. Every aggregation attempt fails with the same error, permanently preventing QC formation for that block

The error is treated as a failure by `round_manager.rs`, but the underlying state corruption persists. [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: Consensus progress is blocked for affected rounds, causing validators to timeout and retry
2. **Significant Protocol Violations**: Breaks the consensus liveness guarantee - honest validators cannot form QCs despite having sufficient voting power
3. **Network-Wide Impact**: A single malicious validator can disrupt consensus for any block they participate in voting on

While this is primarily a liveness issue (not safety), it represents a significant degradation in network performance and reliability. The attack is repeatable across multiple rounds and blocks, potentially causing sustained consensus disruption.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires one malicious validator with minimal resources
- **Attack Complexity**: Low - attacker simply needs to craft a vote with an invalid BLS signature that passes deserialization but fails aggregation
- **Detection Difficulty**: Hard to distinguish from legitimate network issues initially
- **Repeatability**: Attack can be executed repeatedly across different blocks and rounds
- **No Collusion Required**: Single validator can execute the attack independently

The BLS signature deserialization accepts 96-byte inputs that represent G2 curve points, but not all deserialized signatures are valid for aggregation. This gap between deserialization validation and aggregation requirements creates the exploitable condition.

## Recommendation

Modify `SignatureAggregator::aggregate_and_verify()` to clean up invalid signatures even when initial aggregation fails:

```rust
pub fn aggregate_and_verify(
    &mut self,
    verifier: &ValidatorVerifier,
) -> Result<(T, AggregateSignature), VerifyError> {
    let aggregated_sig = match self.try_aggregate(verifier) {
        Ok(sig) => sig,
        Err(e) => {
            // If aggregation fails, filter out invalid signatures and retry
            self.filter_invalid_signatures(verifier);
            self.try_aggregate(verifier)?
        }
    };
    
    match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
        Ok(_) => {
            Ok((self.data.clone(), aggregated_sig))
        },
        Err(_) => {
            self.filter_invalid_signatures(verifier);
            let aggregated_sig = self.try_aggregate(verifier)?;
            Ok((self.data.clone(), aggregated_sig))
        },
    }
}
```

This ensures that invalid signatures are filtered out regardless of whether the failure occurs during aggregation or verification, preventing state corruption.

## Proof of Concept

Add this test to `types/src/ledger_info.rs` in the tests module:

```rust
#[test]
fn test_aggregation_failure_corrupts_state() {
    let ledger_info = LedgerInfo::new(BlockInfo::empty(), HashValue::random());
    const NUM_SIGNERS: u8 = 5;
    let validator_signers: Vec<ValidatorSigner> = (0..NUM_SIGNERS)
        .map(|i| ValidatorSigner::random([i; 32]))
        .collect();
    let mut validator_infos = vec![];
    
    for validator in validator_signers.iter() {
        validator_infos.push(ValidatorConsensusInfo::new(
            validator.author(),
            validator.public_key(),
            1,
        ));
    }
    
    let validator_verifier =
        ValidatorVerifier::new_with_quorum_voting_power(validator_infos, 3)
            .expect("Incorrect quorum size.");
    
    let mut signature_aggregator = SignatureAggregator::new(ledger_info.clone());
    
    // Add two valid signatures
    signature_aggregator.add_signature(
        validator_signers[0].author(),
        &SignatureWithStatus::from(validator_signers[0].sign(&ledger_info).unwrap()),
    );
    signature_aggregator.add_signature(
        validator_signers[1].author(),
        &SignatureWithStatus::from(validator_signers[1].sign(&ledger_info).unwrap()),
    );
    
    // Add a signature that will cause aggregation to fail
    // This simulates a malicious signature that passes deserialization but fails aggregation
    let mut bad_sig_bytes = [0u8; 96];
    bad_sig_bytes[0] = 0xC0; // Set infinity bit to create invalid signature
    let bad_sig = bls12381::Signature::try_from(&bad_sig_bytes[..]).unwrap();
    signature_aggregator.add_signature(
        validator_signers[2].author(),
        &SignatureWithStatus::from(bad_sig),
    );
    
    // Now we have 3 signatures (quorum), try to aggregate
    let result = signature_aggregator.aggregate_and_verify(&validator_verifier);
    
    // The aggregation should fail due to the bad signature
    assert!(result.is_err());
    
    // VULNERABILITY: The bad signature is still in the aggregator!
    assert_eq!(signature_aggregator.all_voters().count(), 3);
    
    // Add another valid signature
    signature_aggregator.add_signature(
        validator_signers[3].author(),
        &SignatureWithStatus::from(validator_signers[3].sign(&ledger_info).unwrap()),
    );
    
    // Try to aggregate again - this should succeed with 3 valid signatures
    // But it FAILS because the bad signature is still corrupting the aggregator
    let result2 = signature_aggregator.aggregate_and_verify(&validator_verifier);
    assert!(result2.is_err()); // VULNERABILITY: Still fails even with enough valid votes
}
```

**Notes**

This vulnerability represents a critical gap in the optimistic signature verification error recovery logic. The design correctly handles the case where aggregation succeeds but verification fails (by filtering invalid signatures), but fails to handle the case where aggregation itself fails. This asymmetry in error handling creates a permanent state corruption that cannot be recovered from without moving to a new round, effectively granting malicious validators a reliable liveness attack vector.

### Citations

**File:** consensus/src/pending_votes.rs (L324-329)
```rust
        let (hash_index, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            (
                len,
                VoteStatus::NotEnoughVotes(SignatureAggregator::new(vote.ledger_info().clone())),
            )
        });
```

**File:** consensus/src/pending_votes.rs (L331-341)
```rust
        let validator_voting_power = validator_verifier.get_voting_power(&vote.author());

        if validator_voting_power.is_none() {
            warn!("Received vote from an unknown author: {}", vote.author());
            return VoteReceptionResult::UnknownAuthor(vote.author());
        }
        let validator_voting_power =
            validator_voting_power.expect("Author must exist in the validator set.");
        if validator_voting_power == 0 {
            warn!("Received vote with no voting power, from {}", vote.author());
        }
```

**File:** consensus/src/pending_votes.rs (L368-368)
```rust
                sig_aggregator.add_signature(vote.author(), vote.signature_with_status());
```

**File:** consensus/src/pending_votes.rs (L383-388)
```rust
                            sig_aggregator.aggregate_and_verify(validator_verifier).map(
                                |(ledger_info, aggregated_sig)| {
                                    LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                                },
                            )
                        };
```

**File:** consensus/src/pending_votes.rs (L399-399)
```rust
                            Err(e) => return VoteReceptionResult::ErrorAggregatingSignature(e),
```

**File:** types/src/ledger_info.rs (L510-513)
```rust
    fn filter_invalid_signatures(&mut self, verifier: &ValidatorVerifier) {
        let signatures = mem::take(&mut self.signatures);
        self.signatures = verifier.filter_invalid_signatures(&self.data, signatures);
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** types/src/validator_verifier.rs (L316-335)
```rust
    pub fn aggregate_signatures<'a>(
        &self,
        signatures: impl Iterator<Item = (&'a AccountAddress, &'a bls12381::Signature)>,
    ) -> Result<AggregateSignature, VerifyError> {
        let mut sigs = vec![];
        let mut masks = BitVec::with_num_bits(self.len() as u16);
        for (addr, sig) in signatures {
            let index = *self
                .address_to_validator_index
                .get(addr)
                .ok_or(VerifyError::UnknownAuthor)?;
            masks.set(index as u16);
            sigs.push(sig.clone());
        }
        // Perform an optimistic aggregation of the signatures without verification.
        let aggregated_sig = bls12381::Signature::aggregate(sigs)
            .map_err(|_| VerifyError::FailedToAggregateSignature)?;

        Ok(AggregateSignature::new(masks, Some(aggregated_sig)))
    }
```

**File:** consensus/src/round_manager.rs (L1829-1829)
```rust
            e => Err(anyhow::anyhow!("{:?}", e)),
```
