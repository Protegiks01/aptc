# Audit Report

## Title
Encrypted Payload Signature Verification Bypass Enables API-Level DoS Attack

## Summary
The API layer validates encrypted transaction payloads by checking only the ciphertext signature, not the transaction signature. This allows attackers to submit transactions with valid ciphertext signatures but invalid transaction signatures, bypassing API validation and consuming resources before rejection in the mempool VM validator. [1](#0-0) 

## Finding Description

The encrypted payload verification and transaction signature verification occur at different stages with insufficient early validation:

**Stage 1 - API Validation** validates only the ciphertext signature: [2](#0-1) 

The `payload.verify()` method checks the Ed25519 signature on the ciphertext itself: [3](#0-2) 

This ciphertext signature is created during encryption and can be generated by anyone: [4](#0-3) 

**Stage 2 - Transaction Signature Verification** happens only in VM validation: [5](#0-4) 

This verifies the SignedTransaction's authenticator field against the raw transaction: [6](#0-5) 

**Attack Path:**
1. Attacker creates an encrypted payload and signs the ciphertext with their own encryption signing key
2. Attacker constructs a SignedTransaction with:
   - `sender`: any address (victim or random)
   - `payload`: EncryptedPayload with attacker's valid ciphertext signature
   - `authenticator`: forged/invalid signature (attacker lacks sender's private key)
3. API accepts transaction because `payload.verify(sender)` only validates ciphertext signature
4. Transaction forwarded to mempool: [7](#0-6) 
5. VM validator calls `validate_transaction()`: [8](#0-7) 
6. Transaction rejected with `INVALID_SIGNATURE` status code
7. Resources consumed: deserialization, API processing, mempool queueing, VM validation overhead

The vulnerability violates the **Transaction Validation** invariant requiring early signature verification before resource-intensive operations.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:
- Resource exhaustion attack allowing unprivileged attackers to degrade node performance
- API accepts invalid transactions that will definitely be rejected, wasting computational resources
- Could lead to state inconsistencies requiring intervention if mempool becomes saturated
- Not Critical severity because: no fund loss, no consensus break, no permanent damage
- Not High severity because: unlikely to cause complete API crashes (rate limits may exist at network layer)

The impact is amplified because encrypted transactions bypass normal payload validation: [9](#0-8) 

## Likelihood Explanation

**High likelihood** of exploitation if encrypted transactions are enabled:
- Attack requires no special privileges or insider access
- Attacker can create valid ciphertext signatures trivially
- No authentication required to submit transactions to API
- Current implementation provides no API-level signature verification

**Current mitigation:** Feature is behind configuration flags: [10](#0-9) 

However, once `allow_encrypted_txns_submission` is enabled, the vulnerability becomes immediately exploitable.

## Recommendation

Add transaction signature verification in the API layer before accepting encrypted payloads:

```rust
fn validate_signed_transaction_payload(
    &self,
    ledger_info: &LedgerInfo,
    signed_transaction: &SignedTransaction,
) -> Result<(), SubmitTransactionError> {
    match signed_transaction.payload() {
        // ... other cases ...
        TransactionPayload::EncryptedPayload(payload) => {
            if !self.context.node_config.api.allow_encrypted_txns_submission {
                return Err(SubmitTransactionError::bad_request_with_code(
                    "Encrypted Transaction submission is not allowed yet",
                    AptosErrorCode::InvalidInput,
                    ledger_info,
                ));
            }

            if !payload.is_encrypted() {
                return Err(SubmitTransactionError::bad_request_with_code(
                    "Encrypted transaction must be in encrypted state",
                    AptosErrorCode::InvalidInput,
                    ledger_info,
                ));
            }

            // ADD THIS: Verify transaction signature before payload verification
            if let Err(e) = signed_transaction.verify_signature() {
                return Err(SubmitTransactionError::bad_request_with_code(
                    e.context("Transaction signature verification failed"),
                    AptosErrorCode::InvalidInput,
                    ledger_info,
                ));
            }

            if let Err(e) = payload.verify(signed_transaction.sender()) {
                return Err(SubmitTransactionError::bad_request_with_code(
                    e.context("Encrypted transaction payload could not be verified"),
                    AptosErrorCode::InvalidInput,
                    ledger_info,
                ));
            }
        },
    }
    Ok(())
}
```

This ensures transaction signatures are verified at the API boundary, rejecting invalid transactions before consuming mempool resources.

## Proof of Concept

```rust
#[cfg(test)]
mod test_encrypted_payload_bypass {
    use aptos_crypto::{ed25519::{Ed25519PrivateKey, Ed25519Signature}, HashValue, PrivateKey, Uniform};
    use aptos_types::transaction::{
        RawTransaction, SignedTransaction, TransactionPayload, 
        authenticator::TransactionAuthenticator,
        encrypted_payload::EncryptedPayload,
    };
    use aptos_batch_encryption::{
        shared::ciphertext::CTEncrypt,
        schemes::fptx::FPTX,
    };
    
    #[test]
    fn test_invalid_signature_with_valid_encrypted_payload() {
        // Setup
        let mut rng = rand::thread_rng();
        let victim_address = AccountAddress::random();
        let attacker_key = Ed25519PrivateKey::generate(&mut rng);
        
        // Create encrypted payload with valid ciphertext signature
        let (ek, _, _, _) = FPTX::setup_for_testing(rng.gen(), 8, 1, &tc).unwrap();
        let plaintext = String::from("malicious");
        let associated_data = PayloadAssociatedData::new(victim_address);
        let ciphertext = ek.encrypt(&mut rng, &plaintext, &associated_data).unwrap();
        
        let encrypted_payload = EncryptedPayload::Encrypted {
            ciphertext,
            extra_config: TransactionExtraConfig::default(),
            payload_hash: HashValue::random(),
        };
        
        // Create transaction with INVALID signature
        let raw_txn = RawTransaction::new(
            victim_address, // pretend to be victim
            0,
            TransactionPayload::EncryptedPayload(encrypted_payload),
            1000000,
            0,
            u64::MAX,
            ChainId::test(),
        );
        
        // Sign with ATTACKER's key (not victim's)
        let invalid_signature = attacker_key.sign(&raw_txn).unwrap();
        let invalid_authenticator = TransactionAuthenticator::ed25519(
            Ed25519PublicKey::from(&attacker_key),
            invalid_signature
        );
        
        let signed_txn = SignedTransaction::new_signed_transaction(
            raw_txn,
            invalid_authenticator,
        );
        
        // Verify: payload.verify() passes (checks ciphertext signature)
        if let TransactionPayload::EncryptedPayload(payload) = signed_txn.payload() {
            assert!(payload.verify(victim_address).is_ok(), 
                "Payload verification should pass with valid ciphertext signature");
        }
        
        // Verify: check_signature() fails (checks transaction signature)
        assert!(signed_txn.verify_signature().is_err(),
            "Transaction signature verification should fail - this is the vulnerability");
        
        // This transaction would pass API validation but fail mempool validation
    }
}
```

## Notes

- The vulnerability exists in the transaction submission pipeline where signature verification is deferred from API to mempool
- The ciphertext signature and transaction signature serve different purposes and are created by different parties
- Current mitigation relies on feature flags (`allow_encrypted_txns_submission`) keeping encrypted transactions disabled
- Once enabled, attackers can exploit this to cause resource exhaustion without authentication
- The fix requires moving transaction signature verification earlier in the pipeline to reject invalid transactions at the API boundary
- This issue only affects encrypted transaction payloads; standard transactions follow different validation paths that properly verify signatures early

### Citations

**File:** api/src/transactions.rs (L1256-1350)
```rust
    fn validate_signed_transaction_payload(
        &self,
        ledger_info: &LedgerInfo,
        signed_transaction: &SignedTransaction,
    ) -> Result<(), SubmitTransactionError> {
        match signed_transaction.payload() {
            TransactionPayload::EntryFunction(entry_function) => {
                TransactionsApi::validate_entry_function_payload_format(
                    ledger_info,
                    entry_function,
                )?;
            },
            TransactionPayload::Script(script) => {
                TransactionsApi::validate_script(ledger_info, script)?;
            },
            TransactionPayload::Multisig(multisig) => {
                if let Some(payload) = &multisig.transaction_payload {
                    match payload {
                        MultisigTransactionPayload::EntryFunction(entry_function) => {
                            TransactionsApi::validate_entry_function_payload_format(
                                ledger_info,
                                entry_function,
                            )?;
                        },
                    }
                }
            },

            // Deprecated. To avoid panics when malicios users submit this
            // payload, return an error.
            TransactionPayload::ModuleBundle(_) => {
                return Err(SubmitTransactionError::bad_request_with_code(
                    "Module bundle payload has been removed",
                    AptosErrorCode::InvalidInput,
                    ledger_info,
                ))
            },
            TransactionPayload::Payload(TransactionPayloadInner::V1 {
                executable,
                extra_config,
            }) => match executable {
                TransactionExecutable::Script(script) => {
                    TransactionsApi::validate_script(ledger_info, script)?;
                    if extra_config.is_multisig() {
                        return Err(SubmitTransactionError::bad_request_with_code(
                            "Script transaction payload must not be a multisig transaction",
                            AptosErrorCode::InvalidInput,
                            ledger_info,
                        ));
                    }
                },
                TransactionExecutable::EntryFunction(entry_function) => {
                    TransactionsApi::validate_entry_function_payload_format(
                        ledger_info,
                        entry_function,
                    )?;
                },
                TransactionExecutable::Empty => {
                    if !extra_config.is_multisig() {
                        return Err(SubmitTransactionError::bad_request_with_code(
                            "Empty transaction payload must be a multisig transaction",
                            AptosErrorCode::InvalidInput,
                            ledger_info,
                        ));
                    }
                },
            },
            TransactionPayload::EncryptedPayload(payload) => {
                if !self.context.node_config.api.allow_encrypted_txns_submission {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted Transaction submission is not allowed yet",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if !payload.is_encrypted() {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted transaction must be in encrypted state",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
            },
        }
        Ok(())
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L147-150)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-132)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```

**File:** types/src/transaction/mod.rs (L1310-1318)
```rust
    pub fn check_signature(self) -> Result<SignatureCheckedTransaction> {
        self.authenticator.verify(&self.raw_txn)?;
        Ok(SignatureCheckedTransaction(self))
    }

    pub fn verify_signature(&self) -> Result<()> {
        self.authenticator.verify(&self.raw_txn)?;
        Ok(())
    }
```

**File:** api/src/context.rs (L217-225)
```rust
    pub async fn submit_transaction(&self, txn: SignedTransaction) -> Result<SubmissionStatus> {
        let (req_sender, callback) = oneshot::channel();
        self.mp_sender
            .clone()
            .send(MempoolClientRequest::SubmitTransaction(txn, req_sender))
            .await?;

        callback.await?
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-504)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
    vm_validation_timer.stop_and_record();
```
