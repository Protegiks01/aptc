# Audit Report

## Title
Event Module Memory Leak Causes Transaction DoS via Memory Quota Exhaustion

## Summary
Starting from gas feature version 4, the event module is incorrectly configured with the `should_leak_memory_for_native` flag without implementing compensating memory tracking in the native functions. This causes the transaction memory quota to permanently decrease with each event emission, enabling denial-of-service attacks where transactions with multiple events fail with `MEMORY_LIMIT_EXCEEDED` even when actual memory usage is within limits.

## Finding Description

The memory tracking system in Aptos VM uses an accounting mechanism to enforce a per-transaction memory quota (default: 10,000,000 abstract value units). For native functions, memory is normally released before execution and re-tracked for return values. [1](#0-0) 

The `charge_call_generic()` function sets `should_leak_memory_for_native = true` for both the table module and event module (when feature_version >= 4). This flag prevents the normal memory release in `charge_native_function_before_execution()`: [2](#0-1) 

**Critical Difference**: Table natives compensate by explicitly calling `context.use_heap_memory()` to re-track memory: [3](#0-2) 

However, event natives do NOT implement this compensation. They only charge gas but never call `use_heap_memory()`: [4](#0-3) 

This creates an accounting bug where:
1. Event function arguments consume memory quota
2. Memory is never released (due to leak flag)
3. Native function doesn't re-track it (unlike table natives)
4. Memory quota permanently decreases with each event emission

The changelog confirms this was added in version 4: [5](#0-4) 

**Attack Vector**: An attacker creates a transaction that repeatedly emits events with large payloads. Each `event::emit()` call consumes memory quota for the event data without releasing it. After emitting sufficient events, the transaction hits `MEMORY_LIMIT_EXCEEDED` and fails, even though actual memory usage is fine.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria.

This vulnerability causes:
- **Transaction-level DoS**: Legitimate transactions with multiple events can unexpectedly fail with `MEMORY_LIMIT_EXCEEDED`
- **Resource exhaustion**: Memory quota is incorrectly depleted, breaking resource limit invariants
- **Unpredictable failures**: Applications emitting events may experience random failures depending on event payload sizes

This breaks **Invariant #9** ("Resource Limits: All operations must respect gas, storage, and computational limits") because memory quota accounting is incorrect, and **Invariant #3** ("Move VM Safety: Bytecode execution must respect gas limits and memory constraints") because memory constraints are enforced incorrectly.

The impact is limited to transaction execution failures (no consensus impact, no fund loss), qualifying as Medium severity: "State inconsistencies requiring intervention" - transactions that should succeed fail due to incorrect memory accounting.

## Likelihood Explanation

**Likelihood: High**

This will occur in any transaction that:
1. Runs on a network with gas feature version >= 4 (current production networks)
2. Emits multiple events with non-trivial payload sizes

The attack requires no special privileges - any transaction sender can emit events through smart contracts. The memory quota of 10,000,000 units can be exhausted by emitting 200-1000 events with moderate payloads (10-50KB each), which is feasible in complex applications like NFT minting, DeFi operations, or gaming protocols that emit extensive event logs.

## Recommendation

**Fix**: Event natives should track memory usage like table natives do. Add explicit memory tracking calls in event native functions:

```rust
// In native_write_to_event_store and native_write_module_event_to_store
// After serialization, track the memory for the serialized event data:
if context.feature_version() >= 4 {
    let blob_size = blob.len() as u64;
    context.use_heap_memory(blob_size)?;
}
```

Alternatively, remove the event module from the `should_leak_memory_for_native` flag if event memory should follow normal tracking: [6](#0-5) 

Change to:
```rust
self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS
    && module_id.name().as_str() == "table");
// Remove event module from leak flag unless compensating memory tracking is added
```

## Proof of Concept

```move
module 0xCAFE::memory_exhaust_poc {
    use std::vector;
    use aptos_framework::event;

    #[event]
    struct LargeEvent has drop, store {
        data: vector<u8>
    }

    public entry fun exhaust_memory_quota() {
        let i = 0;
        // Create large event payloads (10KB each)
        let large_data = vector::empty<u8>();
        while (vector::length(&large_data) < 10000) {
            vector::push_back(&mut large_data, 0xFF);
        };
        
        // Emit multiple events - each leaks memory quota without release
        // After ~200-500 iterations, transaction will fail with MEMORY_LIMIT_EXCEEDED
        while (i < 500) {
            event::emit(LargeEvent { data: large_data });
            i = i + 1;
        };
        // Transaction fails before completion due to memory quota exhaustion
    }
}
```

This PoC demonstrates how repeated event emissions with large payloads exhaust the memory quota, causing `MEMORY_LIMIT_EXCEEDED` errors despite actual memory being properly managed by the VM.

**Notes**

The vulnerability exists because the event module was given the same "leak" treatment as the table module in version 4, but unlike table natives which compensate by explicitly tracking memory usage, event natives lack this compensation mechanism. This causes an accounting mismatch where memory quota decreases without recovery, breaking the resource limit invariants that protect transaction execution.

### Citations

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L302-319)
```rust
    fn charge_call_generic(
        &mut self,
        module_id: &ModuleId,
        func_name: &str,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
        num_locals: NumArgs,
    ) -> PartialVMResult<()> {
        // Save the info for charge_native_function_before_execution.
        self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS
            && module_id.name().as_str() == "table")
            || (self.feature_version() >= 4
                && *module_id.address() == CORE_CODE_ADDRESS
                && module_id.name().as_str() == "event");

        self.base
            .charge_call_generic(module_id, func_name, ty_args, args, num_locals)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L322-344)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // TODO(Gas): https://github.com/aptos-labs/aptos-core/issues/5485
        if !self.should_leak_memory_for_native {
            self.release_heap_memory(args.clone().try_fold(
                AbstractValueSize::zero(),
                |acc, val| {
                    let heap_size = self
                        .vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?;
                    Ok::<_, PartialVMError>(acc + heap_size)
                },
            )?);
        }

        self.base
            .charge_native_function_before_execution(ty_args, args)
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L438-441)
```rust
    context.charge(key_cost)?;
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/framework/src/natives/event.rs (L246-323)
```rust
#[inline]
fn native_write_module_event_to_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 1);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();

    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;

    let type_tag = context.type_to_type_tag(ty)?;

    // Additional runtime check for module call.
    let stack_frames = context.stack_frames(1);
    let id = stack_frames
        .stack_trace()
        .first()
        .map(|(caller, _, _)| caller)
        .ok_or_else(|| {
            let err = PartialVMError::new_invariant_violation(
                "Caller frame for 0x1::emit::event is not found",
            );
            SafeNativeError::InvariantViolation(err)
        })?
        .as_ref()
        .ok_or_else(|| {
            // If module is not known, this call must come from the script, which is not allowed.
            let err = PartialVMError::new_invariant_violation("Scripts cannot emit events");
            SafeNativeError::InvariantViolation(err)
        })?;

    if let TypeTag::Struct(ref struct_tag) = type_tag {
        if id != &struct_tag.module_id() {
            return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::INTERNAL_TYPE_ERROR,
            )));
        }
    } else {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::INTERNAL_TYPE_ERROR,
        )));
    }

    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new_invariant_violation(
                "Event serialization failure",
            ))
        })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event = ContractEvent::new_v2(type_tag, blob).map_err(|_| SafeNativeError::Abort {
        abort_code: ECANNOT_CREATE_EVENT,
    })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));

    Ok(smallvec![])
}
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L62-63)
```rust
/// - V4
///   - Consider memory leaked for event natives
```
