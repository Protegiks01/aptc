# Audit Report

## Title
TOCTOU Vulnerability in Consensus Network Message Serialization Allows Protocol Mismatch Attacks

## Summary
A Time-of-Check to Time-of-Use (TOCTOU) race condition exists in the consensus network layer where messages are serialized once based on a peer's protocol preferences, but sent later after re-querying the protocol. If a peer reconnects with different protocol support between these operations, serialized bytes encoded with one protocol (e.g., CompressedBcs) are sent with a different protocol identifier (e.g., plain Bcs), causing deserialization failures and consensus message delivery disruptions.

## Finding Description
The vulnerability occurs in the reliable broadcast mechanism used by consensus for efficient message distribution to multiple validators. The flow involves two separate protocol queries with a time gap between them, creating a race condition window.

**Serialization Phase (Time of Check):**

The reliable broadcast system calls `to_bytes_by_protocol()` to pre-serialize messages for multiple peers in a blocking task: [1](#0-0) 

This delegates to the consensus network client's implementation: [2](#0-1) 

Which calls the core NetworkClient implementation that groups peers by their preferred protocol: [3](#0-2) 

The protocol selection happens via `group_peers_by_protocol()` which queries each peer's current protocol preference: [4](#0-3) 

This uses `get_preferred_protocol_for_peer()` to determine the protocol at serialization time: [5](#0-4) 

**Peer Metadata Update (Race Condition Window):**

Between serialization and sending, peer metadata can be updated when a peer reconnects. The `insert_connection_metadata()` method updates the peer's supported protocols: [6](#0-5) 

**Sending Phase (Time of Use):**

When actually sending the pre-serialized bytes, the reliable broadcast calls `send_rb_rpc_raw()`: [7](#0-6) 

This eventually reaches `NetworkClient::send_to_peer_rpc_raw()` which **re-queries the protocol preference**: [8](#0-7) 

**Protocol Encoding Incompatibility:**

The different protocols use incompatible encodings. CompressedBcs first compresses then BCS encodes: [9](#0-8) 

While plain Bcs directly encodes without compression: [10](#0-9) 

**Deserialization Failure:**

The receiving peer deserializes based on the protocol_id in the request: [11](#0-10) 

If CompressedBcs bytes are sent with a Bcs protocol identifier, deserialization attempts to BCS decode compressed data, resulting in failure.

**Attack Scenario:**
1. Validator serializes consensus message for Peer A using CompressedBcs (peer supports it at serialization time)
2. Peer A disconnects and reconnects advertising different protocols (e.g., only Bcs and Json)
3. Peer metadata updated with new protocol preferences
4. When sending, system re-queries protocol and gets Bcs instead of CompressedBcs
5. CompressedBcs-encoded bytes sent with Bcs protocol identifier
6. Receiving peer attempts Bcs deserialization on compressed data â†’ failure
7. Consensus message lost, requiring retry

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty criteria:

**Primary Impact: Validator Node Slowdowns**

The bug causes consensus message deserialization failures, forcing message retries that increase latency and resource consumption. This directly qualifies as "Validator Node Slowdowns" which is explicitly listed as High Severity in the Aptos bug bounty program (up to $50,000).

**Secondary Impacts:**
- **Consensus Message Delivery Failures**: Critical consensus messages (votes, proposals, commit decisions) fail to deserialize, disrupting AptosBFT protocol execution
- **Liveness Impact**: If multiple validators are affected simultaneously during critical consensus phases, it could delay round progression and block finalization
- **Reliable Broadcast Disruption**: The reliable broadcast mechanism used for commit messages could experience failures, delaying ledger finalization across the network

The vulnerability affects consensus reliability without causing permanent damage, aligning with High Severity classification.

## Likelihood Explanation
**Likelihood: Medium to High**

**Natural Occurrence:**
- Validators commonly support multiple protocol versions (Compressed, Bcs, Json) for backward compatibility
- Network instability causes frequent peer reconnections
- Version upgrades or configuration changes legitimately trigger protocol preference changes
- The time window is substantial due to async operations and parallel peer processing in reliable broadcast

**Malicious Exploitation:**
A Byzantine validator (< 1/3 stake) can intentionally exploit this by:
- Monitoring for consensus reliable broadcasts
- Strategically disconnecting and reconnecting with different protocol advertisements
- Timing reconnections during the serialization-to-send window
- Targeting critical consensus phases (voting, commit decisions) for maximum impact

The exploit requires no special permissions and can be triggered through normal network operations, making it practically exploitable in production environments.

## Recommendation
Implement atomic protocol selection by binding the protocol choice to the serialized bytes. Two approaches:

**Option 1: Store protocol with serialized bytes**
```rust
// In to_bytes_by_protocol, return protocol info with bytes
pub struct SerializedMessage {
    bytes: Bytes,
    protocol: ProtocolId,
}

// In send_rb_rpc_raw, use stored protocol instead of re-querying
```

**Option 2: Lock peer metadata during serialization and sending**
```rust
// Acquire read lock on peer metadata for the entire operation
let peer_metadata_snapshot = peers_and_metadata.read();
// Serialize with snapshot
// Send with same snapshot
// Release lock
```

**Option 3: Include protocol identifier in serialized data**
Embed the protocol ID in the message payload so receiving peer can validate the encoding matches expectations.

The recommended fix is Option 1 as it's least invasive and maintains the performance benefits of pre-serialization while eliminating the TOCTOU race condition.

## Proof of Concept
```rust
// Conceptual PoC demonstrating the race condition
#[tokio::test]
async fn test_toctou_protocol_mismatch() {
    // 1. Setup: Peer supports [CompressedBcs, Bcs]
    let peer_metadata = create_peer_with_protocols(vec![
        ProtocolId::ConsensusRpcCompressed,
        ProtocolId::ConsensusRpcBcs,
    ]);
    
    // 2. Serialize message using CompressedBcs
    let serialized = network_client
        .to_bytes_by_protocol(vec![peer_id], consensus_msg)
        .await
        .unwrap();
    
    // 3. RACE CONDITION: Peer reconnects with different protocols
    update_peer_metadata(peer_id, vec![
        ProtocolId::ConsensusRpcBcs,  // Compressed removed!
        ProtocolId::ConsensusRpcJson,
    ]);
    
    // 4. Send pre-serialized bytes - protocol re-queried, gets Bcs
    let result = network_client
        .send_to_peer_rpc_raw(serialized[&peer_id], timeout, peer_id)
        .await;
    
    // 5. Assertion: Send succeeds but peer fails to deserialize
    // because CompressedBcs bytes sent with Bcs protocol ID
    assert!(result.is_err()); // Deserialization failure
}
```

## Notes
This vulnerability is particularly concerning because:
1. It can occur naturally during network operations without malicious intent
2. The time window is substantial due to async operations in reliable broadcast
3. It affects consensus-critical messages including commit decisions
4. The impact scales with the number of affected validators
5. Debugging is difficult as failures appear as normal network errors

The vulnerability does NOT constitute a network DoS attack (which is out of scope) but rather a protocol implementation bug that causes message delivery failures through encoding mismatches.

### Citations

**File:** crates/reliable-broadcast/src/lib.rs (L130-135)
```rust
            let protocols = Arc::new(
                tokio::task::spawn_blocking(move || {
                    sender.to_bytes_by_protocol(peers, message_clone)
                })
                .await??,
            );
```

**File:** crates/reliable-broadcast/src/lib.rs (L137-156)
```rust
            let send_message = |receiver, sleep_duration: Option<Duration>| {
                let network_sender = network_sender.clone();
                let time_service = time_service.clone();
                let message = message.clone();
                let protocols = protocols.clone();
                async move {
                    if let Some(duration) = sleep_duration {
                        time_service.sleep(duration).await;
                    }
                    let send_fut = if receiver == self_author {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    } else if let Some(raw_message) = protocols.get(&receiver).cloned() {
                        network_sender.send_rb_rpc_raw(receiver, raw_message, rpc_timeout_duration)
                    } else {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    };
                    (receiver, send_fut.await)
                }
                .boxed()
            };
```

**File:** consensus/src/network.rs (L709-717)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<Author>,
        message: Req,
    ) -> anyhow::Result<HashMap<Author, Bytes>> {
        let consensus_msg = message.into_network_message();
        self.consensus_network_client
            .to_bytes_by_protocol(peers, consensus_msg)
    }
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/application/interface.rs (L160-191)
```rust
    fn group_peers_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
    ) -> HashMap<ProtocolId, Vec<PeerNetworkId>> {
        // Sort peers by protocol
        let mut peers_per_protocol = HashMap::new();
        let mut peers_without_a_protocol = vec![];
        for peer in peers {
            match self
                .get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences)
            {
                Ok(protocol) => peers_per_protocol
                    .entry(protocol)
                    .or_insert_with(Vec::new)
                    .push(peer),
                Err(_) => peers_without_a_protocol.push(peer),
            }
        }

        // We only periodically log any unavailable peers (to prevent log spamming)
        if !peers_without_a_protocol.is_empty() {
            sample!(
                SampleRate::Duration(Duration::from_secs(10)),
                warn!(
                    "[sampled] Unavailable peers (without a common network protocol): {:?}",
                    peers_without_a_protocol
                )
            );
        }

        peers_per_protocol
    }
```

**File:** network/framework/src/application/interface.rs (L274-286)
```rust
    async fn send_to_peer_rpc_raw(
        &self,
        message: Bytes,
        rpc_timeout: Duration,
        peer: PeerNetworkId,
    ) -> Result<Message, Error> {
        let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
        let rpc_protocol_id =
            self.get_preferred_protocol_for_peer(&peer, &self.rpc_protocols_and_preferences)?;
        Ok(network_sender
            .send_rpc_raw(peer.peer_id(), rpc_protocol_id, message, rpc_timeout)
            .await?)
    }
```

**File:** network/framework/src/application/interface.rs (L288-304)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
        message: Message,
    ) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);
        // Convert to bytes per protocol
        let mut bytes_per_peer = HashMap::new();
        for (protocol_id, peers) in peers_per_protocol {
            let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
            for peer in peers {
                bytes_per_peer.insert(peer, bytes.clone());
            }
        }

        Ok(bytes_per_peer)
    }
```

**File:** network/framework/src/application/storage.rs (L189-214)
```rust
        connection_metadata: ConnectionMetadata,
    ) -> Result<(), Error> {
        // Grab the write lock for the peer metadata
        let mut peers_and_metadata = self.peers_and_metadata.write();

        // Fetch the peer metadata for the given network
        let peer_metadata_for_network =
            get_peer_metadata_for_network(&peer_network_id, &mut peers_and_metadata)?;

        // Update the metadata for the peer or insert a new entry
        peer_metadata_for_network
            .entry(peer_network_id.peer_id())
            .and_modify(|peer_metadata| {
                peer_metadata.connection_metadata = connection_metadata.clone()
            })
            .or_insert_with(|| PeerMetadata::new(connection_metadata.clone()));

        // Update the cached peers and metadata
        self.set_cached_peers_and_metadata(peers_and_metadata.clone());

        let event =
            ConnectionNotification::NewPeer(connection_metadata, peer_network_id.network_id());
        self.broadcast(event);

        Ok(())
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L194-222)
```rust
    /// Serializes the given message into bytes (based on the protocol ID
    /// and encoding to use).
    pub fn to_bytes<T: Serialize>(&self, value: &T) -> anyhow::Result<Vec<u8>> {
        // Start the serialization timer
        let serialization_timer = start_serialization_timer(*self, SERIALIZATION_LABEL);

        // Serialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_encode(value, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let bcs_bytes = self.bcs_encode(value, limit)?;
                aptos_compression::compress(
                    bcs_bytes,
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow!("{:?}", e))
            },
            Encoding::Json => serde_json::to_vec(value).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if serialization was successful
        if result.is_ok() {
            serialization_timer.observe_duration();
        }

        result
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L232-243)
```rust
            Encoding::Bcs(limit) => self.bcs_decode(bytes, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let raw_bytes = aptos_compression::decompress(
                    &bytes.to_vec(),
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow! {"{:?}", e})?;
                self.bcs_decode(&raw_bytes, limit)
            },
            Encoding::Json => serde_json::from_slice(bytes).map_err(|e| anyhow!("{:?}", e)),
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L105-114)
```rust
pub trait IncomingRequest {
    fn protocol_id(&self) -> crate::ProtocolId;
    fn data(&self) -> &Vec<u8>;

    /// Converts the `SerializedMessage` into its deserialized version of `TMessage` based on the
    /// `ProtocolId`.  See: [`crate::ProtocolId::from_bytes`]
    fn to_message<TMessage: DeserializeOwned>(&self) -> anyhow::Result<TMessage> {
        self.protocol_id().from_bytes(self.data())
    }
}
```
