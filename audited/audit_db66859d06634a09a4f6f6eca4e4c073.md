# Audit Report

## Title
Source Path Traversal in Coverage Tool Allows Arbitrary File Disclosure via Symlinks

## Summary
The `aptos move coverage source` command fails to validate that source file paths remain within the package directory before reading and displaying them. Attackers can exploit symlink following during compilation to cause the coverage tool to read and display arbitrary files accessible to the user, including sensitive source code, configuration files, and secrets.

## Finding Description

The vulnerability exists in the coverage source display functionality. When a Move package is compiled, the source file discovery uses `walkdir` with `.follow_links(true)`, which allows symlinks to be included as source files. [1](#0-0) 

These symlinked paths are stored in the compiled package without validation and later used directly to read files when generating coverage reports. [2](#0-1) 

The `compute_source_coverage()` function reads the file path without any validation: [3](#0-2) 

**Attack Flow:**

1. **Setup**: Attacker creates a malicious Move package containing a symlink in the `sources/` directory pointing to a sensitive file (e.g., `ln -s ~/.ssh/id_rsa sensitive.move` or `ln -s ../../../other-project/secrets.rs leak.move`)

2. **Compilation**: When the package is compiled, `find_filenames()` discovers the symlink through directory traversal with symlink following enabled, and the symlink path is included in the compilation unit's source_path

3. **Exploitation**: When a victim runs `aptos move coverage source --module <module>`, the coverage tool:
   - Extracts the source_path from the compiled unit without validation [2](#0-1) 
   - Passes it directly to `compute_source_coverage()` [4](#0-3) 
   - Reads and displays the file contents with coverage annotations to stdout [5](#0-4) 

The vulnerability breaks the security assumption that CLI tools should only access files within their intended scope.

## Impact Explanation

This is a **Medium Severity** information disclosure vulnerability. An attacker who can convince a victim to compile and run coverage on a malicious Move package can read arbitrary files accessible to the victim's user account, including:

- Source code from other projects
- Configuration files containing API keys or credentials
- SSH private keys
- Environment-specific secrets
- Any readable file on the system

While this does not directly affect blockchain consensus or validator operations, it represents a significant security risk for developers working with Move packages from untrusted sources.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. An attacker to create a malicious Move package with symlinks
2. A victim to download/clone the package
3. The victim to compile the package (or it may compile successfully if the symlink points to valid Move code)
4. The victim to run the coverage command

This is realistic in scenarios where:
- Developers review third-party Move packages
- Build systems automatically compile and analyze packages
- Educational materials or examples are shared containing malicious symlinks

The attack complexity is low - creating symlinks requires only basic filesystem knowledge.

## Recommendation

Implement path validation to ensure source files remain within the package directory:

```rust
// In crates/aptos/src/move_tool/coverage.rs, before line 152:
async fn execute(self) -> CliTypedResult<()> {
    let (coverage_map, package) = compile_coverage(self.common, self.move_options)?;
    let unit = package.get_module_by_name_from_root(&self.module_name)?;
    let source_path = &unit.source_path;
    
    // Validate that source_path is within the package directory
    let package_path = self.move_options.get_package_path()?;
    let canonical_package = package_path.canonicalize()
        .map_err(|e| CliError::UnexpectedError(format!("Invalid package path: {}", e)))?;
    let canonical_source = source_path.canonicalize()
        .map_err(|e| CliError::UnexpectedError(format!("Invalid source path: {}", e)))?;
    
    if !canonical_source.starts_with(&canonical_package) {
        return Err(CliError::UnexpectedError(
            format!("Source file {} is outside package directory", source_path.display())
        ));
    }
    
    // Continue with existing logic...
}
```

Additionally, consider disabling symlink following in source file discovery: [1](#0-0) 

Change `.follow_links(true)` to `.follow_links(false)` to prevent symlinks from being included in source discovery.

## Proof of Concept

```bash
# Create a malicious Move package
mkdir -p malicious_package/sources
cd malicious_package

# Create Move.toml
cat > Move.toml << 'EOF'
[package]
name = "MaliciousPackage"
version = "0.0.1"

[addresses]
malicious = "0x42"
EOF

# Create a legitimate Move module
cat > sources/legit.move << 'EOF'
module malicious::legit {
    public fun test() {}
}
EOF

# Create a symlink to a sensitive file
ln -s /etc/passwd sources/leaked.move

# Attempt to compile (may fail if /etc/passwd is not valid Move code)
# But the path will still be stored in the package

# Create a valid symlink to demonstrate the issue
echo 'module malicious::leak { public fun secret() {} }' > /tmp/secret.move
ln -sf /tmp/secret.move sources/leak.move

# Compile with coverage
aptos move test --coverage

# Run coverage to leak the file contents
aptos move coverage source --module leak

# The contents of /tmp/secret.move will be displayed with coverage annotations
# In a real attack, this could point to ~/.ssh/id_rsa or other sensitive files
```

## Notes

This vulnerability affects the Aptos CLI tooling used by developers, not the blockchain protocol itself. However, it poses a real security risk for developers who might compile untrusted Move packages, as it could expose sensitive files, credentials, or proprietary source code from their development environment.

The issue stems from the combination of:
1. Symlink following enabled in file discovery
2. Lack of path validation before file access
3. Direct display of file contents to stdout

All three layers should be addressed for defense in depth.

### Citations

**File:** third_party/move/move-command-line-common/src/files.rs (L80-81)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
```

**File:** crates/aptos/src/move_tool/coverage.rs (L137-137)
```rust
        let source_path = &unit.source_path;
```

**File:** crates/aptos/src/move_tool/coverage.rs (L152-152)
```rust
        let source_coverage = source_coverage.compute_source_coverage(source_path);
```

**File:** crates/aptos/src/move_tool/coverage.rs (L153-154)
```rust
        let output_result =
            source_coverage.output_source_coverage(&mut std::io::stdout(), self.color, self.tag);
```

**File:** third_party/move/tools/move-coverage/src/source_coverage.rs (L401-401)
```rust
        let file_contents = fs::read_to_string(file_path).unwrap();
```
