# Audit Report

## Title
State Corruption in Subscription Stream Management Due to Check-After-Modify Race Condition

## Summary
The `add_subscription_request()` function in the storage service subscription handler contains a check-after-modify bug that allows duplicate subscription requests to corrupt stream state. When concurrent requests with the same subscription index are processed, the new request replaces the legitimate one in the pending queue while an error is sent to the original requester, violating the "no duplicate indices" invariant and causing state sync failures.

## Finding Description

The vulnerability exists in the subscription request handling logic that processes transaction data subscription streams. The bug occurs in the `add_subscription_request()` method: [1](#0-0) 

The critical flaw is in the ordering of operations:

1. **Line 384-387**: The function inserts the new subscription request into `pending_subscription_requests` using `BTreeMap::insert()`, which **immediately replaces** any existing request at that index
2. **Line 390**: The stream's `last_stream_update_time` is refreshed
3. **Line 393-400**: Only after modifying state does the function check if a duplicate existed and return an error with the **old** request

This violates the expected atomic check-and-insert pattern. When a duplicate index is sent:
- The NEW duplicate request remains in the map and will be served
- The OLD legitimate request is removed from the map and receives an error response  
- The stream timestamp is incorrectly updated for a rejected request
- The subscription stream state is corrupted

The handler processes this error as follows: [2](#0-1) 

The error handling sends a failure response to the OLD request's channel, but the NEW duplicate request remains active in the pending queue and will be served when data becomes available.

**Attack Scenario:**

1. A fullnode or validator's state sync client sends a subscription request with index N to stream S
2. Due to network retransmission, client race condition, or implementation bug, a second request with the same index N and stream S is sent concurrently
3. Both requests reach the subscription handler
4. The second request replaces the first in the `pending_subscription_requests` map
5. The first request receives error: "Overwriting an existing subscription request for index N"
6. The second duplicate request remains in the map and gets served
7. The client receives an error for a legitimate request while a duplicate is accepted

**Realistic Trigger Conditions:**
- Network-layer retransmissions in the application protocol
- Race conditions in fullnode/validator state sync client code  
- Client implementation bugs causing duplicate sends
- Concurrent request processing from the same peer

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

**"Validator node slowdowns"** - If a validator node's state sync client has a bug or experiences network conditions that trigger this issue repeatedly, the validator will experience persistent state sync failures. Each failure requires the client to restart the subscription stream, causing:
- Delayed state synchronization
- Increased latency in catching up to the latest ledger state
- Potential consensus participation delays
- Degraded validator performance

**"State inconsistencies requiring intervention"** (Medium Severity alternative) - The bug corrupts the subscription stream state by:
- Violating the invariant that duplicate indices must be rejected
- Accepting duplicate requests after sending errors
- Incorrectly updating stream timestamps for rejected requests
- Creating mismatched state between server and client expectations

The impact is limited by the fact that subscriptions are keyed by `PeerNetworkId`, so only the affected peer's own subscription is corrupted. However, for validator nodes, even self-inflicted state sync failures can have network-wide implications if they cause validators to fall behind or miss consensus rounds.

## Likelihood Explanation

**Medium-High Likelihood:**

The vulnerability will be triggered when:
1. Network retransmissions occur at the application layer (common in distributed systems)
2. State sync client implementations have race conditions (possible with async code)
3. Client bugs cause duplicate subscription requests (possible during development/updates)
4. High network latency causes request reordering

The bug affects the v2 transaction data subscription API: [3](#0-2) 

Notably, **there are no existing tests** that verify the duplicate index rejection behavior, suggesting this code path has not been thoroughly validated. The test file contains no coverage for the scenario where the same index is sent twice to the same stream.

## Recommendation

**Fix the check-after-modify bug** by checking for duplicate indices BEFORE modifying state:

```rust
pub fn add_subscription_request(
    &mut self,
    storage_service_config: StorageServiceConfig,
    subscription_request: SubscriptionRequest,
) -> Result<(), (Error, SubscriptionRequest)> {
    // Verify that the subscription metadata is valid
    let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
    if subscription_stream_metadata != self.subscription_stream_metadata {
        return Err((
            Error::InvalidRequest(format!(
                "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                self.subscription_stream_metadata, subscription_stream_metadata
            )),
            subscription_request,
        ));
    }

    // Verify that the subscription request index is valid
    let subscription_request_index = subscription_request.subscription_stream_index();
    if subscription_request_index < self.next_index_to_serve {
        return Err((
            Error::InvalidRequest(format!(
                "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                self.next_index_to_serve, subscription_request_index
            )),
            subscription_request,
        ));
    }

    // Verify that the number of active subscriptions respects the maximum
    let max_num_active_subscriptions =
        storage_service_config.max_num_active_subscriptions as usize;
    if self.pending_subscription_requests.len() >= max_num_active_subscriptions {
        return Err((
            Error::InvalidRequest(format!(
                "The maximum number of active subscriptions has been reached! Max: {:?}, found: {:?}",
                max_num_active_subscriptions, self.pending_subscription_requests.len()
            )),
            subscription_request,
        ));
    }

    // **FIX: Check for duplicate index BEFORE inserting**
    if self.pending_subscription_requests.contains_key(&subscription_request_index) {
        return Err((
            Error::InvalidRequest(format!(
                "A subscription request already exists for index: {:?}",
                subscription_request_index
            )),
            subscription_request,
        ));
    }

    // Insert the subscription request into the pending requests
    // (This should never return Some() now due to the check above)
    self.pending_subscription_requests.insert(
        subscription_request_index,
        subscription_request,
    );

    // Refresh the last stream update time
    self.refresh_last_stream_update_time();

    Ok(())
}
```

**Additional Recommendations:**
1. Add comprehensive test coverage for duplicate index scenarios
2. Add metrics to track duplicate subscription request attempts
3. Consider idempotency tokens for subscription requests to handle legitimate retries

## Proof of Concept

```rust
#[tokio::test]
async fn test_subscription_duplicate_index_race_condition() {
    use crate::subscription::{SubscriptionRequest, SubscriptionStreamRequests};
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::{
        DataRequest, StorageServiceRequest, SubscriptionStreamMetadata,
    };
    use aptos_time_service::TimeService;
    use futures::channel::oneshot;

    // Create a time service and storage config
    let time_service = TimeService::mock();
    let storage_config = StorageServiceConfig::default();

    // Create subscription metadata
    let subscription_metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: 100,
        known_epoch_at_stream_start: 1,
        subscription_stream_id: 12345,
    };

    // Create the first subscription request with index 0
    let (response_sender_1, _) = oneshot::channel();
    let request_1 = StorageServiceRequest::new(
        DataRequest::subscribe_transaction_data_with_proof(
            subscription_metadata,
            0, // index 0
            false,
            1024,
        ),
        false,
    );
    let sub_request_1 = SubscriptionRequest::new(
        request_1,
        response_sender_1,
        time_service.clone(),
    );

    // Create the subscription stream with the first request
    let mut stream = SubscriptionStreamRequests::new(sub_request_1, time_service.clone());

    // Create a second subscription request with the SAME index 0 (duplicate)
    let (response_sender_2, _) = oneshot::channel();
    let request_2 = StorageServiceRequest::new(
        DataRequest::subscribe_transaction_data_with_proof(
            subscription_metadata,
            0, // DUPLICATE index 0
            false,
            1024,
        ),
        false,
    );
    let sub_request_2 = SubscriptionRequest::new(
        request_2,
        response_sender_2,
        time_service.clone(),
    );

    // Attempt to add the duplicate request
    let result = stream.add_subscription_request(storage_config, sub_request_2);

    // Verify that an error is returned
    assert!(result.is_err());
    let (error, returned_request) = result.unwrap_err();
    
    // **BUG DEMONSTRATION:**
    // The error message says "Overwriting an existing subscription request"
    assert!(error.to_string().contains("Overwriting"));
    
    // But the returned request is the OLD request (request_1), not the new one
    // This means:
    // 1. The NEW request (request_2) is now in the map
    // 2. The OLD request (request_1) was removed and returned as an error
    // 3. The stream state was modified before the duplicate check
    
    // Verify that the stream now contains the WRONG request
    // (This demonstrates the state corruption)
    let pending_requests = stream.get_pending_subscription_requests();
    assert_eq!(pending_requests.len(), 1);
    
    // The pending request should be request_1, but due to the bug, it's request_2
    // This violates the invariant that duplicates should be rejected
}
```

## Notes

**Scope Limitation:** This vulnerability affects only the peer that sends duplicate requests - it cannot be exploited cross-peer due to subscriptions being keyed by authenticated `PeerNetworkId`. However, it remains a valid security issue because:

1. Network retransmissions at the application layer are common and expected
2. Client implementation bugs can trigger this condition
3. The bug violates critical state management invariants
4. It can cause validator node performance degradation (High severity)
5. No test coverage exists for this scenario, indicating it was never properly validated

The bug represents a violation of defensive programming principles where state modifications should only occur after all validation checks pass.

### Citations

**File:** state-sync/storage-service/server/src/subscription.rs (L341-404)
```rust
    pub fn add_subscription_request(
        &mut self,
        storage_service_config: StorageServiceConfig,
        subscription_request: SubscriptionRequest,
    ) -> Result<(), (Error, SubscriptionRequest)> {
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
        }

        // Verify that the subscription request index is valid
        let subscription_request_index = subscription_request.subscription_stream_index();
        if subscription_request_index < self.next_index_to_serve {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                    self.next_index_to_serve, subscription_request_index
                )),
                subscription_request,
            ));
        }

        // Verify that the number of active subscriptions respects the maximum
        let max_num_active_subscriptions =
            storage_service_config.max_num_active_subscriptions as usize;
        if self.pending_subscription_requests.len() >= max_num_active_subscriptions {
            return Err((
                Error::InvalidRequest(format!(
                    "The maximum number of active subscriptions has been reached! Max: {:?}, found: {:?}",
                    max_num_active_subscriptions, self.pending_subscription_requests.len()
                )),
                subscription_request,
            ));
        }

        // Insert the subscription request into the pending requests
        let existing_request = self.pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        // Refresh the last stream update time
        self.refresh_last_stream_update_time();

        // If a pending request already existed, return the previous request to the caller
        if let Some(existing_request) = existing_request {
            return Err((
                Error::InvalidRequest(format!(
                    "Overwriting an existing subscription request for the given index: {:?}",
                    subscription_request_index
                )),
                existing_request,
            ));
        }

        Ok(())
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L323-335)
```rust
                    // Add the request to the existing stream
                    if let Err((error, subscription_request)) = occupied_entry
                        .get_mut()
                        .add_subscription_request(storage_service_config, subscription_request)
                    {
                        // Handle the subscription failure
                        self.handle_subscription_request_failure(
                            peer_network_id,
                            request,
                            error,
                            subscription_request,
                        );
                    }
```

**File:** state-sync/storage-service/types/src/requests.rs (L266-280)
```rust
    pub fn subscribe_transaction_data_with_proof(
        subscription_stream_metadata: SubscriptionStreamMetadata,
        subscription_stream_index: u64,
        include_events: bool,
        max_response_bytes: u64,
    ) -> Self {
        let transaction_data_request_type =
            TransactionDataRequestType::TransactionData(TransactionData { include_events });
        Self::SubscribeTransactionDataWithProof(SubscribeTransactionDataWithProofRequest {
            transaction_data_request_type,
            subscription_stream_metadata,
            subscription_stream_index,
            max_response_bytes,
        })
    }
```
