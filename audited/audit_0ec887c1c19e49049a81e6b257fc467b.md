# Audit Report

## Title
Abstract Authenticator Address Spoofing Enables Transaction Filter Bypass and Resource Exhaustion

## Summary
The transaction filter mechanism in Aptos mempool uses unvalidated data from Abstract authenticators to make filtering decisions. An attacker can craft transactions with arbitrary `function_info.module_address` values in Abstract authenticators to bypass address-based filters, causing invalid transactions to consume validator resources before proper authentication validation occurs in the VM.

## Finding Description

The vulnerability exists in the transaction filtering logic that evaluates Abstract authenticators before VM validation occurs. The attack flow is:

**1. Filter Evaluation (Mempool)**

In mempool, transactions are filtered using `TransactionFilter::allows_transaction()` which checks various matchers including `TransactionMatcher::AccountAddress`. [1](#0-0) 

When checking if a transaction matches an address, the filter calls `matches_transaction_authenticator_address()`, which for Abstract authenticators simply extracts the module_address: [2](#0-1) 

**Critical Issue**: At line 277, the filter directly uses `authenticator.function_info().module_address` without any validation that this address is legitimate or corresponds to a registered authentication function for the account.

**2. Filter Application Before VM Validation**

The filter is applied in mempool BEFORE any VM validation: [3](#0-2) [4](#0-3) 

Transactions that pass the filter (line 435-438) proceed to VM validation (line 395), while rejected transactions receive `MempoolStatusCode::RejectedByFilter` status.

**3. Delayed Validation**

The actual validation of Abstract authenticators only occurs later during VM execution in the prologue: [5](#0-4) 

Lines 286 and 291 verify that the `function_info` exists in registered authenticators, but this check happens AFTER the transaction has already bypassed mempool filters.

**Attack Scenario:**

1. Node operator configures filter: "ALLOW only transactions involving module address 0xTRUSTED"
2. Attacker crafts transaction:
   - Normal transaction payload (e.g., calling any entry function)
   - Abstract authenticator with `function_info.module_address = 0xTRUSTED`
   - Invalid authentication data (since attacker doesn't control 0xTRUSTED)
3. Mempool filter sees `module_address = 0xTRUSTED`, ALLOWS transaction
4. Transaction proceeds to VM validation
5. VM rejects transaction because `function_info` is not registered for attacker's account
6. Validator resources have been consumed processing an invalid transaction that should have been filtered

The attacker can craft the FunctionInfo arbitrarily since it's just a struct with public fields: [6](#0-5) 

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

**Validator Node Slowdowns**: Attackers can submit large volumes of transactions with fake Abstract authenticators that bypass mempool filters but fail VM validation. This forces validators to process invalid transactions through the entire mempool pipeline, consuming CPU, memory, and I/O resources before rejection.

**Protocol Violations**: The transaction filter mechanism is designed to protect validator resources by rejecting unwanted transactions early. This vulnerability undermines that security model by allowing attacker-controlled data to influence filtering decisions without validation.

**Resource Exhaustion Vector**: An attacker can flood a node with transactions that:
- Pass mempool filters (consuming filter processing time)
- Pass mempool sequence number checks (consuming state read operations)
- Reach VM validation (consuming VM initialization and prologue execution)
- Finally fail authentication (wasting all above resources)

The severity aligns with "Validator node slowdowns" and "Significant protocol violations" from the HIGH category.

## Likelihood Explanation

**High Likelihood**:

1. **Trivial to Exploit**: Creating an Abstract authenticator with arbitrary `function_info` requires no special privileges or cryptographic operations: [7](#0-6) 

2. **No Prerequisites**: Any transaction submitter can craft this attack without controlling any legitimate accounts with Abstract authentication configured.

3. **Widespread Filter Usage**: Transaction filters are a core mempool feature used by validators to manage transaction admission. Any node using address-based filters is vulnerable.

4. **Amplification Potential**: A single attacker can submit thousands of malicious transactions, each bypassing filters and consuming validator resources.

## Recommendation

**Immediate Fix**: Validate Abstract authenticators in the filter matching logic or defer Abstract authenticator address matching until after basic authentication validation.

**Option 1 - Skip Abstract Authenticator Addresses in Filters**:
In `matches_account_authenticator_address()`, return `false` for Abstract authenticators since the module_address is not validated and shouldn't influence filtering decisions:

```rust
AccountAuthenticator::Abstract { .. } => {
    // Abstract authenticators contain unvalidated function_info that should not
    // influence filtering decisions until proper authentication validation occurs
    false
},
```

**Option 2 - Add Early Validation** (More Complex):
Add a lightweight validation in mempool that checks if the `function_info` exists in registered authenticators before using it for filtering. However, this adds state access overhead to filtering.

**Option 3 - Remove Abstract Authenticator Address Matching**:
Document that `TransactionMatcher::AccountAddress` does not match Abstract authenticator addresses since they require full VM context for validation.

**Recommended Approach**: Option 1 is simplest and most secure - don't use unvalidated Abstract authenticator data for filtering decisions.

## Proof of Concept

```rust
use aptos_types::{
    account_address::AccountAddress,
    chain_id::ChainId,
    function_info::FunctionInfo,
    transaction::{
        authenticator::{AccountAuthenticator, TransactionAuthenticator},
        RawTransaction, Script, SignedTransaction, TransactionPayload,
    },
};
use aptos_transaction_filters::transaction_filter::{TransactionFilter, TransactionMatcher};

#[test]
fn test_abstract_authenticator_filter_bypass() {
    // Setup: Node has filter allowing only transactions involving 0xABCD
    let trusted_address = AccountAddress::from_hex_literal("0xABCD").unwrap();
    let filter = TransactionFilter::empty()
        .add_multiple_matchers_filter(
            true, // ALLOW
            vec![TransactionMatcher::AccountAddress(trusted_address)],
        )
        .add_all_filter(false); // DENY all others

    // Attacker creates transaction with fake sender
    let attacker_address = AccountAddress::from_hex_literal("0xBAD").unwrap();
    let raw_txn = RawTransaction::new(
        attacker_address,
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        100000,
        0,
        1000,
        ChainId::new(1),
    );

    // Attacker crafts Abstract authenticator with spoofed module_address = trusted_address
    let fake_function_info = FunctionInfo::new(
        trusted_address, // Spoofed! Attacker claims to use module at trusted address
        "fake_module".to_string(),
        "fake_auth".to_string(),
    );
    
    let fake_authenticator = AccountAuthenticator::abstraction(
        fake_function_info,
        vec![0u8; 32], // Fake signing_message_digest
        vec![0u8; 64], // Fake abstract_signature
    );

    let signed_txn = SignedTransaction::new_single_sender(raw_txn, fake_authenticator);

    // Vulnerability: Filter allows the transaction because it matches trusted_address
    assert!(
        filter.allows_transaction(&signed_txn),
        "Transaction with fake Abstract authenticator bypasses filter!"
    );

    // In reality, this transaction would later fail VM validation because
    // the function_info is not registered, but it has already consumed
    // validator resources by bypassing the mempool filter.
}
```

This PoC demonstrates that an attacker can craft a transaction with a spoofed Abstract authenticator that bypasses address-based transaction filters, allowing invalid transactions to consume validator resources before proper authentication validation occurs.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L259-280)
```rust
fn matches_account_authenticator_address(
    account_authenticator: &AccountAuthenticator,
    address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match account_authenticator {
        AccountAuthenticator::Ed25519 { .. }
        | AccountAuthenticator::MultiEd25519 { .. }
        | AccountAuthenticator::NoAccountAuthenticator => false,
        AccountAuthenticator::SingleKey { authenticator } => {
            matches_any_public_key_address(authenticator.public_key(), address)
        },
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|any_public_key| matches_any_public_key_address(any_public_key, address)),
        AccountAuthenticator::Abstract { authenticator } => {
            authenticator.function_info().module_address == *address
        },
    }
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L320-326)
```rust
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);

    // If there are no transactions left after filtering, return early
    if transactions.is_empty() {
        return statuses;
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** aptos-move/framework/aptos-framework/sources/account/account_abstraction.move (L274-292)
```text
    fun authenticate(
        account: signer,
        func_info: FunctionInfo,
        signing_data: AbstractionAuthData,
    ): signer acquires DispatchableAuthenticator, DerivableDispatchableAuthenticator {
        let master_signer_addr = signer::address_of(&account);

        if (signing_data.is_derivable()) {
            assert!(features::is_derivable_account_abstraction_enabled(), error::invalid_state(EDERIVABLE_ACCOUNT_ABSTRACTION_NOT_ENABLED));
            assert!(master_signer_addr == derive_account_address(func_info, signing_data.derivable_abstract_public_key()), error::invalid_state(EINCONSISTENT_SIGNER_ADDRESS));

            let func_infos = dispatchable_derivable_authenticator_internal();
            assert!(func_infos.contains(&func_info), error::not_found(EFUNCTION_INFO_EXISTENCE));
        } else {
            assert!(features::is_account_abstraction_enabled(), error::invalid_state(EACCOUNT_ABSTRACTION_NOT_ENABLED));

            let func_infos = dispatchable_authenticator_internal(master_signer_addr);
            assert!(func_infos.contains(&func_info), error::not_found(EFUNCTION_INFO_EXISTENCE));
        };
```

**File:** types/src/function_info.rs (L17-34)
```rust
/// Reflection of aptos_framework::function_info::FunctionInfo
#[derive(Serialize, Deserialize, Eq, PartialEq, Debug, Clone, Hash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct FunctionInfo {
    pub module_address: AccountAddress,
    pub module_name: String,
    pub function_name: String,
}

impl FunctionInfo {
    pub fn new(module_address: AccountAddress, module_name: String, function_name: String) -> Self {
        Self {
            module_address,
            module_name,
            function_name,
        }
    }
}
```

**File:** types/src/transaction/authenticator.rs (L724-739)
```rust
    /// Create a abstracted authenticator
    pub fn abstraction(
        function_info: FunctionInfo,
        signing_message_digest: Vec<u8>,
        abstract_signature: Vec<u8>,
    ) -> Self {
        Self::Abstract {
            authenticator: AbstractAuthenticator::new(
                function_info,
                AbstractAuthenticationData::V1 {
                    signing_message_digest,
                    abstract_signature,
                },
            ),
        }
    }
```
