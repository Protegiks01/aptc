# Audit Report

## Title
Move IR Compiler Generates Invalid Bytecode Due to Incorrect Local Variable Bounds Check

## Summary
The Move IR compiler's `define_local` function checks for exceeding the maximum number of local variables using the wrong constant (`TABLE_MAX_SIZE = 65535`), allowing functions with 256-65535 locals to compile. Since `LocalIndex` is a `u8` (max 255), the cast silently truncates indices, causing multiple variables to alias to the same bytecode local index. This generates semantically invalid bytecode without returning a compilation error.

## Finding Description [1](#0-0) 

The `define_local` function checks if `self.locals.len() >= TABLE_MAX_SIZE` (where `TABLE_MAX_SIZE = 65535`), but then casts the length to `u8` without verifying it fits within `u8::MAX` (255). [2](#0-1) [3](#0-2) 

The `LocalIndex` type is defined as `u8`, meaning only indices 0-255 are valid. However, the compiler's check allows 256-65534 locals, causing:

1. Variable at index 256 → casts to 0
2. Variable at index 257 → casts to 1
3. Multiple variables map to the same bytecode index [4](#0-3) 

The `FunctionFrame.locals` HashMap stores variable names mapping to `u8` indices. When truncation occurs, distinct variable names map to identical indices, causing variable aliasing in the generated bytecode.

**Attack Path:**
1. Attacker creates Move IR with a function containing 256+ local variables
2. Compiler's bounds check passes (256 < 65535)
3. Cast to `u8` silently truncates (256 as u8 = 0)
4. Multiple variables receive identical local indices
5. Invalid bytecode is generated with no compilation error

## Impact Explanation

While the bytecode verifier ultimately catches this via the `TOO_MANY_LOCALS` check, the compiler fails to properly validate during compilation: [5](#0-4) 

The Move IR compiler's `--no-verify` flag allows bypassing verification: [6](#0-5) [7](#0-6) 

If the compiler API is used without subsequent verification, or `--no-verify` is used, invalid bytecode with aliased locals could be serialized and potentially executed, causing:
- Type confusion (different-typed variables at same index)
- Data corruption (writes affect wrong variables)
- Consensus divergence (if different implementations handle truncation differently)

**Severity Assessment:** This is **Medium Severity**. While the verifier provides a safety net, the compiler violates the principle that compilation should either succeed with valid bytecode or fail with an error. The use of the wrong constant (`TABLE_MAX_SIZE` instead of `LocalIndex::MAX`) is a clear implementation bug.

## Likelihood Explanation

**Likelihood: Low to Medium**

The Move IR compiler is primarily a testing tool and not used in production Move compilation (which uses `move-compiler-v2`). However:
- Developers testing with IR compiler could inadvertently use `--no-verify`
- Direct API usage of the compiler library might skip verification
- The bug represents improper error propagation, which is the security question's focus

## Recommendation

Replace the incorrect bounds check constant:

```rust
fn define_local(&mut self, var: &Var_, type_: SignatureToken) -> Result<u8> {
    // Change from TABLE_MAX_SIZE to u8::MAX as usize
    if self.locals.len() >= (u8::MAX as usize) {
        bail!("Max number of locals reached ({})", u8::MAX);
    }
    
    let cur_loc_idx = self.locals.len() as u8;
    let loc = var.clone();
    let entry = self.locals.entry(loc);
    match entry {
        Occupied(_) => bail!("variable redefinition {}", var),
        Vacant(e) => {
            e.insert(cur_loc_idx);
            self.local_types.0.push(type_);
        },
    }
    Ok(cur_loc_idx)
}
```

This ensures the check matches the actual `LocalIndex` type constraint before performing the cast.

## Proof of Concept

Create a file `test_256_locals.mvir`:
```
module 0x1.TestModule {
    public test_function() {
        let x0: u64; let x1: u64; ... let x255: u64; let x256: u64;
    label b0:
        return;
    }
}
```

Compile with:
```bash
move-ir-compiler test_256_locals.mvir --module --no-verify
```

**Expected behavior:** Compilation should fail with "Max number of locals reached" error before generating bytecode.

**Actual behavior:** Compilation succeeds, generating invalid bytecode where variable `x256` aliases to index 0, silently truncating without error.

## Notes

This finding directly addresses the security question about Result propagation: the `define_local` function fails to return an error when the local count exceeds the valid range for the return type (`u8`), instead silently generating invalid indices through truncation. The use of `TABLE_MAX_SIZE` instead of `LocalIndex::MAX` represents improper bounds validation where an error should be propagated but isn't.

### Citations

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs (L123-123)
```rust
    locals: HashMap<Var_, u8>,
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs (L171-187)
```rust
    fn define_local(&mut self, var: &Var_, type_: SignatureToken) -> Result<u8> {
        if self.locals.len() >= TABLE_MAX_SIZE {
            bail!("Max number of locals reached");
        }

        let cur_loc_idx = self.locals.len() as u8;
        let loc = var.clone();
        let entry = self.locals.entry(loc);
        match entry {
            Occupied(_) => bail!("variable redefinition {}", var),
            Vacant(e) => {
                e.insert(cur_loc_idx);
                self.local_types.0.push(type_);
            },
        }
        Ok(cur_loc_idx)
    }
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs (L50-50)
```rust
pub const TABLE_MAX_SIZE: usize = u16::MAX as usize;
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L192-192)
```rust
pub type LocalIndex = u8;
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L478-486)
```rust
        let locals_count = locals.len().saturating_add(parameters.len());

        if locals_count > LocalIndex::MAX as usize {
            return Err(verification_error(
                StatusCode::TOO_MANY_LOCALS,
                IndexKind::FunctionDefinition,
                index as TableIndex,
            ));
        }
```

**File:** third_party/move/move-ir-compiler/src/main.rs (L34-36)
```rust
    /// Do not automatically run the bytecode verifier
    #[clap(long = "no-verify")]
    pub no_verify: bool,
```

**File:** third_party/move/move-ir-compiler/src/main.rs (L137-139)
```rust
        if !args.no_verify {
            do_verify_module(&compiled_module, &deps_owned);
        }
```
