# Audit Report

## Title
Missing Retry-After Header in Legacy /mint Endpoint Enables DoS Amplification

## Summary
The legacy `/mint` endpoint strips the `Retry-After` header from 429 rate-limit responses, preventing clients from knowing when to retry after hitting rate limits. This can cause naive clients to retry immediately, amplifying resource consumption and creating DoS conditions on the faucet service.

## Finding Description
The Aptos faucet implements rate limiting through `RedisRatelimitChecker` and `MemoryRatelimitChecker`, which track request counts and return `RejectionReason` with code `UsageLimitExhausted` when limits are exceeded. [1](#0-0) 

The modern `/fund` endpoint properly converts these rejections into HTTP 429 responses with `Retry-After` headers via `AptosTapErrorResponse`. [2](#0-1) [3](#0-2) 

However, the legacy `/mint` endpoint explicitly strips these headers, preserving only the status code. [4](#0-3) 

When a client using `/mint` hits the rate limit:
1. Rate limiter detects limit exceeded and calculates `seconds_until_next_day` for retry
2. `AptosTapError` correctly includes this retry-after value
3. `/mint` handler calls `status_and_retry_after()` but only uses `.0` (status code)
4. Client receives 429 status but no `Retry-After` header
5. Without backoff guidance, naive clients may retry immediately
6. Each retry still consumes resources: Redis lookups, semaphore permits, request processing

This breaks the **Resource Limits invariant** (Invariant #9): the missing header allows clients to bypass the intended rate limiting protection mechanism by continuing to consume server resources.

## Impact Explanation
This qualifies as **Medium severity** under the bug bounty program based on "State inconsistencies requiring intervention." While the faucet is not a core blockchain component, sustained retry storms from rate-limited clients could:

- Exhaust Redis connection pools
- Consume semaphore permits, blocking legitimate requests [5](#0-4) 
- Increase server load requiring manual intervention (blocking IPs, infrastructure-level rate limiting)
- Degrade service availability for legitimate users

The faucet is documented as the primary method for testnet funding, making its availability critical for development workflows. [6](#0-5) 

## Likelihood Explanation
**High likelihood**. The `/mint` endpoint is actively documented and used in production environments. Clients using this endpoint will inevitably hit rate limits during normal operation or testing. Without `Retry-After` headers, developers may implement aggressive retry logic (exponential backoff with short initial delays, or even immediate retries), unintentionally creating the amplification condition.

The code comment explicitly acknowledges this limitation, indicating awareness but not mitigation. [7](#0-6) 

## Recommendation
Include the `Retry-After` header in `/mint` responses. Modify the error handler to preserve both status code and retry-after value:

```rust
.map_err(|e| {
    let (status, retry_after) = e.status_and_retry_after();
    let mut error = poem::Error::from((status, anyhow::anyhow!(e.message)));
    if let Some(retry_secs) = retry_after {
        error = error.with_header("Retry-After", retry_secs.to_string());
    }
    error
})?;
```

This maintains backwards compatibility (plaintext response body) while adding proper backoff guidance.

## Proof of Concept
```rust
#[tokio::test]
async fn test_mint_endpoint_missing_retry_after() {
    // Setup: Start faucet with Redis rate limiter configured for 3 requests/day
    let config = include_str!("../configs/testing_redis.yaml");
    let (port, _handle) = start_server(config).await.unwrap();
    
    // Make requests until rate limited
    for _ in 0..3 {
        let resp = reqwest::Client::new()
            .post(format!("http://127.0.0.1:{}/mint?amount=10&address=0x1", port))
            .send()
            .await
            .unwrap();
        assert_eq!(resp.status(), 200);
    }
    
    // Fourth request should return 429
    let resp = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/mint?amount=10&address=0x1", port))
        .send()
        .await
        .unwrap();
    
    assert_eq!(resp.status(), 429);
    
    // BUG: Retry-After header is missing despite rate limiter setting it
    assert!(resp.headers().get("Retry-After").is_none());
    
    // For comparison, /fund endpoint properly includes the header
    let fund_resp = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&serde_json::json!({"address": "0x1"}))
        .send()
        .await
        .unwrap();
    
    assert_eq!(fund_resp.status(), 429);
    assert!(fund_resp.headers().get("Retry-After").is_some());
}
```

**Notes:**
While this vulnerability is real and exploitable, it's important to note that the code comments indicate this is intentional behavior for backwards compatibility with the old faucet API. However, intentional or not, the security impact remains: clients lack proper backoff guidance, creating a DoS amplification vector that violates the resource limits invariant. The recommended fix maintains backwards compatibility while adding the missing security control.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L207-217)
```rust
        if limit_value.unwrap_or(0) > self.args.max_requests_per_day as i64 {
            Some(
                RejectionReason::new(
                    format!(
                        "You have reached the maximum allowed number of requests per day: {}",
                        self.args.max_requests_per_day
                    ),
                    RejectionReasonCode::UsageLimitExhausted,
                )
                .retry_after(seconds_until_next_day),
            )
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L64-74)
```rust
    pub fn status_and_retry_after(&self) -> (StatusCode, Option<u64>) {
        let (mut status_code, mut retry_after) = (self.error_code.status(), None);
        for rejection_reason in &self.rejection_reasons {
            if rejection_reason.code == RejectionReasonCode::UsageLimitExhausted {
                status_code = StatusCode::TOO_MANY_REQUESTS;
                retry_after = rejection_reason.retry_after;
                break;
            }
        }
        (status_code, retry_after)
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L91-109)
```rust
#[derive(Debug, ApiResponse)]
pub enum AptosTapErrorResponse {
    Default(
        StatusCode,
        Json<AptosTapError>,
        #[oai(header = "Retry-After")] Option<u64>,
    ),
}

impl From<AptosTapError> for AptosTapErrorResponse {
    fn from(error: AptosTapError) -> Self {
        // We use this opportunity to bump metrics based on the specifics of
        // this response, since this function is only called right when we're
        // about to return this error to the client.
        bump_rejection_reason_counters(&error.rejection_reasons);
        let (status, retry_after) = error.status_and_retry_after();
        Self::Default(status, Json(error), retry_after)
    }
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L204-215)
```rust
        let permit = match &self.concurrent_requests_semaphore {
            Some(semaphore) => match semaphore.try_acquire() {
                Ok(permit) => Some(permit),
                Err(_) => {
                    return Err(AptosTapError::new(
                        "Server overloaded, please try again later".to_string(),
                        AptosTapErrorCode::ServerOverloaded,
                    ))
                },
            },
            None => None,
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L395-411)
```rust
    // We take the AptosTapError and convert it into an anyhow error with just the
    // message so this endpoint returns a plaintext response like the faucet does.
    // We still return the intended status code though, but not any headers that
    // the /mint endpoint would, e.g. Retry-After.
    let fund_request = FundRequest {
        amount,
        auth_key,
        address,
        pub_key,
    };
    let txns = fund_api_components
        .0
        .fund_inner(fund_request, source_ip, header_map, false, None)
        .await
        .map_err(|e| {
            poem::Error::from((e.status_and_retry_after().0, anyhow::anyhow!(e.message)))
        })?;
```

**File:** crates/aptos/src/node/local_testnet/faucet.rs (L29-34)
```rust
    /// Port to run the faucet on.
    ///
    /// When running, you'll be able to use the faucet at `http://127.0.0.1:<port>/mint` e.g.
    /// `http//127.0.0.1:8081/mint`
    #[clap(long, default_value_t = 8081)]
    pub faucet_port: u16,
```
