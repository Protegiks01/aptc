# Audit Report

## Title
Critical Supply Chain Vulnerability: Missing Cryptographic Verification of Framework Release Bundle

## Summary
The Aptos Core codebase lacks any cryptographic verification (signature or hash check) when deserializing the Move framework release bundle (head.mrb/framework.mrb) during build, distribution, and runtime. This allows an attacker who compromises the build pipeline, intercepts binaries, or tampers with genesis files to inject arbitrary malicious bytecode into the blockchain's core framework modules, resulting in total network compromise.

## Finding Description

The vulnerability exists across multiple points in the framework loading pipeline:

**Build-Time Generation (No Integrity Generation):** [1](#0-0) 

The build script generates the `head.mrb` file by calling `ReleaseTarget::Head.create_release()`, which simply serializes the ReleaseBundle to BCS format without generating any cryptographic hash or signature: [2](#0-1) 

**Runtime Deserialization (No Integrity Verification):** [3](#0-2) 

The embedded bytes are deserialized directly using BCS without any verification that the data matches an expected hash or signature. The `expect("bcs succeeds")` call only validates BCS format, not content authenticity.

**Genesis Framework Loading (No Verification):** [4](#0-3) 

For production mainnet genesis, the framework.mrb file is loaded from a git repository or local filesystem with no cryptographic verification whatsoever.

**Framework Deployment to Chain:** [5](#0-4) 

The unverified ReleaseBundle is then published to the blockchain state during genesis, where it becomes the authoritative framework code for all nodes.

**Attack Scenario:**

1. **Attacker Action**: Compromise CI/CD pipeline, intercept binary distribution, or tamper with git repository
2. **Malicious Injection**: Modify head.mrb or framework.mrb to include backdoored versions of critical modules:
   - `coin.move`: Redirect transfers to attacker address
   - `aptos_governance.move`: Automatically approve attacker proposals
   - `stake.move`: Manipulate validator set and rewards
   - `aptos_account.move`: Bypass authentication checks
3. **Distribution**: Compromised binary/file reaches node operators
4. **Deployment**: During genesis or node initialization, malicious framework is published to blockchain state
5. **Exploitation**: All transactions execute using compromised framework logic

**Broken Invariants:**

1. **Deterministic Execution**: Different nodes could have different framework code, causing state divergence
2. **Consensus Safety**: Malicious framework could introduce non-determinism breaking Byzantine fault tolerance
3. **Access Control**: Attacker-controlled framework bypasses system address protections
4. **Cryptographic Correctness**: No chain of trust from trusted source to deployed code

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple Critical impact categories from the Aptos bug bounty:

1. **Loss of Funds (theft or minting)**: Malicious `coin.move` module can redirect any transfer to attacker's address or mint unlimited tokens
2. **Consensus/Safety violations**: Non-deterministic or Byzantine behavior in framework causes nodes to produce different state roots, breaking consensus
3. **Non-recoverable network partition (requires hardfork)**: Once malicious framework is deployed at genesis, all nodes executing it are compromised; recovery requires hard fork with new genesis
4. **Permanent freezing of funds (requires hardfork)**: Malicious framework can lock all accounts by modifying transfer/withdrawal logic

The framework modules control every critical blockchain operation. Complete compromise of framework code equals complete compromise of the blockchain.

## Likelihood Explanation

**Likelihood: Medium-to-High**

While the attack requires:
- Build environment compromise, OR
- Binary interception capability, OR  
- Git repository access

These vectors are increasingly realistic:

1. **Supply Chain Attacks are Common**: SolarWinds, CodeCov, and similar incidents demonstrate feasibility
2. **Multiple Attack Surfaces**: Three independent paths (build, distribution, genesis) increase probability
3. **High-Value Target**: Blockchain infrastructure is valuable enough to justify sophisticated attacks
4. **No Defense-in-Depth**: Complete absence of verification means single point of compromise succeeds

The combination of catastrophic impact with realistic attack vectors makes this a critical vulnerability despite requiring some level of access.

## Recommendation

Implement a multi-layered cryptographic verification system:

**1. Build-Time Signature Generation:**
```rust
// In release_builder.rs::create_release()
let bundle_bytes = bcs::to_bytes(&bundle)?;
let hash = sha3_256(&bundle_bytes);
let signature = sign_with_aptos_release_key(&hash);

// Write bundle + signature + hash
std::fs::write(&output, bundle_bytes)?;
std::fs::write(&output.with_extension("sha3"), hash)?;
std::fs::write(&output.with_extension("sig"), signature)?;
```

**2. Compile-Time Hash Embedding:**
```rust
// In cached-packages/build.rs
const EXPECTED_HASH: &str = include_str!(concat!(env!("OUT_DIR"), "/head.mrb.sha3"));
```

**3. Runtime Verification:**
```rust
// In cached-packages/src/lib.rs
static HEAD_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    verify_hash(HEAD_RELEASE_BUNDLE_BYTES, EXPECTED_FRAMEWORK_HASH)
        .expect("Framework bundle integrity check failed");
    bcs::from_bytes::<ReleaseBundle>(HEAD_RELEASE_BUNDLE_BYTES)
        .expect("bcs succeeds")
});
```

**4. Genesis Verification:**
```rust
// In genesis/git.rs::get_framework()
pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
    let bytes = /* load bytes */;
    verify_framework_signature(&bytes, TRUSTED_PUBLIC_KEY)?;
    Ok(bcs::from_bytes::<ReleaseBundle>(&bytes)?)
}
```

**5. Establish Trust Chain:**
- Hardcode Aptos Foundation's public key in source code
- Sign all official framework releases
- Document key rotation procedure for emergencies
- Consider multi-signature scheme (3-of-5 core developers)

## Proof of Concept

**Step 1: Create Malicious Framework (Conceptual)**
```rust
// Attacker modifies coin.move before compilation:
// public entry fun transfer<CoinType>(
//     from: &signer,
//     to: address,
//     amount: u64,
// ) {
//     let attacker = @0xAAAAAAAAAA; // Attacker address
//     coin::transfer<CoinType>(from, attacker, amount); // Redirect to attacker
// }
```

**Step 2: Demonstrate No Verification**
```rust
// test_no_verification.rs
#[test]
fn test_framework_loaded_without_verification() {
    // This test demonstrates that ANY .mrb file can be loaded
    // with no cryptographic verification
    
    // Create a modified bundle with malicious code
    let malicious_bundle = create_fake_bundle_with_backdoor();
    let malicious_bytes = bcs::to_bytes(&malicious_bundle).unwrap();
    
    // Write to temporary location
    let temp_path = TempPath::new();
    temp_path.create_as_file().unwrap();
    std::fs::write(temp_path.path(), &malicious_bytes).unwrap();
    
    // Load bundle - NO VERIFICATION HAPPENS
    let loaded_bundle = ReleaseBundle::read(temp_path.path().to_path_buf()).unwrap();
    
    // Bundle loads successfully despite being malicious
    assert_eq!(loaded_bundle.packages.len(), malicious_bundle.packages.len());
    
    // This malicious bundle would be published to chain during genesis
}
```

**Step 3: Verify Genesis Publication**
```rust
#[test]
fn test_malicious_framework_reaches_chain() {
    let malicious_bundle = create_fake_bundle_with_backdoor();
    
    // Genesis uses this bundle WITHOUT verification
    let genesis_changeset = generate_test_genesis(&malicious_bundle, Some(1));
    
    // Malicious framework code is now in the genesis state
    // All nodes starting from this genesis have compromised framework
    assert!(genesis_changeset.0.write_set().len() > 0);
}
```

## Notes

1. **Scope Validation**: The security question explicitly asks about "tampering during build or distribution," confirming supply chain attacks are in scope for this audit.

2. **Real-World Precedent**: The Rust ecosystem has faced supply chain attacks (crates.io compromises), and blockchain projects are high-value targets making this threat realistic.

3. **Defense-in-Depth Failure**: Cryptographic verification is a fundamental security control for any distributed system. Its complete absence represents a critical gap in the security architecture.

4. **Affected Codepaths**: Both test/development (head_release_bundle) and production (mainnet genesis) paths are vulnerable, affecting all deployment scenarios.

5. **No Compensating Controls**: There are no alternative integrity checks, making this a single point of failure in the trust chain from source code to deployed framework.

### Citations

**File:** aptos-move/framework/cached-packages/build.rs (L91-96)
```rust
        let path =
            PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR defined")).join("head.mrb");

        ReleaseTarget::Head
            .create_release(true, Some(path))
            .context("Failed to create release")?;
```

**File:** aptos-move/framework/src/release_builder.rs (L99-103)
```rust
        let bundle = ReleaseBundle::new(released_packages, source_paths);
        let parent = output.parent().expect("Failed to get parent directory");
        std::fs::create_dir_all(parent).context("Failed to create dirs")?;
        std::fs::write(&output, bcs::to_bytes(&bundle)?).context("Failed to write output")?;
        Ok(())
```

**File:** aptos-move/framework/cached-packages/src/lib.rs (L12-24)
```rust
#[cfg(unix)]
const HEAD_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/head.mrb"));
#[cfg(windows)]
const HEAD_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "\\head.mrb"));

static HEAD_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    bcs::from_bytes::<ReleaseBundle>(HEAD_RELEASE_BUNDLE_BYTES).expect("bcs succeeds")
});

/// Returns the release bundle for the current code.
pub fn head_release_bundle() -> &'static ReleaseBundle {
    &HEAD_RELEASE_BUNDLE
}
```

**File:** crates/aptos/src/genesis/git.rs (L229-247)
```rust
    /// Retrieve framework release bundle.
    pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(FRAMEWORK_NAME);
                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }
                Ok(ReleaseBundle::read(path)?)
            },
            Client::Github(client) => {
                let bytes = base64::decode(client.get_file(FRAMEWORK_NAME)?)?;
                Ok(bcs::from_bytes::<ReleaseBundle>(&bytes)?)
            },
        }
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1155-1229)
```rust
fn publish_framework(
    genesis_vm: &GenesisMoveVm,
    genesis_runtime_environment: &RuntimeEnvironment,
    hash_value: HashValue,
    framework: &ReleaseBundle,
) -> (VMChangeSet, ModuleWriteSet) {
    // Reset state view to be empty, to make sure all module write ops are creations.
    let mut state_view = GenesisStateView::new();

    // First, publish modules.
    let mut writes = BTreeMap::new();
    for pack in &framework.packages {
        let modules = pack.sorted_code_and_modules();

        let addr = *modules.first().unwrap().1.self_id().address();
        let code = modules
            .into_iter()
            .map(|(c, _)| c.to_vec().into())
            .collect::<Vec<_>>();

        let package_writes = code_to_writes_for_publishing(
            genesis_runtime_environment,
            genesis_vm.genesis_features(),
            &state_view,
            addr,
            code,
        )
        .unwrap_or_else(|e| {
            panic!(
                "Failure publishing package `{}`: {:?}",
                pack.package_metadata().name,
                e
            )
        });

        // Add write ops so that we can later create a module write set. Also add them to the state
        // view so that modules in subsequent packages can link to them.
        writes.extend(package_writes.clone());
        state_view.add_module_write_ops(package_writes);
    }
    let module_write_set = ModuleWriteSet::new(writes);

    // At this point we processed all packages, and the state view contains all the code. We can
    // run package initialization.

    let module_storage = state_view.as_aptos_code_storage(genesis_runtime_environment);
    let resolver = state_view.as_move_resolver();
    let mut session = genesis_vm.new_genesis_session(&resolver, hash_value);

    let traversal_storage = TraversalStorage::new();
    let mut traversal_context = TraversalContext::new(&traversal_storage);

    for pack in &framework.packages {
        // Unfortunately, package does not contain address information, so we have to access its
        // modules to extract the destination address.
        let addr = *pack
            .sorted_code_and_modules()
            .first()
            .unwrap()
            .1
            .self_id()
            .address();
        initialize_package(
            &mut session,
            &module_storage,
            &mut traversal_context,
            addr,
            pack,
        );
    }

    let change_set =
        assert_ok!(session.finish(&genesis_vm.genesis_change_set_configs(), &module_storage,));
    (change_set, module_write_set)
}
```
