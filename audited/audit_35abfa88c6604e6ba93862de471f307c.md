# Audit Report

## Title
Mutex Poisoning in Cross-Shard Message Reception Enables Permanent Denial of Service on Executor Shards

## Summary
The `receive_cross_shard_msg()` function in `RemoteCrossShardClient` holds a Mutex lock while performing BCS deserialization with `.unwrap()`, creating a critical vulnerability where malformed network messages poison the Mutex and permanently disable cross-shard communication for affected rounds. This leads to cascading block execution failures across all executor shards.

## Finding Description

The vulnerability exists in the cross-shard message reception logic where a Mutex-protected channel receiver is locked, and then untrusted network data is deserialized while the lock is held. [1](#0-0) 

The attack flow proceeds as follows:

1. **Unauthenticated Message Injection**: The GRPC network service accepts messages from any peer without authentication or validation: [2](#0-1) 

2. **Mutex Acquisition**: When `receive_cross_shard_msg()` is called, it acquires the Mutex lock for the specified round's receiver channel.

3. **Panic While Holding Lock**: If an attacker sends malformed BCS data, the deserialization at line 64 fails and the `.unwrap()` panics while the MutexGuard is still in scope, poisoning the Mutex per Rust's panic semantics.

4. **Permanent Poisoning**: The `RemoteCrossShardClient` is instantiated once and reused across all block executions: [3](#0-2) 

5. **Cascading Failures**: The `CrossShardCommitReceiver` runs in a loop calling `receive_cross_shard_msg()`: [4](#0-3) 

6. **Thread Pool Scope Panic**: This receiver is spawned in a scoped thread pool, so when it panics, the entire scope panics, failing block execution: [5](#0-4) 

**Critical Issue**: Once a Mutex for a specific round is poisoned, ALL future attempts to receive messages for that round will immediately panic at line 62 when calling `.lock().unwrap()` on the poisoned Mutex. Since there are only `MAX_ALLOWED_PARTITIONING_ROUNDS = 8` rounds: [6](#0-5) 

An attacker can systematically poison all 8 rounds, permanently disabling the validator's ability to execute any sharded blocks.

## Impact Explanation

This vulnerability constitutes **Critical Severity** under the Aptos bug bounty program's "Total loss of liveness/network availability" category because:

1. **Permanent Denial of Service**: Poisoned Mutexes persist across all future block executions, requiring process restart (which would recreate the client, but the attacker can immediately re-poison it).

2. **Validator Incapacitation**: A validator with all rounds poisoned cannot execute blocks and cannot participate in consensus, effectively removing it from the network.

3. **Network-Wide Impact**: If an attacker targets multiple validators simultaneously (feasible since the GRPC endpoints are unauthenticated), the network can lose consensus quorum, causing complete network halt.

4. **No Recovery Without Code Change**: There is no operational recovery path - the poisoned state persists until the service is restarted, and re-poisoning is trivial.

5. **Breaks Availability Invariant**: The system should gracefully handle malformed inputs rather than entering irrecoverable failure states.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to occur because:

1. **No Authentication Required**: The GRPC network service accepts messages from any network peer without authentication, signature verification, or allowlisting.

2. **Trivial Exploitation**: An attacker only needs to:
   - Identify the target validator's executor shard addresses
   - Send malformed bytes (e.g., `vec![0xff]`) to the GRPC endpoint with message type `"cross_shard_0"` through `"cross_shard_7"`
   - No special privileges, stake, or insider access required

3. **Low Cost, High Impact**: A single malformed message permanently disables a round. Eight messages permanently disable a validator's execution capability.

4. **Detectable Attack Surface**: Executor shard endpoints are discoverable through network scanning or configuration observation.

## Recommendation

**Immediate Fix**: Replace `.unwrap()` with proper error handling that does NOT hold the Mutex lock during fallible operations:

```rust
fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
    // Acquire lock only to get the message
    let message = {
        let rx = self.message_rxs[current_round].lock().unwrap();
        rx.recv().expect("Cross-shard channel disconnected")
    }; // MutexGuard dropped here, before deserialization
    
    // Deserialize outside the lock scope with proper error handling
    bcs::from_bytes(&message.to_bytes())
        .expect("Failed to deserialize cross-shard message")
}
```

**Better Fix**: Implement comprehensive error handling with recovery:

```rust
fn receive_cross_shard_msg(&self, current_round: RoundId) -> Result<CrossShardMsg, CrossShardError> {
    let message = {
        let rx = self.message_rxs[current_round]
            .lock()
            .map_err(|_| CrossShardError::PoisonedLock(current_round))?;
        rx.recv()
            .map_err(|_| CrossShardError::ChannelDisconnected)?
    };
    
    bcs::from_bytes(&message.to_bytes())
        .map_err(|e| CrossShardError::DeserializationFailed(e))
}
```

**Defense in Depth**:
1. Add message authentication (HMAC or signature verification)
2. Add peer allowlisting for executor shard endpoints
3. Implement message validation before deserialization
4. Add metrics/alerts for deserialization failures
5. Consider using bounded retry logic or circuit breakers

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_mutex_poisoning_dos() {
    use aptos_secure_net::network_controller::NetworkController;
    use execution_service::remote_cross_shard_client::RemoteCrossShardClient;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    
    // Setup executor service
    let shard_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 8080);
    let mut controller = NetworkController::new("test".to_string(), shard_addr, 5000);
    
    let client = RemoteCrossShardClient::new(&mut controller, vec![]);
    controller.start();
    
    // Attacker: Send malformed BCS message to round 0
    let malicious_message = vec![0xff, 0xff, 0xff]; // Invalid BCS encoding
    send_grpc_message(shard_addr, "cross_shard_0", malicious_message);
    
    // First call: panics during deserialization, poisons Mutex
    let result = std::panic::catch_unwind(|| {
        client.receive_cross_shard_msg(0)
    });
    assert!(result.is_err(), "First call should panic on malformed BCS");
    
    // Second call: immediately panics on poisoned Mutex lock attempt
    let result = std::panic::catch_unwind(|| {
        client.receive_cross_shard_msg(0)
    });
    assert!(result.is_err(), "Subsequent calls panic on poisoned Mutex");
    
    // The Mutex for round 0 is now permanently poisoned
    // All future block executions requiring round 0 will fail
}

fn send_grpc_message(addr: SocketAddr, msg_type: &str, data: Vec<u8>) {
    // Use tonic GRPC client to send malformed message
    // Implementation details omitted for brevity
}
```

**Notes**

The vulnerability specifically affects the remote execution mode where executor shards communicate over the network. The local execution mode using `LocalCrossShardClient` with in-memory channels is not directly vulnerable to external message injection, though it could still experience Mutex poisoning from internal bugs.

The fundamental issue is the violation of the error handling principle: **never panic while holding a lock**. The `.unwrap()` calls at lines 62, 63, and 64 create multiple panic points while the MutexGuard is in scope, with line 64's BCS deserialization being externally triggerable by unauthenticated network peers.

### Citations

**File:** aptos-core-086/execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust

```

**File:** aptos-core-086/secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust

```

**File:** aptos-core-086/execution/executor-service/src/remote_executor_service.rs (L37-40)
```rust

```

**File:** aptos-core-086/aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust

```

**File:** aptos-core-086/aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L134-141)
```rust

```

**File:** aptos-core-086/types/src/block_executor/partitioner.rs (L20-21)
```rust

```
