# Audit Report

## Title
Unvalidated Sync Target LedgerInfo in Consensus Observer Enables State Sync Manipulation and Denial of Service

## Summary

The consensus observer accepts `CommitDecision` messages for future epochs without validating their cryptographic signatures, then passes these unverified ledger infos to state sync as sync targets. The state sync driver's `initialize_sync_target_request()` function accepts these targets without signature validation, only performing version number checks. This allows any malicious peer to cause denial of service by forcing nodes to sync to non-existent or invalid targets. [1](#0-0) 

## Finding Description

When the consensus observer processes a `CommitDecision` message, it only validates the commit proof for decisions matching the current epoch. For future epoch commits, signature verification is completely bypassed: [2](#0-1) 

The unverified commit decision is then forwarded to state sync at line 526 without any cryptographic validation: [3](#0-2) 

This bypasses the fundamental security requirement that all `LedgerInfoWithSignatures` must have valid BLS aggregate signatures from a quorum of validators (2f+1). The `CommitDecision::verify_commit_proof()` method exists specifically for this validation: [4](#0-3) 

When state sync receives this unverified target via `sync_to_target()`, the `initialize_sync_target_request()` function performs only version comparisons, never calling `verify_signatures()`: [5](#0-4) 

The `LedgerInfoWithSignatures` type provides a `verify_signatures()` method that should be called: [6](#0-5) 

**Attack Flow:**
1. Malicious peer sends `CommitDecision` message with forged `LedgerInfoWithSignatures` claiming epoch 100, version 1,000,000
2. Consensus observer receives it, checks `commit_epoch == epoch_state.epoch` (fails for future epoch)
3. Skips `verify_commit_proof()` validation
4. Passes unverified commit to `state_sync_manager.sync_to_commit()`
5. State sync accepts it as sync target without signature validation
6. Node attempts to sync to non-existent version 1,000,000, wasting resources indefinitely

The code even includes a TODO comment acknowledging this gap: [7](#0-6) 

This violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." The sync target ledger info bypasses mandatory signature verification.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability enables:

1. **Validator Node DoS**: Any malicious peer can send forged future-epoch commits causing validators to waste CPU, memory, and network bandwidth attempting to sync to non-existent targets. This can slow down or halt validator operation.

2. **Network Liveness Impact**: If multiple consensus observer nodes are targeted simultaneously, the network could experience degraded liveness as nodes fall behind trying to sync to fake targets.

3. **State Sync Resource Exhaustion**: Nodes continuously retry failed sync attempts, consuming resources that should be used for legitimate consensus participation.

4. **Protocol Violation**: Bypasses the fundamental requirement that all ledger infos must be cryptographically validated before acceptance, weakening the trust model.

While this doesn't directly cause consensus safety violations or loss of funds (actual transaction data is still validated), it falls under "Significant protocol violations" and "Validator node slowdowns" in the High Severity category.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires ability to connect as a consensus observer peer (no validator keys needed)
- **Attack Complexity**: Low - simply craft and send a `CommitDecision` message with arbitrary epoch/version
- **Detection Difficulty**: Medium - node may appear to be syncing normally initially
- **Affected Nodes**: All nodes running consensus observer with `observer_enabled = true`
- **Network Exposure**: Consensus observer accepts connections from network peers

The code path is deterministic and the vulnerability is easily triggered. The presence of the TODO comment suggests the developers are aware of the gap but haven't prioritized fixing it.

## Recommendation

Add signature validation for future-epoch commit decisions before processing them. Two approaches:

**Option 1: Reject future-epoch commits entirely**
```rust
// In process_commit_decision_message
let epoch_state = self.get_epoch_state();
if commit_epoch != epoch_state.epoch {
    error!("Received commit decision for non-current epoch: {} (current: {}). Rejecting.",
           commit_epoch, epoch_state.epoch);
    return;
}
// Existing verification continues...
```

**Option 2: Validate using trusted waypoint or wait for natural sync**
```rust
// Only accept future epochs if we have a trusted source (e.g., waypoint)
if commit_epoch > epoch_state.epoch {
    // Don't immediately sync to future commits - let natural sync handle it
    // or require additional validation through trusted state
    info!("Commit for future epoch {}. Waiting for natural sync progression.", commit_epoch);
    return;
}
```

**Also add validation in state sync as defense-in-depth:**
```rust
// In initialize_sync_target_request
pub async fn initialize_sync_target_request(
    &mut self,
    sync_target_notification: ConsensusSyncTargetNotification,
    latest_pre_committed_version: Version,
    latest_synced_ledger_info: LedgerInfoWithSignatures,
) -> Result<(), Error> {
    // Get the target and validate it
    let target = sync_target_notification.get_target();
    
    // NEW: Validate signatures before accepting as sync target
    let epoch_state = utils::fetch_latest_epoch_state(self.storage.clone())?;
    if let Err(e) = target.verify_signatures(&epoch_state.verifier()) {
        let error = Err(Error::VerificationError(format!(
            "Sync target failed signature verification: {:?}", e
        )));
        self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
        return error;
    }
    
    // Existing version checks continue...
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_unvalidated_future_epoch_commit() {
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        aggregate_signature::AggregateSignature,
    };
    use aptos_crypto::HashValue;

    // Setup: Create a consensus observer node
    let (consensus_notifier, _listener) = 
        aptos_consensus_notifications::new_consensus_notifier_listener_pair(5000);

    // Attack: Create a forged commit decision for future epoch
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            100, // fake future epoch
            0,
            HashValue::zero(),
            HashValue::zero(),
            1_000_000, // fake high version
            0,
            None,
        ),
        HashValue::zero(),
    );
    
    // Create ledger info with EMPTY signatures (invalid!)
    let fake_commit_proof = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(), // No valid signatures!
    );

    // Send the forged commit to state sync
    // This should fail but currently succeeds in bypassing validation
    let result = consensus_notifier.sync_to_target(fake_commit_proof).await;
    
    // BUG: State sync accepts this unvalidated target
    // Expected: Should reject due to missing/invalid signatures
    // Actual: Accepts it and attempts to sync to version 1,000,000
}
```

**Notes:**
- Signature verification is properly implemented in `CommitDecision::verify_commit_proof()` and `LedgerInfoWithSignatures::verify_signatures()`
- The vulnerability is a logic gap, not a crypto implementation bug
- Both consensus observer and state sync assume the other will validate
- Fix requires adding validation at the boundary where unverified external data enters the system

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L467-482)
```rust
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L366-375)
```rust
    /// Verifies the commit proof and returns an error if the proof is invalid
    pub fn verify_commit_proof(&self, epoch_state: &EpochState) -> Result<(), Error> {
        epoch_state.verify(&self.commit_proof).map_err(|error| {
            Error::InvalidMessageError(format!(
                "Failed to verify commit proof ledger info: {:?}, Error: {:?}",
                self.proof_block_info(),
                error
            ))
        })
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L262-318)
```rust
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```
