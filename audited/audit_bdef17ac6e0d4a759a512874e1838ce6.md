# Audit Report

## Title
Unvalidated Address Length Causes Memory Exhaustion in API Layer via String Allocation

## Summary
The `AccountAddress::from_str()` function lacks length validation before performing string allocation, allowing attackers to trigger memory exhaustion by submitting extremely long hex strings through API endpoints that accept address parameters in JSON request bodies.

## Finding Description

The vulnerability exists in the address parsing flow where user-supplied strings are processed without length validation before memory allocation: [1](#0-0) 

When a string without "0x" prefix is provided, the code performs `format!("0x{}", s)` which allocates a new String of arbitrary length before any validation occurs. This allocation happens regardless of how long the input string is.

The Address type used in API request bodies deserializes by calling this vulnerable function: [2](#0-1) 

Multiple API endpoints accept Address fields in POST request bodies, including transaction submission: [3](#0-2) 

The attack propagates as follows:
1. Attacker sends POST request to `/transactions` with JSON body containing `{"sender": "a".repeat(7_000_000), ...}`
2. JSON deserialization calls `Address::deserialize` → `FromStr::from_str`
3. `AccountAddress::from_str()` calls `format!("0x{}", s)` allocating ~7MB
4. Only after allocation, `from_hex_literal` → `from_hex` validates and rejects the invalid length
5. Memory is allocated but wasted before error is returned

The POST body size limit is 8MB: [4](#0-3) 

This allows attackers to include up to ~8MB hex strings in address fields. Multiple concurrent requests cause cumulative memory exhaustion.

Notably, the codebase defines a `TooLong` error variant but never uses it, suggesting incomplete implementation: [5](#0-4) 

The test suite verifies that too-long addresses are rejected, but the rejection occurs after allocation: [6](#0-5) 

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria ("API crashes" - up to $50,000). 

While each individual request is limited to 8MB POST body size, attackers can:
- Send hundreds of concurrent requests, each allocating ~7-8MB for address parsing
- Cause memory exhaustion leading to API server crashes or severe degradation
- Affect API availability for legitimate users
- Target public API endpoints without authentication

The impact is limited to API layer infrastructure and does not affect blockchain consensus, state integrity, or validator operations. However, API availability is critical for users interacting with the blockchain.

## Likelihood Explanation

**High likelihood** - The attack is straightforward:
- No authentication required for API endpoints
- Publicly accessible endpoints like `/transactions`, `/view`, `/encode_submission`
- Simple to craft malicious JSON with long address strings
- Can be automated to send concurrent requests
- Limited by standard rate limiting (if present) but not by address validation

The attack complexity is low and requires only:
- HTTP client capable of POST requests
- Ability to generate large JSON payloads within 8MB limit
- No special privileges or insider access

## Recommendation

Add length validation **before** any string allocation operations:

**In `AccountAddress::from_str()`**, add validation at line 396: [1](#0-0) 

Insert check before `format!()`:
```rust
if s.len() > Self::LENGTH * 2 {
    return Err(AccountAddressParseError::TooLong);
}
```

**In `AccountAddress::from_hex_literal()`**, add validation at line 165: [7](#0-6) 

Insert check after calculating `hex_len`:
```rust
if hex_len > Self::LENGTH * 2 {
    return Err(AccountAddressParseError::TooLong);
}
```

This ensures the existing `TooLong` error variant is properly utilized and validation occurs before any memory allocation.

## Proof of Concept

```rust
#[test]
fn test_address_memory_exhaustion() {
    use aptos_api_types::Address;
    use std::str::FromStr;
    
    // Create a very long hex string (7MB worth)
    let long_address = "a".repeat(7_000_000);
    
    // Attempt to parse - this allocates ~7MB before failing
    let result = Address::from_str(&long_address);
    
    // Verify it fails (but memory was already allocated)
    assert!(result.is_err());
    
    // Simulate concurrent attack: spawn multiple threads
    let handles: Vec<_> = (0..100).map(|_| {
        let addr = long_address.clone();
        std::thread::spawn(move || {
            let _ = Address::from_str(&addr);
        })
    }).collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    // The above allocated ~700MB total across threads before rejecting inputs
}
```

For HTTP-level PoC:
```bash
# Generate 7MB of hex characters
python3 -c 'print("a" * 7000000)' > long_addr.txt

# Send POST request with malicious address
curl -X POST http://localhost:8080/v1/transactions \
  -H "Content-Type: application/json" \
  -d "{\"sender\": \"$(cat long_addr.txt)\", \"sequence_number\": \"0\", ...}"

# Repeat concurrently (100 requests)
for i in {1..100}; do curl ... & done
```

## Notes

The vulnerability is mitigated by the 8MB POST body size limit enforced by the middleware: [8](#0-7) 

However, this middleware only checks Content-Length header and doesn't prevent the memory allocation issue during JSON deserialization. The limit reduces the maximum per-request allocation but doesn't eliminate the vulnerability when combined with concurrent requests.

### Citations

**File:** third_party/move/move-core/types/src/account_address.rs (L160-178)
```rust
    pub fn from_hex_literal(literal: &str) -> Result<Self, AccountAddressParseError> {
        if !literal.starts_with("0x") {
            return Err(AccountAddressParseError::LeadingZeroXRequired);
        }

        let hex_len = literal.len() - 2;

        // If the string is too short, pad it
        if hex_len < Self::LENGTH * 2 {
            let mut hex_str = String::with_capacity(Self::LENGTH * 2);
            for _ in 0..Self::LENGTH * 2 - hex_len {
                hex_str.push('0');
            }
            hex_str.push_str(&literal[2..]);
            AccountAddress::from_hex(hex_str)
        } else {
            AccountAddress::from_hex(&literal[2..])
        }
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L391-403)
```rust
    fn from_str(s: &str) -> Result<Self, AccountAddressParseError> {
        if !s.starts_with("0x") {
            if s.is_empty() {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(&format!("0x{}", s))
        } else {
            if s.len() == 2 {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(s)
        }
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L453-454)
```rust
    #[error("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x")]
    TooLong,
```

**File:** third_party/move/move-core/types/src/account_address.rs (L692-696)
```rust
        // Too long
        AccountAddress::from_hex_literal(
            "0x10000000000000000000000000000001100000000000000000000000000000001",
        )
        .unwrap_err();
```

**File:** api/types/src/address.rs (L91-98)
```rust
impl<'de> Deserialize<'de> for Address {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let address = <String>::deserialize(deserializer)?;
        address.parse().map_err(D::Error::custom)
    }
```

**File:** api/types/src/transaction.rs (L497-507)
```rust
pub struct UserTransactionRequest {
    pub sender: Address,
    pub sequence_number: U64,
    pub max_gas_amount: U64,
    pub gas_unit_price: U64,
    pub expiration_timestamp_secs: U64,
    pub payload: TransactionPayload,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<TransactionSignature>,
    pub replay_protection_nonce: Option<U64>,
}
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/check_size.rs (L11-22)
```rust
/// This middleware confirms that the Content-Length header is set and the
/// value is within the acceptable range. It only applies to POST requests.
pub struct PostSizeLimit {
    max_size: u64,
}

impl PostSizeLimit {
    pub fn new(max_size: u64) -> Self {
        Self { max_size }
    }
}

```
