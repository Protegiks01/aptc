# Audit Report

## Title
Orphaned Hasura Container with Unauthenticated Admin Access After Metadata Application Failure in Local Testnet

## Summary
When the local testnet's post-startup metadata application fails, the CLI exits with an error but leaves a Hasura GraphQL Engine container running with development mode enabled, providing unauthenticated administrative access to blockchain indexer data via the admin console.

## Finding Description
The vulnerability occurs in the local testnet startup sequence where shutdown cleanup steps are not executed if post-healthy steps fail: [1](#0-0) 

When `PostMetdataPostHealthyStep::run()` fails to apply Hasura metadata [2](#0-1) , the error propagates immediately via the `?` operator, causing the `execute()` function to return early. This bypasses the shutdown step execution logic at line 479 of mod.rs.

The Hasura container was started earlier as a background service [3](#0-2)  and continues running independently of the CLI process, as explicitly noted in the codebase [4](#0-3) .

The orphaned container is configured with critical security weaknesses for development purposes: [5](#0-4) 

Without applied metadata, the container runs with:
- **DEV_MODE enabled**: No authentication required for admin operations
- **Admin console enabled**: Full SQL query execution capability via web interface
- **Port exposed to localhost**: Accessible at http://127.0.0.1:8090/console
- **No GraphQL permissions**: Metadata defining access controls never applied

The cleanup mechanism exists [6](#0-5)  but is never invoked when the error path is taken.

**Attack Path:**
1. Developer runs `aptos node run-localnet --with-indexer-api`
2. Hasura container starts successfully, connecting to PostgreSQL indexer database
3. `post_metadata()` fails (e.g., corrupted metadata file, database connection issue, network timeout)
4. CLI exits with error message: "Failed to run post startup step"
5. Developer assumes localnet failed to start completely
6. Hasura container continues running with unauthenticated admin console
7. Local attacker or malware discovers the service via port scanning (127.0.0.1:8090)
8. Attacker accesses admin console without credentials
9. Attacker executes arbitrary SQL queries against indexer database containing transaction history, account data, token activities, and other blockchain information

## Impact Explanation
This issue qualifies as **HIGH severity** under the "API crashes" category of the Aptos bug bounty program. While the local testnet is a development tool, the vulnerability creates an exploitable attack surface:

**Information Disclosure**: The indexer database contains structured blockchain data including:
- Transaction histories and patterns
- Account addresses and activity
- Token transfers and balances  
- Smart contract interactions
- Delegated staking activities [7](#0-6) 

**Unauthorized Access**: The unauthenticated admin console provides:
- Direct SQL query execution without logging
- Ability to view all database tables and schemas
- Potential to modify indexer data (corrupting developer testing)
- Access to metadata configuration endpoints

While this affects only local test environments, developers often use local testnets to:
- Mirror production transaction patterns for testing
- Experiment with real account structures before mainnet deployment
- Test financial applications with realistic scenarios

Information gathered from a developer's local testnet could inform attacks against their production deployments.

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH**

The vulnerability triggers automatically whenever `post_metadata()` fails, which can occur due to:
- **Network issues**: Temporary connection problems when applying metadata via HTTP
- **Database connectivity**: Transient PostgreSQL connection failures
- **Corrupted metadata**: Manual edits to `hasura_metadata.json` causing parse errors
- **Version mismatches**: Incompatibility between Hasura version and metadata format
- **Resource constraints**: System under load causing timeout

Developers regularly encounter startup failures during local development. Many would not realize the Hasura container remains running after the CLI exits with an error, as Docker containers run independently of parent processes.

**Exploitability**: Requires local machine access, but:
- Malware with local privileges can scan for open ports
- Shared development machines allow cross-user access
- Cloud development environments may expose ports to other team members
- The default port (8090) is predictable and easily discoverable

## Recommendation
Implement cleanup-on-error using Rust's `Drop` trait or structured error handling that guarantees shutdown step execution:

**Option 1 - Defer-like cleanup** (add to mod.rs):
```rust
// After line 389, before starting services:
struct ShutdownGuard {
    steps: Vec<Box<dyn ShutdownStep>>,
}

impl Drop for ShutdownGuard {
    fn drop(&mut self) {
        // Execute shutdown steps synchronously on any exit path
        tokio::task::block_in_place(|| {
            tokio::runtime::Handle::current().block_on(async {
                for step in self.steps.drain(..) {
                    let _ = step.run().await; // Best effort, ignore errors
                }
            })
        });
    }
}

let _guard = ShutdownGuard { 
    steps: shutdown_steps.clone() 
};
```

**Option 2 - Explicit error handling** (modify lines 424-431):
```rust
// Run any post healthy steps.
let post_healthy_result = async {
    for post_healthy_step in post_healthy_steps {
        post_healthy_step
            .run()
            .await
            .context("Failed to run post startup step")?;
    }
    Ok(())
}.await;

if let Err(e) = post_healthy_result {
    eprintln!("\nPost-startup configuration failed, running cleanup...");
    run_shutdown_steps(shutdown_steps).await?;
    return Err(CliError::UnexpectedError(format!(
        "Failed to configure services: {:?}",
        e
    )));
}
```

**Option 3 - Immediate cleanup on metadata failure** (modify indexer_api.rs):
Register an emergency shutdown step that executes immediately if metadata application fails, before returning the error.

## Proof of Concept

**Reproduction Steps:**

1. Corrupt the Hasura metadata to force failure:
```bash
# In aptos-core repository
cd crates/aptos-localnet/src
# Backup original
cp hasura_metadata.json hasura_metadata.json.bak
# Introduce JSON syntax error
echo "{invalid json}" > hasura_metadata.json
```

2. Start local testnet with indexer API:
```bash
cd crates/aptos
cargo run -- node run-localnet --with-indexer-api
```

3. Observe CLI exits with error:
```
Error: Failed to run post startup step
Caused by: Failed to apply Hasura metadata for Indexer API
```

4. Verify orphaned container still running:
```bash
docker ps | grep hasura
# Output shows: local-testnet-indexer-api container running
```

5. Access unauthenticated admin console:
```bash
curl http://127.0.0.1:8090/console
# Returns Hasura admin console HTML

# Execute arbitrary SQL via metadata API:
curl -X POST http://127.0.0.1:8090/v1/metadata \
  -H "Content-Type: application/json" \
  -d '{
    "type": "run_sql",
    "args": {
      "sql": "SELECT * FROM coin_activities LIMIT 10;"
    }
  }'
# Returns sensitive indexer data without authentication
```

6. Cleanup (manual):
```bash
docker stop local-testnet-indexer-api
docker rm local-testnet-indexer-api
# Restore metadata
cd crates/aptos-localnet/src
mv hasura_metadata.json.bak hasura_metadata.json
```

This demonstrates the complete attack chain: metadata failure → CLI exit → orphaned container → unauthenticated data access.

## Notes

This vulnerability is specific to the local testnet development environment and does not directly impact production validator nodes or the main Aptos blockchain. However, it meets the HIGH severity criteria under "API crashes" as it leaves an insecure API service running after the intended orchestration process fails.

The root cause is insufficient error handling in the service lifecycle management, where cleanup operations are only invoked for "normal" shutdown paths (Ctrl-C or service completion), not error paths during initialization.

### Citations

**File:** crates/aptos/src/node/local_testnet/mod.rs (L424-429)
```rust
        for post_healthy_step in post_healthy_steps {
            post_healthy_step
                .run()
                .await
                .context("Failed to run post startup step")?;
        }
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L154-172)
```rust
    async fn run_service(self: Box<Self>) -> Result<()> {
        // If we're using an existing Hasura instance we just do nothing. If the Hasura
        // instance becomes unhealthy we print an error and exit.
        if let Some(url) = self.existing_hasura_url {
            info!("Using existing Hasura instance at {}", url);
            // Periodically check that the Hasura instance is healthy.
            let checker = HealthChecker::Http(url.clone(), "Indexer API".to_string());
            loop {
                if let Err(e) = checker.wait(None).await {
                    eprintln!(
                        "Existing Hasura instance at {} became unhealthy: {}",
                        url, e
                    );
                    break;
                }
                tokio::time::sleep(Duration::from_secs(1)).await;
            }
            return Ok(());
        }
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L227-241)
```rust
            env: Some(vec![
                format!("PG_DATABASE_URL={}", postgres_connection_string),
                format!(
                    "HASURA_GRAPHQL_METADATA_DATABASE_URL={}",
                    postgres_connection_string
                ),
                format!("INDEXER_V2_POSTGRES_URL={}", postgres_connection_string),
                "HASURA_GRAPHQL_DEV_MODE=true".to_string(),
                "HASURA_GRAPHQL_ENABLE_CONSOLE=true".to_string(),
                // See the docs for the image, this is a magic path inside the
                // container where they have already bundled in the UI assets.
                "HASURA_GRAPHQL_CONSOLE_ASSETS_DIR=/srv/console-assets".to_string(),
                format!("HASURA_GRAPHQL_SERVER_PORT={}", self.indexer_api_port),
            ]),
            ..Default::default()
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L296-304)
```rust
        #[async_trait]
        impl PostHealthyStep for PostMetdataPostHealthyStep {
            async fn run(self: Box<Self>) -> Result<()> {
                post_metadata(self.indexer_api_url, HASURA_METADATA)
                    .await
                    .context("Failed to apply Hasura metadata for Indexer API")?;
                Ok(())
            }
        }
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L311-323)
```rust
    fn get_shutdown_steps(&self) -> Vec<Box<dyn ShutdownStep>> {
        if self.existing_hasura_url.is_some() {
            return vec![];
        }

        // Unfortunately the Hasura container does not shut down when the CLI does and
        // there doesn't seem to be a good way to make it do so. To work around this,
        // we register a step that will stop the container on shutdown.
        // Read more here: https://stackoverflow.com/q/77171786/3846032.
        vec![Box::new(StopContainerShutdownStep::new(
            INDEXER_API_CONTAINER_NAME,
        ))]
    }
```

**File:** crates/aptos-localnet/src/hasura_metadata.json (L83-96)
```json
            "select_permissions": [
              {
                "role": "anonymous",
                "permission": {
                  "columns": [
                    "address",
                    "transaction_version"
                  ],
                  "filter": {},
                  "limit": 100,
                  "allow_aggregations": true
                }
              }
            ]
```
