# Audit Report

## Title
Stale IP Range Configuration in Faucet Manager Allows Bypass of Security Controls

## Summary
The `IpRangeManager` in the Aptos faucet loads IP configuration files once during initialization and never reloads them. [1](#0-0)  When operators modify blocklist or allowlist files to respond to ongoing abuse, these changes do not take effect until the faucet service is restarted, allowing continued security control bypass.

## Finding Description
The `IpRangeManager::new()` function reads IP range configuration from a file and stores it in memory as `ipv4_list` and `ipv6_list` fields. [1](#0-0)  Once initialized, there is no mechanism to detect file modifications or reload the configuration.

This manager is used by two critical security components:

1. **IP Blocklist Checker** - blocks abusive IP addresses from accessing the faucet [2](#0-1) 

2. **IP Allowlist Bypasser** - allows trusted IPs to bypass all security checks [3](#0-2) 

During faucet initialization, these components are built once and stored in `FundApiComponents`. [4](#0-3)  The loaded IP ranges remain static throughout the service lifetime.

**Attack Scenario 1 - Blocklist Bypass:**
1. Attacker abuses faucet from IP `203.0.113.50`
2. Operator adds `203.0.113.50` to blocklist config file
3. **Vulnerability**: Service continues using old in-memory blocklist
4. Attacker continues draining faucet until manual service restart

**Attack Scenario 2 - Allowlist Persistence:**
1. Trusted IP `198.51.100.10` is in allowlist, bypassing all rate limits
2. IP becomes compromised or untrusted
3. Operator removes `198.51.100.10` from allowlist config
4. **Vulnerability**: Compromised IP continues bypassing all checks until restart

## Impact Explanation
This issue qualifies as **Medium Severity** under the Aptos bug bounty criteria: "Limited funds loss or manipulation."

The faucet distributes testnet tokens used by developers. While these are test tokens, the service can be:
- **Drained** by blocklisted IPs continuing abuse without rate limits
- **Abused** by removed allowlist IPs maintaining bypass privileges
- **Compromised** during the window between config update and service restart

The operational impact includes:
- Inability to respond to active abuse in real-time
- Extended exposure window for compromised trusted IPs
- Requirement for service restarts (downtime) to enforce policy changes

## Likelihood Explanation
**Likelihood: High**

This issue will occur in any production faucet deployment where operators need to:
- Respond to ongoing abuse by adding IPs to blocklists
- Remove compromised or untrusted IPs from allowlists
- Update security policies without downtime

The issue is **guaranteed** to manifest because:
1. There is no reload mechanism in the codebase
2. The `contains_ip()` check uses only in-memory data [5](#0-4) 
3. Faucet abuse is common on testnets, requiring frequent blocklist updates

## Recommendation
Implement a configuration reload mechanism using one of these approaches:

**Option 1: File System Watcher (Recommended)**
```rust
use notify::{Watcher, RecursiveMode, watcher};
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct IpRangeManager {
    pub ipv4_list: Arc<RwLock<IpRange<Ipv4Net>>>,
    pub ipv6_list: Arc<RwLock<IpRange<Ipv6Net>>>,
    config: IpRangeManagerConfig,
}

impl IpRangeManager {
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        let (ipv4_list, ipv6_list) = Self::load_ranges(&config)?;
        
        let manager = Self {
            ipv4_list: Arc::new(RwLock::new(ipv4_list)),
            ipv6_list: Arc::new(RwLock::new(ipv6_list)),
            config,
        };
        
        manager.spawn_file_watcher()?;
        Ok(manager)
    }
    
    fn spawn_file_watcher(&self) -> Result<()> {
        let (tx, rx) = std::sync::mpsc::channel();
        let mut watcher = watcher(tx, Duration::from_secs(1))?;
        watcher.watch(&self.config.file, RecursiveMode::NonRecursive)?;
        
        let config = self.config.clone();
        let ipv4_list = self.ipv4_list.clone();
        let ipv6_list = self.ipv6_list.clone();
        
        tokio::spawn(async move {
            while let Ok(_) = rx.recv() {
                if let Ok((new_v4, new_v6)) = Self::load_ranges(&config) {
                    *ipv4_list.write().await = new_v4;
                    *ipv6_list.write().await = new_v6;
                    info!("Reloaded IP ranges from {}", config.file.display());
                }
            }
        });
        Ok(())
    }
    
    pub async fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.read().await.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.read().await.contains(ipv6),
        }
    }
}
```

**Option 2: Periodic Polling**
Add a periodic task to check file modification time and reload if changed.

**Option 3: Manual Reload Endpoint**
Expose an admin endpoint to trigger manual reloads without full restart.

## Proof of Concept

```rust
#[tokio::test]
async fn test_ip_range_manager_stale_config() -> Result<()> {
    use std::fs::File;
    use std::io::Write;
    use std::path::PathBuf;
    
    // Create initial config with one IP
    let config_path = PathBuf::from("/tmp/test_ip_blocklist.txt");
    let mut file = File::create(&config_path)?;
    writeln!(file, "192.168.1.0/24")?;
    drop(file);
    
    // Initialize manager
    let manager = IpRangeManager::new(IpRangeManagerConfig {
        file: config_path.clone(),
    })?;
    
    // Verify IP in range is detected
    let test_ip: IpAddr = "192.168.1.50".parse()?;
    assert!(manager.contains_ip(&test_ip));
    
    // Update config file to add another range
    let mut file = File::create(&config_path)?;
    writeln!(file, "192.168.1.0/24")?;
    writeln!(file, "10.0.0.0/8")?;
    drop(file);
    
    // Wait to ensure file is written
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    
    // VULNERABILITY: New range is NOT detected
    let new_ip: IpAddr = "10.0.0.100".parse()?;
    assert!(!manager.contains_ip(&new_ip)); // Should be true, but returns false
    
    // This demonstrates that config changes are not loaded
    // An attacker from 10.0.0.100 would NOT be blocked
    // even though operator added this range to the blocklist
    
    Ok(())
}
```

## Notes
This vulnerability affects both the IP blocklist checker and IP allowlist bypasser components. The faucet is a critical service for testnet operations, and inability to dynamically enforce security policies creates an exploitable window for attackers. While this is a testnet service, the resource exhaustion and abuse potential warrant addressing this design limitation.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L24-53)
```rust
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;

        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        let mut ipv6_list = IpRange::<Ipv6Net>::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            match line.parse::<Ipv4Net>() {
                Ok(ipv4_net) => {
                    ipv4_list.add(ipv4_net);
                },
                Err(_) => match line.parse::<Ipv6Net>() {
                    Ok(ipv6_net) => {
                        ipv6_list.add(ipv6_net);
                    },
                    Err(_) => {
                        bail!("Failed to parse line as IPv4 or IPv6 range: {}", line);
                    },
                },
            }
        }
        Ok(Self {
            ipv4_list,
            ipv6_list,
        })
    }
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L17-22)
```rust
impl IpBlocklistChecker {
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        Ok(Self {
            manager: IpRangeManager::new(config)?,
        })
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L16-21)
```rust
impl IpAllowlistBypasser {
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        Ok(Self {
            manager: IpRangeManager::new(config)?,
        })
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L114-152)
```rust
        // Build Bypassers.
        let mut bypassers: Vec<Bypasser> = Vec::new();
        for bypasser_config in &self.bypasser_configs {
            let bypasser = bypasser_config.clone().build().with_context(|| {
                format!("Failed to build Bypasser with args: {:?}", bypasser_config)
            })?;
            bypassers.push(bypasser);
        }

        // Create a periodic task manager.
        let mut join_set = JoinSet::new();

        // Build Checkers and let them spawn tasks on the periodic task
        // manager if they want.
        let mut checkers: Vec<Checker> = Vec::new();
        for checker_config in &self.checker_configs {
            let checker = checker_config
                .clone()
                .build(captcha_manager.clone())
                .await
                .with_context(|| {
                    format!("Failed to build Checker with args: {:?}", checker_config)
                })?;
            checker.spawn_periodic_tasks(&mut join_set);
            checkers.push(checker);
        }

        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());

        // Using those, build the fund API components.
        let fund_api_components = Arc::new(FundApiComponents {
            bypassers,
            checkers,
            funder,
            return_rejections_early: self.handler_config.return_rejections_early,
            concurrent_requests_semaphore,
        });
```
