# Audit Report

## Title
Database Index Inconsistency Due to Unconditional Metadata Update in Transaction Pruner

## Summary
The `TransactionPruner::prune()` function exhibits inconsistent behavior when `get_pruning_candidate_transactions()` returns an empty vector. While index deletion operations depend on the candidate transactions list, the main transaction data deletion operates on the version range directly, and the pruner progress metadata is updated unconditionally. This creates a scenario where orphaned index entries can persist indefinitely if database corruption or partial state exists.

## Finding Description
The transaction pruner violates the **State Consistency** invariant by handling empty candidate transactions inconsistently across different database schemas. [1](#0-0) 

When `get_pruning_candidate_transactions()` returns an empty vector: [2](#0-1) 

The subsequent operations exhibit inconsistent behavior:

1. **Index deletions** (lines 41-46, 52-53, 61-62, 69-70) iterate over the empty `candidate_transactions` list and delete nothing
2. **Main transaction deletion** (lines 47-51) uses the version range `[current_progress, target_version)` directly, independent of `candidate_transactions` [3](#0-2) 

3. **Metadata update** (lines 54-57) advances the progress marker unconditionally to `target_version`

This creates an inconsistency where:
- `TransactionByHashSchema` indices are only deleted if transactions exist in `candidate_transactions`
- `TransactionSummariesByAccountSchema` indices are only deleted if transactions exist in `candidate_transactions`  
- `OrderedTransactionByAccountSchema` indices are only deleted if transactions exist in `candidate_transactions`
- But `TransactionSchema` entries are deleted based on version range
- And the progress marker always advances

**Scenario**: If `TransactionSchema` entries are missing (due to prior corruption, crash, or partial deletion) but their indices still exist:
1. `get_pruning_candidate_transactions()` returns empty (no `TransactionSchema` entries found)
2. No indices are deleted (empty iteration)
3. `prune_transactions()` is a no-op (entries already missing)
4. Progress metadata advances to `target_version`
5. **Result**: Orphaned index entries remain forever, as this version range is marked as pruned and never revisited

This violates database consistency where indices point to non-existent transactions, breaking the invariant that indices must be consistent with main transaction data. [4](#0-3) 

## Impact Explanation
This is a **Medium severity** issue per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The orphaned indices cause:
- Transaction hash lookups returning versions for non-existent transactions
- Account transaction queries returning stale metadata
- Potential crashes or errors when attempting to fetch actual transaction content
- Database bloat from unreachable index entries
- Violation of the State Consistency invariant

However, this does not directly lead to consensus violations, fund loss, or exploitable attacks without pre-existing database corruption.

## Likelihood Explanation
**Likelihood: Low to Medium**

This issue manifests only when:
- Database corruption occurs (disk failure, crash during write)
- Partial transaction deletion happens (manual intervention, interrupted pruning)
- Recovery scenarios where `TransactionSchema` and indices become desynchronized

While not directly exploitable by an unprivileged attacker, these scenarios can occur in production environments through:
- Node crashes during pruning operations
- Disk corruption or hardware failures
- Database migration or recovery procedures

Once triggered, the inconsistency is permanent as the pruner will never revisit the affected version range.

## Recommendation
The pruner should ensure atomic consistency between all schemas. The fix should:

1. **Verify actual deletions before updating metadata**: Only advance the progress marker if transactions were actually found and processed
2. **Use consistent deletion logic**: Either all deletions should use `candidate_transactions`, or all should use version ranges
3. **Add recovery mechanism**: Implement index cleanup that doesn't depend on `TransactionSchema` presence

**Proposed fix**:
```rust
fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
    let mut batch = SchemaBatch::new();
    let candidate_transactions =
        self.get_pruning_candidate_transactions(current_progress, target_version)?;
    
    // Only proceed if we actually have transactions to prune
    if !candidate_transactions.is_empty() {
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
        self.ledger_db.transaction_db().prune_transactions(
            current_progress,
            target_version,
            &mut batch,
        )?;
        self.transaction_store
            .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
            
        // Only update metadata after successful processing
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        
        // ... rest of indexer logic ...
        
        self.ledger_db.transaction_db().write_schemas(batch)
    } else {
        // Log warning about empty pruning attempt but don't advance progress
        info!("No transactions found to prune in range [{}, {}), skipping", 
              current_progress, target_version);
        Ok(())
    }
}
```

## Proof of Concept
```rust
// Pseudo-code demonstrating the issue
// This would require direct database manipulation to simulate corruption

#[test]
fn test_orphaned_indices_on_empty_candidates() {
    // Setup: Create a database with transactions and indices
    let db = create_test_db();
    insert_transaction(db, version=100, tx_data, tx_hash, account);
    
    // Simulate corruption: Delete TransactionSchema entry but keep indices
    db.delete::<TransactionSchema>(&100);
    // Indices still exist:
    // - TransactionByHashSchema(tx_hash) -> 100
    // - TransactionSummariesByAccountSchema((account, 100)) -> summary
    
    // Run pruner
    let pruner = TransactionPruner::new(...);
    pruner.prune(100, 101)?;
    
    // Verify issue:
    // 1. get_pruning_candidate_transactions(100, 101) returns empty
    assert!(candidate_transactions.is_empty());
    
    // 2. Metadata advanced despite no actual pruning
    assert_eq!(get_progress(), 101);
    
    // 3. Orphaned indices remain
    assert!(db.get::<TransactionByHashSchema>(&tx_hash).is_some()); // FAIL: should be deleted
    assert!(db.get::<TransactionSummariesByAccountSchema>(&(account, 100)).is_some()); // FAIL
    
    // 4. Future lookups return stale data
    let version = db.get_transaction_version_by_hash(&tx_hash);
    assert_eq!(version, Some(100)); // Returns version for non-existent transaction!
}
```

## Notes
- This issue requires pre-existing database corruption or crash scenarios to manifest
- It is **not directly exploitable** by unprivileged attackers without physical/system access
- The vulnerability lies in the **robustness** of the pruner's error handling and recovery mechanisms
- While not an active attack vector, it represents a deviation from defensive programming practices
- The unconditional metadata update is the primary concern, as it prevents future cleanup attempts

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L37-74)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        let candidate_transactions =
            self.get_pruning_candidate_transactions(current_progress, target_version)?;
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
        self.ledger_db.transaction_db().prune_transactions(
            current_progress,
            target_version,
            &mut batch,
        )?;
        self.transaction_store
            .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
        self.ledger_db.transaction_db().write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L106-131)
```rust
    fn get_pruning_candidate_transactions(
        &self,
        start: Version,
        end: Version,
    ) -> Result<Vec<(Version, Transaction)>> {
        ensure!(end >= start, "{} must be >= {}", end, start);

        let mut iter = self
            .ledger_db
            .transaction_db_raw()
            .iter::<TransactionSchema>()?;
        iter.seek(&start)?;

        // The capacity is capped by the max number of txns we prune in a single batch. It's a
        // relatively small number set in the config, so it won't cause high memory usage here.
        let mut txns = Vec::with_capacity((end - start) as usize);
        for item in iter {
            let (version, txn) = item?;
            if version >= end {
                break;
            }
            txns.push((version, txn));
        }

        Ok(txns)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L169-179)
```rust
    pub(crate) fn prune_transactions(
        &self,
        begin: Version,
        end: Version,
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for version in begin..end {
            db_batch.delete::<TransactionSchema>(&version)?;
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/schema/transaction_by_hash/mod.rs (L4-10)
```rust
//! This module defines physical storage schema mapping transaction hash to its version.
//! With the version one can resort to `TransactionSchema` for the transaction content.
//!
//! ```text
//! |<--key-->|<-value->|
//! |   hash  | txn_ver |
//! ```
```
