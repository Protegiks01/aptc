# Audit Report

## Title
Non-Exhaustive Match Statement Causes Silent Dropping of Quorum Store V2 Messages

## Summary
The network layer's message routing logic contains a non-exhaustive match statement that only handles V1 quorum store messages, causing all V2 variants (`BatchMsgV2`, `SignedBatchInfoMsgV2`, `ProofOfStoreMsgV2`) to be silently dropped when the `enable_batch_v2` configuration flag is enabled. This breaks the quorum store protocol and causes consensus performance degradation.

## Finding Description

The `ConsensusMsg` enum defines V2 variants for quorum store messages that use `BatchInfoExt` instead of `BatchInfo`: [1](#0-0) 

When `enable_batch_v2` is enabled in the configuration, validators send these V2 messages:

**Batch messages:** [2](#0-1) 

**Signed batch info messages:** [3](#0-2) 

**Proof of store messages:** [4](#0-3) 

These messages are sent via direct send (not RPC): [5](#0-4) 

However, the network layer's message routing logic in `NetworkTask::start()` only handles V1 quorum store messages: [6](#0-5) 

The V2 variants are not matched by any explicit pattern and fall through to the catch-all branch that silently drops them: [7](#0-6) 

Notably, the downstream processing layer CAN handle V2 messages, as evidenced by the `From<ConsensusMsg>` conversion and verification logic: [8](#0-7) 

This indicates an incomplete migration where V2 support was added throughout the codebase except for the critical network routing logic.

**Attack Scenario:**
1. A validator operator enables `enable_batch_v2` in their configuration [9](#0-8) 
2. The validator broadcasts V2 batch messages, signed batch info, and proof of store messages
3. Peer validators receive these V2 messages via `Event::Message`
4. The network routing match statement checks message types
5. V2 messages don't match any explicit pattern (only V1 is matched at lines 823-830)
6. V2 messages hit the catch-all `_` pattern at line 937
7. Messages are logged as "Unexpected direct send msg" and dropped without processing
8. Quorum store protocol fails because critical coordination messages are lost
9. Consensus performance degrades significantly

## Impact Explanation

This vulnerability has **High Severity** impact according to Aptos bug bounty criteria:

**Validator Node Slowdowns (High):** The quorum store is critical for efficient transaction batching and consensus operation. When V2 messages are dropped:
- Batch messages (transaction batches) don't reach peer validators
- Signed batch info (votes/acknowledgments on batches) are lost
- Proof of store messages (aggregated signatures proving batch availability) are lost
- The quorum store protocol cannot function correctly
- Consensus performance degrades due to inefficient batch processing

**Protocol Violations:** The quorum store protocol requires reliable delivery of these message types for correct operation. Silently dropping them breaks the protocol's correctness guarantees and creates inconsistent network behavior where validators with V2 enabled behave differently from those without it.

The default configuration sets `enable_batch_v2: false` [10](#0-9) , but validator operators could enable it expecting improved functionality, not realizing their messages will be dropped by all peers.

## Likelihood Explanation

**Likelihood: High**

1. **Easy to Trigger:** Any validator operator can enable the flag through configuration changes
2. **Silent Failure:** The bug manifests as dropped messages with only warning logs, making it difficult to diagnose
3. **Latent Bug:** The infrastructure to handle V2 messages exists (sending, receiving, verification), but the critical routing logic was not updated - this is an incomplete migration
4. **Immediate Production Impact:** Enabling this flag immediately breaks quorum store functionality for that validator
5. **No Attacker Required:** This is a logic bug that triggers automatically when the feature flag is enabled

## Recommendation

Add explicit match arms for V2 quorum store messages in the network routing logic. In `consensus/src/network.rs` at line 822, update the match statement to handle V2 variants:

```rust
match msg {
    quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
    | ConsensusMsg::BatchMsg(_)
    | ConsensusMsg::ProofOfStoreMsg(_)
    | ConsensusMsg::BatchMsgV2(_)
    | ConsensusMsg::SignedBatchInfoMsgV2(_)
    | ConsensusMsg::ProofOfStoreMsgV2(_)) => {
        Self::push_msg(
            peer_id,
            quorum_store_msg,
            &self.quorum_store_messages_tx,
        );
    },
    // ... rest of match arms
}
```

This ensures V2 messages are routed to the quorum store processing channel where they can be properly converted to `UnverifiedEvent` and verified.

## Proof of Concept

While a complete PoC requires a full Aptos testnet setup, the vulnerability can be verified through code inspection:

1. Enable `enable_batch_v2 = true` in a validator's `QuorumStoreConfig`
2. The validator will call `broadcast_batch_msg_v2()`, `send_signed_batch_info_msg_v2()`, and `broadcast_proof_of_store_msg_v2()`
3. These send `ConsensusMsg::BatchMsgV2`, `ConsensusMsg::SignedBatchInfoMsgV2`, and `ConsensusMsg::ProofOfStoreMsgV2` via direct send
4. Receiving validators' `NetworkTask::start()` receives these as `Event::Message(peer_id, msg)`
5. The match statement at lines 822-940 has no arm matching V2 variants
6. Messages fall through to the catch-all at line 937 and are dropped
7. Monitor logs will show "Unexpected direct send msg" warnings
8. Quorum store metrics will show batch coordination failures

**Notes:**
This is a critical logic bug in an incomplete feature migration. All infrastructure to support V2 messages exists except the network routing logic, creating a situation where enabling the feature flag immediately breaks functionality.

### Citations

**File:** consensus/src/network_interface.rs (L97-102)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-501)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
                            } else {
                                let batches = batches.into_iter().map(|batch| {
                                    batch.try_into().expect("Cannot send V2 batch with flag disabled")
                                }).collect();
                                network_sender.broadcast_batch_msg(batches).await;
                            }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-110)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L485-487)
```rust
                                    if proofs_iter.peek().is_some_and(|p| p.info().is_v2()) {
                                        let proofs: Vec<_> = proofs_iter.collect();
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
```

**File:** consensus/src/network.rs (L617-632)
```rust
    async fn broadcast_batch_msg_v2(&mut self, batches: Vec<Batch<BatchInfoExt>>) {
        fail_point!("consensus::send::broadcast_batch", |_| ());
        let msg = ConsensusMsg::BatchMsgV2(Box::new(BatchMsg::new(batches)));
        self.broadcast(msg).await
    }

    async fn broadcast_proof_of_store_msg(&mut self, proofs: Vec<ProofOfStore<BatchInfo>>) {
        fail_point!("consensus::send::proof_of_store", |_| ());
        let msg = ConsensusMsg::ProofOfStoreMsg(Box::new(ProofOfStoreMsg::new(proofs)));
        self.broadcast(msg).await
    }

    async fn broadcast_proof_of_store_msg_v2(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) {
        fail_point!("consensus::send::proof_of_store", |_| ());
        let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L822-830)
```rust
                    match msg {
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/round_manager.rs (L263-265)
```rust
            ConsensusMsg::BatchMsgV2(m) => UnverifiedEvent::BatchMsgV2(m),
            ConsensusMsg::SignedBatchInfoMsgV2(m) => UnverifiedEvent::SignedBatchInfoMsgV2(m),
            ConsensusMsg::ProofOfStoreMsgV2(m) => UnverifiedEvent::ProofOfStoreMsgV2(m),
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```
