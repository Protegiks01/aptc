# Audit Report

## Title
Lack of Secure Policy Templates and Insufficient Warnings Enables Accidental Exposure of Production Validator Keys

## Summary
The Aptos secure storage system lacks predefined secure policy templates for common validator deployment scenarios (single validator, validator pool, testnet vs production). The codebase provides a dangerous `Policy::public()` API without warnings or documentation, making it trivial for validator operators to accidentally expose production consensus keys by misconfiguring Vault policies with `Identity::Anyone` permissions.

## Finding Description
The secure storage policy system in `aptos-core/secure/storage/src/policy.rs` provides a `Policy::public()` method that grants `Identity::Anyone` both Read and Write capabilities. [1](#0-0) 

When policies are applied through `VaultPolicy::set_policies()`, any permission with `Identity::Anyone` is automatically mapped to the special `APTOS_DEFAULT` policy name. [2](#0-1) 

Critically, the `create_token()` method automatically appends `APTOS_DEFAULT` to every token created in the Vault instance. [3](#0-2) 

This design means that if a validator operator sets consensus keys (stored via `PersistentSafetyStorage`) [4](#0-3)  with a policy containing `Identity::Anyone`, those keys become accessible to any entity possessing any token from that Vault instance.

The codebase provides:
- **No secure policy templates** for production validator scenarios
- **No warnings** that `Policy::public()` is test-only [1](#0-0) 
- **No documentation** distinguishing testnet from production policy configurations
- **Only test examples** showing policy usage [5](#0-4) 

**Attack Scenario:**
1. Validator operator sets up Vault for their production node
2. Operator references test files and uses `Policy::public()` for consensus keys, believing it's standard practice
3. Consensus keys are now governed by `APTOS_DEFAULT` policy
4. Any compromised component with a Vault token (e.g., key_manager, monitoring tools) can export the consensus private keys
5. Attacker with access to any token can impersonate the validator in consensus

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program, potentially escalating to **Critical** depending on exploitation:

- **If exploited:** Exposure of consensus private keys would allow validator impersonation, enabling consensus safety violations and equivocation attacks (**Critical: Consensus/Safety violations**)
- **Pre-exploitation:** This is a misconfiguration vulnerability requiring operator error, but the codebase actively facilitates such errors through lack of templates and warnings (**Medium: State inconsistencies requiring intervention**)

The issue violates the **Access Control** invariant: validator consensus keys must only be accessible to authorized components, not to any token holder.

## Likelihood Explanation
**Likelihood: Medium-High**

Factors increasing likelihood:
- Zero secure policy templates provided for common scenarios
- `Policy::public()` exists without warnings or deprecation notices
- Test files are the only practical examples available
- No distinction between testnet/production configurations in policy APIs
- Validators deploying nodes may copy test patterns without understanding security implications

The README explicitly states Vault is "primarily used in production environments" [6](#0-5) , yet no production-ready policy examples exist in the codebase.

## Recommendation

**Immediate Actions:**

1. **Add explicit warnings to `Policy::public()`:**
```rust
/// WARNING: FOR TESTING ONLY. DO NOT USE IN PRODUCTION.
/// Creates a public policy granting Identity::Anyone full read/write access.
/// In production, this exposes all data to any token holder in the Vault instance.
#[cfg(any(test, feature = "testing"))]
pub fn public() -> Self {
    Self::new(vec![Permission::new(Identity::Anyone, vec![
        Capability::Read,
        Capability::Write,
    ])])
}
```

2. **Create secure policy templates:** [7](#0-6) 

Add production-ready templates:
```rust
impl Policy {
    /// Secure policy for single validator: only specific service can access
    pub fn validator_consensus(service_name: &str) -> Self {
        Self::new(vec![Permission::new(
            Identity::User(service_name.to_string()),
            vec![Capability::Read, Capability::Sign],
        )])
    }
    
    /// Secure policy for validator pool: separate read/sign/rotate permissions
    pub fn validator_pool(
        signer_service: &str,
        key_manager_service: &str,
    ) -> Self {
        Self::new(vec![
            Permission::new(
                Identity::User(signer_service.to_string()),
                vec![Capability::Sign],
            ),
            Permission::new(
                Identity::User(key_manager_service.to_string()),
                vec![Capability::Read, Capability::Rotate],
            ),
        ])
    }
}
```

3. **Add configuration validation** in `SafetyRulesConfig::sanitize()` to detect and reject `Identity::Anyone` policies in production: [8](#0-7) 

4. **Document secure policy configuration** in `secure/storage/README.md` with production examples.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use aptos_secure_storage::*;
    use aptos_vault_client::dev::{self, ROOT_TOKEN};
    
    #[test]
    fn test_policy_public_exposes_keys_to_any_token() {
        if dev::test_host_safe().is_none() {
            return;
        }
        
        // Validator operator sets up Vault
        let mut vault = VaultStorage::new(
            dev::test_host(),
            ROOT_TOKEN.to_string(),
            None, None, true, None, None,
        );
        let mut policy_vault = VaultPolicy::new(vault, None);
        
        // Operator mistakenly uses Policy::public() for consensus key
        let consensus_key = "consensus_key";
        policy_vault.create_key(consensus_key).unwrap();
        policy_vault
            .set_policies(consensus_key, &VaultEngine::Transit, &Policy::public())
            .unwrap();
        
        // Create a low-privilege token (e.g., for monitoring)
        let monitoring_token = policy_vault.create_token(vec!["monitoring"]).unwrap();
        
        // Attacker compromises monitoring component, obtains token
        let mut attacker_vault = VaultStorage::new(
            dev::test_host(),
            monitoring_token,
            None, None, true, None, None,
        );
        
        // Attacker can now export the consensus private key!
        let stolen_key = attacker_vault.export_private_key(consensus_key);
        assert!(stolen_key.is_ok(), 
            "Consensus key should NOT be accessible to monitoring token, but it is!");
    }
}
```

This PoC demonstrates that using `Policy::public()` allows any token holder to export consensus keys, enabling validator impersonation.

**Notes:**
- The vulnerability is in the design facilitating misconfiguration, not in the cryptographic implementation itself
- While this requires operator error, the codebase provides no safeguards against such errors
- Production validators using Vault are at risk if they reference test code patterns
- The absence of templates and warnings constitutes a security design flaw per secure development best practices

### Citations

**File:** secure/storage/src/policy.rs (L1-58)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use serde::{Deserialize, Serialize};

/// Dictates a set of permissions
#[derive(Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
pub struct Policy {
    pub permissions: Vec<Permission>,
}

impl Policy {
    pub fn new(permissions: Vec<Permission>) -> Self {
        Self { permissions }
    }

    pub fn public() -> Self {
        Self::new(vec![Permission::new(Identity::Anyone, vec![
            Capability::Read,
            Capability::Write,
        ])])
    }
}

/// Maps an identity to a set of capabilities
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct Permission {
    pub id: Identity,
    pub capabilities: Vec<Capability>,
}

impl Permission {
    pub fn new(id: Identity, capabilities: Vec<Capability>) -> Self {
        Self { id, capabilities }
    }
}

/// Id represents an internal identifier for a given process. For example, safety_rules or
/// key_manager. It is up to the Storage and its deployment to translate these identifiers into
/// verifiable material. For example, the process running safety_rules may have a token that is
/// intended for only safety_rules to own. The specifics are left to the implementation of the
/// storage backend interface layer.
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Identity {
    User(String),
    Anyone,
    NoOne,
}

/// Represents actions
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum Capability {
    Export,
    Read,
    Rotate,
    Sign,
    Write,
}
```

**File:** secure/storage/src/vault.rs (L358-359)
```rust
        pub fn create_token(&self, mut policies: Vec<&str>) -> Result<String, Error> {
            policies.push(APTOS_DEFAULT);
```

**File:** secure/storage/src/vault.rs (L421-423)
```rust
                    Identity::Anyone => {
                        self.set_policy(APTOS_DEFAULT, engine, name, &perm.capabilities)?
                    },
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L68-68)
```rust
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** secure/storage/src/tests/vault.rs (L117-117)
```rust
    let anyone = Policy::public();
```

**File:** secure/storage/README.md (L33-33)
```markdown
is the one primarily used in production environments by nodes in the blockchain.
```

**File:** config/src/config/safety_rules_config.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
