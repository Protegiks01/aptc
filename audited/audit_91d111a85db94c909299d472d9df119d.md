# Audit Report

## Title
Admin Service Exposes Sensitive Memory Statistics Over Unencrypted HTTP Without TLS Support

## Summary
The Aptos Admin Service lacks TLS/HTTPS support, forcing all handlers including `/malloc/stats` and `/malloc/dump_profile` to operate over unencrypted HTTP. This exposes authentication credentials and sensitive memory statistics to network eavesdroppers, violating security best practices for transmitting sensitive data.

## Finding Description

The Admin Service is configured to bind to a plain HTTP server without any TLS encryption capability. [1](#0-0) 

Unlike the main API service which supports optional TLS configuration through `tls_cert_path` and `tls_key_path` fields [2](#0-1) , the Admin Service configuration struct completely lacks these TLS configuration options. [3](#0-2) 

A TODO comment in the configuration acknowledges this missing security feature. [4](#0-3) 

The authentication mechanism transmits passcodes as plaintext query parameters over HTTP. [5](#0-4)  When a request like `GET /malloc/stats?passcode=mysecret` is made, the passcode is visible in plaintext to any network eavesdropper.

The malloc handlers expose detailed jemalloc memory statistics [6](#0-5)  and heap profile dumps [7](#0-6)  over this unencrypted channel. This information includes memory allocation patterns, heap structure details, and internal allocator state that could aid exploitation attempts (ASLR bypass, heap exploitation).

## Impact Explanation

This qualifies as **High Severity** based on the following:

1. **Authentication Credential Exposure**: Network attackers can capture admin passcodes transmitted in plaintext, gaining unauthorized access to all admin endpoints including consensus DB dumps, quorum store DB access, and mempool inspection capabilities.

2. **Memory Information Leakage for Exploitation**: The memory statistics exposed contain information valuable for crafting exploitation attacks against the validator node, including heap layout details that could bypass security mitigations.

3. **Mainnet Deployment Risk**: While mainnet requires authentication [8](#0-7) , the lack of TLS creates a false sense of security. Operators may believe authentication protects their service, unaware that credentials are exposed.

4. **Significant Protocol Violation**: This violates security best practices for protecting administrative interfaces on production blockchain infrastructure.

## Likelihood Explanation

**Likelihood: Medium to High**

- The admin service is enabled by default on non-mainnet chains [9](#0-8) 
- It binds to `0.0.0.0` by default [10](#0-9) , making it accessible from any network interface
- Network sniffing requires only local network access or compromised network infrastructure
- Many validator operators may expose this service on internal networks without realizing the security implications

## Recommendation

Add TLS support to AdminServiceConfig similar to ApiConfig:

1. Add TLS configuration fields to `AdminServiceConfig`:
```rust
pub struct AdminServiceConfig {
    pub enabled: Option<bool>,
    pub address: String,
    pub port: u16,
    pub authentication_configs: Vec<AuthenticationConfig>,
    pub malloc_stats_max_len: usize,
    // Add these fields:
    pub tls_cert_path: Option<String>,
    pub tls_key_path: Option<String>,
}
```

2. Modify the server binding logic to conditionally use TLS similar to the API service implementation [11](#0-10) 

3. Add configuration sanitizer to enforce TLS on mainnet when authentication is enabled

4. Consider replacing query parameter authentication with header-based authentication (e.g., `Authorization: Bearer <token>`)

## Proof of Concept

**Network Interception Scenario:**

```bash
# Terminal 1: Start aptos-node with admin service enabled
# admin_service.yaml config:
# enabled: true
# address: "0.0.0.0"
# port: 9102
# authentication_configs:
#   - passcode_sha256: "2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"  # SHA256 of "foo"

# Terminal 2: Attacker runs tcpdump to capture traffic
sudo tcpdump -i eth0 -A 'tcp port 9102'

# Terminal 3: Admin makes legitimate request
curl "http://validator-node:9102/malloc/stats?passcode=foo"

# Attacker sees in tcpdump output:
# GET /malloc/stats?passcode=foo HTTP/1.1
# Host: validator-node:9102
# 
# [Response with detailed jemalloc memory statistics]
```

The attacker now has:
1. The plaintext passcode "foo"
2. Full jemalloc memory statistics of the validator node
3. Ability to replay the passcode for future admin access

**Validation Steps:**
1. Deploy Aptos validator with admin service enabled
2. Configure PasscodeSha256 authentication
3. Use network packet capture tool on same network
4. Make admin API request from authorized client
5. Observe plaintext passcode and memory statistics in captured packets

## Notes

- This issue represents a deployment security gap rather than a consensus or state corruption vulnerability
- The TODO comment indicates awareness but lack of implementation priority
- Workaround: Deploy admin service only on isolated administrative networks with proper network segmentation and authentication at the network layer (VPN, firewalls)
- Consider this a defense-in-depth failure - relying solely on query parameter authentication over HTTP is insufficient for production administrative interfaces

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L136-136)
```rust
            let server = Server::bind(&address).serve(make_service);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L160-170)
```rust
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
```

**File:** config/src/config/api_config.rs (L23-28)
```rust
    /// Path to a local TLS certificate to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_cert_path: Option<String>,
    /// Path to a local TLS key to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_key_path: Option<String>,
```

**File:** config/src/config/admin_service_config.rs (L15-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct AdminServiceConfig {
    pub enabled: Option<bool>,
    pub address: String,
    pub port: u16,
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
    pub malloc_stats_max_len: usize,
}
```

**File:** config/src/config/admin_service_config.rs (L38-38)
```rust
    // TODO(grao): Add SSL support if necessary.
```

**File:** config/src/config/admin_service_config.rs (L45-45)
```rust
            address: "0.0.0.0".to_string(),
```

**File:** config/src/config/admin_service_config.rs (L67-77)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
```

**File:** config/src/config/admin_service_config.rs (L93-101)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L36-44)
```rust
pub fn handle_malloc_stats_request(max_len: usize) -> hyper::Result<Response<Body>> {
    match get_jemalloc_stats_string(max_len) {
        Ok(stats) => Ok(reply_with(Vec::new(), Body::from(stats))),
        Err(e) => Ok(reply_with_status(
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to get malloc stats: {e}"),
        )),
    }
}
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L65-76)
```rust
pub fn handle_dump_profile_request() -> hyper::Result<Response<Body>> {
    match dump_heap_profile() {
        Ok(path) => Ok(reply_with(
            Vec::new(),
            Body::from(format!("Successfully dumped heap profile to {path}")),
        )),
        Err(e) => Ok(reply_with_status(
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to dump heap profile: {e}"),
        )),
    }
}
```

**File:** api/src/runtime.rs (L191-210)
```rust
    let listener = match (&config.api.tls_cert_path, &config.api.tls_key_path) {
        (Some(tls_cert_path), Some(tls_key_path)) => {
            info!("Using TLS for API");
            let cert = std::fs::read_to_string(tls_cert_path).context(format!(
                "Failed to read TLS cert from path: {}",
                tls_cert_path
            ))?;
            let key = std::fs::read_to_string(tls_key_path).context(format!(
                "Failed to read TLS key from path: {}",
                tls_key_path
            ))?;
            let rustls_certificate = RustlsCertificate::new().cert(cert).key(key);
            let rustls_config = RustlsConfig::new().fallback(rustls_certificate);
            TcpListener::bind(address).rustls(rustls_config).boxed()
        },
        _ => {
            info!("Not using TLS for API");
            TcpListener::bind(address).boxed()
        },
    };
```
