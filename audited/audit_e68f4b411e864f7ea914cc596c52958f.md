# Audit Report

## Title
State KV Shard Pruner Progress Corruption via Backward Version Movement During Initialization

## Summary
The `StateKvShardPruner::new()` function contains a critical flaw in its catch-up logic that allows shard pruning progress to move backwards when a shard's local progress exceeds the metadata progress. This occurs due to missing validation before calling `prune()`, which unconditionally overwrites the shard's progress with the target version regardless of whether it's lower than the current progress.

## Finding Description

The vulnerability exists in the initialization flow of `StateKvShardPruner` where it compares and synchronizes progress values. [1](#0-0) 

When `StateKvShardPruner::new()` is called with a `metadata_progress` parameter, it retrieves the shard's existing progress using `get_or_initialize_subpruner_progress()`. [2](#0-1) 

This function returns the existing shard progress without any validation against `metadata_progress`. If the shard's progress is higher than `metadata_progress` (e.g., shard progress = 300, metadata_progress = 200), the code proceeds to call `myself.prune(300, 200)`.

In the `prune()` function, the logic seeks to `current_progress` and iterates until `stale_since_version > target_version`. [3](#0-2) 

When `current_progress > target_version`:
1. The iterator seeks to version 300
2. All entries at or above version 300 have `stale_since_version >= 300`
3. Since `300 > 200`, the condition `index.stale_since_version > target_version` is immediately true
4. The loop breaks without deleting any entries
5. **Critical flaw**: The code unconditionally writes `target_version` (200) as the new progress at lines 66-69, moving it backwards from 300 to 200

This creates a state inconsistency where the actual pruned state (deleted up to version 300) no longer matches the progress indicator (200).

**Trigger Scenarios:**
1. **Database restore mismatch**: Metadata DB restored from older backup while shard DBs remain current
2. **Partial database corruption**: Metadata progress value corrupted to lower value
3. **Write ordering issues**: If shard writes complete but metadata writes are lost during crash

**Regarding Version::MAX**: Since `Version` is defined as `u64`, [4](#0-3)  negative versions are impossible. However, if `metadata_progress` were set to `u64::MAX`, the pruning loop would never break (since no value can be > u64::MAX), potentially causing excessive pruning.

## Impact Explanation

This vulnerability causes **Medium Severity** state inconsistencies:

1. **Storage metadata corruption**: Progress indicators no longer reflect actual pruning state
2. **Future operation failures**: Subsequent pruning attempts may fail or behave incorrectly when operating on inconsistent metadata
3. **Database integrity violations**: The pruning system's invariant (progress â‰¤ actual pruned version) is broken
4. **Potential cascading failures**: Other components relying on pruner progress for state management may malfunction

While this doesn't directly cause consensus violations or fund loss, it corrupts critical storage subsystem metadata that could lead to node malfunction requiring manual intervention. Per the bug bounty criteria, this qualifies as "State inconsistencies requiring intervention" (Medium Severity, up to $10,000).

## Likelihood Explanation

**Likelihood: Low to Medium**

This vulnerability requires specific conditions to trigger:
- Database-level inconsistencies between metadata and shard databases
- Operational errors during backup/restore procedures
- Partial failures during pruning operations with inconsistent persistence

However, these scenarios can realistically occur in production environments:
- Hardware failures causing partial database corruption
- Operator errors during disaster recovery
- Bugs in database write synchronization

Once triggered, the vulnerability **deterministically** corrupts the pruning state with 100% certainty due to the missing validation logic.

## Recommendation

Add validation in `StateKvShardPruner::new()` to prevent backward progress movement:

```rust
pub(in crate::pruner) fn new(
    shard_id: usize,
    db_shard: Arc<DB>,
    metadata_progress: Version,
) -> Result<Self> {
    let progress = get_or_initialize_subpruner_progress(
        &db_shard,
        &DbMetadataKey::StateKvShardPrunerProgress(shard_id),
        metadata_progress,
    )?;
    
    // VALIDATION: Only prune if metadata_progress is ahead
    let catch_up_target = std::cmp::max(progress, metadata_progress);
    
    let myself = Self { shard_id, db_shard };
    
    if catch_up_target > progress {
        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            catch_up_target = catch_up_target,
            "Catching up state kv shard {shard_id}."
        );
        myself.prune(progress, catch_up_target)?;
    } else {
        warn!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Shard {shard_id} progress ahead of metadata, skipping catch-up to prevent backward movement."
        );
    }
    
    Ok(myself)
}
```

Additionally, add a defensive check in `prune()`:

```rust
pub(in crate::pruner) fn prune(
    &self,
    current_progress: Version,
    target_version: Version,
) -> Result<()> {
    // Defensive check: prevent backward progress movement
    if target_version < current_progress {
        warn!(
            shard_id = self.shard_id,
            current_progress = current_progress,
            target_version = target_version,
            "Refusing to prune backward. This indicates a consistency issue."
        );
        return Ok(());
    }
    
    // ... existing pruning logic ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_schemadb::DB;
    use tempfile::TempDir;

    #[test]
    fn test_backward_progress_movement_vulnerability() {
        // Setup: Create temporary shard database
        let tmpdir = TempDir::new().unwrap();
        let db_shard = Arc::new(DB::open(
            tmpdir.path(),
            "test_shard",
            vec![StateValueByKeyHashSchema::column_descriptor(),
                 StaleStateValueIndexByKeyHashSchema::column_descriptor(),
                 DbMetadataSchema::column_descriptor()]
        ).unwrap());
        
        // Simulate existing shard with progress=300
        db_shard.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvShardPrunerProgress(0),
            &DbMetadataValue::Version(300)
        ).unwrap();
        
        // Initialize with metadata_progress=200 (lower than shard progress)
        let pruner = StateKvShardPruner::new(0, db_shard.clone(), 200).unwrap();
        
        // Verify vulnerability: progress moved backward from 300 to 200
        let actual_progress = db_shard
            .get::<DbMetadataSchema>(&DbMetadataKey::StateKvShardPrunerProgress(0))
            .unwrap()
            .unwrap()
            .expect_version();
        
        assert_eq!(actual_progress, 200, 
            "VULNERABILITY CONFIRMED: Progress moved backward from 300 to 200");
        
        // Expected: progress should remain at 300 (or at least not decrease)
        // Actual: progress is now 200 (corrupted state)
    }
}
```

## Notes

**Regarding negative versions**: Since `Version` is a type alias for `u64` (unsigned 64-bit integer), negative versions are mathematically impossible and therefore cannot cause issues. The type system prevents this scenario entirely.

**Regarding Version::MAX**: While theoretically `u64::MAX` could be passed as `metadata_progress`, this would require the blockchain to process 18+ quintillion transactions, which is unrealistic. However, if database corruption set this value, it would cause the pruning loop to never terminate (since no `stale_since_version` can exceed `u64::MAX`), potentially deleting all entries inappropriately.

The core vulnerability is the **lack of validation when shard progress > metadata progress**, allowing deterministic state corruption under specific database inconsistency conditions.

### Citations

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L25-45)
```rust
    pub(in crate::pruner) fn new(
        shard_id: usize,
        db_shard: Arc<DB>,
        metadata_progress: Version,
    ) -> Result<Self> {
        let progress = get_or_initialize_subpruner_progress(
            &db_shard,
            &DbMetadataKey::StateKvShardPrunerProgress(shard_id),
            metadata_progress,
        )?;
        let myself = Self { shard_id, db_shard };

        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up state kv shard {shard_id}."
        );
        myself.prune(progress, metadata_progress)?;

        Ok(myself)
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L47-72)
```rust
    pub(in crate::pruner) fn prune(
        &self,
        current_progress: Version,
        target_version: Version,
    ) -> Result<()> {
        let mut batch = SchemaBatch::new();

        let mut iter = self
            .db_shard
            .iter::<StaleStateValueIndexByKeyHashSchema>()?;
        iter.seek(&current_progress)?;
        for item in iter {
            let (index, _) = item?;
            if index.stale_since_version > target_version {
                break;
            }
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(index.state_key_hash, index.version))?;
        }
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvShardPrunerProgress(self.shard_id),
            &DbMetadataValue::Version(target_version),
        )?;

        self.db_shard.write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L44-60)
```rust
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    Ok(
        if let Some(v) = sub_db.get::<DbMetadataSchema>(progress_key)? {
            v.expect_version()
        } else {
            sub_db.put::<DbMetadataSchema>(
                progress_key,
                &DbMetadataValue::Version(metadata_progress),
            )?;
            metadata_progress
        },
    )
}
```

**File:** types/src/transaction/mod.rs (L98-98)
```rust
pub type Version = u64; // Height - also used for MVCC in StateDB
```
