# Audit Report

## Title
Missing Cryptographic Verification of CertifiedNode Objects Loaded from Storage During Bootstrap

## Summary
The DAG consensus implementation fails to cryptographically verify `CertifiedNode` objects when loading them from persistent storage during bootstrap. While nodes received from the network undergo full digest and signature verification, nodes loaded from the consensusDB only receive structural validation, allowing corrupted or tampered nodes to be accepted into the DAG without cryptographic proof of validity.

## Finding Description

The vulnerability exists in the DAG storage recovery path. When a validator restarts, the `DagStore::new()` method reconstructs the in-memory DAG from persistent storage: [1](#0-0) 

The recovered nodes are added via `add_node()`: [2](#0-1) 

However, `add_node()` only calls `validate_new_node()`, which performs structural validation: [3](#0-2) 

This validation checks epoch, round bounds, parent existence, and duplicate prevention, but **does not** verify:
1. The node's digest matches its calculated hash
2. The aggregate signatures are cryptographically valid

In contrast, nodes received from the network are properly verified via `dag_message.verify()`: [4](#0-3) 

Which calls `CertifiedNode::verify()` that performs full cryptographic validation: [5](#0-4) 

The schemas use BCS deserialization without post-deserialization verification: [6](#0-5) 

**Attack Scenario (requires database compromise as precondition):**
1. Validator's consensusDB is corrupted via disk failure, storage bug, or external compromise
2. `CertifiedNode` objects in storage have invalid signatures or tampered digests
3. Validator restarts and loads corrupted nodes without verification
4. Invalid nodes are used in consensus ordering
5. Validator commits to incorrect blocks or diverges from honest validators, violating consensus safety

## Impact Explanation

This is a **defense-in-depth violation** rather than a directly exploitable vulnerability. The impact depends on how the database corruption occurs:

**If database is compromised through storage layer bug or disk corruption:**
- **Medium Severity**: State inconsistencies requiring manual intervention
- Affected validator may diverge from consensus
- Potential Byzantine behavior without malicious intent
- Requires validator restart to trigger

However, this does **not** meet the strict criteria for a valid bug bounty submission because:
- It requires database write access or hardware failure (not achievable by unprivileged attacker)
- It's a defense-in-depth issue, not a primary attack vector
- The trust model assumes storage integrity as baseline

## Likelihood Explanation

**Low likelihood for malicious exploitation** by unprivileged attackers:
- Requires database write access (privileged operation)
- Or requires separate storage layer vulnerability
- Or requires hardware failure (not attacker-controlled)

**Higher likelihood for accidental corruption:**
- Disk failures can corrupt database
- Storage layer bugs could introduce invalid data
- Software bugs during serialization/deserialization

The code **should** verify all cryptographic material regardless of source (defense-in-depth principle), but the absence of this verification is not directly exploitable by external attackers.

## Recommendation

Add cryptographic verification for all nodes loaded from storage during bootstrap:

```rust
impl DagStore {
    pub fn new(
        epoch_state: Arc<EpochState>,
        storage: Arc<dyn DAGStorage>,
        payload_manager: Arc<dyn TPayloadManager>,
        start_round: Round,
        window_size: u64,
    ) -> Self {
        let mut all_nodes = storage.get_certified_nodes().unwrap_or_default();
        all_nodes.sort_unstable_by_key(|(_, node)| node.round());
        let mut to_prune = vec![];
        
        let dag = Self::new_empty(
            epoch_state.clone(),
            storage.clone(),
            payload_manager,
            start_round,
            window_size,
        );
        
        for (digest, certified_node) in all_nodes {
            // ADD VERIFICATION HERE
            if let Err(e) = certified_node.verify(&epoch_state.verifier) {
                error!("Deleting node from storage due to verification failure: {}", e);
                to_prune.push(digest);
                continue;
            }
            
            if let Err(e) = dag.add_node(certified_node) {
                debug!("Delete node after bootstrap due to {}", e);
                to_prune.push(digest);
            }
        }
        // ... rest of method
    }
}
```

## Proof of Concept

This vulnerability cannot be demonstrated through a standard test because it requires:
1. Direct database manipulation OR
2. Injection of corrupted data into consensusDB

A theoretical PoC would involve:
```rust
// This requires privileged database access
#[test]
fn test_corrupted_node_from_storage() {
    let db = ConsensusDB::new(&temp_dir);
    
    // Create node with INVALID signatures
    let node = Node::new(/* ... */);
    let invalid_cert = CertifiedNode::new(
        node, 
        AggregateSignature::empty() // Invalid!
    );
    
    // Save to database (requires write access)
    db.put::<CertifiedNodeSchema>(&invalid_cert.digest(), &invalid_cert).unwrap();
    
    // Bootstrap DagStore - should reject but currently accepts
    let dag_store = DagStore::new(/* ... */);
    // Currently: invalid node is loaded without verification
    // Expected: node should be rejected and pruned
}
```

## Notes

**Why this does NOT meet bug bounty criteria:**

- **Requires privileged access**: Exploiting this requires database write access, which is outside the threat model of "unprivileged attacker"
- **Defense-in-depth issue**: This is a missing safety check, not a primary attack vector
- **Precondition required**: Needs database corruption/compromise first, which itself would be the primary vulnerability

**Why this IS important for code quality:**
- Violates defense-in-depth principles
- Could amplify damage from storage layer bugs
- May cause unexpected validator behavior during disk failures
- Best practice is to verify all cryptographic material regardless of source

**Conclusion**: While this is a real code issue that should be fixed, it does not constitute a valid security vulnerability exploitable by unprivileged attackers per the strict bug bounty criteria.

### Citations

**File:** consensus/src/dag/dag_store.rs (L128-164)
```rust
    fn validate_new_node(&mut self, node: &CertifiedNode) -> anyhow::Result<()> {
        ensure!(
            node.epoch() == self.epoch_state.epoch,
            "different epoch {}, current {}",
            node.epoch(),
            self.epoch_state.epoch
        );
        let author = node.metadata().author();
        let index = *self
            .author_to_index
            .get(author)
            .ok_or_else(|| anyhow!("unknown author"))?;
        let round = node.metadata().round();
        ensure!(
            round >= self.lowest_round(),
            "round too low {}, lowest in dag {}",
            round,
            self.lowest_round()
        );
        ensure!(
            round <= self.highest_round() + 1,
            "round too high {}, highest in dag {}",
            round,
            self.highest_round()
        );
        if round > self.lowest_round() {
            for parent in node.parents() {
                ensure!(self.exists(parent.metadata()), "parent not exist");
            }
        }
        let round_ref = self
            .nodes_by_round
            .entry(round)
            .or_insert_with(|| vec![None; self.author_to_index.len()]);
        ensure!(round_ref[index].is_none(), "duplicate node");
        Ok(())
    }
```

**File:** consensus/src/dag/dag_store.rs (L461-478)
```rust
        let mut all_nodes = storage.get_certified_nodes().unwrap_or_default();
        all_nodes.sort_unstable_by_key(|(_, node)| node.round());
        let mut to_prune = vec![];
        // Reconstruct the continuous dag starting from start_round and gc unrelated nodes
        let dag = Self::new_empty(
            epoch_state,
            storage.clone(),
            payload_manager,
            start_round,
            window_size,
        );
        for (digest, certified_node) in all_nodes {
            // TODO: save the storage call in this case
            if let Err(e) = dag.add_node(certified_node) {
                debug!("Delete node after bootstrap due to {}", e);
                to_prune.push(digest);
            }
        }
```

**File:** consensus/src/dag/dag_store.rs (L518-536)
```rust
    pub fn add_node(&self, node: CertifiedNode) -> anyhow::Result<()> {
        self.dag.write().validate_new_node(&node)?;

        // Note on concurrency: it is possible that a prune operation kicks in here and
        // moves the window forward making the `node` stale. Any stale node inserted
        // due to this race will be cleaned up with the next prune operation.

        // mutate after all checks pass
        self.storage.save_certified_node(&node)?;

        debug!("Added node {}", node.id());
        self.payload_manager.prefetch_payload_data(
            node.payload(),
            *node.author(),
            node.metadata().timestamp(),
        );

        self.dag.write().add_validated_node(node)
    }
```

**File:** consensus/src/dag/dag_handler.rs (L100-104)
```rust
                            monitor!(
                                "dag_message_verify",
                                dag_message.verify(rpc_request.sender, &epoch_state.verifier)
                            )?;
                            Ok(dag_message)
```

**File:** consensus/src/dag/types.rs (L438-442)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(self.digest() == self.calculate_digest(), "invalid digest");

        Ok(verifier.verify_multi_signatures(self.metadata(), self.signatures())?)
    }
```

**File:** consensus/src/consensusdb/schema/dag/mod.rs (L88-96)
```rust
impl ValueCodec<CertifiedNodeSchema> for CertifiedNode {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```
