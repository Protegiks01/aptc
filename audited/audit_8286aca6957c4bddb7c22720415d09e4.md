# Audit Report

## Title
Permanent Validator DoS Due to Unrecoverable LastVote Deserialization Failure

## Summary
The consensus recovery system panics when deserializing corrupted LastVote data from ConsensusDB, causing permanent validator node failure with no automatic recovery mechanism. This breaks the fault-tolerance guarantees of the consensus protocol and requires manual database intervention to restore node operation.

## Finding Description

The vulnerability exists in the consensus recovery flow where LastVote data is deserialized during node startup. The critical code path is: [1](#0-0) 

This deserialization uses `.expect()` which panics if the BCS deserialization fails. The panic occurs during the `StorageWriteProxy::start()` method, which is called by `EpochManager` during consensus initialization: [2](#0-1) 

The panic happens **before** the error handling logic that would allow fallback to `PartialRecoveryData`: [3](#0-2) 

**How the vulnerability breaks consensus guarantees:**

1. LastVote is stored in ConsensusDB using BCS serialization: [4](#0-3) 

2. The LastVote schema stores raw bytes: [5](#0-4) 

3. If these bytes become corrupted (disk corruption, hardware failure, schema mismatch from version upgrades), deserialization will fail and the node will panic on every startup attempt.

4. There is no automatic recovery mechanism. The only cleanup path exists **after** successful recovery: [6](#0-5) 

**Attack scenarios:**
- Disk corruption or bit flips in storage hardware
- Storage backend failures returning corrupted data
- Schema evolution bugs between software versions
- Manual database manipulation by operator
- File system corruption during power loss

## Impact Explanation

**Severity: HIGH** (per Aptos bug bounty: "Validator node slowdowns" and "Significant protocol violations")

This vulnerability causes:

1. **Permanent validator node DoS**: The validator cannot start and cannot participate in consensus. Every restart attempt will panic at the same point.

2. **Reduced network decentralization**: Each affected validator reduces the total number of active honest validators, decreasing network security margins.

3. **Liveness degradation**: If multiple validators are affected simultaneously (e.g., due to correlated storage failures or a bug in a software upgrade), the network could lose liveness if the number of affected validators exceeds the Byzantine fault tolerance threshold.

4. **Manual recovery required**: Operators must manually delete the entire ConsensusDB or use low-level RocksDB tools to delete the corrupted entry, which risks data loss and requires specialized knowledge.

5. **Unreachable fallback mechanism**: The code has a `PartialRecoveryData` fallback designed for recovery scenarios, but it is unreachable when deserialization panics.

While the LastVote in ConsensusDB is primarily used for liveness (idempotent voting), the inability to start affects availability which is a critical property of consensus systems.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This issue is likely to occur because:

1. **Disk corruption is common**: Storage hardware failures, power losses, and file system corruption are routine operational issues in production environments.

2. **No validation before deserialization**: The code assumes that if bytes exist in the database, they will always deserialize successfully, which is a dangerous assumption.

3. **Schema evolution risks**: Software upgrades may change the `Vote` struct definition, potentially causing deserialization failures if old data remains: [7](#0-6) 

4. **No defensive error handling**: Unlike other parts of the codebase that gracefully handle deserialization failures, this critical path uses `.expect()` which crashes the process.

5. **Affects all validators**: Every validator node uses ConsensusDB and is susceptible to this issue.

## Recommendation

Implement graceful error handling for LastVote deserialization with automatic recovery:

```rust
let last_vote = raw_data
    .0
    .and_then(|bytes| {
        match bcs::from_bytes::<Vote>(&bytes[..]) {
            Ok(vote) => Some(vote),
            Err(e) => {
                error!(
                    error = ?e,
                    "Failed to deserialize last vote from storage, deleting corrupted entry"
                );
                // Attempt to delete the corrupted entry
                if let Err(delete_err) = self.db.delete_last_vote_msg() {
                    error!(
                        error = ?delete_err,
                        "Failed to delete corrupted last vote"
                    );
                }
                None
            }
        }
    });
```

Additional recommendations:

1. **Add checksums**: Store a checksum with LastVote data to detect corruption before deserialization.

2. **Implement version markers**: Include schema version information to handle upgrades gracefully.

3. **Add monitoring**: Alert operators when deserialization failures occur so they can investigate storage issues.

4. **Document recovery procedures**: Provide clear operator documentation for manual recovery scenarios.

5. **Apply similar fixes**: Review other uses of `.expect()` in the consensus recovery path for similar issues: [8](#0-7) 

## Proof of Concept

To reproduce this vulnerability:

1. **Setup a validator node** with ConsensusDB containing a valid LastVote entry.

2. **Corrupt the LastVote data** using RocksDB tools or direct file manipulation:
   ```bash
   # Stop the validator
   # Corrupt the ConsensusDB single_entry column family
   # The LastVote key is 0x00 (SingleEntryKey::LastVote = 0)
   ```

3. **Attempt to restart the validator**:
   ```bash
   aptos-node --config validator.yaml
   ```

4. **Observe the panic**:
   ```
   thread 'main' panicked at 'unable to deserialize last vote', consensus/src/persistent_liveness_storage.rs:528
   ```

5. **Verify no recovery**: Every restart attempt will panic at the same point, demonstrating permanent DoS.

**Rust test case**:
```rust
#[test]
fn test_corrupted_last_vote_recovery() {
    let storage = create_test_storage();
    
    // Save valid vote
    let vote = create_test_vote();
    storage.save_vote(&vote).unwrap();
    
    // Corrupt the vote bytes in the database
    corrupt_last_vote_in_db(&storage);
    
    // Attempting to start should gracefully handle corruption
    // Currently this panics - after fix it should return PartialRecoveryData
    let result = storage.start(false, None);
    
    match result {
        LivenessStorageData::PartialRecoveryData(_) => {
            // Expected behavior after fix
        }
        _ => panic!("Should have fallen back to partial recovery")
    }
}
```

## Notes

The vulnerability affects the ConsensusDB LastVote entry specifically. Note that SafetyRules maintains a separate SafetyData storage (via `PersistentSafetyStorage`) which also contains `last_vote`: [9](#0-8) 

This SafetyRules storage uses a different backend (Vault, OnDisk, etc.) and is managed separately: [10](#0-9) 

While both systems store vote information, the ConsensusDB corruption affects node startup and liveness, while SafetyRules storage corruption would affect safety guarantees. This report specifically addresses the ConsensusDB deserialization panic which prevents any recovery mechanism from executing.

### Citations

**File:** consensus/src/persistent_liveness_storage.rs (L507-509)
```rust
    fn save_vote(&self, vote: &Vote) -> Result<()> {
        Ok(self.db.save_vote(bcs::to_bytes(vote)?)?)
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L526-528)
```rust
        let last_vote = raw_data
            .0
            .map(|bytes| bcs::from_bytes(&bytes[..]).expect("unable to deserialize last vote"));
```

**File:** consensus/src/persistent_liveness_storage.rs (L530-532)
```rust
        let highest_2chain_timeout_cert = raw_data.1.map(|b| {
            bcs::from_bytes(&b).expect("unable to deserialize highest 2-chain timeout cert")
        });
```

**File:** consensus/src/persistent_liveness_storage.rs (L559-595)
```rust
        match RecoveryData::new(
            last_vote,
            ledger_recovery_data.clone(),
            blocks,
            accumulator_summary.into(),
            quorum_certs,
            highest_2chain_timeout_cert,
            order_vote_enabled,
            window_size,
        ) {
            Ok(mut initial_data) => {
                (self as &dyn PersistentLivenessStorage)
                    .prune_tree(initial_data.take_blocks_to_prune())
                    .expect("unable to prune dangling blocks during restart");
                if initial_data.last_vote.is_none() {
                    self.db
                        .delete_last_vote_msg()
                        .expect("unable to cleanup last vote");
                }
                if initial_data.highest_2chain_timeout_certificate.is_none() {
                    self.db
                        .delete_highest_2chain_timeout_certificate()
                        .expect("unable to cleanup highest 2-chain timeout cert");
                }
                info!(
                    "Starting up the consensus state machine with recovery data - [last_vote {}], [highest timeout certificate: {}]",
                    initial_data.last_vote.as_ref().map_or_else(|| "None".to_string(), |v| v.to_string()),
                    initial_data.highest_2chain_timeout_certificate().as_ref().map_or_else(|| "None".to_string(), |v| v.to_string()),
                );

                LivenessStorageData::FullRecoveryData(initial_data)
            },
            Err(e) => {
                error!(error = ?e, "Failed to construct recovery data");
                LivenessStorageData::PartialRecoveryData(ledger_recovery_data)
            },
        }
```

**File:** consensus/src/epoch_manager.rs (L1383-1417)
```rust
        match self.storage.start(
            consensus_config.order_vote_enabled(),
            consensus_config.window_size(),
        ) {
            LivenessStorageData::FullRecoveryData(initial_data) => {
                self.recovery_mode = false;
                self.start_round_manager(
                    consensus_key,
                    initial_data,
                    epoch_state,
                    consensus_config,
                    execution_config,
                    onchain_randomness_config,
                    jwk_consensus_config,
                    Arc::new(network_sender),
                    payload_client,
                    payload_manager,
                    rand_config,
                    fast_rand_config,
                    rand_msg_rx,
                    secret_share_msg_rx,
                )
                .await
            },
            LivenessStorageData::PartialRecoveryData(ledger_data) => {
                self.recovery_mode = true;
                self.start_recovery_manager(
                    ledger_data,
                    consensus_config,
                    epoch_state,
                    Arc::new(network_sender),
                )
                .await
            },
        }
```

**File:** consensus/src/consensusdb/schema/single_entry/mod.rs (L36-43)
```rust
#[derive(Debug, Eq, PartialEq, FromPrimitive, ToPrimitive)]
#[repr(u8)]
pub enum SingleEntryKey {
    // Used to store the last vote
    LastVote = 0,
    // Two chain timeout cert
    Highest2ChainTimeoutCert = 1,
}
```

**File:** consensus/consensus-types/src/vote.rs (L22-34)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct Vote {
    /// The data of the vote.
    vote_data: VoteData,
    /// The identity of the voter.
    author: Author,
    /// LedgerInfo of a block that is going to be committed in case this vote gathers QC.
    ledger_info: LedgerInfo,
    /// Signature on the LedgerInfo along with a status on whether the signature is verified.
    signature: SignatureWithStatus,
    /// The 2-chain timeout and corresponding signature.
    two_chain_timeout: Option<(TwoChainTimeout, bls12381::Signature)>,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```
