# Audit Report

## Title
Missing Authorization in Consensus Observer Publisher Subscription Handler

## Summary
The `process_network_message()` function in `ConsensusPublisher` accepts subscription requests from any network peer without verifying authorization, allowing authenticated peers to subscribe to sensitive real-time consensus updates regardless of whether they should have access to this information.

## Finding Description

The consensus observer publisher system is designed to broadcast consensus updates (ordered blocks, commit decisions, and transaction payloads) to subscribed observers. However, the subscription acceptance logic lacks authorization controls.

In `process_network_message()`, when a `ConsensusObserverRequest::Subscribe` message is received, the function directly adds the requesting peer to the active subscribers set without any validation: [1](#0-0) 

The function performs no checks to verify:
1. Whether the peer has the appropriate role (e.g., is it a validator vs. unknown peer)
2. Whether the peer is on an allowlist of authorized observers
3. Whether the peer should receive sensitive consensus information

Once subscribed, peers receive all consensus updates via `publish_message()`, which broadcasts to all active subscribers: [2](#0-1) 

The published messages contain highly sensitive information including:
- **OrderedBlock**: Contains `PipelinedBlock` structures and validator signatures via `LedgerInfoWithSignatures`
- **CommitDecision**: Contains commit proofs with quorum signatures
- **BlockPayload**: Contains actual `SignedTransaction` data and `ProofOfStore` before public commitment
- **OrderedBlockWithWindow**: Contains block dependencies and execution pool information [3](#0-2) 

While the network layer provides **authentication** (verifying peer identity via Noise protocol handshake), it does not provide **authorization** (determining what authenticated peers can access). The only filtering performed is protocol support verification: [4](#0-3) 

This means:
- On validator networks with mutual authentication: Any validator in the trusted set can subscribe to any other validator's consensus updates
- On VFN networks using MaybeMutual authentication: Any VFN that can connect can subscribe
- There is no role-based access control preventing, for example, a regular VFN from subscribing to validator consensus data that should be restricted

## Impact Explanation

This vulnerability enables **unauthorized information disclosure** of pre-commitment consensus data. The severity assessment:

**Medium Severity** (up to $10,000 per Aptos Bug Bounty):
- Enables information leakage of transaction ordering before public commitment
- Allows unauthorized monitoring of validator voting patterns and consensus state
- Could facilitate MEV (Maximal Extractable Value) attacks through advanced knowledge of block contents
- Violates principle of least privilege - peers receive data they don't need

The impact does not reach High/Critical severity because:
- It does not directly cause loss of funds
- It does not violate consensus safety (blocks are still valid and properly signed)
- It does not cause network partition or liveness failures
- Authenticated peers are already somewhat trusted (in the peer set)

However, it represents a **significant protocol violation** where access control assumptions are not enforced, potentially enabling sophisticated economic attacks based on information asymmetry.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploitable because:

1. **Low Barrier to Entry**: Any peer that can establish a network connection can attempt subscription
2. **No Defense in Depth**: There are no compensating controls or authorization layers
3. **Operational Reality**: VFNs are operated by various entities, some of which may be adversarial
4. **Simple Attack**: The exploit requires only sending a standard `Subscribe` RPC request
5. **Production Deployment**: Consensus observer/publisher is enabled by default on validators and VFNs in production

Attack prerequisites:
- Ability to connect to a node with publisher enabled (validator or VFN)
- For validator networks: being in the trusted validator set (already authenticated)
- For VFN networks: being able to establish a connection (lower bar)

The configuration shows publishers are enabled on validators and VFNs: [5](#0-4) [6](#0-5) 

## Recommendation

Implement role-based authorization in `process_network_message()` to validate subscription requests:

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    // Unpack the network message
    let (peer_network_id, message, response_sender) = network_message.into_parts();

    // Update the RPC request counter
    metrics::increment_counter(
        &metrics::PUBLISHER_RECEIVED_REQUESTS,
        message.get_label(),
        &peer_network_id,
    );

    // Handle the message
    match message {
        ConsensusObserverRequest::Subscribe => {
            // ADDED: Verify peer is authorized to subscribe
            if !self.is_peer_authorized_to_subscribe(&peer_network_id) {
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Rejected unauthorized subscription request from peer: {:?}",
                        peer_network_id
                    )));
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck); // Reject
                return;
            }

            // Add the peer to the set of active subscribers
            self.add_active_subscriber(peer_network_id);
            // ... rest of code
        },
        // ... rest of match
    }
}

// ADDED: Authorization check method
fn is_peer_authorized_to_subscribe(&self, peer_network_id: &PeerNetworkId) -> bool {
    // Get peer metadata to check role
    let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
    match peers_and_metadata.get_metadata_for_peer(*peer_network_id) {
        Some(peer_metadata) => {
            // Only allow validators and authorized VFNs
            match peer_metadata.get_connection_metadata().role {
                PeerRole::Validator | PeerRole::ValidatorFullNode => true,
                PeerRole::PreferredUpstream | PeerRole::Upstream | 
                PeerRole::Downstream | PeerRole::Unknown => {
                    // Could also check against an allowlist here
                    false
                }
            }
        },
        None => false, // Reject if no metadata available
    }
}
```

Additionally, consider:
1. Adding a configuration allowlist of authorized subscriber peer IDs
2. Implementing per-peer subscription rate limiting
3. Adding audit logging for all subscription attempts
4. Considering whether certain consensus data should have different authorization levels

## Proof of Concept

This Rust test demonstrates the vulnerability by showing that any peer can subscribe without authorization checks:

```rust
#[tokio::test]
async fn test_unauthorized_subscription_accepted() {
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_network::application::storage::PeersAndMetadata;
    use aptos_network::protocols::wire::handshake::v1::ProtocolIdSet;
    use aptos_network::transport::ConnectionMetadata;
    use aptos_types::PeerId;
    use aptos_config::config::PeerRole;
    
    // Create a network client
    let network_id = NetworkId::Public;
    let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    let network_client = NetworkClient::new(
        vec![ProtocolId::ConsensusObserver],
        vec![ProtocolId::ConsensusObserverRpc],
        hashmap!{},
        peers_and_metadata.clone()
    );
    let consensus_observer_client = Arc::new(ConsensusObserverClient::new(network_client));
    
    // Create a consensus publisher
    let (consensus_publisher, _) = ConsensusPublisher::new(
        ConsensusObserverConfig::default(),
        consensus_observer_client,
    );
    
    // Create a peer with UNKNOWN role (unauthorized)
    let unauthorized_peer = PeerNetworkId::new(network_id, PeerId::random());
    let mut connection_metadata = ConnectionMetadata::mock(unauthorized_peer.peer_id());
    connection_metadata.role = PeerRole::Unknown; // Explicitly unauthorized
    connection_metadata.application_protocols = ProtocolIdSet::from_iter(vec![
        ProtocolId::ConsensusObserver,
        ProtocolId::ConsensusObserverRpc,
    ]);
    
    peers_and_metadata
        .insert_connection_metadata(unauthorized_peer, connection_metadata)
        .unwrap();
    
    // VULNERABILITY: Subscribe the unauthorized peer
    let network_message = ConsensusPublisherNetworkMessage::new(
        unauthorized_peer,
        ConsensusObserverRequest::Subscribe,
        ResponseSender::new_for_test(),
    );
    
    consensus_publisher.process_network_message(network_message);
    
    // PROOF: Verify the unauthorized peer was added to active subscribers
    let active_subscribers = consensus_publisher.get_active_subscribers();
    assert!(active_subscribers.contains(&unauthorized_peer));
    // ^^^ This assertion passes, proving unauthorized peers can subscribe
    
    println!("VULNERABILITY CONFIRMED: Peer with role {:?} successfully subscribed without authorization check", PeerRole::Unknown);
}
```

## Notes

**Important Context:**

1. **Network Layer vs. Application Layer**: While the Noise protocol handshake provides peer **authentication** (verifying peer identity), this is separate from **authorization** (determining what authenticated peers can access). The vulnerability exists at the application layer.

2. **Trust Model Confusion**: The current implementation appears to assume "if a peer can connect, they can subscribe," which conflates authentication with authorization. Even on validator networks with mutual authentication, not all validators may need to subscribe to each other's consensus data.

3. **Information Sensitivity**: The published consensus data includes transactions before public commitment, validator voting patterns, and block ordering information that could enable:
   - Front-running transactions
   - MEV extraction
   - Network topology mapping
   - Validator behavior analysis

4. **Mitigation Exists at Network Layer**: On validator networks, mutual authentication does provide some protection by limiting connections to the trusted validator set. However, this is insufficient because:
   - A compromised but authenticated validator can still subscribe
   - VFN networks use less strict authentication
   - No fine-grained control over which authenticated peers should observe consensus

The vulnerability represents a violation of the **Access Control** invariant (#8 in the critical invariants list), where access to sensitive consensus information should be restricted based on need and authorization, not merely authentication.

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L180-193)
```rust
        match message {
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L129-147)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum ConsensusObserverDirectSend {
    OrderedBlock(OrderedBlock),
    CommitDecision(CommitDecision),
    BlockPayload(BlockPayload),
    OrderedBlockWithWindow(OrderedBlockWithWindow),
}

impl ConsensusObserverDirectSend {
    /// Returns a summary label for the direct send
    pub fn get_label(&self) -> &'static str {
        match self {
            ConsensusObserverDirectSend::OrderedBlock(_) => "ordered_block",
            ConsensusObserverDirectSend::CommitDecision(_) => "commit_decision",
            ConsensusObserverDirectSend::BlockPayload(_) => "block_payload",
            ConsensusObserverDirectSend::OrderedBlockWithWindow(_) => "ordered_block_with_window",
        }
    }
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L352-356)
```rust
/// Returns true iff the peer metadata indicates support for consensus observer
fn supports_consensus_observer(peer_metadata: &PeerMetadata) -> bool {
    peer_metadata.supports_protocol(ProtocolId::ConsensusObserver)
        && peer_metadata.supports_protocol(ProtocolId::ConsensusObserverRpc)
}
```

**File:** config/src/config/consensus_observer_config.rs (L12-14)
```rust
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L112-128)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
            },
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
