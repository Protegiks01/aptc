# Audit Report

## Title
Validator Crash Due to Leaf Node at Root During Non-Sharded to Sharded Database Migration

## Summary
The `unreachable!` macro at line 480 of `storage/jellyfish-merkle/src/lib.rs` assumes the root node is never a `Node::Leaf`, but this assumption can be violated when reading old non-sharded database versions that contained exactly 1 state, causing validator crashes.

## Finding Description
The vulnerability exists in the `get_shard_persisted_versions()` function which is called during state commitment to determine the persisted version of each shard. [1](#0-0) 

The function reads the root node from storage and handles three cases via pattern matching:
1. `Node::Internal` - extracts child versions
2. `Node::Null` - handles empty trees  
3. `_` (catch-all) - triggers `unreachable!("Assume the db doesn't have exactly 1 state.")`

Before AIP-97 introduced sharding, the Jellyfish Merkle tree structure allowed leaf nodes at the root (depth 0) when the tree contained exactly 1 state. This is confirmed by the code that sets `start_num_of_nibbles = 0` for non-sharded mode versus `= 1` for sharded mode: [2](#0-1) 

In non-sharded mode, `MIN_LEAF_DEPTH` was effectively 0, allowing leaves at the root. In the current sharded mode, `MIN_LEAF_DEPTH = 1` prevents this: [3](#0-2) 

The function is called during the critical `merklize()` operation: [4](#0-3) 

**Attack Path:**
1. Validator has database containing old non-sharded versions with exactly 1 state (root is `Node::Leaf`)
2. Validator upgrades to sharded code without proper migration
3. During state commitment, `merklize()` calls `get_shard_persisted_versions(base_version)` where `base_version` points to old version
4. Function reads `Node::Leaf` at root
5. Pattern match hits catch-all `_` case
6. `unreachable!` panics, crashing the validator

The sharding requirement is enforced for mainnet/testnet: [5](#0-4) 

## Impact Explanation
**High Severity** - This causes validator node crashes, meeting the "Validator node slowdowns" and "API crashes" criteria for High severity ($50,000). When triggered, the validator immediately panics and cannot process blocks until the issue is resolved. This breaks the **liveness invariant** - validators must be able to process transactions without crashing on valid historical data.

## Likelihood Explanation
**Medium-Low** - This can occur during:
- Migration from pre-AIP-97 non-sharded databases
- Reading old checkpoints or syncing from old state snapshots
- Development/testing environments with minimal genesis states

However, proper migration procedures should prevent this. The configuration system warns operators about migration requirements, reducing likelihood in production.

## Recommendation
Replace the `unreachable!` with proper error handling:

```rust
Node::Null => (), // Possible in hot state since we start from a non-zero version.
Node::Leaf(_) => {
    // Handle legacy non-sharded database with single state at root
    // Treat as if all shards are empty - the single leaf is at the old root structure
    ()
},
_ => {
    return Err(AptosDbError::Other(format!(
        "Unexpected root node type at version {:?}", root_persisted_version
    )));
},
```

Additionally, implement database migration validation that checks for and converts any leaf nodes at the root before enabling sharded mode.

## Proof of Concept
```rust
// Reproduction requires:
// 1. Create database in non-sharded mode
// 2. Insert exactly 1 key-value pair at version 0
// 3. Enable sharding
// 4. Call get_shard_persisted_versions(Some(0))
// Expected: panic with "Assume the db doesn't have exactly 1 state."

#[test]
fn test_leaf_root_crash() {
    // Setup non-sharded DB
    let db = MockTreeStore::new(false); // non-sharded
    let tree = JellyfishMerkleTree::new(&db);
    
    // Insert single state at version 0
    let key = StateKey::raw(b"key");
    let value = StateValue::new_legacy(b"value".to_vec());
    tree.put_value_set_test(
        vec![(key.hash(), Some(&(value.hash(), key)))],
        0,
    ).unwrap();
    
    // Enable sharding and try to read old version
    db.enable_sharding();
    let result = tree.get_shard_persisted_versions(Some(0));
    // Panics with unreachable!
}
```

## Notes
- The vulnerability is specific to migration scenarios, not exploitable by external attackers through normal operations
- Proper migration procedures following the AIP-97 guide should prevent this issue
- The defensive assertion could be replaced with graceful error handling to improve robustness

### Citations

**File:** storage/jellyfish-merkle/src/lib.rs (L113-114)
```rust
// Assumes 16 shards here.
const MIN_LEAF_DEPTH: usize = 1;
```

**File:** storage/jellyfish-merkle/src/lib.rs (L461-486)
```rust
    pub fn get_shard_persisted_versions(
        &self,
        root_persisted_version: Option<Version>,
    ) -> Result<[Option<Version>; 16]> {
        let mut shard_persisted_versions = arr![None; 16];
        if let Some(root_persisted_version) = root_persisted_version {
            let root_node_key = NodeKey::new_empty_path(root_persisted_version);
            let root_node = self.reader.get_node_with_tag(&root_node_key, "commit")?;
            match root_node {
                Node::Internal(root_node) => {
                    for shard_id in 0..16 {
                        if let Some(Child { version, .. }) = root_node.child(Nibble::from(shard_id))
                        {
                            shard_persisted_versions[shard_id as usize] = Some(*version);
                        }
                    }
                },
                Node::Null => (), // Possible in hot state since we start from a non-zero version.
                _ => {
                    unreachable!("Assume the db doesn't have exactly 1 state.")
                },
            }
        }

        Ok(shard_persisted_versions)
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L768-775)
```rust
        // traverse all shards in a naive way
        let shards = 0..self.hack_num_real_shards();
        let start_num_of_nibbles = if self.enable_sharding { 1 } else { 0 };
        for shard_id in shards.rev() {
            let shard_db = self.state_merkle_db_shards[shard_id].clone();
            let mut shard_iter = shard_db.iter::<JellyfishMerkleNodeSchema>()?;
            // DB sharded only contain nodes with num_of_nibbles >= 1
            shard_iter.seek(&(version, start_num_of_nibbles)).unwrap();
```

**File:** storage/aptosdb/src/state_store/state_snapshot_committer.rs (L203-212)
```rust
    fn merklize(
        db: &StateMerkleDb,
        base_version: Option<Version>,
        version: Version,
        last_smt: &SparseMerkleTree,
        smt: &SparseMerkleTree,
        all_updates: [Vec<(HashValue, Option<(HashValue, StateKey)>)>; NUM_STATE_SHARDS],
        previous_epoch_ending_version: Option<Version>,
    ) -> Result<(StateMerkleBatch, usize)> {
        let shard_persisted_versions = db.get_shard_persisted_versions(base_version)?;
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
