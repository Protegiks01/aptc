# Audit Report

## Title
Config-State Desynchronization in Transaction Simulation Session Leads to Persistent State Corruption

## Summary
The `Session` struct in `aptos-transaction-simulation-session/src/session.rs` contains a critical state consistency bug where the `config` and `state_store` fields can become permanently desynchronized if one file save operation succeeds while the other fails, violating the atomicity guarantee for session state persistence.

## Finding Description

The vulnerability exists in the session persistence logic where state modifications and configuration updates are saved to disk using non-atomic sequential operations. [1](#0-0) 

In both `fund_account` and `execute_transaction` methods, the code follows this unsafe pattern:

1. **State modification in memory**: The `state_store` is modified first [2](#0-1) [3](#0-2) 

2. **Config counter increment**: The operation counter is incremented in memory [4](#0-3) [5](#0-4) 

3. **Sequential non-atomic saves**: Config and delta are saved to separate files sequentially [6](#0-5) [7](#0-6) 

The underlying `DeltaStateStore` has no rollback mechanism - once `states` is modified via `RwLock::write()`, the change is permanent: [8](#0-7) [9](#0-8) 

Both save operations use direct `std::fs::write` without atomic guarantees: [10](#0-9) [11](#0-10) 

**Critical desynchronization scenario**: If `config.save_to_file()` succeeds but `save_delta()` fails (due to disk full, I/O error, permission denied):
- `config.json` on disk: `ops = N+1` 
- `delta.json` on disk: contains state reflecting only `ops = N`
- Function returns error, but disk state is already inconsistent

When the session is reloaded, no validation checks this mismatch: [12](#0-11) 

The config and delta are loaded independently with no integrity verification, resulting in a session that believes it has performed N+1 operations while the actual state only reflects N operations.

## Impact Explanation

This vulnerability constitutes a **Medium severity** issue under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The impact includes:

1. **State Consistency Violation**: Breaks the fundamental invariant that `config.ops` must accurately represent the number of operations persisted in the delta file

2. **Silent Operation Loss**: Operations that executed in memory are lost from persistent state without clear indication to the user after session reload

3. **Simulation Reliability Compromise**: Transaction simulations used for pre-mainnet validation or governance proposal testing will operate on incorrect state, potentially leading to:
   - False validation of transactions that would fail on mainnet
   - Incorrect gas estimation
   - Misleading governance proposal simulation results

4. **Data Integrity Corruption**: The session directory contains numbered operation folders that no longer correspond to the actual state in the delta file

While this does not directly compromise mainnet consensus or validator operations, it undermines the reliability of the simulation tool that developers and governance participants rely on for critical decision-making.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability triggers when specific I/O failure conditions occur:

**Natural occurrence scenarios**:
- Disk space exhaustion during development
- Filesystem errors on developer machines
- Permission issues in CI/CD environments
- Network filesystem failures (NFS, cloud-mounted volumes)
- System crashes or power failures during write operations

**Attacker-induced scenarios**:
- An attacker with access to a developer's environment could deliberately:
  - Fill disk space to trigger the condition
  - Manipulate file permissions
  - Inject filesystem errors
  - Exploit race conditions in file operations

The sequential, non-atomic nature of the saves makes this issue relatively easy to trigger in resource-constrained environments or under adversarial conditions.

## Recommendation

Implement atomic state persistence using a two-phase commit pattern with temporary files and atomic rename operations:

```rust
pub fn fund_account(&mut self, account: AccountAddress, amount: u64) -> Result<()> {
    let (before, after) = self.state_store.fund_apt_fungible_store(account, amount)?;
    
    // Save summary
    let summary = Summary::FundFungible { account, amount, before, after };
    let summary_path = self.path.join(format!("[{}] fund (fungible)", self.config.ops)).join("summary.json");
    std::fs::create_dir_all(summary_path.parent().unwrap())?;
    std::fs::write(summary_path, serde_json::to_string_pretty(&summary)?)?;
    
    // Increment ops counter
    self.config.ops += 1;
    
    // ATOMIC SAVE PATTERN: Write to temp files first, then atomic rename
    let config_path = self.path.join("config.json");
    let config_temp = self.path.join("config.json.tmp");
    let delta_path = self.path.join("delta.json");
    let delta_temp = self.path.join("delta.json.tmp");
    
    // Write to temporary files
    let config_json = serde_json::to_string_pretty(&self.config)?;
    std::fs::write(&config_temp, config_json)?;
    
    let delta = self.state_store.delta();
    save_delta(&delta_temp, &delta)?;
    
    // Atomic rename both files (if one fails, neither is committed)
    std::fs::rename(&config_temp, &config_path)?;
    std::fs::rename(&delta_temp, &delta_path)?;
    
    Ok(())
}
```

Additionally, implement integrity validation in `Session::load()`:

```rust
pub fn load(session_path: impl AsRef<Path>) -> Result<Self> {
    let session_path = session_path.as_ref().to_path_buf();
    let config = Config::load_from_file(&session_path.join("config.json"))?;
    
    // Validate operation directories match config.ops
    let expected_ops = config.ops;
    let mut actual_ops = 0;
    for entry in std::fs::read_dir(&session_path)? {
        let entry = entry?;
        if entry.file_name().to_string_lossy().starts_with('[') {
            actual_ops += 1;
        }
    }
    
    if actual_ops != expected_ops {
        anyhow::bail!(
            "Session integrity check failed: config.ops = {}, but found {} operation directories",
            expected_ops, actual_ops
        );
    }
    
    // Load state and validate consistency
    let delta = load_delta(&session_path.join("delta.json"))?;
    let base = match &config.base { /* existing code */ };
    let state_store = DeltaStateStore::new_with_base_and_delta(base, delta);
    
    Ok(Self { config, path: session_path, state_store })
}
```

## Proof of Concept

```rust
#[test]
fn test_config_state_desync_on_partial_save_failure() -> Result<()> {
    use std::os::unix::fs::PermissionsExt;
    
    let temp_dir = tempfile::tempdir()?;
    let session_path = temp_dir.path();
    
    // Initialize session
    let mut session = Session::init(session_path)?;
    assert_eq!(session.config.ops, 0);
    
    // Fund an account successfully
    let account = AccountAddress::from_hex_literal("0x1")?;
    session.fund_account(account, 1000)?;
    assert_eq!(session.config.ops, 1);
    
    // Simulate partial failure: make delta.json read-only to cause save failure
    let delta_path = session_path.join("delta.json");
    let mut perms = std::fs::metadata(&delta_path)?.permissions();
    perms.set_mode(0o444); // Read-only
    std::fs::set_permissions(&delta_path, perms)?;
    
    // This should fail at delta save, but config might already be updated
    let result = session.fund_account(account, 2000);
    assert!(result.is_err());
    
    // Restore permissions
    let mut perms = std::fs::metadata(&delta_path)?.permissions();
    perms.set_mode(0o644);
    std::fs::set_permissions(&delta_path, perms)?;
    
    // Reload session - this will expose the desynchronization
    let reloaded = Session::load(session_path)?;
    
    // BUG: Config shows 2 operations but delta only has state for 1 operation
    // This assertion will fail, demonstrating the vulnerability
    let state_operations = reloaded.state_store.delta().len();
    assert_eq!(
        reloaded.config.ops as usize, 
        state_operations,
        "Config-state desynchronization detected: config.ops={} but delta has {} state changes",
        reloaded.config.ops,
        state_operations
    );
    
    Ok(())
}
```

## Notes

This vulnerability specifically affects the transaction simulation session persistence layer, which is a critical development and governance tool. While it does not directly compromise mainnet consensus, it undermines the reliability of pre-deployment validation processes. The lack of atomic persistence guarantees and validation checks violates the State Consistency invariant requiring atomic state transitions. The fix requires implementing standard database-style two-phase commit patterns and integrity validation on session load operations.

### Citations

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L103-107)
```rust
pub struct Session {
    config: Config,
    path: PathBuf,
    state_store: SessionStateStore,
}
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L200-233)
```rust
    pub fn load(session_path: impl AsRef<Path>) -> Result<Self> {
        let session_path = session_path.as_ref().to_path_buf();
        let config = Config::load_from_file(&session_path.join("config.json"))?;

        let base = match &config.base {
            BaseState::Empty => EitherStateView::Left(EmptyStateView),
            BaseState::Remote {
                node_url,
                network_version,
                api_key,
            } => {
                let mut builder = Client::builder(AptosBaseUrl::Custom(node_url.clone()));
                if let Some(api_key) = api_key {
                    builder = builder.api_key(api_key)?;
                }
                let client = builder.build();

                let debugger = DebuggerStateView::new(
                    Arc::new(RestDebuggerInterface::new(client)),
                    *network_version,
                );
                EitherStateView::Right(debugger)
            },
        };

        let delta = load_delta(&session_path.join("delta.json"))?;
        let state_store = DeltaStateStore::new_with_base_and_delta(base, delta);

        Ok(Self {
            config,
            path: session_path,
            state_store,
        })
    }
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L243-243)
```rust
        let (before, after) = self.state_store.fund_apt_fungible_store(account, amount)?;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L258-258)
```rust
        self.config.ops += 1;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L260-261)
```rust
        self.config.save_to_file(&self.path.join("config.json"))?;
        save_delta(&self.path.join("delta.json"), &self.state_store.delta())?;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L291-291)
```rust
        self.state_store.apply_write_set(txn_output.write_set())?;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L347-347)
```rust
        self.config.ops += 1;
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L348-349)
```rust
        self.config.save_to_file(&self.path.join("config.json"))?;
        save_delta(&self.path.join("delta.json"), &self.state_store.delta())?;
```

**File:** aptos-move/aptos-transaction-simulation/src/state_store.rs (L440-443)
```rust
pub struct DeltaStateStore<V> {
    base: V,
    states: RwLock<HashMap<StateKey, Option<StateValue>>>,
}
```

**File:** aptos-move/aptos-transaction-simulation/src/state_store.rs (L486-489)
```rust
    fn set_state_value(&self, state_key: StateKey, state_val: StateValue) -> Result<()> {
        self.states.write().insert(state_key, Some(state_val));
        Ok(())
    }
```

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L56-59)
```rust
    pub fn save_to_file(&self, path: &std::path::Path) -> Result<()> {
        let json = serde_json::to_string_pretty(self)?;
        std::fs::write(path, json)?;
        Ok(())
```

**File:** aptos-move/aptos-transaction-simulation-session/src/delta.rs (L28-30)
```rust
    let json = serde_json::to_string_pretty(&delta_str)?;
    std::fs::write(delta_path, json)?;

```
