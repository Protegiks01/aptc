# Audit Report

## Title
Production Panic Risk in Table Native Functions Due to Unsafe Assertion Usage

## Summary
The table native functions in `aptos-move/framework/table-natives/src/lib.rs` use standard Rust `assert!` and `assert_eq!` macros that cause panics in production builds. While these assertions should never trigger under normal operation due to bytecode verification, they violate defense-in-depth principles and could crash validator nodes if the bytecode verifier has bugs or if runtime inconsistencies occur.

## Finding Description

The table-natives module contains multiple assertions checking type argument counts and runtime argument counts: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

These use standard `assert!` macros which **panic in both debug and release builds**, unlike `debug_assert!` which is removed in production.

The Move bytecode verifier does check type argument counts during module verification: [9](#0-8) 

And runtime argument counts are validated indirectly through stack operations during type safety verification: [10](#0-9) 

However, the Move VM's own defensive programming uses conditional panics via the `safe_unwrap!` macro: [11](#0-10) 

This macro panics in debug mode but returns errors gracefully in release mode. The table-natives assertions do not follow this pattern.

**Attack Path:**
1. Bytecode verifier has an undiscovered bug allowing malformed function calls to pass verification
2. Attacker publishes a module exploiting this verifier bug  
3. Transaction calls table native function with incorrect type args/argument counts
4. Assertions trigger, causing validator node to panic and crash
5. Network liveness degraded if multiple validators crash

## Impact Explanation

This issue qualifies as **Medium severity** under Aptos bug bounty criteria. While not directly exploitable, it represents a **defense-in-depth violation** that amplifies the impact of potential bytecode verifier bugs.

**Actual Impact:**
- **Validator Availability**: Crashes validator nodes instead of gracefully rejecting transactions
- **Consensus Risk**: Could cause temporary liveness issues if validators crash during block execution
- **Amplification Effect**: Converts bytecode verifier bugs from transaction rejection to validator crashes

The issue does NOT qualify as High/Critical because:
- Requires a separate bytecode verifier bug to trigger
- Does not directly cause safety violations or fund loss
- Normal operation should never trigger these assertions

However, it meets Medium criteria for "state inconsistencies requiring intervention" since validator crashes could require manual restart and investigation.

## Likelihood Explanation

**Likelihood: Low to Medium**

The assertions would only trigger if:
1. **Bytecode verifier bug exists** (Low probability - verifier is well-tested)
2. **Runtime VM bug** causes type argument mismatch (Low probability)
3. **Memory corruption** or race conditions (Very low probability)

However, the **impact multiplier** is high because:
- Any future verifier bug would cause validator crashes instead of clean errors
- Testing may not catch these panics since they only trigger on malformed input
- Production validators run release builds where these panics are active

The defense-in-depth violation is certain - the code objectively uses unsafe panic patterns.

## Recommendation

Replace all `assert!` macros with proper error handling using `SafeNativeError::InvariantViolation`. This pattern is already used successfully in other native functions: [12](#0-11) 

**Recommended Fix Pattern:**
```rust
fn native_add_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Replace: assert_eq!(ty_args.len(), 3);
    if ty_args.len() != 3 {
        return Err(SafeNativeError::InvariantViolation {
            status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            message: format!(
                "table::add_box expected 3 type arguments, got {}",
                ty_args.len()
            ),
        });
    }
    
    // Replace: assert_eq!(args.len(), 3);
    if args.len() != 3 {
        return Err(SafeNativeError::InvariantViolation {
            status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            message: format!(
                "table::add_box expected 3 arguments, got {}",
                args.len()
            ),
        });
    }
    
    // Rest of function...
}
```

Apply this pattern to all native functions in the file.

## Proof of Concept

This vulnerability cannot be demonstrated with a standalone PoC because it requires first discovering a bytecode verifier bug. However, the unsafe pattern can be verified:

**Verification Steps:**
1. Confirm assertions use `assert!` not `debug_assert!` (lines 358, 391, 452, 512, 566, 626, 639, 649)
2. Build in release mode: `cargo build --release`
3. Verify assertions are compiled into binary: `objdump -d` shows assertion code paths
4. Contrast with `safe_unwrap!` macro which returns errors in release mode

**Hypothetical Trigger (if verifier bug existed):**
```move
// Hypothetical malformed bytecode that bypasses verifier
module attacker::exploit {
    use std::table;
    
    public entry fun trigger_crash() {
        // If verifier allows wrong type arg count
        let t = table::new<u64>(); // Missing second type param
        // Assertion at line 358 triggers: assert_eq!(ty_args.len(), 2)
        // â†’ Validator panics instead of returning error
    }
}
```

## Notes

This is a **code quality and defensive programming issue** rather than a directly exploitable vulnerability. The primary concern is that it violates Aptos's own established patterns for safe error handling in native functions and could amplify the severity of future bugs in the bytecode verification system.

The bytecode verifier provides the first line of defense by checking type argument and parameter counts at module publication time, making these assertions theoretically unreachable under correct operation. However, defense-in-depth principles dictate that native functions should handle invariant violations gracefully rather than crashing the validator process.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L358-359)
```rust
    assert_eq!(ty_args.len(), 2);
    assert!(args.is_empty());
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L391-392)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 3);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L452-453)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 2);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L512-513)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 2);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L566-567)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 2);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L626-627)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 1);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L639-639)
```rust
    assert!(table_data.removed_tables.insert(handle));
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L649-650)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 1);
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L489-499)
```rust
                if func_handle.type_parameters.len() != ty_args.len() {
                    return Err(
                        PartialVMError::new(StatusCode::NUMBER_OF_TYPE_ARGUMENTS_MISMATCH)
                            .with_message(format!(
                                "expected {} type argument(s), got {}",
                                func_handle.type_parameters.len(),
                                ty_args.len()
                            ))
                            .at_index(IndexKind::FunctionInstantiation, func_inst_idx.0),
                    );
                }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L284-305)
```rust
fn call(
    verifier: &mut TypeSafetyChecker,
    meter: &mut impl Meter,
    offset: CodeOffset,
    function_handle: &FunctionHandle,
    type_actuals: &Signature,
) -> PartialVMResult<()> {
    let parameters = verifier.resolver.signature_at(function_handle.parameters);
    for parameter in parameters.0.iter().rev() {
        let arg = safe_unwrap!(verifier.stack.pop());
        // For parameter to argument, use assignability
        if (type_actuals.is_empty() && !parameter.is_assignable_from(&arg))
            || (!type_actuals.is_empty()
                && !instantiate(parameter, type_actuals).is_assignable_from(&arg))
        {
            return Err(verifier.error(StatusCode::CALL_TYPE_MISMATCH_ERROR, offset));
        }
    }
    for return_type in &verifier.resolver.signature_at(function_handle.return_).0 {
        verifier.push(meter, instantiate(return_type, type_actuals))?
    }
    Ok(())
```

**File:** third_party/move/move-binary-format/src/lib.rs (L138-152)
```rust
macro_rules! safe_unwrap {
    ($e:expr) => {{
        match $e {
            Some(x) => x,
            None => {
                let err = PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                    .with_message(format!("{}:{} (none)", file!(), line!()));
                if cfg!(debug_assertions) {
                    panic!("{:?}", err);
                } else {
                    return Err(err);
                }
            },
        }
    }};
```

**File:** aptos-move/aptos-native-interface/src/errors.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use move_binary_format::errors::PartialVMError;
use move_core_types::{identifier::Identifier, language_storage::ModuleId, vm_status::StatusCode};
use move_vm_types::{loaded_data::runtime_types::Type, values::Value};
use smallvec::SmallVec;

/// Wraps [PartialVMError] to ensure it cannot be constructed via public constructor when we create
/// a [LimitExceededError].
pub struct MeteringError(PartialVMError);

impl MeteringError {
    pub fn unpack(self) -> PartialVMError {
        self.0
    }
}

/// Specifies different ways of exceeding the limit.
pub enum LimitExceededError {
    /// Represents legacy out of gas status. Mapped to [StatusCode::OUT_OF_GAS]. Does not represent
    /// anything else, e.g., reaching memory limits, loading too many dependencies.
    LegacyOutOfGas,
    /// Error due to metering. The inner value contains the VM error which can be later returned to
    /// interpreter.
    LimitExceeded(MeteringError),
}

impl LimitExceededError {
    pub fn from_err(err: PartialVMError) -> SafeNativeError {
        match err.major_status() {
            StatusCode::OUT_OF_GAS
            | StatusCode::EXECUTION_LIMIT_REACHED
            | StatusCode::DEPENDENCY_LIMIT_REACHED
            | StatusCode::MEMORY_LIMIT_EXCEEDED
            | StatusCode::TOO_MANY_TYPE_NODES
            | StatusCode::VM_MAX_VALUE_DEPTH_REACHED => SafeNativeError::LimitExceeded(
                LimitExceededError::LimitExceeded(MeteringError(err)),
            ),
            // Treat all other code as invariant violations and leave it for the VM to propagate
            // these further. Note that we do not remap the errors. For example, if there is a
            // speculative error returned (signaling Block-STM to stop executing this transaction),
            // we better not remap it.
            // TODO(Gas): Have a single method to convert partial VM error to safe native error.
            _ => SafeNativeError::InvariantViolation(err),
        }
    }
}

/// Saner representation of a native function error.
```
