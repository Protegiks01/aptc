# Audit Report

## Title
Lambda/Closure Bypass in Randomness Transitive Call Detection

## Summary
The `calls_randomness()` function fails to detect indirect randomness usage through lambda expressions passed to inline functions. This allows public functions to expose randomness functionality and private entry functions to use randomness without required attributes, bypassing critical safety checks designed to prevent non-deterministic execution and consensus violations.

## Finding Description

The randomness safety checker in `extended_checks.rs` is designed to ensure:
1. Public functions do not expose randomness functionality (unless explicitly allowed)
2. Private entry functions using randomness have the `#[randomness]` attribute

However, the transitive call detection mechanism has a critical gap: it only tracks direct function calls and misses indirect calls through lambda expressions/closures.

**Root Cause Analysis:**

The `calls_randomness()` function uses `get_called_functions()` to determine if a function transitively calls randomness: [1](#0-0) 

This function returns `called_funs`, which is populated from bytecode by `get_called_funs_from_bytecode()`: [2](#0-1) 

The critical issue is at lines 1908-1913 where only `Bytecode::Call` and `Bytecode::CallGeneric` instructions are recognized. Lambda/closure references use `Bytecode::PackClosure` and `Bytecode::PackClosureGeneric`, which are completely ignored.

Notably, there exists a separate function `get_used_funs_from_bytecode()` that DOES recognize closure operations: [3](#0-2) 

Lines 1879-1880 show `PackClosure` and `PackClosureGeneric` are correctly handled here, but the randomness checker doesn't use this function.

**Attack Scenario:**

1. Attacker creates a public function that calls an inline function (e.g., `vector::foreach`, `vector::any`, `vector::fold`)
2. Passes a lambda parameter that internally calls randomness functions from `0x1::randomness`
3. During compilation:
   - Lambda lifting transforms the lambda into a private function `__lambda__X`
   - Inlining expands the inline function into the caller
   - The bytecode contains `PackClosure` referencing the lambda function
   - The lambda function's bytecode contains `Call` to randomness
4. Extended checks run:
   - `get_called_funs_from_bytecode()` ignores the `PackClosure` instruction
   - `called_funs` doesn't include `__lambda__X`
   - `calls_randomness()` returns false despite transitive randomness usage
   - No error is reported
5. The function deploys successfully and can be used to access randomness unsafely

**Invariant Violated:**

This breaks the **Deterministic Execution** invariant (#1): Public functions can expose non-deterministic randomness functionality without proper safeguards, potentially causing validators to produce different state roots when randomness results differ or are accessed outside the protected entry point context.

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple attack vectors:

1. **Consensus Violation Risk**: Public functions can expose randomness without the `#[randomness]` attribute required for proper gas accounting and execution context validation. If called outside the intended entry point context, this could lead to non-deterministic execution across validators.

2. **Safety Check Bypass**: Private entry functions can use randomness without declaring it via `#[randomness]`, bypassing the framework's safety mechanisms that ensure proper randomness handling.

3. **Protocol Integrity**: The randomness module was specifically designed with usage restrictions to prevent unsafe access patterns. This bypass undermines the entire security model.

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** because it can lead to consensus/safety violations through non-deterministic execution if randomness is accessed improperly.

## Likelihood Explanation

**High Likelihood:**

1. **Common Pattern**: Using inline functions with lambda parameters is a standard Move programming pattern (vector operations like `foreach`, `map`, `fold` are frequently used)

2. **No Special Permissions Required**: Any Move developer can create such code - no privileged access needed

3. **Realistic Attack**: The attack requires only:
   - Writing a public function
   - Calling a standard library inline function
   - Passing a lambda that calls `0x1::randomness`
   - Deploying the module

4. **Difficult to Detect**: Without runtime monitoring, deployed modules with this pattern would appear normal in static analysis

## Recommendation

**Option 1 (Preferred):** Modify `calls_randomness()` to use transitive closure of used functions instead of called functions:

```rust
fn calls_randomness(&mut self, fun: QualifiedId<FunId>) -> bool {
    if let Some(is_caller) = self.randomness_caller_cache.get(&fun) {
        return *is_caller;
    }
    self.randomness_caller_cache.insert(fun, false);
    let mut is_caller = false;
    
    // Use get_used_functions() instead of get_called_functions()
    // This includes both direct calls and closure/lambda references
    for callee in self
        .env
        .get_function(fun)
        .get_used_functions()  // CHANGED
        .expect("callees defined")
    {
        if self.is_randomness_fun(*callee) || self.calls_randomness(*callee) {
            is_caller = true;
            break;
        }
    }
    
    if is_caller {
        self.randomness_caller_cache.insert(fun, true);
    }
    is_caller
}
``` [4](#0-3) 

**Option 2 (Alternative):** Update `get_called_funs_from_bytecode()` to also recognize `PackClosure` and `PackClosureGeneric` instructions, making it consistent with `get_used_funs_from_bytecode()`.

## Proof of Concept

```move
// File: sources/randomness_bypass.move
module 0x42::randomness_bypass {
    use std::vector;
    use aptos_framework::randomness;
    
    // This public function should be flagged as unsafe but isn't
    public fun unsafe_randomness_via_lambda(values: vector<u64>): bool {
        // foreach is an inline function that takes a lambda
        vector::any(&values, |_x| {
            // This lambda calls randomness - should be detected but isn't
            let random_val = randomness::u64_range(1, 100);
            random_val > 50
        })
    }
    
    // Private entry function without #[randomness] attribute
    entry fun unsafe_entry_via_lambda(values: vector<u64>) {
        // Should require #[randomness] attribute but doesn't get flagged
        vector::foreach(&values, |_x| {
            let _random = randomness::u64_range(1, 100);
        });
    }
}
```

**Expected Behavior:** Extended checks should reject both functions with errors:
- `unsafe_randomness_via_lambda`: "public function exposes functionality of the `randomness` module"
- `unsafe_entry_via_lambda`: "entry function calling randomness features must use the `#[randomness]` attribute"

**Actual Behavior:** Both functions pass extended checks without errors because the lambda's call to randomness is not detected by the transitive call analysis.

**Verification Steps:**
1. Create the module above in the Aptos framework
2. Run `aptos move compile`
3. Observe that compilation succeeds without randomness-related errors
4. The bytecode will contain `PackClosure` instructions that reference lifted lambda functions
5. Those lambda functions call randomness, but this transitive usage is never detected

## Notes

The vulnerability exists because of an architectural mismatch between:
- **AST-level analysis**: Inline functions are expanded and lambdas become `Operation::Closure` nodes
- **Bytecode-level tracking**: `get_called_funs_from_bytecode()` only recognizes direct `Call` instructions, not `PackClosure`

The system already has the infrastructure to track closure usage correctly (`get_used_funs_from_bytecode()` and `get_used_functions()`), but the randomness checker was not updated to use it. This suggests the feature was added after the randomness checks were implemented, creating this security gap.

### Citations

**File:** aptos-move/framework/src/extended_checks.rs (L651-674)
```rust
    fn calls_randomness(&mut self, fun: QualifiedId<FunId>) -> bool {
        if let Some(is_caller) = self.randomness_caller_cache.get(&fun) {
            return *is_caller;
        }
        // For building a fixpoint on cycles, set the value initially to false
        self.randomness_caller_cache.insert(fun, false);
        let mut is_caller = false;
        for callee in self
            .env
            .get_function(fun)
            .get_called_functions()
            .expect("callees defined")
        {
            if self.is_randomness_fun(*callee) || self.calls_randomness(*callee) {
                is_caller = true;
                break;
            }
        }
        if is_caller {
            // If we found a randomness call, update the cache
            self.randomness_caller_cache.insert(fun, true);
        }
        is_caller
    }
```

**File:** third_party/move/move-model/src/model.rs (L1869-1894)
```rust
        def_idx: FunctionDefinitionIndex,
    ) -> BTreeSet<QualifiedId<FunId>> {
        let function_definition = module.function_def_at(def_idx);
        let function_definition_view = FunctionDefinitionView::new(module, function_definition);
        let used_funs: BTreeSet<QualifiedId<FunId>> = match function_definition_view.code() {
            Some(unit) => unit
                .code
                .iter()
                .filter_map(|c| {
                    let handle_idx = match c {
                        Bytecode::Call(i) | Bytecode::PackClosure(i, ..) => Some(*i),
                        Bytecode::CallGeneric(i) | Bytecode::PackClosureGeneric(i, ..) => {
                            Some(module.function_instantiation_at(*i).handle)
                        },
                        _ => None,
                    };
                    handle_idx.map(|idx| {
                        ModuleEnv::get_used_function_from_compiled_module(self, idx, module)
                            .get_qualified_id()
                    })
                })
                .collect(),
            None => BTreeSet::default(),
        };
        used_funs
    }
```

**File:** third_party/move/move-model/src/model.rs (L1896-1924)
```rust
    fn get_called_funs_from_bytecode(
        &self,
        module: &CompiledModule,
        def_idx: FunctionDefinitionIndex,
    ) -> BTreeSet<QualifiedId<FunId>> {
        let function_definition = module.function_def_at(def_idx);
        let function_definition_view = FunctionDefinitionView::new(module, function_definition);
        let called_funs: BTreeSet<QualifiedId<FunId>> = match function_definition_view.code() {
            Some(unit) => unit
                .code
                .iter()
                .filter_map(|c| {
                    let handle_idx = match c {
                        Bytecode::Call(i) => Some(*i),
                        Bytecode::CallGeneric(i) => {
                            Some(module.function_instantiation_at(*i).handle)
                        },
                        _ => None,
                    };
                    handle_idx.map(|idx| {
                        ModuleEnv::get_used_function_from_compiled_module(self, idx, module)
                            .get_qualified_id()
                    })
                })
                .collect(),
            None => BTreeSet::default(),
        };
        called_funs
    }
```

**File:** third_party/move/move-model/src/model.rs (L5302-5304)
```rust
    pub fn get_used_functions(&self) -> Option<&'_ BTreeSet<QualifiedId<FunId>>> {
        self.data.used_funs.as_ref()
    }
```
