# Audit Report

## Title
Unauthorized Governance Proposal Hash Injection Enabling Transaction Limit Bypass

## Summary
The `add_approved_script_hash_script` function in the governance module lacks proper access control, allowing any attacker to inject execution hashes of successful proposals into the `ApprovedExecutionHashes` registry before proper resolution. This enables attackers to bypass transaction size limits (up to 1MB) and execution gas limits, violating fundamental resource limit invariants. [1](#0-0) 

## Finding Description

The Aptos governance system maintains an `ApprovedExecutionHashes` on-chain configuration that stores execution hashes of approved governance proposals. This mechanism allows legitimate governance scripts to bypass mempool transaction size limits (permitting up to 1MB transactions vs normal limits) and receive elevated execution gas limits, enabling large framework upgrades. [2](#0-1) 

The vulnerability exists in the `add_approved_script_hash` function, which is exposed as a public entry function through `add_approved_script_hash_script`. This function performs only a single validation check: [3](#0-2) 

The function verifies only that the proposal has reached `PROPOSAL_STATE_SUCCEEDED` status but includes **no authorization checks** on the caller. This creates a critical governance bypass vector.

**Attack Scenario:**

1. **Proposal Creation**: Attacker creates a malicious governance proposal containing a large script (up to 1MB) with execution hash `H_malicious`. The proposal can appear benign in metadata while containing malicious bytecode.

2. **Vote Manipulation**: Through legitimate voting, social engineering, or exploiting voting power mechanics, the attacker gets the proposal to `SUCCEEDED` state. The proposal only needs to pass the voting threshold—it does not need to be resolved.

3. **Hash Injection**: Before the proposal undergoes proper resolution through `resolve()` or `resolve_multi_step_proposal()`, the attacker calls `add_approved_script_hash_script(proposal_id)`. Since this is a public entry function with no authorization, **anyone** can call it.

4. **Privilege Escalation**: The malicious hash is now in `ApprovedExecutionHashes`. The VM's `is_approved_gov_script` function identifies any transaction with this hash as an approved governance script: [4](#0-3) 

5. **Exploit Execution**: The attacker submits transactions with script hash `H_malicious`. These transactions:
   - Bypass mempool size limits (can be up to 1MB instead of normal limits)
   - Receive elevated execution gas limits designated for governance operations
   - Execute arbitrary malicious code with the attacker's permissions [5](#0-4) 

The attacker never needs to call `voting::resolve()` to execute their script. The `resolve` function requires the executing script's hash to match via `transaction_context::get_script_hash()`, but the attacker's script bypasses this by executing directly, not through the resolution path: [6](#0-5) 

**Broken Invariant:**

This vulnerability violates **Invariant 9: Resource Limits** - "All operations must respect gas, storage, and computational limits." The attacker bypasses fundamental transaction size and gas execution limits that protect the network from resource exhaustion attacks.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty category: "Significant protocol violations")

This vulnerability constitutes a significant protocol violation with multiple attack vectors:

1. **Transaction Limit Bypass**: Attackers can submit transactions up to 1MB (vs normal ~8KB limits), enabling deployment of massive Move modules or execution of extraordinarily complex scripts that would normally be rejected by mempool validation.

2. **Gas Limit Escalation**: Approved scripts receive `max_execution_gas_gov` instead of `max_execution_gas`, providing substantially higher computational resources: [7](#0-6) 

3. **Governance Process Bypass**: The intended governance flow requires formal resolution where the script hash is validated during execution. This vulnerability allows attackers to obtain privileged resource access without completing the governance cycle.

4. **Amplification of Other Vulnerabilities**: The ability to execute large, complex scripts could amplify other potential vulnerabilities that require substantial bytecode payloads or complex state manipulations.

5. **Resource Exhaustion Vector**: While not a direct DoS, the ability to repeatedly submit 1MB transactions with elevated gas limits could strain network resources if exploited at scale.

The vulnerability does not result in direct fund theft or consensus violations, placing it in the High severity category rather than Critical. However, it represents a fundamental breakdown in the governance approval model and resource limit enforcement.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible with the following requirements:

1. **Low Technical Barrier**: Calling `add_approved_script_hash_script` is a single, straightforward transaction. No complex exploit chain or race conditions are required.

2. **Achievable Prerequisites**: The attacker needs to create a proposal and get it to `SUCCEEDED` state. While this requires voting power or community support, it's not insurmountable—especially for proposals that appear legitimate in their metadata descriptions while containing malicious bytecode.

3. **No Authorization Checks**: The public entry function has zero access control validation, making exploitation trivial once a proposal reaches `SUCCEEDED` state.

4. **Timing Window**: The vulnerability can be exploited at any point after a proposal succeeds, providing a wide exploitation window before legitimate resolution occurs.

5. **Minimal Detection**: The hash injection appears as a normal transaction and doesn't trigger obvious alarms, as `add_approved_script_hash_script` is a legitimate function intended for manual intervention scenarios.

## Recommendation

**Immediate Fix**: Restrict `add_approved_script_hash_script` to authorized governance callers only. The function should verify that the caller has the `GovernancePermission`:

```move
public entry fun add_approved_script_hash_script(
    governance_signer: &signer,
    proposal_id: u64
) acquires ApprovedExecutionHashes {
    check_governance_permission(governance_signer);
    add_approved_script_hash(proposal_id)
}
``` [8](#0-7) 

**Additional Hardening**:

1. **Automatic Hash Addition**: The hash should be automatically added when a proposal succeeds (line 602 already does this). Manual addition should be restricted to governance operations only. [9](#0-8) 

2. **Resolution Coupling**: Consider tracking which proposals have been resolved and prevent hash additions for unresolved proposals except during the resolution flow itself.

3. **Hash Validation During Execution**: The VM could verify that approved governance scripts actually call `voting::resolve()` as part of their execution, ensuring they follow the proper governance flow rather than executing independently.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, attacker = @0xBAD, voter = @0x345)]
public entry fun test_hash_injection_bypass(
    aptos_framework: signer,
    attacker: signer,
    voter: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    // Setup governance
    setup_partial_voting(&aptos_framework, &attacker, &voter, &voter);
    
    // Step 1: Attacker creates a large malicious proposal (simulated with hash)
    let large_script = vector::empty<u8>();
    vector::push_back(&mut large_script, 1);
    // In reality, this would be a 1MB malicious script
    
    create_proposal(
        &attacker,
        signer::address_of(&attacker),
        large_script,
        b"Appears benign",
        b"0xABCD",
    );
    
    // Step 2: Get proposal to SUCCEEDED state through voting
    vote(&voter, signer::address_of(&voter), 0, true);
    timestamp::update_global_time_for_test(100001000000);
    
    let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, 0);
    assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, 0);
    
    // Step 3: VULNERABILITY - Anyone can inject the hash
    // Attacker calls public entry function before legitimate resolution
    add_approved_script_hash_script(0);
    
    // Step 4: Verify hash is now in approved list
    let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;
    assert!(simple_map::contains_key(&approved_hashes, &0), 1);
    
    // Step 5: Attacker can now submit large transactions with this hash
    // that bypass size and gas limits without proper governance resolution
    // The script executes with attacker's permissions but elevated resource limits
}
```

## Notes

- The vulnerability exists in the production codebase at `aptos-move/framework/aptos-framework/sources/aptos_governance.move`.
- The issue affects both single-step and multi-step proposals, as both use the same hash injection mechanism.
- While the attacker's script executes with their own permissions (not governance permissions), the ability to bypass fundamental resource limits represents a critical protocol violation that could enable numerous secondary attacks.
- The automatic hash addition during voting (line 602) is the intended behavior; the vulnerability specifically stems from the unrestricted manual addition function.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L108-112)
```text
    /// Used to track which execution script hashes have been approved by governance.
    /// This is required to bypass cases where the execution scripts exceed the size limit imposed by mempool.
    struct ApprovedExecutionHashes has key {
        hashes: SimpleMap<u64, vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L177-182)
```text
    inline fun check_governance_permission(s: &signer) {
        assert!(
            permissioned_signer::check_permission_exists(s, GovernancePermission {}),
            error::permission_denied(ENO_GOVERNANCE_PERMISSION),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L600-604)
```text
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        if (proposal_state == PROPOSAL_STATE_SUCCEEDED) {
            add_approved_script_hash(proposal_id);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L606-608)
```text
    public entry fun add_approved_script_hash_script(proposal_id: u64) acquires ApprovedExecutionHashes {
        add_approved_script_hash(proposal_id)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L613-630)
```text
    public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);

        // Ensure the proposal can be resolved.
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_argument(EPROPOSAL_NOT_RESOLVABLE_YET));

        let execution_hash = voting::get_execution_hash<GovernanceProposal>(@aptos_framework, proposal_id);

        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.
        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.
        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {
            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);
            *current_execution_hash = execution_hash;
        } else {
            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L286-302)
```rust
fn is_approved_gov_script(
    resolver: &impl ConfigStorage,
    txn: &SignedTransaction,
    txn_metadata: &TransactionMetadata,
) -> bool {
    if let Ok(TransactionExecutableRef::Script(_script)) = txn.payload().executable_ref() {
        match ApprovedExecutionHashes::fetch_config(resolver) {
            Some(approved_execution_hashes) => approved_execution_hashes
                .entries
                .iter()
                .any(|(_, hash)| hash == &txn_metadata.script_hash),
            None => false,
        }
    } else {
        false
    }
}
```

**File:** aptos-move/aptos-vm/src/gas.rs (L83-108)
```rust
    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```

**File:** aptos-move/e2e-move-tests/src/tests/governance_updates.rs (L76-93)
```rust
fn alt_execution_limit_for_gov_proposals() {
    // This test validates that approved governance scripts automatically get the
    // alternate (usually increased) execution limit.
    let max_gas_regular = 10;
    let max_gas_gov = 100;

    // Set up the testing environment
    let mut h = MoveHarness::new();

    let alice = h.new_account_at(AccountAddress::from_hex_literal("0xa11ce").unwrap());
    let root = h.aptos_framework_account();

    h.modify_gas_schedule(|gas_params| {
        let txn = &mut gas_params.vm.txn;

        txn.max_execution_gas = Gas::new(max_gas_regular).to_unit_with_params(txn);
        txn.max_execution_gas_gov = Gas::new(max_gas_gov).to_unit_with_params(txn);
    });
```
