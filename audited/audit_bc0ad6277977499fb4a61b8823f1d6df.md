# Audit Report

## Title
Gas Schedule Version-Parameter Name Mismatch Causes Unrecoverable Chain Halt

## Summary
Missing validation in the gas schedule update mechanism allows malformed gas schedule updates where the `feature_version` field does not match the parameter names in the `entries` field. When such a malformed schedule is applied, all transaction execution fails with `VM_STARTUP_FAILURE`, causing complete chain halt that requires an emergency hardfork to recover.

## Finding Description

The Aptos gas schedule system uses version-specific parameter naming. For example, the parameter for state slot reads is named `"load_data.base"` in versions 0-9, but changes to `"storage_io_per_state_slot_read"` in version 10 and above. [1](#0-0) 

The macro-generated code extracts the correct parameter name based on the feature version at runtime: [2](#0-1) 

If a parameter name expected for a given version doesn't exist in the on-chain gas schedule, an error is returned: [3](#0-2) 

**The Critical Vulnerability**: When updating the gas schedule via governance, there is NO validation that the parameter names in the `entries` field match what's expected for the `feature_version` field. The TODO comments explicitly acknowledge this missing validation: [4](#0-3) 

The only validation performed is checking that the feature version is not decreasing and (optionally) that the old schedule hash matches. Parameter name consistency is never validated.

**Attack Propagation Path**:

1. Attacker crafts a malformed `GasScheduleV2` with:
   - `feature_version: 10`
   - `entries: [("txn.load_data.base", value), ...]` (version 9 parameter names)

2. Submits via governance using `set_for_next_epoch()` or `set_for_next_epoch_check_hash()`

3. Proposal passes on-chain validation (only version >= check)

4. During next epoch change, `on_new_epoch()` applies the malformed schedule: [5](#0-4) 

5. When any subsequent transaction attempts execution, gas parameters fail to load because the version 10 parameter name lookups fail to find version 9 parameter names in the on-chain schedule: [6](#0-5) 

6. This error propagates as `VM_STARTUP_FAILURE`: [7](#0-6) 

7. Transactions with `VM_STARTUP_FAILURE` are discarded: [8](#0-7) 

8. **Critical**: Even the block prologue (automatic epoch changes) requires gas parameters and fails: [9](#0-8) 

9. With block prologue failing, no automatic epoch changes can occur, and no governance transactions can execute to fix the malformed schedule. The chain is completely halted.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

- **Total loss of liveness/network availability**: Once triggered, the entire blockchain cannot process ANY transactions, including system transactions.
- **Non-recoverable network partition (requires hardfork)**: The chain cannot recover through normal governance mechanisms because governance transactions also fail. An emergency hardfork with state modification is required.

All validators are affected simultaneously because they all read the same on-chain gas schedule. The deterministic execution invariant is violated in the sense that the chain cannot execute anything deterministically anymore - all execution fails.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack can occur through:

1. **Malicious governance participant**: An attacker with governance voting power could deliberately craft a malformed proposal. Governance participation requires significant stake but is achievable.

2. **Compromised governance account**: If any governance participant's account is compromised, the attacker could submit the malformed proposal.

3. **Accidental misconfiguration**: If developers bypass the standard gas schedule generation tools (which correctly generate matching parameter names) and manually craft a proposal, they could accidentally create a version-parameter mismatch.

The technical complexity is LOW - the attacker only needs to:
- Take a legitimate gas schedule blob
- Modify the `feature_version` field in the BCS-encoded data
- Submit as a governance proposal

The existing TODO comments in the codebase indicate this validation gap is known but unfixed, suggesting it may be considered low priority despite its critical impact.

## Recommendation

Implement validation in `gas_schedule.move` to verify parameter name consistency before accepting gas schedule updates:

```move
/// Validates that all parameter names in the gas schedule match the expected names
/// for the given feature_version by attempting to deserialize them.
fun validate_gas_schedule_consistency(gas_schedule: &GasScheduleV2): bool {
    // Call a native function that attempts to deserialize gas parameters
    // using the Rust FromOnChainGasSchedule trait, which will fail if
    // parameter names don't match the feature_version.
    native_validate_gas_schedule(gas_schedule)
}

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // VALIDATION: Check parameter name consistency
    assert!(
        validate_gas_schedule_consistency(&new_gas_schedule),
        error::invalid_argument(EINVALID_GAS_SCHEDULE)
    );
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

The native validation function should convert the on-chain schedule to a BTreeMap and call `AptosGasParameters::from_on_chain_gas_schedule()`, returning `false` if it returns an error.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_malformed_gas_schedule_halts_chain() {
    let mut harness = MoveHarness::new();
    
    // Step 1: Get current gas schedule (version 9)
    let current_schedule = harness.read_resource::<GasScheduleV2>(
        &AccountAddress::ONE,
        parse_type_tag("0x1::gas_schedule::GasScheduleV2").unwrap()
    ).unwrap();
    
    assert_eq!(current_schedule.feature_version, 9);
    
    // Step 2: Craft malformed schedule with version 10 but version 9 parameter names
    let malformed_schedule = GasScheduleV2 {
        feature_version: 10,  // Bumped version
        entries: current_schedule.entries.clone()  // But kept old parameter names!
    };
    
    // Step 3: Apply the malformed schedule (simulating governance proposal)
    let framework = harness.aptos_framework_account();
    harness.set_resource(
        AccountAddress::ONE,
        parse_type_tag("0x1::gas_schedule::GasScheduleV2").unwrap(),
        &malformed_schedule
    );
    
    // Step 4: Try to execute ANY transaction - it should fail with VM_STARTUP_FAILURE
    let account = harness.new_account_at(AccountAddress::from_hex_literal("0xbeef").unwrap());
    
    let result = harness.run_transaction_payload(
        &account,
        aptos_cached_packages::aptos_stdlib::aptos_coin_transfer(
            AccountAddress::from_hex_literal("0xcafe").unwrap(),
            100
        )
    );
    
    // Assert that transaction was discarded with VM_STARTUP_FAILURE
    assert!(matches!(
        result.status(),
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ));
    
    // Step 5: Verify that even block prologue fails
    let block_result = harness.new_block();
    assert!(block_result.is_err());
    
    // Chain is now completely halted - no transactions can execute
}
```

**Notes:**

This vulnerability breaks the "Total loss of liveness/network availability" critical invariant. The missing validation allows semantically invalid gas schedules to be applied on-chain, causing complete chain halt that cannot be recovered without an emergency hardfork to manually fix the on-chain gas schedule state.

The vulnerability is exploitable through governance mechanisms and could also occur accidentally if proper tooling is not used. The impact is maximally severe - complete denial of service for all network participants.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L89-96)
```rust
            storage_io_per_state_slot_read: InternalGasPerArg,
            { 0..=9 => "load_data.base", 10.. => "storage_io_per_state_slot_read"},
            // At the current mainnet scale, we should assume most levels of the (hexary) JMT nodes
            // in cache, hence target charging 1-2 4k-sized pages for each read. Notice the cost
            // of seeking for the leaf node is covered by the first page of the "value size fee"
            // (storage_io_per_state_byte_read) defined below.
            302_385,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L26-36)
```rust
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2461-2466)
```rust
        let output = get_system_transaction_output(
            session,
            module_storage,
            &self.storage_gas_params(log_context)?.change_set_configs,
        )?;
        Ok((VMStatus::Executed, output))
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L287-299)
```rust
            VMStatus::Error {
                status_code: code,
                message,
                ..
            } => {
                match code.status_type() {
                    // Any unknown error should be discarded
                    StatusType::Unknown => Err(code),
                    // Any error that is a validation status (i.e. an error arising from the prologue)
                    // causes the transaction to not be included.
                    StatusType::Validation => Err(code),
                    // If the VM encountered an invalid internal state, we should discard the transaction.
                    StatusType::InvariantViolation => Err(code),
```
