# Audit Report

## Title
Type Confusion in Keyless Account Multi-Agent Transaction Handling Causes Transaction Emitter Crash

## Summary
When the transaction emitter is configured to use keyless accounts (`AccountType::Keyless`), any transaction type that requires multi-agent or fee-payer signatures will cause an immediate runtime panic and crash the emitter. This occurs because the code attempts to extract Ed25519 private keys from keyless accounts, which use a fundamentally different authentication model, triggering an unimplemented `todo!()` macro.

## Finding Description
The vulnerability exists in a type confusion between keyless and standard private-key accounts in the transaction generation pipeline.

**Vulnerability Path:**

1. In [1](#0-0) , when `keyless_ephem_secret_key` is provided, the system switches to `AccountType::Keyless`.

2. This causes the account generator in [2](#0-1)  to create keyless `LocalAccount` instances using `LocalAccount::new_keyless()`.

3. Multiple transaction entry points require multi-agent signatures, as defined in [3](#0-2) :
   - `Nop2Signers`: `MultiSigConfig::Random(1)` 
   - `Nop5Signers`: `MultiSigConfig::Random(4)`
   - `NopFeePayer`: `MultiSigConfig::FeePayerPublisher`
   - `Republish`, `ResourceGroupsGlobalWriteTag`, `CoinInitAndMint`, etc.: `MultiSigConfig::Publisher`

4. When these transaction types are generated, the code calls multi-agent signing methods in [4](#0-3) .

5. These methods (`sign_multi_agent_with_transaction_builder` and `sign_fee_payer_with_transaction_builder`) extract private keys from accounts in [5](#0-4) .

6. When `private_key()` is called on a keyless account, it hits the unimplemented branch in [6](#0-5) , causing a panic with "not yet implemented".

The root cause is that keyless accounts use a completely different authentication model (ephemeral keys + ZK proofs + JWT) than standard accounts (Ed25519 private keys), but the code treats them interchangeably when generating multi-agent transactions.

## Impact Explanation
**High Severity** per Aptos bug bounty criteria:

- **API Crashes**: The transaction emitter immediately crashes with a panic when attempting to generate multi-agent transactions with keyless accounts
- **Validator Node Slowdowns**: If the transaction emitter is integrated into validator operations or load testing infrastructure, this causes service disruption
- **Denial of Service**: Load testing and transaction generation services become unavailable

This meets the "High Severity" category for "API crashes" and "Significant protocol violations" (mixing incompatible authentication models).

While this doesn't directly affect consensus or cause fund loss, it impacts operational infrastructure used for testing and potentially production transaction generation services.

## Likelihood Explanation
**HIGH Likelihood:**

1. **Common Configuration**: Load testing scenarios regularly use keyless accounts for testing keyless authentication features
2. **Common Transaction Types**: Multi-agent transaction types (Nop2Signers, NopFeePayer, Republish, etc.) are standard load testing scenarios
3. **No Validation**: There is no check preventing this invalid combination at configuration time
4. **Deterministic**: The crash occurs immediately and deterministically upon first transaction generation attempt
5. **Easy to Trigger**: Requires only command-line flags: `--keyless-ephem-secret-key` combined with any multi-sig transaction type

## Recommendation

**Immediate Fix**: Add validation to reject incompatible configurations early: [7](#0-6) 

Add validation after line 109 to check transaction compatibility.

**Long-term Fix**: Implement proper multi-agent support for keyless accounts or provide clear error messages: [5](#0-4) 

Replace `private_key()` calls with auth-type-aware implementations that either support keyless multi-agent (if technically feasible) or provide descriptive error messages.

**Additional Fix**: Update the authentication methods to fail gracefully: [6](#0-5) 

Replace `todo!()` with a descriptive panic message explaining the limitation.

## Proof of Concept

To reproduce the crash:

1. Configure transaction emitter with keyless account parameters:
   ```bash
   --keyless-ephem-secret-key <ephemeral_key>
   --epk-expiry-date-secs <timestamp>
   --keyless-jwt <jwt_token>
   --proof-file-path <proofs.txt>
   ```

2. Set transaction mix to include any multi-sig entry point:
   ```bash
   --transaction-type Nop2Signers
   # OR
   --transaction-type NopFeePayer
   # OR
   --transaction-type Republish
   ```

3. Start the transaction emitter

4. Observe immediate panic with stack trace pointing to:
   - [8](#0-7) 

The crash occurs because:
- Keyless accounts created in [9](#0-8) 
- Are passed to multi-agent signing in [10](#0-9) 
- Which calls unimplemented method in [6](#0-5) 

This demonstrates a clear type confusion vulnerability where the system fails to enforce authentication model compatibility constraints, leading to runtime crashes.

## Notes
This vulnerability specifically affects the transaction emitter testing infrastructure, not the core blockchain consensus or Move VM. However, it represents a significant operational issue for load testing and could impact development workflows or production transaction generation services. The fix should include both validation to prevent invalid configurations and proper error handling for keyless account operations that require private keys.

### Citations

**File:** crates/transaction-emitter-lib/src/wrappers.rs (L109-130)
```rust
    if let Some(keyless_ephem_secret_key) = &args.account_type_args.keyless_ephem_secret_key {
        emit_job_request = emit_job_request
            .account_type(AccountType::Keyless)
            .keyless_ephem_secret_key(keyless_ephem_secret_key.private_key());
        emit_job_request = emit_job_request.epk_expiry_date_secs(
            args.account_type_args
                .epk_expiry_date_secs
                .expect("epk expiry should be set"),
        );
        emit_job_request = emit_job_request.proof_file_path(
            args.account_type_args
                .proof_file_path
                .as_ref()
                .expect("proof file path should be set"),
        );
        emit_job_request = emit_job_request.keyless_jwt(
            args.account_type_args
                .keyless_jwt
                .as_ref()
                .expect("jwt should be set"),
        )
    }
```

**File:** crates/transaction-emitter-lib/src/emitter/mod.rs (L773-797)
```rust
        let account_generator = match req.account_type {
            AccountType::Local => create_private_key_account_generator(),
            AccountType::Keyless => {
                let ephem_sk = Ed25519PrivateKey::try_from(
                    req.keyless_ephem_secret_key
                        .expect("keyless_ephem_secret_key to not be None")
                        .as_ref(),
                )?;
                let keyless_config = self
                    .rest_cli
                    .get_resource(AccountAddress::ONE, "0x1::keyless_account::Configuration")
                    .await?
                    .into_inner();
                create_keyless_account_generator(
                    ephem_sk,
                    req.epk_expiry_date_secs
                        .expect("epk_expiry_date_secs to not be None"),
                    req.keyless_jwt
                        .as_deref()
                        .expect("keyless_jwt to not be None"),
                    req.proof_file_path.as_deref(),
                    keyless_config,
                )?
            },
        };
```

**File:** crates/transaction-workloads-lib/src/move_workloads.rs (L990-1008)
```rust
    fn multi_sig_additional_num(&self) -> MultiSigConfig {
        match self {
            EntryPoints::Republish => MultiSigConfig::Publisher,
            EntryPoints::NopFeePayer => MultiSigConfig::FeePayerPublisher,
            EntryPoints::Nop2Signers => MultiSigConfig::Random(1),
            EntryPoints::Nop5Signers => MultiSigConfig::Random(4),
            EntryPoints::ResourceGroupsGlobalWriteTag { .. }
            | EntryPoints::ResourceGroupsGlobalWriteAndReadTag { .. } => MultiSigConfig::Publisher,
            EntryPoints::CoinInitAndMint | EntryPoints::FungibleAssetMint => {
                MultiSigConfig::Publisher
            },
            EntryPoints::TokenV2AmbassadorMint { .. } | EntryPoints::TokenV2AmbassadorBurn => {
                MultiSigConfig::Publisher
            },
            EntryPoints::LiquidityPoolSwap { .. } => MultiSigConfig::Publisher,
            EntryPoints::CreateGlobalMilestoneAggV2 { .. } => MultiSigConfig::Publisher,
            _ => MultiSigConfig::None,
        }
    }
```

**File:** crates/transaction-generator-lib/src/entry_points.rs (L145-160)
```rust
            Some(match entry_point.multi_sig_additional_num() {
                MultiSigConfig::None => account.sign_with_transaction_builder(builder),
                MultiSigConfig::Random(_) => account.sign_multi_agent_with_transaction_builder(
                    additional_signers[entry_point_idx]
                        .as_ref()
                        .unwrap()
                        .iter()
                        .collect(),
                    builder,
                ),
                MultiSigConfig::Publisher => {
                    account.sign_multi_agent_with_transaction_builder(vec![publisher], builder)
                },
                MultiSigConfig::FeePayerPublisher => {
                    account.sign_fee_payer_with_transaction_builder(vec![], publisher, builder)
                },
```

**File:** sdk/src/types.rs (L370-404)
```rust
    pub fn sign_multi_agent_with_transaction_builder(
        &self,
        secondary_signers: Vec<&Self>,
        builder: TransactionBuilder,
    ) -> SignedTransaction {
        let secondary_signer_addresses = secondary_signers
            .iter()
            .map(|signer| signer.address())
            .collect();
        let secondary_signer_privkeys = secondary_signers
            .iter()
            .map(|signer| signer.private_key())
            .collect();

        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        raw_txn
            .sign_multi_agent(
                self.private_key(),
                secondary_signer_addresses,
                secondary_signer_privkeys,
            )
            .expect("Signing multi agent txn failed")
            .into_inner()
    }
```

**File:** sdk/src/types.rs (L481-489)
```rust
    pub fn private_key(&self) -> &Ed25519PrivateKey {
        match &self.auth {
            LocalAccountAuthenticator::PrivateKey(key) => key.private_key(),
            LocalAccountAuthenticator::Keyless(_) => todo!(),
            LocalAccountAuthenticator::FederatedKeyless(_) => todo!(),
            LocalAccountAuthenticator::Abstraction(..) => todo!(),
            LocalAccountAuthenticator::DerivableAbstraction(..) => todo!(),
        }
    }
```

**File:** crates/transaction-emitter-lib/src/emitter/local_account_generator.rs (L198-208)
```rust
        let accounts = keyless_accounts
            .into_iter()
            .zip(seq_nums)
            .map(|(keyless_account, sequence_number)| {
                LocalAccount::new_keyless(
                    keyless_account.authentication_key().account_address(),
                    keyless_account,
                    sequence_number,
                )
            })
            .collect();
```
