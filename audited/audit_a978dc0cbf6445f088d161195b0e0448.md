# Audit Report

## Title
Race Condition in Faucet Allows Funding of Existing Accounts

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition exists in the `TransferFunder::fund()` function between sequence number validation and transaction execution, allowing attackers to bypass the faucet's protection against funding existing accounts. This enables faucet fund drainage through repeated exploitation.

## Finding Description

The `TransferFunder::fund()` function implements a security check to ensure only new (non-existent) accounts receive funding. However, a race condition window exists between checking account existence and executing the transfer transaction. [1](#0-0) 

The function calls `update_sequence_numbers()` which queries on-chain state to determine if the receiver account exists. [2](#0-1) 

If the account exists, the faucet rejects the request: [3](#0-2) 

However, after this check passes, there is a critical gap before transaction execution: [4](#0-3) 

The transaction calls `aptos_account::transfer`, which explicitly handles both existing and non-existing accounts: [5](#0-4) 

**The Critical Gap**: If another transaction creates the receiver account between the sequence number check (line 284-293) and transaction execution (line 314-320), the Move function will skip account creation and successfully transfer funds to the now-existing account.

This directly contradicts the misleading code comment claiming "The transaction we submit ensures that the account doesn't exist already": [6](#0-5) 

**Attack Scenario**:
1. Attacker submits faucet request for address X
2. Faucet checks account doesn't exist (passes validation)
3. Attacker or concurrent request creates account X via separate transaction
4. Faucet's transaction executes—`aptos_account::transfer` detects existing account, skips creation, transfers funds
5. Attacker receives funds for existing account, bypassing intended restriction
6. Repeat to drain faucet funds

## Impact Explanation

This vulnerability allows **Medium Severity** impact per Aptos bug bounty criteria: "Limited funds loss or manipulation."

**Concrete Harm**:
- Attackers can receive multiple fundings for the same account across concurrent requests
- Faucet funds can be systematically drained through timing exploitation
- The faucet's core access control guarantee (only fund new accounts) is violated
- Faucet operators incur gas costs for transactions that should have been rejected

**Affected Component**: All deployed faucet instances using `TransferFunder` are vulnerable.

## Likelihood Explanation

**Likelihood: HIGH**

**Attack Requirements**:
- No special privileges required—any user can submit faucet requests
- Attack complexity is LOW—simple concurrent request timing
- No need for validator access or insider knowledge
- Exploitable with standard blockchain transaction submission

**Exploitation Feasibility**:
- Attacker submits faucet request for address X
- Immediately submits separate transaction to create account X (or uses another faucet instance)
- Timing window is ~seconds (typical block time), easily achievable
- Can be automated for systematic fund drainage
- Multiple concurrent faucet instances increase race window

**Detection Difficulty**: The faucet logs show successful transactions with no indication of invariant violation, making exploitation difficult to detect.

## Recommendation

**Fix 1: Use Assert-on-Create Transaction Pattern**

Replace `aptos_account::transfer` with a strict two-step approach that aborts if the account already exists:

```rust
// In transfer.rs, replace line 317 with:
let txn = self
    .execute_transaction(
        &client,
        // Use custom entry function that aborts if account exists
        aptos_stdlib::aptos_account_create_account(receiver_address),
        &receiver_address,
    )
    .await?;
// Follow with a second transaction for the transfer
```

Create a Move entry function that enforces the invariant:

```move
// In aptos_account.move, add:
public entry fun create_account_and_transfer(to: address, amount: u64) {
    // This will abort with EACCOUNT_ALREADY_EXISTS if account exists
    create_account(to);
    // Only reached if account was just created
    transfer(&create_signer(@aptos_framework), to, amount);
}
```

**Fix 2: Optimistic Lock with On-Chain Validation**

Add a nonce/timestamp field to track when the account existence check was performed, and validate it hasn't changed:

```rust
// Store the on-chain version/timestamp when checking
let check_version = client.get_ledger_information().await?.version;
// In Move, validate the account didn't exist at that version
```

**Fix 3: Update Documentation**

Correct the misleading comment to accurately reflect that race conditions exist and can be exploited: [6](#0-5) 

## Proof of Concept

```rust
// Rust integration test demonstrating the race condition
#[tokio::test]
async fn test_faucet_race_condition_exploit() {
    // Setup: Deploy faucet with TransferFunder
    let faucet = setup_test_faucet().await;
    let victim_address = generate_new_address();
    
    // Attack: Submit concurrent requests
    let faucet_request = faucet.fund(
        Some(100_000_000), 
        victim_address, 
        None, 
        false, 
        false
    );
    
    // Concurrently create the account
    let create_account = tokio::spawn(async move {
        tokio::time::sleep(Duration::from_millis(100)).await;
        create_account_via_direct_transaction(victim_address).await
    });
    
    // Both should succeed - faucet funds existing account
    let (faucet_result, create_result) = tokio::join!(faucet_request, create_account);
    
    assert!(faucet_result.is_ok(), "Faucet should succeed");
    assert!(create_result.unwrap().is_ok(), "Account creation should succeed");
    
    // Verify: Account was funded despite existing
    let balance = get_account_balance(victim_address).await;
    assert_eq!(balance, 100_000_000, "Account received faucet funds");
    
    // Repeat to demonstrate drainage potential
    for _ in 0..10 {
        let result = faucet.fund(Some(100_000_000), victim_address, None, false, false);
        // Some will succeed due to race window
    }
}
```

**Notes**

This vulnerability exists because the on-chain enforcement assumed by the Rust code comment does not match the actual Move implementation behavior. The `aptos_account::transfer` function is designed for general-purpose transfers that gracefully handle both existing and non-existing accounts, but the faucet requires strict enforcement that accounts must not exist. The race window is exploitable on any network with non-zero block time, making this a practical attack vector for faucet fund drainage.

### Citations

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L255-260)
```rust
    /// receiver account does not yet exist. These are not meant to completely
    /// verify these preconditions, as there could be races between the checks
    /// and the transaction submission between requests, but it reduces the
    /// prevalence of transaction failure. The transaction we submit ensures
    /// that the account doesn't exist already, so that's our real guarantee,
    /// the prior checks are just to avoid paying gas if we don't need to.
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L284-293)
```rust
        let (_funder_seq_num, receiver_seq_num) = update_sequence_numbers(
            &client,
            &self.faucet_account,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.wait_for_outstanding_txns_secs,
            DEFAULT_ASSET_NAME,
        )
        .await?;
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L297-306)
```rust
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L314-320)
```rust
            let txn = self
                .execute_transaction(
                    &client,
                    aptos_stdlib::aptos_account_transfer(receiver_address, amount),
                    &receiver_address,
                )
                .await?;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L311-339)
```rust
async fn get_sequence_numbers(
    client: &Client,
    funder_account: &RwLock<LocalAccount>,
    receiver_address: AccountAddress,
) -> Result<(u64, Option<u64>), AptosTapError> {
    let funder_address = funder_account.read().await.address();
    let f_request = client.get_account(funder_address);
    let r_request = client.get_account(receiver_address);
    let mut responses = futures::future::join_all([f_request, r_request]).await;

    let receiver_seq_num = responses
        .remove(1)
        .as_ref()
        .ok()
        .map(|account| account.inner().sequence_number);

    let funder_seq_num = responses
        .remove(0)
        .map_err(|e| {
            AptosTapError::new(
                format!("funder account {} not found: {:#}", funder_address, e),
                AptosTapErrorCode::AccountDoesNotExist,
            )
        })?
        .inner()
        .sequence_number;

    Ok((funder_seq_num, receiver_seq_num))
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-97)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```
