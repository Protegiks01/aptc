# Audit Report

## Title
Version Inflation Attack in Indexer GRPC Manager Causes Request Routing Failures and Performance Degradation

## Summary
The `handle_fullnode_info()` function in the indexer-grpc-manager accepts `known_latest_version` values from fullnodes without validation, allowing a malicious or compromised fullnode to send an arbitrarily inflated version number (e.g., `u64::MAX`). This causes systematic request routing failures, permanent false "lagging" state detection, and metric pollution across the indexer infrastructure.

## Finding Description

The vulnerability exists in the `MetadataManager::handle_fullnode_info()` function, which processes fullnode status information without validating the reported `known_latest_version` against reasonable bounds. [1](#0-0) 

The function accepts fullnode info and unconditionally:
1. Stores the inflated version in the fullnode's `recent_states`
2. Updates the global `known_latest_version` via `fetch_max`, which permanently raises the system-wide version tracker [2](#0-1) 

**Attack Flow:**

1. **Configuration Phase**: Fullnode addresses are statically configured without authentication of reported data [3](#0-2) 

2. **Infection Phase**: A malicious fullnode sends a ping response with `known_latest_version` set to an inflated value (e.g., `u64::MAX` or `18446744073709551615`) [4](#0-3) 

3. **Propagation Phase**: The inflated version spreads through the system via `fetch_max`, permanently corrupting the global `known_latest_version`

**Impact 1: Request Routing Failures**

When `get_fullnode_for_request()` selects a fullnode for data retrieval, it filters candidates based on whether their `known_latest_version >= request.starting_version`: [5](#0-4) 

The malicious fullnode will always pass the filter (since its inflated version exceeds any request), but when selected, it cannot serve the requested data, causing request failures. While there's a fallback mechanism, this causes:
- Repeated request retries and latency spikes
- Error counter increments degrading service metrics
- Unnecessary load cycling through fullnodes

**Impact 2: Permanent False "Lagging" Detection**

The `lagging()` function determines if the cache should fallback to fullnode fetching: [6](#0-5) 

With `known_latest_version` inflated to `u64::MAX`, the condition `cache_next_version + 20000 < u64::MAX` is **always true**, causing:
- Continuous unnecessary fallback to fullnode data fetching
- Bypassing efficient cache usage even when cache is current
- Sustained increased load on fullnode infrastructure [7](#0-6) 

**Impact 3: Monitoring and Metrics Pollution**

The inflated version is published to Prometheus metrics, corrupting observability: [2](#0-1) 

This causes false alerts, incorrect dashboards, and loss of operational visibility.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Continuous false lagging state causes increased load on fullnodes serving validator infrastructure
- **API crashes/degradation**: Request routing failures and fallback loops degrade API responsiveness
- **Significant protocol violations**: The indexer-grpc system's reliability guarantee is violated

The attack does not directly affect consensus or cause fund loss, preventing Critical severity classification. However, it significantly degrades the availability and reliability of the indexer infrastructure, which is critical for dApp functionality, API services, and blockchain data access.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Requirements**: Only requires a single compromised or malicious fullnode in the configured `fullnode_addresses` list
- **No Authentication**: Fullnode data reports are trusted without cryptographic verification or sanity checks
- **Persistent Impact**: Once the inflated version is set via `fetch_max`, it permanently affects the system until restart
- **Trivial Execution**: Simply returning an inflated `known_latest_version` in the ping response executes the attack

The vulnerability can be triggered accidentally by a buggy fullnode implementation or deliberately by a malicious actor who compromises a configured fullnode.

## Recommendation

Implement multi-layered validation in `handle_fullnode_info()`:

```rust
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // Validate chain_id matches expected value
    if info.chain_id != self.chain_id {
        bail!("Chain ID mismatch: expected {}, got {}", self.chain_id, info.chain_id);
    }
    
    let mut entry = self
        .fullnodes
        .entry(address.clone())
        .or_insert(Fullnode::new(address.clone()));
    
    // Validate known_latest_version is reasonable
    if let Some(reported_version) = info.known_latest_version {
        let current_known = self.get_known_latest_version();
        
        // Reject versions that are suspiciously far ahead (>10M versions ahead)
        const MAX_VERSION_JUMP: u64 = 10_000_000;
        if current_known > 0 && reported_version > current_known + MAX_VERSION_JUMP {
            warn!(
                "Rejecting suspicious version from fullnode {}: reported={}, current={}, delta={}",
                address, reported_version, current_known, reported_version - current_known
            );
            COUNTER
                .with_label_values(&["rejected_version_too_high"])
                .inc();
            return Ok(());
        }
        
        // Additional sanity check: reject u64::MAX or near-MAX values
        if reported_version > u64::MAX - 1000 {
            warn!("Rejecting near-MAX version from fullnode {}: {}", address, reported_version);
            COUNTER
                .with_label_values(&["rejected_version_near_max"])
                .inc();
            return Ok(());
        }
        
        trace!(
            "Accepted known_latest_version ({}) from fullnode {}.",
            reported_version, address
        );
        self.update_known_latest_version(reported_version);
    }
    
    entry.value_mut().recent_states.push_back(info);
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

**Additional Recommendations:**
1. Implement fullnode reputation scoring based on historical accuracy
2. Add cross-validation against multiple fullnodes before accepting extreme version jumps
3. Implement rate-limiting on version updates per fullnode
4. Add alerting for suspicious version reports
5. Consider cryptographic attestation of fullnode version reports

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_indexer_grpc_utils::timestamp_now_proto;
    
    #[test]
    fn test_version_inflation_attack() {
        // Setup: Create MetadataManager with one fullnode
        let metadata_manager = MetadataManager::new(
            1, // chain_id
            "http://manager:50051".to_string(),
            vec![],
            vec!["http://malicious-fn:50052".to_string()],
            None,
        );
        
        // Verify initial state
        assert_eq!(metadata_manager.get_known_latest_version(), 0);
        
        // Attack: Malicious fullnode sends inflated version
        let malicious_info = FullnodeInfo {
            chain_id: 1,
            timestamp: Some(timestamp_now_proto()),
            known_latest_version: Some(u64::MAX), // INFLATED VALUE
        };
        
        let result = metadata_manager.handle_fullnode_info(
            "http://malicious-fn:50052".to_string(),
            malicious_info
        );
        
        assert!(result.is_ok());
        
        // Verify attack success: Global version now corrupted
        assert_eq!(metadata_manager.get_known_latest_version(), u64::MAX);
        
        // Demonstrate Impact 1: Request routing failure
        let request = GetTransactionsFromNodeRequest {
            starting_version: Some(1000),
            transactions_count: Some(100),
        };
        
        let (selected_address, _client) = metadata_manager.get_fullnode_for_request(&request);
        // Malicious fullnode will be selected since u64::MAX >= 1000
        assert_eq!(selected_address, "http://malicious-fn:50052");
        // But actual request will FAIL because fullnode doesn't have version 1000
        
        // Demonstrate Impact 2: Permanent lagging state
        // If cache is at version 5000, lagging() will always return true
        // because 5000 + 20000 < u64::MAX is always true
        assert!(metadata_manager.get_known_latest_version() > 5000 + 20000);
    }
    
    #[test]
    fn test_version_inflation_via_ping() {
        // Simulate the full attack via ping endpoint
        let service_context = create_test_service_context();
        let fullnode_service = FullnodeDataService {
            service_context,
            abort_handle: Arc::new(AtomicBool::new(false)),
        };
        
        // Normal fullnode would report actual synced version
        // Malicious fullnode crafts response with inflated version
        let malicious_response = PingFullnodeResponse {
            info: Some(FullnodeInfo {
                chain_id: 1,
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(u64::MAX),
            }),
        };
        
        // When metadata_manager processes this response,
        // it will update global known_latest_version to u64::MAX
        // causing all the described impacts
    }
}
```

**Runtime Demonstration Steps:**
1. Deploy indexer-grpc-manager with configured fullnode
2. Compromise or simulate malicious fullnode
3. Send ping response with `known_latest_version: u64::MAX`
4. Observe: Global version jumps to u64::MAX
5. Observe: All subsequent requests show lagging=true
6. Observe: Malicious fullnode repeatedly selected for requests
7. Observe: Request failures and performance degradation

## Notes

This vulnerability is particularly insidious because:
- The impact is **permanent** until service restart (due to `fetch_max` monotonic update)
- It affects **all** components relying on `known_latest_version`
- It can be triggered **accidentally** by buggy fullnode implementations
- The attack requires **no special privileges** beyond being a configured fullnode
- Current monitoring may not detect the attack as "abnormal" since metrics will show the inflated version as legitimate

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L341-374)
```rust
    pub(crate) fn get_fullnode_for_request(
        &self,
        request: &GetTransactionsFromNodeRequest,
    ) -> (GrpcAddress, FullnodeDataClient<Channel>) {
        // TODO(grao): Double check the counters to see if we need a different way or additional
        // information.
        let mut rng = thread_rng();
        if let Some(fullnode) = self
            .fullnodes
            .iter()
            .filter(|fullnode| {
                fullnode
                    .recent_states
                    .back()
                    .is_some_and(|s| s.known_latest_version >= request.starting_version)
            })
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
        {
            COUNTER
                .with_label_values(&["get_fullnode_for_request__happy"])
                .inc();
            return fullnode;
        }

        COUNTER
            .with_label_values(&["get_fullnode_for_request__fallback"])
            .inc();
        self.fullnodes
            .iter()
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
            .unwrap()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L405-409)
```rust
    fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
        KNOWN_LATEST_VERSION.set(version as i64);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L31-42)
```rust
pub struct IndexerGrpcManagerConfig {
    pub(crate) chain_id: u64,
    pub(crate) service_config: ServiceConfig,
    #[serde(default = "default_cache_config")]
    pub(crate) cache_config: CacheConfig,
    pub(crate) file_store_config: IndexerGrpcFileStoreConfig,
    pub(crate) self_advertised_address: GrpcAddress,
    pub(crate) grpc_manager_addresses: Vec<GrpcAddress>,
    pub(crate) fullnode_addresses: Vec<GrpcAddress>,
    pub(crate) is_master: bool,
    pub(crate) allow_fn_fallback: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L207-242)
```rust
    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        let timestamp = timestamp_now_proto();
        let known_latest_version = self
            .service_context
            .context
            .db
            .get_synced_version()
            .map_err(|e| Status::internal(format!("{e}")))?;

        let table_info_version = self
            .service_context
            .context
            .indexer_reader
            .as_ref()
            .and_then(|r| r.get_latest_table_info_ledger_version().ok().flatten());

        if known_latest_version.is_some() && table_info_version.is_some() {
            let version = std::cmp::min(known_latest_version.unwrap(), table_info_version.unwrap());
            if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
                let latency = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
                    - Duration::from_micros(timestamp_us);
                LATENCY_MS.set(latency.as_millis() as i64);
            }
        }

        let info = FullnodeInfo {
            chain_id: self.service_context.context.chain_id().id() as u64,
            timestamp: Some(timestamp),
            known_latest_version,
        };
        let response = PingFullnodeResponse { info: Some(info) };
        Ok(Response::new(response))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L284-287)
```rust
    pub(crate) fn lagging(&self, cache_next_version: u64) -> bool {
        // TODO(grao): Need a better way, we can use the information in the metadata_manager.
        cache_next_version + 20000 < self.metadata_manager.get_known_latest_version()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L289-329)
```rust
    pub(crate) async fn get_transactions(
        &self,
        start_version: u64,
        max_size_bytes_from_cache: usize,
    ) -> Result<Vec<Transaction>> {
        let cache = self.cache.read().await;
        let cache_start_version = cache.start_version;
        let cache_next_version = cache_start_version + cache.transactions.len() as u64;
        drop(cache);

        if start_version >= cache_start_version {
            if start_version >= cache_next_version {
                // If lagging, try to fetch the data from FN.
                if self.lagging(cache_next_version) && self.allow_fn_fallback {
                    debug!("GrpcManager is lagging, getting data from FN, requested_version: {start_version}, cache_next_version: {cache_next_version}.");
                    let request = GetTransactionsFromNodeRequest {
                        starting_version: Some(start_version),
                        transactions_count: Some(5000),
                    };

                    let (_, mut fullnode_client) =
                        self.metadata_manager.get_fullnode_for_request(&request);
                    let response = fullnode_client.get_transactions_from_node(request).await?;
                    let mut response = response.into_inner();
                    while let Some(Ok(response_item)) = response.next().await {
                        if let Some(response) = response_item.response {
                            match response {
                                Response::Data(data) => {
                                    return Ok(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        }
                    }
                }

                tokio::time::sleep(Duration::from_millis(200)).await;

                // Let client side to retry.
                return Ok(vec![]);
            }
```
