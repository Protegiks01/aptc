# Audit Report

## Title
Environment Variable Leakage in Backup CLI Command Adapter Subprocess Spawning

## Summary
The backup CLI's CommandAdapter spawns bash subprocesses that inherit ALL environment variables from the parent process without clearing them first. This violates the principle of least privilege and could expose sensitive credentials (cloud storage keys, monitoring tokens, etc.) to user-configurable bash commands defined in backup configuration files.

## Finding Description

The vulnerability exists in the subprocess spawning mechanism within the backup CLI's CommandAdapter implementation. [1](#0-0) 

When spawning bash commands, the code creates a `tokio::process::Command` and sets explicit environment variables from `config_env_vars` and `param_env_vars`, but crucially **does not call `.env_clear()`** before doing so. This means the spawned bash process inherits the complete environment from the parent backup process.

The backup configuration allows operators to define arbitrary bash commands: [2](#0-1) 

In production deployments, the backup process has access to sensitive cloud storage credentials: [3](#0-2) 

These credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, Azure SAS tokens, GCS credentials) are necessary for backup operations, but they become accessible to ALL bash commands defined in the configuration file.

**Existing test proves environment inheritance:** [4](#0-3) 

This test explicitly demonstrates that environment variables set in the parent process (`MYVAR2343u2`) are accessible to spawned bash commands, confirming that environment inheritance is occurring.

## Impact Explanation

**Severity: Medium** ($10,000 tier per Aptos Bug Bounty)

The impact qualifies as Medium severity because:

1. **Limited Information Disclosure**: An attacker who can modify the backup configuration file could inject commands to exfiltrate cloud storage credentials. For example:
   ```bash
   echo "$AWS_SECRET_ACCESS_KEY" | aws s3 cp - s3://$BUCKET/leaked_credentials.txt
   ```

2. **State Inconsistencies**: Compromised backup credentials could lead to:
   - Deletion or tampering of backup data
   - Loss of ability to restore blockchain state after catastrophic failure
   - This constitutes "state inconsistencies requiring intervention"

3. **Defense in Depth Violation**: While the backup process legitimately needs these credentials, exposing them to user-configurable bash scripts creates unnecessary attack surface.

This does NOT qualify as Critical or High severity because:
- No direct loss of validator funds
- No consensus safety violations
- No validator node compromise (requires pre-existing config file access)
- Limited to backup infrastructure security

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:

1. **Attacker Capability**: Write access to the backup configuration file or Kubernetes ConfigMap
   - In Kubernetes deployments: Requires RBAC permissions to modify ConfigMaps
   - In standalone deployments: Requires filesystem access to the config file

2. **Trigger Condition**: Backup must run after the malicious config is deployed
   - Continuous backups run automatically at configured intervals
   - Manual backups can be triggered by operators

3. **Realistic Scenarios**:
   - Compromised CI/CD pipeline that deploys Kubernetes configurations
   - Insider threat from operator with config management access
   - Vulnerable config management system (e.g., exposed Git repository)
   - Supply chain attack on backup configuration templates

The likelihood is not Low because backup configuration is often stored in version control systems or config management platforms that have broader access than the validator nodes themselves, creating a realistic attack vector.

## Recommendation

**Fix: Clear environment before setting specific variables**

Modify the spawn function to explicitly clear all environment variables before setting the required ones:

```rust
pub fn spawn(command: Command) -> Result<Self> {
    debug!("Spawning {:?}", command);

    let mut cmd = tokio::process::Command::new("bash");
    cmd.args(["-c", &command.cmd_str]);
    cmd.stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::inherit());
    
    // SECURITY FIX: Clear all inherited environment variables
    cmd.env_clear();
    
    // Only set explicitly required environment variables
    for v in command
        .config_env_vars
        .iter()
        .chain(command.param_env_vars.iter())
    {
        cmd.env(&v.key, &v.value);
    }
    let child = cmd.spawn().err_notes(&cmd)?;
    // ... rest of function
}
```

Additionally, ensure that only the minimum required environment variables are passed through `config_env_vars`:
- `BUCKET`, `SUB_DIR`, `CONTAINER`, etc. for storage configuration
- Cloud CLI tools (aws, gsutil, azcopy) should authenticate via credential files or instance roles when possible, not environment variables

## Proof of Concept

**Demonstration Test:**

Create a test file `storage/backup/backup-cli/src/storage/command_adapter/test_env_leak.rs`:

```rust
use super::*;
use std::env;

#[tokio::test]
async fn test_environment_variable_leakage() {
    // Set a sensitive environment variable in parent process
    env::set_var("SENSITIVE_SECRET_KEY", "super_secret_value_12345");
    
    // Create a command that attempts to access this variable
    let config = CommandAdapterConfig {
        commands: Commands {
            create_backup: "echo $SENSITIVE_SECRET_KEY".to_string(),
            create_for_write: "echo ok".to_string(),
            open_for_read: "echo ok".to_string(),
            save_metadata_line: "echo ok".to_string(),
            list_metadata_files: "echo ok".to_string(),
            backup_metadata_file: None,
        },
        env_vars: vec![],
    };
    
    let adapter = CommandAdapter::new(config);
    let backup_name = ShellSafeName::from_str("test_backup").unwrap();
    
    // Execute the backup command
    let result = adapter.create_backup(&backup_name).await.unwrap();
    
    // VULNERABILITY: The spawned bash command can access SENSITIVE_SECRET_KEY
    // even though it was never explicitly passed in config_env_vars
    assert_eq!(result.trim(), "super_secret_value_12345");
    
    // Clean up
    env::remove_var("SENSITIVE_SECRET_KEY");
}

#[tokio::test]
async fn test_environment_cleared_after_fix() {
    // After applying the fix with env_clear(), this test should pass
    env::set_var("SENSITIVE_SECRET_KEY", "super_secret_value_12345");
    
    let config = CommandAdapterConfig {
        commands: Commands {
            // With env_clear(), unset variables cause bash to fail with -o nounset
            create_backup: "echo ${SENSITIVE_SECRET_KEY:-NOT_SET}".to_string(),
            create_for_write: "echo ok".to_string(),
            open_for_read: "echo ok".to_string(),
            save_metadata_line: "echo ok".to_string(),
            list_metadata_files: "echo ok".to_string(),
            backup_metadata_file: None,
        },
        env_vars: vec![],
    };
    
    let adapter = CommandAdapter::new(config);
    let backup_name = ShellSafeName::from_str("test_backup").unwrap();
    let result = adapter.create_backup(&backup_name).await.unwrap();
    
    // After fix: Variable should not be accessible, default to "NOT_SET"
    assert_eq!(result.trim(), "NOT_SET");
    
    env::remove_var("SENSITIVE_SECRET_KEY");
}
```

**To run:**
```bash
cd storage/backup/backup-cli
cargo test test_environment_variable_leakage -- --nocapture
```

The first test demonstrates the vulnerability by showing that environment variables from the parent process are accessible to spawned commands. The second test validates the fix by confirming that after calling `env_clear()`, only explicitly passed variables are available.

## Notes

This vulnerability represents a **defense-in-depth** failure in the backup CLI's subprocess handling. While the backup process legitimately requires cloud storage credentials to function, the current implementation exposes ALL environment variables to user-configurable bash commands, violating the principle of least privilege. An attacker with configuration file access could exfiltrate these credentials, potentially leading to backup data compromise and loss of disaster recovery capabilities for the Aptos blockchain.

### Citations

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L65-80)
```rust
    pub fn spawn(command: Command) -> Result<Self> {
        debug!("Spawning {:?}", command);

        let mut cmd = tokio::process::Command::new("bash");
        cmd.args(["-c", &command.cmd_str]);
        cmd.stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit());
        for v in command
            .config_env_vars
            .iter()
            .chain(command.param_env_vars.iter())
        {
            cmd.env(&v.key, &v.value);
        }
        let child = cmd.spawn().err_notes(&cmd)?;
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/s3.sample.yaml (L7-33)
```yaml
  create_backup: |
    # backup handle is the same with input backup name, output to stdout
    echo "$BACKUP_NAME"
  create_for_write: |
    # file handle is the file name under the folder with the name of the backup handle
    FILE_HANDLE="$BACKUP_HANDLE/$FILE_NAME"
    # output file handle to stdout
    echo "$FILE_HANDLE"
    # close stdout
    exec 1>&-
    # route stdin to file handle
    gzip -c | aws s3 cp - "s3://$BUCKET/$SUB_DIR/$FILE_HANDLE"
  open_for_read: |
    # route file handle content to stdout
    aws s3 cp "s3://$BUCKET/$SUB_DIR/$FILE_HANDLE" - | gzip -cd
  save_metadata_line: |
    # save the line to a new file under the metadata folder
    FILE_HANDLE="metadata/$FILE_NAME"
    echo "$FILE_HANDLE"
    exec 1>&-
    gzip -c | aws s3 cp - "s3://$BUCKET/$SUB_DIR/$FILE_HANDLE"
  list_metadata_files: |
    # list files under the metadata folder
    (aws s3 ls s3://$BUCKET/$SUB_DIR/metadata/ ||:) | sed -ne "s#.* \(.*\)#metadata/\1#p"
  backup_metadata_file: |
    # move metadata file to metadata backup folder
    aws s3 mv s3://$BUCKET/$SUB_DIR/metadata/$FILE_NAME s3://$BUCKET/$SUB_DIR/metadata_backup/$FILE_NAME --no-progress
```

**File:** terraform/helm/fullnode/templates/_backup.tpl (L28-37)
```text
- name: AWS_ACCESS_KEY_ID
  valueFrom:
    secretKeyRef:
      name: r2-credentials
      key: access-key-id
- name: AWS_SECRET_ACCESS_KEY
  valueFrom:
    secretKeyRef:
      name: r2-credentials
      key: secret-access-key
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/tests.rs (L169-182)
```rust
fn test_unset_env_var() {
    // TODO: Audit that the environment access only happens in single-threaded code.
    unsafe { std::env::remove_var("MYVAR2343u2") };
    block_on(assert_commands_error(
        "echo $MYVAR2343u2 > /dev/null; echo okay; exec 1>&-; cat > /dev/null",
    ));

    // variable set
    // TODO: Audit that the environment access only happens in single-threaded code.
    unsafe { std::env::set_var("MYVAR2343u2", "hehe") };
    block_on(assert_commands_okay(
        "echo $MYVAR2343u2 > /dev/null; echo okay; exec 1>&-; cat > /dev/null",
    ));
}
```
