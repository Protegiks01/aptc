# Audit Report

## Title
Critical Cross-Shard Abort Coordination Failure Causing Node Crashes and State Divergence

## Summary
The sharded block executor lacks a coordinated abort protocol for cross-shard transactions. When a transaction with cross-shard dependencies aborts due to a fatal VM error, the `CrossShardCommitSender::on_execution_aborted` hook is unimplemented (marked as `todo!()`), causing the shard to panic and crash. Even if the panic were handled, dependent shards would deadlock indefinitely waiting for values that never arrive, violating consensus safety and causing total network liveness failure.

## Finding Description

The Aptos sharded block executor implements cross-shard communication through a commit hook mechanism. When transactions execute successfully, they send write operations to dependent shards via `CrossShardCommitSender`. However, the abort coordination path is completely unimplemented. [1](#0-0) 

When a transaction encounters a fatal VM error during execution, the block executor's commit sequencing logic calls the `on_execution_aborted` method on the transaction commit hook: [2](#0-1) 

This occurs when the output status is `Abort`, which is set when `ExecutionStatus::Abort(err)` is returned from VM execution: [3](#0-2) 

Fatal VM errors (such as `FatalVMError`, `SpeculativeExecutionAbortError`, or `DelayedFieldsCodeInvariantError`) trigger this abort path: [4](#0-3) 

**Attack Scenario:**

1. Attacker submits a transaction that will be assigned to Shard A
2. The transaction has cross-shard dependencies - it writes to state keys that transactions in Shard B depend on
3. The partitioner creates `dependent_edges` from Shard A to Shard B based on these dependencies: [5](#0-4) 

4. Shard B initializes `RemoteStateValue` entries in waiting state for the required keys: [6](#0-5) 

5. The attacker's transaction triggers a fatal VM error during execution on Shard A
6. The block executor calls `on_execution_aborted`, which panics due to `todo!()`, crashing the shard thread
7. Even if the panic were caught, Shard B's execution threads remain blocked indefinitely in `RemoteStateValue::get_value()`: [7](#0-6) 

The `while` loop at line 32-34 waits on a condition variable that will **never** be signaled because no abort message is sent to dependent shards.

**State Divergence Mechanism:**

Without coordinated abort handling, different shards process the failure differently:
- Shard A crashes or marks transactions as failed
- Shard B remains blocked waiting for values
- Other shards may continue executing their sub-blocks
- No rollback or recovery mechanism exists to restore consistency
- The block execution never completes, causing permanent liveness failure

This violates the critical invariant: **"State Consistency: State transitions must be atomic and verifiable via Merkle proofs"** and **"Deterministic Execution: All validators must produce identical state roots for identical blocks"**.

The test suite explicitly acknowledges this limitation: [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **CRITICAL** severity under the Aptos Bug Bounty program for multiple reasons:

**1. Node Crashes via Panic:** The `todo!()` macro causes immediate panic, crashing the shard's execution thread and potentially the entire node process.

**2. Total Loss of Liveness:** Even with panic handling, dependent shards deadlock permanently. Block execution cannot complete, freezing the entire network. This meets the criterion: "Total loss of liveness/network availability" (up to $1,000,000).

**3. Consensus Safety Violation:** Different nodes may handle the crash differently depending on timing and error recovery mechanisms. Some nodes might:
   - Crash completely and restart
   - Timeout and retry (if external timeouts exist)
   - Mark the block as failed while others succeed

This non-deterministic behavior causes validators to produce different state roots for the same block, violating consensus safety. This meets: "Consensus/Safety violations" (up to $1,000,000).

**4. Non-Recoverable Network Partition:** Without a coordinated rollback protocol, the network cannot recover from this state without manual intervention or a hard fork. This meets: "Non-recoverable network partition (requires hardfork)" (up to $1,000,000).

**5. No Two-Phase Commit Protocol:** The system optimistically sends commit messages but lacks:
   - A prepare phase to ensure all shards can commit
   - A rollback mechanism when any shard aborts
   - Timeout or failure detection for missing messages
   - Coordinated transaction status across shards

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

**Ease of Triggering:**
- Any transaction sender can attempt to trigger fatal VM errors
- No special privileges or validator access required
- Multiple error types can trigger the abort path (FatalVMError, SpeculativeExecutionAbortError, DelayedFieldsCodeInvariantError)
- Cross-shard dependencies are automatically created by the partitioner for transactions that touch state across shard boundaries

**Attack Complexity:**
- Low - Simply submit transactions designed to cause VM errors
- Examples: malformed Move bytecode, resource exhaustion, invariant violations
- Attacker can target specific state keys to ensure cross-shard dependencies

**Detection Difficulty:**
- The vulnerability is in production code paths
- Sharded execution is actively being deployed and tested
- No runtime checks prevent this scenario

**Current Status:**
Tests for cross-shard conflicts are explicitly disabled (marked `#[ignore]`) with acknowledgment that "it doesn't work for now," indicating the developers are aware of limitations but the code is still deployable.

## Recommendation

Implement a proper two-phase commit protocol with coordinated abort handling:

**1. Add Abort Message Type:**
```rust
// In messages.rs
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    AbortMsg(TxnIndex), // NEW: Signal transaction abort
    StopMsg,
}
```

**2. Implement Abort Coordination:**
```rust
// In cross_shard_client.rs
fn on_execution_aborted(&self, txn_idx: TxnIndex) {
    let global_txn_idx = txn_idx + self.index_offset;
    if let Some(edges) = self.dependent_edges.get(&global_txn_idx) {
        // Notify all dependent shards about the abort
        for (state_key, dependent_shard_ids) in edges.iter() {
            for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                let message = CrossShardMsg::AbortMsg(global_txn_idx);
                if *round_id == GLOBAL_ROUND_ID {
                    self.cross_shard_client.send_global_msg(message);
                } else {
                    self.cross_shard_client.send_cross_shard_msg(
                        *dependent_shard_id,
                        *round_id,
                        message,
                    );
                }
            }
        }
    }
}
```

**3. Handle Abort Messages in Receiver:**
```rust
// In cross_shard_client.rs, CrossShardCommitReceiver::start()
loop {
    let msg = cross_shard_client.receive_cross_shard_msg(round);
    match msg {
        RemoteTxnWriteMsg(txn_commit_msg) => {
            // existing code
        },
        AbortMsg(txn_idx) => {
            // Signal abort to waiting threads - set value to None or error state
            // This unblocks dependent transactions
            // Trigger rollback of dependent transactions
            cross_shard_state_view.set_abort(txn_idx);
            break; // Exit and fail the entire sub-block execution
        },
        CrossShardMsg::StopMsg => {
            break;
        },
    }
}
```

**4. Add Timeout Protection:**
```rust
// In remote_state_value.rs
pub fn get_value_with_timeout(&self, timeout: Duration) -> Result<Option<StateValue>, TimeoutError> {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    let result = cvar.wait_timeout_while(status, timeout, |s| {
        matches!(s, RemoteValueStatus::Waiting)
    }).unwrap();
    
    if result.1.timed_out() {
        return Err(TimeoutError::CrossShardTimeout);
    }
    // ... rest of logic
}
```

**5. Implement Proper Error Propagation:**
Ensure that when any shard encounters an abort, the entire block execution fails atomically across all shards, maintaining consistency.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
#[should_panic(expected = "on_transaction_aborted not supported for sharded execution yet")]
fn test_cross_shard_abort_causes_panic() {
    use aptos_vm::sharded_block_executor::{
        local_executor_shard::LocalExecutorService, 
        ShardedBlockExecutor,
    };
    use aptos_block_partitioner::v2::config::PartitionerV2Config;
    
    let num_shards = 2;
    let client = LocalExecutorService::setup_local_executor_shards(num_shards, Some(2));
    let sharded_block_executor = ShardedBlockExecutor::new(client);
    let partitioner = PartitionerV2Config::default().build();
    
    // Create a transaction that:
    // 1. Will be assigned to shard 0
    // 2. Has dependencies that shard 1 needs
    // 3. Will trigger a FatalVMError during execution
    let txn_with_cross_shard_deps = create_transaction_that_aborts_with_cross_shard_deps();
    
    // This will panic when the transaction aborts and on_execution_aborted is called
    let result = sharded_block_executor.execute_block(
        Arc::new(FakeStateView::new()),
        partitioner.partition(vec![txn_with_cross_shard_deps]),
        4, // concurrency level
        BlockExecutorConfigFromOnchain::default(),
    );
    
    // Never reaches here - panics first
    assert!(result.is_err());
}

fn create_transaction_that_aborts_with_cross_shard_deps() -> AnalyzedTransaction {
    // Create a malformed Move transaction that will:
    // - Write to state key "key_A" (creates dependent edge to other shards)
    // - Cause a FatalVMError during execution (invalid bytecode, resource exhaustion, etc.)
    // Implementation details depend on transaction builder utilities
}
```

**Notes:**
- This vulnerability is a fundamental design flaw in the cross-shard coordination protocol
- The system assumes optimistic execution without failure handling
- Production deployment of sharded execution without fixing this issue would be catastrophic
- The explicit `todo!()` and ignored tests indicate known limitations, but the code is still reachable in production paths
- Requires immediate attention before sharded execution is enabled in mainnet

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L67-87)
```rust
        let mut dependent_edges = HashMap::new();
        let mut num_dependent_edges = 0;
        for (txn_idx, txn_with_deps) in sub_block.txn_with_index_iter() {
            let mut storage_locations_to_target = HashMap::new();
            for (txn_id_with_shard, storage_locations) in txn_with_deps
                .cross_shard_dependencies
                .dependent_edges()
                .iter()
            {
                for storage_location in storage_locations {
                    storage_locations_to_target
                        .entry(storage_location.clone().into_state_key())
                        .or_insert_with(HashSet::new)
                        .insert((txn_id_with_shard.shard_id, txn_id_with_shard.round_id));
                    num_dependent_edges += 1;
                }
            }
            if !storage_locations_to_target.is_empty() {
                dependent_edges.insert(txn_idx as TxnIndex, storage_locations_to_target);
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L175-177)
```rust
            ExecutionStatus::Abort(err) => {
                Self::empty_with_status(OutputStatusKind::Abort(format!("{:?}", err)))
            },
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L426-428)
```rust
            OutputStatusKind::Abort(_) => {
                txn_listener.on_execution_aborted(txn_idx);
            },
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L102-114)
```rust
                if err.status_code() == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                    ExecutionStatus::SpeculativeExecutionAbortError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else if err.status_code()
                    == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                {
                    ExecutionStatus::DelayedFieldsCodeInvariantError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else {
                    ExecutionStatus::Abort(err)
                }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L26-39)
```rust
    pub fn new(cross_shard_keys: HashSet<StateKey>, base_view: &'a S) -> Self {
        let mut cross_shard_data = HashMap::new();
        trace!(
            "Initializing cross shard state view with {} keys",
            cross_shard_keys.len(),
        );
        for key in cross_shard_keys {
            cross_shard_data.insert(key, RemoteStateValue::waiting());
        }
        Self {
            cross_shard_data,
            base_view,
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/tests/sharded_block_executor.rs (L38-42)
```rust
#[test]
#[ignore]
// Sharded execution with cross shard conflict doesn't work for now because we don't have
// cross round dependency tracking yet.
fn test_partitioner_v2_uniform_sharded_block_executor_with_conflict_parallel() {
```
