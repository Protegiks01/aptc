# Audit Report

## Title
Information Leakage Through Inconsistent Location Error Handling in Module Publishing

## Summary
The module publishing flow in `create_with_compat_config()` inconsistently handles error location information. While most errors correctly use `Location::Undefined`, several verification errors use `Location::Module(ModuleId)`, leaking module addresses and names in error messages during failed publishing attempts.

## Finding Description
The `create_with_compat_config()` function in publishing.rs properly sets `Location::Undefined` for most errors (lines 151, 170, 191, 216, 287). [1](#0-0) [2](#0-1) [3](#0-2) 

However, three error paths in the verification flow leak module location information:

1. **Cyclic Dependency Detection**: The `module_cyclic_dependency_error!` macro sets `Location::Module(ModuleId)` instead of `Location::Undefined`. [4](#0-3)  This error is triggered during module verification at [5](#0-4) 

2. **Native Struct Verification**: The `check_natives` function returns errors with `Location::Module(module.self_id())` when native structs are detected. [6](#0-5) 

3. **Type Argument Ability Verification**: Type argument verification failures use `Location::Module(module.self_id().clone())`. [7](#0-6) 

When these errors occur, the VMError Display implementation exposes the full module ID (address + name) in error messages: [8](#0-7) 

An attacker can craft malicious module bundles to intentionally trigger these error paths and extract information about:
- Internal module dependencies and their addresses
- Module existence and naming conventions  
- Implementation structure details

## Impact Explanation
This is a **Low Severity** information disclosure issue as categorized in the Aptos bug bounty program. It does not enable:
- Fund theft or manipulation
- Consensus safety violations
- Network availability issues
- State corruption

The leaked information is limited to module IDs and could be used for reconnaissance, but does not directly compromise system security or break any critical invariants.

## Likelihood Explanation
This issue occurs with 100% probability when users attempt to publish modules that:
- Form cyclic dependencies
- Contain native struct definitions
- Have type argument ability mismatches

Any user can trigger these conditions, making the information leak readily exploitable for reconnaissance purposes.

## Recommendation
Modify all three error paths to use `Location::Undefined` for consistency:

1. Update `module_cyclic_dependency_error!` macro to use `Location::Undefined`
2. Update `check_natives` to use `Location::Undefined`  
3. Update type argument verification to use `Location::Undefined`

This ensures defense-in-depth by preventing any implementation details from leaking through error messages during module publishing.

## Proof of Concept
```rust
// Test that triggers cyclic dependency error with location leak
// Create module A that depends on module B, and module B that depends on module A
// Attempt to publish both in a bundle
// Error message will contain: "Module 0x1::ModuleA forms a cyclic dependency"
// Instead of generic error with Location::Undefined

#[test]
fn test_cyclic_dependency_location_leak() {
    // Module A depends on B
    let module_a_bytes = compile_module_with_dependency(
        "0x1::A",
        vec!["0x1::B"]
    );
    
    // Module B depends on A (creates cycle)
    let module_b_bytes = compile_module_with_dependency(
        "0x1::B", 
        vec!["0x1::A"]
    );
    
    let result = StagingModuleStorage::create(
        &sender,
        &module_storage,
        vec![module_a_bytes, module_b_bytes]
    );
    
    // Error will leak "Module 0x1::A" or "Module 0x1::B" in location field
    assert!(result.is_err());
    let err = result.unwrap_err();
    // Location should be Undefined but is actually Module(0x1::A or 0x1::B)
}
```

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L151-151)
```rust
                        .finish(Location::Undefined)
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L170-170)
```rust
                .finish(Location::Undefined));
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L191-191)
```rust
                            .map_err(|e| e.finish(Location::Undefined))?;
```

**File:** third_party/move/move-vm/types/src/code/errors.rs (L46-48)
```rust
        .finish(move_binary_format::errors::Location::Module(
            move_core_types::language_storage::ModuleId::new(*$addr, $name.to_owned()),
        ))
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L411-414)
```rust
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L483-488)
```rust
            return Err(verification_error(
                StatusCode::MISSING_DEPENDENCY,
                IndexKind::FunctionHandle,
                idx as TableIndex,
            )
            .finish(Location::Module(module.self_id())));
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/traits.rs (L159-160)
```rust
        Type::verify_ty_arg_abilities(function.ty_param_abilities(), &ty_args)
            .map_err(|e| e.finish(Location::Module(module.self_id().clone())))?;
```

**File:** third_party/move/move-binary-format/src/errors.rs (L586-586)
```rust
            Location::Module(id) => write!(f, "Module {:?}", id),
```
