# Audit Report

## Title
State Inconsistency via Delayed Fields Layout Mismatch in Table Operations

## Summary
The `native_add_box()` function in table natives determines `contains_delayed_fields` based on the current VM configuration's `delayed_field_optimization_enabled` flag. When this flag changes between storing and loading table values containing aggregator types, the system uses incompatible layouts for serialization and deserialization, causing state inconsistency where delayed field IDs are interpreted as regular values or vice versa, bypassing aggregator semantics and potentially causing consensus divergence.

## Finding Description

The vulnerability exists in how table values with delayed fields (aggregators) are serialized and deserialized across different VM configurations. [1](#0-0) 

The `contains_delayed_fields` flag is computed from the type layout, which depends on `delayed_field_optimization_enabled`: [2](#0-1) 

When `delayed_field_optimization_enabled=true`, aggregator types get a `Native` layout wrapper. When false, they don't. [3](#0-2) 

**Critical Issue in Storage Loading:**

When loading values from storage, if `contains_delayed_fields=false`, the layout parameter is NOT passed to storage: [4](#0-3) 

This means no layout-based patching occurs in `patch_base_value`: [5](#0-4) 

**Attack Scenario:**

**Phase 1 (Feature Enabled):** When `AGGREGATOR_V2_DELAYED_FIELDS` feature is enabled: [6](#0-5) 

1. Aggregator value stored as `DelayedFieldID{id: 123}`
2. Layout: `Native(Aggregator, U128)`
3. Serialization converts ID to concrete U128 value (e.g., 456): [7](#0-6) 

4. Bytes stored: serialized U128(456), Layout: `Some(Native(...))`

**Phase 2 (Feature Disabled):** When feature is disabled or VM config differs:

1. Same table accessed with `contains_delayed_fields=false`
2. Layout: `Struct([U128])` (NO Native wrapper)
3. Storage called with `maybe_layout=None` 
4. Raw bytes (U128) returned without patching
5. Deserialization uses plain layout without delayed fields: [8](#0-7) 

6. **Result:** Regular `Value::U128(456)` instead of `DelayedFieldID`!

This bypasses aggregator API, allows direct access to aggregator values, and breaks the invariant that aggregators must be accessed through controlled native functions.

## Impact Explanation

**Critical Severity** - This meets multiple critical impact categories:

1. **Consensus/Safety Violation**: Different validators with different feature flag states will compute different state roots for identical blocks, violating the "Deterministic Execution" invariant. This can cause chain splits.

2. **State Consistency Violation**: The same data is interpreted differently based on transient VM configuration, breaking the fundamental invariant that "State transitions must be atomic and verifiable via Merkle proofs."

3. **Security Control Bypass**: Aggregators are designed to provide controlled concurrent access with validation. Direct value access bypasses all security checks, potentially enabling:
   - Unauthorized aggregator value manipulation
   - Breaking aggregator invariants (max values, bounds)
   - Resource pool corruption

4. **Potential Fund Loss**: If aggregators track financial resources (balances, rewards), incorrect interpretation could lead to double-spending or fund theft.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability will trigger whenever:

1. The `AGGREGATOR_V2_DELAYED_FIELDS` feature flag is toggled (during rollout or rollback)
2. Different validators have inconsistent feature configurations
3. Block executor vs non-executor contexts have different configs: [9](#0-8) 

The block executor explicitly enables delayed field optimization, while other contexts may not, creating immediate inconsistency risk.

**No special attacker privileges required** - This happens automatically when VM configurations differ.

## Recommendation

**Solution:** Store and validate the layout hash/flag with table values to detect configuration mismatches.

1. Extend `TableChange` to include a configuration hash:
```rust
pub struct TableChange {
    pub entries: BTreeMap<Vec<u8>, Op<(Bytes, Option<TriompheArc<MoveTypeLayout>>, u64)>>,
    // Add: config_hash field
}
```

2. When storing, include current `delayed_field_optimization_enabled` state

3. When loading, verify the stored configuration matches current configuration:
```rust
// In get_or_create_global_value
if stored_config_hash != current_config_hash {
    return Err(PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
        .with_message("Configuration mismatch for table value"));
}
```

4. For feature flag transitions, implement a migration that re-serializes all affected table values with the new layout

**Immediate mitigation:** Ensure `delayed_field_optimization_enabled` is consistent across all execution contexts and never changes after initial deployment for existing tables.

## Proof of Concept

```move
// test_delayed_field_layout_mismatch.move
module 0x1::test_layout_mismatch {
    use std::table;
    use aptos_framework::aggregator_v2::{Self, Aggregator};
    
    struct TestTable has key {
        data: table::Table<u64, Aggregator<u64>>
    }
    
    public entry fun store_aggregator(account: &signer) {
        // Phase 1: delayed_field_optimization_enabled=true
        // Stores aggregator as DelayedFieldID
        let agg = aggregator_v2::create_aggregator<u64>(1000);
        aggregator_v2::add(&mut agg, 456);
        
        let t = table::new<u64, Aggregator<u64>>();
        table::add(&mut t, 1, agg);
        
        move_to(account, TestTable { data: t });
    }
    
    public entry fun load_aggregator(addr: address): u64 acquires TestTable {
        // Phase 2: delayed_field_optimization_enabled=false
        // Loads as regular struct, bypassing aggregator semantics
        let table_ref = &borrow_global<TestTable>(addr).data;
        let agg = table::borrow(table_ref, 1);
        
        // This should fail but may succeed with wrong layout
        aggregator_v2::read(agg)
    }
}
```

**Rust test demonstrating layout mismatch:**
```rust
// In table-natives/src/lib.rs tests
#[test]
fn test_delayed_field_config_mismatch() {
    // 1. Create table with delayed fields enabled
    let mut env = create_vm_env_with_delayed_fields(true);
    let table = create_table_with_aggregator(&mut env);
    store_aggregator_value(&mut env, table, 456);
    
    // 2. Load with delayed fields disabled
    let mut env2 = create_vm_env_with_delayed_fields(false);
    let result = load_value(&mut env2, table);
    
    // Expected: Error or DelayedFieldID
    // Actual: Regular U128(456) - VULNERABILITY!
    assert!(matches!(result, Value::U128(456))); // Fails security
}
```

## Notes

This vulnerability is particularly severe because:
- It affects a core primitive (tables with aggregators)
- It occurs automatically without attacker action when configurations differ
- It violates multiple critical invariants simultaneously
- The feature flag controlling it is designed to be toggled during deployment

The root cause is treating `contains_delayed_fields` as a compile-time property derived from types, when it's actually a runtime configuration property that can change. The layout stored with values must be used for deserialization, not recomputed from current configuration.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L237-246)
```rust
impl LayoutInfo {
    fn from_value_ty(loader_context: &mut LoaderContext, value_ty: &Type) -> PartialVMResult<Self> {
        let (layout, contains_delayed_fields) = loader_context
            .type_to_type_layout_with_delayed_fields(value_ty)?
            .unpack();
        Ok(Self {
            layout,
            contains_delayed_fields,
        })
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L260-270)
```rust
                let data = table_context
                    .resolver
                    .resolve_table_entry_bytes_with_layout(
                        &self.handle,
                        entry.key(),
                        if self.value_layout_info.contains_delayed_fields {
                            Some(&self.value_layout_info.layout)
                        } else {
                            None
                        },
                    )?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L704-721)
```rust
fn deserialize_value(
    function_value_extension: &dyn FunctionValueExtension,
    bytes: &[u8],
    layout_info: &LayoutInfo,
) -> PartialVMResult<Value> {
    let layout = layout_info.layout.as_ref();
    let deserialization_result = if layout_info.contains_delayed_fields {
        ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(function_value_extension)
            .with_delayed_fields_serde()
            .deserialize(bytes, layout)
    } else {
        ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(function_value_extension)
            .deserialize(bytes, layout)
    };
    deserialization_result.ok_or_else(|| partial_extension_error("cannot deserialize table value"))
}
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L180-192)
```rust
    fn get_delayed_field_kind_if_delayed_field_optimization_enabled(
        &self,
        idx: &StructNameIndex,
    ) -> PartialVMResult<Option<IdentifierMappingKind>> {
        if !self.vm_config().delayed_field_optimization_enabled {
            return Ok(None);
        }
        let struct_name = self.get_struct_name(idx)?;
        Ok(IdentifierMappingKind::from_ident(
            struct_name.module(),
            struct_name.name(),
        ))
    }
```

**File:** third_party/move/move-core/types/src/value.rs (L209-231)
```rust
impl IdentifierMappingKind {
    /// If the struct identifier has a special mapping, return it.
    pub fn from_ident(
        module_id: &ModuleId,
        struct_id: &Identifier,
    ) -> Option<IdentifierMappingKind> {
        if module_id.address().eq(&AccountAddress::ONE)
            && module_id.name().eq(ident_str!("aggregator_v2"))
        {
            let ident_str = struct_id.as_ident_str();
            if ident_str.eq(ident_str!("Aggregator")) {
                Some(IdentifierMappingKind::Aggregator)
            } else if ident_str.eq(ident_str!("AggregatorSnapshot")) {
                Some(IdentifierMappingKind::Snapshot)
            } else if ident_str.eq(ident_str!("DerivedStringSnapshot")) {
                Some(IdentifierMappingKind::DerivedString)
            } else {
                None
            }
        } else {
            None
        }
    }
```

**File:** aptos-move/block-executor/src/view.rs (L1201-1224)
```rust
        let maybe_patched = match (value.as_state_value(), layout) {
            (Some(state_value), Some(layout)) => {
                let res = self.replace_values_with_identifiers(state_value, layout);
                match res {
                    Ok((value, _)) => Some(value),
                    Err(err) => {
                        let log_context =
                            AdapterLogSchema::new(self.base_view.id(), self.txn_idx as usize);
                        alert!(
                            log_context,
                            "[VM, ResourceView] Error during value to id replacement: {}",
                            err
                        );
                        self.mark_incorrect_use();
                        return Err(PartialVMError::new(
                            StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                        )
                        .with_message(format!("{}", err)));
                    },
                }
            },
            (state_value, _) => state_value,
        };
        Ok(TransactionWrite::from_state_value(maybe_patched))
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L62-68)
```rust
    /// Returns new environment but with delayed field optimization enabled. Should only be used by
    /// block executor where this optimization is needed. Note: whether the optimization will be
    /// enabled or not depends on the feature flag.
    pub fn new_with_delayed_field_optimization_enabled(state_view: &impl StateView) -> Self {
        let env = Environment::new(state_view, false, None).try_enable_delayed_field_optimization();
        Self(TriompheArc::new(env))
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L320-325)
```rust
    fn try_enable_delayed_field_optimization(mut self) -> Self {
        if self.features.is_aggregator_v2_delayed_fields_enabled() {
            self.runtime_environment.enable_delayed_field_optimization();
        }
        self
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4960-4988)
```rust
            (L::Native(kind, layout), Value::DelayedFieldID { id }) => {
                match &self.ctx.delayed_fields_extension {
                    Some(delayed_fields_extension) => {
                        delayed_fields_extension
                            .inc_and_check_delayed_fields_count()
                            .map_err(S::Error::custom)?;

                        let value = match delayed_fields_extension.mapping {
                            Some(mapping) => mapping
                                .identifier_to_value(layout, *id)
                                .map_err(|e| S::Error::custom(format!("{}", e)))?,
                            None => id.try_into_move_value(layout).map_err(|_| {
                                S::Error::custom(format!(
                                    "Custom serialization failed for {:?} with layout {}",
                                    kind, layout
                                ))
                            })?,
                        };

                        // The resulting value should not contain any delayed fields, we disallow
                        // this by using a context without the delayed field extension.
                        let ctx = self.ctx.clone_without_delayed_fields();
                        let value = SerializationReadyValue {
                            ctx: &ctx,
                            layout: layout.as_ref(),
                            value: &value,
                            depth: self.depth,
                        };
                        value.serialize(serializer)
```
