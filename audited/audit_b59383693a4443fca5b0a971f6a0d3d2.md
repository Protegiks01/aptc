# Audit Report

## Title
Multisig Rejection Mechanism Bypass via Race Condition Between Approvals and Rejections

## Summary
The multisig account validation logic fails to check whether a transaction has accumulated sufficient rejections before allowing execution. This enables a transaction to be executed even when it has received enough rejections to be officially removed, creating a race condition that undermines the multisig governance model.

## Finding Description

The vulnerability exists in the transaction validation flow for multisig accounts. When validating whether a multisig transaction can be executed, the system only checks if the transaction has accumulated sufficient approvals, but completely ignores whether it has also accumulated sufficient rejections. [1](#0-0) [2](#0-1) 

The `can_be_executed()` and `can_execute()` functions retrieve both approval and rejection counts via `num_approvals_and_rejections()`, but immediately discard the rejection count (using `_`). They only validate that `num_approvals >= num_signatures_required`.

During transaction prologue validation (called by the VM for both mempool validation and execution), the system invokes `validate_multisig_transaction()`: [3](#0-2) 

This validation function calls `can_execute()` or `can_be_executed()`, which only check approvals. There is no subsequent check to ensure the transaction doesn't also have sufficient rejections.

Conversely, the rejection mechanism in `can_be_rejected()` only checks rejections and discards approval counts: [4](#0-3) 

**Attack Scenario:**
Consider a multisig account with 5 owners requiring 3 signatures:

1. Owner A creates transaction T (auto-approval count: 1)
2. Owner B approves (approval count: 2)  
3. Owner C approves (approval count: 3) ✓ meets approval threshold
4. Owner D rejects (rejection count: 1)
5. Owner E rejects (rejection count: 2)
6. Owner F rejects (rejection count: 3) ✓ meets rejection threshold

At this point, BOTH conditions are simultaneously true:
- `can_be_executed()` returns `true` (3 approvals ≥ 3 required)
- `can_be_rejected()` returns `true` (3 rejections ≥ 3 required)

Any approving owner can submit an execution transaction and it will pass validation, bypassing the fact that the transaction has accumulated sufficient rejections. This creates a race condition where whichever action (execute or reject) reaches the blockchain first will succeed, rather than properly blocking execution when sufficient rejections exist.

The VM validation confirms this via the prologue execution path: [5](#0-4) [6](#0-5) 

## Impact Explanation

This is a **HIGH severity** governance vulnerability per Aptos bug bounty criteria ("Significant protocol violations"). 

The vulnerability breaks the fundamental governance invariant of multisig accounts: that transactions receiving sufficient rejections should be blocked from execution. This undermines the entire purpose of the rejection mechanism and enables the following attacks:

1. **Governance Bypass**: Malicious or compromised owners can execute transactions that the majority of owners have rejected
2. **Trust Model Violation**: Honest owners who reject malicious proposals cannot prevent execution if the proposal simultaneously has enough approvals
3. **Race Condition Exploitation**: Attackers can time their execution transactions to win the race against rejection finalization

While this requires owner-level access within the multisig context, it allows those owners to subvert the intended checks and balances of the multisig governance system. The impact is amplified in high-value multisig accounts controlling significant assets or protocol parameters.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability is easily exploitable once the conditions are met:

**Prerequisites:**
- Attacker is an owner of a multisig account (or has compromised an owner's key)
- A transaction proposal accumulates both sufficient approvals AND sufficient rejections
- Attacker can submit execution transaction before rejection finalization

**Realistic scenarios:**
1. **Contentious proposals**: When multisig owners disagree, split votes can easily result in both thresholds being met
2. **Compromised owner**: A single compromised owner in an active multisig can approve malicious transactions they created, then rush to execute before rejection threshold triggers removal
3. **Front-running**: Malicious owner monitors pending rejection votes and front-runs the final rejection with an execution transaction

The vulnerability is particularly likely in:
- Large multisig accounts with many owners (more likely to have split decisions)
- Multisigs managing high-value assets (higher motivation for exploitation)
- Multisigs with automated voting systems (easier to create race conditions)

## Recommendation

Add a rejection threshold check to the validation logic. The fix should ensure mutual exclusivity between execution and rejection:

**Fix for `can_be_executed()` and `can_execute()`:**

```move
public fun can_be_executed(multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
    assert_valid_sequence_number(multisig_account, sequence_number);
    let (num_approvals, num_rejections) = num_approvals_and_rejections(multisig_account, sequence_number);
    let num_signatures_required = num_signatures_required(multisig_account);
    
    // Transaction can only be executed if it has enough approvals AND does not have enough rejections
    sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
        num_approvals >= num_signatures_required &&
        num_rejections < num_signatures_required  // ADD THIS CHECK
}

public fun can_execute(owner: address, multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
    assert_valid_sequence_number(multisig_account, sequence_number);
    let (num_approvals, num_rejections) = num_approvals_and_rejections(multisig_account, sequence_number);
    if (!has_voted_for_approval(multisig_account, sequence_number, owner)) {
        num_approvals = num_approvals + 1;
    };
    let num_signatures_required = num_signatures_required(multisig_account);
    
    is_owner(owner, multisig_account) &&
        sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
        num_approvals >= num_signatures_required &&
        num_rejections < num_signatures_required  // ADD THIS CHECK
}
```

Similarly, update `can_be_rejected()` and `can_reject()` to ensure rejections cannot finalize if sufficient approvals exist (for consistency, though the current state is less severe).

## Proof of Concept

```move
#[test_only]
module aptos_framework::multisig_account_rejection_bypass_test {
    use aptos_framework::multisig_account;
    use aptos_framework::account;
    use std::vector;
    
    #[test(owner1 = @0x100, owner2 = @0x200, owner3 = @0x300, owner4 = @0x400, owner5 = @0x500)]
    fun test_rejection_bypass(
        owner1: &signer, 
        owner2: &signer, 
        owner3: &signer, 
        owner4: &signer, 
        owner5: &signer
    ) {
        // Setup: Create multisig with 5 owners, requiring 3 signatures
        let owners = vector[@0x100, @0x200, @0x300, @0x400, @0x500];
        multisig_account::create_with_owners(owner1, vector[@0x200, @0x300, @0x400, @0x500], 3, vector[], vector[]);
        
        let multisig_addr = multisig_account::get_next_multisig_account_address(@0x100);
        
        // Create a transaction (owner1 auto-approves, count = 1)
        multisig_account::create_transaction(owner1, multisig_addr, b"some_payload");
        
        // Owner2 approves (count = 2)
        multisig_account::approve_transaction(owner2, multisig_addr, 1);
        
        // Owner3 approves (count = 3) - meets approval threshold
        multisig_account::approve_transaction(owner3, multisig_addr, 1);
        
        // Owner4 rejects (rejection count = 1)
        multisig_account::reject_transaction(owner4, multisig_addr, 1);
        
        // Owner5 rejects (rejection count = 2)
        multisig_account::reject_transaction(owner5, multisig_addr, 1);
        
        // At this point: 3 approvals (meets threshold), 2 rejections (doesn't meet threshold yet)
        // If we add one more rejection...
        // Create a new owner to reject
        let owner6 = account::create_account_for_test(@0x600);
        multisig_account::add_owner(owner1, @0x600); // This would need to be done via multisig proposal in reality
        
        // Owner6 rejects (rejection count = 3) - meets rejection threshold
        multisig_account::reject_transaction(&owner6, multisig_addr, 1);
        
        // VULNERABILITY: Even with 3 rejections (meeting threshold), 
        // can_be_executed() will return TRUE because it only checks approvals
        let can_execute = multisig_account::can_be_executed(multisig_addr, 1);
        assert!(can_execute, 0); // This should be FALSE but will be TRUE
        
        let can_reject = multisig_account::can_be_rejected(multisig_addr, 1);
        assert!(can_reject, 1); // This is also TRUE
        
        // BOTH conditions are true simultaneously - race condition exists
        // Transaction can be executed despite having sufficient rejections
    }
}
```

This test demonstrates that a transaction can simultaneously satisfy both execution and rejection conditions, allowing a race condition where execution can proceed despite sufficient rejections.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L408-413)
```text
    public fun can_be_executed(multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
        assert_valid_sequence_number(multisig_account, sequence_number);
        let (num_approvals, _) = num_approvals_and_rejections(multisig_account, sequence_number);
        sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
            num_approvals >= num_signatures_required(multisig_account)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L417-426)
```text
    public fun can_execute(owner: address, multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
        assert_valid_sequence_number(multisig_account, sequence_number);
        let (num_approvals, _) = num_approvals_and_rejections(multisig_account, sequence_number);
        if (!has_voted_for_approval(multisig_account, sequence_number, owner)) {
            num_approvals = num_approvals + 1;
        };
        is_owner(owner, multisig_account) &&
            sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
            num_approvals >= num_signatures_required(multisig_account)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L430-435)
```text
    public fun can_be_rejected(multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
        assert_valid_sequence_number(multisig_account, sequence_number);
        let (_, num_rejections) = num_approvals_and_rejections(multisig_account, sequence_number);
        sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
            num_rejections >= num_signatures_required(multisig_account)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1139-1157)
```text
    fun validate_multisig_transaction(
        owner: &signer, multisig_account: address, payload: vector<u8>) acquires MultisigAccount {
        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);
        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;
        assert_transaction_exists(multisig_account, sequence_number);

        if (features::multisig_v2_enhancement_feature_enabled()) {
            assert!(
                can_execute(address_of(owner), multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        }
        else {
            assert!(
                can_be_executed(multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        };
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L393-407)
```rust
/// Run the prologue for a multisig transaction. This needs to verify that:
/// 1. The multisig tx exists
/// 2. It has received enough approvals to meet the signature threshold of the multisig account
/// 3. If only the payload hash was stored on chain, the provided payload in execution should
/// match that hash.
pub(crate) fn run_multisig_prologue(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl ModuleStorage,
    txn_data: &TransactionMetadata,
    executable: TransactionExecutableRef,
    multisig_address: AccountAddress,
    features: &Features,
    log_context: &AdapterLogSchema,
    traversal_context: &mut TraversalContext,
) -> Result<(), VMStatus> {
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L431-440)
```rust
    session
        .execute_function_bypass_visibility(
            &MULTISIG_ACCOUNT_MODULE,
            VALIDATE_MULTISIG_TRANSACTION,
            vec![],
            serialize_values(&vec![
                MoveValue::Signer(txn_data.sender),
                MoveValue::Address(multisig_address),
                MoveValue::vector_u8(provided_payload),
            ]),
```
