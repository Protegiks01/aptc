# Audit Report

## Title
Path Traversal Vulnerability in Move Package Local Dependency Resolution Affects Build Systems

## Summary
The Move package dependency resolution system contains a path traversal vulnerability in the handling of `PackageLocation::Local` dependencies. Both the legacy (`move-package`) and newer (`move-package-resolver`) implementations fail to validate local dependency paths, allowing arbitrary file system access during package compilation on build systems. However, this vulnerability does **not** affect validator nodes at runtime.

## Finding Description

The vulnerability exists in two locations:

**Legacy System (move-package):** [1](#0-0) 

The `parse_package_manifest` function directly pushes the unvalidated `dep.local` path onto `root_path` without any sanitization or bounds checking.

**New System (move-package-resolver):** [2](#0-1) 

The `resolve_dependency` function joins the local path with the parent path without validation when both parent and child are local packages.

**Asymmetric Security:** The new resolver implements validation for git dependencies: [3](#0-2) 

This validation explicitly checks for `ParentDir` components and rejects subdirectories that escape the git repository root, but this protection is **not applied** to local-to-local dependencies.

**Exploitation Path:**
1. Attacker creates a malicious Move package with `Move.toml` containing: `[dependencies]` with `local = "../../../etc"`
2. When a developer compiles this package, the system traverses to arbitrary filesystem locations
3. During resolution, the system reads from the traversed path: [4](#0-3) 

4. During compilation, source files are enumerated and loaded: [5](#0-4) 

## Impact Explanation

**NOT Critical Severity as claimed in the security question.** This vulnerability does NOT meet the Aptos Bug Bounty Critical criteria because:

1. **No validator node impact at runtime:** Validator nodes execute pre-compiled Move bytecode, not Move.toml manifests. The package compilation system is a development-time tool. [6](#0-5) 

Genesis and framework publishing use pre-compiled `ReleaseBundle` objects, not Move.toml compilation.

2. **No consensus impact:** This cannot cause consensus splits, safety violations, or validator disagreements.

3. **No fund loss:** This cannot directly steal, mint, or freeze funds.

**Actual Impact: Medium Severity at most**
- Information disclosure on developer workstations and CI/CD build systems
- Supply chain attack vector if malicious packages are built
- Limited to build-time, not blockchain operations

## Likelihood Explanation

**High likelihood** of exploitation in development environments:
- Attacker can publish malicious Move packages to public repositories
- Developers regularly clone and build third-party Move packages
- CI/CD systems automatically build packages from pull requests
- No warnings or security notices about untrusted dependencies

However, **low likelihood** of affecting the Aptos blockchain directly because validators don't use this code path during normal operations.

## Recommendation

Add path traversal validation for local dependencies similar to git dependencies:

```rust
// In resolve_dependency for PackageLocation::Local
if local_path.is_relative() {
    let normalized_path = NormalizedPath::new(&local_path);
    if let Some(std::path::Component::ParentDir) = normalized_path.components().next() {
        bail!("local dependency path cannot escape parent directory: {}", local_path.display());
    }
}
```

Additionally, consider:
1. Warning users when compiling packages with local dependencies from untrusted sources
2. Adding an allowlist mechanism for permitted local dependency paths
3. Sandboxing the build environment to limit filesystem access

## Proof of Concept

```bash
# Create malicious package
mkdir -p malicious_package
cd malicious_package

cat > Move.toml << 'EOF'
[package]
name = "MaliciousPackage"
version = "0.0.1"

[dependencies]
EvilDep = { local = "../../../etc" }
EOF

mkdir sources
cat > sources/main.move << 'EOF'
module 0x1::Main {
    public fun test() {}
}
EOF

# Attempt to compile - will try to access /etc/Move.toml
aptos move compile

# Expected: Error attempting to read from traversed path
# Actual: System attempts to read /etc/Move.toml, exposing path traversal
```

**Notes**

The security question incorrectly claims this is a "Critical" severity issue affecting "validator nodes." My investigation confirms:

1. ✅ **Path traversal vulnerability exists** in both package resolvers
2. ❌ **Does NOT affect validator nodes** - they don't compile Move.toml files at runtime  
3. ❌ **Does NOT meet Critical severity** - limited to build system information disclosure
4. ⚠️ **Medium severity at most** - affects developer workstations and CI/CD, not blockchain operations

This is a real supply chain security issue, but not the Critical validator-node vulnerability claimed in the security question.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L758-768)
```rust
    pub fn get_sources(&self, config: &BuildConfig) -> Result<Vec<FileName>> {
        let places_to_look =
            ResolvingPackage::get_source_paths_for_config(&self.package_path, config)?
                .into_iter()
                .map(|p| p.to_string_lossy().to_string())
                .collect::<Vec<_>>();
        Ok(find_move_filenames(&places_to_look, false)?
            .into_iter()
            .map(Symbol::from)
            .collect())
    }
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L324-350)
```rust
    let (package_identity, user_provided_url) = match dep.location {
        PackageLocation::Local { path: local_path } => match &parent_identity.location {
            SourceLocation::Local { path: parent_path } => {
                // Both parent and child are local, so if the child's path is relative,
                // it is relative to the parent's path.
                let dep_manitest_path = if local_path.is_absolute() {
                    local_path
                } else {
                    parent_path.join(local_path)
                };
                let canonical_path = CanonicalPath::new(&dep_manitest_path).map_err(|err| {
                    anyhow!(
                        "failed to find package at {}: {}",
                        dep_manitest_path.display(),
                        err
                    )
                })?;

                let identity = PackageIdentity {
                    name: dep_name.to_string(),
                    location: SourceLocation::Local {
                        path: canonical_path,
                    },
                };

                (identity, None)
            },
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L366-372)
```rust
                let new_subdir = subdir.join(local_path);
                let normalized_new_subdir = NormalizedPath::new(&new_subdir);
                if let Some(std::path::Component::ParentDir) =
                    normalized_new_subdir.components().next()
                {
                    bail!("subdir outside of repo root: {}", new_subdir.display());
                }
```

**File:** third_party/move/tools/move-package/src/resolution/digest.rs (L11-24)
```rust
pub fn compute_digest(paths: &[PathBuf]) -> Result<PackageDigest> {
    let mut hashed_files = Vec::new();
    let mut hash = |path: &Path| {
        let contents = std::fs::read(path)?;
        hashed_files.push(format!("{:X}", Sha256::digest(&contents)));
        Ok(())
    };
    let mut maybe_hash_file = |path: &Path| -> Result<()> {
        match path.extension() {
            Some(x) if MOVE_EXTENSION == x => hash(path),
            _ if path.ends_with(SourcePackageLayout::Manifest.path()) => hash(path),
            _ => Ok(()),
        }
    };
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1155-1194)
```rust
fn publish_framework(
    genesis_vm: &GenesisMoveVm,
    genesis_runtime_environment: &RuntimeEnvironment,
    hash_value: HashValue,
    framework: &ReleaseBundle,
) -> (VMChangeSet, ModuleWriteSet) {
    // Reset state view to be empty, to make sure all module write ops are creations.
    let mut state_view = GenesisStateView::new();

    // First, publish modules.
    let mut writes = BTreeMap::new();
    for pack in &framework.packages {
        let modules = pack.sorted_code_and_modules();

        let addr = *modules.first().unwrap().1.self_id().address();
        let code = modules
            .into_iter()
            .map(|(c, _)| c.to_vec().into())
            .collect::<Vec<_>>();

        let package_writes = code_to_writes_for_publishing(
            genesis_runtime_environment,
            genesis_vm.genesis_features(),
            &state_view,
            addr,
            code,
        )
        .unwrap_or_else(|e| {
            panic!(
                "Failure publishing package `{}`: {:?}",
                pack.package_metadata().name,
                e
            )
        });

        // Add write ops so that we can later create a module write set. Also add them to the state
        // view so that modules in subsequent packages can link to them.
        writes.extend(package_writes.clone());
        state_view.add_module_write_ops(package_writes);
    }
```
