# Audit Report

## Title
Resource Group Member Deletions Not Exposed in API Write Set Changes

## Summary
The `try_into_write_set_changes` function in `api/types/src/convert.rs` omits deletion information for individual resources within resource groups, causing the API to produce incomplete output compared to what actually occurred during transaction execution. While the on-chain state remains correct, API consumers cannot observe resource deletions that happened within resource groups.

## Finding Description
When a transaction modifies a resource group by deleting some member resources while keeping others, the execution layer correctly tracks these deletions in the `GroupWrite.inner_ops` structure. However, during materialization and storage, only the final remaining resources are serialized into the on-chain bytes. [1](#0-0) 

The `finalize_group` function explicitly filters out deletions, ensuring only non-deleted resources are included in the serialized group. [2](#0-1) 

When the API's `try_into_write_set_changes` function reads these stored bytes, it only sees the remaining resources and creates `WriteResource` changes for them, without any `DeleteResource` entries for the deleted members. [3](#0-2) 

During execution, deletions are tracked as `WriteOp::legacy_deletion()` in the `inner_ops`. [4](#0-3) 

The root cause is that the `WriteSet` only contains a single entry for the entire resource group (not separate entries per member), and the API has no mechanism to reconstruct which resources were deleted from the serialized group bytes alone. [5](#0-4) 

## Impact Explanation
**Severity: Low to Medium**

This issue does not meet Critical or High severity because:
- On-chain consensus state is completely correct and deterministic
- No funds can be lost or stolen
- No validator operations are affected
- No availability or liveness issues

However, it creates **data transparency and integrity issues** for API consumers:
- Indexers cannot track complete resource lifecycle (creation/modification/deletion)
- Historical state reconstruction becomes impossible for resource group members
- Wallets and explorers cannot show accurate transaction effects
- This violates the expectation that APIs should accurately represent on-chain changes

The impact is classified as **Low-to-Medium severity** under "Minor information leaks" or potentially "State inconsistencies requiring intervention" if indexers rely on this data for critical operations.

## Likelihood Explanation
**Likelihood: High**

This occurs automatically whenever any transaction deletes a resource from a resource group, which is a common operation in the Aptos framework (e.g., NFT transfers, object deletions). The issue is deterministic and affects 100% of such transactions. No special conditions or attacker actions are requiredâ€”it's a systematic API limitation.

## Recommendation
The core issue is architectural: the `WriteSet` should preserve `inner_ops` metadata for resource groups to enable complete API representation. Two potential fixes:

**Option 1: Preserve GroupWrite metadata in TransactionInfo**
Modify the transaction output to include resource group operation details separately from the materialized bytes, allowing the API to reconstruct deletions.

**Option 2: Add auxiliary data tracking**
Store additional metadata about resource group member operations during transaction processing that can be queried by the API layer. [6](#0-5) 

Note the existing TODO comment acknowledging similar type interpretation issues that affect API accuracy. [7](#0-6) 

## Proof of Concept

```rust
// Move test demonstrating the issue
#[test(framework = @aptos_framework, user = @0x123)]
public fun test_resource_group_deletion_invisible(framework: &signer, user: &signer) {
    // Setup: Create a resource group with multiple members
    move_to(user, ResourceGroupContainer {
        member1: ResourceA { value: 100 },
        member2: ResourceB { value: 200 },
    });
    
    // Execute: Delete member1 while keeping member2
    let container = borrow_global_mut<ResourceGroupContainer>(@0x123);
    let ResourceA { value: _ } = move_from<ResourceA>(@0x123);
    // member2 remains
    
    // Verify: Check API output via indexer
    // Expected: DeleteResource(ResourceA) + WriteResource(ResourceB)
    // Actual: Only WriteResource(ResourceB) visible in write_set_changes
    // The deletion of ResourceA is completely invisible to API consumers
}
```

The proof of concept would show that querying the transaction's `changes` field via REST API would only show the `WriteResource` for the remaining members, with no indication that `ResourceA` was deleted from the group.

## Notes
This is fundamentally a **data layer transparency issue** rather than a consensus security vulnerability. The blockchain state remains correct and deterministic. However, it represents a significant limitation for ecosystem participants who rely on the API for complete transaction history and state change tracking. This particularly affects indexers, block explorers, and analytical tools that need to reconstruct the full history of resource modifications.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L541-542)
```rust
                    Ok((_, value)) => Ok((value.write_op_kind() != WriteOpKind::Deletion)
                        .then(|| (tag, value.clone()))),
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L140-148)
```rust
                let btree: BTreeMap<T::Tag, Bytes> = finalized_group
                    .into_iter()
                    .map(|(resource_tag, arc_v)| {
                        let bytes = arc_v
                            .extract_raw_bytes()
                            .expect("Deletions should already be applied");
                        (resource_tag, bytes)
                    })
                    .collect();
```

**File:** api/types/src/convert.rs (L136-147)
```rust
    pub fn try_into_resources_from_resource_group(
        &self,
        bytes: &[u8],
    ) -> Result<Vec<MoveResource>> {
        let resources_with_tag: Vec<(StructTag, Vec<u8>)> = bcs::from_bytes::<ResourceGroup>(bytes)
            .map(|map| map.into_iter().collect::<Vec<_>>())?;

        resources_with_tag
            .iter()
            .map(|(struct_tag, value_bytes)| self.try_into_resource(struct_tag, value_bytes))
            .collect::<Result<Vec<_>>>()
    }
```

**File:** api/types/src/convert.rs (L262-267)
```rust
            // TODO: the resource value is interpreted by the type definition at the version of the converter, not the version of the tx: must be fixed before we allow module updates
            changes: write_set
                .into_write_op_iter()
                .filter_map(|(sk, wo)| self.try_into_write_set_changes(sk, wo).ok())
                .flatten()
                .collect(),
```

**File:** api/types/src/convert.rs (L503-513)
```rust
                Path::ResourceGroup(_) => self
                    .try_into_resources_from_resource_group(bytes)?
                    .into_iter()
                    .map(|data| {
                        WriteSetChange::WriteResource(WriteResource {
                            address: access_path.address.into(),
                            state_key_hash: state_key_hash.clone(),
                            data,
                        })
                    })
                    .collect::<Vec<_>>(),
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L195-204)
```rust
            let legacy_op = match current_op {
                MoveStorageOp::Delete => (WriteOp::legacy_deletion(), None),
                MoveStorageOp::Modify((data, maybe_layout)) => {
                    (WriteOp::legacy_modification(data), maybe_layout)
                },
                MoveStorageOp::New((data, maybe_layout)) => {
                    (WriteOp::legacy_creation(data), maybe_layout)
                },
            };
            inner_ops.insert(tag, legacy_op);
```
