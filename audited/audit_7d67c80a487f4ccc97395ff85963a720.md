# Audit Report

## Title
PostgreSQL Connection String Credential Exposure in Local Testnet Indexer API Logs

## Summary
The local testnet indexer API logs PostgreSQL connection strings containing embedded passwords in plaintext without sanitization, violating established security patterns present elsewhere in the codebase. When users run the local testnet with `--use-host-postgres` and provide credentials via `--host-postgres-password`, these credentials are written to logs and error messages, creating a credential exposure vulnerability.

## Finding Description

The Aptos local testnet tool supports connecting to external PostgreSQL databases using the `--use-host-postgres` flag along with `--host-postgres-password` to provide authentication credentials. When these flags are used, the password is embedded in the connection string format `postgres://user:password@host:port/database`. [1](#0-0) 

This connection string with embedded credentials is then passed to the `IndexerApiManager` and logged without sanitization in multiple locations:

1. **Primary exposure in `indexer_api.rs`**: The connection string is logged directly using the `info!` macro: [2](#0-1) 

2. **Error context exposure in `postgres.rs`**: Connection failures expose credentials in error messages: [3](#0-2) 

3. **Error context exposure in `processors.rs`**: Similar pattern when establishing processor connections: [4](#0-3) 

**The vulnerability violates established security patterns**: The codebase already implements proper credential sanitization in production code. The `aptos-node` logger sanitizes PostgreSQL URIs before logging: [5](#0-4) 

Similarly, the `IndexerConfig` Debug implementation sanitizes connection strings: [6](#0-5) 

The local testnet code fails to apply these same sanitization patterns, creating an inconsistency where development tools leak credentials that production code properly protects.

## Impact Explanation

This qualifies as **High Severity** based on the following factors:

1. **Credential Exposure**: Database credentials logged in plaintext can be extracted by attackers who gain access to:
   - Log files stored on disk
   - Centralized logging systems (Splunk, ELK, etc.)
   - Bug reports and support tickets
   - Shared development environments
   - System monitoring dashboards

2. **Potential for Lateral Movement**: While this affects the local testnet tool rather than production validators, developers may:
   - Use production or staging database credentials during testing
   - Reuse credentials across environments
   - Run the tool on shared infrastructure where logs are accessible to multiple users

3. **Security Best Practice Violation**: Credential logging is a well-established security anti-pattern that can lead to unauthorized database access, data breaches, and compliance violations.

4. **Inconsistency with Production Code**: The existence of proper sanitization elsewhere in the codebase indicates this is a known security requirement that was not applied consistently.

## Likelihood Explanation

**High Likelihood** of exploitation due to:

1. **Ease of Exploitation**: No special skills required - an attacker only needs read access to logs
2. **Common Attack Vector**: Log files are frequently targeted and often have overly permissive access controls
3. **Developer Workflow**: The local testnet tool is actively used by developers, increasing exposure
4. **Persistent Exposure**: Credentials remain in logs indefinitely unless logs are rotated with secure deletion
5. **No User Warning**: Users are not warned that providing `--host-postgres-password` will log the password in plaintext

## Recommendation

Implement the same credential sanitization pattern used in production code before logging connection strings. Create a helper function to sanitize PostgreSQL URIs:

```rust
fn sanitize_connection_string(connection_string: &str) -> String {
    match url::Url::parse(connection_string) {
        Ok(mut parsed_url) => {
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        },
        Err(_) => connection_string.to_string(),
    }
}
```

Then apply it before logging:

**In `indexer_api.rs`** (line 217-220):
```rust
info!(
    "Using postgres connection string: {}",
    sanitize_connection_string(&postgres_connection_string)
);
```

**In `postgres.rs`** (line 154-156):
```rust
let mut connection = AsyncPgConnection::establish(&connection_string)
    .await
    .with_context(|| format!(
        "Failed to connect to postgres at {}", 
        sanitize_connection_string(&connection_string)
    ))?;
```

**In `processors.rs`** (line 138-140):
```rust
let mut conn: AsyncConnectionWrapper<AsyncPgConnection> =
    AsyncConnectionWrapper::establish(&connection_string).with_context(|| {
        format!(
            "Failed to connect to postgres at {}", 
            sanitize_connection_string(&connection_string)
        )
    })?;
```

## Proof of Concept

**Steps to reproduce**:

1. Run the Aptos local testnet with host PostgreSQL and a password:
```bash
aptos node run-local-testnet \
  --with-indexer-api \
  --use-host-postgres \
  --host-postgres-password "MySecretPassword123" \
  --postgres-database testdb
```

2. Check the logs (stdout or log files):
```bash
# The logs will contain:
# INFO Using postgres connection string: postgres://postgres:MySecretPassword123@127.0.0.1:5432/testdb
```

3. Observe that the password `MySecretPassword123` is logged in plaintext.

**Expected behavior**: The password should be masked as:
```
INFO Using postgres connection string: postgres://postgres:*@127.0.0.1:5432/testdb
```

**Test case** (conceptual - would require integration test setup):
```rust
#[test]
fn test_connection_string_sanitization() {
    let conn_str = "postgres://user:password123@localhost:5432/db";
    let sanitized = sanitize_connection_string(conn_str);
    assert!(!sanitized.contains("password123"));
    assert!(sanitized.contains("postgres://user:*@localhost:5432/db"));
}
```

## Notes

This vulnerability specifically affects the **local testnet development tool**, not production validator nodes. However, the security impact remains significant because:

1. Developers may inadvertently use real credentials when testing
2. Development/staging databases often contain sensitive or production-like data
3. Logs from development environments are frequently shared or stored insecurely
4. The issue represents a clear deviation from the security patterns established in the production codebase

The fix is straightforward and should be applied consistently across all locations where connection strings are logged or included in error messages.

### Citations

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L92-116)
```rust
    pub fn get_connection_string(&self, database: Option<&str>, external: bool) -> String {
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
        let port = self.get_postgres_port(external);
        let database = match database {
            Some(database) => database,
            None => &self.postgres_database,
        };
        let host = match self.use_host_postgres {
            true => &self.host_postgres_host,
            false => match external {
                true => "127.0.0.1",
                false => POSTGRES_CONTAINER_NAME,
            },
        };
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
    }
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L154-156)
```rust
        let mut connection = AsyncPgConnection::establish(&connection_string)
            .await
            .with_context(|| format!("Failed to connect to postgres at {}", connection_string))?;
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L217-220)
```rust
        info!(
            "Using postgres connection string: {}",
            postgres_connection_string
        );
```

**File:** crates/aptos/src/node/local_testnet/processors.rs (L138-140)
```rust
                AsyncConnectionWrapper::establish(&connection_string).with_context(|| {
                    format!("Failed to connect to postgres at {}", connection_string)
                })?;
```

**File:** aptos-node/src/logger.rs (L91-99)
```rust
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }
```

**File:** config/src/config/indexer_config.rs (L92-100)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
```
