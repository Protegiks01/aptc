# Audit Report

## Title
Missing fsync() in OnDiskStorage Allows Consensus Safety Data Loss on Power Failure

## Summary
The `OnDiskStorage` implementation in `secure/storage/src/on_disk.rs` writes consensus safety data using an atomic rename pattern but fails to call `fsync()`/`sync_all()` before the rename operation. This violates durability guarantees and can cause validators to lose critical safety state (including `last_voted_round`) on power failures, potentially enabling double-signing vulnerabilities.

## Finding Description

The `OnDiskStorage::write()` function implements an atomic write pattern by writing to a temporary file and then renaming it to the target location. However, it omits the critical `fsync()` call required for durability: [1](#0-0) 

Without `file.sync_all()` before the `fs::rename()`, the file data remains in OS write buffers and may not be physically written to disk. The rename operation updates directory metadata atomically, but if a power failure occurs after the rename but before the OS flushes buffered writes, the target file will exist but contain incomplete or no data.

This storage backend is used by `PersistentSafetyStorage` to persist consensus safety data: [2](#0-1) 

The `SafetyData` structure contains critical consensus safety state including `last_voted_round`, which prevents double-signing: [3](#0-2) 

When a validator creates a vote, it updates `last_voted_round` and persists it: [4](#0-3) 

**Attack Scenario:**
1. Validator receives proposal for round 100
2. SafetyRules validates and votes, updating `last_voted_round` to 100
3. `set_safety_data()` writes to temporary file via `File::write_all()`
4. `fs::rename()` succeeds (atomically updates directory)
5. **Power failure occurs before OS flushes write buffer**
6. Validator reboots and reads `secure-data.json`
7. File exists but is empty/corrupted (data was never flushed)
8. Validator reverts to old `last_voted_round` (e.g., 0)
9. Validator can vote again in round 100 with potentially different vote
10. **Double-signing occurs, violating BFT consensus safety**

## Impact Explanation

**Severity: Critical** - This violates the fundamental **Consensus Safety** invariant (#2 in the specification): "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

Double-signing by validators breaks BFT safety assumptions and can lead to:
- Chain forks and conflicting committed blocks
- Loss of consensus finality guarantees
- Potential double-spending if different branches contain conflicting transactions
- Network partition requiring manual intervention or hard fork

While the `OnDiskStorage` README states it "should not be used in production environments," the production configuration examples use it: [5](#0-4) [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium-Low** - While the impact is critical, the likelihood depends on:

1. **Usage in production**: The README warns against production use of `OnDiskStorage`, but configuration examples show it being used. If validators actually deploy with these configs, the risk is real.

2. **Timing window**: The vulnerability requires a power failure in the narrow window between `write_all()` completing and the OS buffer being flushed. Modern filesystems typically flush within seconds, making this window narrow.

3. **Triggering crashes**: While unprivileged attackers cannot cause power failures, they might trigger validator crashes through other vulnerabilities (OOM, panics, etc.). However, this requires first finding such a crash vulnerability.

4. **Write frequency**: Safety data is written on every vote/timeout, so there are many opportunities for the timing window to be hit during normal operation.

The config sanitizer only prevents `InMemoryStorage` on mainnet, not `OnDiskStorage`: [7](#0-6) 

## Recommendation

Add `sync_all()` call before the rename operation in `OnDiskStorage::write()`:

```rust
fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut file = File::create(self.temp_path.path())?;
    file.write_all(&contents)?;
    file.sync_all()?;  // ADD THIS LINE - ensure data is flushed to disk
    fs::rename(&self.temp_path, &self.file_path)?;
    Ok(())
}
```

Additionally, update the config sanitizer to prevent `OnDiskStorage` on mainnet validators, similar to the `InMemoryStorage` check, and add clearer documentation warnings in the configuration examples.

## Proof of Concept

```rust
// Test demonstrating the durability issue
// Place in secure/storage/src/on_disk.rs tests section

#[cfg(test)]
mod durability_tests {
    use super::*;
    use std::process;
    
    #[test]
    #[ignore] // Dangerous test - simulates power failure
    fn test_missing_fsync_durability() {
        let temp_dir = TempPath::new();
        temp_dir.create_as_dir().unwrap();
        let file_path = temp_dir.path().join("safety_data.json");
        
        let mut storage = OnDiskStorage::new(file_path.clone());
        
        // Write critical safety data
        storage.set("last_voted_round", 100u64).unwrap();
        
        // Simulate power failure immediately after write
        // In real scenario, power fails before OS flush
        // Here we simulate by killing process before fsync
        process::abort(); // Simulates abrupt termination
        
        // After "reboot", read the file
        let storage2 = OnDiskStorage::new(file_path);
        let result: Result<GetResponse<u64>, _> = storage2.get("last_voted_round");
        
        // Without sync_all(), this may fail or return incorrect data
        assert!(result.is_ok());
        assert_eq!(result.unwrap().value, 100u64);
    }
}
```

**Notes:**
- The vulnerability specifically affects the `OnDiskStorage` backend used for safety rules persistence
- `TempPath` itself is not the issue - it's just a wrapper for temporary path cleanup
- The atomic rename pattern is correct, but incomplete without `fsync()`
- Production validators should use `Vault` storage backend for proper security guarantees

### Citations

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L86-94)
```rust
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-17)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** docker/compose/aptos-node/validator.yaml (L11-14)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```
