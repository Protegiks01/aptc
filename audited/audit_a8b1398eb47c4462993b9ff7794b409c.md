# Audit Report

## Title
Transaction Index Corruption During Pruning When Duplicate Sequence Numbers Exist

## Summary
The `prune_transaction_by_account()` function blindly deletes index entries based on (account, sequence_number) keys without verifying that the indexed version matches the version being pruned. If the database contains duplicate sequence numbers due to a bug (e.g., consensus failure, storage corruption, or recovery issues), pruning older versions will incorrectly delete index entries that point to newer versions, leaving the database in a corrupted state.

## Finding Description

The vulnerability exists in the `prune_transaction_by_account()` function [1](#0-0) 

The `OrderedTransactionByAccountSchema` uses a composite key of `(AccountAddress, SequenceNumber)` that maps to a transaction `Version` [2](#0-1) 

In RocksDB (the underlying key-value store), keys must be unique within a column family. If duplicate sequence numbers exist at different versions due to a bug:

**Database State After Bug:**
- Transaction at version 100: account A, sequence number 5
- Transaction at version 200: account A, sequence number 5 (duplicate)
- `TransactionSchema`: Both version 100 and 200 contain transactions
- `OrderedTransactionByAccountSchema`: Only ONE entry exists: `(A, 5) -> 200` (version 200 overwrote version 100's entry when written)

**Pruning Scenario:**
When `TransactionPruner` prunes versions 0-150 [3](#0-2) :

1. `get_pruning_candidate_transactions()` reads transaction at version 100 from `TransactionSchema` [4](#0-3) 
2. `prune_transaction_by_account()` is called with this transaction
3. The function extracts `(account A, seq_num 5)` and issues `delete((A, 5))`
4. **BUG**: This deletes the entry pointing to version 200, not version 100!
5. Transaction at version 200 becomes orphaned - it exists in `TransactionSchema` but has no entry in `OrderedTransactionByAccountSchema`

**Broken Invariants:**
- **State Consistency**: The index no longer correctly reflects which transactions exist
- **Deterministic Execution**: Different nodes recovering from the same corrupted state may have different index states
- Queries via `get_account_ordered_transaction_version()` will fail for the orphaned transaction [5](#0-4) 

## Impact Explanation

This qualifies as **High Severity** based on Aptos bug bounty criteria:

1. **Significant Protocol Violations**: The function makes pre-existing database corruption worse by destroying index integrity
2. **API Crashes/Failures**: Queries for transactions by account/sequence number will return incorrect results or fail
3. **State Inconsistencies Requiring Intervention**: The corrupted index state requires manual database repair or reindexing

While the initial duplicate sequence numbers represent a separate bug (in consensus, execution, or storage), the pruning function's lack of defensive programming transforms a potentially recoverable corruption into persistent data loss. Transaction data exists but becomes permanently unfindable through the account index.

This impacts:
- REST API queries using account/sequence number lookups
- State synchronization processes that rely on transaction indexing
- Debugging and forensic analysis of historical transactions
- Any downstream systems depending on account transaction history

## Likelihood Explanation

**Moderate Likelihood**, contingent on the existence of duplicate sequence numbers:

**Pre-conditions:**
1. Database must contain duplicate sequence numbers (same account + seq_num at different versions) - This could occur through:
   - Consensus bugs allowing duplicate transactions
   - Storage corruption during crash recovery
   - Bugs in transaction commit logic [6](#0-5) 
   - State sync errors during initial database population

**Trigger:**
2. Normal pruning operations occur (happens regularly on validator nodes)

While Aptos has strong sequence number validation in the transaction prologue to prevent duplicates during normal execution, the question explicitly asks about defensive handling of corrupted states. Database corruption can occur through:
- Hardware failures
- Crash during write operations  
- Bugs in storage layer
- Recovery from backups with inconsistencies

Once duplicates exist, the vulnerability is **deterministically triggered** by routine pruning, affecting all nodes that prune the corrupted data.

## Recommendation

The function should verify that the index entry being deleted actually corresponds to the version being pruned:

```rust
pub fn prune_transaction_by_account(
    &self,
    transactions: &[(Version, Transaction)],
    db_batch: &mut SchemaBatch,
) -> Result<()> {
    for (version, transaction) in transactions {
        if let Some(txn) = transaction.try_as_signed_user_txn() {
            if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                // Check if the current index entry points to the version being pruned
                let key = (txn.sender(), seq_num);
                if let Some(indexed_version) = self.ledger_db
                    .transaction_db_raw()
                    .get::<OrderedTransactionByAccountSchema>(&key)? 
                {
                    // Only delete if the indexed version matches the version being pruned
                    if indexed_version == *version {
                        db_batch.delete::<OrderedTransactionByAccountSchema>(&key)?;
                    } else {
                        // Log warning about duplicate sequence numbers
                        warn!(
                            "Skipping index deletion for ({:?}, {}) during version {} pruning: \
                             index points to version {} (potential duplicate sequence number)",
                            txn.sender(), seq_num, version, indexed_version
                        );
                    }
                }
            }
        }
    }
    Ok(())
}
```

**Alternative Approach**: Track which sequence numbers have been deleted in the current batch to avoid issuing duplicate deletes, though the version-check approach is more robust.

## Proof of Concept

```rust
#[cfg(test)]
mod duplicate_sequence_number_pruning_test {
    use super::*;
    use aptos_types::{
        account_address::AccountAddress,
        transaction::{SignedTransaction, RawTransaction, Script, TransactionPayload},
    };
    
    #[test]
    fn test_prune_with_duplicate_sequence_numbers() {
        // Setup: Create test database
        let tmpdir = aptos_temppath::TempPath::new();
        let db = AptosDB::new_for_test(&tmpdir);
        
        let account = AccountAddress::random();
        let seq_num = 5u64;
        
        // Simulate bug: Write transaction with same seq_num at two different versions
        // Version 100: First transaction
        let txn1 = create_test_transaction(account, seq_num);
        db.save_transactions(&[(100, txn1.clone())], /*first_version=*/ 100, None).unwrap();
        
        // Version 200: Duplicate sequence number (simulating bug)
        let txn2 = create_test_transaction(account, seq_num);
        db.save_transactions(&[(200, txn2.clone())], /*first_version=*/ 200, None).unwrap();
        
        // Verify: Index now points to version 200 (overwrote version 100's entry)
        let indexed_version = db.get_account_transaction_version(
            account, seq_num, 300
        ).unwrap().unwrap();
        assert_eq!(indexed_version, 200);
        
        // Prune: Attempt to prune version 100
        let mut batch = SchemaBatch::new();
        let transaction_store = db.get_transaction_store();
        transaction_store.prune_transaction_by_account(
            &[(100, txn1)], 
            &mut batch
        ).unwrap();
        db.ledger_db.transaction_db().write_schemas(batch).unwrap();
        
        // BUG: Index entry for version 200 was incorrectly deleted!
        let result = db.get_account_transaction_version(account, seq_num, 300).unwrap();
        assert_eq!(result, None); // Index is now broken
        
        // Transaction at version 200 still exists in TransactionSchema
        assert!(db.get_transaction(200).is_ok());
        
        // But is not findable via account index - DATA CORRUPTION!
    }
    
    fn create_test_transaction(sender: AccountAddress, seq_num: u64) -> Transaction {
        // Create a minimal signed transaction for testing
        Transaction::UserTransaction(SignedTransaction::new(
            RawTransaction::new(
                sender,
                seq_num,
                TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
                0,
                0,
                0,
                ChainId::test(),
            ),
            test_signature(), // Mock signature
        ))
    }
}
```

## Notes

While normal Aptos operation prevents duplicate sequence numbers through transaction validation [7](#0-6) , defensive programming requires handling corrupted database states gracefully. This vulnerability demonstrates the importance of verifying assumptions even when deleting data, not just when writing it.

### Citations

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L143-157)
```rust
    pub fn prune_transaction_by_account(
        &self,
        transactions: &[(Version, Transaction)],
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for (_, transaction) in transactions {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    db_batch
                        .delete::<OrderedTransactionByAccountSchema>(&(txn.sender(), seq_num))?;
                }
            }
        }
        Ok(())
    }
```

**File:** storage/indexer_schemas/src/schema/ordered_transaction_by_account/mod.rs (L23-31)
```rust
define_pub_schema!(
    OrderedTransactionByAccountSchema,
    Key,
    Version,
    ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME
);

type SeqNum = u64;
type Key = (AccountAddress, SeqNum);
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L37-74)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        let candidate_transactions =
            self.get_pruning_candidate_transactions(current_progress, target_version)?;
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
        self.ledger_db.transaction_db().prune_transactions(
            current_progress,
            target_version,
            &mut batch,
        )?;
        self.transaction_store
            .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
        self.ledger_db.transaction_db().write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L106-131)
```rust
    fn get_pruning_candidate_transactions(
        &self,
        start: Version,
        end: Version,
    ) -> Result<Vec<(Version, Transaction)>> {
        ensure!(end >= start, "{} must be >= {}", end, start);

        let mut iter = self
            .ledger_db
            .transaction_db_raw()
            .iter::<TransactionSchema>()?;
        iter.seek(&start)?;

        // The capacity is capped by the max number of txns we prune in a single batch. It's a
        // relatively small number set in the config, so it won't cause high memory usage here.
        let mut txns = Vec::with_capacity((end - start) as usize);
        for item in iter {
            let (version, txn) = item?;
            if version >= end {
                break;
            }
            txns.push((version, txn));
        }

        Ok(txns)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L128-166)
```rust
    /// Saves signed transaction at `version`.
    pub(crate) fn put_transaction(
        // TODO(grao): Consider remove &self.
        &self,
        version: Version,
        transaction: &Transaction,
        skip_index: bool,
        batch: &mut impl WriteBatch,
    ) -> Result<()> {
        if !skip_index {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    batch.put::<OrderedTransactionByAccountSchema>(
                        &(txn.sender(), seq_num),
                        &version,
                    )?;
                }
            }
        }

        let transaction_hash = transaction.hash();

        if let Some(signed_txn) = transaction.try_as_signed_user_txn() {
            let txn_summary = IndexedTransactionSummary::V1 {
                sender: signed_txn.sender(),
                replay_protector: signed_txn.replay_protector(),
                version,
                transaction_hash,
            };
            batch.put::<TransactionSummariesByAccountSchema>(
                &(signed_txn.sender(), version),
                &txn_summary,
            )?;
        }
        batch.put::<TransactionByHashSchema>(&transaction_hash, &version)?;
        batch.put::<TransactionSchema>(&version, transaction)?;

        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```
