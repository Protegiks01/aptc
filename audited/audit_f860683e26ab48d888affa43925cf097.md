# Audit Report

## Title
Byzantine Validator Amplification Attack via Unbounded `contiguous_rounds` in RotatingProposer

## Summary
The `RotatingProposer` implementation lacks upper bound validation on the `contiguous_rounds` parameter, allowing Byzantine validators (up to f = ⌊n/3⌋) to amplify network disruption by refusing to propose during their allocated consecutive rounds. Each Byzantine proposer can waste `contiguous_rounds` rounds instead of the standard single round, creating an amplification factor that violates BFT liveness assumptions and can cause hours to days of network unavailability.

## Finding Description

The `RotatingProposer` struct assigns each validator `contiguous_rounds` consecutive rounds as proposer. [1](#0-0) 

The proposer selection formula [2](#0-1)  gives proposer at index `(round / contiguous_rounds) % proposers.len()` exactly `contiguous_rounds` consecutive rounds before rotating to the next validator.

When creating a `RotatingProposer` instance, the `contiguous_rounds` parameter comes directly from on-chain configuration without any validation or upper bound checks. [3](#0-2) 

**The Attack Path:**

1. System is configured with `ProposerElectionType::RotatingProposer(N)` where N is the `contiguous_rounds` value
2. Byzantine validators (up to f = ⌊n/3⌋) exist in the validator set per standard BFT assumptions
3. When a Byzantine validator's turn arrives, they are assigned rounds `[k*N, (k+1)*N)` for some k
4. The Byzantine validator refuses to propose during all N rounds
5. For each round, honest validators wait for a proposal, then timeout after 1-3 seconds [4](#0-3) 
6. After f+1 timeout votes, the "echo timeout" mechanism triggers [5](#0-4) 
7. After 2f+1 timeout votes, a `TwoChainTimeoutCertificate` forms and the round advances [6](#0-5) 
8. This process repeats for all N rounds in the Byzantine proposer's contiguous window

**Amplification Factor Calculation:**

- Standard BFT with single-round proposers: f Byzantine validators waste f rounds
- With `contiguous_rounds = N`: f Byzantine validators waste f × N rounds
- **Amplification factor = N** (unbounded)

**Concrete Example:**
- 100 validators, f = 33 Byzantine (standard 1/3 tolerance)
- `contiguous_rounds = 1000` (not unreasonable for perceived "stability")
- Average timeout = 2 seconds
- Total wasted rounds = 33 × 1000 = 33,000 rounds
- Total downtime = 33,000 × 2 seconds = 66,000 seconds ≈ **18.3 hours**

With `contiguous_rounds = 10,000`:
- Total downtime ≈ **7.6 days**

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos Bug Bounty criteria:
- **"Validator node slowdowns"**: Network block production is severely degraded
- **"Significant protocol violations"**: The BFT liveness guarantee is effectively nullified by the amplification factor

While the network technically maintains liveness (rounds eventually advance via timeout certificates), the practical availability is catastrophically degraded. The unbounded amplification transforms tolerable Byzantine behavior into a denial-of-service attack vector.

The lack of upper bound validation means even accidental misconfiguration (e.g., setting `contiguous_rounds` to 1,000,000) could cause weeks of network unavailability with just a single Byzantine validator.

## Likelihood Explanation

**Likelihood: Medium to High**

While the default configuration uses `LeaderReputation` [7](#0-6) , the `RotatingProposer` mode is a legitimate configuration option that may be selected for operational reasons (e.g., predictable rotation, testing, or specific network requirements).

Factors increasing likelihood:
1. No validation exists to prevent large `contiguous_rounds` values
2. No documentation warns about Byzantine amplification risks  
3. Operators may set large values believing it provides "stability"
4. Byzantine validators are assumed to exist in the standard BFT threat model (up to f = ⌊n/3⌋)
5. The attack is trivial to execute (simply don't propose)

The vulnerability exists in production code paths and can manifest whenever `RotatingProposer` is configured with non-minimal `contiguous_rounds` values.

## Recommendation

**Immediate Fixes:**

1. **Add upper bound validation** in `RotatingProposer::new()`:
```rust
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
    const MAX_CONTIGUOUS_ROUNDS: u32 = 10;
    assert!(
        contiguous_rounds > 0 && contiguous_rounds <= MAX_CONTIGUOUS_ROUNDS,
        "contiguous_rounds must be in range [1, {}], got {}",
        MAX_CONTIGUOUS_ROUNDS,
        contiguous_rounds
    );
    Self {
        proposers,
        contiguous_rounds,
    }
}
```

2. **Add validation in `create_proposer_election()`** to reject dangerous configurations:
```rust
match &onchain_config.proposer_election_type() {
    ProposerElectionType::RotatingProposer(contiguous_rounds) => {
        ensure!(
            *contiguous_rounds <= 10,
            "contiguous_rounds must be <= 10 to prevent Byzantine amplification attacks"
        );
        Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
    },
    // ...
}
```

3. **Implement adaptive skip mechanism**: After a proposer fails their first round (no proposal received), skip their remaining contiguous rounds and advance to the next proposer.

4. **Add documentation** warning about Byzantine amplification in `rotating_proposer_election.rs` and consensus configuration documentation.

**Long-term Solution:**

Consider deprecating `RotatingProposer` with `contiguous_rounds > 1` in favor of `LeaderReputation`, which adaptively selects proposers based on performance and naturally resists Byzantine amplification.

## Proof of Concept

```rust
// Test demonstrating Byzantine amplification attack
// Add to consensus/src/liveness/rotating_proposer_test.rs

#[test]
fn test_byzantine_amplification_with_large_contiguous_rounds() {
    use aptos_types::account_address::AccountAddress;
    use std::time::Duration;

    // Setup: 9 validators, 3 Byzantine (exactly f = n/3)
    let honest_validators: Vec<_> = (0..6).map(|_| AccountAddress::random()).collect();
    let byzantine_validators: Vec<_> = (0..3).map(|_| AccountAddress::random()).collect();
    
    let mut proposers = honest_validators.clone();
    proposers.extend(byzantine_validators.clone());
    
    // Large contiguous_rounds value
    const CONTIGUOUS_ROUNDS: u32 = 1000;
    let pe = RotatingProposer::new(proposers.clone(), CONTIGUOUS_ROUNDS);
    
    // Simulate network operation
    let timeout_duration = Duration::from_secs(2);
    let mut total_wasted_time = Duration::ZERO;
    let mut round = 0u64;
    
    // Run through one full cycle of all proposers
    for _ in 0..(proposers.len() as u64) {
        let proposer = pe.get_valid_proposer(round);
        
        // If Byzantine proposer, they waste all their contiguous rounds
        if byzantine_validators.contains(&proposer) {
            println!("Byzantine proposer {:?} wastes rounds {}-{}",
                proposer, round, round + CONTIGUOUS_ROUNDS as u64 - 1);
            total_wasted_time += timeout_duration * CONTIGUOUS_ROUNDS;
        }
        
        round += CONTIGUOUS_ROUNDS as u64;
    }
    
    // With 3 Byzantine validators out of 9, and contiguous_rounds = 1000:
    // Total wasted rounds = 3 * 1000 = 3000 rounds
    // Total wasted time = 3000 * 2 seconds = 6000 seconds = 1.67 hours
    
    println!("Total network downtime from Byzantine validators: {:?}", total_wasted_time);
    println!("This is {} times worse than standard BFT (contiguous_rounds=1)",
        CONTIGUOUS_ROUNDS);
    
    // Demonstrate the amplification factor
    let standard_bft_waste = timeout_duration * byzantine_validators.len() as u32;
    let actual_waste = total_wasted_time;
    let amplification_factor = actual_waste.as_secs() / standard_bft_waste.as_secs();
    
    assert_eq!(amplification_factor as u32, CONTIGUOUS_ROUNDS,
        "Byzantine impact should be amplified by contiguous_rounds factor");
}
```

**To reproduce:**
1. Configure Aptos network with `ProposerElectionType::RotatingProposer(1000)`
2. Include Byzantine validators (up to 33% of validator set)
3. Byzantine validators simply refuse to broadcast proposals during their allocated rounds
4. Observe network block production stalls for 1000 rounds per Byzantine proposer
5. Calculate cumulative downtime: (num_byzantine) × 1000 × (timeout_duration)

## Notes

This vulnerability specifically affects the `RotatingProposer` election type when configured with `contiguous_rounds > 1`. The default `LeaderReputation` mode is not affected as it adaptively penalizes non-performing validators. However, `RotatingProposer` remains a valid configuration option in the codebase without adequate safeguards against Byzantine amplification attacks.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L10-16)
```rust
pub struct RotatingProposer {
    // Ordering of proposers to rotate through (all honest replicas must agree on this)
    proposers: Vec<Author>,
    // Number of contiguous rounds (i.e. round numbers increase by 1) a proposer is active
    // in a row
    contiguous_rounds: u32,
}
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/epoch_manager.rs (L297-299)
```rust
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
```

**File:** consensus/src/liveness/round_state.rs (L117-123)
```rust
impl RoundTimeInterval for ExponentialTimeInterval {
    fn get_round_duration(&self, round_index_after_ordered_qc: usize) -> Duration {
        let pow = round_index_after_ordered_qc.min(self.max_exponent) as u32;
        let base_multiplier = self.exponent_base.powf(f64::from(pow));
        let duration_ms = ((self.base_ms as f64) * base_multiplier).ceil() as u64;
        Duration::from_millis(duration_ms)
    }
```

**File:** consensus/src/pending_votes.rs (L236-243)
```rust
            match validator_verifier.check_voting_power(partial_tc.signers(), true) {
                Ok(_) => {
                    return match partial_tc.aggregate_signatures(validator_verifier) {
                        Ok(tc_with_sig) => {
                            VoteReceptionResult::New2ChainTimeoutCertificate(Arc::new(tc_with_sig))
                        },
                        Err(e) => VoteReceptionResult::ErrorAggregatingTimeoutCertificate(e),
                    };
```

**File:** consensus/src/pending_votes.rs (L255-263)
```rust
        // Echo timeout if receive f+1 timeout message.
        if !self.echo_timeout {
            let f_plus_one = validator_verifier.total_voting_power()
                - validator_verifier.quorum_voting_power()
                + 1;
            if tc_voting_power >= f_plus_one {
                self.echo_timeout = true;
                return VoteReceptionResult::EchoTimeout(tc_voting_power);
            }
```

**File:** types/src/on_chain_config/consensus_config.rs (L488-503)
```rust
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
```
