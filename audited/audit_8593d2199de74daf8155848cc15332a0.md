# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Aptos Faucet IP Blocklist and Rate Limiting

## Summary
The Aptos faucet's `IpBlocklistChecker` and rate limiting systems treat IPv4 and IPv6 addresses as completely separate entities without normalizing IPv4-mapped IPv6 addresses (format: `::ffff:x.x.x.x`). This allows attackers to bypass IP blocklists and rate limits by using IPv4-mapped IPv6 representations of their blocked IPv4 addresses.

## Finding Description

The vulnerability exists in multiple components of the Aptos faucet system that perform IP-based security checks: [1](#0-0) 

The `IpBlocklistChecker::check` method handles IPv4 and IPv6 addresses separately, checking IPv4 addresses only against `ipv4_list` and IPv6 addresses only against `ipv6_list`. [2](#0-1) 

The underlying `IpRangeManager::contains_ip` method perpetuates this separation without any normalization logic.

IPv4-mapped IPv6 addresses (e.g., `::ffff:192.0.2.1`) are valid IPv6 addresses that represent IPv4 addresses in IPv6 format. When a client connects to a dual-stack server via IPv6, their IPv4 address may be represented as an IPv4-mapped IPv6 address.

**Attack Path:**
1. Administrator blocks malicious IPv4 address `192.0.2.1` by adding it to the blocklist file
2. Attacker connects to the faucet service using IPv6, which represents their address as `::ffff:192.0.2.1`
3. The faucet extracts the source IP from the request headers [3](#0-2) 

4. The source IP is `IpAddr::V6(::ffff:192.0.2.1)`, treated as a pure IPv6 address
5. The blocklist check only searches the `ipv6_list`, not the `ipv4_list`
6. The attacker bypasses the blocklist

**Amplified Impact via Rate Limiters:**

The same vulnerability affects rate limiting systems: [4](#0-3) 

The memory-based rate limiter uses the raw `source_ip` as a cache key. [5](#0-4) 

The Redis-based rate limiter converts `source_ip` to string without normalization, treating `192.0.2.1` and `::ffff:192.0.2.1` as different identities.

**Additional Impact on IP Allowlist:** [6](#0-5) 

The IP allowlist bypasser also suffers from the same issue, creating operational complexity where administrators must explicitly add both IPv4 and IPv4-mapped IPv6 formats to achieve consistent behavior.

## Impact Explanation

This vulnerability is **HIGH SEVERITY** according to Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violations**: The faucet's security controls (IP blocklists and rate limits) are fundamental to preventing abuse. Bypassing these controls violates the security design of the faucet service.

2. **Resource Exhaustion**: Attackers can abuse the faucet by bypassing rate limits, potentially exhausting testnet/devnet resources and degrading service availability for legitimate users.

3. **Operational Security Impact**: IP blocklists are critical security controls used to block malicious actors. This bypass completely defeats this protection mechanism.

4. **Easy Exploitation**: The attack requires no special privileges or complex setup—attackers simply need IPv6 connectivity, which is widely available.

While this does not affect consensus safety or mainnet funds (the faucet is for testnet/devnet only), it represents a significant operational security failure that can lead to service degradation and resource abuse.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Common Configuration**: Many modern servers and cloud platforms support dual-stack IPv4/IPv6 networking by default, making IPv4-mapped IPv6 addresses a common occurrence.

2. **Trivial Exploitation**: Attackers do not need specialized tools—standard IPv6 networking is sufficient. The bypass happens automatically when connecting via IPv6.

3. **No Detection Required**: Attackers don't need to discover a vulnerability; they may stumble upon the bypass simply by connecting via different network configurations.

4. **Active Blocklists**: Faucets typically maintain active IP blocklists to prevent abuse, meaning blocked attackers have strong motivation to find bypasses.

5. **Rate Limit Circumvention**: Even without being explicitly blocked, attackers can multiply their request quota by alternating between IPv4 and IPv6 formats.

## Recommendation

Implement IPv4-mapped IPv6 address normalization in the `IpRangeManager` or at the IP extraction point. The solution should check if an IPv6 address is IPv4-mapped and normalize it to IPv4 format before performing any security checks.

**Recommended Fix:**

Add a normalization function to `IpRangeManager`:

```rust
impl IpRangeManager {
    // Add this helper method
    fn normalize_ip(ip: &IpAddr) -> IpAddr {
        match ip {
            IpAddr::V6(v6) => {
                // Check if this is an IPv4-mapped IPv6 address
                if let Some(v4) = v6.to_ipv4_mapped() {
                    IpAddr::V4(v4)
                } else {
                    IpAddr::V6(*v6)
                }
            },
            IpAddr::V4(_) => *ip,
        }
    }

    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        let normalized_ip = Self::normalize_ip(ip);
        match normalized_ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(&ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(&ipv6),
        }
    }
}
```

Apply the same normalization in rate limiter key generation:

```rust
// In RedisRatelimitChecker::ratelimit_key_value
RatelimitKeyProvider::Ip => {
    let normalized_ip = normalize_ip(&data.source_ip);
    Ok(normalized_ip.to_string())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    use ipnet::{Ipv4Net, Ipv6Net};
    use iprange::IpRange;

    #[test]
    fn test_ipv4_mapped_ipv6_bypass() {
        // Create blocklist with IPv4 address
        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        ipv4_list.add("192.0.2.1/32".parse().unwrap());
        let ipv6_list = IpRange::<Ipv6Net>::new();
        
        let manager = IpRangeManager {
            ipv4_list,
            ipv6_list,
        };

        // Test that IPv4 address is blocked
        let ipv4_addr = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 1));
        assert!(manager.contains_ip(&ipv4_addr), "IPv4 should be blocked");

        // Test that IPv4-mapped IPv6 address bypasses the block
        let ipv4_mapped_ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x0201));
        assert!(!manager.contains_ip(&ipv4_mapped_ipv6), 
                "IPv4-mapped IPv6 bypasses blocklist - VULNERABILITY!");
        
        // Verify they represent the same address
        if let IpAddr::V6(v6) = ipv4_mapped_ipv6 {
            assert_eq!(v6.to_ipv4_mapped(), Some(Ipv4Addr::new(192, 0, 2, 1)),
                      "Addresses are equivalent but treated differently");
        }
    }

    #[test]
    fn test_rate_limit_bypass() {
        use std::collections::HashMap;
        
        let ipv4_addr = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 1));
        let ipv4_mapped_ipv6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x0201));
        
        // Simulate rate limiting by IP
        let mut rate_limit_map: HashMap<String, u32> = HashMap::new();
        
        // Make requests with IPv4
        rate_limit_map.insert(ipv4_addr.to_string(), 5);
        assert_eq!(*rate_limit_map.get(&ipv4_addr.to_string()).unwrap(), 5);
        
        // Make requests with IPv4-mapped IPv6 - bypasses rate limit!
        assert!(!rate_limit_map.contains_key(&ipv4_mapped_ipv6.to_string()),
                "IPv4-mapped IPv6 bypasses rate limit - VULNERABILITY!");
    }
}
```

## Notes

This vulnerability affects all IP-based security controls in the Aptos faucet system:
- IP blocklists
- Memory-based rate limiting  
- Redis-based rate limiting
- IP allowlists

The root cause is the lack of IPv4-mapped IPv6 address normalization throughout the IP handling pipeline. Administrators must currently maintain duplicate entries in blocklists/allowlists for both IPv4 and IPv4-mapped IPv6 formats to achieve consistent security controls, which is error-prone and defeats the purpose of these protections.

The fix should be applied at the lowest level (`IpRangeManager`) to ensure all dependent systems benefit from the normalization automatically.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L75-88)
```rust
        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```
