# Audit Report

## Title
Indexer-gRPC EventFilter Validation Bypass Allows Resource Exhaustion via Empty String Filters

## Summary
The `validate_state()` function in `EventFilter` is never invoked during filter parsing, and even if called, it fails to reject empty strings in filter parameters. This allows attackers to create useless filters that bypass validation and waste server resources by forcing evaluation against every event in the transaction stream.

## Finding Description

The indexer-grpc transaction filtering system has a critical validation gap. When clients submit `EventFilter` objects via gRPC requests, the validation logic defined in `validate_state()` is completely bypassed. [1](#0-0) 

The `parse_transaction_filter()` function only calls `new_from_proto()`, which performs structural protobuf conversion but never invokes `is_valid()` or `validate_state()`. This means the validation logic is effectively dead code. [2](#0-1) 

Even if validation were called, the `EventFilter.validate_state()` implementation has a critical weakness: [3](#0-2) 

While it checks that at least one field is `Some`, it delegates to `Option<String>::validate_state()` which always returns `Ok()` without checking for empty strings: [4](#0-3) 

Similarly, `MoveStructTagFilter::validate_state()` only checks if all fields are `None`, not if any field contains an empty string: [5](#0-4) 

**Attack Path:**
1. Attacker sends gRPC `GetTransactionsRequest` with malicious filter: `EventFilter { data_substring_filter: Some(""), struct_type: None }`
2. Filter passes structural validation (field is `Some`, not `None`)
3. Semantic validation is never called
4. Filter is created and registered for the stream
5. For every transaction, the filter's `matches()` method is invoked
6. Empty string creates a `Finder::new("")` which matches at position 0 of every string [6](#0-5) 

This creates a useless filter that either matches everything or performs unnecessary work, directly violating the system's design goal: [7](#0-6) 

## Impact Explanation

This vulnerability enables resource exhaustion attacks against the indexer-grpc API service:

1. **CPU Waste**: Each empty-string filter forces string matching operations on every event in every transaction
2. **Memory Waste**: Filter objects, `OnceCell`, and `Finder` instances consume heap memory
3. **Amplification**: Multiple concurrent requests multiply the resource consumption
4. **Availability Impact**: Under sustained attack, the indexer API could slow down significantly or crash, denying service to legitimate users

Per the Aptos bug bounty criteria, "API crashes" qualify as **High Severity**. However, since the attack requires sustained load to cause crashes (rather than a single request), and there is a 10KB filter size limit providing partial mitigation, this is more accurately assessed as **Medium Severity** - resource inefficiency that could lead to service degradation requiring intervention. [8](#0-7) 

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable:
- No authentication bypass required (API is designed for public access)
- Simple gRPC request with empty string parameter
- No special timing or race conditions needed
- Filter validation gap affects all indexer-grpc deployments

The only barrier is the 10KB filter size limit, which doesn't prevent the attack - it merely limits the number of useless filters per request. An attacker can send multiple requests to amplify the effect.

## Recommendation

Implement validation at the filter parsing stage and strengthen empty-value checks:

**1. Call validation in parse_transaction_filter():**
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    let filter = BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))?;
    
    // Validate the filter before use
    filter.is_valid()
        .map_err(|e| Status::invalid_argument(format!("Filter validation failed: {e:?}.")))?;
    
    Ok(filter)
}
```

**2. Add empty-string validation to Option<String>:**
```rust
impl Filterable<String> for Option<String> {
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        if let Some(s) = self {
            if s.is_empty() {
                return Err(Error::msg("String filter cannot be empty").into());
            }
        }
        Ok(())
    }
    // ... matches() unchanged
}
```

**3. Add empty-string validation to MoveStructTagFilter:**
```rust
impl Filterable<MoveStructTag> for MoveStructTagFilter {
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        let has_filter = self.address.is_some() || self.module.is_some() || self.name.is_some();
        if !has_filter {
            return Err(anyhow!("At least one of address, module or name must be set").into());
        }
        
        // Reject empty strings
        if self.address.as_ref().map_or(false, |s| s.is_empty()) ||
           self.module.as_ref().map_or(false, |s| s.is_empty()) ||
           self.name.as_ref().map_or(false, |s| s.is_empty()) {
            return Err(anyhow!("Filter fields cannot be empty strings").into());
        }
        
        Ok(())
    }
    // ... matches() unchanged
}
```

## Proof of Concept

```rust
use aptos_protos::indexer::v1::{BooleanTransactionFilter, EventFilter as ProtoEventFilter};
use aptos_transaction_filter::{BooleanTransactionFilter as InternalFilter, Filterable};

#[test]
fn test_empty_string_filter_bypass() {
    // Create a malicious filter with empty string
    let proto_filter = BooleanTransactionFilter {
        filter: Some(
            aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                aptos_protos::indexer::v1::ApiFilter {
                    filter: Some(
                        aptos_protos::indexer::v1::api_filter::Filter::EventFilter(
                            ProtoEventFilter {
                                data_substring_filter: Some("".to_string()), // Empty string!
                                struct_type: None,
                            }
                        )
                    )
                }
            )
        )
    };
    
    // This should fail but currently succeeds - validation is never called
    let filter = InternalFilter::new_from_proto(proto_filter, Some(10_000));
    assert!(filter.is_ok(), "Empty string filter incorrectly bypasses validation");
    
    let filter = filter.unwrap();
    
    // Demonstrate that validate_state would catch it IF called
    // (but it never is in production code)
    // Note: This would currently pass because Option<String>::validate_state() returns Ok()
    let validation_result = filter.is_valid();
    
    // Expected: Err, Actual: Ok - demonstrates the vulnerability
    println!("Validation result: {:?}", validation_result);
    
    // The filter will now be used to evaluate every transaction,
    // creating a Finder::new("") that wastes CPU on useless matching
}
```

**Notes**

This vulnerability exists because validation methods were implemented but never integrated into the request processing pipeline. The `is_valid()` trait method is only called recursively within the filter hierarchy for error tracing, never at the top level when parsing client requests. This makes all `validate_state()` implementations effectively unreachable code from the gRPC API entry points, allowing malformed filters to bypass all semantic validation checks.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L65-73)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.data_substring_filter.is_none() && self.struct_type.is_none() {
            return Err(Error::msg("At least one of data or struct_type must be set").into());
        };

        self.data_substring_filter.is_valid()?;
        self.struct_type.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L89-96)
```rust
        if let Some(data_substring_filter) = self.data_substring_filter.as_ref() {
            let finder = self
                .data_substring_finder
                .get_or_init(|| Finder::new(data_substring_filter).into_owned());
            if finder.find(item.data.as_bytes()).is_none() {
                return false;
            }
        }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/traits.rs (L108-121)
```rust
impl Filterable<String> for Option<String> {
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        Ok(())
    }

    #[inline]
    fn matches(&self, item: &String) -> bool {
        match self {
            Some(filter) => filter == item,
            None => true,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L76-81)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.address.is_none() && self.module.is_none() && self.name.is_none() {
            return Err(anyhow!("At least one of address, module or name must be set").into());
        };
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/README.md (L5-6)
```markdown
The goal of **transaction filtering** is to be able to save resources downstream of wherever filtering is used.
For this to be true, the filtering itself must be **fast and use minimal resources**, and so we do a few things:
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L20-21)
```rust
// Default maximum size in bytes for transaction filters.
pub const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```
