# Audit Report

## Title
Indexer Supply Tracking Incomplete: Coin-to-FungibleAsset Conversions Create Misleading Supply Data

## Summary
The indexer's `coin_supply` table only tracks `CoinInfo<AptosCoin>.supply` from the aggregator table but does not track the paired `FungibleAsset` supply. Since AptosCoin has a paired fungible asset representation created at genesis, users can freely convert between representations. These conversions cause the indexer to display incorrect total supply, potentially hiding legitimate minting operations or creating false burn signals that could mislead governance decisions and monitoring systems.

## Finding Description

The Aptos blockchain implements a dual-representation system for AptosCoin where coins can exist as both `Coin<AptosCoin>` and as a paired `FungibleAsset`. This pairing is established during genesis: [1](#0-0) 

When users convert between representations, the supplies adjust inversely: [2](#0-1) 

The blockchain correctly tracks total supply by aggregating both representations in the on-chain view function: [3](#0-2) 

However, the indexer only tracks the coin supply portion via aggregator table writes: [4](#0-3) 

The indexer processes only `WriteTableItem` changes that match the AptosCoin aggregator's handle and key, extracting the coin supply value. It has no mechanism to simultaneously track the fungible asset supply stored in `Supply` or `ConcurrentSupply` resources at the paired metadata object address. [5](#0-4) 

**Attack Scenario:**
1. An entity with legitimate minting authority (e.g., staking rewards) mints 1 million APT
2. These coins are immediately converted to FungibleAsset representation
3. The indexer shows coin supply decreased by 1 million (appears as burn)
4. The fungible asset supply increased by 1 million (not tracked by indexer)
5. Net effect: Indexer shows 1 million APT "disappeared" while true supply increased
6. Monitoring systems querying the indexer's `coin_supply` table see no supply increase
7. Governance proposals relying on indexer data for supply metrics receive false information

This breaks the **State Consistency** invariant (invariant #4) by creating divergence between on-chain truth and indexed data that external systems depend on for critical decisions.

## Impact Explanation

**Medium Severity** - "State inconsistencies requiring intervention"

This vulnerability causes the indexer to misrepresent the total APT supply, which affects:

1. **Governance Integrity**: Governance participants may make proposals or votes based on incorrect supply data from the indexer, affecting tokenomics decisions, inflation parameters, and validator reward rates.

2. **Monitoring System Failures**: External monitoring systems, dashboards, and analytics platforms querying the indexer's `coin_supply` table will show incorrect metrics, potentially triggering false alarms or missing real supply inflation.

3. **DeFi Protocol Risk**: DeFi protocols using the indexer for APT supply data in their oracle systems or collateral calculations will use incorrect values, potentially affecting liquidations and risk parameters.

While this does not directly compromise consensus or enable direct fund theft, it creates a reliable mechanism to obscure supply changes from off-chain observers, which is critical for transparency and governance of the blockchain.

## Likelihood Explanation

**High Likelihood** - This is actively occurring whenever coin-to-fungible-asset conversions happen.

The likelihood is high because:

1. **Genesis Enabled**: The pairing is created at genesis for all networks, making this issue universal. [6](#0-5) 

2. **No Access Control Needed**: Any user holding APT can trigger conversions through the primary fungible store interface, which internally calls the conversion functions.

3. **Legitimate Use Cases**: The fungible asset representation is actively promoted by the framework for interoperability, meaning conversions are expected normal behavior, not adversarial actions.

4. **Currently Undetected**: The issue is structural in the indexer's design and has likely been present since the fungible asset pairing was introduced.

## Recommendation

The indexer must track both coin supply AND paired fungible asset supply to provide accurate total supply data.

**Implementation Steps:**

1. **Extend CoinSupply Model**: Add a `fungible_asset_supply` field and `total_supply` computed field to the indexer's coin supply tracking.

2. **Track FungibleAsset Supply Changes**: In `coin_processor.rs`, when processing write set changes for AptosCoin, also check for `WriteResource` changes to `0x1::fungible_asset::Supply` or `0x1::fungible_asset::ConcurrentSupply` at the paired metadata address (0xa for AptosCoin).

3. **Parse Supply Resources**: Use similar logic to the token processor's fungible asset supply parsing: [7](#0-6) 

4. **Database Schema Update**: Add `fungible_asset_supply` column to `coin_supply` table and create a view that computes `total_supply = supply + fungible_asset_supply`.

5. **Update Queries**: Modify all queries and dashboards to use the `total_supply` field instead of raw `supply` field.

## Proof of Concept

```move
#[test_only]
module test_addr::supply_tracking_test {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::primary_fungible_store;
    use std::signer;

    #[test(framework = @aptos_framework, user = @0x456)]
    fun test_supply_divergence(framework: &signer, user: &signer) {
        // Setup: Initialize AptosCoin with pairing (done in genesis normally)
        // Assume framework has mint capability and has minted initial supply
        
        // Get initial on-chain supply (includes both representations)
        let initial_supply = coin::supply<AptosCoin>();
        
        // User has 1000 APT in coin form
        let user_addr = signer::address_of(user);
        let coins = coin::withdraw<AptosCoin>(user, 1000);
        
        // Convert all to fungible asset
        let fa = coin::coin_to_fungible_asset(coins);
        primary_fungible_store::deposit(user_addr, fa);
        
        // Check on-chain supply - should be unchanged
        let final_supply = coin::supply<AptosCoin>();
        assert!(initial_supply == final_supply, 1);
        
        // However, indexer querying CoinInfo<AptosCoin>.supply via aggregator
        // would show 1000 less (decrease)
        // And indexer has NO visibility into the fungible asset supply increase
        // Result: indexer shows net -1000 supply change when actual change is 0
    }
}
```

**Demonstration Steps:**
1. Query indexer's `coin_supply` table before conversion: `SELECT supply FROM coin_supply WHERE coin_type = '0x1::aptos_coin::AptosCoin' ORDER BY transaction_version DESC LIMIT 1`
2. Execute coin-to-fungible-asset conversion for large amount
3. Query indexer again: supply value has decreased
4. Query on-chain via node API `coin::supply<AptosCoin>()`: shows correct unchanged total
5. Discrepancy proves indexer is missing the fungible asset component

## Notes

The on-chain state and consensus mechanism are functioning correctly. The blockchain's view functions properly aggregate both representations. This is purely an indexer data completeness issue, but one with significant impact on off-chain systems that depend on the indexer for supply transparency and governance decision-making.

The fix requires coordination between the indexer schema, the coin processor logic, and potentially the GraphQL API layer to expose the corrected total supply metric to downstream consumers.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L138-150)
```text
    fun initialize_aptos_coin(aptos_framework: &signer) {
        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);

        coin::create_coin_conversion_map(aptos_framework);
        coin::create_pairing<AptosCoin>(aptos_framework);

        // Give stake module MintCapability<AptosCoin> so it can mint rewards.
        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.
        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);
        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.
        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L407-433)
```text
    /// Conversion from coin to fungible asset
    public fun coin_to_fungible_asset<CoinType>(
        coin: Coin<CoinType>
    ): FungibleAsset acquires CoinConversionMap, CoinInfo {
        let metadata = ensure_paired_metadata<CoinType>();
        let amount = burn_internal(coin);
        fungible_asset::mint_internal(metadata, amount)
    }

    /// Conversion from fungible asset to coin. Not public to push the migration to FA.
    fun fungible_asset_to_coin<CoinType>(
        fungible_asset: FungibleAsset
    ): Coin<CoinType> acquires CoinInfo, PairedCoinType {
        let metadata_addr =
            object::object_address(&fungible_asset::metadata_from_asset(&fungible_asset));
        assert!(
            object::object_exists<PairedCoinType>(metadata_addr),
            error::not_found(EPAIRED_COIN)
        );
        let coin_type_info = borrow_global<PairedCoinType>(metadata_addr).type;
        assert!(
            coin_type_info == type_info::type_of<CoinType>(),
            error::invalid_argument(ECOIN_TYPE_MISMATCH)
        );
        let amount = fungible_asset::burn_internal(fungible_asset);
        mint_internal<CoinType>(amount)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L838-850)
```text
    public fun supply<CoinType>(): Option<u128> acquires CoinInfo, CoinConversionMap {
        let coin_supply = coin_supply<CoinType>();
        let metadata = paired_metadata<CoinType>();
        if (option::is_some(&metadata)) {
            let fungible_asset_supply =
                fungible_asset::supply(option::extract(&mut metadata));
            if (option::is_some(&coin_supply)) {
                let supply = option::borrow_mut(&mut coin_supply);
                *supply = *supply + option::destroy_some(fungible_asset_supply);
            };
        };
        coin_supply
    }
```

**File:** crates/indexer/src/models/coin_models/coin_supply.rs (L28-96)
```rust
impl CoinSupply {
    /// Currently only supports aptos_coin. Aggregator table detail is in CoinInfo which for aptos coin appears during genesis.
    /// We query for the aggregator table details (handle and key) once upon indexer initiation and use it to fetch supply.
    pub fn from_write_table_item(
        write_table_item: &APIWriteTableItem,
        maybe_aptos_coin_info: &Option<CoinInfoQuery>,
        txn_version: i64,
        txn_timestamp: chrono::NaiveDateTime,
        txn_epoch: i64,
    ) -> anyhow::Result<Option<Self>> {
        if let Some(aptos_coin_info) = maybe_aptos_coin_info {
            // Return early if we don't have the aptos aggregator table info
            if aptos_coin_info.supply_aggregator_table_key.is_none()
                || aptos_coin_info.supply_aggregator_table_handle.is_none()
            {
                return Ok(None);
            }
            if let Some(data) = &write_table_item.data {
                // Return early if not aggregator table type
                if !(data.key_type == "address" && data.value_type == "u128") {
                    return Ok(None);
                }
                // Return early if not aggregator table handle
                if &write_table_item.handle.to_string()
                    != aptos_coin_info
                        .supply_aggregator_table_handle
                        .as_ref()
                        .unwrap()
                {
                    return Ok(None);
                }
                // Return early if not aptos coin aggregator key
                let table_key = data
                    .key
                    .as_str()
                    .context(format!("key is not a string: {:?}", data.key))?;
                if table_key
                    != aptos_coin_info
                        .supply_aggregator_table_key
                        .as_ref()
                        .unwrap()
                {
                    return Ok(None);
                }
                // Everything matches. Get the coin supply
                let supply = data
                    .value
                    .as_str()
                    .map(|s| s.parse::<BigDecimal>())
                    .context(format!(
                        "value is not a string: {:?}, table_item {:?}, version {}",
                        data.value, write_table_item, txn_version
                    ))?
                    .context(format!(
                        "cannot parse string as u128: {:?}, version {}",
                        data.value, txn_version
                    ))?;
                return Ok(Some(Self {
                    transaction_version: txn_version,
                    coin_type_hash: aptos_coin_info.coin_type_hash.clone(),
                    coin_type: aptos_coin_info.coin_type.clone(),
                    supply,
                    transaction_timestamp: txn_timestamp,
                    transaction_epoch: txn_epoch,
                }));
            }
        }
        Ok(None)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L110-120)
```text
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Supply has key {
        current: u128,
        // option::none() means unlimited supply.
        maximum: Option<u128>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ConcurrentSupply has key {
        current: Aggregator<u128>
    }
```

**File:** crates/indexer/src/models/coin_models/v2_fungible_asset_utils.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

// This is required because a diesel macro makes clippy sad
#![allow(clippy::extra_unused_lifetimes)]

use crate::{
    models::{
        move_resources::MoveResource,
        token_models::{token_utils::URI_LENGTH, v2_token_utils::ResourceReference},
    },
    util::truncate_str,
};
use anyhow::{Context, Result};
use aptos_api_types::{deserialize_from_string, WriteResource};
use bigdecimal::BigDecimal;
use serde::{Deserialize, Serialize};

const FUNGIBLE_ASSET_LENGTH: usize = 32;
const FUNGIBLE_ASSET_SYMBOL: usize = 10;

/* Section on fungible assets resources */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FungibleAssetMetadata {
    name: String,
    symbol: String,
    pub decimals: i32,
    icon_uri: String,
    project_uri: String,
}

impl FungibleAssetMetadata {
    pub fn from_write_resource(
        write_resource: &WriteResource,
        txn_version: i64,
    ) -> anyhow::Result<Option<Self>> {
        let type_str = format!(
            "{}::{}::{}",
            write_resource.data.typ.address,
            write_resource.data.typ.module,
            write_resource.data.typ.name
        );
        if !V2FungibleAssetResource::is_resource_supported(type_str.as_str()) {
            return Ok(None);
        }
        let resource = MoveResource::from_write_resource(
            write_resource,
            0, // Placeholder, this isn't used anyway
            txn_version,
            0, // Placeholder, this isn't used anyway
```
