# Audit Report

## Title
Race Condition in Order Vote Creation Allows Consensus on Blocks with Dummy Execution State

## Summary
PipelinedBlock objects can be accessed and used to create order votes before their asynchronous execution completes, resulting in order certificates that certify dummy/placeholder execution state (`ACCUMULATOR_PLACEHOLDER_HASH`) instead of actual execution results. This violates the consensus invariant that all validators must agree on identical state roots for identical blocks.

## Finding Description

Aptos implements a decoupled execution model where block ordering consensus occurs separately from execution. The vulnerability exists in the timing between block execution completion and order vote creation:

**Root Cause:**

When blocks are inserted into the block store, they are initialized with a dummy `StateComputeResult` containing `ACCUMULATOR_PLACEHOLDER_HASH` as the execution state root: [1](#0-0) 

The execution pipeline runs asynchronously and eventually calls `set_compute_result()` to update the block with real execution state: [2](#0-1) 

However, order votes can be created immediately after a QC is formed, without waiting for execution to complete: [3](#0-2) 

**Critical Flow:**

1. When `create_order_vote()` is called, it invokes `block.order_vote_proposal(qc)`: [4](#0-3) 

2. This calls `block_info()` which reads the current `compute_result()`: [5](#0-4) 

3. `compute_result()` simply locks and clones the current state without waiting for execution: [6](#0-5) 

**Safety Check Bypass:**

The safety rules verify that the QC and order vote proposal match, but this check passes when BOTH have dummy state: [7](#0-6) 

Since regular QCs are intentionally created with dummy state (via `decoupled_execution=true`), if the order vote is also created before execution completes, both will have matching dummy state and the check passes.

**Consensus Divergence Scenario:**

- Validator A (fast network/CPU): Receives QC, immediately broadcasts order vote with dummy state before execution completes
- Validator B (slower): Execution completes before creating order vote, broadcasts order vote with real execution state
- If 2f+1 validators are "fast," the order certificate will have `executed_state_id = ACCUMULATOR_PLACEHOLDER_HASH`
- If 2f+1 validators are "slow," the order certificate will have the real `executed_state_id`

This breaks deterministic execution as validators disagree on the certified execution state.

## Impact Explanation

**Critical Severity** - This vulnerability causes consensus safety violations:

1. **Breaks Deterministic Execution Invariant**: Different validators produce different order certificates for the same block, violating the requirement that "all validators must produce identical state roots for identical blocks"

2. **State Inconsistency**: Order certificates serve to certify execution results. Certificates with dummy state (placeholder hash) do not certify any meaningful execution, breaking the chain of state verification

3. **Potential Chain Split**: If different validator subsets form conflicting order certificates (some with dummy state, some with real state), this could lead to consensus divergence requiring manual intervention or hardfork to resolve

This qualifies as **Critical Severity** under Aptos bug bounty criteria: "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**High Likelihood** - This race condition occurs naturally in production:

1. **No Synchronization**: There is zero synchronization between execution completion and order vote creation. The code paths are entirely independent.

2. **Network Speed Dependency**: On fast networks, QCs can be formed and order vote broadcasts triggered within milliseconds, often faster than block execution (especially for blocks with complex transactions)

3. **No Validation**: Neither the safety rules nor the block store validate that execution has completed before allowing order vote creation

4. **Systemic Issue**: Every block processed through the decoupled execution pipeline is vulnerable to this race condition

The vulnerability triggers automatically without any attacker action required - it's a systemic timing issue in the consensus implementation.

## Recommendation

Add explicit synchronization to ensure execution completes before order votes can be created:

```rust
async fn broadcast_order_vote(
    &mut self,
    vote: &Vote,
    qc: Arc<QuorumCert>,
) -> anyhow::Result<()> {
    if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
        // **FIX: Wait for execution to complete before creating order vote**
        if let Some(pipeline_futs) = proposed_block.pipeline_futs() {
            // Wait for ledger_update_fut to ensure execution is complete
            pipeline_futs.ledger_update_fut.clone().await
                .map_err(|e| anyhow::anyhow!("Execution not complete: {:?}", e))?;
        }
        
        // Verify that execution state is not dummy
        let block_info = proposed_block.block_info();
        ensure!(
            !block_info.is_ordered_only(),
            "Cannot create order vote with dummy execution state"
        );
        
        let order_vote = self.create_order_vote(proposed_block.clone(), qc.clone()).await?;
        // ... rest of function
    }
    Ok(())
}
```

Additionally, add validation in safety rules:

```rust
pub(crate) fn verify_order_vote_proposal(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<(), Error> {
    // ... existing checks ...
    
    // **FIX: Reject order vote proposals with dummy execution state**
    if order_vote_proposal.block_info().is_ordered_only() {
        return Err(Error::InvalidOrderVoteProposal(
            "Block has not been executed yet - execution state is dummy".to_string()
        ));
    }
    
    Ok(())
}
```

## Proof of Concept

This vulnerability can be demonstrated by adding instrumentation to track the state at order vote creation time:

```rust
// Add to round_manager.rs in broadcast_order_vote before creating order vote:
let block_info = proposed_block.block_info();
if block_info.is_ordered_only() {
    error!(
        "RACE CONDITION DETECTED: Creating order vote with dummy state! \
         Block {}, executed_state_id = {:?}",
        block_info.id(),
        block_info.executed_state_id()
    );
}
```

Under normal operation with moderate block execution time (50-100ms) and fast consensus (10-20ms for QC formation), this log would fire frequently, proving that order votes are being created before execution completes.

A more complete reproduction would involve:
1. Setting up a local testnet with 4 validators
2. Submitting blocks with transactions that take 100ms+ to execute
3. Monitoring order vote messages on the network
4. Observing order votes with `executed_state_id == ACCUMULATOR_PLACEHOLDER_HASH` being broadcast and forming certificates

The vulnerability is systemic and does not require crafted attack transactions - it occurs naturally whenever execution takes longer than the time to form a QC and trigger order vote broadcast.

## Notes

This vulnerability is particularly insidious because:
- It appears to be working correctly under most conditions (validators do eventually get the right execution state via `set_compute_result`)
- The safety check in `verify_order_vote_proposal` gives false confidence - it ensures consistency between QC and order vote, but both can be consistently WRONG (both dummy state)
- The decoupled execution design is correct in principle, but the implementation fails to ensure proper sequencing between execution completion and order vote creation

The fix must maintain the performance benefits of decoupled execution while ensuring order votes only certify actual execution results, not placeholder values.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L394-398)
```rust
    pub fn new_ordered(block: Block, window: OrderedBlockWindow) -> Self {
        let input_transactions = Vec::new();
        let state_compute_result = StateComputeResult::new_dummy();
        Self::new(block, input_transactions, state_compute_result).with_block_window(window)
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L440-442)
```rust
    pub fn compute_result(&self) -> StateComputeResult {
        self.state_compute_result.lock().clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/src/pipeline/execution_schedule_phase.rs (L70-77)
```rust
        let fut = async move {
            for b in ordered_blocks.iter_mut() {
                let (compute_result, execution_time) = b.wait_for_compute_result().await?;
                b.set_compute_result(compute_result, execution_time);
            }
            Ok(ordered_blocks)
        }
        .boxed();
```

**File:** consensus/src/round_manager.rs (L1626-1651)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
        let order_vote_result = self
            .safety_rules
            .lock()
            .construct_and_sign_order_vote(&order_vote_proposal);
        let order_vote = order_vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {} for order vote",
            block.block()
        ))?;

        fail_point!("consensus::create_invalid_order_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_order_vote = OrderVote::new_with_signature(
                order_vote.author(),
                order_vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
            );
            Ok(faulty_order_vote)
        });
        Ok(order_vote)
    }
```

**File:** consensus/src/round_manager.rs (L1653-1689)
```rust
    async fn broadcast_order_vote(
        &mut self,
        vote: &Vote,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<()> {
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
            if !proposed_block.block().is_nil_block() {
                observe_block(
                    proposed_block.block().timestamp_usecs(),
                    BlockStage::ORDER_VOTED,
                );
            }
            if proposed_block.block().is_opt_block() {
                observe_block(
                    proposed_block.block().timestamp_usecs(),
                    BlockStage::ORDER_VOTED_OPT_BLOCK,
                );
            }
            let order_vote_msg = OrderVoteMsg::new(order_vote, qc.as_ref().clone());
            info!(
                self.new_log(LogEvent::BroadcastOrderVote),
                "{}", order_vote_msg
            );
            self.network.broadcast_order_vote(order_vote_msg).await;
            if proposed_block.pipeline_futs().is_some() {
                if let Some(tx) = proposed_block.pipeline_tx().lock().as_mut() {
                    let _ = tx.order_vote_tx.take().map(|tx| tx.send(()));
                }
            }
            ORDER_VOTE_BROADCASTED.inc();
        }
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```
