# Audit Report

## Title
DAG Quorum Store Configuration Mismatch Allows Oversized Batch Messages

## Summary
When DAG consensus is enabled, the `init_payload_provider()` function correctly uses `dag_config.quorum_store` with stricter limits (`receiver_max_num_batches = 5`), but the message validation in `process_message()` always uses the default `config.quorum_store` limits (`receiver_max_num_batches = 20`). This mismatch allows malicious validators to send messages with 4x more batches than the DAG architecture is designed to handle, potentially causing resource exhaustion and protocol violations.

## Finding Description
The vulnerability stems from an inconsistent configuration selection pattern in the EpochManager. When DAG consensus is enabled (`is_dag_enabled() == true`):

1. **Correct configuration selection** occurs in `init_payload_provider()`: [1](#0-0) 

This correctly selects the DAG-specific quorum store configuration where `receiver_max_num_batches = 5`.

2. **Incorrect configuration usage** occurs in `process_message()` when validating incoming batch messages: [2](#0-1) 

This always uses `self.config.quorum_store.receiver_max_num_batches` which defaults to 20, regardless of whether DAG is enabled.

The DAG-specific configuration explicitly sets smaller limits because DAG nodes must fit batches within strict size constraints: [3](#0-2) 

The validation function enforces this limit by rejecting messages that exceed `max_num_batches`: [4](#0-3) 

**Attack Vector:**
A malicious or misconfigured validator operating in a DAG-enabled network could send `ProofOfStoreMsg`, `SignedBatchInfoMsg`, or `BatchMsg` containing 6-20 batches. These messages would:
- Pass the validation check (since 6-20 â‰¤ 20)  
- Be processed by QuorumStore components configured for max 5 batches
- Violate DAG architectural constraints requiring small batches to fit in DAG nodes

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program as it creates state inconsistencies requiring intervention:

1. **Resource Exhaustion**: DAG nodes process up to 4x more batches than designed, consuming excessive memory and CPU resources
2. **Protocol Violation**: The DAG architecture explicitly requires small batches to fit within node size constraints, which this bypass violates
3. **Asymmetric Behavior**: Honest validators send 5 batches while malicious ones send 20, creating processing asymmetry that could affect consensus timing
4. **Potential Consensus Impact**: Resource exhaustion could cause validators to fall behind or timeout, potentially affecting liveness

While not immediately causing consensus safety breaks or fund loss, the mismatch violates critical design invariants and could lead to validator instability or network degradation.

## Likelihood Explanation
**Likelihood: Medium**

- Requires DAG consensus to be enabled (specific network configuration)
- Requires a malicious or misconfigured validator in the network
- The misconfiguration is straightforward to exploit once identified
- Under Byzantine fault tolerance assumptions, up to 1/3 malicious validators are expected
- The bug is deterministic and reliably exploitable

## Recommendation
Use the same configuration source for both QuorumStore initialization and message validation. Specifically, modify `process_message()` to select the appropriate configuration based on whether DAG is enabled:

```rust
// In process_message(), around line 1582:
let quorum_store_config = if self.epoch_state
    .as_ref()
    .and_then(|es| /* check if DAG enabled */)
    .unwrap_or(false) {
    &self.dag_config.quorum_store
} else {
    &self.config.quorum_store
};

let max_num_batches = quorum_store_config.receiver_max_num_batches;
let max_batch_expiry_gap_usecs = quorum_store_config.batch_expiry_gap_when_init_usecs;
```

Alternatively, store the selected `quorum_store_config` as a field in EpochManager during epoch initialization to ensure consistency across all uses.

## Proof of Concept
```rust
// Reproduction steps:
// 1. Start a network with DAG consensus enabled
// 2. Observe that init_payload_provider() sets receiver_max_num_batches = 5
// 3. From a validator node, craft a ProofOfStoreMsg with 15 batches
// 4. Send the message to peer validators
// 5. Observe that:
//    - The message passes validation (15 <= 20)
//    - But violates DAG's design expectation of max 5 batches
//    - Causes increased resource consumption on receiving nodes

// Test case in epoch_manager.rs:
#[test]
fn test_dag_config_mismatch() {
    // Setup DAG-enabled EpochManager
    let mut epoch_manager = /* initialize with DAG enabled */;
    
    // Verify init_payload_provider uses dag_config
    let (_, _, builder) = epoch_manager.init_payload_provider(/*...*/);
    // Assert builder uses receiver_max_num_batches = 5
    
    // Verify process_message uses config (wrong!)
    let msg = create_proof_of_store_msg_with_n_batches(15);
    let result = epoch_manager.process_message(peer_id, msg);
    // Assert message is accepted despite exceeding DAG limit
    assert!(result.is_ok()); // Bug: should fail with DAG config
}
```

## Notes
Additional configuration mismatches may exist at: [5](#0-4) [6](#0-5) [7](#0-6) 

These should be reviewed to ensure consistent configuration selection throughout the DAG lifecycle.

### Citations

**File:** consensus/src/epoch_manager.rs (L731-735)
```rust
        let quorum_store_config = if consensus_config.is_dag_enabled() {
            self.dag_config.quorum_store.clone()
        } else {
            self.config.quorum_store.clone()
        };
```

**File:** consensus/src/epoch_manager.rs (L905-909)
```rust
        let opt_qs_payload_param_provider = Arc::new(OptQSPullParamsProvider::new(
            self.config.quorum_store.enable_opt_quorum_store,
            self.config.quorum_store.opt_qs_minimum_batch_age_usecs,
            failures_tracker.clone(),
        ));
```

**File:** consensus/src/epoch_manager.rs (L945-947)
```rust
            self.config
                .quorum_store
                .allow_batches_without_pos_in_proposal,
```

**File:** consensus/src/epoch_manager.rs (L1510-1512)
```rust
            self.config
                .quorum_store
                .allow_batches_without_pos_in_proposal,
```

**File:** consensus/src/epoch_manager.rs (L1582-1584)
```rust
            let max_num_batches = self.config.quorum_store.receiver_max_num_batches;
            let max_batch_expiry_gap_usecs =
                self.config.quorum_store.batch_expiry_gap_when_init_usecs;
```

**File:** config/src/config/quorum_store_config.rs (L155-176)
```rust
    pub fn default_for_dag() -> Self {
        Self {
            sender_max_batch_txns: 300,
            sender_max_batch_bytes: 4 * 1024 * 1024,
            sender_max_num_batches: 5,
            sender_max_total_txns: 500,
            sender_max_total_bytes: 8 * 1024 * 1024,
            receiver_max_batch_txns: 300,
            receiver_max_batch_bytes: 4 * 1024 * 1024,
            receiver_max_num_batches: 5,
            receiver_max_total_txns: 500,
            receiver_max_total_bytes: 8 * 1024 * 1024,
            back_pressure: QuorumStoreBackPressureConfig {
                backlog_txn_limit_count: 100000,
                backlog_per_validator_batch_limit_count: 20,
                dynamic_min_txn_per_s: 100,
                dynamic_max_txn_per_s: 200,
                ..Default::default()
            },
            ..Default::default()
        }
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L573-578)
```rust
        ensure!(
            self.proofs.len() <= max_num_proofs,
            "Too many proofs: {} > {}",
            self.proofs.len(),
            max_num_proofs
        );
```
