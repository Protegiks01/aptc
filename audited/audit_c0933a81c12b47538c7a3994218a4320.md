# Audit Report

## Title
V2 Token Events Not Indexed When MODULE_EVENT_MIGRATION Feature Flag Enabled

## Summary
The indexer's `V2TokenEvent::from_event()` function only handles legacy V1 event types (`MintEvent`, `BurnEvent`, `TokenMutationEvent`) but not the new V2 event types (`Mint`, `Burn`, `Mutation`) emitted when the `MODULE_EVENT_MIGRATION` feature flag is enabled. Since this feature flag is enabled by default, all V2 token mints, burns, and mutations are silently dropped from the `token_activities_v2` indexer table, allowing malicious activity to go undetected.

## Finding Description
The Aptos Move framework conditionally emits different event types based on the `MODULE_EVENT_MIGRATION` feature flag: [1](#0-0) [2](#0-1) 

When `module_event_migration_enabled()` returns true, the framework emits the new `Mint` struct instead of `MintEvent`. The same pattern exists for burn operations and token mutations. [3](#0-2) 

The `MODULE_EVENT_MIGRATION` feature flag is **enabled by default**: [4](#0-3) 

However, the indexer's event parser only handles the **old** event type strings: [5](#0-4) 

The new event types use different struct names defined in the Rust type system: [6](#0-5) [7](#0-6) 

The indexer processes these events through `get_nft_v2_from_parsed_event()`: [8](#0-7) 

When `V2TokenEvent::from_event()` encounters the new event types (`0x4::collection::Mint`, `0x4::collection::Burn`, `0x4::token::Mutation`, `0x4::collection::Mutation`), it returns `Ok(None)` due to the default match arm, causing these events to be silently dropped from the `token_activities_v2` database table.

**Missing Event Types:**
1. `0x4::collection::Mint` (new) vs `0x4::collection::MintEvent` (old)
2. `0x4::collection::Burn` (new) vs `0x4::collection::BurnEvent` (old)
3. `0x4::token::Mutation` (new) vs `0x4::token::MutationEvent` (old)
4. `0x4::collection::Mutation` (new, no old equivalent captured by indexer)
5. `0x4::collection::SetMaxSupply` (new, no old equivalent)

## Impact Explanation
This vulnerability allows malicious actors to perform token operations that are invisible to indexers, explorers, wallets, and monitoring systems. With the feature flag enabled by default, ALL V2 token activities are currently unindexed, enabling:

- **Hidden minting**: Attackers can mint tokens without detection
- **Concealed burns**: Evidence destruction through burning goes unnoticed  
- **Invisible mutations**: Property changes and ownership manipulations are hidden
- **Collection manipulation**: Collection-level changes are not tracked

This qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category, as the indexer database contains incomplete state that requires code fixes and potentially full re-indexing to correct.

## Likelihood Explanation
**Likelihood: High** - The `MODULE_EVENT_MIGRATION` feature flag is enabled by default in production, meaning this issue affects all V2 token operations on current Aptos networks. Any token creator performing normal operations will have their activities silently dropped from the indexer without any indication of failure.

## Recommendation
Add cases for the new V2 event types to the match statement in `V2TokenEvent::from_event()`:

```rust
pub fn from_event(
    data_type: &str,
    data: &serde_json::Value,
    txn_version: i64,
) -> Result<Option<Self>> {
    match data_type {
        // Legacy V1 events
        "0x4::collection::MintEvent" => {
            serde_json::from_value(data.clone()).map(|inner| Some(Self::MintEvent(inner)))
        },
        "0x4::token::MutationEvent" => serde_json::from_value(data.clone())
            .map(|inner| Some(Self::TokenMutationEvent(inner))),
        "0x4::collection::BurnEvent" => {
            serde_json::from_value(data.clone()).map(|inner| Some(Self::BurnEvent(inner)))
        },
        "0x1::object::TransferEvent" => {
            serde_json::from_value(data.clone()).map(|inner| Some(Self::TransferEvent(inner)))
        },
        // NEW: Add V2 event support
        "0x4::collection::Mint" => {
            // Parse new Mint struct and convert to MintEvent format
            serde_json::from_value(data.clone()).map(|inner| Some(Self::MintEvent(inner)))
        },
        "0x4::collection::Burn" => {
            // Parse new Burn struct and convert to BurnEvent format
            serde_json::from_value(data.clone()).map(|inner| Some(Self::BurnEvent(inner)))
        },
        "0x4::token::Mutation" => {
            // Parse new Mutation struct and convert to TokenMutationEvent format
            serde_json::from_value(data.clone()).map(|inner| Some(Self::TokenMutationEvent(inner)))
        },
        _ => Ok(None),
    }
    .context(format!(
        "version {} failed! failed to parse type {}, data {:?}",
        txn_version, data_type, data
    ))
}
```

Note: The new event structs have different field structures (e.g., `Burn` includes `previous_owner`), so proper mapping logic is required to convert them to the existing enum variants or extend the enum to support both formats.

## Proof of Concept
1. Deploy a V2 token collection with the `MODULE_EVENT_MIGRATION` feature enabled (default)
2. Mint a token using any V2 token standard function
3. Query the indexer's `token_activities_v2` table for mint events
4. Observe that the mint event is missing despite the token being successfully minted on-chain
5. Verify the blockchain state shows the token exists but the indexer has no record of the mint activity

This can be reproduced by checking any mainnet/testnet indexer database for V2 token activities since the feature flag was enabled - there will be a noticeable gap in indexed events.

## Notes
The storage layer DOES have translators for these new events (`event_v2_translator.rs`), but those are for backward-compatible API responses, not for populating the indexer's activity tracking tables. The indexer and storage layer serve different purposes and have separate event processing pipelines.

### Citations

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L401-416)
```text
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Mint {
                        collection: collection_addr,
                        index: aggregator_v2::create_snapshot(supply.total_minted),
                        token,
                    },
                );
            } else {
                event::emit_event(&mut supply.mint_events,
                    MintEvent {
                        index: supply.total_minted,
                        token,
                    },
                );
            };
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L422-438)
```text
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Mint {
                        collection: collection_addr,
                        index: aggregator_v2::create_snapshot(supply.total_minted),
                        token,
                    },
                );
            } else {
                event::emit_event(
                    &mut supply.mint_events,
                    MintEvent {
                        index: supply.total_minted,
                        token,
                    },
                );
            };
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L489-527)
```text
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Burn {
                        collection: collection_addr,
                        index: *index.borrow(),
                        token,
                        previous_owner,
                    },
                );
            } else {
                event::emit_event(
                    &mut supply.burn_events,
                    BurnEvent {
                        index: *index.borrow(),
                        token,
                    },
                );
            };
        } else if (exists<UnlimitedSupply>(collection_addr)) {
            let supply = &mut UnlimitedSupply[collection_addr];
            supply.current_supply -= 1;
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Burn {
                        collection: collection_addr,
                        index: *index.borrow(),
                        token,
                        previous_owner,
                    },
                );
            } else {
                event::emit_event(
                    &mut supply.burn_events,
                    BurnEvent {
                        index: *index.borrow(),
                        token,
                    },
                );
            };
```

**File:** types/src/on_chain_config/aptos_features.rs (L228-228)
```rust
            FeatureFlag::MODULE_EVENT_MIGRATION,
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L520-532)
```rust
        match data_type {
            "0x4::collection::MintEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::MintEvent(inner)))
            },
            "0x4::token::MutationEvent" => serde_json::from_value(data.clone())
                .map(|inner| Some(Self::TokenMutationEvent(inner))),
            "0x4::collection::BurnEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::BurnEvent(inner)))
            },
            "0x1::object::TransferEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::TransferEvent(inner)))
            },
            _ => Ok(None),
```

**File:** types/src/account_config/events/mint.rs (L55-69)
```rust
impl MoveStructType for Mint {
    const MODULE_NAME: &'static IdentStr = ident_str!("collection");
    const STRUCT_NAME: &'static IdentStr = ident_str!("Mint");
}

impl MoveEventV2Type for Mint {}

pub static MINT_TYPE: Lazy<TypeTag> = Lazy::new(|| {
    TypeTag::Struct(Box::new(StructTag {
        address: TOKEN_OBJECTS_ADDRESS,
        module: ident_str!("collection").to_owned(),
        name: ident_str!("Mint").to_owned(),
        type_args: vec![],
    }))
});
```

**File:** types/src/account_config/events/burn.rs (L59-73)
```rust
impl MoveStructType for Burn {
    const MODULE_NAME: &'static IdentStr = ident_str!("collection");
    const STRUCT_NAME: &'static IdentStr = ident_str!("Burn");
}

impl MoveEventV2Type for Burn {}

pub static BURN_TYPE: Lazy<TypeTag> = Lazy::new(|| {
    TypeTag::Struct(Box::new(StructTag {
        address: TOKEN_OBJECTS_ADDRESS,
        module: ident_str!("collection").to_owned(),
        name: ident_str!("Burn").to_owned(),
        type_args: vec![],
    }))
});
```

**File:** crates/indexer/src/models/token_models/v2_token_activities.rs (L148-151)
```rust
        let event_type = event.typ.to_string();
        if let Some(token_event) =
            &V2TokenEvent::from_event(event_type.as_str(), &event.data, txn_version)?
        {
```
