# Audit Report

## Title
Storage Commit and Callback Execution Non-Atomicity Creates State Inconsistency Risk

## Summary
The consensus pipeline commits blocks to storage before invoking the post-commit callback. If the callback panics during execution, the block remains permanently committed to storage while in-memory state updates (root ledger info, block pruning) are not completed. This violates atomicity guarantees and can create validator state divergence.

## Finding Description

The vulnerability exists in the consensus pipeline's commit sequence, where storage persistence occurs before callback execution:

**Commit Sequence:**

1. `commit_ledger` executes and persists the block to storage [1](#0-0) 

2. `post_commit_ledger` then invokes the callback AFTER storage commit [2](#0-1) 

**Panic Points in Callback:**

The callback can panic at multiple points. In consensus mode, `BlockTree::commit_callback` contains an `.expect()` that panics if finality proof and commit decision are inconsistent [3](#0-2) 

**Error Propagation:**

When the callback panics, tokio catches it and converts it to `JoinError` [4](#0-3) 

This error propagates to child blocks because each block's `post_commit` waits for its parent [5](#0-4) 

**Consequence:**
- Storage shows block N is committed
- In-memory root ledger info still points to block N-1
- Block tree state is not pruned
- All subsequent blocks fail in `post_commit` phase
- Validator cannot process new blocks despite storage being ahead

**State Consistency Invariant Violation:**

This breaks the "State Consistency: State transitions must be atomic" invariant because storage commit and in-memory state update are not atomic. Different validators experiencing different panic conditions will have divergent in-memory states despite identical storage states.

## Impact Explanation

**Critical Severity** - This qualifies as a Consensus/Safety violation per Aptos bug bounty criteria:

1. **Validator Liveness Failure**: Affected validators cannot process subsequent blocks because `post_commit` error propagates, blocking the pipeline
2. **State Inconsistency**: Storage and in-memory state diverge permanently until restart
3. **Cross-Validator Divergence**: If only subset of validators experience the panic (due to subtle timing differences or transient conditions), the network has inconsistent validator states
4. **Non-Recoverable Without Restart**: The error propagation blocks all future blocks, requiring node restart to recover

While this requires a panic condition to trigger (not directly exploitable), it represents a fundamental design flaw that violates atomicity guarantees critical for consensus safety.

## Likelihood Explanation

**Medium-to-High Likelihood** if panic conditions exist:

The panic can be triggered by:
1. Logic bugs causing finality_proof/commit_decision mismatch
2. Race conditions in concurrent block processing
3. Transient state inconsistencies during epoch transitions
4. Edge cases in reconfig suffix blocks

The `.expect()` usage indicates this is considered an "impossible" condition, but defensive programming principles dictate that storage commits should be atomic with all state updates. The fact that `post_commit_fut` is not included in `wait_until_finishes` [6](#0-5)  suggests this phase is not critical-path, which is architecturally incorrect given its state update importance.

## Recommendation

**Fix 1: Atomic Commit-and-Callback Pattern**

Wrap both storage commit and callback in a transaction-like pattern using `catch_unwind`:

```rust
async fn post_commit_ledger(...) -> TaskResult<PostCommitResult> {
    // ... existing pre-conditions ...
    
    if let Some(ledger_info_with_sigs) = maybe_ledger_info_with_sigs {
        let order_proof = order_proof_fut.await?;
        
        // Execute callback with panic protection
        let callback_result = std::panic::catch_unwind(
            std::panic::AssertUnwindSafe(|| {
                block_store_callback(order_proof.clone(), ledger_info_with_sigs.clone());
            })
        );
        
        // If callback panics, log critical error but don't propagate
        // This prevents blocking child blocks while maintaining storage consistency
        if let Err(panic_err) = callback_result {
            error!(
                "CRITICAL: Callback panicked after storage commit for block {} {} {}: {:?}",
                block.id(), block.epoch(), block.round(), panic_err
            );
            // Consider triggering node restart or state sync recovery
        }
    }
    Ok(())
}
```

**Fix 2: Replace `.expect()` with Error Return**

In `BlockTree::commit_callback`, replace the panic with error handling:

```rust
let commit_proof = match finality_proof.create_merged_with_executed_state(commit_decision) {
    Ok(proof) => proof,
    Err(e) => {
        error!("Cannot merge finality proof with commit decision: {}", e);
        // Log the inconsistency but continue with best-effort state updates
        // Alternatively, trigger state sync to recover
        return;
    }
};
```

**Fix 3: Include `post_commit_fut` in Critical Path**

Ensure `post_commit` is awaited before considering block finalized:

```rust
pub async fn wait_until_finishes(self) {
    let _ = join!(
        // ... existing futures ...
        self.post_commit_fut,  // Add this
    ).await;
}
```

## Proof of Concept

Due to the need for engineering specific panic conditions, a full PoC requires a consensus protocol bug. However, the vulnerability can be demonstrated conceptually:

```rust
#[tokio::test]
async fn test_callback_panic_leaves_inconsistent_state() {
    // Setup: Create a validator with committed block at round N
    let mut block_tree = BlockTree::new(...);
    let storage = Arc::new(MockStorage::new());
    
    // Simulate storage commit (happens in commit_ledger)
    executor.commit_ledger(ledger_info_N).await.unwrap();
    // At this point, storage shows block N committed
    
    // Create mismatched finality_proof and commit_decision to trigger panic
    let finality_proof = create_proof_for_block_id(hash_A);
    let commit_decision = create_ledger_info_for_block_id(hash_B); // Different!
    
    // Callback panics here
    let result = std::panic::catch_unwind(|| {
        block_tree.commit_callback(
            storage.clone(),
            block_N.id(),
            block_N.round(),
            finality_proof,
            commit_decision,
            None
        );
    });
    
    assert!(result.is_err()); // Callback panicked
    
    // Verify state inconsistency:
    // 1. Storage shows block N committed
    assert_eq!(executor.committed_block_id(), block_N.id());
    
    // 2. But BlockTree root still at block N-1
    assert_eq!(block_tree.commit_root().id(), block_N_minus_1.id());
    
    // 3. Block N not pruned from in-memory tree
    assert!(block_tree.get_block(&block_N.id()).is_some());
    
    // This is the inconsistent state that violates atomicity
}
```

---

**Notes:**

The core issue is architectural: storage commits should be atomic with all state updates, including callback execution. The current design prioritizes commit latency over consistency guarantees. While the `.expect()` indicates the mismatch is considered impossible, defensive programming requires handling all error paths gracefully after storage mutation.

The vulnerability severity is Critical because it can cause validator liveness failures and state divergence, even though it requires a panic condition rather than direct attacker exploitation.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L156-162)
```rust
        match join_handle.await {
            Ok(Ok(res)) => Ok(res),
            Ok(e @ Err(TaskError::PropagatedError(_))) => e,
            Ok(Err(e @ TaskError::InternalError(_) | e @ TaskError::JoinError(_))) => {
                Err(TaskError::PropagatedError(Box::new(e)))
            },
            Err(e) => Err(TaskError::JoinError(Arc::new(e))),
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1098-1104)
```rust
        tokio::task::spawn_blocking(move || {
            executor
                .commit_ledger(ledger_info_with_sigs_clone)
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1123-1123)
```rust
        parent_post_commit.await?;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1137-1140)
```rust
        if let Some(ledger_info_with_sigs) = maybe_ledger_info_with_sigs {
            let order_proof = order_proof_fut.await?;
            block_store_callback(order_proof, ledger_info_with_sigs);
        }
```

**File:** consensus/src/block_storage/block_tree.rs (L578-580)
```rust
        let commit_proof = finality_proof
            .create_merged_with_executed_state(commit_decision)
            .expect("Inconsistent commit proof and evaluation decision, cannot commit block");
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L104-113)
```rust
    pub async fn wait_until_finishes(self) {
        let _ = join5(
            self.execute_fut,
            self.ledger_update_fut,
            self.pre_commit_fut,
            self.commit_ledger_fut,
            self.notify_state_sync_fut,
        )
        .await;
    }
```
