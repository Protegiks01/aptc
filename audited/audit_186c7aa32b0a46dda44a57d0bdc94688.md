# Audit Report

## Title
Mempool Gas-Price-Agnostic Eviction Allows Low-Priority Transaction DoS with Retry Loop Amplification

## Summary

The Aptos mempool lacks gas-price-based eviction when at capacity, allowing an attacker to fill it with low-gas-price transactions that block high-priority legitimate transactions. Combined with the Rosetta API marking `MempoolIsFull` errors as retriable, this creates retry loops that amplify the denial-of-service impact on transaction submission infrastructure. [1](#0-0) 

## Finding Description

The vulnerability consists of two components working together:

**Component 1: Gas-Price-Agnostic Eviction**

When the mempool reaches capacity (2,000,000 transactions or 2GB), the eviction logic only removes "parked" (non-ready) transactions, completely ignoring gas price prioritization: [2](#0-1) 

The capacity check occurs before any priority-based admission: [3](#0-2) 

**Component 2: Retriable Flag Causing Retry Amplification**

The Rosetta API marks `MempoolIsFull` as a retriable error, instructing clients to retry indefinitely: [4](#0-3) 

**Attack Path:**

1. Attacker creates ~20,000 funded accounts
2. Submits 100 transactions per account (capacity_per_user limit) with:
   - Correct sequence numbers (making them "ready", not parked)
   - Minimum gas price (e.g., 1 gas unit)
   - Valid signatures
3. This fills mempool to 2,000,000 ready transactions
4. Legitimate user submits high-gas-price transaction
5. `check_is_full_after_eviction()` is invoked:
   - Mempool is full (2M transactions)
   - Incoming transaction is ready
   - Attempts to evict from parking lot
   - Parking lot is empty (all attacker transactions are ready)
   - Returns `MempoolIsFull` error
6. Rosetta API marks error as retriable
7. Client retries while mempool remains full

The attack exploits that consensus prioritizes by gas price when pulling transactions, but mempool admission does NOT prioritize by gas price when at capacity. High-priority transactions cannot displace low-priority ones. [5](#0-4) 

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria for the following reasons:

1. **API Infrastructure Impact**: The retry loop amplification can cause widespread API slowdowns as thousands of clients simultaneously retry failed submissions, potentially overwhelming Rosetta API infrastructure.

2. **Transaction Submission Denial**: Legitimate high-priority transactions (e.g., time-sensitive DeFi operations, emergency governance actions) are blocked from entering the mempool during the attack window.

3. **Resource Limits Invariant Violation**: Breaks the documented invariant that "All operations must respect gas, storage, and computational limits" by not respecting gas price prioritization in resource-constrained scenarios.

4. **Prolonged Impact Potential**: While individual transactions expire after 10 minutes (system TTL), an attacker can sustain the attack by continuously submitting new batches, though at significant cost. [6](#0-5) 

The attack does not require validator access and can be executed by any external actor with sufficient funds.

## Likelihood Explanation

**Moderate to High Likelihood:**

**Prerequisites:**
- Attacker needs ~20,000 funded accounts (achievable but requires capital)
- Must generate ~2M valid signatures (computationally intensive but feasible)
- Attack cost scales with duration (transactions eventually get executed and attacker pays gas)

**Attack Sustainability:**
- Initial fill: One-time cost to create and fill mempool
- Maintenance: Continuous refilling required as transactions expire every 10 minutes
- System clears via: GC (60s intervals), consensus commits, and system TTL (600s)

**Real-World Scenarios:**
- During legitimate network congestion, the issue manifests naturally (mempool full of valid high-activity transactions blocks others)
- Malicious actor can weaponize this by deliberately filling with low-gas spam
- Most critical during high-value events (token launches, governance votes) when legitimate users compete for mempool space

The code comment acknowledges retry loop risk but dismisses it: "Note, there is a possibility that some of these could be retriable forever". [7](#0-6) 

## Recommendation

Implement gas-price-based eviction when mempool is at capacity:

```rust
fn check_is_full_after_eviction(
    &mut self,
    txn: &MempoolTransaction,
    account_sequence_number: Option<u64>,
) -> bool {
    if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
        let now = Instant::now();
        let mut evicted_txns = 0;
        let mut evicted_bytes = 0;
        
        // First try evicting from parking lot
        while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
            // [existing eviction logic]
        }
        
        // If still full, evict lowest-priority ready transactions
        // if incoming transaction has higher priority
        if self.is_full() && txn.ranking_score > 0 {
            while let Some(lowest_priority_key) = self.priority_index.get_lowest() {
                if lowest_priority_key.gas_ranking_score < txn.ranking_score {
                    // Evict this transaction
                    if let Some(evicted) = self.remove_transaction(
                        &lowest_priority_key.address, 
                        lowest_priority_key.replay_protector
                    ) {
                        evicted_txns += 1;
                        evicted_bytes += evicted.get_estimated_bytes() as u64;
                        if !self.is_full() {
                            break;
                        }
                    }
                } else {
                    break; // Incoming txn has lower priority
                }
            }
        }
        
        if evicted_txns > 0 {
            counters::CORE_MEMPOOL_PRIORITY_EVICTED_COUNT.observe(evicted_txns as f64);
        }
    }
    self.is_full()
}
```

Additionally, consider adding:
1. Rate limiting per sender address for mempool submissions
2. Minimum gas price threshold that increases dynamically when mempool is near capacity
3. Separate error code for "rejected due to low priority" vs "temporarily full"

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_mempool_low_gas_dos_with_retry_loop() {
    use aptos_mempool::core_mempool::CoreMempool;
    use aptos_config::config::MempoolConfig;
    use aptos_types::transaction::SignedTransaction;
    
    // Create mempool with small capacity for testing
    let mut config = MempoolConfig::default();
    config.capacity = 100;
    config.capacity_per_user = 10;
    let mempool = Arc::new(Mutex::new(CoreMempool::new(&config)));
    
    // Step 1: Fill mempool with low-gas transactions
    for account_idx in 0..10 {
        let account = create_test_account(account_idx);
        for seq_num in 0..10 {
            let low_gas_txn = create_transaction(
                account,
                seq_num,
                1, // minimum gas price
            );
            let status = mempool.lock().add_txn(
                low_gas_txn,
                0,
                seq_num,
                TimelineState::NotReady,
            );
            assert_eq!(status.code, MempoolStatusCode::Accepted);
        }
    }
    
    // Verify mempool is full
    assert_eq!(mempool.lock().get_committed_txn_count(), 100);
    
    // Step 2: Attempt to submit high-priority transaction
    let high_priority_account = create_test_account(999);
    let high_gas_txn = create_transaction(
        high_priority_account,
        0,
        1000, // high gas price
    );
    
    let status = mempool.lock().add_txn(
        high_gas_txn.clone(),
        0,
        0,
        TimelineState::Ready,
    );
    
    // Step 3: Verify rejection despite higher priority
    assert_eq!(status.code, MempoolStatusCode::MempoolIsFull);
    
    // Step 4: Verify Rosetta marks as retriable
    let rosetta_error = ApiError::from(
        RestError::Api(AptosError::new_with_error_code(
            "Mempool is full",
            AptosErrorCode::MempoolIsFull,
        ))
    );
    assert!(rosetta_error.retriable()); // This causes retry loops
    
    // High-priority transaction cannot enter despite higher gas price
    // Low-priority transactions remain in mempool
    // Client will retry indefinitely per Rosetta spec
}
```

**Notes:**

The vulnerability is real but has important limitations:
- Attack requires significant resources (~20,000 funded accounts)
- Transactions expire after 10 minutes unless continuously refilled
- Well-implemented clients should have retry limits despite "retriable" flag
- During legitimate high network activity, same behavior occurs naturally

The core issue is architectural: mempool admission policy does not align with consensus selection policy (both should prioritize by gas price).

### Citations

**File:** crates/aptos-rosetta/src/error.rs (L150-151)
```rust
    /// Retriable errors will allow for Rosetta upstreams to retry.  These are only for temporary
    /// state blockers.  Note, there is a possibility that some of these could be retriable forever (e.g. an account is never created).
```

**File:** crates/aptos-rosetta/src/error.rs (L152-162)
```rust
    pub fn retriable(&self) -> bool {
        use ApiError::*;
        matches!(
            self,
            AccountNotFound(_)
                | BlockNotFound(_)
                | MempoolIsFull(_)
                | GasEstimationFailed(_)
                | CoinTypeFailedToBeFetched(_)
        )
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L415-456)
```rust
    fn check_is_full_after_eviction(
        &mut self,
        txn: &MempoolTransaction,
        account_sequence_number: Option<u64>,
    ) -> bool {
        if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
            let now = Instant::now();
            // try to free some space in Mempool from ParkingLot by evicting non-ready txns
            let mut evicted_txns = 0;
            let mut evicted_bytes = 0;
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
            }
            if evicted_txns > 0 {
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                    .observe(now.elapsed().as_secs_f64());
            }
        }
        self.is_full()
    }
```

**File:** mempool/src/core_mempool/index.rs (L193-198)
```rust
    fn cmp(&self, other: &OrderedQueueKey) -> Ordering {
        // Higher gas preferred
        match self.gas_ranking_score.cmp(&other.gas_ranking_score) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
```

**File:** config/src/config/mempool_config.rs (L121-129)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
            default_failovers: 1,
            enable_intelligent_peer_prioritization: true,
            shared_mempool_peer_update_interval_ms: 1_000,
            shared_mempool_priority_update_interval_secs: 600, // 10 minutes (frequent reprioritization is expensive)
            shared_mempool_failover_delay_ms: 500,
            system_transaction_timeout_secs: 600,
```
