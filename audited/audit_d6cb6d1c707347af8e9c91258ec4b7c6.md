# Audit Report

## Title
Division-by-Zero Panic in Proposer Election Causes Total Network Halt When All Validators Fall Below Minimum Stake

## Summary
The `choose_index()` function in the proposer election mechanism performs a modulo operation with zero when the validator set becomes empty or all validators have zero stake weight, causing a panic that halts consensus across all nodes. This can occur when all validators fall below the `minimum_stake` threshold during epoch transitions, as there is no safeguard preventing an empty active validator set.

## Finding Description

The vulnerability exists in the leader election mechanism used by AptosBFT consensus. When selecting a proposer for each round, the system calls `choose_index()` to randomly select a validator weighted by their stake. [1](#0-0) 

The function computes cumulative weights and then calls `next_in_range(state, total_weight)` to generate a random value. The critical issue is in `next_in_range()`: [2](#0-1) 

When `total_weight` is zero (empty validator set or all-zero stake weights), the expression `u128::from_le_bytes(temp) % max` performs a division by zero, causing a panic.

The chosen index is used directly to access the proposers list without bounds checking: [3](#0-2) 

**How This Condition Occurs:**

During epoch transitions in `on_new_epoch()`, validators are filtered based on minimum stake requirements: [4](#0-3) 

The filtered validators are assigned to the active set: [5](#0-4) 

**There is no assertion that `next_epoch_validators` is non-empty.** If all validators fall below `minimum_stake`, the active validator set becomes empty.

When `create_proposer_election()` is called, it retrieves an empty proposers list: [6](#0-5) 

This leads to empty `voting_powers` and `stake_weights`: [7](#0-6) [8](#0-7) 

**Attack Path:**

1. **Governance Manipulation**: Malicious governance proposal sets `minimum_stake` to an extremely high value exceeding all current validators' stake
2. **Epoch Transition**: During `on_new_epoch()`, all validators are filtered out as they fall below the new threshold
3. **Empty Validator Set**: `active_validators` becomes an empty vector
4. **Consensus Halt**: Every call to `get_valid_proposer()` panics with division-by-zero, nodes cannot propose or vote on blocks
5. **Network Freeze**: All nodes halt, requiring a hard fork to recover

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

- **Total loss of liveness/network availability**: All consensus nodes panic when attempting to elect a proposer, causing complete network halt
- **Non-recoverable network partition (requires hardfork)**: Once triggered, nodes cannot progress. Recovery requires coordinated hard fork to restore validator set or reduce minimum stake, as the network cannot process any transactions including governance proposals

The impact affects:
- All validator nodes (consensus halt)
- All users (cannot submit transactions)
- All dApps (complete service disruption)
- Network requires emergency hard fork intervention

## Likelihood Explanation

**Likelihood: Medium-High**

While not trivial to trigger accidentally, multiple realistic scenarios can cause this:

1. **Governance Attack**: Attacker gains sufficient voting power (or exploits governance vulnerability) to pass a proposal setting `minimum_stake` unreasonably high
2. **Coordinated Mass Withdrawal**: Economic incentives or coordination leads validators to simultaneously withdraw stake below threshold
3. **Configuration Error During Upgrade**: Network upgrade misconfigures `minimum_stake` or validator stakes
4. **Edge Case During Testnet/Devnet**: More likely on test networks with fewer validators and lower stakes

The lack of validation (no assertion that active validators must be non-empty) makes this a latent bug waiting to be triggered.

## Recommendation

Add validation to prevent empty validator sets at multiple layers:

**Layer 1: Stake Module Validation**
```move
// In stake.move, after line 1401:
validator_set.active_validators = next_epoch_validators;
assert!(
    vector::length(&validator_set.active_validators) > 0,
    error::invalid_state(ENO_ACTIVE_VALIDATORS)
);
```

**Layer 2: Staking Config Validation**
```move
// Validate minimum_stake changes cannot exclude all validators
public fun update_minimum_stake(new_minimum: u64) {
    // Ensure at least one validator can meet the new minimum
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    let validators_meeting_threshold = 0;
    // Count validators that would survive the new minimum
    // Reject if count would be zero
}
```

**Layer 3: Proposer Election Defensive Check**
```rust
// In choose_index(), add:
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    assert!(!weights.is_empty(), "Cannot choose from empty validator set");
    let mut total_weight = 0;
    // ... rest of function
    assert!(total_weight > 0, "Total voting power cannot be zero");
    // ... continue
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_choose_index_empty_weights_panic() {
    use crate::liveness::proposer_election::choose_index;
    
    // Empty validator set - should panic with division by zero
    let empty_weights: Vec<u128> = vec![];
    let state = vec![1, 2, 3, 4]; // arbitrary state
    
    // This will panic at next_in_range(state, 0) with modulo zero
    let _ = choose_index(empty_weights, state);
}

#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_choose_index_all_zero_weights_panic() {
    use crate::liveness::proposer_election::choose_index;
    
    // All validators have zero stake - should panic with division by zero
    let zero_weights: Vec<u128> = vec![0, 0, 0, 0];
    let state = vec![1, 2, 3, 4];
    
    // This will panic at next_in_range(state, 0) with modulo zero
    let _ = choose_index(zero_weights, state);
}
```

**Move Integration Test:**
```move
#[test(framework = @aptos_framework)]
#[expected_failure(abort_code = ENO_ACTIVE_VALIDATORS)]
fun test_epoch_transition_prevents_empty_validator_set(framework: &signer) {
    // Setup: Initialize with validators at minimum stake
    // Set all validators' stake below new minimum
    // Call on_new_epoch()
    // Should abort instead of allowing empty active_validators
}
```

**Notes**

The vulnerability stems from missing defensive programming at the boundary between the Move staking module and the Rust consensus layer. While the Move code filters validators correctly based on minimum stake requirements, it lacks validation that the result is non-empty. The Rust consensus code assumes it will always receive a non-empty validator list, creating a critical gap where division-by-zero can occur.

This is particularly dangerous because it cannot be recovered from without a hard fork - once triggered, nodes cannot process transactions to fix the governance parameters or validator stakes that caused the issue.

### Citations

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-715)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/liveness/leader_reputation.rs (L732-733)
```rust
        let chosen_index = choose_index(stake_weights, state);
        (proposers[chosen_index], voting_power_participation_ratio)
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1397)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1401-1403)
```text
        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
        validator_set.total_joining_power = 0;
```

**File:** consensus/src/epoch_manager.rs (L292-295)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
```

**File:** consensus/src/epoch_manager.rs (L347-359)
```rust
                let voting_powers: Vec<_> = if weight_by_voting_power {
                    proposers
                        .iter()
                        .map(|p| {
                            epoch_state
                                .verifier
                                .get_voting_power(p)
                                .expect("INVARIANT VIOLATION: proposer not in verifier set")
                        })
                        .collect()
                } else {
                    vec![1; proposers.len()]
                };
```
