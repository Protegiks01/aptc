# Audit Report

## Title
Precision Loss in Gas Unit Conversion During Transaction Simulation

## Summary
The `simulate_transaction()` function uses incorrect integer division instead of proper rounding when converting `min_transaction_gas_units` from InternalGas to external Gas units, causing precision loss of up to 33% with default parameters.

## Finding Description

In the transaction simulation API, the code incorrectly converts between internal and external gas units: [1](#0-0) 

This uses raw integer division which truncates rather than rounding up. The codebase has established proper conversion methods that should be used instead: [2](#0-1) 

The correct conversion uses `to_unit_round_up_with_params()`, which properly rounds up during the division operation: [3](#0-2) 

With default gas parameters:
- `min_transaction_gas_units` = 2,760,000 (InternalGas)
- `gas_unit_scaling_factor` = 1,000,000 [4](#0-3) [5](#0-4) 

Current buggy calculation: 2,760,000 / 1,000,000 = **2 Gas units**
Correct calculation: ceiling(2,760,000 / 1,000,000) = **3 Gas units**

This 33% underestimation is used as the floor for `max_account_gas_units`: [6](#0-5) 

## Impact Explanation

This is a **Low severity** issue per Aptos bug bounty criteria. While it causes incorrect gas estimates in the simulation API, it does NOT affect actual transaction execution security because:

1. The VM's actual gas validation uses the correct conversion method and will reject under-gased transactions
2. No funds can be stolen or minted
3. Consensus safety is not affected
4. No validator nodes are impacted

The impact is limited to poor UX where users receive underestimated gas requirements and may have transactions fail validation.

## Likelihood Explanation

This bug occurs on **every call** to `simulate_transaction()` with `estimate_max_gas_amount=true`, making it highly reproducible. However, it's a quality/correctness issue rather than a security vulnerability since the actual VM execution path enforces correct gas limits.

## Recommendation

Replace the integer division with the proper conversion method:

```rust
let min_number_of_gas_units: u64 =
    gas_params.vm.txn.min_transaction_gas_units
        .to_unit_round_up_with_params(&gas_params.vm.txn)
        .into();
```

This ensures proper rounding and consistency with the rest of the codebase.

## Proof of Concept

```rust
use aptos_gas_algebra::InternalGas;
use aptos_gas_schedule::gas_schedule::TransactionGasParameters;

#[test]
fn test_gas_conversion_precision_loss() {
    let gas_params = TransactionGasParameters::default();
    
    // Buggy conversion (current code)
    let buggy_result = u64::from(gas_params.min_transaction_gas_units) 
        / u64::from(gas_params.gas_unit_scaling_factor);
    
    // Correct conversion
    let correct_result: u64 = gas_params.min_transaction_gas_units
        .to_unit_round_up_with_params(&gas_params)
        .into();
    
    assert_eq!(buggy_result, 2);     // Wrong: loses precision
    assert_eq!(correct_result, 3);   // Correct: rounds up
    
    println!("Precision loss: {} gas units underestimated", 
             correct_result - buggy_result);
}
```

## Notes

While this is a genuine implementation bug causing measurable precision loss, it fails the validation criteria for a security vulnerability because it:
- Cannot be exploited to steal funds or break consensus
- Does not affect actual transaction execution (which uses correct methods)
- Is limited to API simulation responses (Low severity UX issue)

The bug should be fixed for correctness, but it does not pose a security risk to the Aptos network.

### Citations

**File:** api/src/transactions.rs (L654-656)
```rust
                let min_number_of_gas_units =
                    u64::from(gas_params.vm.txn.min_transaction_gas_units)
                        / u64::from(gas_params.vm.txn.gas_unit_scaling_factor);
```

**File:** api/src/transactions.rs (L705-713)
```rust
                // To give better error messaging, we should not go below the minimum number of gas units
                let max_account_gas_units =
                    std::cmp::max(min_number_of_gas_units, max_account_gas_units);

                // Minimum of the max account and the max total needs to be used for estimation
                Some(std::cmp::min(
                    max_account_gas_units,
                    max_number_of_gas_units,
                ))
```

**File:** aptos-move/aptos-vm/src/gas.rs (L157-158)
```rust
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L266-279)
```rust
fn apply_ratio_round_up(val: u64, nominator: u64, denominator: u64) -> u64 {
    assert_ne!(nominator, 0);
    assert_ne!(denominator, 0);

    let n = val as u128 * nominator as u128;
    let d = denominator as u128;

    let res = n / d + if n.is_multiple_of(d) { 0 } else { 1 };
    if res > u64::MAX as u128 {
        u64::MAX
    } else {
        res as u64
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L33-36)
```rust
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L83-86)
```rust
            gas_unit_scaling_factor: GasScalingFactor,
            "gas_unit_scaling_factor",
            GAS_SCALING_FACTOR
        ],
```
