# Audit Report

## Title
Heterogeneous Quorum Store Filter Configurations Cause Batch Certificate Failures and Consensus Liveness Degradation

## Summary
Validators with different `quorum_store_filter` configurations can disagree on batch validity, preventing batch certificate generation and degrading quorum store throughput. When some validators have filtering enabled while others have it disabled, batches containing filtered transactions will timeout without reaching quorum, causing validator resource waste and consensus performance degradation.

## Finding Description

The `quorum_store_filter` is a per-validator configuration that filters transactions in batches before signing them. [1](#0-0) 

The critical issue is that each validator independently loads its filter configuration from local node configuration files, with no network-level consensus on filter rules. [2](#0-1) 

When a batch is received, validators apply their local filter. If enabled and ANY transaction is rejected, the ENTIRE batch message is dropped without signing. [3](#0-2) 

This creates a consensus divergence scenario:

1. **Validator A** (filter disabled) creates a batch with transactions T1, T2, T3 where T2 matches a filter rule
2. **Validators B, C, D** (filter enabled) receive the batch and reject it entirely, sending no signature back
3. **Validators E, F** (filter disabled) accept the batch and send signatures
4. **Validator A** attempts to aggregate signatures in ProofCoordinator but cannot reach the 2f+1 quorum threshold if B, C, D represent >1/3 voting power
5. After `proof_timeout_ms`, the batch expires without certificate generation [4](#0-3) 
6. Metrics show this as a timeout [5](#0-4) 
7. The batch is removed from in-progress tracking [6](#0-5) 

The existing test suite confirms this behavior - batches are either fully accepted or fully rejected based on local filter configuration. [7](#0-6) 

**Broken Invariant:** This violates the **Deterministic Execution** invariant - validators must agree on what constitutes a valid batch for the quorum store to function correctly. Non-deterministic batch acceptance breaks consensus liveness guarantees.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Validators waste CPU cycles processing batches that will never reach quorum, repeatedly broadcasting and timing out batches containing filtered transactions.

2. **Significant Protocol Violations**: The quorum store protocol assumes validators agree on batch validity. Heterogeneous filtering violates this assumption, causing systematic batch certificate generation failures.

3. **Consensus Liveness Degradation**: In severe cases where many batches contain filtered transactions, quorum store throughput can degrade significantly, reducing overall network performance.

The impact is amplified because:
- Validators may legitimately have different compliance requirements necessitating different filters
- No warning mechanism alerts operators to configuration divergence
- Failed batches waste network bandwidth broadcasting to validators that will reject them
- Transactions in failed batches must be re-proposed, increasing latency

## Likelihood Explanation

**Likelihood: High** in production environments due to:

1. **Decentralized Configuration**: Validators independently manage node configurations with no central coordination mechanism
2. **Compliance Requirements**: Different jurisdictions may require validators to filter different transaction types
3. **Rolling Updates**: During configuration updates, validators will temporarily have different filter settings
4. **No Validation**: The system provides no checks, warnings, or consensus on filter configurations
5. **Silent Failures**: Batch timeouts appear in metrics but don't clearly indicate configuration divergence as the root cause

The vulnerability is inherent to the current design where local node configuration affects network-level consensus decisions without coordination.

## Recommendation

Implement one of the following mitigations:

**Option 1: Network-Level Filter Consensus (Recommended)**
Add filter configuration to on-chain consensus parameters or epoch configuration. All validators must use the same filter rules within an epoch.

**Option 2: Batch Pre-Validation**
Before broadcasting batches, query a representative sample of validators to check if they would accept the batch under their local filters. Only broadcast if sufficient validators signal acceptance.

**Option 3: Configuration Warning System**
Implement network-level monitoring that detects filter configuration divergence and alerts operators via metrics/logs when validators have incompatible settings.

**Option 4: Disable Quorum Store Filtering**
Mark `quorum_store_filter` as deprecated and move transaction filtering to earlier stages (mempool) where local filtering doesn't affect network consensus.

**Code Fix Sketch (Option 3 - Detection):**
```rust
// In BatchCoordinator::handle_batches_msg, add after filtering:
if self.transaction_filter_config.is_enabled() {
    // Log that this validator has filtering enabled
    // to help operators detect configuration divergence
    counters::QUORUM_STORE_FILTER_ENABLED.set(1);
}
```

## Proof of Concept

The following test demonstrates the vulnerability:

```rust
#[tokio::test]
async fn test_heterogeneous_filter_configs_cause_quorum_failure() {
    // Validator 1: Filter disabled
    let filter_disabled = BatchTransactionFilterConfig::new(false, BatchTransactionFilter::empty());
    
    // Validator 2: Filter enabled, rejecting specific sender
    let transactions = create_signed_transactions(10);
    let filter_enabled = BatchTransactionFilterConfig::new(
        true,
        BatchTransactionFilter::empty().add_sender_filter(false, transactions[0].sender())
    );
    
    // Create two batch coordinators with different configs
    let mut coordinator1 = create_batch_coordinator(/* ... */, filter_disabled);
    let mut coordinator2 = create_batch_coordinator(/* ... */, filter_enabled);
    
    // Create batch with the filtered transaction
    let batch = Batch::new_v1(BatchId::new_for_test(100), transactions.clone(), /* ... */);
    let author = AccountAddress::random();
    
    // Coordinator 1 (filter disabled) accepts the batch
    coordinator1.handle_batches_msg(author, vec![batch.clone()]).await;
    // Verify signature sent
    
    // Coordinator 2 (filter enabled) rejects the batch
    coordinator2.handle_batches_msg(author, vec![batch.clone()]).await;
    // Verify NO signature sent (silent drop)
    
    // Result: Batch author cannot collect enough signatures for quorum
    // After proof_timeout_ms, batch expires with TIMEOUT_BATCHES_COUNT incremented
}
```

## Notes

This vulnerability is particularly concerning because it's a **systemic design issue** rather than a simple bug. The transaction filtering feature itself works as designed, but its interaction with the quorum store consensus mechanism creates an implicit requirement for configuration uniformity that is not enforced.

The issue becomes more severe as the network grows and validators become more heterogeneous in their compliance requirements. Without coordination mechanisms, this will lead to increasing batch timeout rates and degraded network performance over time.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L17-17)
```rust
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
```

**File:** config/src/config/transaction_filters_config.rs (L81-88)
```rust
impl Default for BatchTransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                                     // Disable the filter
            batch_transaction_filter: BatchTransactionFilter::empty(), // Use an empty filter
        }
    }
}
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L189-213)
```rust
        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L369-402)
```rust
    async fn expire(&mut self) {
        let mut batch_ids = vec![];
        for signed_batch_info_info in self.timeouts.expire() {
            if let Some(state) = self.batch_info_to_proof.remove(&signed_batch_info_info) {
                if !state.completed {
                    batch_ids.push(signed_batch_info_info.batch_id());
                }
                Self::update_counters_on_expire(&state);

                // We skip metrics if the proof did not complete and did not get a self vote, as it
                // is considered a proof that was re-inited due to a very late vote.
                if !state.completed && !state.self_voted {
                    continue;
                }

                if !state.completed {
                    counters::TIMEOUT_BATCHES_COUNT.inc();
                    info!(
                        LogSchema::new(LogEvent::IncrementalProofExpired),
                        digest = signed_batch_info_info.digest(),
                        self_voted = state.self_voted,
                    );
                }
            }
        }
        if self
            .batch_generator_cmd_tx
            .send(BatchGeneratorCommand::ProofExpiration(batch_ids))
            .await
            .is_err()
        {
            warn!("Failed to send proof expiration to batch generator");
        }
    }
```

**File:** consensus/src/quorum_store/counters.rs (L735-741)
```rust
pub static TIMEOUT_BATCHES_COUNT: Lazy<IntCounter> = Lazy::new(|| {
    register_int_counter!(
        "quorum_store_timeout_batch_count",
        "Count of the timeout batches at the sender side."
    )
    .unwrap()
});
```

**File:** consensus/src/quorum_store/batch_generator.rs (L554-564)
```rust
                        BatchGeneratorCommand::ProofExpiration(batch_ids) => {
                            for batch_id in batch_ids {
                                counters::BATCH_IN_PROGRESS_TIMEOUT.inc();
                                debug!(
                                    "QS: received timeout for proof of store, batch id = {}",
                                    batch_id
                                );
                                // Not able to gather the proof, allow transactions to be polled again.
                                self.remove_batch_in_progress(self.my_peer_id, batch_id);
                            }
                        },
```

**File:** consensus/src/quorum_store/tests/batch_coordinator_test.rs (L84-120)
```rust
async fn test_handle_batches_msg_filter_enabled() {
    // Create the message channels
    let (sender_to_proof_manager, _receiver_for_proof_manager) = channel(100);
    let (sender_to_batch_generator, mut receiver_for_batch_generator) = channel(100);

    // Create a filtering config with filtering enabled (the first transaction sender is rejected)
    let transactions = create_signed_transactions(10);
    let transaction_filter =
        BatchTransactionFilter::empty().add_sender_filter(false, transactions[0].sender());
    let transaction_filter_config = BatchTransactionFilterConfig::new(true, transaction_filter);

    // Create a batch coordinator
    let mut batch_coordinator = create_batch_coordinator(
        sender_to_proof_manager,
        sender_to_batch_generator,
        transaction_filter_config,
    );

    // Create a single batch
    let account_address = AccountAddress::random();
    let batch = Batch::new_v1(
        BatchId::new_for_test(109),
        transactions.clone(),
        1,
        1,
        account_address,
        0,
    );

    // Handle a batches message
    batch_coordinator
        .handle_batches_msg(account_address, vec![batch])
        .await;

    // Verify that the receiver for the batch generator does not receive the batch
    assert!(receiver_for_batch_generator.recv().now_or_never().is_none());
}
```
