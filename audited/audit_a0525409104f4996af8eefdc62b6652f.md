# Audit Report

## Title
Memory Exhaustion via Vec<Vec<u8>> Deserialization in Consensus Block Proposals

## Summary
The `vec_bytes::deserialize()` function lacks bounds checking, allowing malicious validators to propose consensus blocks containing transactions with crafted `EntryFunction` payloads that consume significantly more memory during deserialization than their serialized size suggests. This exploits the gap between network-level limits (64 MiB) and consensus validation limits (6 MB), causing validator node memory exhaustion before block validation rejects oversized proposals.

## Finding Description

The vulnerability exists in how consensus block proposals are processed: [1](#0-0) 

This deserializer has no size limits or bounds checking. It's used by the `EntryFunction` struct for transaction arguments: [2](#0-1) 

**Attack Flow:**

1. **Network Reception**: The network layer accepts messages up to MAX_MESSAGE_SIZE (64 MiB): [3](#0-2) 

2. **Deserialization Before Validation**: When a block proposal arrives, it's fully deserialized by the network layer before being passed to consensus: [4](#0-3) 

3. **Late Validation**: Block size validation only occurs in `process_proposal()` AFTER deserialization: [5](#0-4) 

4. **Size Calculation Mismatch**: The validation uses `raw_txn_bytes_len()` which returns BCS serialized size: [6](#0-5) 
   
   with a default limit of 6 MB: [7](#0-6) 

**Memory Amplification:**

In Rust, `Vec<T>` has a 24-byte header (pointer, capacity, length). When deserializing `Vec<Vec<u8>>` with many small inner vectors:

- **Serialized (BCS)**: Each inner `Vec<u8>` = 1 byte (length prefix) + data
- **Deserialized**: Each inner `Vec<u8>` = 24 bytes (header) + data

**Example Attack:**
- Craft 10 million inner vectors, each containing 3 bytes
- Serialized size: ~40 MB (within 64 MiB network limit)
- Deserialized memory: 10M Ã— 27 bytes = ~270 MB
- **Amplification factor: 6.75x**

An attacker proposing a block at the network limit (64 MiB) with optimally crafted `Vec<Vec<u8>>` structures could allocate **400+ MB of memory** before consensus validation rejects the oversized block. Repeated malicious proposals across multiple rounds cause cumulative memory exhaustion and GC thrashing, degrading validator performance.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty: "Validator node slowdowns")

**Impact Scope:**
- All honest validators processing malicious block proposals
- Memory exhaustion occurs before validation can reject the block
- Repeated attacks cause sustained performance degradation
- GC pressure from allocating then discarding large structures
- Can affect consensus liveness if validators slow down significantly

**Invariant Violated:**
- **Resource Limits**: "All operations must respect gas, storage, and computational limits"
- The deserialization bypasses memory limits by exploiting the validation timing gap

**Affected Nodes:** All validators receiving the malicious proposal

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a validator (to propose blocks)
- No additional Byzantine behavior or collusion needed
- Any validator can perform this attack when elected as proposer

**Exploitation Complexity:**
- Low: Simply craft transactions with pathological `Vec<Vec<u8>>` structures
- Automated: Can be repeated every time the attacker is proposer
- Difficult to detect: Appears as legitimate proposals until validation

**Attack Frequency:**
- Can occur once per round when attacker is proposer
- In a rotating leader protocol, happens periodically
- Cumulative effect across multiple rounds

## Recommendation

**Immediate Fix:** Add bounds checking to `vec_bytes::deserialize()`:

```rust
pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<u8>>, D::Error>
where
    D: Deserializer<'de>,
{
    const MAX_OUTER_VEC_LEN: usize = 100_000; // Reasonable limit
    const MAX_INNER_VEC_LEN: usize = 1_000_000; // 1 MB per inner vector
    
    let outer_vec = <Vec<serde_bytes::ByteBuf>>::deserialize(deserializer)?;
    
    if outer_vec.len() > MAX_OUTER_VEC_LEN {
        return Err(serde::de::Error::custom(
            format!("Vec<Vec<u8>> outer length {} exceeds limit {}", 
                    outer_vec.len(), MAX_OUTER_VEC_LEN)
        ));
    }
    
    let mut result = Vec::with_capacity(outer_vec.len().min(MAX_OUTER_VEC_LEN));
    for inner in outer_vec {
        if inner.len() > MAX_INNER_VEC_LEN {
            return Err(serde::de::Error::custom(
                format!("Vec<Vec<u8>> inner length {} exceeds limit {}", 
                        inner.len(), MAX_INNER_VEC_LEN)
            ));
        }
        result.push(inner.into_vec());
    }
    
    Ok(result)
}
```

**Defense in Depth:**
1. Add early size validation during BCS deserialization before full object construction
2. Implement memory-aware limits for transaction argument sizes
3. Add monitoring for abnormal memory spikes during block processing
4. Consider streaming deserialization with size tracking

## Proof of Concept

```rust
// PoC: Demonstrate memory amplification
use aptos_types::transaction::EntryFunction;
use move_core_types::{
    identifier::Identifier,
    language_storage::ModuleId,
    account_address::AccountAddress,
};

fn main() {
    // Create EntryFunction with pathological Vec<Vec<u8>> args
    let num_inner_vecs = 1_000_000;
    let bytes_per_inner = 3;
    
    let mut args: Vec<Vec<u8>> = Vec::with_capacity(num_inner_vecs);
    for _ in 0..num_inner_vecs {
        args.push(vec![0u8; bytes_per_inner]);
    }
    
    let entry_fn = EntryFunction::new(
        ModuleId::new(AccountAddress::ZERO, Identifier::new("test").unwrap()),
        Identifier::new("func").unwrap(),
        vec![],
        args,
    );
    
    // Serialize
    let serialized = bcs::to_bytes(&entry_fn).unwrap();
    println!("Serialized size: {} MB", serialized.len() / (1024 * 1024));
    
    // Deserialize (allocates significantly more memory)
    let _deserialized: EntryFunction = bcs::from_bytes(&serialized).unwrap();
    
    // Estimated memory:
    // - Serialized: ~4 MB
    // - Deserialized: 1M * 27 bytes = ~27 MB
    // - Amplification: ~6.75x
    
    println!("Memory amplification achieved!");
    println!("A malicious validator can send blocks up to 64 MiB that");
    println!("expand to ~400+ MB in memory before validation rejects them.");
}
```

**Notes:**
- The PoC demonstrates the memory amplification principle
- In a real attack, the malicious validator would wrap multiple such transactions in a block proposal
- The attack succeeds because deserialization happens before the `max_receiving_block_bytes` check
- Repeated proposals cause sustained memory pressure and validator slowdowns

### Citations

**File:** types/src/serde_helper/vec_bytes.rs (L21-29)
```rust
pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<u8>>, D::Error>
where
    D: Deserializer<'de>,
{
    Ok(<Vec<serde_bytes::ByteBuf>>::deserialize(deserializer)?
        .into_iter()
        .map(serde_bytes::ByteBuf::into_vec)
        .collect())
}
```

**File:** types/src/transaction/script.rs (L113-114)
```rust
    #[serde(with = "vec_bytes")]
    args: Vec<Vec<u8>>,
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/src/network.rs (L863-900)
```rust
                        consensus_msg @ (ConsensusMsg::ProposalMsg(_)
                        | ConsensusMsg::OptProposalMsg(_)
                        | ConsensusMsg::VoteMsg(_)
                        | ConsensusMsg::RoundTimeoutMsg(_)
                        | ConsensusMsg::OrderVoteMsg(_)
                        | ConsensusMsg::SyncInfo(_)
                        | ConsensusMsg::EpochRetrievalRequest(_)
                        | ConsensusMsg::EpochChangeProof(_)) => {
                            if let ConsensusMsg::ProposalMsg(proposal) = &consensus_msg {
                                observe_block(
                                    proposal.proposal().timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED,
                                );
                                info!(
                                    LogSchema::new(LogEvent::NetworkReceiveProposal)
                                        .remote_peer(peer_id),
                                    block_round = proposal.proposal().round(),
                                    block_hash = proposal.proposal().id(),
                                );
                            }
                            if let ConsensusMsg::OptProposalMsg(proposal) = &consensus_msg {
                                observe_block(
                                    proposal.timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED,
                                );
                                observe_block(
                                    proposal.timestamp_usecs(),
                                    BlockStage::NETWORK_RECEIVED_OPT_PROPOSAL,
                                );
                                info!(
                                    LogSchema::new(LogEvent::NetworkReceiveOptProposal)
                                        .remote_peer(peer_id),
                                    block_author = proposal.proposer(),
                                    block_epoch = proposal.epoch(),
                                    block_round = proposal.round(),
                                );
                            }
                            Self::push_msg(peer_id, consensus_msg, &self.consensus_messages_tx);
```

**File:** consensus/src/round_manager.rs (L1187-1193)
```rust
        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** types/src/transaction/mod.rs (L1294-1298)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
    }
```

**File:** config/src/config/consensus_config.rs (L231-231)
```rust
            max_receiving_block_bytes: 6 * 1024 * 1024, // 6MB
```
