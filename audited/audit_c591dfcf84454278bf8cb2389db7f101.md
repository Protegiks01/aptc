# Audit Report

## Title
Redis Credential Exposure Through Display and Debug Trait Implementations in Indexer Services

## Summary
The `RedisUrl` type in the indexer-grpc utilities implements `Display` and `Debug` traits that directly expose the full Redis URL including embedded passwords. This leads to credential leakage in error messages, normal operation logs, and debug output across multiple indexer service components, allowing unauthorized parties with log access to obtain Redis authentication credentials.

## Finding Description

The `RedisUrl` wrapper type implements `Display` trait by directly delegating to the underlying `Url` type's Display implementation, which exposes the complete URL including any embedded credentials: [1](#0-0) 

Additionally, the type derives `Debug` trait which similarly exposes the full URL: [2](#0-1) 

This vulnerability manifests in multiple critical locations:

**1. Data Service Error Context**: When Redis client creation fails, the error message includes the full URL with credentials: [3](#0-2) 

**2. Cache Worker Error Context**: Similar credential exposure during cache worker initialization: [4](#0-3) 

**3. File Store Processor Error Context**: Credentials exposed in two separate error contexts during processor initialization: [5](#0-4) 

**4. Normal Operation Logging**: Most critically, the data service explicitly prints Redis URL to stdout during normal startup operations, exposing credentials even when no errors occur: [6](#0-5) 

**5. Configuration Debug Output**: Configuration structs that contain `RedisUrl` fields derive `Debug`, exposing credentials when configs are logged or displayed: [7](#0-6) [8](#0-7) 

Redis URLs commonly contain passwords in formats like `redis://:password@host:6379` or `redis://username:password@host:6379`. When these URLs are formatted via Display or Debug traits, the passwords are included in plaintext in logs, error messages, and stdout.

## Impact Explanation

This vulnerability qualifies as **High Severity** based on the Aptos bug bounty criteria for the following reasons:

1. **API Service Compromise**: Exposed Redis credentials grant attackers access to the indexer's cache layer, enabling them to corrupt cached transaction data, delete cache entries, or manipulate cache state. This can directly cause **API crashes** (a High severity impact per bounty criteria) when the data service attempts to serve corrupted data or encounters unexpected cache states.

2. **Broad Exposure Surface**: Credentials are leaked through multiple vectors:
   - Normal operation logs (stdout during startup)
   - Error logs (when Redis connections fail)
   - Debug/diagnostic output (configuration dumps)
   - Log aggregation systems (centralized logging)

3. **Unauthorized Access Scope**: Logs are typically accessible to:
   - System operators and administrators
   - Monitoring and observability platforms
   - Log aggregation services
   - Security information and event management (SIEM) systems
   - Potentially external log analysis services

4. **Service Disruption Potential**: Once an attacker obtains Redis credentials, they can:
   - Corrupt transaction cache data causing incorrect responses
   - Delete cache entries forcing expensive recomputation
   - Inject malicious data into the cache
   - Cause service degradation or complete unavailability

The impact extends beyond simple information disclosure to potential **API crashes** and **significant service disruption**, meeting the High severity threshold defined in the bug bounty program.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exposure:

1. **Guaranteed Exposure During Normal Operation**: The println statement in the data service config guarantees credential exposure on every service startup, not just during error conditions.

2. **Common Error Scenario**: Redis connection failures are common operational issues (network problems, Redis downtime, configuration errors), making error-based credential exposure highly likely.

3. **Widespread Logging Practices**: Modern infrastructure typically captures all stdout/stderr and error logs, routing them to centralized systems where they may be accessible to broader audiences than intended.

4. **Configuration Debugging**: Operators frequently log or display configuration during troubleshooting, triggering Debug trait implementations.

The combination of normal-operation exposure and common error scenarios makes this vulnerability highly likely to leak credentials in production environments.

## Recommendation

Implement credential sanitization in the `Display` and `Debug` trait implementations for `RedisUrl`:

**Fix for Display trait:**
```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let mut sanitized = self.0.clone();
        // Remove password from URL
        let _ = sanitized.set_password(None);
        write!(f, "{}", sanitized)
    }
}
```

**Fix for Debug trait:**
```rust
impl std::fmt::Debug for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let mut sanitized = self.0.clone();
        let _ = sanitized.set_password(None);
        f.debug_tuple("RedisUrl").field(&sanitized).finish()
    }
}
```

**Additional fixes:**
1. Remove the println statement that logs the Redis URL during startup
2. Implement custom Debug for configuration structs that contain RedisUrl to ensure credentials aren't exposed
3. Audit all logging statements to ensure no direct URL exposure
4. Consider using a credential redaction library for structured logging

## Proof of Concept

```rust
// Create a test demonstrating credential exposure
use url::Url;

#[test]
fn test_redis_credential_exposure() {
    // Simulate a Redis URL with password
    let redis_url_str = "redis://:mysecretpassword@localhost:6379";
    let redis_url = RedisUrl::from_str(redis_url_str).unwrap();
    
    // Display trait exposes password
    let display_output = format!("{}", redis_url);
    assert!(display_output.contains("mysecretpassword"), 
            "Display trait exposes password in logs");
    
    // Debug trait also exposes password
    let debug_output = format!("{:?}", redis_url);
    assert!(debug_output.contains("mysecretpassword"),
            "Debug trait exposes password in logs");
    
    // Error context exposure
    let error_msg = format!("Failed to connect to {}", redis_url);
    assert!(error_msg.contains("mysecretpassword"),
            "Error messages expose password");
    
    println!("VULNERABILITY CONFIRMED: Password '{}' exposed in:",
             "mysecretpassword");
    println!("  Display: {}", display_output);
    println!("  Debug: {:?}", redis_url);
    println!("  Error context: {}", error_msg);
}

// Reproduce the actual vulnerability from service.rs
#[tokio::test]
async fn test_service_credential_leak() {
    let redis_url = RedisUrl::from_str("redis://:secretpass@localhost:6379")
        .unwrap();
    
    // This is what happens in service.rs line 111-113
    let result = redis::Client::open(redis_url.0.clone())
        .with_context(|| {
            format!("Failed to create redis client for {}", redis_url)
        });
    
    if let Err(e) = result {
        let error_msg = format!("{:?}", e);
        assert!(error_msg.contains("secretpass"),
                "Credentials leaked in error context");
        println!("ERROR MESSAGE LEAKS CREDENTIALS: {}", error_msg);
    }
}
```

**Notes**

This vulnerability affects the indexer-grpc ecosystem services which provide off-chain data access for Aptos blockchain clients. While not directly impacting consensus, compromised indexer services can disrupt client access to blockchain data and potentially serve corrupted information, qualifying as a High severity issue per the bug bounty program's inclusion of API crashes and significant service disruptions.

The vulnerability is particularly severe because credential exposure occurs during **normal operation** (startup logging), not just error conditions, maximizing the likelihood of exploitation.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L13-14)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct RedisUrl(pub Url);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L58-62)
```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L110-114)
```rust
            redis_client: Arc::new(
                redis::Client::open(redis_address.0.clone()).with_context(|| {
                    format!("Failed to create redis client for {}", redis_address)
                })?,
            ),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L84-90)
```rust
        let redis_client = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "[Indexer Cache] Failed to create redis client for {}",
                    redis_main_instance_address
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L44-58)
```rust
        let conn = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "Create redis client for {} failed",
                    redis_main_instance_address.0
                )
            })?
            .get_tokio_connection_manager()
            .await
            .with_context(|| {
                format!(
                    "Create redis connection to {} failed.",
                    redis_main_instance_address.0
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L162-165)
```rust
        println!(
            ">>>> Starting Redis connection: {:?}",
            &self.redis_read_replica_address.0
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/lib.rs (L14-22)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcCacheWorkerConfig {
    pub fullnode_grpc_address: Url,
    pub file_store_config: IndexerGrpcFileStoreConfig,
    pub redis_main_instance_address: RedisUrl,
    #[serde(default = "default_enable_cache_compression")]
    pub enable_cache_compression: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/lib.rs (L13-22)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcFileStoreWorkerConfig {
    pub file_store_config: IndexerGrpcFileStoreConfig,
    pub redis_main_instance_address: RedisUrl,
    pub enable_expensive_logging: Option<bool>,
    pub chain_id: u64,
    #[serde(default = "default_enable_cache_compression")]
    pub enable_cache_compression: bool,
}
```
