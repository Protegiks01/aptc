# Audit Report

## Title
Epoch Spoofing in Optimistic Fetch Enables State Sync Failures via Bypassed Epoch Boundary Validation

## Summary
A malicious peer can lie about their `known_epoch` in a `NewTransactionOutputsWithProofRequest` to bypass critical validation logic in the storage service's optimistic fetch handler. This causes the server to send transaction outputs spanning multiple epoch boundaries without providing the required epoch ending ledger infos, leading to state sync execution failures and inconsistencies on the requesting peer.

## Finding Description

The vulnerability exists in the optimistic fetch validation logic. When a peer sends a `NewTransactionOutputsWithProofRequest`, the server accepts it immediately without validating whether the claimed `known_epoch` is consistent with the `known_version`. [1](#0-0) 

The request is inserted into the active optimistic fetches map without any validation: [2](#0-1) 

Later, when the storage service processes ready optimistic fetches, it only validates epoch consistency if BOTH conditions are true: `known_version < highest_synced_version` AND `known_epoch < highest_synced_epoch`. However, if `known_epoch >= highest_synced_epoch`, the validation is completely bypassed: [3](#0-2) 

In the `else` branch (lines 542-545), when `known_epoch >= highest_synced_epoch`, the fetch is immediately marked as ready without ANY validation of whether the epoch value is legitimate for the given version.

**Attack Scenario:**

1. Server state: Version 1000, Epoch 10
2. Peer's actual state: Version 500, Epoch 5
3. Malicious request: `known_version: 500`, `known_epoch: 10` (LIE!)

Since `known_epoch (10) >= highest_synced_epoch (10)`, the validation at line 533 is skipped. The server creates a storage request for versions 501-1000: [4](#0-3) 

The continuous syncer then applies these outputs with `end_of_epoch_ledger_info: None`: [5](#0-4) 

When the chunk executor processes outputs that actually span an epoch boundary (e.g., epoch 5 ends at version 600), it detects that `next_epoch_state.is_some()` but no `epoch_change_li` was provided, causing a validation failure: [6](#0-5) 

This breaks the critical invariant: **State Consistency - State transitions must be atomic and verifiable via Merkle proofs**. The peer receives data spanning multiple epochs without the proper epoch ending ledger infos required for verification.

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The malicious peer's state sync will fail when trying to apply outputs across epoch boundaries, requiring manual intervention or re-syncing from a different peer
- **Limited to requesting peer**: The attack only affects the malicious peer itself, not the broader network
- **No consensus impact**: This does not affect consensus safety or liveness for honest nodes

The vulnerability enables a malicious peer to cause its own state sync to fail, which could be used as part of a larger attack strategy or to cause operational disruptions.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
1. Any network peer can send optimistic fetch requests
2. No special privileges or validator access required
3. The malicious request is accepted immediately without validation
4. The attack succeeds deterministically when the spoofed epoch bypasses the validation condition

The only requirement is that the peer's `known_epoch >= server's highest_synced_epoch`, which is easy to achieve by simply claiming the maximum possible epoch value.

## Recommendation

Add upfront validation in the optimistic fetch handler to verify that the `known_epoch` is consistent with the `known_version`. The server should:

1. **Validate epoch-version consistency upfront** before accepting the optimistic fetch request
2. **Fix the validation logic** in `identify_ready_and_invalid_optimistic_fetches` to validate epoch claims even when `known_epoch >= highest_synced_epoch`

Proposed fix in `handler.rs`:

```rust
pub fn handle_optimistic_fetch_request(
    &self,
    peer_network_id: PeerNetworkId,
    request: StorageServiceRequest,
    response_sender: ResponseSender,
) {
    // Extract known_version and known_epoch from the request
    let (known_version, known_epoch) = extract_known_version_and_epoch(&request);
    
    // Validate epoch is consistent with version using storage
    if let Err(error) = self.validate_epoch_for_version(known_version, known_epoch) {
        self.send_response(
            request,
            Err(StorageServiceError::InvalidRequest(error.to_string())),
            response_sender,
        );
        return;
    }
    
    // Rest of existing logic...
}
```

And fix in `optimistic_fetch.rs` at the else branch:

```rust
} else {
    // Even if known_epoch >= highest_synced_epoch, we must still validate
    // that the claimed epoch is consistent with the known_version
    let epoch_at_known_version = match utils::get_epoch_for_version(
        cached_storage_server_summary.clone(),
        optimistic_fetches.clone(),
        subscriptions.clone(),
        known_version,
        lru_response_cache.clone(),
        request_moderator.clone(),
        &peer_network_id,
        storage.clone(),
        time_service.clone(),
    ) {
        Ok(epoch) => epoch,
        Err(error) => {
            // Failed to get epoch, mark as invalid
            peers_with_invalid_optimistic_fetches.lock().push(peer_network_id);
            return;
        },
    };
    
    if highest_known_epoch != epoch_at_known_version {
        peers_with_invalid_optimistic_fetches.lock().push(peer_network_id);
    } else {
        peers_with_ready_optimistic_fetches
            .lock()
            .push((peer_network_id, highest_synced_ledger_info.clone()));
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_epoch_spoofing_in_optimistic_fetch() {
    use aptos_storage_service_types::requests::{DataRequest, NewTransactionOutputsWithProofRequest, StorageServiceRequest};
    
    // Setup: Server at version 1000, epoch 10
    // Peer actually at version 500, epoch 5
    
    // Malicious request: claim to be at version 500 but epoch 10 (LIE!)
    let malicious_request = StorageServiceRequest::new(
        DataRequest::GetNewTransactionOutputsWithProof(
            NewTransactionOutputsWithProofRequest {
                known_version: 500,
                known_epoch: 10,  // Should be 5!
            }
        ),
        false,
    );
    
    // Send request to storage service
    // Expected: Request should be rejected or validated properly
    // Actual: Request is accepted and processed, leading to invalid data being sent
    
    // The server will send data from version 501-1000 without epoch ending ledger infos
    // When peer tries to apply this data, the chunk executor will fail because:
    // - The data spans epochs 5->10 (epoch boundaries at versions 600, 700, 800, 900)
    // - But no epoch_change_li was provided
    // - The validator at chunk_result_verifier.rs:119-123 will error:
    //   "End of epoch chunk based on local computation but no EoE LedgerInfo provided"
    
    assert!(/* State sync fails with epoch boundary error */);
}
```

To reproduce:
1. Set up a storage service with data through version 1000, epoch 10
2. Send a `NewTransactionOutputsWithProofRequest` with `known_version: 500, known_epoch: 10`
3. Observe that the request is accepted and marked as ready in the optimistic fetches
4. Observe that the server sends transaction outputs 501-1000 without epoch ending ledger infos
5. When the peer attempts to apply these outputs, the chunk executor fails at epoch boundary validation

## Notes

This vulnerability specifically affects the optimistic fetch path for transaction outputs. The root cause is insufficient validation of the relationship between `known_version` and `known_epoch` before accepting and processing optimistic fetch requests. The validation logic incorrectly assumes that if a peer claims a high enough epoch, no further validation is needed, allowing malicious peers to receive improperly structured data that violates state sync invariants.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L327-330)
```rust
pub struct NewTransactionOutputsWithProofRequest {
    pub known_version: u64, // The highest known output version
    pub known_epoch: u64,   // The highest known epoch
}
```

**File:** state-sync/storage-service/server/src/handler.rs (L242-280)
```rust
    /// Handles the given optimistic fetch request
    pub fn handle_optimistic_fetch_request(
        &self,
        peer_network_id: PeerNetworkId,
        request: StorageServiceRequest,
        response_sender: ResponseSender,
    ) {
        // Create the optimistic fetch request
        let optimistic_fetch = OptimisticFetchRequest::new(
            request.clone(),
            response_sender,
            self.time_service.clone(),
        );

        // Store the optimistic fetch and check if any existing fetches were found
        if self
            .optimistic_fetches
            .insert(peer_network_id, optimistic_fetch)
            .is_some()
        {
            sample!(
                SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
                trace!(LogSchema::new(LogEntry::OptimisticFetchRequest)
                    .error(&Error::InvalidRequest(
                        "An active optimistic fetch was already found for the peer!".into()
                    ))
                    .peer_network_id(&peer_network_id)
                    .request(&request)
                );
            );
        }

        // Update the optimistic fetch metrics
        increment_counter(
            &metrics::OPTIMISTIC_FETCH_EVENTS,
            peer_network_id.network_id(),
            OPTIMISTIC_FETCH_ADD.into(),
        );
    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L61-142)
```rust
    pub fn get_storage_request_for_missing_data(
        &self,
        config: StorageServiceConfig,
        target_ledger_info: &LedgerInfoWithSignatures,
    ) -> aptos_storage_service_types::Result<StorageServiceRequest, Error> {
        // Verify that the target version is higher than the highest known version
        let known_version = self.highest_known_version();
        let target_version = target_ledger_info.ledger_info().version();
        if target_version <= known_version {
            return Err(Error::InvalidRequest(format!(
                "Target version: {:?} is not higher than known version: {:?}!",
                target_version, known_version
            )));
        }

        // Calculate the number of versions to fetch
        let mut num_versions_to_fetch =
            target_version.checked_sub(known_version).ok_or_else(|| {
                Error::UnexpectedErrorEncountered(
                    "Number of versions to fetch has overflown!".into(),
                )
            })?;

        // Bound the number of versions to fetch by the maximum chunk size
        num_versions_to_fetch = min(
            num_versions_to_fetch,
            self.max_chunk_size_for_request(config),
        );

        // Calculate the start and end versions
        let start_version = known_version.checked_add(1).ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Start version has overflown!".into())
        })?;
        let end_version = known_version
            .checked_add(num_versions_to_fetch)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("End version has overflown!".into())
            })?;

        // Create the storage request
        let data_request = match &self.request.data_request {
            DataRequest::GetNewTransactionOutputsWithProof(_) => {
                DataRequest::GetTransactionOutputsWithProof(TransactionOutputsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                })
            },
            DataRequest::GetNewTransactionsWithProof(request) => {
                DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                    include_events: request.include_events,
                })
            },
            DataRequest::GetNewTransactionsOrOutputsWithProof(request) => {
                DataRequest::GetTransactionsOrOutputsWithProof(
                    TransactionsOrOutputsWithProofRequest {
                        proof_version: target_version,
                        start_version,
                        end_version,
                        include_events: request.include_events,
                        max_num_output_reductions: request.max_num_output_reductions,
                    },
                )
            },
            DataRequest::GetNewTransactionDataWithProof(request) => {
                DataRequest::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
                    transaction_data_request_type: request.transaction_data_request_type,
                    proof_version: target_version,
                    start_version,
                    end_version,
                    max_response_bytes: request.max_response_bytes,
                })
            },
            request => unreachable!("Unexpected optimistic fetch request: {:?}", request),
        };
        let storage_request =
            StorageServiceRequest::new(data_request, self.request.use_compression);
        Ok(storage_request)
    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L500-547)
```rust
        let active_task = runtime.spawn_blocking(move || {
            // Check if we have synced beyond the highest known version
            if highest_known_version < highest_synced_version {
                if highest_known_epoch < highest_synced_epoch {
                    // Fetch the epoch ending ledger info from storage (the
                    // peer needs to sync to their epoch ending ledger info).
                    let epoch_ending_ledger_info = match utils::get_epoch_ending_ledger_info(
                        cached_storage_server_summary.clone(),
                        optimistic_fetches.clone(),
                        subscriptions.clone(),
                        highest_known_epoch,
                        lru_response_cache.clone(),
                        request_moderator.clone(),
                        &peer_network_id,
                        storage.clone(),
                        time_service.clone(),
                    ) {
                        Ok(epoch_ending_ledger_info) => epoch_ending_ledger_info,
                        Err(error) => {
                            // Log the failure to fetch the epoch ending ledger info
                            error!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                                .error(&error)
                                .message(&format!(
                                    "Failed to get the epoch ending ledger info for epoch: {:?} !",
                                    highest_known_epoch
                                )));

                            return;
                        },
                    };

                    // Check that we haven't been sent an invalid optimistic fetch request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_optimistic_fetches
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_optimistic_fetches
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
                } else {
                    peers_with_ready_optimistic_fetches
                        .lock()
                        .push((peer_network_id, highest_synced_ledger_info.clone()));
                };
            }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L300-311)
```rust
        // Execute/apply and commit the transactions/outputs
        let num_transactions_or_outputs = match self.get_continuous_syncing_mode() {
            ContinuousSyncingMode::ApplyTransactionOutputs => {
                if let Some(transaction_outputs_with_proof) = transaction_outputs_with_proof {
                    utils::apply_transaction_outputs(
                        &mut self.storage_synchronizer,
                        notification_metadata,
                        ledger_info_with_signatures.clone(),
                        None,
                        transaction_outputs_with_proof,
                    )
                    .await?
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L119-123)
```rust
            ensure!(
                next_epoch_state.is_none(),
                "End of epoch chunk based on local computation but no EoE LedgerInfo provided. version: {:?}",
                txn_accumulator.num_leaves().checked_sub(1),
            );
```
