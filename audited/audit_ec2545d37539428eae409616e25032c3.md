# Audit Report

## Title
Epoch Mismatch in verify_payload_signatures() Causes Unverified Payload Accumulation Leading to Denial of Service

## Summary
The `verify_payload_signatures()` function in the consensus observer's payload store contains a critical logic flaw where payloads from epochs older than the current epoch are silently skipped without verification or removal. This allows old unverified payloads to accumulate indefinitely in the store, eventually exhausting the `max_num_pending_blocks` limit and causing legitimate payloads to be dropped, resulting in node liveness failure.

## Finding Description

The vulnerability exists in the epoch matching logic of `verify_payload_signatures()`: [1](#0-0) 

The function iterates through all stored payloads and:
1. **Breaks early** if `epoch > current_epoch` (future epochs) at line 229-231
2. **Only processes** payloads where `epoch == current_epoch` (verifies or removes them) at line 234-257  
3. **Silently skips** payloads where `epoch < current_epoch` (past epochs) - they remain unverified with no code path handling this case

This creates an accumulation scenario when:

1. **Payload Reception**: Node receives block payloads for future epochs, which are stored as unverified because signature verification requires the epoch state: [2](#0-1) 

2. **Epoch Skipping via Commit Sync**: When the node performs commit sync and transitions across epochs, it calls `verify_payload_signatures()` but does NOT clear old payloads: [3](#0-2) 

3. **Store Exhaustion**: Old unverified payloads accumulate until the store reaches `max_num_pending_blocks`, after which ALL new payloads (including legitimate ones) are dropped: [4](#0-3) 

**Attack Scenario:**
1. Attacker sends malicious block payloads for epochs 6, 7, 8, 9, 10 while node is at epoch 5
2. These are stored as unverified (can't verify signatures for future epochs)
3. Node receives a commit decision causing it to sync from epoch 5 to epoch 11 (skipping epochs 6-10)
4. `verify_payload_signatures()` is called with epoch 11 state
5. Payloads for epochs 6-10 have `epoch < current_epoch (11)`, so they are SKIPPED in the loop
6. These old unverified payloads persist indefinitely
7. Attacker repeats for subsequent epochs (12, 13, 14...)
8. Store fills up with old unverified payloads
9. New legitimate payloads are dropped
10. Node cannot process blocks → **Liveness failure**

**Contrast with Fallback Sync**: The fallback sync path correctly clears all payloads: [5](#0-4) 

At line 961, fallback sync calls `clear_pending_block_state()` which clears all payloads: [6](#0-5) 

But the commit sync path does not perform this cleanup before calling `verify_payload_signatures()`.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Accumulated payloads cause memory bloat and processing delays affecting consensus observer nodes (Validator Fullnodes)
- **Significant protocol violations**: Breaks the resource limits invariant - the store should bound memory usage but fails to do so
- **Liveness impact**: When the store fills up, legitimate payloads are dropped, preventing the node from processing new blocks

The default limit is 150 blocks: [7](#0-6) 

The impact manifests as:
1. **Memory exhaustion** from unbounded payload accumulation
2. **Block processing failure** when legitimate payloads are rejected  
3. **Network partition** if multiple observer nodes are affected simultaneously
4. **Cascading failures** as observers fall behind and require state sync, further exacerbating the issue

This does NOT reach Critical severity because it doesn't cause permanent chain splits or fund loss, but it significantly degrades network availability for consensus observer nodes.

## Likelihood Explanation

**Likelihood: Medium-to-High**

Required conditions:
1. Node must use commit sync (not fallback sync) to transition epochs - **Common**: This is the normal sync path for observers
2. Node must skip at least one epoch during sync - **Common**: Can occur naturally when nodes fall behind or during network disruptions  
3. Attacker must be able to send block payload messages - **Easy**: Any network peer can send consensus observer messages

Complexity: **Low** - Attacker simply needs to:
1. Connect as a peer to the consensus observer network
2. Send crafted `BlockPayload` messages for various future epochs
3. Wait for natural epoch transitions or network delays to trigger the bug

The attack requires no special privileges, validator access, or cryptographic breaks. It exploits a pure logic bug in epoch handling.

## Recommendation

Modify `verify_payload_signatures()` to handle the `epoch < current_epoch` case by removing these old payloads:

```rust
for (epoch, round) in payload_epochs_and_rounds {
    // Check if we can break early (BtreeMaps are sorted by key)
    if epoch > current_epoch {
        break;
    }
    
    // Remove payloads from old epochs
    if epoch < current_epoch {
        self.block_payloads.lock().remove(&(epoch, round));
        continue;
    }

    // Otherwise, attempt to verify the payload signatures for current epoch
    if epoch == current_epoch {
        // ... existing verification logic ...
    }
}
```

Alternatively, add a cleanup call before `verify_payload_signatures()` in the commit sync path to match the fallback sync behavior.

## Proof of Concept

The logic bug is evident from code inspection. A full PoC would require:
1. Setting up a consensus observer node
2. Sending block payloads for future epochs (epochs 6-10)
3. Triggering commit sync that skips these epochs (epoch 5 → 11)
4. Observing that old payloads remain in the store
5. Repeating until store reaches 150 block limit
6. Demonstrating that legitimate payloads are dropped

The core vulnerability is the missing code path in the `for` loop at line 227-258 that handles `epoch < current_epoch`.

## Notes

This vulnerability affects **consensus observer nodes** (Validator Fullnodes and Public Fullnodes with observer enabled), not core consensus validators. Validators only publish consensus data and do not run the vulnerable observer code path. However, the impact on network availability and observer node liveness is still significant and qualifies as High severity under the bug bounty program.

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L84-95)
```rust
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L217-274)
```rust
    pub fn verify_payload_signatures(&mut self, epoch_state: &EpochState) -> Vec<Round> {
        // Get the current epoch
        let current_epoch = epoch_state.epoch;

        // Gather the keys for the block payloads
        let payload_epochs_and_rounds: Vec<(u64, Round)> =
            self.block_payloads.lock().keys().cloned().collect();

        // Go through all unverified blocks and attempt to verify the signatures
        let mut verified_payloads_to_update = vec![];
        for (epoch, round) in payload_epochs_and_rounds {
            // Check if we can break early (BtreeMaps are sorted by key)
            if epoch > current_epoch {
                break;
            }

            // Otherwise, attempt to verify the payload signatures
            if epoch == current_epoch {
                if let Entry::Occupied(mut entry) = self.block_payloads.lock().entry((epoch, round))
                {
                    if let BlockPayloadStatus::AvailableAndUnverified(block_payload) =
                        entry.get_mut()
                    {
                        if let Err(error) = block_payload.verify_payload_signatures(epoch_state) {
                            // Log the verification failure
                            error!(
                                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                                    "Failed to verify the block payload signatures for epoch: {:?} and round: {:?}. Error: {:?}",
                                    epoch, round, error
                                ))
                            );

                            // Remove the block payload from the store
                            entry.remove();
                        } else {
                            // Save the block payload for reinsertion
                            verified_payloads_to_update.push(block_payload.clone());
                        }
                    }
                }
            }
        }

        // Collect the rounds of all newly verified blocks
        let verified_payload_rounds: Vec<Round> = verified_payloads_to_update
            .iter()
            .map(|block_payload| block_payload.round())
            .collect();

        // Update the verified block payloads. Note: this will cause
        // notifications to be sent to any listeners that are waiting.
        for verified_payload in verified_payloads_to_update {
            self.insert_block_payload(verified_payload, true);
        }

        // Return the newly verified payload rounds
        verified_payload_rounds
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-418)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L917-965)
```rust
    async fn process_fallback_sync_notification(
        &mut self,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) {
        // Get the epoch and round for the latest synced ledger info
        let ledger_info = latest_synced_ledger_info.ledger_info();
        let epoch = ledger_info.epoch();
        let round = ledger_info.round();

        // Log the state sync notification
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Received state sync notification for fallback completion! Epoch {}, round: {}!",
                epoch, round
            ))
        );

        // Verify that there is an active fallback sync
        if !self.state_sync_manager.in_fallback_mode() {
            // Log the error and return early
            error!(LogSchema::new(LogEntry::ConsensusObserver).message(
                "Failed to process fallback sync notification! No active fallback sync found!"
            ));
            return;
        }

        // Reset the fallback manager state
        self.observer_fallback_manager
            .reset_syncing_progress(&latest_synced_ledger_info);

        // Update the root with the latest synced ledger info
        self.observer_block_data
            .lock()
            .update_root(latest_synced_ledger_info);

        // If the epoch has changed, end the current epoch and start the latest one
        let current_epoch_state = self.get_epoch_state();
        if epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;
        };

        // Reset the pending block state
        self.clear_pending_block_state().await;

        // Reset the state sync manager for the synced fallback
        self.state_sync_manager.clear_active_fallback_sync();
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1026-1044)
```rust
        // If the epoch has changed, end the current epoch and start the latest one.
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L93-105)
```rust
    pub fn clear_block_data(&mut self) -> LedgerInfoWithSignatures {
        // Clear the payload store
        self.block_payload_store.clear_all_payloads();

        // Clear the ordered blocks
        self.ordered_block_store.clear_all_ordered_blocks();

        // Clear the pending blocks
        self.pending_block_store.clear_missing_blocks();

        // Return the root ledger info
        self.root()
    }
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```
