# Audit Report

## Title
Cache Invalidation Bug in SignatureChecker Allows References in Type Arguments via Function Types

## Summary
The `SignatureChecker` struct in `signature_v2.rs` uses caches that do not include the `allow_ref` parameter in their cache keys, allowing stale cache entries computed with `allow_ref=true` to be incorrectly reused when `allow_ref=false` is required. This enables function types containing references to bypass validation when used as struct type arguments, violating the Move type system invariant that type arguments cannot contain references.

## Finding Description

The `SignatureChecker` maintains multiple caches to optimize verification performance: [1](#0-0) 

The critical issue lies in how these caches are keyed. The `ty_results` cache uses the key `(SignatureIndex, usize, AbilitySet)`, and the `sig_results` cache uses only `SignatureIndex`: [2](#0-1) [3](#0-2) 

Neither cache key includes the `allow_ref` parameter, which controls whether references are permitted in the type being checked.

**Exploitation Path:**

1. During `verify_signature_pool_contextless()`, all signatures are verified with `allow_ref=true`: [4](#0-3) 

2. Function types are allowed to contain references in their parameters when `allow_ref=true`: [5](#0-4) 

3. When a struct instantiation uses a signature containing a function type with references as its type argument, the explicit reference check only validates the top level: [6](#0-5) 

4. The subsequent call to `verify_type_in_signature_contextless` with `allow_ref=false` hits the cache: [7](#0-6) 

5. Since the cache key `(sig_idx, ty_idx, AbilitySet::EMPTY)` matches the previous entry cached with `allow_ref=true`, the cached constraints are returned without re-validating that references are disallowed.

6. The nested references within the function type bypass validation, violating the type system invariant that type arguments cannot contain references.

The developers were aware of this caching issue, as evidenced by the comment acknowledging that signatures cached with references allowed must have explicit checks elsewhere. However, these explicit checks (`ty.is_reference()`) only catch top-level references, not references nested within function types.

## Impact Explanation

This vulnerability allows malformed Move bytecode to pass verification, specifically struct instantiations with function type arguments containing references. This violates the fundamental Move type system invariant that type arguments must not contain references, as documented in the test files: [8](#0-7) 

**Impact Assessment: Medium Severity**

This qualifies as Medium severity under the bug bounty program because:
- It causes state inconsistencies by allowing invalid bytecode that violates documented type system invariants
- All validators would accept the same invalid bytecode (no consensus split), but the bytecode violates safety guarantees
- Could lead to downstream issues in runtime execution or serialization where code assumes type arguments are reference-free
- Does not directly cause fund loss or consensus violations, but breaks critical type safety guarantees

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is exploitable by any attacker who can submit a Move module for publication. The attack requires:

1. Crafting a module with a signature containing `Function([&T], [])` or similar function types with reference parameters
2. Using that signature as type arguments for a struct instantiation (e.g., `MyStruct<Function([&u64], [])>`)
3. The module passes verification due to the cache invalidation bug

The attack does not require:
- Validator access or privileges
- Economic resources beyond transaction fees
- Coordination with other parties
- Timing-dependent exploits

The likelihood is elevated because:
- Function types with type arguments are a supported feature (bytecode version 8+)
- The caching behavior is deterministic and reproducible
- No special conditions or race conditions are required

## Recommendation

**Fix 1: Include `allow_ref` in Cache Keys**

Modify cache keys to include the `allow_ref` parameter:

```rust
// For ty_results cache
ty_results: RefCell<
    BTreeMap<(SignatureIndex, usize, AbilitySet, bool), &'a BitsetTypeParameterConstraints<N>>,
>,

// For sig_results cache  
sig_results: RefCell<BTreeMap<(SignatureIndex, bool), &'a BitsetTypeParameterConstraints<N>>>,
```

Update cache lookups and insertions accordingly to include the `allow_ref` parameter in the tuple key.

**Fix 2: Add Explicit Function Type Validation**

Add an explicit check that rejects function types containing references when used as type arguments:

```rust
// In verify_struct_type_params, before line 669
if let SignatureToken::Function(params, results, _) = ty {
    for param_ty in params.iter().chain(results) {
        if contains_reference(param_ty) {
            return Err(PartialVMError::new(StatusCode::INVALID_SIGNATURE_TOKEN)
                .with_message("function type arguments cannot contain references".to_string()));
        }
    }
}
```

Where `contains_reference` recursively checks for any reference tokens in the type tree.

**Fix 3: Disable Caching Across allow_ref Changes**

Alternatively, clear relevant caches when transitioning from checks with `allow_ref=true` to `allow_ref=false`, though this is less performant.

## Proof of Concept

The following Move bytecode module demonstrates the vulnerability:

```move
module 0x1::Exploit {
    // Define a struct with a generic type parameter
    struct Container<T> has key { value: T }
    
    // Create a signature containing a function type with a reference parameter
    // Signature pool entry: [Function([&u64], [])]
    
    public fun exploit() {
        // Attempt to instantiate Container with a function type containing references
        // Container<Function([&u64], [])>
        // This should be rejected but passes due to the caching bug
        let x: Container<|&u64| ()>;
    }
}
```

**Verification Test:**

To reproduce, create a compiled module with the above structure and run it through the bytecode verifier. The module should be rejected with `INVALID_SIGNATURE_TOKEN` but will incorrectly pass verification due to the cache key not including the `allow_ref` parameter.

**Notes**

The vulnerability is confirmed by the developers' own comment acknowledging the caching issue and stating that explicit checks must compensate: [9](#0-8) 

However, the explicit checks using `ty.is_reference()` are insufficient for function types, as they only validate the top-level type token, not nested references within function parameters or return types. This creates a gap in the verification logic that the cache invalidation bug exploits.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L172-187)
```rust
            Function(params, results, abilities) => {
                assert_abilities(*abilities, required_abilities)?;
                if self.sig_checker_v2_fix_function_signatures {
                    for ty in params.iter().chain(results) {
                        self.check_ty(
                            ty,
                            // Immediate params and returns can be references.
                            true,
                            // Note we do not need to check abilities of argument or result types,
                            // they do not matter for the `required_abilities`.
                            AbilitySet::EMPTY,
                            param_constraints,
                        )?
                    }
                }
            },
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L313-340)
```rust
    // Cached results of the context-less checks.
    //
    // The interior mutability pattern (RefCell) is used because it is hard to prove to the
    // borrow checker that the partial borrows the algorithm makes are disjoint.
    //
    // TODO: Right now looking up ty_results can be a major bottleneck.
    //       Can we make it faster?
    ty_results: RefCell<
        BTreeMap<(SignatureIndex, usize, AbilitySet), &'a BitsetTypeParameterConstraints<N>>,
    >,
    sig_results: RefCell<BTreeMap<SignatureIndex, &'a BitsetTypeParameterConstraints<N>>>,
    func_inst_results: RefCell<
        BTreeMap<(FunctionHandleIndex, SignatureIndex), &'a BitsetTypeParameterConstraints<N>>,
    >,
    struct_inst_results: RefCell<
        BTreeMap<(StructDefInstantiationIndex, AbilitySet), &'a BitsetTypeParameterConstraints<N>>,
    >,
    field_inst_results:
        RefCell<BTreeMap<FieldInstantiationIndex, &'a BitsetTypeParameterConstraints<N>>>,
    variant_field_inst_results:
        RefCell<BTreeMap<VariantFieldInstantiationIndex, &'a BitsetTypeParameterConstraints<N>>>,
    struct_variant_inst_results: RefCell<
        BTreeMap<
            (StructVariantInstantiationIndex, AbilitySet),
            &'a BitsetTypeParameterConstraints<N>,
        >,
    >,
}
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L370-400)
```rust
    fn verify_type_in_signature_contextless(
        &self,
        sig_idx: SignatureIndex,
        ty_idx: usize,
        required_abilities: AbilitySet,
        allow_ref: bool,
    ) -> PartialVMResult<&'a BitsetTypeParameterConstraints<N>> {
        let r = match self
            .ty_results
            .borrow_mut()
            .entry((sig_idx, ty_idx, required_abilities))
        {
            btree_map::Entry::Occupied(entry) => *entry.into_mut(),
            btree_map::Entry::Vacant(entry) => {
                let mut param_constraints = BitsetTypeParameterConstraints::new();
                let sig = self.resolver.signature_at(sig_idx);
                let ty = &sig.0[ty_idx];
                self.check_ty(ty, allow_ref, required_abilities, &mut param_constraints)
                    .map_err(|err| {
                        err.append_message_with_separator(' ', format!("at type {}", ty_idx))
                            .at_index(IndexKind::Signature, sig_idx.0)
                    })?;

                let r = self.constraints.alloc(param_constraints);

                *entry.insert(r)
            },
        };

        Ok(r)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L409-433)
```rust
    fn verify_signature_contextless(
        &self,
        sig_idx: SignatureIndex,
        allow_ref: bool,
    ) -> PartialVMResult<&'a BitsetTypeParameterConstraints<N>> {
        let r = match self.sig_results.borrow_mut().entry(sig_idx) {
            btree_map::Entry::Occupied(entry) => *entry.into_mut(),
            btree_map::Entry::Vacant(entry) => {
                let mut constraints = BitsetTypeParameterConstraints::new();

                for ty_idx in 0..self.resolver.signature_at(sig_idx).len() {
                    constraints.merge(self.verify_type_in_signature_contextless(
                        sig_idx,
                        ty_idx,
                        AbilitySet::EMPTY,
                        allow_ref,
                    )?)
                }

                *entry.insert(self.constraints.alloc(constraints))
            },
        };

        Ok(r)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L436-444)
```rust
    fn verify_signature_pool_contextless(&self) -> PartialVMResult<()> {
        for sig_idx in 0..self.resolver.signatures().len() {
            // Here we check signatures, which can be locals for instance, so references should be
            // allowed. Note that this function will cache results, which means that the signature
            // which is not supposed reference is cached with references allowed. One must make
            // sure any later checks do not go through cache, but explicitly reject references.
            self.verify_signature_contextless(SignatureIndex(sig_idx as u16), true)?;
        }
        Ok(())
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L664-667)
```rust
            if ty.is_reference() {
                return Err(PartialVMError::new(StatusCode::INVALID_SIGNATURE_TOKEN)
                    .with_message("reference not allowed".to_string()));
            }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L669-675)
```rust
            constraints.merge(self.verify_type_in_signature_contextless(
                ty_args_idx,
                ty_idx,
                arg_abilities,
                false,
            )?);
        }
```

**File:** third_party/move/move-bytecode-verifier/transactional-tests/tests/signature/reference_as_type_actual_in_struct_inst_for_bytecode_instruction.mvir (L1-57)
```text
//# publish
module 0x1.M {
    import 0x1.signer;

    struct Some<T> has key { item: T }

    foo(account: &signer) acquires Some {
    label b0:
        // cannot use refs in generics
        move_from<Some<&u64>>(signer.address_of(move(account)));
        return;
    }
}

//# publish
module 0x1.M {
    import 0x1.signer;

    struct Some<T> has key { item: T }

    foo(account: &signer) {
        let v: Self.Some<u64>;
    label b0:
        // cannot use refs in generics
        move_to<Some<&u64>>(copy(account), move(v));
        return;
    }
}

//# publish
module 0x1.M {
    import 0x1.signer;

    struct Some<T> has key { item: T }

    foo(account: &signer) {
    label b0:
        // cannot use refs in generics
        exists<Some<&u64>>(signer.address_of(move(account)));
        return;
    }
}

//# publish
module 0x1.M {
    import 0x1.signer;

    struct Some<T> has key { item: T }

    foo(account: &signer) {
    label b0:
        // cannot use refs in generics
        borrow_global<Some<&u64>>(signer.address_of(move(account)));
        return;
    }
}
// check: INVALID_SIGNATURE_TOKEN
```
