# Audit Report

## Title
Fee Payer Transaction Simulation Uses Wrong Address for Balance Query Leading to Incorrect Max Gas Calculations

## Summary
The `simulate_transaction()` function in `api/src/transactions.rs` queries the sender's balance instead of the fee payer's balance when calculating maximum gas for fee payer transactions with `estimate_max_gas_amount=true`. This causes incorrect gas estimation that diverges from actual on-chain execution behavior.

## Finding Description
In Aptos, fee payer transactions allow a designated fee payer address to pay for gas costs instead of the transaction sender. The transaction validation framework correctly checks the fee payer's balance during prologue execution [1](#0-0) , but the API simulation endpoint queries the wrong address.

The vulnerability occurs in the `simulate_transaction()` function when `estimate_max_gas_amount` parameter is set to true. The code retrieves the balance using the transaction sender's address [2](#0-1) , but for fee payer transactions, gas is actually deducted from the fee payer address, not the sender.

The fee payer address is available through the transaction authenticator [3](#0-2)  and can be accessed via the `fee_payer_address()` method [4](#0-3) .

During on-chain execution, the prologue functions for fee payer transactions explicitly pass the fee payer address as the gas payer [5](#0-4) , ensuring the balance check uses the correct address.

**Attack Scenario:**
1. User A (sender) has 100 APT balance
2. User B (fee payer) has 10 APT balance  
3. User A creates a fee payer transaction with B as fee payer
4. Simulation with `estimate_max_gas_amount=true` queries A's balance (100 APT) and calculates max gas based on that
5. Transaction submission fails on-chain because B only has 10 APT, causing unexpected transaction rejection

## Impact Explanation
This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty program for the following reasons:

1. **State Inconsistencies**: Simulation results diverge from actual on-chain execution behavior, violating the deterministic execution invariant. Users relying on simulation results will experience unexpected transaction failures.

2. **Limited Funds Manipulation**: While not direct theft, incorrect gas estimation can cause:
   - Users to waste gas fees on transactions that fail on-chain but passed simulation
   - Users to under-estimate required fee payer balances, leading to stuck transactions
   - Integration issues for wallets and dApps relying on accurate simulation

3. **User Experience Degradation**: The mismatch between simulation and execution breaks the fundamental contract of the simulation API, which is meant to predict actual transaction behavior.

The impact does not reach High/Critical severity because it doesn't enable consensus violations, direct fund theft, or network-wide failures. However, it represents a clear protocol violation affecting transaction validation reliability.

## Likelihood Explanation
**Likelihood: High**

This vulnerability will occur in every fee payer transaction simulation where:
- The `estimate_max_gas_amount` parameter is set to true
- The sender and fee payer have different balances
- Users rely on the simulation results for transaction construction

Fee payer transactions are a standard feature in Aptos for sponsored transactions, making this a commonly-used code path. The bug is deterministic and requires no special conditions or race conditions to trigger.

## Recommendation
The fix requires checking if the transaction uses a fee payer authenticator and querying the appropriate address:

```rust
// In simulate_transaction() function, replace the balance query logic:

// Determine the correct gas payer address
let gas_payer_address = signed_transaction
    .authenticator_ref()
    .fee_payer_address()
    .unwrap_or_else(|| signed_transaction.sender());

// Query balance using the correct address
let output = AptosVM::execute_view_function(
    &state_view,
    ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
    ident_str!("balance").into(),
    vec![AptosCoinType::type_tag()],
    vec![gas_payer_address.to_vec()],  // Use gas_payer_address instead of sender
    context.node_config.api.max_gas_view_function,
);
```

This ensures the simulation logic matches the on-chain prologue behavior [6](#0-5) .

## Proof of Concept

```rust
// Integration test for api/src/tests/simulation_test.rs

#[tokio::test]
async fn test_fee_payer_simulation_balance_query() {
    let mut context = new_test_context();
    
    // Create accounts
    let sender_account = context.create_account().await;
    let fee_payer_account = context.create_account().await;
    
    // Fund sender with high balance
    context.fund_account(sender_account.address(), 100_000_000).await;
    
    // Fund fee payer with low balance (only enough for minimal gas)
    context.fund_account(fee_payer_account.address(), 1_000).await;
    
    // Create a fee payer transaction
    let payload = aptos_stdlib::aptos_coin_transfer(
        context.get_apt_framework_account().address(),
        1000,
    );
    
    let raw_txn = RawTransaction::new(
        sender_account.address(),
        0,
        TransactionPayload::EntryFunction(payload),
        1_000_000, // High gas amount
        1,
        0,
        ChainId::test(),
    );
    
    // Create fee payer transaction with fee_payer_account as payer
    let signed_txn = SignedTransaction::new_fee_payer(
        raw_txn,
        sender_account.public_key(),
        sender_account.sign_message(&raw_txn),
        vec![], // No secondary signers
        fee_payer_account.address(),
        fee_payer_account.public_key(),
        fee_payer_account.sign_fee_payer(&raw_txn),
    );
    
    // Simulate with estimate_max_gas_amount=true
    let simulation_result = context
        .simulate_transaction(signed_txn.clone(), true, false, false)
        .await;
    
    // Bug: simulation uses sender's balance (100M), calculates high max gas
    // Reality: on-chain would use fee_payer's balance (1000), much lower max gas
    
    // Submit actual transaction - should fail due to insufficient fee payer balance
    let submit_result = context.submit_transaction(signed_txn).await;
    
    // Assert: simulation succeeded but submission failed due to balance mismatch
    assert!(simulation_result.is_ok());
    assert!(submit_result.is_err());
    assert!(submit_result.unwrap_err().to_string().contains("INSUFFICIENT_BALANCE"));
}
```

**Notes:**

The vulnerability specifically affects the simulation API's gas estimation feature when used with fee payer transactions. The core transaction execution logic is correct [7](#0-6) , but the API layer simulation doesn't properly handle the fee payer authenticator variant [3](#0-2) . This creates a discrepancy between simulated and actual execution that can mislead users and cause integration failures.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L126-138)
```text
    fun prologue_common(
        sender: &signer,
        gas_payer: &signer,
        replay_protector: ReplayProtector,
        txn_authentication_key: Option<vector<u8>>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        let sender_address = signer::address_of(sender);
        let gas_payer_address = signer::address_of(gas_payer);
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L187-212)
```text
        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L455-465)
```text
        prologue_common(
            &sender,
            &create_signer::create_signer(fee_payer_address),
            ReplayProtector::SequenceNumber(txn_sequence_number),
            option::some(txn_sender_public_key),
            txn_gas_price,
            txn_max_gas_units,
            txn_expiration_time,
            chain_id,
            false,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L494-496)
```text
        prologue_common(
            &sender,
            &create_signer::create_signer(fee_payer_address),
```

**File:** api/src/transactions.rs (L670-677)
```rust
                let output = AptosVM::execute_view_function(
                    &state_view,
                    ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
                    ident_str!("balance").into(),
                    vec![AptosCoinType::type_tag()],
                    vec![signed_transaction.sender().to_vec()],
                    context.node_config.api.max_gas_view_function,
                );
```

**File:** types/src/transaction/authenticator.rs (L92-98)
```rust
    FeePayer {
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
        fee_payer_address: AccountAddress,
        fee_payer_signer: AccountAuthenticator,
    },
```

**File:** types/src/transaction/authenticator.rs (L297-311)
```rust
    pub fn fee_payer_address(&self) -> Option<AccountAddress> {
        match self {
            Self::Ed25519 { .. }
            | Self::MultiEd25519 { .. }
            | Self::MultiAgent { .. }
            | Self::SingleSender { .. } => None,
            Self::FeePayer {
                sender: _,
                secondary_signer_addresses: _,
                secondary_signers: _,
                fee_payer_address,
                ..
            } => Some(*fee_payer_address),
        }
    }
```
