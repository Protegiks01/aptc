# Audit Report

## Title
Orphaned Commit Decisions: Blocks with Set CommitDecisions Can Be Removed Before Forwarding to Execution Pipeline

## Summary
The consensus observer can set a `CommitDecision` for an ordered block but then immediately remove that block via `remove_blocks_for_commit()`, causing the commit decision to be permanently lost and never forwarded to the execution pipeline. This creates state consistency issues where blocks have commit proofs that are never processed.

## Finding Description
The vulnerability occurs through a race condition between setting commit decisions and removing blocks during state sync operations: [1](#0-0) 

When `update_commit_decision()` is called, it sets the commit decision at line 137. However, this commit decision can be immediately orphaned through the following sequence:

1. **Block Storage During Sync**: Ordered blocks are inserted into storage even while state sync is running: [2](#0-1) 

2. **Commit Decision Stored But Not Forwarded**: When a commit decision arrives for a block while `is_syncing_to_commit()` returns true, the commit decision is stored but NOT immediately forwarded: [3](#0-2) 

3. **Block Removal During New Sync**: When a new commit decision for a higher round arrives, it triggers `update_blocks_for_state_sync_commit()` which removes all blocks up to that round: [4](#0-3) 

4. **Commit Decisions Lost**: The `remove_blocks_for_commit()` function removes blocks including their stored commit decisions: [5](#0-4) 

5. **No Recovery After Sync**: When state sync completes, `process_commit_sync_notification()` only forwards commit decisions for blocks that still exist: [6](#0-5) 

**Attack Scenario**:
1. Node receives ordered block A at round 101 during an ongoing state sync to round 100
2. CommitDecision for block A arrives; it's stored but not forwarded (line 555 check fails)
3. CommitDecision for round 200 arrives (block not yet received)
4. New state sync to round 200 is triggered, calling `update_blocks_for_state_sync_commit()`
5. Block A and its commit decision are removed via `remove_blocks_for_commit()`
6. When state sync completes, the commit decision for block A is permanently lost

## Impact Explanation
This violates the **State Consistency** invariant (#4) that "state transitions must be atomic and verifiable." The execution pipeline expects commit decisions for all committed blocks, but these can be silently dropped.

**Severity: High** (per Aptos Bug Bounty criteria)
- **Significant protocol violations**: Commit decisions are lost, breaking the consensus observer's contract with the execution pipeline
- **State inconsistencies requiring intervention**: The execution pipeline may not receive critical commit proofs

While state sync eventually ensures storage consistency, the execution pipeline's buffer manager expects to receive commit decisions for ordered blocks it has processed. Missing commit decisions could cause:
- Execution pipeline state mismatches
- Blocks that are ordered but never properly committed in the pipeline
- Potential liveness issues if the pipeline waits for commit decisions that never arrive

## Likelihood Explanation
**Likelihood: Medium-High**

This scenario is realistic and can occur in normal network conditions:
- State sync to commit is a common operation when catching up
- Nodes frequently receive blocks and commit decisions while syncing
- Multiple commit decisions from different peers can arrive in quick succession
- No malicious behavior required - just network timing

The conditions are:
1. Node is syncing to a commit (common during catch-up)
2. Node receives and stores new ordered blocks (happens continuously)
3. Commit decisions arrive while syncing (expected behavior)
4. A higher-round commit decision triggers a new sync (normal when falling behind)

## Recommendation
**Fix Option 1**: Don't store commit decisions while syncing if they won't be forwarded. Modify `process_commit_decision_for_pending_block()` to return false if syncing:

```rust
fn process_commit_decision_for_pending_block(&self, commit_decision: &CommitDecision) -> bool {
    // Get the pending block for the commit decision
    let pending_block = self.observer_block_data.lock()
        .get_ordered_block(commit_decision.epoch(), commit_decision.round());
    
    if let Some(pending_block) = pending_block {
        if self.all_payloads_exist(pending_block.blocks()) {
            // If state sync is syncing to a commit, don't store the commit decision
            // since it may be removed before we can forward it
            if !self.state_sync_manager.is_syncing_to_commit() {
                self.observer_block_data.lock()
                    .update_ordered_block_commit_decision(commit_decision);
                self.forward_commit_decision(commit_decision.clone());
                return true;
            }
        }
    }
    false
}
```

**Fix Option 2**: Preserve commit decisions separately from blocks, so they survive block removal:

```rust
// Add to OrderedBlockStore
pending_commit_decisions: BTreeMap<(u64, Round), CommitDecision>,

// In update_commit_decision, also store separately:
self.pending_commit_decisions.insert(
    (commit_decision_epoch, commit_decision_round),
    commit_decision.clone()
);

// Forward these after sync completes
```

**Recommended**: Fix Option 1 is simpler and safer - if we're syncing, state sync handles everything, so we shouldn't store commit decisions that might be orphaned.

## Proof of Concept
```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_orphaned_commit_decision() {
    // Setup: Create consensus observer with state sync active
    let mut observer = setup_consensus_observer().await;
    
    // Step 1: Start state sync to round 100
    let commit_100 = create_commit_decision(100);
    observer.state_sync_manager.sync_to_commit(commit_100, false);
    
    // Step 2: Receive and store ordered block at round 101
    let block_101 = create_ordered_block(101);
    observer.process_ordered_block(block_101).await;
    
    // Step 3: Receive commit decision for block 101 while syncing
    let commit_101 = create_commit_decision(101);
    observer.process_commit_decision_message(peer_id, now(), commit_101.clone());
    
    // Verify commit decision was stored
    let stored_blocks = observer.observer_block_data.lock().get_all_ordered_blocks();
    assert!(stored_blocks.get(&(0, 101)).unwrap().1.is_some());
    
    // Step 4: Receive commit decision for round 200, triggering new sync
    let commit_200 = create_commit_decision(200);
    observer.process_commit_decision_message(peer_id, now(), commit_200);
    
    // Step 5: Verify block 101 and its commit decision are removed
    let stored_blocks = observer.observer_block_data.lock().get_all_ordered_blocks();
    assert!(!stored_blocks.contains_key(&(0, 101))); // Block removed
    
    // Step 6: Complete state sync
    observer.process_state_sync_notification(
        StateSyncNotification::commit_sync_completed(commit_200.commit_proof().clone())
    ).await;
    
    // Vulnerability: Commit decision for block 101 was never forwarded
    // and is now permanently lost
}
```

## Notes
This vulnerability specifically affects the consensus observer component, which is responsible for receiving consensus updates from peers and forwarding them to the local execution pipeline. The issue does not affect full consensus participants, only observer nodes. However, observer nodes are critical for network scalability and their correctness is important for system integrity.

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L112-124)
```rust
    pub fn remove_blocks_for_commit(&mut self, commit_ledger_info: &LedgerInfoWithSignatures) {
        // Determine the epoch and round to split off
        let split_off_epoch = commit_ledger_info.ledger_info().epoch();
        let split_off_round = commit_ledger_info.commit_info().round().saturating_add(1);

        // Remove the blocks from the ordered blocks
        self.ordered_blocks = self
            .ordered_blocks
            .split_off(&(split_off_epoch, split_off_round));

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_ledger_info);
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L127-142)
```rust
    pub fn update_commit_decision(&mut self, commit_decision: &CommitDecision) {
        // Get the epoch and round of the commit decision
        let commit_decision_epoch = commit_decision.epoch();
        let commit_decision_round = commit_decision.round();

        // Update the commit decision for the ordered blocks
        if let Some((_, existing_commit_decision)) = self
            .ordered_blocks
            .get_mut(&(commit_decision_epoch, commit_decision_round))
        {
            *existing_commit_decision = Some(commit_decision.clone());
        }

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_decision.commit_proof());
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L550-565)
```rust
                self.observer_block_data
                    .lock()
                    .update_ordered_block_commit_decision(commit_decision);

                // If state sync is not syncing to a commit, forward the commit decision to the execution pipeline
                if !self.state_sync_manager.is_syncing_to_commit() {
                    info!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Forwarding commit decision to the execution pipeline: {}",
                            commit_decision.proof_block_info()
                        ))
                    );
                    self.forward_commit_decision(commit_decision.clone());
                }

                return true; // The commit decision was successfully processed
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L785-792)
```rust
            self.observer_block_data
                .lock()
                .insert_ordered_block(observed_ordered_block.clone());

            // If state sync is not syncing to a commit, finalize the ordered blocks
            if !self.state_sync_manager.is_syncing_to_commit() {
                self.finalize_ordered_block(ordered_block).await;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1050-1061)
```rust
        // Process all the newly ordered blocks
        let all_ordered_blocks = self.observer_block_data.lock().get_all_ordered_blocks();
        for (_, (observed_ordered_block, commit_decision)) in all_ordered_blocks {
            // Finalize the ordered block
            let ordered_block = observed_ordered_block.consume_ordered_block();
            self.finalize_ordered_block(ordered_block).await;

            // If a commit decision is available, forward it to the execution pipeline
            if let Some(commit_decision) = commit_decision {
                self.forward_commit_decision(commit_decision.clone());
            }
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```
