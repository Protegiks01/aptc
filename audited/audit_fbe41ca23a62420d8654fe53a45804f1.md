# Audit Report

## Title
Incomplete Signature Data Indexing for Modern Authentication Schemes

## Summary
The SQL-based indexer in `crates/indexer/src/models/signatures.rs` contains incomplete implementations for parsing SingleKeySignature, MultiKeySignature, and AbstractSignature types. While the match statement correctly handles all `AccountSignature` variants without crashes, three parsing functions store placeholder "Not implemented" strings instead of extracting actual cryptographic data. This results in permanent signature data loss in the indexer database for transactions using these authentication schemes, which are enabled on mainnet. [1](#0-0) 

## Finding Description

The `parse_multi_agent_signature_helper()` function handles all six `AccountSignature` variants through exhaustive pattern matching, preventing any runtime panics from unhandled cases. However, the implementations for three modern signature types are stubbed out:

1. **SingleKeySignature** - The `parse_single_key_signature()` function ignores the available `public_key` and `signature` fields from the input parameter, instead returning hardcoded placeholder strings. [2](#0-1) 

2. **MultiKeySignature** - The `parse_multi_key_signature()` function ignores `public_keys`, `signatures`, and `signatures_required` fields, returning placeholders. [3](#0-2) 

3. **AbstractSignature** - The `parse_abstraction_signature()` function ignores `function_info` and `auth_data` fields, returning placeholders. [4](#0-3) 

These signature types are **enabled on mainnet** through feature flags `SINGLE_SENDER_AUTHENTICATOR` (flag 33) and `ACCOUNT_ABSTRACTION` (flag 102), as confirmed in the features configuration. [5](#0-4) 

The API type definitions show that complete signature data is available in these structures:
- `SingleKeySignature` contains `public_key: PublicKey` and `signature: Signature` [6](#0-5) 
- `MultiKeySignature` contains `public_keys: Vec<PublicKey>`, `signatures: Vec<IndexedSignature>`, and `signatures_required: u8` [7](#0-6) 
- `AbstractSignature` contains `function_info: String` and `auth_data: HexEncodedBytes` [8](#0-7) 

Notably, the indexer-grpc implementation demonstrates that complete parsing is feasible, with fully implemented conversion functions that properly extract all signature data. [9](#0-8) 

The database schema expects signature data in VARCHAR fields: [10](#0-9) 

## Impact Explanation

This issue represents a **data integrity problem in an auxiliary indexing service** rather than a core blockchain security vulnerability. The impact is limited to:

1. **Historical Data Completeness**: Applications querying the SQL indexer for transaction signatures will receive incomplete data for SingleKey, MultiKey, and Abstract signature types
2. **Forensic Analysis**: Post-incident investigation relying on the SQL indexer would lack complete signature information
3. **Transaction Explorers**: User-facing explorers using the SQL indexer cannot display accurate signature details for affected transactions

**Critically, this does NOT affect**:
- ✅ Consensus safety or transaction execution (signatures are validated correctly on-chain)
- ✅ Blockchain state integrity (AptosDB stores complete signature data)
- ✅ Funds security or validator operations
- ✅ Network availability or performance

According to Aptos bug bounty severity criteria, this does not qualify as:
- **Critical**: No consensus violations, funds loss, or network partition
- **High**: No validator slowdowns or API crashes  
- **Medium**: While there are "state inconsistencies," they are limited to the auxiliary indexer database, not the canonical blockchain state

This is a **data quality issue** in a non-consensus-critical component. The indexer-grpc service has complete implementations, and direct node queries can retrieve full signature data.

## Likelihood Explanation

**Occurrence**: HIGH - Any transaction using SingleKeySignature, MultiKeySignature, or AbstractSignature will have its signature data incompletely indexed in the SQL database. Given these signature types are enabled on mainnet, this is actively occurring.

**Security Impact**: LOW - While data is lost in the indexer, no security boundaries are violated. The blockchain itself maintains complete signature data, and alternative query methods (indexer-grpc, direct node APIs) can access it.

## Recommendation

Implement complete parsing functions for all modern signature types by extracting actual cryptographic data instead of placeholder strings. The indexer-grpc implementation provides a reference:

```rust
fn parse_single_key_signature(
    s: &APISingleKeySignature,
    sender: &String,
    transaction_version: i64,
    transaction_block_height: i64,
    is_sender_primary: bool,
    multi_agent_index: i64,
    override_address: Option<&String>,
) -> Self {
    let signer = standardize_address(override_address.unwrap_or(sender));
    Self {
        transaction_version,
        transaction_block_height,
        signer,
        is_sender_primary,
        type_: String::from("single_key_signature"),
        public_key: format!("{:?}", s.public_key), // Extract actual public key
        signature: format!("{:?}", s.signature),   // Extract actual signature
        threshold: 1,
        public_key_indices: serde_json::Value::Array(vec![]),
        multi_agent_index,
        multi_sig_index: 0,
    }
}
```

**Note**: The database schema may require migration to accommodate larger signature data (VARCHAR limits: 66 for public_key, 200 for signature may be insufficient for some signature types).

## Proof of Concept

```rust
// Test demonstrating signature data loss
#[test]
fn test_single_key_signature_data_loss() {
    use aptos_api_types::{PublicKey, Signature, SingleKeySignature};
    
    // Create a SingleKeySignature with actual data
    let sig = SingleKeySignature {
        public_key: PublicKey::Ed25519(/* actual public key */),
        signature: Signature::Ed25519(/* actual signature */),
    };
    
    // Parse through indexer
    let indexed = Signature::parse_single_key_signature(
        &sig,
        &"0x1".to_string(),
        100,
        10,
        true,
        0,
        None,
    );
    
    // Verify data loss - actual signature data is replaced with placeholders
    assert_eq!(indexed.public_key, "Not implemented");
    assert_eq!(indexed.signature, "Not implemented");
    
    // The original signature had real cryptographic data that is now lost
}
```

---

## Notes

While this finding confirms that signature data loss occurs for three modern authentication schemes in the SQL-based indexer, it does not constitute a security vulnerability under the Aptos bug bounty program criteria. The issue is isolated to an auxiliary indexing service and does not impact consensus, execution, or funds security. The blockchain's canonical state (AptosDB) retains complete signature data, and alternative query interfaces (indexer-grpc) have proper implementations.

This represents a **data quality and completeness issue** that should be addressed to maintain consistency between indexing services, but it does not expose exploitable attack vectors against the core Aptos blockchain protocol.

### Citations

**File:** crates/indexer/src/models/signatures.rs (L271-328)
```rust
        match s {
            APIAccountSignature::Ed25519Signature(sig) => vec![Self::parse_ed25519_signature(
                sig,
                sender,
                transaction_version,
                transaction_block_height,
                is_sender_primary,
                multi_agent_index,
                override_address,
            )],
            APIAccountSignature::MultiEd25519Signature(sig) => Self::parse_multi_signature(
                sig,
                sender,
                transaction_version,
                transaction_block_height,
                is_sender_primary,
                multi_agent_index,
                override_address,
            ),
            APIAccountSignature::SingleKeySignature(sig) => vec![Self::parse_single_key_signature(
                sig,
                sender,
                transaction_version,
                transaction_block_height,
                is_sender_primary,
                multi_agent_index,
                override_address,
            )],
            APIAccountSignature::MultiKeySignature(sig) => vec![Self::parse_multi_key_signature(
                sig,
                sender,
                transaction_version,
                transaction_block_height,
                is_sender_primary,
                multi_agent_index,
                override_address,
            )],
            APIAccountSignature::NoAccountSignature(sig) => vec![Self::parse_no_account_signature(
                sig,
                sender,
                transaction_version,
                transaction_block_height,
                is_sender_primary,
                multi_agent_index,
                override_address,
            )],
            APIAccountSignature::AbstractSignature(sig) => {
                vec![Self::parse_abstraction_signature(
                    sig,
                    sender,
                    transaction_version,
                    transaction_block_height,
                    is_sender_primary,
                    multi_agent_index,
                    override_address,
                )]
            },
        }
```

**File:** crates/indexer/src/models/signatures.rs (L331-354)
```rust
    fn parse_single_key_signature(
        _s: &APISingleKeySignature,
        sender: &String,
        transaction_version: i64,
        transaction_block_height: i64,
        is_sender_primary: bool,
        multi_agent_index: i64,
        override_address: Option<&String>,
    ) -> Self {
        let signer = standardize_address(override_address.unwrap_or(sender));
        Self {
            transaction_version,
            transaction_block_height,
            signer,
            is_sender_primary,
            type_: String::from("single_key_signature"),
            public_key: "Not implemented".into(),
            threshold: 1,
            public_key_indices: serde_json::Value::Array(vec![]),
            signature: "Not implemented".into(),
            multi_agent_index,
            multi_sig_index: 0,
        }
    }
```

**File:** crates/indexer/src/models/signatures.rs (L356-379)
```rust
    fn parse_multi_key_signature(
        _s: &APIMultiKeySignature,
        sender: &String,
        transaction_version: i64,
        transaction_block_height: i64,
        is_sender_primary: bool,
        multi_agent_index: i64,
        override_address: Option<&String>,
    ) -> Self {
        let signer = standardize_address(override_address.unwrap_or(sender));
        Self {
            transaction_version,
            transaction_block_height,
            signer,
            is_sender_primary,
            type_: String::from("multi_key_signature"),
            public_key: "Not implemented".into(),
            threshold: 1,
            public_key_indices: serde_json::Value::Array(vec![]),
            signature: "Not implemented".into(),
            multi_agent_index,
            multi_sig_index: 0,
        }
    }
```

**File:** crates/indexer/src/models/signatures.rs (L406-429)
```rust
    fn parse_abstraction_signature(
        _s: &APIAbstractSignature,
        sender: &String,
        transaction_version: i64,
        transaction_block_height: i64,
        is_sender_primary: bool,
        multi_agent_index: i64,
        override_address: Option<&String>,
    ) -> Self {
        let signer = standardize_address(override_address.unwrap_or(sender));
        Self {
            transaction_version,
            transaction_block_height,
            signer,
            is_sender_primary,
            type_: String::from("abstraction_signature"),
            public_key: "Not implemented".into(),
            threshold: 1,
            public_key_indices: serde_json::Value::Array(vec![]),
            signature: "Not implemented".into(),
            multi_agent_index,
            multi_sig_index: 0,
        }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L160-257)
```rust
    /// reads between sessions (e.g., between transaction prologue, user session and epilogue).
    SESSION_CONTINUATION = 104,
    /// Enables function value reflection in the stdlib
    ENABLE_FUNCTION_REFLECTION = 105,
    /// Enables bytecode version v10
    VM_BINARY_FORMAT_V10 = 106,
    /// Whether SLH-DSA-SHA2-128s signature scheme is enabled for transaction authentication.
    SLH_DSA_SHA2_128S_SIGNATURE = 107,
}

impl FeatureFlag {
    pub fn default_features() -> Vec<Self> {
        vec![
            FeatureFlag::CODE_DEPENDENCY_CHECK,
            FeatureFlag::TREAT_FRIEND_AS_PRIVATE,
            FeatureFlag::SHA_512_AND_RIPEMD_160_NATIVES,
            FeatureFlag::APTOS_STD_CHAIN_ID_NATIVES,
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
            FeatureFlag::MULTI_ED25519_PK_VALIDATE_V2_NATIVES,
            FeatureFlag::BLAKE2B_256_NATIVE,
            FeatureFlag::RESOURCE_GROUPS,
            FeatureFlag::MULTISIG_ACCOUNTS,
            FeatureFlag::DELEGATION_POOLS,
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BLS12_381_STRUCTURES,
            FeatureFlag::ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH,
            FeatureFlag::STRUCT_CONSTRUCTORS,
            FeatureFlag::PERIODICAL_REWARD_RATE_DECREASE,
            FeatureFlag::PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::_SIGNATURE_CHECKER_V2,
            FeatureFlag::STORAGE_SLOT_METADATA,
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
            FeatureFlag::DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::APTOS_UNIQUE_IDENTIFIERS,
            FeatureFlag::GAS_PAYER_ENABLED,
            FeatureFlag::BULLETPROOFS_NATIVES,
            FeatureFlag::SIGNER_NATIVE_FORMAT_FIX,
            FeatureFlag::MODULE_EVENT,
            FeatureFlag::EMIT_FEE_STATEMENT,
            FeatureFlag::STORAGE_DELETION_REFUND,
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
            FeatureFlag::AGGREGATOR_V2_API,
            FeatureFlag::SAFER_RESOURCE_GROUPS,
            FeatureFlag::SAFER_METADATA,
            FeatureFlag::SINGLE_SENDER_AUTHENTICATOR,
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
            FeatureFlag::FEE_PAYER_ACCOUNT_OPTIONAL,
            FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS,
            FeatureFlag::CONCURRENT_TOKEN_V2,
            FeatureFlag::LIMIT_MAX_IDENTIFIER_LENGTH,
            FeatureFlag::OPERATOR_BENEFICIARY_CHANGE,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET,
            FeatureFlag::COMMISSION_CHANGE_DELEGATION_POOL,
            FeatureFlag::WEBAUTHN_SIGNATURE,
            FeatureFlag::KEYLESS_ACCOUNTS,
            FeatureFlag::FEDERATED_KEYLESS,
            FeatureFlag::KEYLESS_BUT_ZKLESS_ACCOUNTS,
            FeatureFlag::JWK_CONSENSUS,
            FeatureFlag::REFUNDABLE_BYTES,
            FeatureFlag::OBJECT_CODE_DEPLOYMENT,
            FeatureFlag::MAX_OBJECT_NESTING_CHECK,
            FeatureFlag::KEYLESS_ACCOUNTS_WITH_PASSKEYS,
            FeatureFlag::MULTISIG_V2_ENHANCEMENT,
            FeatureFlag::DELEGATION_POOL_ALLOWLISTING,
            FeatureFlag::MODULE_EVENT_MIGRATION,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE,
            FeatureFlag::TRANSACTION_CONTEXT_EXTENSION,
            FeatureFlag::COIN_TO_FUNGIBLE_ASSET_MIGRATION,
            FeatureFlag::_OBJECT_NATIVE_DERIVED_ADDRESS,
            FeatureFlag::DISPATCHABLE_FUNGIBLE_ASSET,
            FeatureFlag::NEW_ACCOUNTS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::OPERATIONS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::CONCURRENT_FUNGIBLE_ASSETS,
            FeatureFlag::_AGGREGATOR_V2_IS_AT_LEAST_API,
            FeatureFlag::CONCURRENT_FUNGIBLE_BALANCE,
            FeatureFlag::_LIMIT_VM_TYPE_SIZE,
            FeatureFlag::ABORT_IF_MULTISIG_PAYLOAD_MISMATCH,
            FeatureFlag::_DISALLOW_USER_NATIVES,
            FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS,
            FeatureFlag::_USE_COMPATIBILITY_CHECKER_V2,
            FeatureFlag::ENABLE_ENUM_TYPES,
            FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE_FOR_SCRIPT,
            FeatureFlag::TRANSACTION_SIMULATION_ENHANCEMENT,
            FeatureFlag::_NATIVE_MEMORY_OPERATIONS,
            FeatureFlag::_ENABLE_LOADER_V2,
            FeatureFlag::_DISALLOW_INIT_MODULE_TO_PUBLISH_MODULES,
            FeatureFlag::COLLECTION_OWNER,
            FeatureFlag::PERMISSIONED_SIGNER,
            FeatureFlag::ENABLE_CALL_TREE_AND_INSTRUCTION_VM_CACHE,
            FeatureFlag::ACCOUNT_ABSTRACTION,
            FeatureFlag::BULLETPROOFS_BATCH_NATIVES,
            FeatureFlag::DERIVABLE_ACCOUNT_ABSTRACTION,
            FeatureFlag::VM_BINARY_FORMAT_V8,
```

**File:** api/types/src/transaction.rs (L1733-1736)
```rust
pub struct SingleKeySignature {
    pub public_key: PublicKey,
    pub signature: Signature,
}
```

**File:** api/types/src/transaction.rs (L1886-1890)
```rust
pub struct MultiKeySignature {
    pub public_keys: Vec<PublicKey>,
    pub signatures: Vec<IndexedSignature>,
    pub signatures_required: u8,
}
```

**File:** api/types/src/transaction.rs (L2033-2036)
```rust
pub struct AbstractSignature {
    pub function_info: String,
    pub auth_data: HexEncodedBytes,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L610-630)
```rust
pub fn convert_single_key_signature(sig: &SingleKeySignature) -> transaction::SingleKeySignature {
    transaction::SingleKeySignature {
        public_key: Some(convert_public_key(&sig.public_key)),
        signature: Some(convert_signature(&sig.signature)),
    }
}

pub fn convert_multi_key_signature(sig: &MultiKeySignature) -> transaction::MultiKeySignature {
    transaction::MultiKeySignature {
        public_keys: sig.public_keys.iter().map(convert_public_key).collect(),
        signatures: sig
            .signatures
            .iter()
            .map(|signature| transaction::IndexedSignature {
                index: signature.index as u32,
                signature: Some(convert_signature(&signature.signature)),
            })
            .collect(),
        signatures_required: sig.signatures_required as u32,
    }
}
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L183-184)
```sql
  public_key VARCHAR(66) NOT NULL,
  signature VARCHAR(200) NOT NULL,
```
