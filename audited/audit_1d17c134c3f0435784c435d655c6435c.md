# Audit Report

## Title
Transaction Commit Hooks Invoked Out-of-Order During Parallel PostCommitProcessing in BlockSTM V2

## Summary
In BlockSTM V2 parallel execution, transaction commit hooks (`on_transaction_committed`) are invoked during the parallel PostCommitProcessing phase, not during the sequential commit phase. This allows hooks for transaction i+1 to be invoked before hooks for transaction i, violating the expected sequential commit order and potentially causing cross-shard state inconsistencies in sharded execution scenarios.

## Finding Description

The BlockSTM V2 parallel executor implements a two-phase commit process:

**Phase 1 - Sequential Commit Hooks** (protected by `queueing_commits_lock`): [1](#0-0) 

Workers acquire the lock and call `prepare_and_queue_commit_ready_txn` which validates delayed fields, publishes modules, and adds transactions to the post-commit queue in sequential order via `last_input_output.commit()`: [2](#0-1) 

**Phase 2 - Parallel PostCommitProcessing** (NO ordering guarantees): [3](#0-2) 

Multiple workers concurrently pop transactions from `post_commit_processing_queue`: [4](#0-3) 

During PostCommitProcessing, workers call `record_finalized_output` which invokes the transaction commit hook: [5](#0-4) 

The hook invocation happens via `notify_listener`: [6](#0-5) 

**The Race Condition:**

Since `materialize_txn_commit` (which happens before hook invocation) involves heavy work like serialization and materialization, transaction i+1 can complete materialization faster than transaction i. This causes the following sequence:

1. Thread A: PostCommitProcessing(i) starts, begins slow materialization
2. Thread B: PostCommitProcessing(i+1) completes fast materialization  
3. Thread B: Calls `on_transaction_committed(i+1, ...)` 
4. Thread A: Finally completes, calls `on_transaction_committed(i, ...)`

The hook for transaction i+1 fires BEFORE the hook for transaction i, despite i committing first.

**Impact on CrossShardCommitSender:**

The real-world `CrossShardCommitSender` hook implementation sends cross-shard state updates: [7](#0-6) 

When out-of-order hooks send messages to dependent shards, the receiver calls `set_value`: [8](#0-7) 

The `set_value` method unconditionally overwrites the stored value with no ordering checks. If transactions i and i+1 both write to the same `StateKey` and both have cross-shard dependencies, the later transaction's hook firing first could result in the earlier transaction's stale value overwriting the correct value at the dependent shard.

## Impact Explanation

This violates **Invariant 1: Deterministic Execution** - all validators must produce identical state roots for identical blocks. If cross-shard state propagation happens non-deterministically due to hook invocation racing, different validators could observe different orderings of state updates, leading to state divergence.

This could also violate **Invariant 4: State Consistency** - state transitions must be atomic and verifiable. Cross-shard dependent transactions might observe inconsistent intermediate states if hooks deliver updates out of order.

**Severity Assessment: High** - While this doesn't directly cause fund loss, it represents a significant protocol violation that could cause validator consensus failures, state inconsistencies requiring manual intervention, and potential validator node issues in sharded execution scenarios.

## Likelihood Explanation

**Likelihood: Medium-High**

The race condition occurs naturally during normal BlockSTM V2 operation:
- No attacker action required
- Depends only on relative timing of materialization operations
- More likely with heterogeneous transaction complexities (simple vs complex transactions)
- Guaranteed to occur eventually in high-throughput scenarios

However, actual exploitability depends on:
- Whether the partitioner creates scenarios where multiple transactions write to the same cross-shard state keys
- Whether dependent shards process messages with ordering assumptions
- Whether the system has other implicit safeguards

## Recommendation

**Fix: Invoke hooks during sequential commit phase, not parallel PostCommitProcessing**

Move the hook invocation from `record_finalized_output` to `prepare_and_queue_commit_ready_txn`, ensuring hooks execute sequentially while holding the commit lock:

```rust
// In prepare_and_queue_commit_ready_txn, after validating and before queueing:
if let Some(commit_hook) = &self.transaction_commit_hook {
    last_input_output.notify_listener(txn_idx, commit_hook)?;
}
```

Remove the hook invocation from `record_finalized_output` to prevent duplicate calls.

**Alternative: Add explicit sequencing to RemoteStateValue**

Modify `RemoteStateValue` to track transaction indices and reject out-of-order updates:

```rust
pub struct RemoteStateValue {
    value_condition: Arc<(Mutex<RemoteValueStatus>, Condvar)>,
    expected_txn_idx: AtomicU32, // Track expected transaction order
}

pub fn set_value(&self, txn_idx: TxnIndex, value: Option<StateValue>) {
    // Verify sequential ordering before updating
    let expected = self.expected_txn_idx.load(Ordering::Acquire);
    if txn_idx != expected {
        // Log error or retry
        return;
    }
    // ... update value and increment expected_txn_idx
}
```

## Proof of Concept

The following conceptual test demonstrates the race condition (actual compilation requires full BlockSTM test harness):

```rust
#[test]
fn test_out_of_order_hook_invocation() {
    // Setup: Create two transactions where T1 takes longer to materialize than T2
    let t1 = create_transaction_with_large_resource_groups(); // Slow materialization
    let t2 = create_simple_transaction(); // Fast materialization
    
    let hook_invocation_order = Arc::new(Mutex::new(Vec::new()));
    let hook_order_clone = hook_invocation_order.clone();
    
    // Custom hook that records invocation order
    struct OrderTrackingHook {
        invocation_order: Arc<Mutex<Vec<TxnIndex>>>,
    }
    
    impl TransactionCommitHook for OrderTrackingHook {
        fn on_transaction_committed(&self, txn_idx: TxnIndex, _: &OnceCell<TransactionOutput>) {
            self.invocation_order.lock().push(txn_idx);
        }
        fn on_execution_aborted(&self, _: TxnIndex) {}
    }
    
    let hook = OrderTrackingHook { invocation_order: hook_order_clone };
    
    // Execute block with V2 scheduler
    let executor = BlockExecutor::new(config, pool, Some(hook));
    executor.execute_block(/*...*/);
    
    // Verify: T2's hook may fire before T1's hook despite T1 committing first
    let order = hook_invocation_order.lock();
    // With race condition, order could be [1, 0] instead of expected [0, 1]
    assert!(order == vec![0, 1], "Hooks fired out of order: {:?}", order);
}
```

## Notes

This vulnerability exists specifically in BlockSTM V2's parallel PostCommitProcessing implementation. The sequential execution path correctly invokes hooks in order: [9](#0-8) 

The issue affects any `TransactionCommitHook` implementation that assumes sequential invocation order, with `CrossShardCommitSender` being the primary production use case.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L1277-1279)
```rust
        if let Some(txn_commit_listener) = &self.transaction_commit_hook {
            last_input_output.notify_listener(txn_idx, txn_commit_listener)?;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1455-1471)
```rust
            while scheduler.commit_hooks_try_lock() {
                // Perform sequential commit hooks.
                while let Some((txn_idx, incarnation)) = scheduler.start_commit()? {
                    self.prepare_and_queue_commit_ready_txn(
                        txn_idx,
                        incarnation,
                        num_txns,
                        executor,
                        block,
                        num_workers as usize,
                        runtime_environment,
                        scheduler_wrapper,
                        shared_sync_params,
                    )?;
                }

                scheduler.commit_hooks_unlock();
```

**File:** aptos-move/block-executor/src/executor.rs (L1507-1515)
```rust
                TaskKind::PostCommitProcessing(txn_idx) => {
                    self.materialize_txn_commit(
                        txn_idx,
                        scheduler_wrapper,
                        environment,
                        shared_sync_params,
                    )?;
                    self.record_finalized_output(txn_idx, txn_idx, shared_sync_params)?;
                },
```

**File:** aptos-move/block-executor/src/executor.rs (L2493-2496)
```rust
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook
                            .on_transaction_committed(idx as TxnIndex, output.committed_output());
                    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L376-376)
```rust
        scheduler.add_to_post_commit(txn_idx)?;
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L417-424)
```rust
                txn_listener.on_transaction_committed(
                    txn_idx,
                    output_wrapper
                        .output
                        .as_ref()
                        .expect("Output must be set when status is success or skip rest")
                        .committed_output(),
                );
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1177-1190)
```rust
    fn pop_post_commit_task(&self) -> Result<Option<TxnIndex>, PanicError> {
        match self.post_commit_processing_queue.pop() {
            Ok(txn_idx) => {
                if txn_idx == self.num_txns - 1 {
                    self.is_done.store(true, Ordering::SeqCst);
                }
                Ok(Some(txn_idx))
            },
            Err(PopError::Empty) => Ok(None),
            Err(PopError::Closed) => {
                Err(code_invariant_error("Commit queue should never be closed"))
            },
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L137-147)
```rust
impl TransactionCommitHook for CrossShardCommitSender {
    fn on_transaction_committed(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let global_txn_idx = txn_idx + self.index_offset;
        if self.dependent_edges.contains_key(&global_txn_idx) {
            self.send_remote_update_for_success(global_txn_idx, txn_output);
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L22-27)
```rust
    pub fn set_value(&self, value: Option<StateValue>) {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        *status = RemoteValueStatus::Ready(value);
        cvar.notify_all();
    }
```
