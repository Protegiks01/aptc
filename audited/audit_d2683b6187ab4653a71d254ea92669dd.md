# Audit Report

## Title
Lack of Runtime Verification and Authentication in TSerializerClient Enables Consensus Safety Violations

## Summary
The `TSerializerClient` trait lacks runtime verification of safety invariants, and its network-based implementations (`RemoteClient`) use unencrypted, unauthenticated TCP communication. This allows man-in-the-middle attackers to bypass consensus safety rules and cause validator equivocation when SafetyRules operates in Process or Thread mode.

## Finding Description

At [1](#0-0) , the `TSerializerClient` trait defines the interface for serializer clients with no runtime verification requirements.

The `SerializerClient` accepts arbitrary implementations via `new_client()` at [2](#0-1)  and blindly trusts all responses without validation.

When SafetyRules operates in Process mode, it communicates with a remote service using `RemoteClient` at [3](#0-2) . The underlying network communication uses `aptos-secure-net`'s `NetworkClient` and `NetworkServer`, which provide **zero encryption or authentication** as shown at [4](#0-3) .

The critical consensus safety checks performed by `SafetyRules` at [5](#0-4)  can be bypassed by a malicious `TSerializerClient` implementation that returns arbitrary responses without enforcing voting rules, allowing:

1. **Equivocation**: Signing multiple blocks at the same round
2. **Safety rule violations**: Bypassing last_voted_round and preferred_round checks
3. **Consensus fork**: Different validators committing different blocks

**Attack Path:**
1. Validator configures SafetyRules in Process or Thread mode via [6](#0-5) 
2. Network attacker performs MITM on unencrypted TCP connection
3. Attacker intercepts `sign_proposal` or `construct_and_sign_vote` requests
4. Attacker returns signatures without checking safety invariants
5. Validator signs conflicting blocks, breaking consensus safety

## Impact Explanation

This vulnerability breaks the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

**Critical Severity** because:
- **Consensus Safety Violation**: Enables validator equivocation leading to chain splits
- **Loss of Funds**: Double-spending becomes possible if validators commit conflicting blocks
- **Network Partition**: Requires coordination to recover from forked state

The lack of cryptographic verification means `SerializerClient` at [7](#0-6)  cannot distinguish between legitimate SafetyRules responses and attacker-crafted responses.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Mitigating Factors:**
- Mainnet enforces Local mode via config sanitizer at [8](#0-7) , preventing this attack
- Requires network positioning for MITM attack
- Process mode requires explicit configuration

**Risk Factors:**
- Testnet/devnet validators may use Process/Thread modes
- Defense-in-depth failure: no authentication layer exists even if configured
- Thread mode uses localhost but still vulnerable to local MITM
- Configuration errors could inadvertently enable vulnerable modes

## Recommendation

**Immediate Fix:**
1. Add cryptographic authentication to `aptos-secure-net` using mutual TLS or similar
2. Implement response validation in `SerializerClient` to verify signatures match expected safety rules
3. Add runtime checks that TSerializerClient responses are cryptographically bound to SafetyRules state

**Defense-in-Depth Improvements:**
```rust
// In SerializerClient implementation
impl TSafetyRules for SerializerClient {
    fn construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        let response = self.request(SafetyRulesInput::ConstructAndSignVoteTwoChain(...))?;
        let vote: Vote = serde_json::from_slice(&response)?;
        
        // NEW: Verify the vote matches safety rules
        self.verify_vote_safety(&vote, vote_proposal)?;
        
        Ok(vote)
    }
    
    fn verify_vote_safety(&self, vote: &Vote, proposal: &VoteProposal) -> Result<(), Error> {
        // Verify round progression, QC validity, etc.
        // This creates defense-in-depth even if network is compromised
    }
}
```

**Configuration Fix:**
Extend the sanitizer to forbid Process/Thread modes on all production networks, not just mainnet.

## Proof of Concept

**Network MITM Attack (Conceptual):**

```rust
// Malicious TSerializerClient implementation
struct MaliciousTSerializerClient;

impl TSerializerClient for MaliciousTSerializerClient {
    fn request(&mut self, input: SafetyRulesInput) -> Result<Vec<u8>, Error> {
        match input {
            SafetyRulesInput::ConstructAndSignVoteTwoChain(proposal, _) => {
                // BYPASS: Return signature without checking last_voted_round
                // This allows signing multiple blocks at same round (equivocation)
                let malicious_vote = create_vote_without_safety_checks(proposal);
                Ok(serde_json::to_vec(&malicious_vote)?)
            }
            _ => // Handle other cases maliciously
        }
    }
}

// In production, this gets injected via MITM on the unencrypted TCP connection:
// 1. Intercept request from consensus to SafetyRules service
// 2. Parse the SafetyRulesInput 
// 3. Generate malicious response allowing equivocation
// 4. Send back to consensus node
// 5. Consensus node accepts it because SerializerClient doesn't verify
```

**Verification Steps:**
1. Configure validator with `SafetyRulesService::Process` pointing to attacker-controlled server
2. Attacker server returns signatures without checking `last_voted_round` 
3. Send two conflicting vote proposals at same round
4. Validator signs both, creating equivocation proof
5. Network detects safety violation and can slash validator

## Notes

The vulnerability is present in the codebase but **mitigated on mainnet** by the configuration sanitizer. However, this represents a critical defense-in-depth failure:

1. **No cryptographic authentication** in the network transport layer at [9](#0-8) 
2. **No runtime verification** that responses actually came from legitimate SafetyRules logic
3. **Trust boundary violation** where `SerializerClient` blindly trusts external inputs

Testnet, devnet, and misconfigured validators remain vulnerable. The design should enforce security through cryptography and runtime verification, not solely through configuration.

### Citations

**File:** consensus/safety-rules/src/serializer.rs (L95-97)
```rust
    pub fn new_client(service: Box<dyn TSerializerClient>) -> Self {
        Self { service }
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L104-174)
```rust
impl TSafetyRules for SerializerClient {
    fn consensus_state(&mut self) -> Result<ConsensusState, Error> {
        let _timer = counters::start_timer("external", LogEntry::ConsensusState.as_str());
        let response = self.request(SafetyRulesInput::ConsensusState)?;
        serde_json::from_slice(&response)?
    }

    fn initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
        let _timer = counters::start_timer("external", LogEntry::Initialize.as_str());
        let response = self.request(SafetyRulesInput::Initialize(Box::new(proof.clone())))?;
        serde_json::from_slice(&response)?
    }

    fn sign_proposal(&mut self, block_data: &BlockData) -> Result<bls12381::Signature, Error> {
        let _timer = counters::start_timer("external", LogEntry::SignProposal.as_str());
        let response =
            self.request(SafetyRulesInput::SignProposal(Box::new(block_data.clone())))?;
        serde_json::from_slice(&response)?
    }

    fn sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        let _timer = counters::start_timer("external", LogEntry::SignTimeoutWithQC.as_str());
        let response = self.request(SafetyRulesInput::SignTimeoutWithQC(
            Box::new(timeout.clone()),
            Box::new(timeout_cert.cloned()),
        ))?;
        serde_json::from_slice(&response)?
    }

    fn construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        let _timer =
            counters::start_timer("external", LogEntry::ConstructAndSignVoteTwoChain.as_str());
        let response = self.request(SafetyRulesInput::ConstructAndSignVoteTwoChain(
            Box::new(vote_proposal.clone()),
            Box::new(timeout_cert.cloned()),
        ))?;
        serde_json::from_slice(&response)?
    }

    fn construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        let _timer =
            counters::start_timer("external", LogEntry::ConstructAndSignOrderVote.as_str());
        let response = self.request(SafetyRulesInput::ConstructAndSignOrderVote(Box::new(
            order_vote_proposal.clone(),
        )))?;
        serde_json::from_slice(&response)?
    }

    fn sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        let _timer = counters::start_timer("external", LogEntry::SignCommitVote.as_str());
        let response = self.request(SafetyRulesInput::SignCommitVote(
            Box::new(ledger_info),
            Box::new(new_ledger_info),
        ))?;
        serde_json::from_slice(&response)?
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L177-179)
```rust
pub trait TSerializerClient: Send + Sync {
    fn request(&mut self, input: SafetyRulesInput) -> Result<Vec<u8>, Error>;
}
```

**File:** consensus/safety-rules/src/remote_service.rs (L14-22)
```rust
    fn client(&self) -> SerializerClient {
        let network_client = NetworkClient::new(
            "safety-rules".to_string(),
            self.server_address(),
            self.network_timeout_ms(),
        );
        let service = Box::new(RemoteClient::new(network_client));
        SerializerClient::new_client(service)
    }
```

**File:** secure/net/src/lib.rs (L1-29)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#![forbid(unsafe_code)]

//! This provides a simple networking substrate between a client and server. It is assumed that all
//! operations are blocking and return only complete blocks of data. The intended use case has the
//! server blocking on read.  Upon receiving a payload during a read, the server should process the
//! payload, write a response, and then block on read again. The client should block on read after
//! performing a write. Upon errors or remote disconnections, the call (read, write) will return an
//! error to let the caller know of the event. A follow up call will result in the service
//! attempting to either reconnect in the case of a client or accept a new client in the case of a
//! server.
//!
//! Internally both the client and server leverage a NetworkStream that communications in blocks
//! where a block is a length prefixed array of bytes.

pub mod grpc_network_service;
pub mod network_controller;

use aptos_logger::{info, trace, warn, Schema};
use aptos_metrics_core::{register_int_counter_vec, IntCounterVec};
use once_cell::sync::Lazy;
use serde::Serialize;
use std::{
    io::{Read, Write},
    net::{Shutdown, SocketAddr, TcpListener, TcpStream},
    thread, time,
};
```

**File:** secure/net/src/lib.rs (L149-270)
```rust
pub struct NetworkClient {
    service: String,
    server: SocketAddr,
    stream: Option<NetworkStream>,
    /// Read, Write, Connect timeout in milliseconds.
    timeout_ms: u64,
}

impl NetworkClient {
    pub fn new(service: String, server: SocketAddr, timeout_ms: u64) -> Self {
        Self {
            service,
            server,
            stream: None,
            timeout_ms,
        }
    }

    fn increment_counter(&self, method: Method, result: MethodResult) {
        increment_counter(&self.service, NetworkMode::Client, method, result)
    }

    /// Blocking read until able to successfully read an entire message
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);
        let stream = self.server()?;
        let result = stream.read();
        if let Err(err) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(&self.server));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }
        result
    }

    /// Shutdown the internal network stream
    pub fn shutdown(&mut self) -> Result<(), Error> {
        info!(SecureNetLogSchema::new(
            &self.service,
            NetworkMode::Client,
            LogEvent::Shutdown,
        ));

        let stream = self.stream.take().ok_or(Error::NoActiveStream)?;
        stream.shutdown()?;
        Ok(())
    }

    /// Blocking write until able to successfully send an entire message
    pub fn write(&mut self, data: &[u8]) -> Result<(), Error> {
        self.increment_counter(Method::Write, MethodResult::Query);
        let stream = self.server()?;
        let result = stream.write(data);
        if let Err(err) = &result {
            self.increment_counter(Method::Write, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::DisconnectedPeerOnWrite,
            )
            .error(err)
            .remote_peer(&self.server));

            self.stream = None;
        } else {
            self.increment_counter(Method::Write, MethodResult::Success);
        }
        result
    }

    fn server(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionAttempt,
            )
            .remote_peer(&self.server));

            let timeout = std::time::Duration::from_millis(self.timeout_ms);
            let mut stream = TcpStream::connect_timeout(&self.server, timeout);

            let sleeptime = time::Duration::from_millis(100);
            while let Err(err) = stream {
                self.increment_counter(Method::Connect, MethodResult::Failure);
                warn!(SecureNetLogSchema::new(
                    &self.service,
                    NetworkMode::Client,
                    LogEvent::ConnectionFailed,
                )
                .error(&err.into())
                .remote_peer(&self.server));

                thread::sleep(sleeptime);
                stream = TcpStream::connect_timeout(&self.server, timeout);
            }

            let stream = stream?;
            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, self.server, self.timeout_ms));
            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&self.server));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L204-216)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum SafetyRulesService {
    /// This runs safety rules in the same thread as event processor
    Local,
    /// This is the production, separate service approach
    Process(RemoteService),
    /// This runs safety rules in the same thread as event processor but data is passed through the
    /// light weight RPC (serializer)
    Serializer,
    /// This creates a separate thread to run safety rules, it is similar to a fork / exec style
    Thread,
}
```
