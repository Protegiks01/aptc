# Audit Report

## Title
OnChainConsensusConfig Window Size Parameter Bypass Causes Network-Wide Validator Panic and Total Loss of Availability

## Summary
The `OnChainConsensusConfig.window_size` parameter can be set to `Some(0)` through on-chain governance without validation, causing all validator nodes to panic with an assertion failure when attempting to commit blocks. This results in immediate and complete network halt requiring emergency intervention.

## Finding Description

The security question asks whether OnChainConsensusConfig parameters can be altered to cause harm. While timeout values, round durations, and safety check flags are **not** present in `OnChainConsensusConfig`, I discovered that the `window_size` parameter lacks validation and can be weaponized to achieve total network DoS.

**Attack Path:**

1. **Governance Stage**: An attacker with governance access submits a proposal to set `OnChainConsensusConfig` with `window_size: Some(0)`. [1](#0-0) 

The Move contract only validates that config bytes are non-empty, with **no semantic validation** of parameter values.

2. **Epoch Transition**: When the new epoch starts, `EpochManager::start_new_epoch()` extracts the config without validation: [2](#0-1) 

The malicious config deserializes successfully since BCS can represent `Some(0)`.

3. **StateComputer.new_epoch()**: The config is stored without any validation: [3](#0-2) 

4. **BlockStore Construction**: The `window_size` is extracted and stored: [4](#0-3) 

5. **Block Commit Trigger**: When any validator attempts to commit a block, the panic occurs: [5](#0-4) [6](#0-5) 

The assertion `assert_ne!(window_size, 0, "Window size must be greater than 0")` triggers a panic, crashing the validator node.

**Root Cause**: The Aptos framework provides **no validation layer** between on-chain governance and consensus-critical parameters. The Move contract validates only structural properties (non-empty bytes), while the Rust consensus code uses assertions instead of graceful error handling.

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability causes **Total loss of liveness/network availability**:

- All validators crash simultaneously when the first block is committed in the malicious epoch
- Network enters complete halt with zero block production
- Requires emergency intervention (hotfix deployment or governance rollback)
- Cannot be recovered through normal consensus mechanisms
- Meets the "requires hardfork" criteria for Critical severity

The attack affects **100% of validators** regardless of their individual configurations, as the malicious parameter originates from on-chain consensus configuration that all nodes must respect.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Governance access to submit and pass a proposal (requires minimum stake + voting approval)
- Knowledge of the window_size validation bypass
- Ability to craft valid BCS-serialized OnChainConsensusConfig with window_size=0

**Feasibility:**
- The attack is **deterministic** - if the malicious config is applied, all validators will crash
- **No cryptographic breaks** required - purely logic vulnerability
- **Detection window is narrow** - once the epoch transitions, the crash is immediate on first commit
- Could be disguised in a larger governance proposal with multiple config changes

**Mitigation Factors:**
- Requires governance approval (not unilateral)
- Governance participants may scrutinize proposals
- However, technical validation of BCS-encoded configs is difficult for non-experts

## Recommendation

Implement multi-layer validation for `OnChainConsensusConfig` parameters:

**1. On-Chain Validation (Move Framework):**
Add semantic validation before accepting config updates:

```move
// In consensus_config.move
public fun validate_config(config_bytes: vector<u8>): bool {
    // Deserialize and validate window_size bounds
    // Return false if window_size == Some(0)
    validator_config_internal(config_bytes)
}

native fun validator_config_internal(config_bytes: vector<u8>): bool;
```

**2. Rust Consensus Layer:**
Replace assertions with graceful error handling:

```rust
// In block_tree.rs, replace line 474:
if let Some(window_size) = window_size {
    if window_size == 0 {
        return Err(anyhow::anyhow!(
            "Invalid window_size: must be greater than 0"
        ));
    }
}
```

**3. Runtime Validation:**
Add validation in `StateComputer::new_epoch()`:

```rust
// In state_computer.rs, before line 258:
if let Some(ws) = consensus_onchain_config.window_size() {
    if ws == 0 {
        error!("Invalid window_size=0 in consensus config, using default");
        consensus_onchain_config = OnChainConsensusConfig::default();
    }
}
```

## Proof of Concept

**Governance Proposal Creation (Move):**

```move
script {
    use aptos_framework::consensus_config;
    use aptos_framework::aptos_governance;
    
    fun exploit_window_size_zero(governance_signer: &signer) {
        // Create OnChainConsensusConfig with window_size = Some(0)
        // Serialized using BCS with window_size field set to 0
        let malicious_config = x"05..."; // BCS bytes with window_size=Some(0)
        
        consensus_config::set_for_next_epoch(governance_signer, malicious_config);
        aptos_governance::reconfigure(governance_signer);
    }
}
```

**Expected Result:**
- Proposal passes governance
- New epoch starts with window_size=0
- First block commit attempt triggers panic across all validators
- Network halts immediately

**Validation:**
Check assertion location: [7](#0-6) 

The panic will occur in `calculate_window_start_round()` which is called during block commit operations.

---

**Notes:**

The security question specifically mentions "timeout values to zero, set infinite round durations, or disable safety checks" - these specific parameters do **not** exist in `OnChainConsensusConfig`. Timeout configuration resides in the local `ConsensusConfig` file [8](#0-7) , and safety checks are hardcoded in SafetyRules.

However, the `window_size` parameter vulnerability discovered here achieves equivalent impact (network DoS) through a different mechanism in the same configuration surface. This represents a critical gap in OnChainConsensusConfig validation that allows governance-level attacks on consensus availability.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/epoch_manager.rs (L896-896)
```rust
            onchain_consensus_config.window_size(),
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/state_computer.rs (L235-262)
```rust
    fn new_epoch(
        &self,
        epoch_state: &EpochState,
        payload_manager: Arc<dyn TPayloadManager>,
        transaction_shuffler: Arc<dyn TransactionShuffler>,
        block_executor_onchain_config: BlockExecutorConfigFromOnchain,
        transaction_deduper: Arc<dyn TransactionDeduper>,
        randomness_enabled: bool,
        consensus_onchain_config: OnChainConsensusConfig,
        persisted_auxiliary_info_version: u8,
        network_sender: Arc<NetworkSender>,
    ) {
        *self.state.write() = Some(MutableState {
            validators: epoch_state
                .verifier
                .get_ordered_account_addresses_iter()
                .collect::<Vec<_>>()
                .into(),
            payload_manager,
            transaction_shuffler,
            block_executor_onchain_config,
            transaction_deduper,
            is_randomness_enabled: randomness_enabled,
            consensus_onchain_config,
            persisted_auxiliary_info_version,
            network_sender,
        });
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L470-475)
```rust
        window_size: Option<u64>,
    ) -> HashValue {
        // Window Size is None only if execution pool is off
        if let Some(window_size) = window_size {
            assert_ne!(window_size, 0, "Window size must be greater than 0");
        }
```

**File:** consensus/src/block_storage/block_tree.rs (L588-588)
```rust
        let window_root_id = self.find_window_root(block_id, window_size);
```

**File:** consensus/src/util/mod.rs (L26-29)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
}
```

**File:** config/src/config/consensus_config.rs (L48-50)
```rust
    pub round_initial_timeout_ms: u64,
    pub round_timeout_backoff_exponent_base: f64,
    pub round_timeout_backoff_max_exponent: usize,
```
