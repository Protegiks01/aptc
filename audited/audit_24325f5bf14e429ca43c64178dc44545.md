# Audit Report

## Title
Protocol Mismatch Vulnerability in DKG Reliable Broadcast Encoding

## Summary
A Byzantine validator can cause protocol divergence in DKG (Distributed Key Generation) by exploiting a logic error where `to_bytes_by_protocol()` encodes messages using DirectSend protocol preferences, but `send_rb_rpc_raw()` sends them using RPC protocol preferences. This mismatch allows encoding with one protocol (e.g., CompressedBcs) while advertising another (e.g., plain Bcs), causing peers to fail decoding or receive corrupted messages.

## Finding Description
The vulnerability exists in the reliable broadcast implementation used by DKG. The attack flow is:

1. **Encoding Phase**: When `to_bytes_by_protocol()` is called, it groups peers by protocol using `group_peers_by_protocol()` [1](#0-0) , which internally calls `get_preferred_protocol_for_peer()` with `direct_send_protocols_and_preferences` [2](#0-1) .

2. **Sending Phase**: Later, when `send_rb_rpc_raw()` is invoked, it calls `send_to_peer_rpc_raw()` [3](#0-2) , which calls `get_preferred_protocol_for_peer()` with `rpc_protocols_and_preferences` [4](#0-3) .

3. **The Mismatch**: A Byzantine validator manipulates its local peer metadata to create different protocol preferences:
   - Peer P supports only `DKGDirectSendCompressed` for DirectSend
   - Peer P supports only `DKGRpcBcs` for RPC
   
4. **Encoding**: Message M is encoded using `DKGDirectSendCompressed`, which uses `CompressedBcs(RECURSION_LIMIT)` encoding [5](#0-4) .

5. **Transmission**: The compressed bytes are sent with protocol ID `DKGRpcBcs`, which expects `Bcs(RECURSION_LIMIT)` encoding [6](#0-5) .

6. **Decoding Failure**: The receiver attempts to decode compressed bytes as plain BCS, resulting in either decode failure or garbage data, breaking the DKG protocol.

The reliable broadcast code explicitly uses `to_bytes_by_protocol()` for encoding [7](#0-6)  and later sends via `send_rb_rpc_raw()` [8](#0-7) , creating this vulnerability.

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

- **Significant Protocol Violation**: DKG is critical for validator operations and epoch transitions. A Byzantine validator can prevent honest validators from successfully completing DKG by sending malformed messages.

- **Consensus Disruption**: Failed DKG prevents validators from agreeing on shared cryptographic keys, potentially blocking epoch transitions and validator set updates.

- **Selective Targeting**: A Byzantine validator can selectively target specific peers with mismatched encodings while sending correct encodings to others, causing inconsistent protocol state across the network.

- **No Recovery Without Intervention**: Peers receiving corrupted messages will continuously fail to decode DKG messages, requiring manual intervention or node restarts.

## Likelihood Explanation
**Likelihood: High**

- **Low Complexity**: The attack requires only manipulating local peer metadata, which a Byzantine validator has complete control over. No cryptographic breaking or complex timing attacks needed.

- **Undetectable**: The mismatch occurs within the validator's node; external observers cannot detect that encoding uses different protocols than advertised.

- **Byzantine Fault Model**: Aptos consensus is designed to tolerate Byzantine validators (up to 1/3). This vulnerability allows a single Byzantine validator to disrupt DKG for targeted peers.

- **Code Path Active**: This code path is executed during every DKG round, providing frequent exploitation opportunities.

## Recommendation
The root cause is using DirectSend protocols for encoding when messages will be sent via RPC. The fix is to ensure `to_bytes_by_protocol()` uses the appropriate protocol preference list based on the intended transmission method.

**Option 1**: Add a parameter to `to_bytes_by_protocol()` to specify which protocol list to use:
```rust
fn to_bytes_by_protocol(
    &self,
    peers: Vec<PeerNetworkId>,
    message: Message,
    use_rpc_protocols: bool, // NEW parameter
) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
    let protocol_preferences = if use_rpc_protocols {
        &self.rpc_protocols_and_preferences
    } else {
        &self.direct_send_protocols_and_preferences
    };
    
    let peers_per_protocol = self.group_peers_by_protocol_with_prefs(peers, protocol_preferences);
    // ... rest of implementation
}
```

**Option 2**: Create separate methods for RPC vs DirectSend encoding to make the distinction explicit and prevent misuse.

The DKG network interface should be updated to pass the correct protocol preferences when calling this method [9](#0-8) .

## Proof of Concept

```rust
// This PoC demonstrates the encoding mismatch
// To run: place in network/framework/src/application/interface.rs as a test

#[cfg(test)]
mod protocol_mismatch_test {
    use super::*;
    use crate::protocols::wire::handshake::v1::ProtocolId;
    
    #[test]
    fn test_encoding_mismatch_vulnerability() {
        // Simulate DKG message
        #[derive(Serialize, Deserialize, Clone)]
        struct TestDKGMessage {
            epoch: u64,
            data: Vec<u8>,
        }
        
        let message = TestDKGMessage {
            epoch: 1,
            data: vec![1, 2, 3, 4, 5],
        };
        
        // Encode with DKGDirectSendCompressed (CompressedBcs)
        let compressed_protocol = ProtocolId::DKGDirectSendCompressed;
        let compressed_bytes = compressed_protocol.to_bytes(&message).unwrap();
        
        // Try to decode with DKGRpcBcs (plain Bcs)
        let bcs_protocol = ProtocolId::DKGRpcBcs;
        let result: Result<TestDKGMessage, _> = bcs_protocol.from_bytes(&compressed_bytes);
        
        // This will fail because compressed bytes != BCS bytes
        assert!(result.is_err(), 
            "Decoding compressed bytes as plain BCS should fail!");
        
        // Demonstrate correct round-trip
        let bcs_bytes = bcs_protocol.to_bytes(&message).unwrap();
        let decoded: TestDKGMessage = bcs_protocol.from_bytes(&bcs_bytes).unwrap();
        assert_eq!(decoded.epoch, message.epoch);
        
        // Show that compressed and uncompressed are different
        assert_ne!(compressed_bytes, bcs_bytes,
            "Compressed and uncompressed encodings should differ!");
    }
}
```

## Notes

The vulnerability stems from a fundamental design issue where the network layer's `to_bytes_by_protocol()` method was designed for DirectSend operations but is being used for RPC operations in the reliable broadcast implementation. This affects not only DKG but potentially other systems using reliable broadcast (consensus, JWK consensus).

Additionally, there's a secondary bug where `DKGDirectSendJson` and `DKGRpcJson` protocols fall through to the default `Bcs(RECURSION_LIMIT)` encoding instead of `Json` encoding [6](#0-5) , further exacerbating potential encoding mismatches.

### Citations

**File:** network/framework/src/application/interface.rs (L169-169)
```rust
                .get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences)
```

**File:** network/framework/src/application/interface.rs (L282-282)
```rust
            self.get_preferred_protocol_for_peer(&peer, &self.rpc_protocols_and_preferences)?;
```

**File:** network/framework/src/application/interface.rs (L293-293)
```rust
        let peers_per_protocol = self.group_peers_by_protocol(peers);
```

**File:** dkg/src/network_interface.rs (L57-58)
```rust
        self.network_client
            .send_to_peer_rpc_raw(message, rpc_timeout, peer_network_id)
```

**File:** dkg/src/network_interface.rs (L62-77)
```rust
    pub fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerId>,
        message: DKGMessage,
    ) -> anyhow::Result<HashMap<PeerId, Bytes>> {
        let peer_network_ids: Vec<PeerNetworkId> = peers
            .into_iter()
            .map(|peer| self.get_peer_network_id_for_peer(peer))
            .collect();
        Ok(self
            .network_client
            .to_bytes_by_protocol(peer_network_ids, message)?
            .into_iter()
            .map(|(peer_network_id, bytes)| (peer_network_id.peer_id(), bytes))
            .collect())
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L163-165)
```rust
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L170-170)
```rust
            _ => Encoding::Bcs(RECURSION_LIMIT),
```

**File:** crates/reliable-broadcast/src/lib.rs (L130-135)
```rust
            let protocols = Arc::new(
                tokio::task::spawn_blocking(move || {
                    sender.to_bytes_by_protocol(peers, message_clone)
                })
                .await??,
            );
```

**File:** crates/reliable-broadcast/src/lib.rs (L149-149)
```rust
                        network_sender.send_rb_rpc_raw(receiver, raw_message, rpc_timeout_duration)
```
