# Audit Report

## Title
Memory Address Disclosure via Unauthenticated `/profilez` Endpoint Defeats ASLR

## Summary
The `/profilez` endpoint in the Admin Service exposes CPU profiling data in pprof protocol buffer format, which contains raw memory addresses (instruction pointers and library mappings). On testnet and devnet networks, this endpoint is accessible without authentication by default, allowing any network attacker to defeat Address Space Layout Randomization (ASLR) and obtain detailed memory layout information of validator nodes. [1](#0-0) 

## Finding Description

The admin service's `/profilez` endpoint delegates to `handle_cpu_profiling_request()`, which generates CPU profiling reports using the `pprof` crate. [2](#0-1) 

The profiling function supports two output formats: "proto" (default) and "flamegraph". When the proto format is requested, it generates a protocol buffer file conforming to the Google pprof specification. [3](#0-2) 

The pprof protocol buffer format inherently includes raw memory addresses in `Location.address` fields (containing instruction pointer values) and `Mapping` messages (containing memory region start/limit addresses). These addresses reveal where code is loaded in memory, completely defeating ASLR protection.

The authentication model is critically flawed for non-mainnet deployments: [4](#0-3) [5](#0-4) 

When `authentication_configs` is empty (the default), the endpoint allows all requests without authentication. The configuration optimizer automatically enables the admin service on non-mainnet chains: [6](#0-5) 

**Attack Scenario:**
1. Attacker identifies a testnet/devnet validator node (admin service enabled by default)
2. Attacker sends: `GET http://validator-node:9102/profilez?format=proto&seconds=30`
3. Attacker receives pprof protocol buffer containing raw memory addresses
4. Attacker parses the proto file to extract `Location.address` values for all sampled functions
5. Attacker calculates library base addresses and code offsets
6. Attacker uses this information to craft reliable ROP chains for memory corruption exploits

The `frames_post_processor` only sanitizes thread names and does not filter memory addresses: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program:

1. **Significant Protocol Violation**: ASLR is a fundamental OS-level security control. Defeating it violates the security model of the entire system.

2. **Attack Enabler for RCE**: While not directly causing Remote Code Execution, this information disclosure makes exploitation of memory corruption vulnerabilities significantly more reliable. An attacker who discovers a memory corruption bug (buffer overflow, use-after-free, etc.) can use the leaked addresses to bypass ASLR and achieve reliable code execution.

3. **Affects All Testnet/Devnet Validators**: Every validator node on testnet and devnet networks is vulnerable by default, as the admin service runs on `0.0.0.0:9102` without authentication. [8](#0-7) 

4. **Potential Mainnet Risk**: While mainnet has protections (disabled by default, requires authentication), misconfiguration could expose mainnet validators to this attack. [9](#0-8) 

## Likelihood Explanation

**Very High on Testnet/Devnet:**
- Admin service enabled by default
- No authentication required
- Endpoint publicly accessible on standard port 9102
- Attack requires only a single HTTP GET request
- No special privileges or validator access needed

**Medium on Mainnet:**
- Disabled by default, but operators might enable it for debugging
- If enabled, requires authentication (but weak passcode-based auth)
- Configuration sanitizer prevents enabling without auth, but only if chain_id is known [10](#0-9) 

The vulnerability is trivially exploitable once the admin service is accessible.

## Recommendation

**Immediate Mitigations:**

1. **Remove proto format support from unauthenticated endpoints**: The flamegraph format contains symbolicated function names without raw addresses and is safer for debugging.

2. **Disable proto format by default**: Only allow proto format when explicitly enabled via configuration with strong authentication.

3. **Require authentication on all networks**: Do not default to no authentication even on testnet/devnet.

4. **Bind to localhost by default**: Change default address from `0.0.0.0` to `127.0.0.1` to prevent network access.

**Code Fix Suggestion:**

In `config/src/config/admin_service_config.rs`:
- Change default address to `127.0.0.1`
- Add authentication requirement for all networks, not just mainnet
- Add a `allow_proto_format: bool` flag that defaults to `false`

In `crates/aptos-system-utils/src/profiling.rs`:
- Remove proto format support or add explicit configuration check
- If proto format is requested without proper authorization, return an error

## Proof of Concept

**Step 1: Start a testnet validator node** (admin service will be enabled by default)

**Step 2: Request profile data:**
```bash
curl "http://localhost:9102/profilez?format=proto&seconds=10" -o profile.pb
```

**Step 3: Parse the protocol buffer to extract addresses:**
```rust
use pprof::protos::Message;
use std::io::Read;

fn main() -> anyhow::Result<()> {
    let mut file = std::fs::File::open("profile.pb")?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    
    let profile = pprof::protos::perftools::profiles::Profile::parse_from_bytes(&buffer)?;
    
    println!("=== Memory Address Disclosure ===");
    for location in profile.location.iter() {
        if location.address > 0 {
            println!("Function at address: 0x{:x}", location.address);
        }
    }
    
    for mapping in profile.mapping.iter() {
        println!("Memory region: 0x{:x} - 0x{:x}", 
                 mapping.memory_start, mapping.memory_limit);
    }
    
    Ok(())
}
```

**Expected Output:**
```
=== Memory Address Disclosure ===
Function at address: 0x7f8a2c4e1230
Function at address: 0x7f8a2c4e1450
Memory region: 0x7f8a2c000000 - 0x7f8a2d000000
...
```

These addresses reveal the exact memory layout, defeating ASLR and enabling targeted memory corruption exploits.

## Notes

- The vulnerability affects the pprof **protocol buffer format** specifically. The flamegraph SVG format only contains symbolicated function names and is safer (though still reveals some implementation details).
- The `pprof` crate version 0.11 with `protobuf-codec` feature implements the standard Google pprof format, which includes raw addresses by specification.
- The comment at line 21 of `admin_service_config.rs` explicitly acknowledges the authentication issue: "If empty, will allow all requests without authentication. (Not allowed on mainnet.)" However, this design is still vulnerable on testnet/devnet and to mainnet misconfigurations. [11](#0-10)

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-156)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L185-185)
```rust
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
```

**File:** crates/aptos-system-utils/src/profiling.rs (L19-78)
```rust
pub async fn handle_cpu_profiling_request(req: Request<Body>) -> hyper::Result<Response<Body>> {
    let query = req.uri().query().unwrap_or("");
    let query_pairs: HashMap<_, _> = url::form_urlencoded::parse(query.as_bytes()).collect();

    let seconds: u64 = match query_pairs.get("seconds") {
        Some(val) => match val.parse() {
            Ok(val) => val,
            Err(err) => return Ok(reply_with_status(StatusCode::BAD_REQUEST, err.to_string())),
        },
        None => 10,
    };

    let frequency: i32 = match query_pairs.get("frequency") {
        Some(val) => match val.parse() {
            Ok(val) => val,
            Err(err) => return Ok(reply_with_status(StatusCode::BAD_REQUEST, err.to_string())),
        },
        None => 99,
    };

    let use_proto = match query_pairs.get("format") {
        Some(format) => match format.as_ref() {
            "proto" => true,
            "flamegraph" => false,
            _ => {
                return Ok(reply_with_status(
                    StatusCode::BAD_REQUEST,
                    "Unsupported format.",
                ))
            },
        },
        _ => true,
    };

    match start_cpu_profiling(seconds, frequency, use_proto).await {
        Ok(body) => {
            let content_type = if use_proto {
                mime::APPLICATION_OCTET_STREAM
            } else {
                mime::IMAGE_SVG
            };
            let headers: Vec<(_, HeaderValue)> = vec![
                (CONTENT_LENGTH, HeaderValue::from(body.len())),
                (CONTENT_DISPOSITION, HeaderValue::from_static("inline")),
                (
                    CONTENT_TYPE,
                    HeaderValue::from_str(content_type.as_ref()).unwrap(),
                ),
            ];
            Ok(reply_with(headers, body))
        },
        Err(e) => {
            info!("Failed to generate cpu profile: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
    }
}
```

**File:** crates/aptos-system-utils/src/profiling.rs (L107-112)
```rust
    if use_proto {
        report
            .pprof()
            .map_err(|e| anyhow!("Failed to generate proto report: {e:?}."))?
            .write_to_vec(&mut body)
            .map_err(|e| anyhow!("Failed to serialize proto report: {e:?}."))?;
```

**File:** crates/aptos-system-utils/src/profiling.rs (L124-132)
```rust
fn frames_post_processor() -> impl Fn(&mut pprof::Frames) {
    let regex = Regex::new(r"^(.*)-(\d*)$").unwrap();

    move |frames| {
        if let Some((_, [name, _])) = regex.captures(&frames.thread_name).map(|c| c.extract()) {
            frames.thread_name = name.to_string();
        }
    }
}
```

**File:** config/src/config/admin_service_config.rs (L21-22)
```rust
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L59-82)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/admin_service_config.rs (L93-100)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```
