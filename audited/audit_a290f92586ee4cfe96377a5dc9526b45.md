# Audit Report

## Title
Semantically Invalid PayloadUnavailable Timeout with All-Zeros BitVec Causes Incorrect Failure Tracking

## Summary
The timeout aggregation logic in `pending_votes.rs` can create a `PayloadUnavailable` timeout reason with an all-zeros `missing_authors` BitVec, which is semantically contradictory. This causes the failure tracker to degrade optimistic quorum store performance without excluding any problematic validators, leading to unnecessary liveness degradation.

## Finding Description

The `check_payload_availability` method correctly ensures that if all batches are available (all zeros), it returns `Ok(())` rather than an error. [1](#0-0) 

However, during timeout vote aggregation, the system can create a semantically invalid state. The `aggregated_timeout_reason` method aggregates timeout votes from multiple validators. [2](#0-1) 

When computing the aggregated missing authors BitVec, the code creates a new all-zeros BitVec and only sets bits for authors reported missing by f+1 validators. [3](#0-2) 

**The vulnerability**: If f+1 validators report `PayloadUnavailable` but each reports different missing authors such that NO single author reaches the f+1 threshold, the result is `PayloadUnavailable { missing_authors: <all zeros> }`.

**Example Scenario** (7 validators, f+1 = 3):
- V0, V1, V2, V3 each report `PayloadUnavailable` with different single authors missing
- Total PayloadUnavailable voting power = 4 (reaches f+1)
- But each individual author only has voting power = 1 (below f+1 threshold)
- Result: `PayloadUnavailable { missing_authors: <all zeros> }`

This semantically invalid state is then consumed by the failure tracker. The tracker treats any `PayloadUnavailable` as a failure and doubles the failure window, [4](#0-3)  but when computing which authors to exclude, the all-zeros BitVec results in an empty exclusion set. [5](#0-4) 

## Impact Explanation

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention" because:

1. **Liveness Degradation**: The system unnecessarily reduces optimistic proposal frequency (by doubling the failure window) without addressing the root cause
2. **Protocol Correctness**: Creates semantically contradictory state that violates the invariant that PayloadUnavailable should identify specific problematic validators
3. **Persistent Issue**: The problem can recur across multiple rounds, compounding the performance impact
4. **No Automatic Recovery**: Requires manual investigation to understand why optimistic quorum store is degraded despite no validators being excluded

This does not reach High/Critical severity because it affects liveness/performance rather than consensus safety or fund security.

## Likelihood Explanation

**Likelihood: Medium**

This can occur naturally in production under the following realistic conditions:
- Network partitions cause different validators to have different views of batch availability
- Byzantine validators send inconsistent timeout reports
- Transient network issues cause temporary batch unavailability that differs across validators

The scenario does not require a coordinated attack, just distributed system conditions where validators disagree about which specific authors have missing batches.

## Recommendation

Add validation in `aggregated_timeout_reason` to prevent returning `PayloadUnavailable` with an all-zeros BitVec:

```rust
if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
    for (author_idx, voting_power) in missing_batch_authors {
        if verifier
            .check_aggregated_voting_power(voting_power, false)
            .is_ok()
        {
            aggregated_bitvec.set(author_idx as u16);
        }
    }
    
    // CRITICAL FIX: If no specific author can be identified as problematic,
    // don't return PayloadUnavailable
    if aggregated_bitvec.all_zeros() {
        return RoundTimeoutReason::Unknown;
    }
    
    RoundTimeoutReason::PayloadUnavailable {
        missing_authors: aggregated_bitvec,
    }
}
```

This ensures that `PayloadUnavailable` is only used when at least one specific validator can be identified as having missing batches, maintaining semantic consistency and enabling proper failure tracking.

## Proof of Concept

The issue is demonstrated in the existing test that creates `PayloadUnavailable` with all-zeros BitVec without validation: [6](#0-5) 

A more complete PoC would involve setting up 7 validators where 4 send `PayloadUnavailable` timeouts with different single-bit missing_authors patterns, then verifying that:
1. The aggregated reason is `PayloadUnavailable` (4 >= f+1)
2. The aggregated `missing_authors` BitVec is all zeros (no author reaches f+1)
3. The failure window doubles
4. But `get_exclude_authors()` returns an empty set

This can be implemented as a Rust unit test in `consensus/src/pending_votes_test.rs` by constructing the appropriate timeout votes and calling `aggregated_timeout_reason()`.

## Notes

**All-Ones Case**: The inverse scenario (all validators reporting all authors missing, resulting in all-ones BitVec) is also problematic as it would exclude ALL validators from optimistic proposals, effectively disabling the feature. However, this requires more extreme conditions and is less likely to occur naturally.

The fix addresses both extreme cases by ensuring semantic validity: `PayloadUnavailable` should only be used when specific problematic validators can be identified.

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L420-424)
```rust
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/pending_votes.rs (L93-153)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L204-210)
```rust
        tracker.push(NewRoundReason::Timeout(
            RoundTimeoutReason::PayloadUnavailable {
                missing_authors: BitVec::with_num_bits(4),
            },
        ));
        assert_eq!(tracker.window, 4);
        assert_eq!(tracker.last_consecutive_success_count, 0);
```
