# Audit Report

## Title
Missing On-Chain Validation for Randomness Threshold Parameters Allows Governance to Break Randomness Security or Liveness

## Summary
The `randomness_config::new_v1()` Move function lacks on-chain validation of threshold relationships, allowing governance proposals to set invalid DKG threshold values that either break randomness security (allowing small coalitions to reconstruct randomness) or break liveness (requiring excessive validator participation). While Rust-side validation exists, it is bypassed during governance proposal execution.

## Finding Description

The Aptos randomness system uses Distributed Key Generation (DKG) with two critical threshold parameters:
- **secrecy_threshold**: Maximum validator stake ratio that cannot reconstruct randomness (intended: â‰¤50%)
- **reconstruction_threshold**: Minimum validator stake ratio that can reconstruct randomness (intended: >66.67%)

These parameters must satisfy strict cryptographic constraints to ensure security:
1. `secrecy_threshold > 1/3` (prevents minority from revealing secrets)
2. `secrecy_threshold < reconstruction_threshold` (ensures gap between secrecy and reconstruction)
3. `reconstruction_threshold <= 2/3` (ensures supermajority can always reconstruct)

**The Vulnerability:**

The on-chain Move function `randomness_config::new_v1()` accepts threshold parameters without any validation: [1](#0-0) 

This allows governance proposals to execute Move scripts that set arbitrary threshold values. When validators initialize DKG for the next epoch, they call `DKGRounding::new()`: [2](#0-1) 

The `DKGRoundingProfile::new()` function has validation logic: [3](#0-2) 

However, when these validations fail, the code falls back to `infallible()` mode which does NOT enforce the critical constraints: [4](#0-3) 

The `infallible()` function only ensures `reconstruct >= secrecy` and both are in [0,1], but crucially does NOT validate the security-critical constraints.

**Attack Scenario:**

1. Attacker (or compromised governance) submits a proposal with malicious thresholds:
   - Low thresholds: `secrecy=0.1, reconstruct=0.2` (breaks security)
   - High thresholds: `secrecy=0.9, reconstruct=0.9` (breaks liveness)

2. Proposal calls: [5](#0-4) 

3. All validators deterministically compute the same invalid DKG configuration

4. **Low threshold impact**: Coalition with 20% stake can reconstruct randomness (should require 66.67%)

5. **High threshold impact**: Randomness fails if >10% validators offline (should tolerate up to 33%)

## Impact Explanation

**Critical Severity** - This vulnerability enables two critical attack vectors:

1. **Randomness Security Breach**: With low thresholds (e.g., `reconstruct=0.2`), only 20% of validator stake is needed to reconstruct on-chain randomness. This breaks the security model requiring supermajority (66.67%) participation. Attackers controlling 20% stake could:
   - Predict future randomness values
   - Manipulate randomness-dependent outcomes
   - Front-run randomness-based applications

2. **Liveness Failure**: With high thresholds (e.g., `reconstruct=0.9`), the network requires >90% validator participation to generate randomness. This causes:
   - Randomness generation failure if 10%+ validators are offline
   - Blocking of all randomness-dependent features
   - Potential consensus stalls if randomness is consensus-critical

This qualifies as **"Total loss of liveness/network availability"** (Critical) for the high-threshold case, and **"Significant protocol violations"** (High) for the low-threshold case.

## Likelihood Explanation

**Medium-High Likelihood:**

- **Attack Requirements**: Requires governance proposal execution, which needs either:
  - Sufficient voting power to pass a proposal legitimately (high stake requirement)
  - Compromise of governance process
  - Social engineering of governance participants

- **Feasibility**: Once governance access is obtained, the attack is straightforward - simply submit a proposal with invalid thresholds. The lack of validation makes this trivial to execute.

- **Detection**: The invalid thresholds would be visible in the governance proposal, but without automated validation, may not be caught before execution.

- **Mitigation Complexity**: Currently there is NO on-chain defense against this attack.

## Recommendation

Add on-chain validation to `randomness_config::new_v1()` and `new_v2()` functions to enforce threshold constraints:

```move
/// Create a `ConfigV1` variant with validation.
public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
    use aptos_std::fixed_point64;
    
    // Validate: secrecy_threshold > 1/3
    let one_third = fixed_point64::create_from_rational(1, 3);
    assert!(fixed_point64::greater(secrecy_threshold, one_third), EINVALID_SECRECY_THRESHOLD);
    
    // Validate: secrecy_threshold < reconstruction_threshold
    assert!(fixed_point64::less(secrecy_threshold, reconstruction_threshold), EINVALID_THRESHOLD_RELATIONSHIP);
    
    // Validate: reconstruction_threshold <= 2/3
    let two_thirds = fixed_point64::create_from_rational(2, 3);
    assert!(fixed_point64::less_or_equal(reconstruction_threshold, two_thirds), EINVALID_RECONSTRUCTION_THRESHOLD);
    
    RandomnessConfig {
        variant: copyable_any::pack( ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold
        } )
    }
}
```

Add corresponding error constants:
```move
const EINVALID_SECRECY_THRESHOLD: u64 = 2;
const EINVALID_THRESHOLD_RELATIONSHIP: u64 = 3;
const EINVALID_RECONSTRUCTION_THRESHOLD: u64 = 4;
```

## Proof of Concept

```move
#[test(framework = @0x1)]
#[expected_failure(abort_code = 0x10003)] // Should abort with EINVALID_THRESHOLD_RELATIONSHIP
fun test_invalid_thresholds_attack(framework: signer) {
    use aptos_framework::randomness_config;
    use aptos_std::fixed_point64;
    
    // Attack: Set thresholds that violate security constraints
    // secrecy > reconstruct (backwards relationship)
    let malicious_config = randomness_config::new_v1(
        fixed_point64::create_from_rational(9, 10),  // 90% secrecy
        fixed_point64::create_from_rational(1, 10)   // 10% reconstruct
    );
    
    // This should FAIL but currently SUCCEEDS without on-chain validation
    randomness_config::set_for_next_epoch(&framework, malicious_config);
}

#[test(framework = @0x1)]
#[expected_failure(abort_code = 0x10004)] // Should abort with EINVALID_RECONSTRUCTION_THRESHOLD
fun test_excessive_reconstruct_threshold(framework: signer) {
    use aptos_framework::randomness_config;
    use aptos_std::fixed_point64;
    
    // Attack: Set reconstruct threshold too high (breaks liveness)
    let malicious_config = randomness_config::new_v1(
        fixed_point64::create_from_rational(5, 10),  // 50% secrecy (valid)
        fixed_point64::create_from_rational(9, 10)   // 90% reconstruct (too high!)
    );
    
    // This should FAIL but currently SUCCEEDS
    randomness_config::set_for_next_epoch(&framework, malicious_config);
}
```

## Notes

While the Rust-side DKG implementation handles invalid thresholds deterministically (preventing consensus splits), it still accepts dangerous configurations through the `infallible()` fallback mechanism. The lack of on-chain validation creates a trust dependency on off-chain governance review processes, which is insufficient for security-critical parameters. This violates the principle of on-chain enforcement of invariants and leaves the system vulnerable to governance-level attacks or mistakes.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-100)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L61-129)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );

        let total_weight_min = total_weight_lower_bound(validator_stakes);
        let total_weight_max = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );

        let (profile, rounding_error, rounding_method) = match DKGRoundingProfile::new(
            validator_stakes,
            total_weight_min,
            total_weight_max,
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        ) {
            Ok(profile) => (profile, None, "binary_search".to_string()),
            Err(e) => {
                let profile = DKGRoundingProfile::infallible(
                    validator_stakes,
                    secrecy_threshold_in_stake_ratio,
                    reconstruct_threshold_in_stake_ratio,
                    fast_secrecy_threshold_in_stake_ratio,
                );
                (profile, Some(format!("{e}")), "infallible".to_string())
            },
        };
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();

        let fast_wconfig = profile.fast_reconstruct_threshold_in_weights.map(
            |fast_reconstruct_threshold_in_weights| {
                WeightedConfigBlstrs::new(
                    fast_reconstruct_threshold_in_weights as usize,
                    profile
                        .validator_weights
                        .iter()
                        .map(|w| *w as usize)
                        .collect(),
                )
                .unwrap()
            },
        );

        Self {
            rounding_method,
            profile,
            wconfig,
            fast_wconfig,
            rounding_error,
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L197-199)
```rust
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```

**File:** aptos-move/aptos-release-builder/src/components/randomness_config.rs (L81-97)
```rust
                    emitln!(writer, "let v1 = randomness_config::new_v1(");
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        secrecy_threshold_in_percentage
                    );
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        reconstruct_threshold_in_percentage
                    );
                    emitln!(writer, ");");
                    emitln!(
                        writer,
                        "randomness_config::set_for_next_epoch({}, v1);",
                        signer_arg
                    );
```
