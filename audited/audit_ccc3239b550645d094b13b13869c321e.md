# Audit Report

## Title
Unmetered Access Control Check Computation Enables Validator Griefing Attack

## Summary
The Move VM's access control system performs unbounded computational work during resource operations without charging gas, allowing attackers to craft transactions that force validators to execute tens of thousands of clause checks while paying minimal gas fees.

## Finding Description

The Move VM implements a runtime access control system that validates resource access permissions through `AccessSpecifier` constraints. When functions with access specifiers are called, these specifiers are pushed onto a stack, and every resource operation (`exists`, `borrow_global`, `move_from`, `move_to`) must verify the access against ALL specifiers on the stack.

**The Critical Gas Metering Gap:**

The access control verification happens in `AccessControlState::check_access()` which iterates through the entire specifier stack calling `AccessSpecifier::enables()` for each entry. This computation is **completely unmetered** - no gas is charged for this work. [1](#0-0) 

The `enables()` method must check all inclusion clauses (up to 64 per specifier) and ALL exclusion clauses (up to 64 per specifier), performing struct identifier comparisons, type parameter vector comparisons, and address comparisons for each clause: [2](#0-1) 

Each clause check involves multiple complex matching operations: [3](#0-2) [4](#0-3) 

**Exploitation Path:**

1. The binary format allows up to 64 access specifier clauses per function: [5](#0-4) 

2. The access specifier stack can grow to 256 entries deep: [6](#0-5) 

3. When entering functions, specifiers are pushed WITHOUT any gas charge: [7](#0-6) 

4. Resource operations charge gas for the operation itself but NOT for the access control checks that follow: [8](#0-7) 

**Attack Scenario:**

An attacker deploys Move modules where:
- Each function has 64 inclusion + 64 exclusion clauses (maximum allowed)
- Functions call each other in a chain 256 levels deep
- At maximum depth, performs resource operations repeatedly

**Worst-case computational cost per resource operation:**
- Stack depth: 256 specifiers
- Each specifier: 64 inclusion + 64 exclusion clauses
- Total clause checks: 256 × 128 = **32,768 clause evaluations**
- Each clause involves struct comparisons, type parameter vector comparisons, and address comparisons

The attacker pays only for:
- Function call gas (based on arguments/locals)
- Resource operation gas (exists/borrow_global/etc.)

But forces validators to execute **32,768+ complex comparisons per resource operation** with ZERO gas accounting.

This breaks **Critical Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" and **Critical Invariant #3**: "Move VM Safety: Bytecode execution must respect gas limits and memory constraints".

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria: "Validator node slowdowns"

This vulnerability enables a **griefing attack** where:

1. **Disproportionate Resource Consumption**: An attacker pays minimal gas fees while forcing validators to perform massive computational work (30k+ operations per resource access)

2. **Network Performance Degradation**: Multiple such transactions in blocks cause validator nodes to spend excessive CPU time on unmetered access control checks, slowing block processing

3. **Unfair Gas Economics**: Honest users pay fair gas prices while attackers consume validator resources at a fraction of the cost, violating the gas metering security model

4. **Deterministic Execution Preserved**: While this doesn't break consensus (all validators execute identically), it creates asymmetric resource consumption that can degrade network performance

The GasMeter trait defines all chargeable operations but has NO method for access control computation: [9](#0-8) 

## Likelihood Explanation

**HIGH Likelihood**

1. **Easy to Exploit**: Any user can deploy Move modules with access specifiers - no special permissions required
2. **Low Cost to Attack**: Attacker pays only standard gas for operations, not proportional to the computational burden imposed
3. **Realistic Attack Vector**: The access specifier feature is production code; attackers can craft modules that maximize the unmetered work
4. **Persistent Threat**: Once deployed, malicious modules can be called repeatedly by any transaction

## Recommendation

**Add gas metering for access control checks proportional to computational cost:**

```rust
// In AccessControlState::check_access()
pub(crate) fn check_access(
    &self, 
    access: AccessInstance,
    gas_meter: &mut impl GasMeter  // ADD gas meter parameter
) -> PartialVMResult<()> {
    for specifier in self.specifier_stack.iter().rev() {
        // Charge gas proportional to number of clauses checked
        let num_clauses = match specifier {
            AccessSpecifier::Any => 0,
            AccessSpecifier::Constraint(incls, excls) => incls.len() + excls.len(),
        };
        
        // Charge base cost per specifier + per-clause cost
        gas_meter.charge_access_control_check(num_clauses)?;
        
        if !specifier.enables(&access) {
            return Err(PartialVMError::new(StatusCode::ACCESS_DENIED)
                .with_message(format!("not allowed to perform `{}`", access)));
        }
    }
    Ok(())
}
```

**Additionally:**

1. Extend `GasMeter` trait with `charge_access_control_check(num_clauses: usize)` method
2. Implement appropriate gas parameters in the gas schedule (e.g., `ACCESS_CHECK_BASE`, `ACCESS_CHECK_PER_CLAUSE`)
3. Thread the gas meter through all `check_access` call sites in the interpreter
4. Consider lowering `ACCESS_SPECIFIER_COUNT_MAX` if gas costs become prohibitive

## Proof of Concept

```move
// Attacker deploys this module
module attacker::griefing {
    use std::signer;
    
    struct Resource1 has key { value: u64 }
    struct Resource2 has key { value: u64 }
    // ... define 64 different resources
    
    // Each function has maximum access specifier clauses (64 includes + 64 excludes)
    // This would be declared as:
    // reads Resource1, reads Resource2, ..., reads Resource64,
    // !writes Resource1, !writes Resource2, ..., !writes Resource64
    public fun level_1() 
        reads Resource1, reads Resource2  // ... 64 reads clauses
        !writes Resource1, !writes Resource2  // ... 64 negated writes
    {
        level_2();
    }
    
    public fun level_2()
        reads Resource1, reads Resource2  // ... 64 reads clauses
        !writes Resource1, !writes Resource2  // ... 64 negated writes
    {
        level_3();
    }
    
    // ... continue nesting up to 256 levels
    
    public fun level_256(addr: address)
        reads Resource1, reads Resource2  // ... 64 reads clauses
        !writes Resource1, !writes Resource2  // ... 64 negated writes
    {
        // At max stack depth, perform many resource operations
        let _ = exists<Resource1>(addr);  // Forces 32,768 clause checks
        let _ = exists<Resource2>(addr);  // Forces another 32,768 checks
        // Repeat for massive unmetered computation
    }
}

// Transaction script:
script {
    fun main(account: &signer) {
        attacker::griefing::level_1();
        // Pays minimal gas but forces validators to execute
        // 256 stack depth × 128 clauses × multiple operations
        // = hundreds of thousands of unmetered comparisons
    }
}
```

**Expected Behavior**: Transaction consumes gas proportional to the number of function calls and resource operations only.

**Actual Behavior**: Validators perform 30k+ clause evaluations per resource operation with zero gas accounting, enabling griefing attacks that degrade network performance.

## Notes

This vulnerability is specific to the access control feature introduced in bytecode version 7. The property tests correctly validate the semantic correctness of `enables()` but fail to validate that this computation is properly metered, as noted in the security question. The fix requires extending the gas metering infrastructure to account for access control verification costs.

### Citations

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L26-48)
```rust
    pub(crate) fn enter_function(
        &mut self,
        env: &impl AccessSpecifierEnv,
        fun: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if matches!(fun.access_specifier(), AccessSpecifier::Any) {
            // Shortcut case that no access is specified
            return Ok(());
        }
        if self.specifier_stack.len() >= ACCESS_STACK_SIZE_LIMIT {
            Err(
                PartialVMError::new(StatusCode::ACCESS_STACK_LIMIT_EXCEEDED).with_message(format!(
                    "access specifier stack overflow (limit = {})",
                    ACCESS_STACK_SIZE_LIMIT
                )),
            )
        } else {
            // Specialize the functions access specifier and push it on the stack.
            let mut fun_specifier = fun.access_specifier().clone();
            fun_specifier.specialize(env)?;
            self.specifier_stack.push(fun_specifier);
            Ok(())
        }
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L68-77)
```rust
    /// Check whether the given access is allowed in the current state.
    pub(crate) fn check_access(&self, access: AccessInstance) -> PartialVMResult<()> {
        for specifier in self.specifier_stack.iter().rev() {
            if !specifier.enables(&access) {
                return Err(PartialVMError::new(StatusCode::ACCESS_DENIED)
                    .with_message(format!("not allowed to perform `{}`", access)));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L144-153)
```rust
    pub fn enables(&self, access: &AccessInstance) -> bool {
        use AccessSpecifier::*;
        match self {
            Any => true,
            Constraint(incls, excls) => {
                (incls.is_empty() && !excls.is_empty() || incls.iter().any(|c| c.includes(access)))
                    && excls.iter().all(|c| !c.excludes(access))
            },
        }
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L158-174)
```rust
    fn includes(&self, access: &AccessInstance) -> bool {
        use AccessKind::*;
        let AccessInstance {
            kind,
            resource,
            instance,
            address,
        } = access;
        let kind_allows = match (self.kind, kind) {
            (Reads, Reads) => true,
            (Reads, Writes) => false,
            // `writes` enables both read and write access
            (Writes, Reads) => true,
            (Writes, Writes) => true,
        };
        kind_allows && self.resource.matches(resource, instance) && self.address.matches(address)
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L206-217)
```rust
    fn matches(&self, struct_id: &StructIdentifier, type_inst: &[Type]) -> bool {
        use ResourceSpecifier::*;
        match self {
            Any => true,
            DeclaredAtAddress(addr) => struct_id.module().address() == addr,
            DeclaredInModule(module_id) => struct_id.module() == module_id,
            Resource(enabled_struct_id) => enabled_struct_id == struct_id,
            ResourceInstantiation(enabled_struct_id, enabled_type_inst) => {
                enabled_struct_id == struct_id && enabled_type_inst == type_inst
            },
        }
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L86-86)
```rust
pub const ACCESS_SPECIFIER_COUNT_MAX: u64 = 64;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1379-1402)
```rust
        let res = gv.borrow_global();
        gas_meter.charge_borrow_global(
            is_mut,
            is_generic,
            TypeWithRuntimeEnvironment {
                ty,
                runtime_environment,
            },
            res.is_ok(),
        )?;
        self.check_access(
            runtime_environment,
            if is_mut {
                AccessKind::Writes
            } else {
                AccessKind::Reads
            },
            ty,
            addr,
        )?;
        self.operand_stack.push(res.map_err(|err| {
            err.with_message(format!("Failed to borrow global resource from {:?}", addr))
        })?)?;
        Ok(())
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1768-1768)
```rust
pub(crate) const ACCESS_STACK_SIZE_LIMIT: usize = 256;
```

**File:** third_party/move/move-vm/types/src/gas.rs (L210-392)
```rust
pub trait GasMeter: NativeGasMeter {
    fn balance_internal(&self) -> InternalGas;

    /// Charge an instruction and fail if not enough gas units are left.
    fn charge_simple_instr(&mut self, instr: SimpleInstruction) -> PartialVMResult<()>;

    fn charge_br_true(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;

    fn charge_br_false(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;

    fn charge_branch(&mut self, target_offset: CodeOffset) -> PartialVMResult<()>;

    fn charge_pop(&mut self, popped_val: impl ValueView) -> PartialVMResult<()>;

    fn charge_call(
        &mut self,
        module_id: &ModuleId,
        func_name: &str,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
        num_locals: NumArgs,
    ) -> PartialVMResult<()>;

    fn charge_call_generic(
        &mut self,
        module_id: &ModuleId,
        func_name: &str,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
        num_locals: NumArgs,
    ) -> PartialVMResult<()>;

    fn charge_ld_const(&mut self, size: NumBytes) -> PartialVMResult<()>;

    fn charge_ld_const_after_deserialization(&mut self, val: impl ValueView)
        -> PartialVMResult<()>;

    fn charge_copy_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_move_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_store_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_pack(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_pack_variant(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // Currently mapped to pack, can be specialized if needed
        self.charge_pack(is_generic, args)
    }

    fn charge_unpack(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_unpack_variant(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // Currently mapped to pack, can be specialized if needed
        self.charge_unpack(is_generic, args)
    }

    fn charge_pack_closure(
        &mut self,
        is_generic: bool,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_read_ref(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_write_ref(
        &mut self,
        new_val: impl ValueView,
        old_val: impl ValueView,
    ) -> PartialVMResult<()>;

    fn charge_eq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()>;

    fn charge_neq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()>;

    fn charge_borrow_global(
        &mut self,
        is_mut: bool,
        is_generic: bool,
        ty: impl TypeView,
        is_success: bool,
    ) -> PartialVMResult<()>;

    fn charge_exists(
        &mut self,
        is_generic: bool,
        ty: impl TypeView,
        // TODO(Gas): see if we can get rid of this param
        exists: bool,
    ) -> PartialVMResult<()>;

    fn charge_move_from(
        &mut self,
        is_generic: bool,
        ty: impl TypeView,
        val: Option<impl ValueView>,
    ) -> PartialVMResult<()>;

    fn charge_move_to(
        &mut self,
        is_generic: bool,
        ty: impl TypeView,
        val: impl ValueView,
        is_success: bool,
    ) -> PartialVMResult<()>;

    fn charge_vec_pack(
        &mut self,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_vec_len(&mut self) -> PartialVMResult<()>;

    fn charge_vec_borrow(&mut self, is_mut: bool) -> PartialVMResult<()>;

    fn charge_vec_push_back(&mut self, val: impl ValueView) -> PartialVMResult<()>;

    fn charge_vec_pop_back(&mut self, val: Option<impl ValueView>) -> PartialVMResult<()>;

    fn charge_vec_unpack(
        &mut self,
        expect_num_elements: NumArgs,
        elems: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    // TODO(Gas): Expose the two elements
    fn charge_vec_swap(&mut self) -> PartialVMResult<()>;

    /// Charges for loading a resource from storage. This is only called when the resource is not
    /// cached.
    ///
    /// WARNING: This can be dangerous if you execute multiple user transactions in the same
    /// session -- identical transactions can have different gas costs. Use at your own risk.
    fn charge_load_resource(
        &mut self,
        addr: AccountAddress,
        ty: impl TypeView,
        val: Option<impl ValueView>,
        bytes_loaded: NumBytes,
    ) -> PartialVMResult<()>;

    /// Charge for executing a native function.
    /// The cost is calculated returned by the native function implementation.
    /// Should fail if not enough gas units are left.
    ///
    /// In the future, we may want to remove this and directly pass a reference to the GasMeter
    /// instance to the native functions to allow gas to be deducted during computation.
    fn charge_native_function(
        &mut self,
        amount: InternalGas,
        ret_vals: Option<impl ExactSizeIterator<Item = impl ValueView> + Clone>,
    ) -> PartialVMResult<()>;

    fn charge_native_function_before_execution(
        &mut self,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_drop_frame(
        &mut self,
        locals: impl Iterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()>;

    fn charge_create_ty(&mut self, num_nodes: NumTypeNodes) -> PartialVMResult<()>;

    fn charge_abort_message(&mut self, bytes: &[u8]) -> PartialVMResult<()>;
}
```
