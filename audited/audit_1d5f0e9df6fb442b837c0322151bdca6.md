# Audit Report

## Title
Missing Cryptographic Verification of Decrypted PVSS Secret Shares Enables Undetected Share Corruption

## Summary
Validators in the Aptos DKG system cannot cryptographically verify that their decrypted `DealtSecretKeyShare` is consistent with the publicly committed `DealtPubKey` without revealing the share value. While the verification is cryptographically possible and necessary for defense-in-depth, it is not implemented in the PVSS `decrypt_own_share` methods, leaving validators unable to detect corrupted shares from implementation bugs or malicious transcripts. [1](#0-0) 

## Finding Description

The chunky PVSS implementation defines `DealtSecretKeyShare` as a scalar field element and `DealtPubKeyShare` as a G2 group element, but provides no mechanism for validators to verify their consistency after decryption. [2](#0-1) 

The `decrypt_own_share` method:
1. Decrypts ciphertexts using the validator's decryption key
2. Uses BSGS discrete logarithm to recover secret share chunks
3. Returns both the secret share and public share extracted from the transcript
4. **Does NOT verify** that `public_share == G2_generator * secret_share`

This same pattern exists in the Transcript implementation: [3](#0-2) 

The DKG system calls this directly without additional verification: [4](#0-3) 

While transcript verification performs pairing-based checks with random coefficients, this is probabilistic and aggregate-level. Individual validators have no way to verify their specific decrypted shares match their committed public values.

Test code reveals this gap by only checking that both methods return the same transcript value, not the cryptographic relationship: [5](#0-4) 

Notably, the batch encryption layer DOES implement this verification correctly: [6](#0-5) 

This proves the verification is both necessary and feasible, yet it's missing from the core PVSS layer that the DKG directly uses.

## Impact Explanation

This breaks the **Cryptographic Correctness** invariant. Without self-verification, validators cannot detect:

1. **BSGS Discrete Log Bugs**: If the baby-step giant-step algorithm fails or returns incorrect results, validators accept corrupted shares
2. **Numerical Errors**: Chunk reconstruction errors propagate undetected  
3. **Implementation Vulnerabilities**: Any bug in the decryption path cannot be caught by validators
4. **Malicious Transcript Edge Cases**: While probabilistic verification should catch most issues, edge cases with the randomness beacon or transcript aggregation could pass verification but decrypt incorrectly for specific validators

The impact is **Medium to High severity**:
- Validators using incorrect secret shares could cause DKG protocol failure
- Corrupted shares affect randomness beacon generation, compromising on-chain randomness
- No recovery mechanism exists once corrupted shares are accepted
- Affects consensus safety during epoch transitions

## Likelihood Explanation

**Likelihood: Medium**

The missing verification becomes exploitable when:
- Implementation bugs exist in BSGS discrete log (complex algorithm prone to edge cases)
- Chunk reconstruction has numerical errors (dealing with field arithmetic)
- Transcript aggregation introduces inconsistencies that pass probabilistic checks
- Future cryptographic optimizations introduce subtle bugs

While the transcript verification is strong, defense-in-depth requires validators to self-verify their shares. The absence of this check means any single bug in the decryption path becomes undetectable and exploitable.

## Recommendation

Add cryptographic verification to `decrypt_own_share` methods in all PVSS implementations:

```rust
fn decrypt_own_share(
    &self,
    sc: &Self::SecretSharingConfig,
    player: &Player,
    dk: &Self::DecryptPrivKey,
    pp: &Self::PublicParameters,
) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
    // Existing decryption logic...
    let sk_shares = /* ... */;
    let pk_shares = self.get_public_key_share(sc, player);
    
    // NEW: Verify consistency for each share
    let g2_generator = E::G2Affine::generator();
    for (sk, pk) in sk_shares.iter().zip(pk_shares.iter()) {
        let computed_pk = g2_generator.mul(sk.0).into_affine();
        if computed_pk != pk.as_g2() {
            return Err(anyhow::anyhow!(
                "Decrypted secret share does not match public commitment"
            ));
        }
    }
    
    (sk_shares, pk_shares)
}
```

Change the return type to `Result<(Self::DealtSecretKeyShare, Self::DealtPubKeyShare), anyhow::Error>` to propagate verification failures.

## Proof of Concept

```rust
#[test]
fn test_missing_share_verification() {
    use aptos_dkg::pvss::chunky;
    use ark_bn254::Bn254;
    
    // Setup DKG with test configuration
    let mut rng = thread_rng();
    let wc = WeightedConfig::new(3, vec![1, 1, 1, 1]).unwrap();
    let pp = PublicParameters::<Bn254>::with_max_num_shares(4);
    
    // Generate keys and deal a transcript
    let dks: Vec<_> = (0..4).map(|_| DecryptPrivKey::generate(&mut rng)).collect();
    let eks: Vec<_> = dks.iter().map(|dk| dk.to(&pp.pp_elgamal)).collect();
    
    let trx = chunky::UnsignedWeightedTranscript::<Bn254>::deal(
        &wc, &pp, &ssk, &spk, &eks, &secret, &NoAux, &Player { id: 0 }, &mut rng
    );
    
    // Decrypt shares for player 0
    let (sk_share, pk_share) = trx.decrypt_own_share(
        &wc,
        &Player { id: 0 },
        &dks[0],
        &pp
    );
    
    // VULNERABILITY: No verification that sk_share corresponds to pk_share
    // Validators have no way to check this relationship
    // If BSGS returned wrong value or chunks corrupted, it goes undetected
    
    // Manual verification (should be built-in):
    let g2_gen = ark_bn254::G2Affine::generator();
    for (sk, pk) in sk_share.iter().zip(pk_share.iter()) {
        let computed_pk = (g2_gen * sk.0).into_affine();
        assert_eq!(computed_pk, pk.as_g2(), 
            "Share verification failed - implementation bug detected!");
    }
}
```

This test demonstrates that validators must manually verify share consistency, and any implementation bug in decryption would go undetected without this check.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/keys.rs (L125-129)
```rust
// TODO: maybe make these actual structs
#[allow(type_alias_bounds)]
pub type DealtSecretKey<F: PrimeField> = Scalar<F>;
#[allow(type_alias_bounds)]
pub type DealtSecretKeyShare<F: PrimeField> = Scalar<F>;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L318-380)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);

        let Cs = &self.Cs[player.id];

        // TODO: put an assert here saying that len(Cs) = weight

        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();

        if let Some(first_key) = ephemeral_keys.first() {
            debug_assert_eq!(
                first_key.len(),
                Cs[0].len(),
                "Number of ephemeral keys does not match the number of ciphertext chunks"
            );
        }

        let mut sk_shares: Vec<Scalar<E::ScalarField>> = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();

            let dealt_chunked_secret_key_share = bsgs::dlog_vec(
                pp.pp_elgamal.G.into_group(),
                &dealt_encrypted_secret_key_share_chunks,
                &pp.table,
                pp.get_dlog_range_bound(),
            )
            .expect("BSGS dlog failed");

            let dealt_chunked_secret_key_share_fr: Vec<E::ScalarField> =
                dealt_chunked_secret_key_share
                    .iter()
                    .map(|&x| E::ScalarField::from(x))
                    .collect();

            let dealt_secret_key_share =
                chunks::le_chunks_to_scalar(pp.ell, &dealt_chunked_secret_key_share_fr);

            sk_shares.push(Scalar(dealt_secret_key_share));
        }

        (
            sk_shares, pk_shares, // TODO: review this formalism... why do we need this here?
        )
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L570-605)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let Cs = &self.subtrs.Cs[player.id];
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));

        if !Cs.is_empty() {
            if let Some(first_key) = self.subtrs.Rs.first() {
                debug_assert_eq!(
                    first_key.len(),
                    Cs[0].len(),
                    "Number of ephemeral keys does not match the number of ciphertext chunks"
                );
            }
        }

        let pk_shares = self.get_public_key_share(sc, player);

        let sk_shares: Vec<_> = decrypt_chunked_scalars(
            &Cs,
            &self.subtrs.Rs,
            &dk.dk,
            &pp.pp_elgamal,
            &pp.table,
            pp.ell,
        );

        (
            Scalar::vec_from_inner(sk_shares),
            pk_shares, // TODO: review this formalism... why do we need this here?
        )
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L422-467)
```rust
    fn decrypt_secret_share_from_transcript(
        pub_params: &Self::PublicParams,
        trx: &Self::Transcript,
        player_idx: u64,
        dk: &Self::NewValidatorDecryptKey,
    ) -> anyhow::Result<(Self::DealtSecretShare, Self::DealtPubKeyShare)> {
        let (sk, pk) = trx.main.decrypt_own_share(
            &pub_params.pvss_config.wconfig,
            &Player {
                id: player_idx as usize,
            },
            dk,
            &pub_params.pvss_config.pp,
        );
        assert_eq!(
            trx.fast.is_some(),
            pub_params.pvss_config.fast_wconfig.is_some()
        );
        let (fast_sk, fast_pk) = match (
            trx.fast.as_ref(),
            pub_params.pvss_config.fast_wconfig.as_ref(),
        ) {
            (Some(fast_trx), Some(fast_wconfig)) => {
                let (fast_sk, fast_pk) = fast_trx.decrypt_own_share(
                    fast_wconfig,
                    &Player {
                        id: player_idx as usize,
                    },
                    dk,
                    &pub_params.pvss_config.pp,
                );
                (Some(fast_sk), Some(fast_pk))
            },
            _ => (None, None),
        };
        Ok((
            DealtSecretKeyShares {
                main: sk,
                fast: fast_sk,
            },
            DealtPubKeyShares {
                main: pk,
                fast: fast_pk,
            },
        ))
    }
```

**File:** crates/aptos-dkg/src/pvss/test_utils.rs (L336-348)
```rust
    let players_and_shares = sc
        .get_random_eligible_subset_of_players(rng)
        .into_iter()
        .map(|p| {
            let (sk, pk) = trx.decrypt_own_share(sc, &p, &dks[p.get_id()], pp);

            assert_eq!(pk, trx.get_public_key_share(sc, &p));

            (p, sk)
        })
        .collect::<Vec<(Player, T::DealtSecretKeyShare)>>();

    T::DealtSecretKey::reconstruct(sc, &players_and_shares).unwrap()
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L275-283)
```rust
        vks[msk_share.weighted_player.get_id()]
            .vks_g2
            .iter()
            .zip(msk_share.shamir_share_evals.clone())
            .try_for_each(|(vk_raw, msk_share_raw)| {
                (G2Projective::from(*vk_raw) == G2Affine::generator() * msk_share_raw)
                    .then_some(())
                    .ok_or(BatchEncryptionError::VKMSKMismatchError)
            })?;
```
