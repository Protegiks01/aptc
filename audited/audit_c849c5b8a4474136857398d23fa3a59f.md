# Audit Report

## Title
JWT Authentication Bypass via Bypasser Fallthrough in Faucet Service

## Summary
The `AuthTokenBypasser.request_can_bypass()` function returns `Ok(false)` when the `X_IS_JWT_HEADER` is present, allowing requests claiming to use JWT authentication to fall through to other bypassers. If a subsequent bypasser (e.g., `IpAllowlistBypasser`) grants bypass, JWT validation is completely skipped, allowing unauthorized access. [1](#0-0) 

## Finding Description

The faucet service supports two authentication modes: static auth tokens and Firebase JWT tokens. The `X_IS_JWT_HEADER` header differentiates between these modes. [2](#0-1) 

When a request includes `X_IS_JWT_HEADER`, it signals JWT authentication mode. The `AuthTokenBypasser` correctly skips auth token validation by returning `Ok(false)`. [3](#0-2) 

However, in the bypasser evaluation loop, returning `Ok(false)` means "this bypasser doesn't grant bypass, continue to next bypasser." [4](#0-3) 

**Attack Scenario:**
1. Attacker sends request with `X_IS_JWT_HEADER` set (claiming JWT auth)
2. Request includes invalid/missing JWT token in Authorization header
3. Request originates from IP in `IpAllowlistBypasser`
4. `AuthTokenBypasser` returns `Ok(false)` - doesn't grant bypass, but continues
5. `IpAllowlistBypasser` returns `Ok(true)` - grants bypass based on IP
6. Request bypasses ALL checkers, including JWT validation in `RedisRatelimitChecker` [5](#0-4) 
7. Attacker receives funds without valid JWT authentication

The JWT validation only occurs in checkers (via `FirebaseJwtVerifier.validate_jwt()`), never in bypassers. [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This violates the authentication invariant that JWT mode requires valid, verified JWT tokens. An attacker on an allowed IP can:
- Bypass JWT authentication completely by setting `X_IS_JWT_HEADER` with invalid/missing JWT
- Bypass JWT-based rate limiting configured in `RedisRatelimitChecker`
- Access faucet funds without proper authentication

While this falls under "Limited funds loss or manipulation" (Medium severity per bug bounty), the impact is constrained because:
- Only affects users already on IP allowlist (somewhat trusted)
- Applies to testnet/devnet faucet tokens (no mainnet value)
- Doesn't affect blockchain consensus, execution, or state

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific conditions:
- Faucet configured with multiple bypassers (`AuthTokenBypasser` + `IpAllowlistBypasser`)
- Attacker must originate from an IP in the allowlist
- Attacker must know to set `X_IS_JWT_HEADER` to trigger the bypass

However, if these conditions exist, exploitation is trivial - just set one HTTP header with an invalid JWT. No sophisticated attack techniques required.

## Recommendation

Change `AuthTokenBypasser` to return an error when `X_IS_JWT_HEADER` is present, preventing JWT requests from being evaluated by other bypassers:

```rust
async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
    // JWT requests should not be handled by AuthTokenBypasser
    if data.headers.contains_key(X_IS_JWT_HEADER) {
        return Err(anyhow::anyhow!(
            "Requests with {} header must use JWT authentication flow, not auth token bypass",
            X_IS_JWT_HEADER
        ));
    }
    
    // ... rest of auth token validation
}
```

This ensures JWT authentication requests are handled exclusively through the checker validation flow where `FirebaseJwtVerifier` properly validates tokens.

## Proof of Concept

```bash
# Setup: Faucet configured with AuthTokenBypasser and IpAllowlistBypasser
# Assumption: Attacker's IP (e.g., 192.168.1.100) is in the allowlist

# Exploit: Request with JWT header but invalid/missing token
curl -X POST https://faucet.devnet.aptoslabs.com/fund \
  -H "X-Is-Jwt: true" \
  -H "Authorization: Bearer invalid_or_missing_token" \
  -H "Content-Type: application/json" \
  -d '{
    "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    "amount": 100000000
  }'

# Expected (current behavior): Request succeeds if IP is in allowlist
# - AuthTokenBypasser returns Ok(false) due to X_IS_JWT_HEADER
# - IpAllowlistBypasser returns Ok(true) for allowed IP
# - All checkers bypassed, including JWT validation
# - Funds distributed without valid JWT

# Expected (after fix): Request fails with BypasserError
# - AuthTokenBypasser returns error for JWT requests
# - Request rejected before reaching IpAllowlistBypasser
```

**Notes:**
- This vulnerability is specific to the faucet service, not core blockchain components
- Does not affect consensus, Move VM, state management, governance, or staking systems
- Primary impact is on faucet authentication integrity, not blockchain security invariants

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L32-36)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L11-11)
```rust
pub const X_IS_JWT_HEADER: &str = "x-is-jwt";
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L41-64)
```rust
    pub async fn validate_jwt(&self, headers: Arc<HeaderMap>) -> Result<String, AptosTapError> {
        let auth_token = jwt_sub(headers)?;

        let verify = self.jwt_verifier.verify::<JwtClaims>(&auth_token);
        let token_data = match verify.await {
            Some(token_data) => token_data,
            None => {
                return Err(AptosTapError::new(
                    "Failed to verify JWT token".to_string(),
                    AptosTapErrorCode::AuthTokenInvalid,
                ));
            },
        };
        let claims = token_data.claims;

        if !claims.email_verified {
            return Err(AptosTapError::new(
                "The JWT token is not verified".to_string(),
                AptosTapErrorCode::AuthTokenInvalid,
            ));
        }

        Ok(claims.sub)
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```
