# Audit Report

## Title
Module Verification Complexity Not Gas-Metered - Validator DoS via Expensive Bytecode Verification

## Summary
Module publishing transactions charge gas based only on bytecode size, not verification complexity. Attackers can craft maximally complex modules that consume significant validator CPU time during bytecode verification while paying minimal gas, enabling a validator slowdown attack.

## Finding Description

When a transaction publishes Move modules, the gas charged is determined solely by module size, not the computational cost of verifying the bytecode. This creates a discrepancy where attackers can submit complex-to-verify modules that impose disproportionate costs on validators.

**Gas Charging Flow:**

1. Initial gas charge in `native_request_publish` charges based on size only: [1](#0-0) 

2. During `resolve_pending_code_publish_and_finish_user_session`, additional gas is charged for module dependencies based on size: [2](#0-1) 

3. A simple complexity check exists, but it's linear based on code length with a TODO to make it configurable: [3](#0-2) 

**Verification Without Gas Metering:**

The actual bytecode verification happens in `StagingModuleStorage::create_with_compat_config`, called during module publishing: [4](#0-3) 

This triggers comprehensive bytecode verification including multiple expensive passes: [5](#0-4) 

The verification includes bounds checking, feature verification, limits verification, duplication checking, signature verification, instruction consistency, control flow analysis, type checking, and more: [6](#0-5) 

**Verification Metering vs Gas Metering:**

Bytecode verification uses internal metering with production limits of 80,000,000 units per function and module: [7](#0-6) 

However, this internal meter only prevents infinite loopsâ€”it does NOT charge gas to the transaction. The meter enforces hard limits but verification work itself is free: [8](#0-7) 

**Attack Scenario:**

1. Attacker crafts modules with maximum verification complexity (deep type nesting, complex control flow, maximum loop depth)
2. Modules stay just under the 80M unit verification limits
3. Attacker publishes multiple such modules across transactions
4. Each validator independently verifies these modules during block execution
5. Verification consumes significant CPU time (potentially seconds per module)
6. Gas cost only reflects bytecode size (~KB), not verification work (CPU seconds)
7. Result: Disproportionate validator burden causing consensus delays and reduced network throughput

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The verification work escapes gas metering.

## Impact Explanation

**High Severity - Validator Node Slowdowns** (per Aptos bug bounty criteria)

This vulnerability enables a resource exhaustion attack against validators:

- **Consensus Impact**: Slow block execution can delay block proposal and voting, reducing network throughput
- **Validator DoS**: Sustained attacks could cause validator nodes to fall behind, affecting network health
- **Asymmetric Cost**: Attacker pays minimal gas (based on size) while imposing significant CPU costs on ALL validators
- **Network-Wide Effect**: Every validator must independently verify each complex module during block execution

The attack does not cause fund loss or consensus safety violations, but directly impacts validator performance and network availability, matching the "Validator node slowdowns" category explicitly listed as High Severity.

## Likelihood Explanation

**High Likelihood:**

- **No Special Access Required**: Any user can submit module publishing transactions
- **Knowledge Barrier**: Moderate - requires understanding of bytecode verifier internals to maximize complexity
- **Cost to Attacker**: Low - gas costs are based on size, not verification complexity
- **Detection Difficulty**: Complex modules appear legitimate; distinguishing malicious complexity from valid code is non-trivial
- **Persistence**: Cached verification (by hash) helps, but unique complex modules force re-verification
- **Amplification**: One transaction forces ALL validators to perform expensive verification

The TODO comment suggests developers recognize complexity checking needs improvement, but the fundamental issue of verification cost not being gas-metered remains unaddressed.

## Recommendation

**Primary Solution: Convert Verification Metering to Gas Charges**

1. Track verification meter consumption during `verify_module_with_config`
2. Convert meter units to gas units using a configurable conversion factor
3. Charge gas proportional to verification complexity in addition to size-based charges

**Implementation Approach:**

```rust
// In aptos_vm.rs, after module verification:
let verification_units = /* extract from verifier */;
let verification_gas = convert_verification_units_to_gas(verification_units);
gas_meter.charge_verification_gas(verification_gas)?;
```

**Secondary Defenses:**

1. **Strengthen Complexity Limits**: Replace the simple linear complexity check with limits based on verification meter consumption
2. **Global Verification Cache**: Enhance the existing module hash cache to be persistent across blocks (already partially implemented)
3. **Rate Limiting**: Limit the number of new module publications per block or per account
4. **Stricter Verifier Limits**: Reduce `max_per_fun_meter_units` and `max_per_mod_meter_units` from 80M to more conservative values

## Proof of Concept

A complete PoC would require crafting a Move module that maximizes verification complexity. Key complexity vectors include:

```move
module attacker::complex_module {
    // Deep type nesting (up to max_type_nodes limit of 128/256)
    struct Nested<T> has drop { value: T }
    struct VeryNested has drop {
        n: Nested<Nested<Nested<Nested<Nested<Nested<Nested<Nested<
           Nested<Nested<Nested<Nested<Nested<Nested<Nested<u64>>>>>>>>>>>>>>>
    }
    
    // Maximum loop depth (5 in production config)
    public fun complex_control_flow() {
        let i = 0;
        while (i < 10) {
            let j = 0;
            while (j < 10) {
                let k = 0;
                while (k < 10) {
                    let l = 0;
                    while (l < 10) {
                        let m = 0;
                        while (m < 10) {
                            // Maximum nesting reached
                            m = m + 1;
                        };
                        l = l + 1;
                    };
                    k = k + 1;
                };
                j = j + 1;
            };
            i = i + 1;
        };
    }
    
    // Maximum function parameters, complex generic instantiations
    // Many functions with complex signatures
    // ... (repeat for max_function_definitions limit)
}
```

**Testing Steps:**

1. Compile the complex module and measure its size
2. Publish via transaction and record gas consumed
3. Instrument the verifier to measure actual CPU time spent
4. Calculate the ratio: (CPU microseconds) / (gas units)
5. Compare against normal modules to demonstrate disproportion

Expected result: Complex module consumes 100-1000x more CPU time per gas unit than a simple module of equivalent size.

## Notes

The vulnerability stems from a fundamental design choice where gas metering covers execution costs but not verification costs. The existing verification meter prevents DoS via infinite loops during verification, but doesn't translate that work into gas charges. This creates an asymmetric cost structure exploitable for validator DoS.

The caching mechanism (`VERIFIED_MODULES_CACHE`) provides partial mitigation by preventing re-verification of identical modules, but unique complex modules still impose full verification costs on all validators during block execution.

### Citations

**File:** aptos-move/framework/src/natives/code.rs (L292-300)
```rust
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1525-1543)
```rust
            // Charge all modules in the bundle that is about to be published.
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;

                // In case of lazy loading: add all modules in a bundle as visited to avoid double
                // charging during module initialization.
                if self.features().is_lazy_loading_enabled() {
                    traversal_context.visit_if_not_special_address(addr, name);
                }
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1558)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L97-102)
```rust
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L140-163)
```rust
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** third_party/move/move-bytecode-verifier/src/meter.rs (L91-106)
```rust
    fn add(&mut self, units: u128) -> PartialVMResult<()> {
        if let Some(max) = self.max {
            let new_units = self.units.saturating_add(units);
            if new_units > max {
                // TODO: change to a new status PROGRAM_TOO_COMPLEX once this is rolled out. For
                // now we use an existing code to avoid breaking changes on potential rollback.
                return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(format!(
                        "program too complex (in `{}` with `{} current + {} new > {} max`)",
                        self.name, self.units, units, max
                    )));
            }
            self.units = new_units;
        }
        Ok(())
    }
```
