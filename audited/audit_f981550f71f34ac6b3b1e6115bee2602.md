# Audit Report

## Title
REST Discovery Server Authentication Bypass Enables Malicious Peer List Injection

## Summary
The REST discovery mechanism in Aptos lacks proper server authentication and cryptographic verification of validator set data. An attacker who can intercept or control the REST endpoint can inject arbitrary peer lists, potentially leading to eclipse attacks and network isolation of nodes using REST discovery.

## Finding Description

The `setup_discovery()` function in the network builder creates a REST-based discovery listener that periodically fetches the validator set from a configured REST endpoint. [1](#0-0) 

The REST discovery configuration accepts any URL without scheme validation: [2](#0-1) 

When REST discovery is initialized, it creates a `RestStream` that uses the standard `aptos_rest_client::Client` with the configured URL: [3](#0-2) 

The REST client is built using the default reqwest HTTP client without any additional authentication: [4](#0-3) 

The `RestStream` periodically fetches the `ValidatorSet` resource and directly extracts peer information without any cryptographic verification: [5](#0-4) 

The REST API response contains only metadata headers but no state proofs or cryptographic signatures: [6](#0-5) 

**Attack Vectors:**

1. **HTTP Configuration**: If the administrator configures an HTTP URL (not HTTPS), any network-level attacker can perform a man-in-the-middle attack and inject arbitrary validator sets with zero authentication.

2. **HTTPS with TLS Compromise**: Even with HTTPS, the system relies solely on standard TLS certificate verification. Attackers who can compromise a certificate authority, perform DNS hijacking with a valid certificate, or exploit other TLS vulnerabilities can inject malicious peer lists.

3. **Malicious/Compromised Endpoint**: If the configured REST endpoint itself is malicious or compromised, it can serve fake validator information that will be blindly trusted.

4. **No Cryptographic Verification**: Unlike on-chain discovery which reads from authenticated blockchain state, REST discovery has no cryptographic proof that the validator set data is legitimate. The data could be completely fabricated.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: The network discovery mechanism is a critical component of the P2P layer. Compromising peer discovery violates the fundamental network security invariant that nodes should only connect to legitimate peers.

2. **Eclipse Attack Vector**: An attacker who successfully injects malicious peer lists can eclipse vulnerable nodes, isolating them from the real network. Eclipsed nodes:
   - Cannot participate in consensus correctly
   - May accept invalid transactions
   - Cannot sync to the correct blockchain state
   - Become vulnerable to double-spend attacks

3. **Validator Node Impact**: If validator fullnodes use REST discovery and are eclipsed, they cannot relay accurate information to validators, potentially causing:
   - Validator node slowdowns (High severity per bug bounty)
   - Degraded network performance
   - Consensus liveness issues

4. **Network Partition Risk**: Multiple nodes using the same compromised REST endpoint could be partitioned from the legitimate network, creating a split-brain scenario.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The likelihood is elevated because:

1. **Common Deployment Scenario**: REST discovery is specifically designed for fullnodes that need to bootstrap or catch up when genesis is far behind. This is a common operational scenario documented in the code comments.

2. **Configuration Flexibility**: The system accepts any URL scheme without validation, making HTTP misconfiguration likely in development/staging environments that may accidentally persist to production.

3. **No Warning/Validation**: There are no runtime warnings or configuration validation checks that alert operators to the security implications of their REST discovery configuration.

4. **Trust Assumption**: The code assumes the configured REST endpoint is trustworthy, but provides no mechanism to verify this assumption.

5. **Low Attacker Complexity**: For HTTP configurations, standard network-level MITM attacks require only network position. For HTTPS, while more difficult, TLS compromise attacks are well-documented.

## Recommendation

Implement multiple security layers for REST discovery:

**1. Enforce HTTPS and Add Scheme Validation:**

Add validation in the `RestDiscovery` configuration:

```rust
// In config/src/config/network_config.rs
impl RestDiscovery {
    pub fn validate(&self) -> Result<(), String> {
        if self.url.scheme() != "https" {
            return Err(format!(
                "REST discovery URL must use HTTPS scheme for security. Got: {}",
                self.url.scheme()
            ));
        }
        Ok(())
    }
}
```

**2. Add Cryptographic Verification:**

The most robust solution is to verify the validator set data against on-chain state:

```rust
// In network/discovery/src/rest.rs
impl RestStream {
    fn verify_validator_set(&self, validator_set: &ValidatorSet, ledger_version: u64) -> Result<(), DiscoveryError> {
        // Option 1: Require state proof from REST API
        // Verify the state proof against known ledger info
        
        // Option 2: Cross-check with local blockchain state
        // Compare against the validator set at the reported ledger version
        
        // Option 3: Require the validator set to be signed by 2f+1 validators
        // Verify aggregated signatures before accepting
    }
}
```

**3. Add Certificate Pinning (Optional Defense-in-Depth):**

For known endpoints (e.g., official Aptos Labs infrastructure), implement certificate pinning:

```rust
// In crates/aptos-rest-client/src/client_builder.rs
pub fn with_certificate_pinning(mut self, expected_cert_hash: String) -> Self {
    // Add custom certificate validation
    self.reqwest_builder = self.reqwest_builder.add_root_certificate(/* pinned cert */);
    self
}
```

**4. Add Runtime Warnings:**

Log warnings when REST discovery is used without additional security measures:

```rust
warn!(
    "REST discovery is configured without cryptographic verification. \
     The validator set data from {} will be trusted without proof. \
     Ensure this endpoint is secure and authenticated.",
    rest_url
);
```

## Proof of Concept

**Scenario:** An attacker performs a MITM attack on a node configured with HTTP REST discovery.

**Setup Steps:**

1. Configure a fullnode with REST discovery using an HTTP endpoint:
```yaml
full_node_networks:
  - discovery_method:
      rest:
        url: "http://malicious-endpoint.example.com"
        interval_secs: 1
```

2. Attacker intercepts HTTP traffic and responds with malicious ValidatorSet containing only attacker-controlled peers:

```rust
// Attacker's malicious REST API response
{
  "type": "0x1::stake::ValidatorSet",
  "data": {
    "active_validators": [
      {
        "addr": "0xAttackerAddress1",
        "config": {
          "consensus_pubkey": "...",
          "validator_network_addresses": ["attacker-node-1:6180"],
          "fullnode_network_addresses": ["attacker-node-1:6182"],
          // ... more attacker-controlled validators
        }
      }
    ]
  }
}
```

3. The victim node's `RestStream::poll_next()` fetches this data at line 48: [7](#0-6) 

4. The malicious validator set is extracted without verification at line 54-58: [8](#0-7) 

5. The malicious peer list is sent to the connectivity manager which will attempt to connect to attacker-controlled nodes only.

6. The victim node is now eclipsed from the legitimate network.

**Verification:**

To verify this vulnerability exists:
1. Deploy a fullnode with HTTP REST discovery pointing to a controlled endpoint
2. Serve a fabricated ValidatorSet from that endpoint
3. Monitor the fullnode's peer connections using `aptos node show-peers`
4. Observe that the node only connects to the injected malicious peers

## Notes

- The on-chain discovery method (`DiscoveryMethod::Onchain`) does not have this vulnerability because it reads validator set data from authenticated blockchain state
- The file discovery method (`DiscoveryMethod::File`) has similar trust issues but is typically only used in controlled test environments
- This vulnerability requires either network position (for HTTP) or TLS compromise (for HTTPS), but the lack of any cryptographic verification significantly lowers the security bar
- The impact is particularly severe for nodes that rely exclusively on REST discovery without seed peers or on-chain discovery as fallback

### Citations

**File:** network/builder/src/builder.rs (L347-395)
```rust
    fn setup_discovery(
        &mut self,
        config: &NetworkConfig,
        mut reconfig_subscription_service: Option<&mut EventSubscriptionService>,
    ) {
        let conn_mgr_reqs_tx = self
            .conn_mgr_reqs_tx()
            .expect("ConnectivityManager must exist");
        for discovery_method in config.discovery_methods() {
            let listener = match discovery_method {
                DiscoveryMethod::Onchain => {
                    let reconfig_events = reconfig_subscription_service
                        .as_mut()
                        .expect("An event subscription service is required for on-chain discovery!")
                        .subscribe_to_reconfigurations()
                        .expect("On-chain discovery is unable to subscribe to reconfigurations!");
                    let identity_key = config.identity_key();
                    let pubkey = identity_key.public_key();
                    DiscoveryChangeListener::validator_set(
                        self.network_context,
                        conn_mgr_reqs_tx.clone(),
                        pubkey,
                        reconfig_events,
                    )
                },
                DiscoveryMethod::File(file_discovery) => DiscoveryChangeListener::file(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    file_discovery.path.as_path(),
                    Duration::from_secs(file_discovery.interval_secs),
                    self.time_service.clone(),
                ),
                DiscoveryMethod::Rest(rest_discovery) => DiscoveryChangeListener::rest(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    rest_discovery.url.clone(),
                    Duration::from_secs(rest_discovery.interval_secs),
                    self.time_service.clone(),
                ),
                DiscoveryMethod::None => {
                    continue;
                },
            };
            self.discovery_listeners
                .as_mut()
                .expect("Can only add listeners before starting")
                .push(listener);
        }
    }
```

**File:** config/src/config/network_config.rs (L359-364)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")]
pub struct RestDiscovery {
    pub url: url::Url,
    pub interval_secs: u64,
}
```

**File:** network/discovery/src/rest.rs (L24-36)
```rust
impl RestStream {
    pub(crate) fn new(
        network_context: NetworkContext,
        rest_url: url::Url,
        interval_duration: Duration,
        time_service: TimeService,
    ) -> Self {
        RestStream {
            network_context,
            rest_client: aptos_rest_client::Client::new(rest_url),
            interval: Box::pin(time_service.interval(interval_duration)),
        }
    }
```

**File:** network/discovery/src/rest.rs (L42-68)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
            Err(err) => {
                info!(
                    "Failed to retrieve validator set by REST discovery {:?}",
                    err
                );
                Some(Err(DiscoveryError::Rest(err)))
            },
        })
    }
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```

**File:** crates/aptos-rest-client/src/state.rs (L10-102)
```rust
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct State {
    pub chain_id: u8,
    pub epoch: u64,
    pub version: u64,
    pub timestamp_usecs: u64,
    pub oldest_ledger_version: u64,
    pub oldest_block_height: u64,
    pub block_height: u64,
    pub cursor: Option<String>,
}

impl State {
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```
