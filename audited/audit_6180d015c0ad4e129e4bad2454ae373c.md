# Audit Report

## Title
FederatedKeyless JWK Address Manipulation Enables Transaction Filter Bypass

## Summary
The `matches_any_public_key_address()` function in transaction filters incorrectly treats the `jwk_addr` field of `FederatedKeylessPublicKey` as a transaction participant address, when it is actually a configuration pointer to JWK storage. This semantic error allows attackers to bypass whitelist filters, breaking access control invariants in the optional transaction filter system. [1](#0-0) 

## Finding Description

The transaction filter system uses `TransactionMatcher::AccountAddress` to match transactions involving specific addresses (sender, module address, multisig participants, etc.). The matching logic chains through multiple functions to check if an address appears in any transaction participant role. [2](#0-1) 

For `FederatedKeyless` public keys, the filter checks if `jwk_addr` equals the target address: [3](#0-2) 

However, `jwk_addr` is NOT a participant address - it merely indicates where JWKs are stored on-chain for signature verification: [4](#0-3) [5](#0-4) 

The actual sender address is derived from the **entire** `FederatedKeylessPublicKey` structure (including both `jwk_addr` and the inner `KeylessPublicKey`) through the authentication key derivation process: [6](#0-5) [7](#0-6) 

**Attack Scenario - Whitelist Bypass:**

1. A node configures a filter: `Allow(vec![TransactionMatcher::AccountAddress(0xWHITELIST)])`
2. Attacker creates `FederatedKeylessPublicKey { jwk_addr: 0xWHITELIST, pk: <attacker's KeylessPublicKey> }`
3. Attacker's actual address = `hash(BCS(FederatedKeylessPublicKey) || scheme_id)` â‰  0xWHITELIST
4. Filter sees `jwk_addr == 0xWHITELIST` and allows the transaction
5. Transaction from attacker's address (NOT 0xWHITELIST) bypasses the whitelist

For the attack to succeed:
- 0xWHITELIST must have `FederatedJWKs` resource published on-chain
- Those JWKs must correspond to an OIDC provider the attacker can authenticate with (e.g., Google)

## Impact Explanation

**Severity: Medium** (up to $10,000 - Limited Protocol Violations)

This vulnerability breaks access control in the **optional** transaction filter system. Transaction filters are used in mempool and consensus for optional access control: [8](#0-7) [9](#0-8) 

**Impacts:**
- **Whitelist Bypass**: Attackers can set `jwk_addr` to match whitelisted addresses, bypassing filters
- **False Denials**: Legitimate users whose `jwk_addr` matches denied addresses will be incorrectly blocked
- **Rate Limit Evasion**: If filters are used for rate limiting, attackers can evade them

This constitutes a "Limited Protocol Violation" rather than a "Significant Protocol Violation" because:
- Transaction filters are **optional configuration**, not core protocol
- No impact on consensus correctness, fund security, or network liveness
- Only affects nodes that choose to enable transaction filters
- Does not meet HIGH severity criteria (no validator slowdowns, no API crashes)

## Likelihood Explanation

**Likelihood: Medium**

The attack is feasible in realistic scenarios:
- Attacker only needs an OIDC identity (Google account, GitHub account, etc.) - easily obtainable
- Target address must have FederatedJWKs published for public providers - possible for addresses using federated keyless authentication
- Creating the malicious FederatedKeylessPublicKey is trivial
- No special privileges required

The main limiting factor is that not all addresses will have FederatedJWKs published, but for addresses deliberately configured for federated authentication with public providers, exploitation is straightforward.

## Recommendation

Modify `matches_any_public_key_address()` to return `false` for `FederatedKeyless` keys, similar to other key types, since the `jwk_addr` is not the sender address:

```rust
fn matches_any_public_key_address(any_public_key: &AnyPublicKey, address: &AccountAddress) -> bool {
    match any_public_key {
        AnyPublicKey::Ed25519 { .. }
        | AnyPublicKey::Secp256k1Ecdsa { .. }
        | AnyPublicKey::Secp256r1Ecdsa { .. }
        | AnyPublicKey::SlhDsa_Sha2_128s { .. }
        | AnyPublicKey::Keyless { .. }
        | AnyPublicKey::FederatedKeyless { .. } => false, // Changed from checking jwk_addr
    }
}
```

Alternatively, if there's a legitimate need to filter by `jwk_addr`, introduce a separate matcher type (e.g., `TransactionMatcher::FederatedKeylessJWKAddress`) to make the distinction explicit.

## Proof of Concept

**Note:** No executable PoC was provided in the original report. A complete PoC would require:
1. Creating a test with a FederatedKeylessPublicKey where jwk_addr matches a whitelisted address
2. Demonstrating the transaction filter allows it despite the sender address being different
3. Showing that the derived sender address is computed from the entire structure via `AuthenticationKey::any_key()`

## Notes

This is a valid semantic error that breaks the intended access control behavior of transaction filters. However, the severity is classified as **MEDIUM** rather than HIGH because transaction filters are optional infrastructure configuration, not core protocol. The vulnerability does not affect consensus, cause fund loss, or meet the criteria for HIGH severity issues (validator slowdowns, API crashes). It represents a "Limited Protocol Violation" affecting optional access control mechanisms.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L312-325)
```rust
fn matches_any_public_key_address(any_public_key: &AnyPublicKey, address: &AccountAddress) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match any_public_key {
        AnyPublicKey::Ed25519 { .. }
        | AnyPublicKey::Secp256k1Ecdsa { .. }
        | AnyPublicKey::Secp256r1Ecdsa { .. }
        | AnyPublicKey::SlhDsa_Sha2_128s { .. }
        | AnyPublicKey::Keyless { .. } => false,
        AnyPublicKey::FederatedKeyless { public_key } => {
            // Check if the public key's JWK address matches the given address
            public_key.jwk_addr == *address
        },
    }
}
```

**File:** types/src/keyless/mod.rs (L374-379)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct FederatedKeylessPublicKey {
    pub jwk_addr: AccountAddress,
    pub pk: KeylessPublicKey,
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L244-254)
```rust
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
```

**File:** types/src/transaction/authenticator.rs (L884-887)
```rust
    pub fn from_preimage(mut public_key_bytes: Vec<u8>, scheme: Scheme) -> AuthenticationKey {
        public_key_bytes.push(scheme as u8);
        AuthenticationKey::new(*HashValue::sha3_256_of(&public_key_bytes).as_ref())
    }
```

**File:** types/src/transaction/authenticator.rs (L924-926)
```rust
    pub fn any_key(public_key: AnyPublicKey) -> AuthenticationKey {
        Self::from_preimage(public_key.to_bytes(), Scheme::SingleKey)
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L318-321)
```rust
    // Filter out any disallowed transactions
    let mut statuses = vec![];
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L17-29)
```rust
pub struct BlockTransactionFilter {
    block_transaction_rules: Vec<BlockTransactionRule>,
}

impl BlockTransactionFilter {
    pub fn new(block_transaction_rules: Vec<BlockTransactionRule>) -> Self {
        Self {
            block_transaction_rules,
        }
    }

    /// Returns true iff the filter allows the transaction in the block
    pub fn allows_transaction(
```
