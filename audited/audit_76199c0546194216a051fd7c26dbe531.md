# Audit Report

## Title
Missing Authorization Check in RequestSecretShare Handler Enables Unauthorized Secret Share Extraction

## Summary

The `RequestSecretShare` message handler does not validate that the requesting peer is a validator in the current epoch's validator set. Any authenticated network peer can request and receive secret shares from validators, violating the security assumptions of the threshold secret sharing scheme used for consensus randomness generation.

## Finding Description

The secret sharing system in Aptos consensus uses threshold cryptography to generate randomness for leader selection and other consensus operations. When validators receive a `RequestSecretShare` message, they should only respond to other validators in the current epoch. However, the implementation fails to perform this authorization check.

**Vulnerability Location:**

The `verify()` method for `RequestSecretShare` messages only checks epoch matching and immediately returns success without sender validation: [1](#0-0) 

The network layer provides sender information in the `IncomingSecretShareRequest` structure, but this field is marked as unused: [2](#0-1) 

In the verification task, the sender information is received but completely ignored: [3](#0-2) 

When handling the request, the validator retrieves and sends back its secret share without any authorization check: [4](#0-3) 

**Attack Path:**

1. Attacker connects to validator network as an authenticated peer (e.g., compromised validator full node, validator from previous epoch, or any peer with valid network credentials)
2. Attacker crafts `RequestSecretShare` message with current epoch and target round metadata
3. Victim validator receives request, deserializes it, calls `verify()` which only checks epoch
4. Validator retrieves secret share via `get_self_share()` 
5. Validator sends share back to attacker without checking if attacker is in validator set
6. Attacker repeats this against multiple validators to collect threshold shares
7. With threshold shares, attacker reconstructs decryption key and compromises randomness

**Broken Invariant:**

This violates the **Cryptographic Correctness** invariant: the threshold secret sharing scheme assumes only authorized validators can access shares, but any authenticated peer can extract them.

The infrastructure for authorization exists - `EpochState` contains a `ValidatorVerifier` with methods like `get_public_key()` and `get_voting_power()` that can check validator membership: [5](#0-4) [6](#0-5) 

However, these validation methods are never invoked for `RequestSecretShare` messages.

## Impact Explanation

**Severity: Critical**

This vulnerability breaks the security assumptions of the threshold secret sharing scheme, which is fundamental to consensus randomness generation. The impact includes:

1. **Randomness Compromise**: Attackers obtaining threshold shares can reconstruct decryption keys and potentially predict or manipulate randomness used for leader selection
2. **Consensus Manipulation**: Compromised randomness enables attacks on leader election, potentially allowing attackers to influence which validators propose blocks
3. **Liveness Attacks**: Manipulation of randomness could be used to cause consensus disruption or denial of service
4. **Cryptographic Security Violation**: Breaks the t-of-n threshold assumption where an attacker needs t shares - instead they can collect shares from any authenticated peer

This qualifies as **Critical Severity** under Aptos bug bounty criteria as it constitutes a "Consensus/Safety violation" and "Significant protocol violation" that undermines the cryptographic foundation of the randomness beacon.

## Likelihood Explanation

**Likelihood: Medium-to-High**

While the attacker requires authenticated network access to validators, several realistic attack vectors exist:

1. **Compromised Validator Full Nodes (VFNs)**: VFNs maintain authenticated connections to validators and could exploit this to extract shares
2. **Former Validators**: Validators from previous epochs may retain network credentials and validator network access
3. **Network-Level Compromises**: Any compromise that grants access to validator network credentials enables this attack
4. **Insider Threats**: Malicious operators with legitimate network access can exploit this

The attack is straightforward to execute once network access is obtained - it requires only sending properly formatted `RequestSecretShare` messages with the correct epoch. No complex cryptographic operations or race conditions are needed.

## Recommendation

Add authorization validation to verify the sender is a validator in the current epoch's validator set before responding to `RequestSecretShare` messages.

**Recommended Fix:**

Modify `SecretShareMessage::verify()` to validate the sender for `RequestShare`:

```rust
impl SecretShareMessage {
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
        sender: Author, // Add sender parameter
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => {
                // Validate sender is in current validator set
                ensure!(
                    epoch_state.verifier.get_public_key(&sender).is_some(),
                    "Sender {} is not a validator in epoch {}",
                    sender,
                    epoch_state.epoch
                );
                Ok(())
            },
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
}
```

Update `verification_task` to pass the sender to `verify()`:

```rust
async fn verification_task(
    epoch_state: Arc<EpochState>,
    mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
    verified_msg_tx: UnboundedSender<SecretShareRpc>,
    config: SecretShareConfig,
    bounded_executor: BoundedExecutor,
) {
    while let Some(dec_msg) = incoming_rpc_request.next().await {
        let tx = verified_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        let config_clone = config.clone();
        let sender = dec_msg.sender; // Extract sender
        bounded_executor
            .spawn(async move {
                match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                    Ok(msg) => {
                        if msg.verify(&epoch_state_clone, &config_clone, sender).is_ok() {
                            let _ = tx.unbounded_send(SecretShareRpc {
                                msg,
                                protocol: dec_msg.protocol,
                                response_sender: dec_msg.response_sender,
                            });
                        }
                    },
                    Err(e) => {
                        warn!("Invalid dec message: {}", e);
                    },
                }
            })
            .await;
    }
}
```

Apply the same fix to the RandGen system's `RequestShare` message handling, which has the identical vulnerability: [7](#0-6) 

## Proof of Concept

```rust
// PoC demonstrating unauthorized secret share extraction
// This test would be added to consensus/src/rand/secret_sharing/tests.rs

#[tokio::test]
async fn test_unauthorized_secret_share_request() {
    use crate::rand::secret_sharing::{
        network_messages::SecretShareMessage,
        types::RequestSecretShare,
    };
    use aptos_types::{
        account_address::AccountAddress,
        secret_sharing::SecretShareMetadata,
        epoch_state::EpochState,
        validator_verifier::ValidatorVerifier,
    };
    use aptos_crypto::hash::HashValue;

    // Setup: Create epoch state with 4 validators
    let validator_addresses: Vec<AccountAddress> = (0..4)
        .map(|i| AccountAddress::from_hex_literal(&format!("0x{:x}", i)).unwrap())
        .collect();
    
    // Create non-validator attacker address
    let attacker = AccountAddress::from_hex_literal("0xABCD").unwrap();
    
    // Create validator verifier with only the 4 validators
    let validator_infos = validator_addresses.iter().map(|addr| {
        ValidatorConsensusInfo::new(*addr, /* fake key */, 1)
    }).collect();
    let verifier = ValidatorVerifier::new(validator_infos);
    let epoch_state = Arc::new(EpochState::new(1, verifier));
    
    // Attacker crafts RequestSecretShare message
    let metadata = SecretShareMetadata::new(
        1, // epoch
        100, // round
        1234567890, // timestamp
        HashValue::random(),
        vec![1, 2, 3], // fake digest
    );
    let request = RequestSecretShare::new(metadata);
    let message = SecretShareMessage::RequestShare(request);
    
    // Attempt verification with attacker as sender
    let config = /* create fake config */;
    let result = message.verify(&epoch_state, &config);
    
    // CURRENT BEHAVIOR: This succeeds even though attacker is not a validator
    assert!(result.is_ok()); // This should FAIL but currently PASSES
    
    // EXPECTED BEHAVIOR: Should fail with authorization error
    // assert!(result.is_err());
    // assert!(result.unwrap_err().to_string().contains("not a validator"));
}
```

## Notes

This vulnerability also affects the RandGen system's `RequestShare` message handling, which uses the same pattern of accepting requests without sender authorization. Both systems should be patched simultaneously to ensure consistent security guarantees across the randomness generation infrastructure.

The network layer does provide Noise-based cryptographic authentication at the transport level, ensuring peers are who they claim to be. However, this is insufficient - authorization must also verify that authenticated peers have the *right* to access secret shares based on their role in the current epoch's validator set.

### Citations

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/network.rs (L155-161)
```rust
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L279-308)
```rust
    fn handle_incoming_msg(&self, rpc: SecretShareRpc) {
        let SecretShareRpc {
            msg,
            protocol,
            response_sender,
        } = rpc;
        match msg {
            SecretShareMessage::RequestShare(request) => {
                let result = self
                    .secret_share_store
                    .lock()
                    .get_self_share(request.metadata());
                match result {
                    Ok(Some(share)) => {
                        self.process_response(
                            protocol,
                            response_sender,
                            SecretShareMessage::Share(share),
                        );
                    },
                    Ok(None) => {
                        warn!(
                            "Self secret share could not be found for RPC request {}",
                            request.metadata().round
                        );
                    },
                    Err(e) => {
                        warn!("[SecretShareManager] Failed to get share: {}", e);
                    },
                }
```

**File:** types/src/epoch_state.rs (L19-22)
```rust
pub struct EpochState {
    pub epoch: u64,
    pub verifier: Arc<ValidatorVerifier>,
}
```

**File:** types/src/validator_verifier.rs (L496-507)
```rust
    pub fn get_public_key(&self, author: &AccountAddress) -> Option<PublicKey> {
        self.address_to_validator_index
            .get(author)
            .map(|index| self.validator_infos[*index].public_key().clone())
    }

    /// Returns the voting power for this address.
    pub fn get_voting_power(&self, author: &AccountAddress) -> Option<u64> {
        self.address_to_validator_index
            .get(author)
            .map(|index| self.validator_infos[*index].voting_power)
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-60)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
            RandMessage::FastShare(share) => {
                share.share.verify(fast_rand_config.as_ref().ok_or_else(|| {
                    anyhow::anyhow!("[RandMessage] rand config for fast path not found")
                })?)
            },
            _ => bail!("[RandMessage] unexpected message type"),
        }
    }
```
