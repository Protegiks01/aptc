# Audit Report

## Title
Type System Invariant Violation in Function Signature Validation Allows Invalid Reference Nesting

## Summary
When the `sig_checker_v2_fix_function_signatures` flag is disabled (gas_feature_version < 38), malicious modules can publish function types containing nested references or references embedded in composite types, violating Move's fundamental type system invariant that references may only appear at the top level of function parameters/returns.

## Finding Description

The Move bytecode verifier's signature checker has a critical configuration flag that controls validation of function type signatures: [1](#0-0) 

When this flag is disabled, the recursive validation of function signature parameters and results is completely skipped. This allows modules to be published with function types that violate Move's type system invariants.

The flag is controlled by the gas feature version: [2](#0-1) 

Before release v1.34 (gas_feature_version < 38), this flag was disabled, allowing the following invalid patterns:

1. **Nested References**: `|&&u64|u32` - references to references
2. **References in Vectors**: `|vector<&u64>|u32` - references embedded inside vectors  
3. **References in Struct Instantiations**: `|A<&u64>|u32` - references as type arguments

These patterns are explicitly tested and rejected when validation is enabled: [3](#0-2) 

The correct behavior is that only immediate parameters and returns of function types can be references (line 179 comment), but nested types must have `allow_ref=false`: [4](#0-3) 

When a reference type is checked with `allow_ref=false`, it properly rejects the reference. However, when the flag is disabled, this check never occurs for function signature contents.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the **Deterministic Execution** and **Move VM Safety** invariants:

1. **Type System Violation**: The Move language specification explicitly prohibits nested references and references in composite types within function signatures, as documented in the reference safety model.

2. **Consensus Risk**: Different validators or runtime configurations might handle these malformed types differently, potentially causing consensus divergence when executing transactions involving these types.

3. **Undefined Behavior**: The Move VM's type operations, memory layout calculations, and value handling code were designed assuming this invariant holds. Violating it creates undefined behavior paths where:
   - Type substitution operations may produce unexpected results
   - Memory safety assumptions in unsafe code blocks could be violated
   - Value serialization/deserialization could fail inconsistently

4. **Attack Vector**: An attacker can publish modules with these invalid types before v1.34, and they remain permanently on-chain even after the fix, potentially triggering issues when interacted with.

## Likelihood Explanation

**High Likelihood** for networks running gas_feature_version < 38:

- **Ease of Exploitation**: Any transaction sender can publish a module with malformed function types by crafting bytecode directly
- **No Special Privileges Required**: Does not require validator access or governance participation
- **Permanent Impact**: Once published, malformed modules remain on-chain
- **Detection Difficulty**: The malformed types may not cause immediate errors but could trigger issues during specific operations (closure packing, type substitution, etc.)

For current networks with the fix enabled (gas_feature_version >= 38), the vulnerability is mitigated at the verification layer.

## Recommendation

The fix has already been implemented correctly by enabling the flag in v1.34: [5](#0-4) 

**Additional Recommendations**:

1. **Audit Existing Modules**: Scan all published modules on networks that ran with gas_feature_version < 38 for function types containing invalid reference patterns

2. **Add Runtime Guards**: Even with verification fixed, add defensive runtime checks when function types are used in critical operations to ensure the invariant holds

3. **Document the Invariant**: Explicitly document in code comments that function signature types must not contain nested references or references in composite types

## Proof of Concept

A malicious module that would be accepted when the flag is disabled:

```move
// This module would pass verification with sig_checker_v2_fix_function_signatures=false
module 0x42::malicious {
    struct Exploit has drop {
        // Function type with nested reference - violates type system
        evil_function: |&&u64|u32 has drop
    }
    
    public fun create_exploit(): Exploit {
        // This would fail at runtime when trying to construct
        abort 1
    }
}
```

The bytecode representation would have a `SignatureToken::Function` containing `SignatureToken::Reference(SignatureToken::Reference(SignatureToken::U64))` in its parameters vector, which bypasses validation when the flag is disabled but would be rejected when enabled.

**Notes**

The vulnerability represents a **type system integrity violation** that was correctly fixed in v1.34. While I could not identify a specific code path guaranteed to cause a VM panic (as opposed to a runtime error), the violation of a fundamental Move type system invariant creates undefined behavior and consensus risk. The existence of explicit test cases rejecting these patterns and the gating of the fix by gas_feature_version confirms this was treated as a security-critical issue by the Aptos team.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L159-167)
```rust
            Reference(ty) | MutableReference(ty) => {
                if allow_ref {
                    assert_abilities(AbilitySet::REFERENCES, required_abilities)?;
                    self.check_ty(ty, false, AbilitySet::EMPTY, param_constraints)?;
                } else {
                    return Err(PartialVMError::new(StatusCode::INVALID_SIGNATURE_TOKEN)
                        .with_message("reference not allowed".to_string()));
                }
            },
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L172-187)
```rust
            Function(params, results, abilities) => {
                assert_abilities(*abilities, required_abilities)?;
                if self.sig_checker_v2_fix_function_signatures {
                    for ty in params.iter().chain(results) {
                        self.check_ty(
                            ty,
                            // Immediate params and returns can be references.
                            true,
                            // Note we do not need to check abilities of argument or result types,
                            // they do not matter for the `required_abilities`.
                            AbilitySet::EMPTY,
                            param_constraints,
                        )?
                    }
                }
            },
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-149)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
```

**File:** third_party/move/move-bytecode-verifier/transactional-tests/tests/signature/reference_in_function_signatures.masm (L26-54)
```text
//# publish
module 0x42::b

public fun foo(f: |&&u64|u32 has drop)
    ret


//# publish
module 0x42::b

public fun foo(f: |vector<&u64>|u32 has drop)
    ret


//# publish
module 0x42::c

struct A<T>
    x: T

public fun foo(f: |A<&u64>|u32 has drop)
    ret


//# publish
module 0x42::d

struct A
    x: |vector<&u64>|
```
