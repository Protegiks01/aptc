# Audit Report

## Title
Unmetered CPU Exhaustion via Excessive Function Handles in Dependency Verification

## Summary
The Move bytecode verifier enforces limits on `function_defs` count but not on `function_handles` count. During dependency verification, all function handles undergo expensive validation in an O(N) unmetered loop. An attacker can create modules with thousands of function handles, forcing validators to perform excessive CPU work while paying only for module size in gas, enabling validator slowdown attacks.

## Finding Description

The vulnerability stems from an asymmetry in the bytecode verifier's limit enforcement. The `verify_definitions` function checks `function_defs` count against `max_function_definitions`, but there is no corresponding check for the total count of `function_handles`. [1](#0-0) 

The `verify_function_handles` function validates properties like type parameters and parameters for each handle, but never checks the total count of function handles. [2](#0-1) 

The binary format permits up to 65,535 function handles (TABLE_INDEX_MAX), providing a large attack surface. [3](#0-2) 

During dependency verification, every function handle is iterated and undergoes expensive validation operations including module lookups, function signature comparisons, type parameter validation, and attribute compatibility checks. [4](#0-3) 

**Critical Issue**: This verification is NOT metered. The `build_verified_module_with_linking_checks` function calls `dependencies::verify_module` without any gas metering. [5](#0-4) 

In production configuration, there is no limit on function definitions, and by extension, no limit on function handles count. [6](#0-5) 

Gas charging is based on module size in bytes using the formula `DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size`, not on verification complexity, creating a severe asymmetry where attackers pay minimal gas for maximum CPU consumption.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns: Significant performance degradation affecting consensus, DoS through resource exhaustion."

**Network Impact**: All validator nodes must verify published modules during execution. An attacker can publish modules that force validators to perform excessive unmetered CPU work during dependency verification.

**Liveness Threat**: Multiple such modules published in succession could cause validators to experience slowdowns in block production and consensus participation, degrading network liveness.

**Resource Exhaustion**: The verification CPU cost is O(N) for N function handles, while gas charging is O(module_bytes), creating an asymmetry where attackers pay based on module size but consume CPU based on handle count.

**Consensus Impact**: Dependency verification happens synchronously during module loading in `visit_dependencies_and_verify`, potentially delaying transaction execution and block production. [7](#0-6) 

## Likelihood Explanation

**Likelihood: Medium to High**

**Ease of Exploitation**: Any user can publish Move modules to the blockchain. Creating a module with excessive function handles requires deploying dependency modules with multiple functions, then creating a module that references them.

**Economic Constraints**: While the binary format allows up to 65,535 handles, practical exploitation requires valid function handles. An attacker must first deploy dependency modules with sufficient functions, which has a cost. However, even with 5,000-10,000 valid function handles (which is more economically feasible), the unmetered CPU impact is significant.

**No Special Privileges Required**: This is exploitable by any unprivileged transaction sender through normal module publishing.

**Deterministic Impact**: All validators will experience the same CPU exhaustion when verifying the malicious module, making the attack reliable and repeatable.

## Recommendation

Add a limit check for function handles count in the `LimitsVerifier`:

```rust
fn verify_function_handles(&self, config: &VerifierConfig) -> PartialVMResult<()> {
    let handles = self.resolver.function_handles();
    
    // Add count check
    if let Some(max_function_handles) = config.max_function_handles {
        if handles.len() > max_function_handles {
            return Err(PartialVMError::new(
                StatusCode::MAX_FUNCTION_HANDLES_REACHED
            ));
        }
    }
    
    for (idx, function_handle) in handles.iter().enumerate() {
        // existing per-handle validation...
    }
    Ok(())
}
```

Add `max_function_handles` to `VerifierConfig` and set a reasonable production limit (e.g., 2,000-5,000) in `aptos_prod_verifier_config`.

## Proof of Concept

A full PoC would require creating dependency modules with multiple functions and a malicious module referencing them. The key demonstration is that `verify_imported_functions` iterates all handles without count limits:

```rust
// Malicious module with N function_handles
module Attacker::Malicious {
    use Dependency1::Module1;
    use Dependency2::Module2;
    // ... reference functions from dependencies
    
    public fun trigger() {
        // Minimal function body
        // But module has N function_handles in its handle table
    }
}
```

When validators verify this module, they iterate through all N handles performing expensive operations without gas metering, while the attacker pays only for module size in bytes.

## Notes

While the theoretical maximum is 65,535 function handles, practical exploitation is constrained by the economic cost of deploying large dependency modules. However, even with 5,000-10,000 valid function handles (achievable with moderate investment), the vulnerability enables significant unmetered CPU consumption on validators. The core issue is the asymmetry: function_defs count is checked, but function_handles count is not, and verification work is unmetered while gas is charged based on bytes.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L65-93)
```rust
    fn verify_function_handles(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        for (idx, function_handle) in self.resolver.function_handles().iter().enumerate() {
            if let Some(limit) = config.max_generic_instantiation_length {
                if function_handle.type_parameters.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            };
            if let Some(limit) = config.max_function_parameters {
                if self
                    .resolver
                    .signature_at(function_handle.parameters)
                    .0
                    .len()
                    > limit
                {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            }
            if let Some(limit) = config.max_function_return_values {
                if self.resolver.signature_at(function_handle.return_).0.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            };
            // Note: the size of `attributes` is limited by the deserializer.
        }
        Ok(())
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L197-206)
```rust
    fn verify_definitions(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        if let Some(defs) = self.resolver.function_defs() {
            if let Some(max_function_definitions) = config.max_function_definitions {
                if defs.len() > max_function_definitions {
                    return Err(PartialVMError::new(
                        StatusCode::MAX_FUNCTION_DEFINITIONS_REACHED,
                    ));
                }
            }
        }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-50)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
pub const SIGNATURE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const ADDRESS_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const IDENTIFIER_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const MODULE_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_DEF_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const FUNCTION_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L281-387)
```rust
fn verify_imported_functions(context: &Context) -> PartialVMResult<()> {
    let self_module = context.resolver.self_handle_idx();
    for (idx, function_handle) in context.resolver.function_handles().iter().enumerate() {
        if Some(function_handle.module) == self_module {
            continue;
        }
        let owner_module_id = context
            .resolver
            .module_id_for_handle(context.resolver.module_handle_at(function_handle.module));
        let function_name = context.resolver.identifier_at(function_handle.name);
        let owner_module = safe_unwrap!(context.dependency_map.get(&owner_module_id));
        match context
            .func_id_to_index_map
            .get(&(owner_module_id.clone(), function_name.to_owned()))
        {
            Some((owner_handle_idx, owner_def_idx)) => {
                let def_handle = owner_module.function_handle_at(*owner_handle_idx);
                // compatible type parameter constraints
                if !compatible_fun_type_parameters(
                    &function_handle.type_parameters,
                    &def_handle.type_parameters,
                ) {
                    return Err(verification_error(
                        StatusCode::TYPE_MISMATCH,
                        IndexKind::FunctionHandle,
                        idx as TableIndex,
                    )
                    .with_message("imported function mismatches expectation"));
                }
                // same parameters
                let handle_params = context.resolver.signature_at(function_handle.parameters);
                let def_params = match context.dependency_map.get(&owner_module_id) {
                    Some(module) => module.signature_at(def_handle.parameters),
                    None => {
                        return Err(verification_error(
                            StatusCode::LOOKUP_FAILED,
                            IndexKind::FunctionHandle,
                            idx as TableIndex,
                        ))
                    },
                };

                compare_cross_module_signatures(
                    context,
                    &handle_params.0,
                    &def_params.0,
                    owner_module,
                )
                .map_err(|e| e.at_index(IndexKind::FunctionHandle, idx as TableIndex))?;

                // same return_
                let handle_return = context.resolver.signature_at(function_handle.return_);
                let def_return = match context.dependency_map.get(&owner_module_id) {
                    Some(module) => module.signature_at(def_handle.return_),
                    None => {
                        return Err(verification_error(
                            StatusCode::LOOKUP_FAILED,
                            IndexKind::FunctionHandle,
                            idx as TableIndex,
                        ))
                    },
                };

                compare_cross_module_signatures(
                    context,
                    &handle_return.0,
                    &def_return.0,
                    owner_module,
                )
                .map_err(|e| e.at_index(IndexKind::FunctionHandle, idx as TableIndex))?;

                // Compatible attributes.
                let mut def_attrs = def_handle.attributes.as_slice();
                let handle_attrs = function_handle.attributes.as_slice();
                if !handle_attrs.is_empty() && def_attrs.is_empty() {
                    // This is a function with no attributes, which can come from that
                    // it's compiled for < Move 2.2. Synthesize the
                    // `persistent` attribute from Public visibility, which we find
                    // in the definition.
                    if owner_module.function_def_at(*owner_def_idx).visibility == Visibility::Public
                    {
                        def_attrs = &[FunctionAttribute::Persistent]
                    }
                }
                if !FunctionAttribute::is_compatible_with(handle_attrs, def_attrs) {
                    let def_view = FunctionHandleView::new(*owner_module, def_handle);
                    return Err(verification_error(
                        StatusCode::LINKER_ERROR,
                        IndexKind::FunctionHandle,
                        idx as TableIndex,
                    )
                    .with_message(format!(
                        "imported function `{}` missing expected attributes",
                        def_view.name()
                    )));
                }
            },
            None => {
                return Err(verification_error(
                    StatusCode::LOOKUP_FAILED,
                    IndexKind::FunctionHandle,
                    idx as TableIndex,
                ));
            },
        }
    }
    Ok(())
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L205-216)
```rust
    pub(crate) fn build_verified_module_with_linking_checks(
        &self,
        locally_verified_module: LocallyVerifiedModule,
        immediate_dependencies: &[Arc<Module>],
    ) -> VMResult<Module> {
        dependencies::verify_module(
            &self.vm_config.verifier_config,
            locally_verified_module.0.as_ref(),
            immediate_dependencies
                .iter()
                .map(|module| module.as_ref().as_ref()),
        )?;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L171-171)
```rust
        max_function_definitions: None,
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L345-427)
```rust
fn visit_dependencies_and_verify<T, E, V>(
    module_id: ModuleId,
    module: Arc<ModuleCode<CompiledModule, Module, E>>,
    version: V,
    visited: &mut HashSet<ModuleId>,
    module_cache_with_context: &T,
) -> VMResult<Arc<Module>>
where
    T: WithRuntimeEnvironment
        + ModuleCache<
            Key = ModuleId,
            Deserialized = CompiledModule,
            Verified = Module,
            Extension = E,
            Version = V,
        > + ModuleCodeBuilder<
            Key = ModuleId,
            Deserialized = CompiledModule,
            Verified = Module,
            Extension = E,
        >,
    E: WithBytes + WithSize + WithHash,
    V: Clone + Default + Ord,
{
    let runtime_environment = module_cache_with_context.runtime_environment();

    // Step 1: Local verification.
    runtime_environment.paranoid_check_module_address_and_name(
        module.code().deserialized(),
        module_id.address(),
        module_id.name(),
    )?;
    let locally_verified_code = runtime_environment.build_locally_verified_module(
        module.code().deserialized().clone(),
        module.extension().size_in_bytes(),
        module.extension().hash(),
    )?;

    // Step 2: Traverse and collect all verified immediate dependencies so that we can verify
    // non-local properties of the module.
    let mut verified_dependencies = vec![];
    for (addr, name) in locally_verified_code.immediate_dependencies_iter() {
        let dependency_id = ModuleId::new(*addr, name.to_owned());

        let (dependency, dependency_version) = module_cache_with_context
            .get_module_or_build_with(&dependency_id, module_cache_with_context)?
            .ok_or_else(|| module_linker_error!(addr, name))?;

        // Dependency is already verified!
        if dependency.code().is_verified() {
            verified_dependencies.push(dependency.code().verified().clone());
            continue;
        }

        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
    }

    let verified_code = runtime_environment
        .build_verified_module_with_linking_checks(locally_verified_code, &verified_dependencies)?;
    let module = module_cache_with_context.insert_verified_module(
        module_id,
        verified_code,
        module.extension().clone(),
        version,
    )?;
    Ok(module.code().verified().clone())
}
```
