# Audit Report

## Title
Unbounded HashMap Growth via Malicious JWK Consensus RPC Requests Enables Validator Node Memory Exhaustion DoS

## Summary
The `KeyLevelConsensusManager` in the JWK consensus implementation creates unbounded HashMap entries for arbitrary `(issuer, kid)` pairs received via RPC without validation. A single Byzantine validator can spam the network with malicious requests, causing memory exhaustion on all other validators due to flawed cleanup logic that never removes these entries.

## Finding Description

The vulnerability exists in the per-key JWK consensus manager's RPC request handler. When processing a `KeyLevelObservationRequest`, the code unconditionally creates HashMap entries for any `(issuer, kid)` pair without validation: [1](#0-0) 

This creates a `ConsensusState::NotStarted` entry (the default) for any arbitrary pair. The types allow arbitrary byte sequences: [2](#0-1) 

There is no validation that:
- The issuer corresponds to a legitimate OIDC provider
- The kid is a valid key identifier  
- The total number of entries is bounded

**Critical Flaw in Cleanup Logic:**

The cleanup function attempts to remove stale entries but has a fundamental logic error: [3](#0-2) 

For arbitrary `(issuer, kid)` pairs that never existed on-chain:
- `new_onchain_jwks.get(issuer)` returns `None` → `unwrap_or_default()` returns `0` (default for u64)
- `self.onchain_jwks.get(issuer)` returns `None` → `unwrap_or_default()` returns `0`
- The condition `0 == 0` is `true`, so the entry is **retained**

This means malicious entries persist indefinitely in memory.

**Attack Execution Path:**

1. Byzantine validator sends `KeyLevelObservationRequest` messages via the validator network
2. Network layer forwards these to the epoch manager with only epoch validation: [4](#0-3) 

3. Each unique `(issuer, kid)` pair creates a new HashMap entry
4. No bounds checking prevents unlimited growth
5. Cleanup logic never removes malicious entries
6. Memory consumption grows until OOM occurs, crashing the validator

This violates AptosBFT's Byzantine fault tolerance guarantee - the system should tolerate up to 1/3 Byzantine validators, but a single malicious validator can cause memory exhaustion on all other nodes.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty categories:

**Validator Node Slowdowns (High)**: As memory fills, garbage collection pressure increases dramatically, degrading consensus performance. This matches the explicit category "DoS through resource exhaustion."

**API Crashes (High)**: OOM conditions will crash the validator process entirely, removing it from consensus participation.

The attack requires minimal resources (just network bandwidth for RPC messages) but forces victims to consume gigabytes of memory. With sufficient unique pairs:
- 10 million pairs ≈ 2 GB memory
- 100 million pairs ≈ 20 GB memory

Could escalate to **Critical Severity** if enough validators are crashed simultaneously to cause "Total loss of liveness/network availability" (requires > 1/3 validators down).

## Likelihood Explanation

**High Likelihood** in a realistic Byzantine threat model:

- **Low barrier to entry**: Any single Byzantine validator can execute this attack (< 1/3 threshold)
- **Easy execution**: Simple automated script to generate random `(issuer, kid)` pairs and send RPC requests
- **No detection**: Malicious requests are indistinguishable from legitimate JWK consensus messages
- **No defenses**: No rate limiting, bounds checking, or validation of issuer/kid legitimacy
- **Persistent damage**: Entries never cleaned up, so even brief attacks cause permanent memory leaks

AptosBFT is designed to tolerate Byzantine behavior from up to 1/3 validators. This vulnerability violates that guarantee by allowing a single Byzantine validator to degrade or crash all other validators.

## Recommendation

Implement the following defenses:

1. **Whitelist validation**: Only allow `(issuer, kid)` pairs from on-chain registered OIDC providers:
```rust
// Validate issuer exists in onchain_jwks or supported providers
if !self.onchain_jwks.contains_key(&issuer) && !is_supported_provider(&issuer) {
    return Ok(()); // Ignore request for unknown issuer
}
```

2. **Bounds checking**: Limit total HashMap entries:
```rust
const MAX_CONSENSUS_STATES: usize = 10000;
if self.states_by_key.len() >= MAX_CONSENSUS_STATES {
    warn!("states_by_key capacity exceeded, dropping request");
    return Ok(());
}
```

3. **Fix cleanup logic**: Remove entries for issuers that don't exist in the new on-chain state:
```rust
self.states_by_key.retain(|(issuer, _), _| {
    new_onchain_jwks.contains_key(issuer)
});
```

4. **Rate limiting**: Implement per-peer rate limiting for observation requests.

## Proof of Concept

```rust
// Simulated attack demonstrating unbounded growth
#[test]
fn test_unbounded_hashmap_growth() {
    let mut manager = create_test_manager();
    
    // Attacker sends requests with random (issuer, kid) pairs
    for i in 0..1_000_000 {
        let issuer = format!("malicious_issuer_{}", i).into_bytes();
        let kid = format!("malicious_kid_{}", i).into_bytes();
        
        let request = IncomingRpcRequest {
            msg: JWKConsensusMsg::KeyLevelObservationRequest(
                ObservedKeyLevelUpdateRequest {
                    epoch: 1,
                    issuer,
                    kid,
                }
            ),
            sender: test_validator_address(),
            response_sender: Box::new(DummyResponseSender::new()),
        };
        
        manager.process_peer_request(request).unwrap();
    }
    
    // Verify unbounded growth
    assert_eq!(manager.states_by_key.len(), 1_000_000);
    
    // Verify cleanup doesn't remove malicious entries
    manager.reset_with_on_chain_state(AllProvidersJWKs::empty()).unwrap();
    assert_eq!(manager.states_by_key.len(), 1_000_000); // Still present!
}
```

## Notes

This vulnerability affects the per-key JWK consensus mode (enabled via `JWK_CONSENSUS_PER_KEY_MODE` feature flag). The attack leverages the Byzantine fault tolerance assumption - while AptosBFT is designed to tolerate up to 1/3 Byzantine validators, this implementation flaw allows a single Byzantine validator to cause resource exhaustion on all other validators, violating the fundamental BFT safety guarantee.

The distinction between "trusted validator operators" and "Byzantine validators" is critical: while we trust validator operators not to collude in majority (>1/3), BFT consensus must still handle Byzantine behavior from individual validators. This vulnerability demonstrates a failure to properly bound resources in the presence of Byzantine inputs.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L244-254)
```rust
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L274-277)
```rust
                let consensus_state = self
                    .states_by_key
                    .entry((issuer.clone(), kid.clone()))
                    .or_default();
```

**File:** types/src/jwks/mod.rs (L36-38)
```rust
pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L99-104)
```rust
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
```
