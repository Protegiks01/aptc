# Audit Report

## Title
Admin Service Silent Failure on Port Conflict - Missing Error Handling in Server Startup

## Summary
The admin service's `start()` function logs "Started AdminService" before the HTTP server actually begins listening, and does not handle errors from the server binding process. This can cause silent failures where operators believe the service is running but it's not actually listening due to port conflicts.

## Finding Description
The vulnerability exists in the `start()` function of the admin service. [1](#0-0) 

The function spawns a background task that:
1. Creates the server with `Server::bind(&address).serve(make_service)`
2. Immediately logs "Started AdminService" 
3. Awaits the server without error handling

The critical flaw is that the log message appears **before** the server future is polled and actually starts listening. If the port is already in use or binding fails for any reason, the error from `server.await` is silently discarded because it's in a spawned background task with no error handling.

In contrast, other services in the codebase properly handle server errors. The pepper service uses explicit error handling: [2](#0-1) 

The inspection service also handles errors by unwrapping the result: [3](#0-2) 

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program's "State inconsistencies requiring intervention" category, as it creates an operational state where:

1. **False Operational State**: The node logs indicate the admin service started successfully, but it's not actually listening
2. **Incident Response Degradation**: During critical incidents, operators cannot access debugging endpoints (`/debug/consensus/consensusdb`, `/debug/mempool/parking-lot/addresses`, `/profilez`) to diagnose validator issues
3. **Delayed Detection**: The silent failure means operators won't discover the problem until they try to use the service during an emergency

While this doesn't directly impact consensus or funds, it degrades the operational security posture of the validator node by removing critical debugging capabilities during incidents.

## Likelihood Explanation
**Moderate Likelihood** - Port conflicts can occur through:
- Previous admin service process not cleanly terminated
- Multiple Aptos node instances misconfigured on the same host
- System services or other applications using the same port
- An attacker with local access pre-binding the port (requires host compromise)

The impact is amplified because the silent failure is not immediately detected - operators only discover it when they need the service during an incident.

## Recommendation
Add proper error handling to the server startup. The fix should:
1. Handle errors from `server.await`
2. Log the error before panicking or attempting recovery
3. Move the success log after confirming the server started

Recommended fix:
```rust
fn start(&self, address: SocketAddr, enabled: bool) {
    let context = self.context.clone();
    self.runtime.spawn(async move {
        let make_service = make_service_fn(move |_conn| {
            let context = context.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |req| {
                    Self::serve_requests(context.clone(), req, enabled)
                }))
            }
        });

        let server = Server::bind(&address).serve(make_service);
        info!("Starting AdminService at {address:?}, enabled: {enabled}.");
        
        // Handle server errors instead of silently ignoring them
        if let Err(error) = server.await {
            panic!("AdminService failed to start on {address:?}: {error}");
        }
    });
}
```

## Proof of Concept
To reproduce the silent failure:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::TcpListener;

    #[test]
    fn test_admin_service_port_conflict() {
        // Bind to the admin service port first
        let port = 9102; // Default admin service port
        let _blocker = TcpListener::bind(format!("127.0.0.1:{}", port))
            .expect("Failed to bind blocker");

        // Create a minimal node config
        let mut config = NodeConfig::default();
        config.admin_service.port = port;
        config.admin_service.address = "127.0.0.1".to_string();

        // Create the admin service - this will log "Started" but fail silently
        let admin_service = AdminService::new(&config);
        
        // Sleep to allow the background task to attempt binding
        std::thread::sleep(std::time::Duration::from_secs(1));
        
        // The admin service appears to be running based on logs,
        // but attempting to connect will fail
        let result = std::net::TcpStream::connect(format!("127.0.0.1:{}", port));
        
        // Connection succeeds to the blocker, not the admin service
        assert!(result.is_ok(), "Connected to blocker, not admin service");
    }
}
```

**Notes**

This vulnerability represents a quality-of-service and operational security issue rather than a direct consensus or fund security threat. However, it meets Medium severity criteria because it creates a misleading operational state that could delay incident response during critical validator issues. The fix is straightforward - add proper error handling consistent with other HTTP services in the codebase.

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L124-140)
```rust
    fn start(&self, address: SocketAddr, enabled: bool) {
        let context = self.context.clone();
        self.runtime.spawn(async move {
            let make_service = make_service_fn(move |_conn| {
                let context = context.clone();
                async move {
                    Ok::<_, Infallible>(service_fn(move |req| {
                        Self::serve_requests(context.clone(), req, enabled)
                    }))
                }
            });

            let server = Server::bind(&address).serve(make_service);
            info!("Started AdminService at {address:?}, enabled: {enabled}.");
            server.await
        });
    }
```

**File:** keyless/pepper/service/src/main.rs (L249-252)
```rust
        let server = Server::bind(&socket_addr).serve(make_service);
        if let Err(error) = server.await {
            panic!("Metrics server error! Error: {}", error);
        }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L96-99)
```rust
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
```
