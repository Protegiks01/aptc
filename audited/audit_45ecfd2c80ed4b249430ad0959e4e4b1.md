# Audit Report

## Title
Two-Chain Timeout Certificate Verification Failure Due to Signature Update Race Condition

## Summary
The timeout certificate aggregation logic in `TwoChainTimeoutVotes` fails to properly track signature updates when validators send multiple timeout messages with increasing HQC (Highest Quorum Certificate) rounds. This creates an inconsistency where the stored timeout's HQC round does not match the maximum signed HQC round, causing legitimate timeout certificates to fail verification and disrupting consensus liveness.

## Finding Description

The vulnerability exists in the interaction between three critical components in the Aptos consensus layer:

**1. No Duplicate Detection**: Unlike vote processing which uses the `author_to_vote` HashMap to detect duplicates and equivocations, `insert_round_timeout()` has no mechanism to prevent validators from sending multiple timeout messages for the same round. [1](#0-0) 

This contrasts sharply with `insert_vote()`, which explicitly checks for duplicate votes and equivocations. [2](#0-1) 

**2. Signature Tracking Bug**: The `add_signature()` method in `PartialSignaturesWithRound` uses `or_insert()`, which only inserts a new entry if the key doesn't exist. This means the FIRST signature from each validator is recorded, but subsequent signatures from the same validator are silently ignored, even if they contain updated information. [3](#0-2) 

**3. Timeout Replacement Without Signature Update**: When `TwoChainTimeoutWithPartialSignatures::add()` receives a timeout with a higher HQC round, it correctly updates the stored timeout object. However, when it subsequently calls `add_signature()` with the new HQC round, the signature is NOT updated due to the `or_insert()` behavior. [4](#0-3) 

**Exploitation Scenario**:

During normal AptosBFT operation, validators may receive new quorum certificates while an ongoing round is timing out:

1. Validator A sends `RoundTimeout(round=10, HQC_round=5)` → Stored timeout HQC=5, Signatures: `{A: (5, sig_A)}`
2. Validator B sends `RoundTimeout(round=10, HQC_round=6)` → Stored timeout updated to HQC=6, Signatures: `{A: (5, sig_A), B: (6, sig_B)}`
3. Validator A receives QC for round 8 and legitimately sends updated `RoundTimeout(round=10, HQC_round=8)`
   - Stored timeout updated to HQC=8 (line 260)
   - `add_signature(A, 8, sig_A_new)` called (line 262)
   - But A's signature remains `(5, sig_A)` due to `or_insert()` (line 328)
   - Signatures: `{A: (5, sig_A), B: (6, sig_B)}`
4. Validator C sends `RoundTimeout(round=10, HQC_round=5)` → Signatures: `{A: (5, sig_A), B: (6, sig_B), C: (5, sig_C)}`

When quorum is reached and `aggregate_signatures()` creates the `TwoChainTimeoutCertificate`:
- Stored `timeout.hqc_round()` = 8
- Signature HQC rounds: [5, 6, 5]
- `max(signed rounds)` = 6

**Verification Failure**: When the TC is verified (e.g., in a `ProposalMsg`), the consistency check fails because it requires that the stored timeout's HQC round must equal the maximum of all signed HQC rounds. [5](#0-4) 

The verification error message is: `"Inconsistent hqc round, qc has round 8, highest signed round 6"`

This causes the legitimately aggregated TC to be rejected, even though all signatures are valid and the quorum threshold was reached.

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria: "State inconsistencies requiring manual intervention" and "Temporary liveness issues"

This vulnerability causes:

1. **Consensus Liveness Degradation**: Legitimate timeout certificates fail verification during the proposal phase, preventing round progression when timeouts occur. This directly impacts the network's ability to recover from scenarios requiring timeouts (slow validators, network partitions).

2. **State Inconsistency**: The TC successfully passes aggregation (voting power check succeeds), but subsequently fails verification when used. This creates a confusing state where the node believes it has a valid TC but cannot use it.

3. **Diagnostic Complexity**: The failure manifests only during TC usage in proposals, not during aggregation. The error message indicates an "inconsistent hqc round" but the root cause (signature not updated) is non-obvious, making debugging difficult.

4. **Network-Wide Impact**: All nodes receiving a proposal with the malformed TC will reject it, potentially causing the round to fail and requiring another timeout cycle.

The issue does NOT affect safety (no double-spending or chain splits), but significantly impacts liveness, which is critical for a production blockchain. Under adversarial conditions or during network stress, this could cause prolonged consensus stalls requiring manual intervention or node restarts.

## Likelihood Explanation

**HIGH likelihood** of occurrence:

1. **Natural Trigger During Normal Operations**: Validators routinely receive new quorum certificates during ongoing rounds due to block proposals from other validators. It is entirely normal and expected for a validator's view of the highest QC to change during a timeout period. No malicious behavior is required.

2. **Common Network Conditions**: Network delays, varying block propagation times, and validators catching up after brief disconnections all create scenarios where validators have different HQC rounds during the same timeout round.

3. **No Protective Measures**: The code completely lacks duplicate detection for timeout messages. [1](#0-0)  There is no validation at the `RoundManager` level [6](#0-5)  or the `RoundState` level [7](#0-6)  to prevent multiple timeout messages from the same validator.

4. **Malicious Amplification**: While the bug can occur naturally, a malicious validator could deliberately exploit it by sending multiple timeout messages with incrementally increasing HQC rounds to ensure the inconsistency occurs and disrupts consensus.

5. **Test Coverage Gap**: The existing test suite does not cover the scenario of the same validator sending multiple timeout messages with different HQC rounds. [8](#0-7) 

## Recommendation

Implement one of the following fixes:

**Option 1: Add Duplicate Detection** (Recommended)
Track which validators have already sent timeout messages for the current round, similar to how votes are tracked. Reject subsequent timeout messages from the same validator.

```rust
// In PendingVotes struct, add:
author_to_timeout: HashMap<Author, RoundTimeout>,

// In insert_round_timeout():
if let Some(previous_timeout) = self.author_to_timeout.get(&round_timeout.author()) {
    if previous_timeout.two_chain_timeout().hqc_round() == timeout.hqc_round() {
        return VoteReceptionResult::DuplicateVote;
    } else {
        return VoteReceptionResult::EquivocateVote;
    }
}
self.author_to_timeout.insert(round_timeout.author(), round_timeout.clone());
```

**Option 2: Fix Signature Update Logic**
Change `add_signature()` to update existing signatures instead of preserving the first one:

```rust
pub fn add_signature(
    &mut self,
    validator: AccountAddress,
    round: Round,
    signature: bls12381::Signature,
) {
    self.signatures.insert(validator, (round, signature));
}
```

**Option 1 is recommended** because it maintains consistency with vote processing and prevents potential Byzantine behavior where validators send conflicting timeout information.

## Proof of Concept

```rust
#[test]
fn test_timeout_signature_update_race_condition() {
    use aptos_consensus_types::{
        quorum_cert::QuorumCert,
        round_timeout::RoundTimeout,
        timeout_2chain::{TwoChainTimeout, TwoChainTimeoutWithPartialSignatures},
    };
    use aptos_types::validator_verifier::random_validator_verifier;

    let (signers, validator_verifier) = random_validator_verifier(4, None, false);
    
    // Create timeouts with different HQC rounds
    let timeout_hqc5 = TwoChainTimeout::new(1, 10, create_qc_for_round(5, &signers, &validator_verifier));
    let timeout_hqc8 = TwoChainTimeout::new(1, 10, create_qc_for_round(8, &signers, &validator_verifier));
    
    let mut tc_partial = TwoChainTimeoutWithPartialSignatures::new(timeout_hqc5.clone());
    
    // Validator 0 sends timeout with HQC=5
    tc_partial.add(
        signers[0].author(),
        timeout_hqc5.clone(),
        timeout_hqc5.sign(&signers[0]).unwrap(),
    );
    
    // Validator 0 sends UPDATED timeout with HQC=8 (after receiving new QC)
    tc_partial.add(
        signers[0].author(),
        timeout_hqc8.clone(),
        timeout_hqc8.sign(&signers[0]).unwrap(),
    );
    
    // Other validators send timeouts
    tc_partial.add(signers[1].author(), timeout_hqc5.clone(), timeout_hqc5.sign(&signers[1]).unwrap());
    tc_partial.add(signers[2].author(), timeout_hqc5.clone(), timeout_hqc5.sign(&signers[2]).unwrap());
    
    // Aggregate and verify
    let tc = tc_partial.aggregate_signatures(&validator_verifier).unwrap();
    
    // Verification SHOULD succeed but WILL FAIL due to the bug
    // Expected: tc.timeout.hqc_round() = 8
    // Actual: max(signed_rounds) = 5 (validator 0's signature stuck at round 5)
    assert!(tc.verify(&validator_verifier).is_err());
}
```

## Notes

This vulnerability represents a logic bug in the consensus layer that can manifest during normal network operations. The issue is particularly insidious because:

1. The TC successfully passes quorum checks during aggregation, giving nodes a false sense that consensus is progressing normally
2. The failure only occurs during verification when the TC is actually used, creating a delayed failure mode
3. The root cause (signature not being updated) is hidden behind the error message about inconsistent HQC rounds

The fix should prioritize preventing multiple timeout messages from the same validator (Option 1) to maintain consistency with the vote processing path and prevent potential Byzantine exploitation of this behavior.

### Citations

**File:** consensus/src/pending_votes.rs (L190-271)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );

        let partial_tc = two_chain_votes.partial_2chain_tc_mut();
        let tc_voting_power =
            match validator_verifier.check_voting_power(partial_tc.signers(), true) {
                Ok(_) => {
                    return match partial_tc.aggregate_signatures(validator_verifier) {
                        Ok(tc_with_sig) => {
                            VoteReceptionResult::New2ChainTimeoutCertificate(Arc::new(tc_with_sig))
                        },
                        Err(e) => VoteReceptionResult::ErrorAggregatingTimeoutCertificate(e),
                    };
                },
                Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => voting_power,
                Err(error) => {
                    error!(
                        "MUST_FIX: 2-chain timeout vote received could not be added: {}, vote: {}",
                        error, timeout
                    );
                    return VoteReceptionResult::ErrorAddingVote(error);
                },
            };

        // Echo timeout if receive f+1 timeout message.
        if !self.echo_timeout {
            let f_plus_one = validator_verifier.total_voting_power()
                - validator_verifier.quorum_voting_power()
                + 1;
            if tc_voting_power >= f_plus_one {
                self.echo_timeout = true;
                return VoteReceptionResult::EchoTimeout(tc_voting_power);
            }
        }

        //
        // No TC could be formed, return the TC's voting power
        //

        VoteReceptionResult::VoteAdded(tc_voting_power)
    }
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/src/pending_votes.rs (L791-869)
```rust
    #[test]
    fn test_2chain_tc_aggregation() {
        ::aptos_logger::Logger::init_for_testing();

        // set up 4 validators
        let (signers, validator_verifier) = random_validator_verifier(4, None, false);
        let mut pending_votes = PendingVotes::new();

        // submit a new vote from validator[0] -> VoteAdded
        let li0 = random_ledger_info();
        let vote0 = random_vote_data();
        let mut vote0_author_0 = Vote::new(vote0, signers[0].author(), li0, &signers[0]).unwrap();

        assert_eq!(
            pending_votes.insert_vote(&vote0_author_0, &validator_verifier),
            VoteReceptionResult::VoteAdded(1)
        );

        // submit the same vote but enhanced with a timeout -> VoteAdded
        let timeout = vote0_author_0.generate_2chain_timeout(certificate_for_genesis());
        let signature = timeout.sign(&signers[0]).unwrap();
        vote0_author_0.add_2chain_timeout(timeout, signature);

        assert_eq!(
            pending_votes.insert_vote(&vote0_author_0, &validator_verifier),
            VoteReceptionResult::VoteAdded(1)
        );

        // another vote for a different block cannot form a TC if it doesn't have a timeout signature
        let li1 = random_ledger_info();
        let vote1 = random_vote_data();
        let mut vote1_author_1 = Vote::new(vote1, signers[1].author(), li1, &signers[1]).unwrap();
        assert_eq!(
            pending_votes.insert_vote(&vote1_author_1, &validator_verifier),
            VoteReceptionResult::VoteAdded(1)
        );

        // if that vote is now enhanced with a timeout signature -> EchoTimeout.
        let timeout = vote1_author_1.generate_2chain_timeout(certificate_for_genesis());
        let signature = timeout.sign(&signers[1]).unwrap();
        vote1_author_1.add_2chain_timeout(timeout, signature);
        match pending_votes.insert_vote(&vote1_author_1, &validator_verifier) {
            VoteReceptionResult::EchoTimeout(voting_power) => {
                assert_eq!(voting_power, 2);
            },
            _ => {
                panic!("Should echo timeout");
            },
        };

        let li2 = random_ledger_info();
        let vote2 = random_vote_data();
        let mut vote2_author_2 = Vote::new(vote2, signers[2].author(), li2, &signers[2]).unwrap();

        // if that vote is now enhanced with a timeout signature -> NewTimeoutCertificate.
        let timeout = vote2_author_2.generate_2chain_timeout(certificate_for_genesis());
        let signature = timeout.sign(&signers[2]).unwrap();
        vote2_author_2.add_2chain_timeout(timeout, signature);
        match pending_votes.insert_vote(&vote2_author_2, &validator_verifier) {
            VoteReceptionResult::New2ChainTimeoutCertificate(tc) => {
                assert!(validator_verifier
                    .check_voting_power(
                        tc.signatures_with_rounds()
                            .get_voters(
                                &validator_verifier
                                    .get_ordered_account_addresses_iter()
                                    .collect_vec()
                            )
                            .iter(),
                        true
                    )
                    .is_ok());
            },
            _ => {
                panic!("Should form TC");
            },
        };
    }
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L176-181)
```rust
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L242-263)
```rust
    pub fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
    ) {
        debug_assert_eq!(
            self.timeout.epoch(),
            timeout.epoch(),
            "Timeout should have the same epoch as TimeoutCert"
        );
        debug_assert_eq!(
            self.timeout.round(),
            timeout.round(),
            "Timeout should have the same round as TimeoutCert"
        );
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```

**File:** consensus/src/round_manager.rs (L1881-1895)
```rust
    async fn process_round_timeout(&mut self, timeout: RoundTimeout) -> anyhow::Result<()> {
        info!(
            self.new_log(LogEvent::ReceiveRoundTimeout)
                .remote_peer(timeout.author()),
            vote = %timeout,
            epoch = timeout.epoch(),
            round = timeout.round(),
        );

        let vote_reception_result = self
            .round_state
            .insert_round_timeout(&timeout, &self.epoch_state.verifier);
        self.process_timeout_reception_result(&timeout, vote_reception_result)
            .await
    }
```

**File:** consensus/src/liveness/round_state.rs (L306-316)
```rust
    pub fn insert_round_timeout(
        &mut self,
        timeout: &RoundTimeout,
        verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        if timeout.round() == self.current_round {
            self.pending_votes.insert_round_timeout(timeout, verifier)
        } else {
            VoteReceptionResult::UnexpectedRound(timeout.round(), self.current_round)
        }
    }
```
