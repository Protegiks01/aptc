# Audit Report

## Title
Panic Path in CompiledScript Deserialization Bypasses Error Handling in move-disassembler

## Summary
The `CompiledScript::deserialize()` function has an unprotected panic path that can crash the move-disassembler tool when processing malformed bytecode. Unlike `CompiledModule::deserialize()`, which wraps deserialization in `std::panic::catch_unwind()`, script deserialization lacks this protection, allowing crafted input to trigger panics that bypass the `.expect()` error handling in main.rs.

## Finding Description

The vulnerability stems from an asymmetry in panic protection between module and script deserialization: [1](#0-0) 

The module deserialization wraps the entire process in `std::panic::catch_unwind()`, converting any panics to `VERIFIER_INVARIANT_VIOLATION` errors.

However, script deserialization lacks this protection: [2](#0-1) 

The panic occurs in `BoundsChecker::verify_script()` when accessing the signatures pool: [3](#0-2) 

The `.unwrap()` on line 66 will panic if `script.parameters` is an out-of-bounds index.

**Attack Path:**

1. During deserialization, `script.parameters` is loaded as a signature index: [4](#0-3) 

2. The `load_signature_index()` only validates the index is below `SIGNATURE_INDEX_MAX` (65535): [5](#0-4) [6](#0-5) 

3. The signatures pool is built afterward, potentially with fewer entries than the index value
4. When `BoundsChecker::verify_script()` attempts to access `signatures().get(script.parameters)`, if the index exceeds the pool size, `.get()` returns `None`
5. The `.unwrap()` panics, crashing the tool

The tool invocation in main.rs cannot catch this panic: [7](#0-6) 

## Impact Explanation

This is a **Medium Severity** vulnerability for the following reasons:

1. **Tool Availability Impact**: An attacker can crash the move-disassembler tool by providing malformed bytecode files, causing denial of service for developers and auditors attempting to analyze bytecode
2. **Production System Risk**: If move-disassembler or similar deserialization code paths are used in production systems (e.g., blockchain explorers, verification services), this could cause service crashes
3. **Asymmetric Protection**: The fact that modules have panic protection but scripts don't suggests developers were aware of panic risks but failed to apply the fix consistently

While this doesn't directly affect consensus or funds, it represents a significant implementation bug that violates the **Move VM Safety** invariant requiring robust bytecode handling.

## Likelihood Explanation

**Likelihood: High**

- **Ease of Exploitation**: Trivial - an attacker only needs to craft a malformed bytecode file with an out-of-bounds signature index
- **Attack Surface**: Any system accepting user-provided Move bytecode for disassembly is vulnerable
- **Detection**: The panic will occur before any transaction execution, making it exploitable pre-deployment
- **No Special Privileges Required**: Any user can provide a malformed bytecode file

## Recommendation

Apply the same panic protection to `CompiledScript::deserialize_with_config()` that exists for modules:

```rust
impl CompiledScript {
    pub fn deserialize_with_config(
        binary: &[u8],
        config: &DeserializerConfig,
    ) -> BinaryLoaderResult<Self> {
        let prev_state = move_core_types::state::set_state(VMState::DESERIALIZER);
        let result = std::panic::catch_unwind(|| {
            let script = deserialize_compiled_script(binary, config)?;
            BoundsChecker::verify_script(&script)?;
            Ok(script)
        })
        .unwrap_or_else(|_| {
            Err(PartialVMError::new(
                StatusCode::VERIFIER_INVARIANT_VIOLATION,
            ))
        });
        move_core_types::state::set_state(prev_state);
        
        result
    }
}
```

**Alternative Fix**: Replace the `.unwrap()` in `BoundsChecker::verify_script()` with proper error handling:

```rust
bounds_check
    .view
    .signatures()
    .get(script.parameters.into_index())
    .ok_or_else(|| {
        bounds_error(
            IndexKind::Signature,
            script.parameters.into_index()
        )
    })?,
```

## Proof of Concept

```rust
// Create a minimal malformed script bytecode
// This would be a binary file with:
// 1. Valid header and magic bytes
// 2. A signatures table with only 1 entry
// 3. script.parameters set to index 100 (out of bounds)
// 4. Valid code unit

use move_binary_format::file_format::CompiledScript;

fn main() {
    // Craft bytecode with out-of-bounds signature index
    let malformed_bytecode = craft_malformed_script_bytecode();
    
    // This will panic instead of returning an error
    let result = CompiledScript::deserialize(&malformed_bytecode);
    
    // The expect() below never gets a chance to run because
    // the panic occurs inside deserialize()
    let _script = result.expect("Should return error, not panic");
}

fn craft_malformed_script_bytecode() -> Vec<u8> {
    // Build a Move script bytecode where:
    // - signatures table has 1 entry (index 0 only)
    // - script.parameters = SignatureIndex(100) (out of bounds)
    // When BoundsChecker tries signatures().get(100).unwrap()
    // it will panic
    
    let mut bytecode = vec![
        0xA1, 0x1C, 0xEB, 0x0B,  // Magic bytes
        0x08,                     // Version 8
    ];
    
    // Build minimal tables with signature index out of bounds
    // (detailed bytecode construction omitted for brevity)
    
    bytecode
}
```

**Notes**

The vulnerability is confirmed by the presence of panic protection in `CompiledModule::deserialize_with_config()` but not in `CompiledScript::deserialize_with_config()`, indicating developers were aware of panic risks but failed to apply the protection consistently. The `.unwrap()` call in bounds checking is the specific panic trigger.

### Citations

**File:** third_party/move/move-binary-format/src/deserializer.rs (L27-34)
```rust
    pub fn deserialize_with_config(
        binary: &[u8],
        config: &DeserializerConfig,
    ) -> BinaryLoaderResult<Self> {
        let script = deserialize_compiled_script(binary, config)?;
        BoundsChecker::verify_script(&script)?;
        Ok(script)
    }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L52-71)
```rust
    pub fn deserialize_with_config(
        binary: &[u8],
        config: &DeserializerConfig,
    ) -> BinaryLoaderResult<Self> {
        let prev_state = move_core_types::state::set_state(VMState::DESERIALIZER);
        let result = std::panic::catch_unwind(|| {
            let module = deserialize_compiled_module(binary, config)?;
            BoundsChecker::verify_module(&module)?;

            Ok(module)
        })
        .unwrap_or_else(|_| {
            Err(PartialVMError::new(
                StatusCode::VERIFIER_INVARIANT_VIOLATION,
            ))
        });
        move_core_types::state::set_state(prev_state);

        result
    }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L214-219)
```rust
fn load_signature_index(cursor: &mut VersionedCursor) -> BinaryLoaderResult<SignatureIndex> {
    Ok(SignatureIndex(read_uleb_internal(
        cursor,
        SIGNATURE_INDEX_MAX,
    )?))
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L450-450)
```rust
    let parameters = load_signature_index(&mut cursor)?;
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L59-68)
```rust
        bounds_check.check_code(
            &script.code,
            &script.type_parameters,
            bounds_check
                .view
                .signatures()
                .get(script.parameters.into_index())
                .unwrap(),
            CompiledScript::MAIN_INDEX.into_index(),
        )
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-44)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
pub const SIGNATURE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```

**File:** third_party/move/tools/move-disassembler/src/main.rs (L98-106)
```rust
    let bytecode = if args.is_script {
        script = CompiledScript::deserialize(&bytecode_bytes)
            .expect("Script blob can't be deserialized");
        BinaryIndexedView::Script(&script)
    } else {
        module = CompiledModule::deserialize(&bytecode_bytes)
            .expect("Module blob can't be deserialized");
        BinaryIndexedView::Module(&module)
    };
```
