# Audit Report

## Title
Governance-Enabled Network-Wide DoS via Unvalidated Gas Parameter Allowing Saturation Overflow in Intrinsic Gas Calculation

## Summary
An attacker with sufficient governance voting power can set `intrinsic_gas_per_byte` to `u64::MAX` through on-chain governance proposals without any validation, causing all transactions larger than 600 bytes to fail validation due to saturating arithmetic overflow in the intrinsic gas calculation. This results in a total loss of network liveness for most practical transactions.

## Finding Description

The vulnerability exists across multiple components in the gas parameter system:

**1. Missing Validation in Governance Updates** [1](#0-0) 

The `set_for_next_epoch` function accepts arbitrary gas parameter values without validation. The only checks are that the blob is non-empty and the feature version doesn't decrease. [2](#0-1) 

Multiple TODO comments throughout the file explicitly note that validation is missing but never implemented.

**2. Saturating Multiplication in Gas Algebra** [3](#0-2) 

The multiplication operation uses `saturating_mul`, which silently saturates to `u64::MAX` on overflow instead of detecting the error.

**3. Intrinsic Gas Calculation** [4](#0-3) 

The function calculates `MIN_TRANSACTION_GAS_UNITS + INTRINSIC_GAS_PER_BYTE * excess`. When `intrinsic_gas_per_byte` is `u64::MAX` and excess > 0, the multiplication saturates to `u64::MAX`.

**4. Transaction Validation Check** [5](#0-4) 

The validation converts the saturated intrinsic gas value (~18.4 trillion Gas units after scaling factor division) and compares it against the transaction's `max_gas_amount`, which is capped at 2 million in production. [6](#0-5) 

**Attack Path:**

1. Attacker creates a governance proposal to update gas parameters with `intrinsic_gas_per_byte` set to `u64::MAX`
2. Proposal passes through normal governance voting (requires sufficient stake/voting power)
3. At next epoch, the malicious gas schedule is applied
4. For any transaction with size > `large_transaction_cutoff` (600 bytes):
   - `excess = transaction_size - 600`
   - `intrinsic_gas = MIN_TRANSACTION_GAS_UNITS + u64::MAX * excess` → saturates to `u64::MAX`
   - After conversion to Gas units: ~18,446,744,073,710 gas units required
   - Transaction's `max_gas_amount` (max 2,000,000) < required gas → transaction rejected with `MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS`
5. All transactions above 600 bytes become impossible to execute, effectively halting the network

## Impact Explanation

This vulnerability qualifies as **HIGH Severity** under the Aptos bug bounty criteria:

- **Total loss of network availability**: Nearly all practical transactions (token transfers, smart contract calls, governance proposals) exceed 600 bytes and would become impossible to execute
- **Non-recoverable without hardfork**: Once applied, the malicious gas schedule persists across epochs. Even governance proposals to fix it would fail (they exceed 600 bytes themselves), requiring emergency hardfork intervention
- **Validator node impact**: All validator nodes would consistently reject legitimate transactions, causing consensus on empty blocks only

While this requires governance access (not completely unprivileged), it doesn't require validator insider access or collusion - only sufficient governance voting power, which is achievable through token acquisition or coalition building in a permissionless system.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attack Requirements:**
- Sufficient governance voting power to pass a proposal (~50% of participating stake)
- Knowledge of the missing validation (now publicly disclosed)
- Ability to craft a malicious gas schedule proposal

**Mitigating Factors:**
- Requires significant stake or coalition building
- Governance voting period provides time for detection (though defenders face same 600-byte limit once applied)
- Community monitoring of governance proposals

**Aggravating Factors:**
- No validation exists to prevent this
- TODO comments indicate developers knew validation was needed but never implemented it
- Similar validation exists for storage gas parameters, showing the pattern was understood but not applied consistently
- Attack is deterministic once governance approves it
- Recovery requires emergency hardfork since fixing proposals can't execute

## Recommendation

Implement comprehensive validation for all gas parameters in `gas_schedule.move`:

```move
/// Validate that gas schedule parameters are within reasonable bounds
fun validate_gas_schedule(schedule: &GasScheduleV2) {
    // Define maximum reasonable values for gas parameters
    const MAX_REASONABLE_GAS_PER_BYTE: u64 = 1_000_000; // 1M internal gas units
    const MAX_REASONABLE_MIN_GAS: u64 = 100_000_000; // 100M internal gas units
    
    // Iterate through entries and validate critical parameters
    let i = 0;
    let len = vector::length(&schedule.entries);
    while (i < len) {
        let entry = vector::borrow(&schedule.entries, i);
        
        // Validate intrinsic_gas_per_byte specifically
        if (entry.key == b"txn.intrinsic_gas_per_byte") {
            assert!(
                entry.val <= MAX_REASONABLE_GAS_PER_BYTE,
                error::invalid_argument(EINVALID_GAS_PARAMETER_VALUE)
            );
        };
        
        // Add similar checks for other critical parameters
        if (entry.key == b"txn.min_transaction_gas_units") {
            assert!(
                entry.val <= MAX_REASONABLE_MIN_GAS,
                error::invalid_argument(EINVALID_GAS_PARAMETER_VALUE)
            );
        };
        
        i = i + 1;
    };
}

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD VALIDATION HERE
    validate_gas_schedule(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

Additionally, consider using checked arithmetic instead of saturating arithmetic in gas calculations: [3](#0-2) 

Replace `saturating_mul` with `checked_mul` and handle overflow appropriately, similar to how `checked_sub` is already used for subtraction operations.

## Proof of Concept

```rust
// File: test_gas_overflow_dos.rs
#[test]
fn test_intrinsic_gas_overflow_dos() {
    use aptos_gas_schedule::{AptosGasParameters, VMGasParameters};
    use aptos_types::on_chain_config::GasScheduleV2;
    use move_core_types::gas_algebra::NumBytes;
    
    // Create gas parameters with intrinsic_gas_per_byte set to u64::MAX
    let mut gas_params = AptosGasParameters::initial();
    gas_params.vm.txn.intrinsic_gas_per_byte = u64::MAX.into();
    
    // Test with a transaction slightly over the cutoff (601 bytes)
    let txn_size: NumBytes = 601.into();
    
    // Calculate intrinsic gas - this will saturate to u64::MAX
    let intrinsic_gas = gas_params.vm.txn
        .calculate_intrinsic_gas(txn_size)
        .evaluate(14, &gas_params.vm);
    
    // Convert to Gas units with scaling factor (1,000,000)
    let total_gas = intrinsic_gas
        .to_unit_round_up_with_params(&gas_params.vm.txn);
    
    // Maximum allowed gas in production
    let max_gas_amount = 2_000_000u64;
    
    // Verify the DoS condition: required gas far exceeds maximum allowed
    assert!(u64::from(total_gas) > max_gas_amount);
    println!("Required gas: {}", u64::from(total_gas));
    println!("Maximum allowed: {}", max_gas_amount);
    println!("Transaction would be rejected!");
    
    // Expected output:
    // Required gas: 18446744073710
    // Maximum allowed: 2000000
    // Transaction would be rejected!
}
```

This PoC demonstrates that with `intrinsic_gas_per_byte = u64::MAX`, even a 601-byte transaction requires ~18.4 trillion gas units, which exceeds the 2 million maximum by a factor of ~9 billion, making execution impossible.

---

**Notes**

The vulnerability is confirmed across multiple components with clear citations. The missing validation in `gas_schedule.move` combined with saturating arithmetic in `gas_algebra.rs` creates a governance-exploitable DoS vector. While the attack requires governance access, it meets the HIGH severity criteria due to its catastrophic impact on network availability and the difficulty of recovery. The issue breaks the "Resource Limits" and "Move VM Safety" invariants by allowing gas calculations to produce meaningless values that make legitimate transactions impossible to execute.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L229-231)
```rust
fn mul_impl<U1, U2>(x: GasQuantity<U2>, y: GasQuantity<UnitDiv<U1, U2>>) -> GasQuantity<U1> {
    GasQuantity::new(x.val.saturating_mul(y.val))
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L301-310)
```rust
    pub fn calculate_intrinsic_gas(
        &self,
        transaction_size: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        let excess = transaction_size
            .checked_sub(self.large_transaction_cutoff)
            .unwrap_or_else(|| 0.into());

        MIN_TRANSACTION_GAS_UNITS + INTRINSIC_GAS_PER_BYTE * excess
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```
