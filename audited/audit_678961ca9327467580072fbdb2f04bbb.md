# Audit Report

## Title
Complete Absence of Execution Pool Window Validation Allows Invalid Block Dependencies

## Summary
The `verify_window_contents()` function in the consensus observer performs **zero validation** on execution pool window contents, despite being called as a critical security check. The function is completely unimplemented with only a TODO comment, allowing arbitrary block dependency information to pass validation. [1](#0-0) 

## Finding Description

The `process_ordered_block_with_window_message()` function calls `verify_window_contents()` to validate the execution pool window before processing ordered blocks with dependency information. [2](#0-1) 

However, `verify_window_contents()` performs **no validation whatsoever** - it simply returns `Ok(())` with a TODO comment. The `ExecutionPoolWindow` structure contains a vector of block IDs representing parent block hashes in chronological order, but none of the following critical validations are performed:

1. **Window size validation**: Whether `block_ids.len()` satisfies the window size constraint (should be < window_size)
2. **Chronological ordering**: Whether blocks are in correct round order
3. **Parent chain validity**: Whether block IDs form a valid parent chain
4. **Round constraints**: Whether blocks satisfy `round > current_block.round() - window_size` as implemented in `get_ordered_block_window()`
5. **Connectivity**: Whether the window connects to the ordered block's parent
6. **Existence**: Whether block IDs reference actual blocks [3](#0-2) 

The `get_ordered_block_window()` implementation shows how windows should be constructed and validated - blocks must follow the parent chain and satisfy round constraints. The calculation uses `calculate_window_start_round()` to determine valid rounds. [4](#0-3) 

## Impact Explanation

**Current Impact: LOW** - The feature is not yet operational. After validation passes, messages are currently dropped rather than processed. [5](#0-4) 

**Future Impact: HIGH to CRITICAL** - Once the TODO is implemented and execution pool is enabled via on-chain configuration, this could cause:

- **State Divergence**: Different observers receiving different windows for the same blocks would execute them with different dependencies, violating the **Deterministic Execution** invariant
- **Execution Failures**: Invalid block IDs causing execution pipeline crashes
- **Consensus Safety Violations**: Incorrect execution dependencies could lead to different state roots between nodes

Execution pool is controlled by `window_size` in the on-chain consensus configuration (V4/V5): [6](#0-5) 

## Likelihood Explanation

**Current Likelihood: NONE** - Feature not implemented.

**Future Likelihood: MEDIUM** - Requires:
1. Execution pool enabled via on-chain governance (currently disabled by default)
2. TODO implementation completed
3. **Malicious or compromised validator** sending invalid windows, OR network-level message modification

**Critical Limitation**: This bug requires a **validator with publisher privileges** to send malicious `OrderedBlockWithWindow` messages. Consensus observers only accept messages from subscribed publishers (validators). [7](#0-6) 

Per the trust model specification, this requires "privileged validator access," which is explicitly stated as outside the scope of unprivileged attacker scenarios. However, BFT consensus protocols are designed to tolerate Byzantine validators (up to 1/3), making receiver-side validation a critical defense-in-depth measure.

## Recommendation

Implement comprehensive validation in `verify_window_contents()`:

```rust
pub fn verify_window_contents(&self, expected_window_size: u64) -> Result<(), Error> {
    // Validate window size constraint
    if self.block_ids.len() >= expected_window_size as usize {
        return Err(Error::InvalidMessageError(format!(
            "Window size {} exceeds maximum {}",
            self.block_ids.len(), expected_window_size - 1
        )));
    }
    
    // Validate non-empty if window size > 1
    if expected_window_size > 1 && self.block_ids.is_empty() {
        return Err(Error::InvalidMessageError(
            "Window is empty but window_size > 1".to_string()
        ));
    }
    
    // Additional validations when blocks are available:
    // - Verify chronological ordering by round
    // - Verify parent chain connectivity  
    // - Verify round constraints per window_size
    // - Verify block IDs exist and are accessible
    
    Ok(())
}
```

The validation should be implemented **before** the feature becomes operational to prevent future security issues.

## Proof of Concept

Cannot provide a working PoC because:
1. The feature is not implemented (messages are dropped after validation)
2. Requires validator privileges to send `OrderedBlockWithWindow` messages
3. Requires execution pool to be enabled via on-chain governance

However, the vulnerability is evident from the code itself - the function explicitly returns `Ok(())` without any validation logic.

---

## Notes

**Validation Checklist Assessment:**
- [✓] Vulnerability lies within Aptos Core codebase 
- [✗] **Exploitable by unprivileged attacker** - Requires validator access
- [✗] **Current impact** - Feature not yet implemented (TODO at line 895)
- [✓] Would break invariants if exploited (Deterministic Execution, Consensus Safety)

This represents a **defense-in-depth failure** and **incomplete implementation** rather than a currently exploitable vulnerability. The missing validation should be implemented before the feature becomes operational, but it does not meet the criteria for an immediately exploitable bug by unprivileged attackers.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L329-332)
```rust
    /// Verifies the execution pool window contents and returns an error if the data is invalid
    pub fn verify_window_contents(&self, _expected_window_size: u64) -> Result<(), Error> {
        Ok(()) // TODO: Implement this method!
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L578-594)
```rust
        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L849-867)
```rust
        // Verify the execution pool window contents
        let execution_pool_window = ordered_block_with_window.execution_pool_window();
        if let Err(error) = execution_pool_window.verify_window_contents(execution_pool_window_size)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify execution pool window contents! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L895-896)
```rust
        // TODO: process the ordered block with window message (instead of just dropping it!)
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L264-305)
```rust
    pub fn get_ordered_block_window(
        &self,
        block: &Block,
        window_size: Option<u64>,
    ) -> anyhow::Result<OrderedBlockWindow> {
        // Block round should never be less than the commit root round
        ensure!(
            block.round() >= self.commit_root().round(),
            "Block round {} is less than the commit root round {}, cannot get_ordered_block_window",
            block.round(),
            self.commit_root().round()
        );

        // window_size is None only if execution pool is turned off
        let Some(window_size) = window_size else {
            return Ok(OrderedBlockWindow::empty());
        };
        let round = block.round();
        let window_start_round = calculate_window_start_round(round, window_size);
        let window_size = round - window_start_round + 1;
        ensure!(window_size > 0, "window_size must be greater than 0");

        let mut window = vec![];
        let mut current_block = block.clone();

        // Add each block to the window until you reach the start round
        while !current_block.is_genesis_block()
            && current_block.quorum_cert().certified_block().round() >= window_start_round
        {
            if let Some(current_pipelined_block) = self.get_block(&current_block.parent_id()) {
                current_block = current_pipelined_block.block().clone();
                window.push(current_pipelined_block);
            } else {
                bail!("Parent block not found for block {}", current_block.id());
            }
        }

        // The window order is lower round -> higher round
        window.reverse();
        ensure!(window.len() < window_size as usize);
        Ok(OrderedBlockWindow::new(window))
    }
```

**File:** consensus/src/util/mod.rs (L26-29)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L404-412)
```rust
    pub fn window_size(&self) -> Option<u64> {
        match self {
            OnChainConsensusConfig::V1(_)
            | OnChainConsensusConfig::V2(_)
            | OnChainConsensusConfig::V3 { .. } => None,
            OnChainConsensusConfig::V4 { window_size, .. }
            | OnChainConsensusConfig::V5 { window_size, .. } => *window_size,
        }
    }
```
