# Audit Report

## Title
Supply Chain Attack via Spec Module Attribute Injection Causing Silent Module Removal from Production Builds

## Summary
A malicious dependency can provide a specification module with attributes (such as `#[test_only]`) that override a source module's specification, causing the target module to inherit those attributes and be completely excluded from production compilation. This creates a silent supply chain attack vector that can remove arbitrary modules from the blockchain runtime without any warning.

## Finding Description

The vulnerability exists in the spec module merging process where duplicate spec modules are not validated, and the merge order allows lib_definitions (dependencies) to override source_definitions. [1](#0-0) 

The compilation pipeline processes spec modules in this order:
1. Spec modules from source_definitions are extracted first and added to a shared BTreeMap
2. Spec modules from lib_definitions are extracted second and can **overwrite** entries with the same key (address, module_name)
3. The TODO comment indicates this was never implemented: [2](#0-1) 

During the merge phase, spec module **attributes are extended** into the target module: [3](#0-2) 

The compilation pipeline order is critical: [4](#0-3) 

After spec modules are merged, the filter_test_members pass removes modules with `#[test_only]` attributes in production builds: [5](#0-4) 

The filtering logic removes nodes with test attributes when not in test mode: [6](#0-5) 

**Attack Path:**
1. Attacker publishes a malicious dependency containing a spec module for a target module (e.g., `0x1::CriticalModule`)
2. The malicious spec module has a `#[test_only]` attribute
3. During compilation, the malicious spec module overwrites any legitimate spec module from source
4. The spec module (with its malicious attribute) is merged into the target module
5. The filter_test_members pass sees the `#[test_only]` attribute and removes the **entire module** from the production build
6. The module is completely missing from the compiled bytecode with no error or warning

This breaks the **Deterministic Execution** invariant because different nodes with different dependency versions will compile different code, producing different state roots for identical blocks.

## Impact Explanation

**Severity: Critical**

This vulnerability meets Critical severity criteria:

1. **Consensus/Safety Violations**: Different validators with different dependency versions will have different modules in their runtime, causing consensus divergence and potential chain splits. This directly violates invariant #1 (Deterministic Execution).

2. **Permanent Freezing of Funds**: If a module managing funds (like a token module or DeFi protocol) is removed, those funds become inaccessible and permanently frozen, requiring a hardfork to recover.

3. **Non-recoverable Network Partition**: If critical system modules are targeted and different nodes have different dependencies, the network could partition in an unrecoverable way.

4. **Loss of Funds**: Applications relying on removed modules will fail, potentially causing loss of user funds through failed transactions or inaccessible state.

The attack is particularly dangerous because:
- It's completely silent - no errors or warnings are generated
- It affects production builds while appearing correct in test mode
- It can target framework modules at address `0x1` if they have dependencies
- Code review won't detect it as the malicious code is in a dependency's spec module

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to occur because:

1. **Low Barrier to Entry**: Any user can publish a package that others depend on
2. **No Validation**: The TODO comment confirms duplicate spec module checking was never implemented
3. **Stealth Attack**: Spec modules are rarely inspected during dependency review since they're considered documentation/verification only
4. **Wide Target Surface**: Any module with a known address and name can be targeted
5. **No Runtime Detection**: The issue manifests silently during compilation with no errors

The only requirement is that the target uses the malicious package as a dependency, which is common in the Move ecosystem where code reuse is encouraged.

## Recommendation

Implement duplicate spec module validation and enforce strict namespacing rules:

```rust
fn extract_spec_module(
    spec_modules: &mut BTreeMap<(Option<LeadingNameAccess_>, Symbol), ModuleDefinition>,
    address_opt: Option<&LeadingNameAccess_>,
    m: ModuleDefinition,
) -> Option<ModuleDefinition> {
    if m.is_spec_module {
        let key = module_key(address_opt, &m);
        // Check for duplicate spec modules and report error
        if let Some(existing) = spec_modules.get(&key) {
            // Report duplicate spec module error
            compilation_env.add_diag(diag!(
                Declarations::InvalidSpec,
                (m.name.loc(), "Duplicate spec module found"),
                (existing.name.loc(), "Previously defined here")
            ));
        } else {
            spec_modules.insert(key, m);
        }
        None
    } else {
        Some(m)
    }
}
```

Additionally, prevent lib_definitions from providing spec modules for addresses they don't own, or at minimum issue warnings when spec modules in dependencies override source spec modules.

## Proof of Concept

```move
// ============= SOURCE CODE (User's Project) =============
// File: sources/CriticalModule.move
module 0x1::CriticalModule {
    public fun manage_funds(amount: u64): u64 {
        amount * 2
    }
}

// File: sources/CriticalModule.spec.move
spec module 0x1::CriticalModule {
    spec manage_funds {
        ensures result == amount * 2;
    }
}

// ============= MALICIOUS DEPENDENCY =============
// File: malicious_dep/sources/attack.spec.move
#[test_only]
spec module 0x1::CriticalModule {
    // Empty or benign specifications that will override source specs
    // The #[test_only] attribute will be merged into CriticalModule
}

// ============= COMPILATION BEHAVIOR =============
// When compiling in production mode (test_mode = false):
// 1. extract_spec_modules extracts source spec module -> spec_modules[(0x1, CriticalModule)]
// 2. extract_spec_modules extracts lib spec module -> OVERWRITES spec_modules[(0x1, CriticalModule)]
// 3. merge_spec_modules merges malicious spec (with #[test_only]) into CriticalModule
// 4. filter_test_members removes CriticalModule entirely from compilation
// 5. RESULT: CriticalModule.mv does NOT exist in build/artifacts
// 6. Runtime calls to 0x1::CriticalModule::manage_funds FAIL with "module not found"

// To demonstrate this issue, compile a Move package with:
// 1. A source module M
// 2. A spec module for M in sources/
// 3. A dependency containing spec module for M with #[test_only]
// 4. Compile in production mode
// 5. Observe that module M is missing from compiled output
```

**Notes:**

The vulnerability is particularly severe because spec modules were designed as a documentation/verification mechanism that should have zero impact on runtime behavior. However, by allowing attributes from spec modules to be merged into runtime modules, and by not validating duplicate spec modules across source and library boundaries, the compiler creates a silent supply chain attack vector. This could be exploited to remove critical Aptos framework modules, DeFi protocols, or governance modules from production builds, causing catastrophic consensus failures and fund loss across the network.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L33-36)
```rust
    let mut spec_modules = BTreeMap::new();
    let mut source_definitions = extract_spec_modules(&mut spec_modules, source_definitions);
    let mut lib_definitions = extract_spec_modules(&mut spec_modules, lib_definitions);

```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L114-114)
```rust
        // TODO check for duplicate spec modules?
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L147-159)
```rust
    if let Some(spec_module) = spec_modules.remove(&module_key(address_opt, m)) {
        let ModuleDefinition {
            attributes,
            members,
            loc: _,
            address: _,
            name: _,
            is_spec_module,
        } = spec_module;
        assert!(is_spec_module);
        m.attributes.extend(attributes);
        m.members.extend(members);
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/command_line/compiler.rs (L581-583)
```rust
            let prog = parser::merge_spec_modules::program(compilation_env, prog);
            let prog = unit_test::filter_test_members::program(compilation_env, prog);
            let prog = verification::ast_filter::program(compilation_env, prog);
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L38-45)
```rust
    fn filter_map_module(
        &mut self,
        mut module_def: P::ModuleDefinition,
        is_source_def: bool,
    ) -> Option<P::ModuleDefinition> {
        if self.should_remove_by_attributes(&module_def.attributes, is_source_def) {
            return None;
        }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L224-235)
```rust
fn should_remove_node(env: &CompilationEnv, attrs: &[P::Attributes], is_source_def: bool) -> bool {
    use known_attributes::TestingAttribute;
    let flattened_attrs: Vec<_> = attrs.iter().flat_map(test_attributes).collect();
    let is_test_only = flattened_attrs
        .iter()
        .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly));
    is_test_only && !env.flags().keep_testing_functions()
        || (!is_source_def
            && flattened_attrs
                .iter()
                .any(|attr| attr.1 == TestingAttribute::Test))
}
```
