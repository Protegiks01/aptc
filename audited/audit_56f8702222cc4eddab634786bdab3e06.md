# Audit Report

## Title
Gas Accounting Bypass in View Function Argument Construction with Eager Loading

## Summary
When eager module loading is enabled (ENABLE_LAZY_LOADING feature flag disabled), view function argument construction completely bypasses gas metering by using `UnmeteredGasMeter`. This allows attackers to perform expensive module loading and constructor execution operations without gas accounting, enabling DoS attacks and rate limiting bypasses against fullnodes serving view function requests.

## Finding Description

The `validate_view_function` function in `view_function.rs` conditionally meters gas based on whether lazy loading is enabled: [1](#0-0) 

When lazy loading is disabled (eager loading mode), the code creates a new `UnmeteredGasMeter` instead of using the production gas meter passed as a parameter. This `UnmeteredGasMeter` is then passed to `construct_args`, which performs argument construction including:

1. **Module loading for constructors**: The `load_constructor_function` calls `loader.load_function_definition(gas_meter, traversal_context, ...)`: [2](#0-1) 

2. **Constructor function execution**: The `validate_and_construct` calls `session.execute_loaded_function(..., gas_meter, ...)`: [3](#0-2) 

With `UnmeteredGasMeter`, all charge operations return `Ok(())` without tracking any gas: [4](#0-3) 

The view function execution flow creates a production gas meter but then fails to use it during argument construction: [5](#0-4) 

Additionally, view functions always use `LegacyLoaderConfig::unmetered()` when loading the function itself, skipping upfront dependency gas charging even with eager loading: [6](#0-5) 

**Attack Path:**
1. Attacker identifies a network where ENABLE_LAZY_LOADING is disabled (eager loading active)
2. Crafts view function calls with complex struct arguments requiring constructor functions from framework modules (e.g., `String`, `Object`, `Option`, `FixedPoint32`, `FixedPoint64`)
3. Each constructor invocation loads modules and executes code without gas metering
4. Up to 10 constructor invocations are allowed per argument: [7](#0-6) 

5. Multiple arguments can each trigger 10 invocations, multiplying the unmetered work
6. The returned `gas_used` value is artificially low, not including argument construction costs
7. Rate limiting mechanisms based on `gas_used` can be bypassed
8. Repeated calls exhaust fullnode resources

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Resource Exhaustion**: Attackers can force expensive operations (module loading, constructor execution) without proper gas accounting, leading to CPU and memory exhaustion on fullnodes
- **Rate Limiting Bypass**: The `gas_used` value returned via `X-Aptos-Gas-Used` header is understated, allowing attackers to bypass gas-based rate limiting: [8](#0-7) 

- **State Inconsistency**: Inaccurate gas reporting violates the invariant that all operations must be properly metered
- **Limited Scope**: Only affects fullnode API availability, not consensus or validator operations
- **Does not directly cause funds loss** but enables DoS against node infrastructure

## Likelihood Explanation

**Likelihood: Medium**

**Factors increasing likelihood:**
- View functions are publicly accessible via API without authentication
- Constructor functions for framework types are legitimate and commonly used
- The code explicitly handles eager loading mode, suggesting it's a supported configuration
- No special privileges required to exploit

**Factors decreasing likelihood:**
- ENABLE_LAZY_LOADING (feature flag #95) appears to be the default/preferred mode based on AIP-127: [9](#0-8) 

- Networks using lazy loading (likely mainnet) are not affected
- Constructor invocations limited to 10 per argument
- Only framework modules (special addresses) can have constructor functions
- View functions already have `max_gas_view_function` limits

The vulnerability is exploitable when eager loading is active, making it configuration-dependent but still a legitimate security concern.

## Recommendation

**Fix 1: Always use the production gas meter for argument construction**

Remove the conditional branching and always pass the production `gas_meter` and `traversal_context` to `construct_args`, regardless of lazy/eager loading mode:

```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // ... validation checks ...
    
    let allowed_structs = get_allowed_structs(struct_constructors_feature);
    // Always use the provided gas_meter, regardless of loading mode
    let result = transaction_arg_validation::construct_args(
        session,
        loader,
        gas_meter,  // Always use production meter
        traversal_context,  // Always use provided context
        func.param_tys(),
        args,
        func.ty_args(),
        allowed_structs,
        true,
    );
    result.map_err(|e| PartialVMError::new(e.status_code()))
}
```

**Fix 2: Use metered config for view function module loading**

Update `execute_view_function_in_vm` to charge gas for dependency loading:

```rust
let legacy_loader_config = LegacyLoaderConfig {
    charge_for_dependencies: true,
    charge_for_ty_tag_dependencies: true,
};
let func = loader.load_instantiated_function(
    &legacy_loader_config,  // Use metered config
    gas_meter,
    traversal_context,
    &module_id,
    &func_name,
    &ty_args,
)?;
```

This ensures accurate gas accounting regardless of lazy/eager loading configuration.

## Proof of Concept

```rust
// File: aptos-move/aptos-vm/tests/view_function_gas_bypass_test.rs

#[test]
fn test_view_function_gas_bypass_with_eager_loading() {
    use aptos_vm::AptosVM;
    use aptos_types::{
        account_address::AccountAddress,
        state_store::StateView,
        transaction::ViewFunctionError,
    };
    use move_core_types::{
        identifier::Identifier,
        language_storage::{ModuleId, TypeTag},
    };
    
    // Setup: Create a view function that takes complex struct arguments
    // requiring multiple constructor invocations
    
    // Deploy a view function that takes multiple String arguments
    let module_id = ModuleId::new(
        AccountAddress::from_hex_literal("0x1").unwrap(),
        Identifier::new("test_module").unwrap(),
    );
    
    // Craft arguments with 10 nested String constructors to maximize unmetered work
    let mut args = vec![];
    for _ in 0..10 {
        // Each String argument requires utf8() constructor invocation
        let string_bytes = b"A".repeat(1000); // Large string to maximize work
        args.push(bcs::to_bytes(&string_bytes).unwrap());
    }
    
    // Execute with max gas
    let max_gas = 1_000_000;
    
    // Case 1: With lazy loading (expected: proper gas metering)
    // Case 2: With eager loading (vulnerable: UnmeteredGasMeter used)
    
    let output = AptosVM::execute_view_function(
        &state_view,
        module_id,
        Identifier::new("view_with_many_strings").unwrap(),
        vec![],
        args.clone(),
        max_gas,
    );
    
    // With eager loading, gas_used will be artificially low
    // because argument construction (10 constructor calls) is not metered
    assert!(output.gas_used < expected_gas_for_constructors);
    
    // Attacker can repeatedly call this to exhaust resources
    // while bypassing gas-based rate limiting
}
```

**Notes:**

The vulnerability stems from the design decision to use `UnmeteredGasMeter` with eager loading, combined with `LegacyLoaderConfig::unmetered()` for view functions. While the comment indicates this is intentional ("No metering with eager loading"), it creates a security gap where expensive operations bypass gas accounting entirely. This breaks the invariant that all operations should respect gas limits and enables resource exhaustion attacks against fullnodes.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L64-90)
```rust
    let result = if loader.is_lazy_loading_enabled() {
        transaction_arg_validation::construct_args(
            session,
            loader,
            gas_meter,
            traversal_context,
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    } else {
        let traversal_storage = TraversalStorage::new();
        transaction_arg_validation::construct_args(
            session,
            loader,
            // No metering with eager loading.
            &mut UnmeteredGasMeter,
            &mut TraversalContext::new(&traversal_storage),
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    };
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L289-289)
```rust
            let mut max_invocations = 10; // Read from config in the future
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L503-511)
```rust
    let serialized_result = session.execute_loaded_function(
        function,
        args,
        gas_meter,
        traversal_context,
        loader,
        // No need to record the trace for argument construction.
        &mut NoOpTraceRecorder,
    )?;
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L596-597)
```rust
    let (module, function) =
        loader.load_function_definition(gas_meter, traversal_context, module_id, function_name)?;
```

**File:** third_party/move/move-vm/types/src/gas.rs (L424-431)
```rust
impl GasMeter for UnmeteredGasMeter {
    fn balance_internal(&self) -> InternalGas {
        u64::MAX.into()
    }

    fn charge_simple_instr(&mut self, _instr: SimpleInstruction) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2662-2689)
```rust
        let mut gas_meter = make_prod_gas_meter(
            vm.gas_feature_version(),
            vm_gas_params,
            storage_gas_params,
            /* is_approved_gov_script */ false,
            max_gas_amount.into(),
            &NoopBlockSynchronizationKillSwitch {},
        );

        let resolver = state_view.as_move_resolver();
        let module_storage = state_view.as_aptos_code_storage(&env);

        let mut session = vm.new_session(&resolver, SessionId::Void, None);

        let traversal_storage = TraversalStorage::new();
        let mut traversal_context = TraversalContext::new(&traversal_storage);
        let execution_result = Self::execute_view_function_in_vm(
            &mut session,
            &vm,
            module_id,
            func_name,
            type_args,
            arguments,
            &mut gas_meter,
            &mut traversal_context,
            &module_storage,
        );
        let gas_used = Self::gas_used(max_gas_amount.into(), &gas_meter);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2751-2758)
```rust
            let func = loader.load_instantiated_function(
                &LegacyLoaderConfig::unmetered(),
                gas_meter,
                traversal_context,
                &module_id,
                &func_name,
                &ty_args,
            )?;
```

**File:** api/src/view_function.rs (L234-236)
```rust
        output.gas_used,
    );
    result.map(|r| r.with_gas_used(Some(output.gas_used)))
```

**File:** types/src/on_chain_config/aptos_features.rs (L145-148)
```rust
    /// With lazy loading, modules are loaded lazily (as opposed to loading the transitive closure
    /// of dependencies). For more details, see:
    ///   AIP-127 (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-127.md)
    ENABLE_LAZY_LOADING = 95,
```
