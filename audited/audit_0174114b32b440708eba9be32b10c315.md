# Audit Report

## Title
Resource Group Validation Allows Forged StructTag Type Arguments Leading to Type System Violation and State Fragmentation

## Summary
The resource group validation in `resource_groups.rs` only validates the struct name when checking resource_group_member metadata, but does not verify that the StructTag's type arguments match the actual struct definition. This allows attackers to forge metadata with invalid type arguments (e.g., `ObjectGroup<u8>` when `ObjectGroup` has no type parameters), bypassing Move's type system and causing resource group fragmentation.

## Finding Description
When a module declares a struct as a `resource_group_member`, the container is specified as a StructTag in the module's metadata. At module publish time, the validation extracts this StructTag and validates it in `validate_resource_groups()`. [1](#0-0) 

The critical flaw is at line 91 where the validation only checks if the struct **name** exists as a resource group: [2](#0-1) 

The StructTag includes type arguments which are never validated against the actual struct definition. An attacker can:

1. Compile a module normally with valid `#[resource_group_member]` attribute
2. Modify the bytecode post-compilation to change the metadata string from `0x1::object::ObjectGroup` to `0x1::object::ObjectGroup<u8>`
3. Publish the modified module

The validation will:
- Extract `module_id()` from the forged StructTag (returns `0x1::object`)
- Check if module exists ✓
- Check if struct name "ObjectGroup" is a resource group ✓  
- **NOT** check if type arguments `<u8>` match the struct definition (ObjectGroup has no type parameters)
- Pass validation ✓

At runtime, when accessing resources of the attacker's struct type, the system uses the forged StructTag to create storage keys: [3](#0-2) 

This creates a StateKey for `ObjectGroup<u8>` which is distinct from the legitimate `ObjectGroup`, causing resources to be stored at incorrect locations.

Real resource groups like ObjectGroup are defined without type parameters: [4](#0-3) 

Yet the attacker can instantiate them with arbitrary type arguments, violating Move's type system.

## Impact Explanation
This is a **Medium Severity** vulnerability based on Aptos bug bounty criteria:

1. **State Inconsistencies**: Creates multiple resource group instances per address (e.g., `ObjectGroup`, `ObjectGroup<u8>`, `ObjectGroup<bool>`) fragmenting state
2. **Type System Violation**: Allows instantiation of structs with incorrect type arguments, breaking Move's core type safety guarantees
3. **Gas Accounting Bypass**: Resources split across fragmented groups may bypass shared gas charges intended for a single group
4. **Storage Manipulation**: Attackers can create unlimited group variants, affecting storage accounting and limits

While this doesn't directly cause fund loss or consensus breaks, it creates state inconsistencies requiring intervention and violates fundamental type system invariants that are critical to Move's security model.

## Likelihood Explanation
**Likelihood: Medium to High**

- Requires bytecode modification post-compilation (medium technical difficulty)
- No special permissions or validator access required
- Affects any module declaring resource_group_member relationships
- Global-scope groups like ObjectGroup are particularly vulnerable
- Attack is deterministic once bytecode is modified correctly

The attack is feasible for moderately skilled attackers who can:
1. Compile Move code
2. Parse and modify BCS-serialized metadata
3. Reserialize and publish the modified module

## Recommendation
The validation must verify that StructTag type arguments match the actual struct definition:

```rust
// In validate_resource_groups(), after line 86:
let old_module = module_storage.unmetered_get_existing_deserialized_module(
    group_module_id.address(),
    group_module_id.name(),
)?;

// Add validation for type arguments:
let struct_def = old_module.struct_defs().iter()
    .find(|def| {
        let handle = old_module.struct_handle_at(def.struct_handle);
        old_module.identifier_at(handle.name).as_str() == group_tag.name.as_str()
    })
    .ok_or_else(|| metadata_validation_error("Resource group struct not found"))?;

let struct_handle = old_module.struct_handle_at(struct_def.struct_handle);
let expected_type_param_count = struct_handle.type_parameters.len();

if group_tag.type_args.len() != expected_type_param_count {
    return Err(metadata_validation_error(
        "Resource group StructTag type argument count mismatch"
    ));
}
```

Additionally, validate that structs declared as resource groups have no type parameters: [5](#0-4) 

## Proof of Concept

**Step 1**: Create a malicious Move module:
```move
module attacker::malicious {
    use aptos_framework::object::ObjectGroup;
    
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MaliciousResource has key {
        value: u64
    }
}
```

**Step 2**: Compile the module normally (this will pass)

**Step 3**: Modify the compiled bytecode's metadata section:
- Locate the `aptos::metadata_v1` section
- Find the `resource_group_member` attribute for `MaliciousResource`
- Change the container string from `"0x1::object::ObjectGroup"` to `"0x1::object::ObjectGroup<u8>"`
- Reserialize the metadata

**Step 4**: Publish the modified module (validation will incorrectly pass)

**Step 5**: Create instances of `MaliciousResource` at various addresses

**Result**: Resources are stored at `StateKey::resource_group(address, StructTag { address: 0x1, module: "object", name: "ObjectGroup", type_args: [U8] })` instead of the legitimate group, creating fragmentation and type confusion.

**Notes**
This vulnerability exploits the gap between compile-time and runtime validation. The compiler validates the complete type signature, but runtime validation only checks struct names. By modifying bytecode post-compilation, attackers bypass compiler checks while exploiting incomplete runtime checks. The fix requires runtime validation to match the rigor of compile-time type checking by verifying type argument counts and kinds match the struct definition.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L57-101)
```rust
    for (module_id, inner_members) in members {
        for group_tag in inner_members.values() {
            let group_module_id = group_tag.module_id();
            if !groups.contains_key(&group_module_id) {
                // Note: module must exist for the group member to refer to it! Also, we need to
                // charge gas because this module is not in a bundle.
                if features.is_lazy_loading_enabled()
                    && traversal_context.visit_if_not_special_module_id(&group_module_id)
                {
                    let size = module_storage.unmetered_get_existing_module_size(
                        group_module_id.address(),
                        group_module_id.name(),
                    )?;
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            group_module_id.address(),
                            group_module_id.name(),
                            NumBytes::new(size as u64),
                        )
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                let old_module = module_storage.unmetered_get_existing_deserialized_module(
                    group_module_id.address(),
                    group_module_id.name(),
                )?;

                let (inner_groups, _, _) =
                    extract_resource_group_metadata_from_module(&old_module)?;
                groups.insert(group_tag.module_id(), inner_groups);
            }

            let scope = if let Some(inner_group) = groups.get(&group_module_id) {
                inner_group
                    .get(group_tag.name.as_ident_str().as_str())
                    .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
            } else {
                return Err(metadata_validation_error("No such resource_group"));
            };

            if !scope.are_equal_module_ids(&module_id, &group_module_id) {
                metadata_validation_err("Scope mismatch")?;
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L121-123)
```text
    #[resource_group(scope = global)]
    /// A shared resource group for storing object resources together in storage.
    struct ObjectGroup {}
```

**File:** types/src/vm/module_metadata.rs (L449-451)
```rust
    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
```
