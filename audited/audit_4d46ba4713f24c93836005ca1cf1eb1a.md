# Audit Report

## Title
Lack of Configuration Validation for `min_time_to_ignore_peers_secs` Enables Rate Limiting Bypass via Rapid Ignore/Unblock Cycling

## Summary
The storage service's `StorageServiceConfig` does not validate the `min_time_to_ignore_peers_secs` parameter, allowing administrators to set dangerously low values (including 0 or 1 second). When misconfigured with short durations, attackers can exploit rapid ignore/unblock cycles to send excessive invalid requests before exponential backoff becomes effective, causing service degradation through CPU waste and log spam.

## Finding Description
The storage service implements a request moderator that tracks invalid requests per peer and temporarily ignores peers exceeding `max_invalid_requests_per_peer` (default: 500). When ignored, peers are blocked for `min_time_to_ignore_peers_secs` with exponential backoff doubling on each subsequent offense. [1](#0-0) 

However, the configuration lacks validation: [2](#0-1) [3](#0-2) 

The sanitization logic does not validate `StorageServiceConfig` fields: [4](#0-3) 

**Attack Scenario** (with `min_time_to_ignore_peers_secs = 1`):
1. Attacker sends 500 invalid requests → ignored for 1 second
2. After 1 second: unblocked (count reset), sends 500 more → ignored for 2 seconds
3. After 2 seconds: unblocked, sends 500 more → ignored for 4 seconds
4. Pattern continues: 8s, 16s, 32s...

In ~31 seconds, a single peer sends 2,500 invalid requests. With 100 concurrent connections (max_inbound_connections), attackers could send ~250,000 invalid requests in this timeframe. [5](#0-4) 

## Impact Explanation
This is a **Low Severity** configuration vulnerability, not Medium. While it can cause service degradation, the impact is limited:

1. **No Critical System Compromise**: Does not affect consensus, funds, or state consistency
2. **Cheap Validation**: Request validation only checks in-memory data ranges without I/O operations
3. **Default is Safe**: Default 300 seconds (5 minutes) prevents exploitation
4. **Requires Misconfiguration**: Only exploitable if admin sets unreasonable values

The issue falls under "Non-critical implementation bugs" (Low Severity per Aptos bug bounty) rather than "State inconsistencies requiring intervention" (Medium Severity).

## Likelihood Explanation
**Low likelihood** because:
- Requires administrator to explicitly misconfigure the system with unsafe values
- Default configuration (300 seconds) is reasonable and secure
- Exponential backoff provides protection even with moderate misconfigurations
- Connection limits (`max_inbound_connections = 100`) bound the attack surface

## Recommendation
Add configuration validation to enforce minimum acceptable values:

```rust
impl ConfigSanitizer for StorageServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.state_sync.storage_service;
        
        // Enforce minimum ignore duration to prevent rapid cycling
        const MIN_IGNORE_DURATION_SECS: u64 = 60; // 1 minute minimum
        if config.min_time_to_ignore_peers_secs < MIN_IGNORE_DURATION_SECS {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "min_time_to_ignore_peers_secs must be at least {} seconds to prevent abuse",
                    MIN_IGNORE_DURATION_SECS
                ),
            ));
        }
        
        Ok(())
    }
}
```

Update `StateSyncConfig::sanitize()` to include this check:

```rust
impl ConfigSanitizer for StateSyncConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        StateSyncDriverConfig::sanitize(node_config, node_type, chain_id)?;
        StorageServiceConfig::sanitize(node_config, node_type, chain_id)?;
        Ok(())
    }
}
```

## Proof of Concept
```rust
#[tokio::test]
async fn test_rapid_cycling_with_short_ignore_time() {
    // Create config with dangerously short ignore duration
    let storage_service_config = StorageServiceConfig {
        max_invalid_requests_per_peer: 500,
        min_time_to_ignore_peers_secs: 1, // VULNERABLE: Too short!
        ..Default::default()
    };
    
    let (mut mock_client, mut service, _, time_service, peers_and_metadata) =
        MockClient::new(None, Some(storage_service_config));
    
    utils::update_storage_server_summary(&mut service, 100, 10);
    let request_moderator = service.get_request_moderator();
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    peers_and_metadata
        .insert_connection_metadata(
            peer_network_id,
            create_connection_metadata(peer_network_id.peer_id(), 0),
        )
        .unwrap();
    
    tokio::spawn(service.start());
    
    let mut total_requests_sent = 0;
    let start_time = Instant::now();
    
    // Exploit rapid cycling for 31 seconds
    for round in 0..5 {
        // Send max invalid requests
        for _ in 0..500 {
            let _ = send_invalid_request(&mut mock_client, peer_network_id).await;
            total_requests_sent += 1;
        }
        
        // Wait for unblock (1 * 2^round seconds)
        let wait_duration = 1 << round;
        time_service.advance_secs_async(wait_duration).await;
        advance_moderator_refresh_time(&time_service).await;
    }
    
    let elapsed = start_time.elapsed();
    
    // Demonstrate vulnerability: 2,500 invalid requests in ~31 seconds
    assert!(total_requests_sent >= 2500);
    assert!(elapsed.as_secs() <= 35);
    println!("Attack sent {} invalid requests in {} seconds", 
             total_requests_sent, elapsed.as_secs());
}
```

## Notes
While this is a valid configuration issue, it does not meet **Medium severity** criteria due to:
- Limited impact (no consensus/funds/critical system compromise)
- Requires misconfiguration (default is safe)
- Existing mitigations (exponential backoff, connection limits, cheap validation)

The vulnerability confirms the security question's premise but represents **Low severity** rather than Medium.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L76-98)
```rust
    /// Refreshes the peer's state (if it has been ignored for long enough).
    /// Note: each time we unblock a peer, we double the min time to ignore the peer.
    /// This provides an exponential backoff for peers that are sending too many invalid requests.
    pub fn refresh_peer_state(&mut self, peer_network_id: &PeerNetworkId) {
        if let Some(ignore_start_time) = self.ignore_start_time {
            let ignored_duration = self.time_service.now().duration_since(ignore_start_time);
            if ignored_duration >= Duration::from_secs(self.min_time_to_ignore_secs) {
                // Reset the invalid request count
                self.invalid_request_count = 0;

                // Reset the ignore start time
                self.ignore_start_time = None;

                // Double the min time to ignore the peer
                self.min_time_to_ignore_secs *= 2;

                // Log the fact that we're no longer ignoring the peer
                warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                    .peer_network_id(peer_network_id)
                    .message("No longer ignoring peer! Enough time has elapsed."));
            }
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L132-196)
```rust
    /// Validates the given request and verifies that the peer is behaving
    /// correctly. If the request fails validation, an error is returned.
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
    }
```

**File:** config/src/config/state_sync_config.rs (L155-193)
```rust
#[serde(default, deny_unknown_fields)]
pub struct StorageServiceConfig {
    /// Whether to enable size and time-aware chunking
    pub enable_size_and_time_aware_chunking: bool,
    /// Whether transaction data v2 is enabled
    pub enable_transaction_data_v2: bool,
    /// Maximum number of epoch ending ledger infos per chunk
    pub max_epoch_chunk_size: u64,
    /// Maximum number of invalid requests per peer
    pub max_invalid_requests_per_peer: u64,
    /// Maximum number of items in the lru cache before eviction
    pub max_lru_cache_size: u64,
    /// Maximum number of pending network messages
    pub max_network_channel_size: u64,
    /// Maximum number of bytes to send per network message
    pub max_network_chunk_bytes: u64,
    /// Maximum number of bytes to send per network message (for v2 data)
    pub max_network_chunk_bytes_v2: u64,
    /// Maximum number of active subscriptions (per peer)
    pub max_num_active_subscriptions: u64,
    /// Maximum period (ms) of pending optimistic fetch requests
    pub max_optimistic_fetch_period_ms: u64,
    /// Maximum number of state keys and values per chunk
    pub max_state_chunk_size: u64,
    /// Maximum time (ms) to wait for storage before truncating a response
    pub max_storage_read_wait_time_ms: u64,
    /// Maximum period (ms) of pending subscription requests
    pub max_subscription_period_ms: u64,
    /// Maximum number of transactions per chunk
    pub max_transaction_chunk_size: u64,
    /// Maximum number of transaction outputs per chunk
    pub max_transaction_output_chunk_size: u64,
    /// Minimum time (secs) to ignore peers after too many invalid requests
    pub min_time_to_ignore_peers_secs: u64,
    /// The interval (ms) to refresh the request moderator state
    pub request_moderator_refresh_interval_ms: u64,
    /// The interval (ms) to refresh the storage summary
    pub storage_summary_refresh_interval_ms: u64,
}
```

**File:** config/src/config/state_sync_config.rs (L195-218)
```rust
impl Default for StorageServiceConfig {
    fn default() -> Self {
        Self {
            enable_size_and_time_aware_chunking: false,
            enable_transaction_data_v2: true,
            max_epoch_chunk_size: MAX_EPOCH_CHUNK_SIZE,
            max_invalid_requests_per_peer: 500,
            max_lru_cache_size: 500, // At ~0.6MiB per chunk, this should take no more than 0.5GiB
            max_network_channel_size: 4000,
            max_network_chunk_bytes: SERVER_MAX_MESSAGE_SIZE as u64,
            max_network_chunk_bytes_v2: SERVER_MAX_MESSAGE_SIZE_V2 as u64,
            max_num_active_subscriptions: 30,
            max_optimistic_fetch_period_ms: 5000, // 5 seconds
            max_state_chunk_size: MAX_STATE_CHUNK_SIZE,
            max_storage_read_wait_time_ms: 10_000, // 10 seconds
            max_subscription_period_ms: 30_000,    // 30 seconds
            max_transaction_chunk_size: MAX_TRANSACTION_CHUNK_SIZE,
            max_transaction_output_chunk_size: MAX_TRANSACTION_OUTPUT_CHUNK_SIZE,
            min_time_to_ignore_peers_secs: 300, // 5 minutes
            request_moderator_refresh_interval_ms: 1000, // 1 second
            storage_summary_refresh_interval_ms: 100, // Optimal for <= 10 blocks per second
        }
    }
}
```

**File:** config/src/config/state_sync_config.rs (L487-496)
```rust
impl ConfigSanitizer for StateSyncConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Sanitize the state sync driver config
        StateSyncDriverConfig::sanitize(node_config, node_type, chain_id)
    }
}
```
