# Audit Report

## Title
CPU Exhaustion via Unbounded Batch Count in BatchMsg Processing When receiver_max_num_batches Set to usize::MAX

## Summary
Setting `receiver_max_num_batches` to `usize::MAX` removes the intended protection against oversized batch messages, allowing an attacker to send a single `BatchMsg` containing hundreds of thousands of minimal batches (limited only by the 64 MiB network message size). The verification loop processes every batch, causing severe CPU exhaustion and validator slowdowns.

## Finding Description

The `receiver_max_num_batches` parameter in `QuorumStoreConfig` controls the maximum number of batches allowed in a `BatchMsg` received from network peers. [1](#0-0) 

When this parameter is set to `usize::MAX` (either through misconfiguration or malicious config modification), the validation check becomes effectively useless. [2](#0-1) 

**Attack Path:**

1. An attacker crafts a `BatchMsg` containing hundreds of thousands of minimal batches. Each `Batch` contains a `BatchInfo` structure (~136 bytes) and a `BatchPayload` with empty transactions (~34 bytes), totaling approximately 170-200 bytes per batch. [3](#0-2) 

2. Within the 64 MiB network message size limit, approximately 335,000+ minimal batches can fit. [4](#0-3) 

3. The message is deserialized and passes through `UnverifiedEvent::verify()` which extracts `max_num_batches` from the configuration. [5](#0-4) 

4. The verification is called with the misconfigured `max_num_batches = usize::MAX`. [6](#0-5) 

5. Inside `BatchMsg::verify()`, the critical loop processes ALL batches without early rejection. [7](#0-6) 

6. For each batch, the code performs hash lookups, author verification, and calls `batch.verify()` which includes hash verification and transaction iteration. [8](#0-7) 

**Critical Vulnerability:** The configuration sanitizer does NOT validate or set an upper bound on `receiver_max_num_batches`. [9](#0-8) 

The sanitization only validates sender-vs-receiver limits and batch-vs-total limits for txns and bytes, but completely ignores `receiver_max_num_batches` itself, allowing unrestricted values including `usize::MAX`.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty criteria: "Validator node slowdowns."

**Specific Impacts:**

1. **CPU Exhaustion**: Processing 335,000+ batches in a single message causes significant CPU consumption on the verification thread pool, even with `BoundedExecutor` rate limiting. [10](#0-9) 

2. **Consensus Liveness Degradation**: Repeated attacks can starve the bounded executor, delaying legitimate consensus message verification and affecting the validator's ability to participate in consensus rounds.

3. **Resource Exhaustion**: Each verification task holds resources while iterating through hundreds of thousands of batches, potentially blocking other critical tasks.

4. **Network-wide Impact**: If multiple validators use this misconfiguration, attackers can simultaneously degrade performance across the network.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Factors Increasing Likelihood:**
- Configuration files are operator-managed; mistakes in setting limits are realistic
- No validation prevents setting extreme values
- Default value (20) is safe, but nothing prevents operators from setting `usize::MAX`
- No runtime monitoring alerts on abnormally high values

**Factors Decreasing Likelihood:**
- Requires operator misconfiguration (not exploitable on default-configured nodes)
- The default value (20) is reasonable and commonly used
- Well-managed validators would likely use standard configurations

However, the lack of ANY upper bound validation or sanity checking makes this a legitimate configuration-based attack surface.

## Recommendation

Add explicit upper bound validation for `receiver_max_num_batches` in the configuration sanitizer:

```rust
// In config/src/config/quorum_store_config.rs
const MAX_RECEIVER_NUM_BATCHES: usize = 1000; // Reasonable upper limit

fn sanitize_receiver_max_num_batches(
    sanitizer_name: &str,
    config: &QuorumStoreConfig,
) -> Result<(), Error> {
    if config.receiver_max_num_batches > MAX_RECEIVER_NUM_BATCHES {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!(
                "receiver_max_num_batches {} exceeds maximum allowed {}",
                config.receiver_max_num_batches,
                MAX_RECEIVER_NUM_BATCHES
            ),
        ));
    }
    Ok(())
}

impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        
        // Add this new validation
        Self::sanitize_receiver_max_num_batches(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;
        
        // Existing validations...
        Self::sanitize_send_recv_batch_limits(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;
        
        Ok(())
    }
}
```

Additionally, add validation for `sender_max_num_batches` to ensure consistency.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::HashValue;
    use aptos_types::{PeerId, transaction::SignedTransaction};
    use aptos_consensus_types::common::BatchPayload;
    
    #[test]
    fn test_batch_msg_cpu_exhaustion_with_max_batches() {
        // Simulate misconfiguration
        let max_num_batches = usize::MAX;
        
        // Create a large number of minimal batches
        let num_batches = 100_000; // Reduced for test, but attack uses 300k+
        let mut batches = Vec::new();
        let peer_id = PeerId::random();
        
        for i in 0..num_batches {
            let batch_id = BatchId::new_for_test(i as u64);
            let payload = vec![]; // Empty payload for minimal size
            let batch = Batch::new(
                batch_id,
                payload,
                0, // epoch
                u64::MAX, // expiration
                peer_id,
                0, // gas_bucket_start
            );
            batches.push(batch);
        }
        
        let batch_msg = BatchMsg::new(batches);
        
        // Create validator verifier
        let validator_verifier = ValidatorVerifier::new(...);
        
        // Measure CPU time for verification
        let start = std::time::Instant::now();
        let result = batch_msg.verify(peer_id, max_num_batches, &validator_verifier);
        let duration = start.elapsed();
        
        println!("Verification of {} batches took: {:?}", num_batches, duration);
        
        // With default limit (20), this would fail immediately
        // With usize::MAX, it processes all batches causing significant delay
        assert!(duration.as_millis() > 100); // Significant processing time
    }
    
    #[test]
    fn test_config_should_reject_extreme_receiver_max_num_batches() {
        // Test that extreme values should be rejected by sanitizer
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                quorum_store: QuorumStoreConfig {
                    receiver_max_num_batches: usize::MAX, // Should fail
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };
        
        // Currently this PASSES (vulnerability)
        // Should FAIL with proper sanitization
        let result = QuorumStoreConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );
        
        // With fix, this should return an error
        // assert!(result.is_err());
    }
}
```

**Notes:**

This vulnerability demonstrates a gap in configuration validation that could be exploited through misconfiguration or malicious config modification. The default value provides protection, but the absence of upper bound validation creates an attack surface that violates the "Resource Limits" invariant requiring all operations to respect computational limits.

### Citations

**File:** config/src/config/quorum_store_config.rs (L122-122)
```rust
            receiver_max_num_batches: 20,
```

**File:** config/src/config/quorum_store_config.rs (L253-271)
```rust
impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Sanitize the send/recv batch limits
        Self::sanitize_send_recv_batch_limits(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;

        // Sanitize the batch total limits
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;

        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L440-445)
```rust
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
```

**File:** consensus/src/quorum_store/types.rs (L447-459)
```rust
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L49-58)
```rust
pub struct BatchInfo {
    author: PeerId,
    batch_id: BatchId,
    epoch: u64,
    expiration: u64,
    digest: HashValue,
    num_txns: u64,
    num_bytes: u64,
    gas_bucket_start: u64,
}
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/src/epoch_manager.rs (L1582-1582)
```rust
            let max_num_batches = self.config.quorum_store.receiver_max_num_batches;
```

**File:** consensus/src/epoch_manager.rs (L1587-1621)
```rust
            self.bounded_executor
                .spawn(async move {
                    match monitor!(
                        "verify_message",
                        unverified_event.clone().verify(
                            peer_id,
                            &epoch_state.verifier,
                            &proof_cache,
                            quorum_store_enabled,
                            peer_id == my_peer_id,
                            max_num_batches,
                            max_batch_expiry_gap_usecs,
                        )
                    ) {
                        Ok(verified_event) => {
                            Self::forward_event(
                                quorum_store_msg_tx,
                                round_manager_tx,
                                buffered_proposal_tx,
                                peer_id,
                                verified_event,
                                payload_manager,
                                pending_blocks,
                            );
                        },
                        Err(e) => {
                            error!(
                                SecurityEvent::ConsensusInvalidMessage,
                                remote_peer = peer_id,
                                error = ?e,
                                unverified_event = unverified_event
                            );
                        },
                    }
                })
```

**File:** consensus/src/round_manager.rs (L168-168)
```rust
                    b.verify(peer_id, max_num_batches, validator)?;
```
