# Audit Report

## Title
Silent Failure of Proof-of-Store Self-Delivery in DAG Consensus Mode Causes Batch Exclusion

## Summary
In DAG consensus mode, when a validator successfully creates a Proof-of-Store (after collecting quorum signatures), the proof is sent only to itself via an internal channel. If this self-send operation fails due to channel closure, the error is silently logged but not propagated, causing the validator to permanently lose access to those proofs and preventing it from including those batches in future block proposals.

## Finding Description

The vulnerability exists in the proof-of-store delivery mechanism when DAG consensus is enabled. The attack surface involves the interaction between three components:

1. **ProofCoordinator** creates proofs after collecting quorum signatures
2. **NetworkSender** delivers proofs via internal channels
3. **ProofManager** stores proofs for inclusion in proposals

**Configuration Context:**
When DAG consensus is enabled, the `broadcast_proofs` flag is set to `false`: [1](#0-0) 

**Proof Delivery Logic:**
In DAG mode (`broadcast_proofs = false`), proofs are sent ONLY to self, not broadcast to other validators: [2](#0-1) 

**The Critical Flaw:**
The `send_proof_of_store_msg_to_self()` implementation calls the underlying `send()` method which contains the vulnerability: [3](#0-2) [4](#0-3) 

When sending to self (line 416-421), if the channel send fails, the error is only logged as a warning and execution continues. The failure is NOT propagated to the caller.

**Impact Chain:**
1. ProofCoordinator successfully creates valid proofs with quorum signatures
2. Calls `send_proof_of_store_msg_to_self()` to deliver to ProofManager
3. If `self_sender` channel is closed/failed, send() logs warning but returns normally
4. ProofCoordinator believes delivery succeeded
5. ProofManager never receives the proofs
6. Proofs are not inserted into the batch_proof_queue: [5](#0-4) 

7. When this validator becomes a proposer, it cannot pull these proofs for inclusion in proposals

**Channel Failure Scenarios:**
The `self_sender` is an unbounded channel that can fail when: [6](#0-5) 

The channel fails with `mpsc::SendError` when the receiver is dropped or the channel is closed, which can occur during:
- NetworkTask crashes or panics
- Abnormal shutdown sequences
- System-level failures

## Impact Explanation

**Severity: High** (Validator node performance degradation)

This vulnerability causes significant protocol violations affecting validator participation:

1. **Loss of Batch Availability**: In DAG mode, proofs are not broadcast. If self-send fails, those batches become unavailable for proposal by this validator permanently.

2. **Consensus Participation Degradation**: The validator cannot include its own batches in proposals, effectively preventing it from participating in consensus for those specific transaction batches.

3. **Silent Failure Mode**: The error handling only logs warnings, making diagnosis difficult and potentially masking ongoing failures.

4. **DAG Mode Specific**: Since `broadcast_proofs = false` only in DAG mode, this creates a mode-specific vulnerability where the same code behaves differently based on configuration.

5. **Atomicity Violation**: The security question specifically asks about atomicity - the proof creation is atomic and successful, but the delivery is not atomic with proper error handling, violating the expected invariant that successful proof creation means the validator can use those proofs.

While this doesn't cause network-wide consensus failure (other validators continue operating), it significantly degrades the affected validator's ability to participate in consensus, meeting the "Validator node slowdowns" and "Significant protocol violations" criteria for High severity.

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires specific conditions:
- DAG consensus mode must be enabled
- The `self_sender` channel must experience a failure (receiver dropped)
- Timing must align with proof creation

While the channel is designed to be persistent across epochs, failures can occur due to:
- Programming errors causing NetworkTask to exit
- System-level issues (resource exhaustion, panics)
- Race conditions during shutdown or restart

The impact is guaranteed once the channel fails - all subsequent proof-of-store messages in DAG mode will be lost for that validator.

## Recommendation

Implement proper error propagation and recovery for self-send failures:

```rust
async fn send_proof_of_store_msg_to_self(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) -> anyhow::Result<()> {
    fail_point!("consensus::send::proof_of_store", |_| Ok(()));
    let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
    
    // For self-send, we need guaranteed delivery
    if let Err(e) = self.send(msg.clone(), vec![self.author]).await {
        error!("Critical: Failed to deliver proof-of-store to self: {:?}", e);
        // Retry with backoff or use alternative delivery mechanism
        return Err(anyhow::anyhow!("Failed to send proof-of-store to self: {}", e));
    }
    Ok(())
}
```

Additionally, modify the `send()` method to propagate errors for self-sends:

```rust
async fn send(&self, msg: ConsensusMsg, recipients: Vec<Author>) -> anyhow::Result<()> {
    fail_point!("consensus::send::any", |_| Ok(()));
    let network_sender = self.consensus_network_client.clone();
    let mut self_sender = self.self_sender.clone();
    for peer in recipients {
        if self.author == peer {
            let self_msg = Event::Message(self.author, msg.clone());
            self_sender.send(self_msg).await
                .context("Failed to deliver message to self")?;
            continue;
        }
        // ... rest of network sending
    }
    Ok(())
}
```

## Proof of Concept

The following demonstrates the vulnerability by simulating channel closure:

```rust
#[tokio::test]
async fn test_proof_of_store_self_send_failure() {
    use aptos_channels;
    use consensus::network::{NetworkSender, NetworkTask};
    use consensus_types::proof_of_store::{ProofOfStore, BatchInfoExt};
    
    // Setup network sender with closed self-channel
    let (self_sender, self_receiver) = aptos_channels::new_unbounded_test();
    
    // Drop the receiver immediately to simulate channel closure
    drop(self_receiver);
    
    // Create network sender
    let network_sender = NetworkSender::new(
        /* author */ test_peer_id(),
        /* network_client */ test_network_client(),
        /* self_sender */ self_sender,
        /* validators */ test_validator_verifier(),
    );
    
    // Create a valid proof-of-store
    let proof = create_test_proof_of_store();
    let proofs = vec![proof];
    
    // Attempt to send to self - this should fail but doesn't propagate error
    network_sender.send_proof_of_store_msg_to_self(proofs).await;
    
    // Expected: Function should return error
    // Actual: Function completes successfully, proof is lost
    // The ProofManager never receives the proof and cannot include it in proposals
}
```

## Notes

This vulnerability specifically affects DAG consensus mode where proofs are not broadcast. The architectural decision to use different delivery mechanisms based on consensus mode creates this attack surface. The issue demonstrates a violation of the fail-safe principle - errors should be explicit and handled, not silently ignored in critical consensus paths.

### Citations

**File:** consensus/src/epoch_manager.rs (L753-753)
```rust
                !consensus_config.is_dag_enabled(),
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L484-498)
```rust
                                if enable_broadcast_proofs {
                                    if proofs_iter.peek().is_some_and(|p| p.info().is_v2()) {
                                        let proofs: Vec<_> = proofs_iter.collect();
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
                                    } else {
                                        let proofs: Vec<_> = proofs_iter.map(|proof| {
                                            let (info, sig) = proof.unpack();
                                            ProofOfStore::new(info.info().clone(), sig)
                                        }).collect();
                                        network_sender.broadcast_proof_of_store_msg(proofs).await;
                                    }
                                } else {
                                    let proofs: Vec<_> = proofs_iter.collect();
                                    network_sender.send_proof_of_store_msg_to_self(proofs).await;
                                }
```

**File:** consensus/src/network.rs (L411-433)
```rust
    async fn send(&self, msg: ConsensusMsg, recipients: Vec<Author>) {
        fail_point!("consensus::send::any", |_| ());
        let network_sender = self.consensus_network_client.clone();
        let mut self_sender = self.self_sender.clone();
        for peer in recipients {
            if self.author == peer {
                let self_msg = Event::Message(self.author, msg.clone());
                if let Err(err) = self_sender.send(self_msg).await {
                    warn!(error = ?err, "Error delivering a self msg");
                }
                continue;
            }
            counters::CONSENSUS_SENT_MSGS
                .with_label_values(&[msg.name()])
                .inc();
            if let Err(e) = network_sender.send_to(peer, msg.clone()) {
                warn!(
                    remote_peer = peer,
                    error = ?e, "Failed to send a msg {:?} to peer", msg
                );
            }
        }
    }
```

**File:** consensus/src/network.rs (L635-639)
```rust
    async fn send_proof_of_store_msg_to_self(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) {
        fail_point!("consensus::send::proof_of_store", |_| ());
        let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
        self.send(msg, vec![self.author]).await
    }
```

**File:** consensus/src/quorum_store/proof_manager.rs (L65-69)
```rust
    pub(crate) fn receive_proofs(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) {
        for proof in proofs.into_iter() {
            self.batch_proof_queue.insert_proof(proof);
        }
        self.update_remaining_txns_and_proofs();
```

**File:** crates/channel/src/lib.rs (L177-186)
```rust
impl<T> Sink<T> for UnboundedSender<T> {
    type Error = mpsc::SendError;

    fn poll_ready(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        (self).inner.poll_ready(cx)
    }

    fn start_send(mut self: Pin<&mut Self>, msg: T) -> Result<(), Self::Error> {
        (self).inner.start_send(msg).map(|_| self.gauge.inc())
    }
```
