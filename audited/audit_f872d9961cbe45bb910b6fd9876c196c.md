# Audit Report

## Title
V2 Event Sequence Number Collision in Coin Activity Indexer Causes Silent Data Loss

## Summary
The coin activity indexer silently drops multiple coin deposit/withdrawal events within the same transaction when V2 event translation is disabled (the default configuration), causing all V2 events to share identical dummy GUID values (0x0, 0, 0) and creating primary key collisions that mask legitimate financial activities.

## Finding Description

The `insert_coin_activities()` function uses a composite primary key consisting of `(transaction_version, event_account_address, event_creation_number, event_sequence_number)` with a `.do_nothing()` conflict resolution strategy. [1](#0-0) 

When the blockchain emits V2 events (MODULE_EVENT_MIGRATION enabled), CoinDeposit and CoinWithdraw events are created as module events: [2](#0-1) 

These V2 events are converted to API Event structs with DUMMY_GUID and DUMMY_SEQUENCE_NUMBER when event translation is not applied: [3](#0-2) 

The dummy values are hardcoded as: [4](#0-3) 

Event translation in `Context.get_transactions()` is conditional and only occurs when both the indexer_reader exists AND `enable_event_v2_translation` is enabled: [5](#0-4) 

Critically, the default configuration has `enable_event_v2_translation: false`: [6](#0-5) 

The indexer fetcher uses `Context.get_transactions()` to retrieve transaction data: [7](#0-6) 

**Attack Path:**
1. Attacker creates a transaction that triggers multiple coin events (e.g., multiple transfers, complex DeFi operations)
2. Blockchain emits V2 CoinDeposit/CoinWithdraw events
3. Indexer fetches transaction via `Context.get_transactions()` with default config (translation disabled)
4. All V2 events receive identical dummy values: account_address=0x0, creation_number=0, sequence_number=0
5. Coin processor attempts to insert all events with primary key: (txn_version, 0x0, 0, 0)
6. Only first event is inserted, all subsequent events are silently dropped
7. Legitimate withdrawals/deposits are masked in the indexed database

## Impact Explanation

This constitutes a **Medium Severity** vulnerability (up to $10,000) per the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The indexer database contains incomplete/incorrect coin activity records
- **Limited funds loss or manipulation**: While on-chain state remains correct, applications relying on indexed data (exchanges, wallets, explorers) may:
  - Miss deposit detections leading to delayed credit
  - Display incorrect transaction histories
  - Make incorrect balance calculations
  - Fail to detect malicious withdrawals

The vulnerability breaks the **State Consistency** invariant for the indexer subsystem, though not for blockchain consensus itself. However, given that many ecosystem applications depend on indexed data for UX and financial operations, this represents significant operational risk.

## Likelihood Explanation

**Likelihood: High**

1. **Default configuration is vulnerable**: `enable_event_v2_translation: false` is the default
2. **MODULE_EVENT_MIGRATION is active on mainnet**: V2 events are being emitted for coin operations
3. **Automatic exploitation**: No specialized attack needed - any transaction with multiple coin events triggers the bug
4. **Common occurrence**: DeFi operations, batch transfers, and complex transactions routinely generate multiple coin events

The vulnerability will manifest automatically in production environments running default indexer configurations, making it highly likely to occur without attacker intervention.

## Recommendation

**Immediate Fix:**
1. Change the default configuration to enable V2 event translation:

```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: true,  // Changed from false
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
}
```

2. Add validation to prevent silent failures:

```rust
fn insert_coin_activities(
    conn: &mut PgConnection,
    item_to_insert: &[CoinActivity],
) -> Result<(), diesel::result::Error> {
    use schema::coin_activities::dsl::*;
    
    // Validate that no V2 events with dummy GUIDs are being inserted
    for item in item_to_insert {
        if item.event_account_address == "0x0" 
           && item.event_creation_number == 0 
           && item.event_sequence_number == 0 {
            return Err(diesel::result::Error::RollbackTransaction);
        }
    }
    
    let chunks = get_chunks(item_to_insert.len(), CoinActivity::field_count());
    for (start_ind, end_ind) in chunks {
        let result = execute_with_better_error(
            conn,
            diesel::insert_into(schema::coin_activities::table)
                .values(&item_to_insert[start_ind..end_ind])
                .on_conflict((
                    transaction_version,
                    event_account_address,
                    event_creation_number,
                    event_sequence_number,
                ))
                .do_nothing(),
            None,
        )?;
    }
    Ok(())
}
```

3. Require V2 translation for coin processor initialization to fail-fast if misconfigured

## Proof of Concept

```rust
// Simulation demonstrating the collision:
// 
// Setup: Configure indexer with enable_event_v2_translation: false
// 
// Transaction containing multiple coin events:
// 1. Transfer 100 APT from Alice to Bob  -> CoinWithdraw(Alice, 100), CoinDeposit(Bob, 100)
// 2. Transfer 50 APT from Alice to Carol -> CoinWithdraw(Alice, 50), CoinDeposit(Carol, 50)
//
// Expected indexed activities: 4 entries
// Actual indexed activities: 1 entry (only first CoinWithdraw is recorded)
//
// Impact: Bob's deposit of 100 APT, Alice's second withdrawal of 50 APT,
//         and Carol's deposit of 50 APT are all missing from indexed database
//
// Verification steps:
// 1. Deploy indexer with default config (enable_event_v2_translation: false)
// 2. Execute transaction with multiple coin operations
// 3. Query coin_activities table for the transaction version
// 4. Observe only 1 row exists instead of expected 4 rows
// 5. Primary key collision: All have (txn_version, "0x0", 0, 0)
```

**Notes:**
- This vulnerability only affects indexer data integrity, not blockchain consensus
- On-chain state remains correct and verifiable
- Applications querying blockchain state directly are not affected
- Only applications relying on indexed coin_activities table are impacted
- The issue compounds with transaction complexity (more events = more data loss)

### Citations

**File:** crates/indexer/src/processors/coin_processor.rs (L137-143)
```rust
                .on_conflict((
                    transaction_version,
                    event_account_address,
                    event_creation_number,
                    event_sequence_number,
                ))
                .do_nothing(),
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L177-191)
```text
    #[event]
    /// Module event emitted when some amount of a coin is deposited into an account.
    struct CoinDeposit has drop, store {
        coin_type: String,
        account: address,
        amount: u64
    }

    #[event]
    /// Module event emitted when some amount of a coin is withdrawn from an account.
    struct CoinWithdraw has drop, store {
        coin_type: String,
        account: address,
        amount: u64
    }
```

**File:** api/types/src/transaction.rs (L48-52)
```rust
static DUMMY_GUID: Lazy<EventGuid> = Lazy::new(|| EventGuid {
    creation_number: U64::from(0u64),
    account_address: Address::from(AccountAddress::ZERO),
});
static DUMMY_SEQUENCE_NUMBER: Lazy<U64> = Lazy::new(|| U64::from(0));
```

**File:** api/types/src/transaction.rs (L877-893)
```rust
impl From<(&ContractEvent, serde_json::Value)> for Event {
    fn from((event, data): (&ContractEvent, serde_json::Value)) -> Self {
        match event {
            ContractEvent::V1(v1) => Self {
                guid: (*v1.key()).into(),
                sequence_number: v1.sequence_number().into(),
                typ: v1.type_tag().into(),
                data,
            },
            ContractEvent::V2(v2) => Self {
                guid: *DUMMY_GUID,
                sequence_number: *DUMMY_SEQUENCE_NUMBER,
                typ: v2.type_tag().into(),
                data,
            },
        }
    }
```

**File:** api/src/context.rs (L831-877)
```rust
    pub fn get_transactions(
        &self,
        start_version: u64,
        limit: u16,
        ledger_version: u64,
    ) -> Result<Vec<TransactionOnChainData>> {
        let data = self
            .db
            .get_transaction_outputs(start_version, limit as u64, ledger_version)?
            .consume_output_list_with_proof();

        let txn_start_version = data
            .get_first_output_version()
            .ok_or_else(|| format_err!("no start version from database"))?;
        ensure!(
            txn_start_version == start_version,
            "invalid start version from database: {} != {}",
            txn_start_version,
            start_version
        );

        let infos = data.proof.transaction_infos;
        let transactions_and_outputs = data.transactions_and_outputs;

        ensure!(
            transactions_and_outputs.len() == infos.len(),
            "invalid data size from database: {}, {}",
            transactions_and_outputs.len(),
            infos.len(),
        );

        transactions_and_outputs
            .into_iter()
            .zip(infos)
            .enumerate()
            .map(
                |(i, ((txn, txn_output), info))| -> Result<TransactionOnChainData> {
                    let version = start_version + i as u64;
                    let (write_set, events, _, _, _) = txn_output.unpack();
                    let h = self.get_accumulator_root_hash(version)?;
                    let txn: TransactionOnChainData =
                        (version, txn, info, events, h, write_set).into();
                    Ok(self.maybe_translate_v2_to_v1_events(txn))
                },
            )
            .collect()
    }
```

**File:** api/src/context.rs (L1004-1017)
```rust
    fn maybe_translate_v2_to_v1_events(
        &self,
        mut txn: TransactionOnChainData,
    ) -> TransactionOnChainData {
        if self.indexer_reader.is_some()
            && self
                .node_config
                .indexer_db_config
                .enable_event_v2_translation
        {
            self.translate_v2_to_v1_events_for_version(txn.version, &mut txn.events)
                .ok();
        }
        txn
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-79)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
```
