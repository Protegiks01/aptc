# Audit Report

## Title
DKG Sigma Protocol Verification Panic Enables Validator Denial-of-Service via Malformed Proof Type

## Summary
The sigma protocol verification logic in the DKG subsystem panics when encountering Challenge-type proofs instead of gracefully rejecting them. An attacker can exploit this by crafting a malicious DKG transcript containing a Challenge-type proof and broadcasting it to validators, causing them to crash during transcript verification.

## Finding Description

The `prove_homomorphism()` function accepts a `store_prover_commitment` boolean parameter that determines whether the proof stores a Commitment (tag=0) or Challenge (tag=1) as the first proof item. [1](#0-0) 

While legitimate code paths always use `store_prover_commitment = true`, the serialization format accepts both types: [2](#0-1) 

The verification logic, however, only handles Commitment-type proofs and **panics** on Challenge-type proofs: [3](#0-2) 

This same panic occurs in the PairingTupleHomomorphism verification: [4](#0-3) 

**Attack Path:**

1. Attacker constructs a DKG transcript with a SharingProof containing a Challenge-type proof (manually setting tag=1 during serialization)
2. Attacker broadcasts this transcript to validators via DKG network messages
3. When validators receive the transcript, they call verification in `TranscriptAggregationState::add()`: [5](#0-4) 

4. This triggers verification of the main transcript: [6](#0-5) 

5. Which verifies the SharingProof's SoK: [7](#0-6) 

6. The verification extracts the first proof item and panics on Challenge type, crashing the validator node

## Impact Explanation

**High Severity** - This vulnerability enables a Denial-of-Service attack against validator nodes during Distributed Key Generation:

- **Validator node crashes**: The panic is unhandled and causes the validator process to terminate
- **DKG protocol disruption**: Repeated attacks can prevent successful DKG completion, blocking randomness generation for the epoch
- **No authentication required**: Any network participant who can send DKG messages can exploit this
- **Affects critical protocol**: DKG is essential for on-chain randomness in Aptos

Per the Aptos bug bounty program, this qualifies as High severity: "Validator node slowdowns / API crashes / Significant protocol violations."

## Likelihood Explanation

**High Likelihood**:

- **Easy to exploit**: Attacker only needs to flip a single byte (tag from 0 to 1) in a serialized proof
- **No authentication barrier**: DKG transcripts are broadcast over the network without strong sender authentication before deserialization
- **Reliable crash**: The panic is deterministic and will crash any validator that attempts verification
- **Low detection risk**: The malformed transcript appears syntactically valid until verification

The only barrier is network access to send DKG messages to validators, which is not a significant obstacle for a motivated attacker.

## Recommendation

Replace the panic with proper error handling that returns a verification failure instead of crashing:

```rust
let prover_first_message = match &proof.first_proof_item {
    FirstProofItem::Commitment(A) => A,
    FirstProofItem::Challenge(_) => {
        return Err(anyhow::anyhow!(
            "Challenge-type proofs are not supported in this context"
        ));
    },
};
```

Apply this fix to both locations:
- `crates/aptos-dkg/src/sigma_protocol/traits.rs` line 115-117
- `crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs` line 339-341

Additionally, consider either:
1. Completing the Challenge-type proof verification implementation if needed for batch verification
2. Removing Challenge-type support entirely if not required, rejecting it during deserialization

## Proof of Concept

```rust
use aptos_dkg::sigma_protocol::traits::{FirstProofItem, Proof};
use ark_serialize::CanonicalSerialize;

// Construct a malicious proof with Challenge type
fn create_malicious_proof() -> Vec<u8> {
    // Serialize a proof with tag=1 (Challenge type)
    let mut malicious_bytes = Vec::new();
    
    // Write tag 1 for Challenge
    1u8.serialize_uncompressed(&mut malicious_bytes).unwrap();
    
    // Serialize a field element as the challenge
    let challenge = ScalarField::from(42u64);
    challenge.serialize_uncompressed(&mut malicious_bytes).unwrap();
    
    // Serialize the response (z)
    let z = /* valid witness value */;
    z.serialize_uncompressed(&mut malicious_bytes).unwrap();
    
    malicious_bytes
}

// Create and broadcast malicious DKG transcript
fn exploit_validator() {
    let malicious_proof_bytes = create_malicious_proof();
    
    // Include in SharingProof and then Transcript
    let malicious_transcript = create_transcript_with_proof(malicious_proof_bytes);
    
    // Send to validators via DKG network message
    broadcast_dkg_transcript(malicious_transcript);
    
    // Validators will panic when calling verify() on this transcript
}
```

When a validator receives and attempts to verify this transcript, it will panic at the `msm_terms_for_verify` match statement, terminating the process.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L113-118)
```rust
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L308-340)
```rust
impl<F: PrimeField, H: homomorphism::Trait> CanonicalDeserialize for FirstProofItem<F, H>
where
    H::Domain: Witness<F>,
    H::Codomain: Statement + CanonicalDeserialize + Valid,
{
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: Validate,
    ) -> Result<Self, SerializationError> {
        // Read the discriminant tag
        let tag = u8::deserialize_with_mode(&mut reader, compress, validate)?;

        let item = match tag {
            0 => {
                let c = H::Codomain::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Commitment(c)
            },
            1 => {
                let f = F::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Challenge(f)
            },
            _ => return Err(SerializationError::InvalidData),
        };

        // Run validity check if requested
        if validate == Validate::Yes {
            item.check()?;
        }

        Ok(item)
    }
}
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L467-509)
```rust
pub fn prove_homomorphism<Ct: Serialize, F: PrimeField, H: homomorphism::Trait, R>(
    homomorphism: &H,
    witness: &H::Domain,
    statement: &H::Codomain,
    cntxt: &Ct,
    store_prover_commitment: bool, // true = store prover's commitment, false = store Fiat-Shamir challenge
    rng: &mut R,
    dst: &[u8],
) -> Proof<F, H>
where
    H::Domain: Witness<F>,
    H::Codomain: Statement,
    R: RngCore + CryptoRng,
{
    // Step 1: Sample randomness. Here the `witness` is only used to make sure that `r` has the right dimensions
    let r = witness.rand(rng);

    // Step 2: Compute commitment A = Î¨(r)
    let A = homomorphism.apply(&r);

    // Step 3: Obtain Fiat-Shamir challenge
    let c = fiat_shamir_challenge_for_sigma_protocol::<_, F, H>(
        cntxt,
        homomorphism,
        statement,
        &A,
        dst,
    );

    // Step 4: Compute prover response
    let z = r.scaled_add(&witness, c);

    // Step 5: Pick first **recorded** item
    let first_proof_item = if store_prover_commitment {
        FirstProofItem::Commitment(A)
    } else {
        FirstProofItem::Challenge(c)
    };

    Proof {
        first_proof_item,
        z,
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L337-342)
```rust
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };
```

**File:** dkg/src/transcript_aggregation/mod.rs (L99-101)
```rust
        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L514-529)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    TupleCodomainShape(
                        self.sharing_proof.range_proof_commitment.clone(),
                        chunked_elgamal::WeightedCodomainShape {
                            chunks: self.subtrs.Cs.clone(),
                            randomness: self.subtrs.Rs.clone(),
                        },
                    ),
                    chunked_scalar_mul::CodomainShape(self.subtrs.Vs.clone()),
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```
