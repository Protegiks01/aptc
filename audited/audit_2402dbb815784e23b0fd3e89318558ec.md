# Audit Report

## Title
Script Cache Pollution via Transactional Rollback Asymmetry in Parallel Execution

## Summary
In Aptos parallel execution, module cache insertions are tracked in `captured_reads` for transactional rollback, but script cache insertions are not. When a transaction aborts after verifying a script and its dependencies, module cache changes are rolled back while script cache changes persist, creating an inconsistent state where verified scripts reference non-existent modules. This breaks deterministic execution and can cause consensus divergence.

## Finding Description

The Aptos block executor uses a transactional caching mechanism via `CapturedReads` to track module reads and enable rollback on transaction abort. However, this mechanism has a critical asymmetry:

**Module Cache** - Properly tracked: [1](#0-0) 

When `insert_verified_module` is called, it explicitly updates `captured_reads` (line 118-121), enabling transactional rollback.

**Script Cache** - NOT tracked: [2](#0-1) 

The `ScriptCache` trait is delegated directly to the underlying cache without any `captured_reads` tracking.

**CapturedReads Structure** confirms this asymmetry: [3](#0-2) 

There is a `module_reads` field (line 553) but **no equivalent `script_reads` field**.

**Attack Flow:**

During script verification, modules are loaded and verified: [4](#0-3) 

Lines 123-129 call `unmetered_get_existing_eagerly_verified_module` for dependencies, which triggers: [5](#0-4) 

This calls `visit_dependencies_and_verify` which eventually calls `insert_verified_module` with `captured_reads` tracking.

However, the script insertion at line 135-137 only updates script_cache without captured_reads tracking.

**Exploitation Path:**
1. Attacker submits transaction with script S depending on modules M1, M2
2. In parallel execution (ViewState::Sync), script verification loads M1, M2
3. `insert_verified_module` called for M1, M2 → updates module_cache AND captured_reads
4. `insert_verified_script` called for S → updates script_cache but NOT captured_reads
5. Transaction aborts/fails validation
6. Captured_reads discarded → module_cache rolled back (M1, M2 removed)
7. Script_cache NOT rolled back → script S remains verified in cache
8. Cache now inconsistent: verified script S references modules M1, M2 that don't exist

## Impact Explanation

**High Severity** - This violates multiple critical invariants:

1. **Deterministic Execution Violation**: Different validators may have different cache states depending on transaction abort timing, leading to non-deterministic behavior when the same script is executed again.

2. **State Consistency Violation**: The cache state is inconsistent - verified scripts reference modules that were rolled back. This breaks the assumption that all verified code has verified dependencies.

3. **Consensus Risk**: If validators have divergent cache states:
   - Cache hits/misses differ across validators
   - Gas consumption differs (cached vs. loaded from storage)
   - Execution timing differs
   - Could lead to different transaction outcomes or state roots

4. **Cache Poisoning**: Attackers can intentionally create these inconsistent states by submitting transactions designed to abort after script verification, polluting the cache across the network.

This meets **High Severity** criteria: "Significant protocol violations" and potential path to consensus divergence.

## Likelihood Explanation

**High Likelihood:**
- Parallel execution is the default mode in Aptos
- Transaction aborts are common (validation failures, gas exhaustion, execution errors)
- Script transactions are frequently used
- No special privileges required - any transaction sender can trigger this
- The bug is deterministic and reproducible

The vulnerability will manifest whenever:
1. A script transaction is executed in parallel mode
2. Script verification completes successfully
3. Transaction subsequently aborts for any reason
4. The cache is not flushed between blocks

## Recommendation

Add script cache read/write tracking to `CapturedReads` analogous to module tracking:

**1. Extend CapturedReads structure:**
```rust
// In captured_reads.rs
pub(crate) struct CapturedReads<T: Transaction, K, DC, VC, S> {
    data_reads: HashMap<T::Key, DataRead<T::Value>>,
    group_reads: HashMap<T::Key, GroupRead<T>>,
    delayed_field_reads: HashMap<DelayedFieldID, DelayedFieldRead>,
    aggregator_v1_reads: HashSet<T::Key>,
    module_reads: hashbrown::HashMap<K, ModuleRead<DC, VC, S>>,
    
    // ADD THIS:
    script_reads: hashbrown::HashMap<[u8; 32], Option<Arc<Code<CompiledScript, Script>>>>,
    
    // ... rest of fields
}
```

**2. Update insert_verified_script in code_cache.rs:**
```rust
fn insert_verified_script(
    &self,
    key: Self::Key,
    verified_script: Self::Verified,
) -> Arc<Self::Verified> {
    match &self.latest_view {
        ViewState::Sync(state) => {
            let script = state.versioned_map.script_cache()
                .insert_verified_script(key, verified_script);
            // ADD THIS:
            state.captured_reads.borrow_mut()
                .capture_script_cache_write(key, Some(script.clone()));
            script
        },
        ViewState::Unsync(state) => {
            state.unsync_map.script_cache()
                .insert_verified_script(key, verified_script)
        },
    }
}
```

**3. Implement script cache validation** in captured_reads.rs to check script cache consistency during transaction validation.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_script_cache_rollback_inconsistency() {
    use aptos_types::transaction::Script as TxnScript;
    use move_core_types::account_address::AccountAddress;
    
    // Setup parallel execution environment
    let mut executor = create_parallel_executor();
    
    // Compile a script that depends on module M
    let script_code = compile_script_with_dependency("0x1::some_module");
    let module_code = compile_module("some_module", "0x1");
    
    // Publish module M first
    executor.publish_module(module_code);
    
    // Create transaction with script S
    let txn = create_script_transaction(script_code);
    
    // Execute in parallel - script verification will:
    // 1. Load and verify module M (tracked in captured_reads)
    // 2. Verify and cache script S (NOT tracked in captured_reads)
    let result = executor.execute_transaction_parallel(txn);
    
    // Verify script S is in cache
    assert!(executor.script_cache_contains(&script_hash));
    
    // Verify module M is in cache AND captured_reads
    assert!(executor.module_cache_contains(&module_id));
    assert!(executor.captured_reads_contains_module(&module_id));
    
    // But script S is NOT in captured_reads
    assert!(!executor.captured_reads_contains_script(&script_hash));
    
    // Abort the transaction
    executor.abort_transaction(txn.id());
    
    // After abort:
    // Module M is rolled back (removed from cache)
    assert!(!executor.module_cache_contains(&module_id));
    
    // But script S remains in cache (BUG!)
    assert!(executor.script_cache_contains(&script_hash));
    
    // Cache is now inconsistent: verified script references non-existent module
    // This can cause consensus divergence when script is executed again
}
```

## Notes

This vulnerability exists because the `UnsyncCodeStorage` delegation pattern treats script_cache and module_storage as independent components without coordinated transactional semantics. The fix requires extending the captured_reads mechanism to track script cache operations during parallel execution, ensuring that script cache changes are rolled back alongside module cache changes when transactions abort.

### Citations

**File:** aptos-move/block-executor/src/code_cache.rs (L99-131)
```rust
    fn insert_verified_module(
        &self,
        key: Self::Key,
        verified_code: Self::Verified,
        extension: Arc<Self::Extension>,
        version: Self::Version,
    ) -> VMResult<Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
        match &self.latest_view {
            ViewState::Sync(state) => {
                // For parallel execution, if we insert a verified module, we might need to also
                // update module cache in captured reads so that they also store the verified code.
                // If we do not do that, reads to module cache will end up reading "old" code that
                // is stored in captured reads and is not verified.
                let module = state.versioned_map.module_cache().insert_verified_module(
                    key.clone(),
                    verified_code,
                    extension,
                    version,
                )?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key, Some((module.clone(), version)));
                Ok(module)
            },
            ViewState::Unsync(state) => state.unsync_map.module_cache().insert_verified_module(
                key,
                verified_code,
                extension,
                version,
            ),
        }
    }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L224-235)
```rust
#[delegate_to_methods]
#[delegate(ScriptCache, target_ref = "as_script_cache")]
impl<T: Transaction, S: TStateView<Key = T::Key>> LatestView<'_, T, S> {
    /// Returns the script cache.
    fn as_script_cache(
        &self,
    ) -> &dyn ScriptCache<Key = [u8; 32], Deserialized = CompiledScript, Verified = Script> {
        match &self.latest_view {
            ViewState::Sync(state) => state.versioned_map.script_cache(),
            ViewState::Unsync(state) => state.unsync_map.script_cache(),
        }
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L546-567)
```rust
pub(crate) struct CapturedReads<T: Transaction, K, DC, VC, S> {
    data_reads: HashMap<T::Key, DataRead<T::Value>>,
    group_reads: HashMap<T::Key, GroupRead<T>>,
    delayed_field_reads: HashMap<DelayedFieldID, DelayedFieldRead>,
    // Captured always, but used for aggregator v1 validation in BlockSTMv2 flow.
    aggregator_v1_reads: HashSet<T::Key>,

    module_reads: hashbrown::HashMap<K, ModuleRead<DC, VC, S>>,

    /// If there is a speculative failure (e.g. delta application failure, or an observed
    /// inconsistency), the transaction output is irrelevant (must be discarded and transaction
    /// re-executed). We have two global flags, one for speculative failures regarding
    /// delayed fields, and the second for all other speculative failures, because these
    /// require different validation behavior (delayed fields are validated commit-time).
    delayed_field_speculative_failure: bool,
    non_delayed_field_speculative_failure: bool,
    /// Set if the invariant on CapturedReads intended use is violated. Leads to an alert
    /// and sequential execution fallback.
    incorrect_use: bool,

    data_read_comparator: DataReadComparator,
}
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L123-138)
```rust
        let immediate_dependencies = locally_verified_script
            .immediate_dependencies_iter()
            .map(|(addr, name)| {
                self.module_storage
                    .unmetered_get_existing_eagerly_verified_module(addr, name)
            })
            .collect::<VMResult<Vec<_>>>()?;

        let verified_script = self
            .runtime_environment()
            .build_verified_script(locally_verified_script, &immediate_dependencies)?;

        Ok(self
            .module_storage
            .insert_verified_script(hash, verified_script))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L233-262)
```rust
    fn unmetered_get_eagerly_verified_module(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<Option<Arc<Module>>> {
        let id = ModuleId::new(*address, module_name.to_owned());

        // Look up the verified module in cache, if it is not there, or if the module is not yet
        // verified, we need to load & verify its transitive dependencies.
        let (module, version) = match self.get_module_or_build_with(&id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer =
            VM_TIMER.timer_with_label("unmetered_get_eagerly_verified_module [cache miss]");
        let mut visited = HashSet::new();
        visited.insert(id.clone());
        Ok(Some(visit_dependencies_and_verify(
            id,
            module,
            version,
            &mut visited,
            self,
        )?))
    }
```
