# Audit Report

## Title
Integer Underflow in Transaction Restore Causing Out-of-Bounds Vector Access and Process Crash

## Summary
The `save_before_replay_version()` function contains an integer underflow vulnerability when processing backup chunks where `target_version < global_first_version`. This occurs due to improper ordering of filtering operations, causing a panic when attempting to drain more elements than exist in transaction vectors.

## Finding Description

The vulnerability exists in the transaction restore logic within the `save_before_replay_version()` function. The issue arises from two sequential filtering operations that can leave vectors in an inconsistent state: [1](#0-0) 

The problematic sequence occurs when:
1. A backup chunk spans versions `[chunk.first_version, chunk.last_version]`
2. User specifies `target_version < global_first_version` (database's next expected version)
3. The chunk passes the initial filter because `chunk.first_version <= target_version && chunk.last_version >= global_first_version`

The code first trims the chunk to retain only transactions up to `target_version` (line 475-482), then attempts to remove the first `(global_first_version - chunk.first_version)` transactions (line 486-494). However, when `target_version < global_first_version`, the second drain operation attempts to remove more transactions than remain after the first drain, causing an out-of-bounds panic.

**Concrete Attack Scenario:**
- Backup chunk contains versions [100, 1500] with 1401 transactions
- User runs restore with `--target-version 500`
- Database is at version 999, so `global_first_version = 1000`
- First drain keeps `(500 - 100 + 1) = 401` transactions
- Second drain attempts to remove `(1000 - 100) = 900` transactions from the 401 remaining
- Rust's `Vec::drain()` panics: "range end index 900 out of range for slice of length 401"

The chunk filtering logic allows such chunks through: [2](#0-1) 

## Impact Explanation

This vulnerability causes a **Denial of Service** of the backup restore functionality, categorized as **Medium Severity** per Aptos bug bounty criteria:

- **Availability Impact**: The restore process crashes and cannot complete, preventing database recovery operations
- **No Consensus/Safety Impact**: Does not affect running validators or blockchain consensus
- **No Fund Loss**: Does not compromise user funds or state integrity
- **Operational Disruption**: Requires manual intervention to identify and correct the parameter mismatch

The impact is limited to backup/restore operations, which are critical for node operators during disaster recovery scenarios but do not affect the live blockchain network.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability can be triggered through legitimate operator error:
- **Common Scenario**: An operator attempting to restore to a historical version but specifying a `target_version` less than the current database version
- **Misconfiguration**: Confusion about version numbering or attempting to "roll back" to an earlier state
- **Resume Operations**: Multi-phase restore where phase 1 advanced the database beyond the target specified for phase 2

The vulnerability requires:
1. Access to run the `backup-cli` restore command (node operator privilege)
2. A backup chunk that spans the problematic version range
3. User-specified `--target-version` less than `db_next_version`

No special attacker capabilities are required beyond operator access, making this a realistic operational error scenario.

## Recommendation

Add validation to ensure `target_version >= global_first_version` before processing chunks, or reorder the filtering operations to prevent the underflow condition:

```rust
// After line 495, before line 497:
// Validate that we have a valid version range after filtering
if first_version > last_version {
    // This chunk has been completely filtered out, skip processing
    return Ok(stream::empty());
}
```

Alternatively, add an early check at the beginning of `save_before_replay_version()`:

```rust
// After line 458:
if target_version < global_first_version {
    return Err(anyhow!(
        "Invalid restore configuration: target_version ({}) is less than the database's next expected version ({}). \
         Cannot restore to a version before the current database state.",
        target_version,
        global_first_version
    ));
}
```

This provides a clear error message to operators rather than a cryptic panic.

## Proof of Concept

```rust
#[test]
fn test_restore_with_target_below_db_version() {
    // Setup: Create a backup chunk with versions [100, 1500]
    let chunk_first = 100;
    let chunk_last = 1500;
    let mut txns: Vec<Transaction> = (chunk_first..=chunk_last)
        .map(|_| Transaction::dummy())
        .collect();
    
    // Simulate restore parameters
    let target_version = 500;
    let global_first_version = 1000; // DB is at version 999
    
    // First filtering operation (lines 475-482)
    if target_version < chunk_last {
        let num_to_keep = (target_version - chunk_first + 1) as usize;
        txns.drain(num_to_keep..);
        // Now txns has 401 elements
    }
    
    // Second filtering operation (lines 486-494)
    if global_first_version > chunk_first {
        let num_to_remove = (global_first_version - chunk_first) as usize;
        // Attempting to drain 900 elements from a vec with 401 elements
        // This panics: "range end index 900 out of range for slice of length 401"
        txns.drain(..num_to_remove);
    }
}
```

**Notes**

The vulnerability is present in the backup restore CLI functionality at lines 486-494. The root cause is the assumption that filtering operations maintain vector size consistency, which fails when `target_version < global_first_version`. While this doesn't affect live blockchain operations or consensus, it prevents disaster recovery operations from completing successfully, requiring manual diagnosis and parameter correction by operators.

The Version type is defined as `u64`: [3](#0-2) 

The `target_version` defaults to `Version::MAX` when not specified: [4](#0-3)

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L357-362)
```rust
        let chunk_manifest_stream = manifest_stream
            .map_ok(|m| stream::iter(m.chunks.into_iter().map(Result::<_>::Ok)))
            .try_flatten()
            .try_filter(move |c| {
                future::ready(c.first_version <= target_version && c.last_version >= first_version)
            })
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L474-495)
```rust
                    // remove the txns that exceeds the target_version to be restored
                    if target_version < last_version {
                        let num_to_keep = (target_version - first_version + 1) as usize;
                        txns.drain(num_to_keep..);
                        persisted_aux_info.drain(num_to_keep..);
                        txn_infos.drain(num_to_keep..);
                        event_vecs.drain(num_to_keep..);
                        write_sets.drain(num_to_keep..);
                        last_version = target_version;
                    }

                    // remove the txns that are before the global_first_version
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
                    }
```

**File:** types/src/transaction/mod.rs (L98-98)
```rust
pub type Version = u64; // Height - also used for MVCC in StateDB
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L294-294)
```rust
        let target_version = opt.target_version.unwrap_or(Version::MAX);
```
