# Audit Report

## Title
Aptos Debugger Tool Lacks Access Controls Enabling Unauthorized Database Access

## Summary
The `aptos-debugger` tool, deployed on production validator nodes, has no built-in access controls to restrict who can execute it or what data they can access. Any user with command-line access to the validator container can use the debugger to read sensitive validator state, pending transactions, consensus data, and all on-chain state data from AptosDB without authentication or authorization checks.

## Finding Description

The `aptos-debugger` is a command-line tool included in production validator Docker images that provides direct access to sensitive blockchain data. [1](#0-0) 

The tool's main entry point simply parses command-line arguments and executes the requested command with no access control verification. [2](#0-1) 

The debugger exposes four major attack surfaces through its subcommands: [3](#0-2) 

**1. Consensus Data Exposure via `DumpPendingTxns`**

The `DumpPendingTxns` command directly accesses the ConsensusDB and QuorumStoreDB to extract pending transactions and consensus blocks. [4](#0-3) 

This command can extract all pending transactions from uncommitted blocks, including:
- User transactions not yet finalized on-chain
- Transaction ordering information useful for MEV
- Internal consensus state

**2. Complete State Data Exposure via `state-kv scan-snapshot`**

The state-kv scan-snapshot command can iterate through ALL key-value pairs in the state database at any version. [5](#0-4) 

This provides unrestricted access to:
- All account balances
- Validator configurations and private validator state
- Smart contract state
- Any sensitive on-chain data

**3. Historical Transaction Data via `examine print-raw-data-by-version`**

The examine command exposes transaction details, write sets, events, and transaction metadata for any blockchain version. [6](#0-5) 

**4. Container Security Context**

In Kubernetes deployments, even when not in privileged mode, the validator container runs as user 6180 (aptos) with read access to the database directory. [7](#0-6) 

While Kubernetes RBAC controls who can exec into pods through the "debuggers" group, [8](#0-7)  once a user has container access, there are NO additional access controls enforced by the debugger tool itself.

**Attack Scenario:**

1. An attacker gains container access through:
   - Compromised credentials for a user in the "debuggers" Kubernetes group
   - Overly permissive RBAC policies
   - Exploitation of cluster vulnerabilities
   - Insider threat with limited authorized access

2. The attacker executes:
   ```bash
   # Extract all pending transactions
   /usr/local/bin/aptos-debugger dump-pending-txns --db-dir /opt/aptos/data/db
   
   # Scan all state data
   /usr/local/bin/aptos-debugger aptos-db debug state-kv scan-snapshot \
     --db-dir /opt/aptos/data/db --version <latest_version>
   
   # Extract specific transaction details
   /usr/local/bin/aptos-debugger aptos-db debug examine print-raw-data-by-version \
     --db-dir /opt/aptos/data/db --version <target_version>
   ```

3. The tool provides full access with no authentication, authorization checks, or audit logging.

**Broken Security Guarantees:**

This violates the principle of least privilege and breaks implicit access control expectations:
- No authentication: The tool doesn't verify user identity
- No authorization: The tool doesn't check what data the user should access
- No audit logging: No security events are logged for debugger usage [9](#0-8) 
- No rate limiting: Unrestricted data extraction
- No data scope limitation: Full database read access

## Impact Explanation

While this issue represents a legitimate security concern regarding defense-in-depth and principle of least privilege, it **does not meet the Critical, High, or Medium severity thresholds** defined in the Aptos bug bounty program for the following reasons:

1. **Requires Privileged Access:** Exploitation requires container access to validator nodes, which is considered "privileged validator access" per the trust model. The bug bounty explicitly focuses on "bugs exploitable without requiring privileged validator access."

2. **Information Disclosure Severity:** The Aptos bug bounty categorizes "Minor information leaks" as Low Severity ($1,000 maximum). While the data exposed is sensitive, it does not directly lead to:
   - Loss of funds (Critical)
   - Consensus/safety violations (Critical)
   - Network partition (Critical)
   - Validator slowdowns (High)
   - Limited funds loss (Medium)

3. **Trusted Actor Requirement:** The trust model explicitly lists "validator operators" as trusted actors. Anyone with container access to production validators is operating at validator operator privilege level.

4. **No Direct Exploitable Impact:** Reading data does not directly enable:
   - Stealing funds
   - Breaking consensus
   - Causing liveness failures
   - Manipulating validator state

**Best Classification:** This would be a **Low Severity** security hardening issue focused on operational security and defense-in-depth rather than a direct vulnerability with exploitable impact.

## Likelihood Explanation

**Prerequisites for exploitation:**
- Kubernetes cluster access with pods/exec permissions, OR
- Compromised credentials for accounts in the "debuggers" group, OR
- Insider threat with authorized but excessive access

**Likelihood: Low-to-Medium**

While the technical barrier is low once container access is obtained, the requirement for privileged access significantly reduces the likelihood. Organizations following Kubernetes security best practices would limit pod exec permissions to authorized operators.

## Recommendation

Implement defense-in-depth access controls:

**1. Add Authentication & Authorization:**
```rust
// In crates/aptos-debugger/src/main.rs
#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);
    
    // Verify authorized user before executing sensitive commands
    verify_authorized_user()?;
    
    let cmd = Cmd::parse();
    
    // Log security event for audit trail
    security_log_debugger_execution(&cmd);
    
    cmd.run().await
}

fn verify_authorized_user() -> Result<()> {
    // Check environment variable or auth token
    // Verify against whitelist of authorized users
    // Or require interactive confirmation for sensitive operations
}
```

**2. Add Audit Logging:**

Add new SecurityEvent variants for debugger access:
```rust
// In crates/aptos-logger/src/security.rs
pub enum SecurityEvent {
    // ... existing variants ...
    
    /// Debugger tool accessed database
    DebuggerDatabaseAccess,
    
    /// Debugger tool read sensitive state data  
    DebuggerStateAccess,
    
    /// Debugger tool accessed pending transactions
    DebuggerPendingTxnAccess,
}
```

**3. Implement Least Privilege:**
- Create separate tools for different access levels
- Require explicit flags for sensitive operations
- Add read-only vs read-write access modes
- Implement data scope restrictions (e.g., version ranges)

**4. Container Security Hardening:**
- Mount database as read-only when possible
- Use separate service accounts with minimal permissions
- Implement file-level access controls
- Add SELinux/AppArmor policies

**5. Operational Monitoring:**
- Alert on debugger tool execution
- Log all database access operations
- Implement anomaly detection for unusual access patterns

## Proof of Concept

```bash
#!/bin/bash
# Prerequisites: kubectl access to validator pod

# 1. Exec into validator container
kubectl exec -it <validator-pod-name> -- /bin/bash

# 2. Extract pending transactions (no authentication required)
/usr/local/bin/aptos-debugger dump-pending-txns \
  --db-dir /opt/aptos/data/db \
  > pending_txns.json

# 3. Scan all state data (no authorization checks)
/usr/local/bin/aptos-debugger aptos-db debug state-kv scan-snapshot \
  --db-dir /opt/aptos/data/db \
  --version $(cat /opt/aptos/data/db/ledger_db/ledger_metadata | grep version) \
  > full_state_dump.txt

# 4. Extract transaction details for any version
/usr/local/bin/aptos-debugger aptos-db debug examine print-raw-data-by-version \
  --db-dir /opt/aptos/data/db \
  --version 1000000 \
  > tx_details.json

# All operations succeed with no access control enforcement
echo "Successfully extracted sensitive data with no authentication"
```

**Expected Result:** All commands execute successfully with full database read access and no access control enforcement or audit logging.

## Notes

**Validation Against Checklist:**

- ✗ **Exploitable by unprivileged attacker:** Requires privileged container access
- ✗ **Impact meets Critical/High/Medium severity:** Information disclosure = Low severity  
- ✗ **Breaks documented invariant:** No explicit invariant about internal access controls
- ✓ **Lies within Aptos Core codebase:** Yes
- ✓ **Realistic attack path:** Yes, given container access
- ✓ **Clear security concern:** Yes, violates least privilege

**Conclusion:** While this represents a valid security hardening opportunity, it does not meet the bug bounty program's criteria for reportable vulnerabilities due to the privileged access requirement and information disclosure impact classification.

### Citations

**File:** docker/builder/validator.Dockerfile (L26-26)
```dockerfile
COPY --link --from=tools-builder /aptos/dist/aptos-debugger /usr/local/bin/
```

**File:** crates/aptos-debugger/src/main.rs (L14-20)
```rust
#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);

    Cmd::parse().run().await
}
```

**File:** crates/aptos-debugger/src/lib.rs (L7-18)
```rust
#[derive(Parser)]
pub enum Cmd {
    #[clap(subcommand)]
    AptosDb(aptos_db_tool::DBTool),

    Decode(aptos_move_debugger::bcs_txn_decoder::Command),

    DumpPendingTxns(aptos_consensus::util::db_tool::Command),

    #[clap(subcommand)]
    Move(aptos_move_debugger::common::Command),
}
```

**File:** consensus/src/util/db_tool.rs (L44-66)
```rust
    pub fn dump_pending_txns(&self) -> Result<Vec<Transaction>> {
        let quorum_store_db = QuorumStoreDB::new(self.db_dir.clone());
        let all_batches = quorum_store_db.get_all_batches().unwrap();

        let consensus_db = ConsensusDB::new(self.db_dir.clone());
        let (_, _, blocks, _) = consensus_db.get_data()?;

        let mut txns = Vec::new();
        for block in blocks {
            let id = block.id();
            #[allow(clippy::unwrap_in_result)]
            if self.block_id.is_none() || id == self.block_id.unwrap() {
                txns.extend(
                    extract_txns_from_block(&block, &all_batches)?
                        .into_iter()
                        .cloned()
                        .map(Transaction::UserTransaction),
                );
            }
        }

        Ok(txns)
    }
```

**File:** storage/aptosdb/src/db_debugger/state_kv/scan_snapshot.rs (L38-49)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        println!(
            "{}",
            format!(
                "* Scan all key values in snapshot at version {} in the key hash value order. \n",
                self.version,
            )
            .yellow()
        );

        let state_kv_db = Arc::new(self.db_dir.open_state_kv_db()?);
```

**File:** storage/aptosdb/src/db_debugger/examine/print_raw_data_by_version.rs (L23-79)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        let rocksdb_config = RocksdbConfigs {
            enable_storage_sharding: self.sharding_config.enable_storage_sharding,
            ..Default::default()
        };
        let env = None;
        let block_cache = None;

        let (ledger_db, _, _, _) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&self.db_dir),
            rocksdb_config,
            env,
            block_cache,
            /*readonly=*/ true,
            /*max_num_nodes_per_lru_cache_shard=*/ 0,
            /*reset_hot_state=*/ false,
        )?;

        println!(
            "Transaction: {:?}",
            ledger_db.transaction_db().get_transaction(self.version)?
        );

        println!(
            "PersistedAuxiliaryInfo: {:?}",
            ledger_db
                .persisted_auxiliary_info_db()
                .get_persisted_auxiliary_info(self.version)?
        );

        println!(
            "WriteSet: {:?}",
            ledger_db.write_set_db().get_write_set(self.version)?
        );

        println!(
            "Events: {:?}",
            ledger_db.event_db().get_events_by_version(self.version)?
        );

        println!(
            "TransactionInfo: {:?}",
            ledger_db
                .transaction_info_db()
                .get_transaction_info(self.version)?
        );

        println!(
            "TransactionAccumulatorHash: {:?}",
            ledger_db
                .transaction_accumulator_db()
                .get_root_hash(self.version)?
        );

        Ok(())
    }
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L193-227)
```yaml
        securityContext:
          {{- if $.Values.enablePrivilegedMode }}
          runAsUser: 0
          privileged: true
          {{- else }}
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          {{- end }}
      {{- with $.Values.validator }}
      {{- with .nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      securityContext:
        {{- if $.Values.enablePrivilegedMode }}
        runAsUser: 0
        runAsGroup: 0
        fsGroup: 0
        {{- else }}
        runAsNonRoot: true
        runAsUser: 6180
        runAsGroup: 6180
        fsGroup: 6180
        {{- end }}
```

**File:** terraform/modules/eks/kubernetes.tf (L87-114)
```terraform
resource "kubernetes_cluster_role" "debug" {
  metadata {
    name = "debug"
  }

  rule {
    api_groups = [""]
    resources  = ["pods/portforward", "pods/exec"]
    verbs      = ["create"]
  }
}

resource "kubernetes_role_binding" "debuggers" {
  metadata {
    name = "debuggers"
  }

  role_ref {
    api_group = "rbac.authorization.k8s.io"
    kind      = "ClusterRole"
    name      = kubernetes_cluster_role.debug.metadata[0].name
  }

  subject {
    kind = "Group"
    name = "debuggers"
  }
}
```

**File:** crates/aptos-logger/src/security.rs (L23-82)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```
