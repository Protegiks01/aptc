# Audit Report

## Title
Multisig Account State Corruption on Cleanup Failure

## Summary
The `failure_multisig_payload_cleanup()` function in the Aptos VM can fail and leave multisig accounts in a permanently corrupted state. When the cleanup function aborts (e.g., due to state inconsistencies or `table::remove` failing), the error handling mechanism commits the transaction prologue changes (sequence number increment) but discards the multisig cleanup changes (transaction removal, sequence number update), rendering the multisig account unusable.

## Finding Description
The vulnerability exists in the multisig transaction execution flow where cleanup operations are not handled atomically with respect to the overall transaction state.

**Execution Flow:**

1. A multisig transaction is submitted and passes prologue validation [1](#0-0) 

2. The multisig payload execution fails, triggering cleanup [2](#0-1) 

3. The cleanup function `failure_multisig_payload_cleanup` creates a fresh epilogue session and attempts to execute the Move cleanup function [3](#0-2) 

4. The Move cleanup function must remove the transaction from the table and update `last_executed_sequence_number` [4](#0-3) 

**Critical Failure Point:**

The `table::remove` operation will **abort** if the transaction key doesn't exist in the table. When this abort occurs during cleanup:

- The epilogue_session changes (including the cleanup) are discarded due to the error propagation at line 1321
- The error is caught by `unwrap_or_else` and passed to `on_user_transaction_execution_failure` [5](#0-4) 
- This invokes `failed_transaction_cleanup` with the **original** `prologue_session_change_set` [6](#0-5) 
- The fallback cleanup only includes prologue changes, NOT the multisig-specific state updates [7](#0-6) 

**Result:** The transaction is marked as "Keep" (charges gas and increments sequence number) but the multisig state is not updated:
- Sender's account sequence number: ✓ Incremented (committed)
- Transaction removed from multisig table: ✗ Not removed (discarded)
- `last_executed_sequence_number` updated: ✗ Not updated (discarded)

This violates the **State Consistency** invariant - the transaction partially succeeds, leaving the multisig account in an inconsistent state where the transaction appears pending but cannot be executed.

## Impact Explanation
**Severity: Medium**

This vulnerability causes **state inconsistencies requiring intervention** as defined in the Aptos bug bounty program's Medium severity category.

**Impact:**
1. **Multisig Account Denial of Service**: The affected multisig account becomes permanently unusable for its intended purpose
2. **Fund Locking**: Any funds controlled exclusively by the multisig account cannot be accessed through normal operations
3. **Transaction Queue Corruption**: All pending transactions with sequence numbers > N cannot execute because transaction N is stuck
4. **No Self-Recovery**: There is no on-chain mechanism to recover from this state without governance intervention

**Affected Parties:**
- Multisig account owners lose control over their account
- Projects using multisig accounts for treasury management
- DAO governance systems built on multisig accounts

**Does not qualify for Higher Severity because:**
- Does not directly cause loss of funds (funds are frozen, not stolen)
- Does not affect consensus or network-wide operations
- Limited to individual multisig accounts (not systemic)
- Requires specific failure conditions to trigger

## Likelihood Explanation
**Likelihood: Medium**

**Triggering Conditions:**

The cleanup can fail when:

1. **State Corruption Scenario**: If a previous partial execution left the multisig state inconsistent (transaction already removed but sequence number not updated)

2. **Race Condition**: In theoretical concurrent access scenarios where state is modified between validation and cleanup

3. **Resource Exhaustion**: If the MultisigAccount resource is deleted or corrupted during execution

4. **Logic Errors**: Bugs in related code that manipulate the multisig transaction table

The `table::remove` operation aborts when the key is not found, which can occur in edge cases even though the transaction was validated initially.

**Probability Assessment:**
- **Not theoretical**: The code path exists and is reachable
- **Requires specific conditions**: Needs cleanup to fail, which is not common in normal operation
- **Increasing likelihood**: As the system scales and state complexity grows, edge cases become more probable
- **Reproducible**: Once conditions are met, the vulnerability is deterministic

## Recommendation

**Fix Strategy**: Wrap the cleanup execution in a try-catch mechanism that handles failures gracefully without corrupting state.

**Recommended Implementation:**

1. **Option 1 (Preferred)**: Make cleanup functions infallible by design:
   - Check if transaction exists before attempting removal
   - Use conditional logic instead of operations that can abort
   - Emit events for audit trail even if cleanup partially fails

2. **Option 2**: Implement cleanup failure recovery:
   - If cleanup fails, still commit the multisig state changes manually
   - Add a recovery mechanism that can fix corrupted multisig accounts
   - Provide an escape hatch for stuck transactions

**Code Fix Example** (pseudocode for Move cleanup function):

```move
fun failed_transaction_execution_cleanup(
    executor: address,
    multisig_account: address,
    transaction_payload: vector<u8>,
    execution_error: ExecutionError,
) acquires MultisigAccount {
    let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);
    let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
    
    // Safe removal - check existence first
    if (table::contains(&multisig_account_resource.transactions, sequence_number)) {
        let transaction = table::remove(&mut multisig_account_resource.transactions, sequence_number);
        multisig_account_resource.last_executed_sequence_number = sequence_number;
        // ... rest of cleanup logic
    } else {
        // Transaction already removed - log warning but don't abort
        // Still update sequence number to maintain consistency
        multisig_account_resource.last_executed_sequence_number = sequence_number;
    }
    // ... emit events
}
```

3. **Option 3**: Add a governance function to manually recover corrupted multisig accounts:
   - Allow clearing stuck transactions
   - Allow resetting sequence numbers
   - Require multi-sig approval from account owners

## Proof of Concept

```move
#[test_only]
module aptos_framework::multisig_corruption_poc {
    use aptos_framework::multisig_account;
    use aptos_framework::account;
    use std::signer;
    
    #[test(owner1 = @0x100, owner2 = @0x200, framework = @aptos_framework)]
    fun test_cleanup_failure_corrupts_state(
        owner1: &signer,
        owner2: &signer,
        framework: &signer
    ) {
        // Setup: Create multisig account
        let owner1_addr = signer::address_of(owner1);
        account::create_account_for_test(owner1_addr);
        
        multisig_account::create_with_owners(
            owner1,
            vector[signer::address_of(owner2)],
            2, // 2-of-2 multisig
            vector[],
            vector[]
        );
        
        let multisig_addr = multisig_account::get_next_multisig_account_address(owner1_addr);
        
        // Create a transaction that will fail during execution
        let payload = create_failing_payload();
        multisig_account::create_transaction(owner1, multisig_addr, payload);
        
        // Approve the transaction
        multisig_account::approve(owner2, multisig_addr, 1);
        
        // Manually corrupt the state by removing the transaction before execution
        // This simulates the scenario where cleanup fails because table::remove aborts
        let multisig_resource = borrow_global_mut<MultisigAccount>(multisig_addr);
        table::remove(&mut multisig_resource.transactions, 1);
        
        // Now execute - this will trigger cleanup which will fail
        // because the transaction is already removed
        multisig_account::execute_rejected_transaction(owner1, multisig_addr);
        
        // Verify corrupted state:
        // 1. Sender sequence number should be incremented
        assert!(account::get_sequence_number(owner1_addr) > initial_seq, 0);
        
        // 2. But last_executed_sequence_number should NOT be updated due to failed cleanup
        assert!(multisig_account::last_resolved_sequence_number(multisig_addr) == 0, 1);
        
        // 3. Account is now stuck - cannot execute any new transactions
        // because they require in-order execution
    }
}
```

## Notes

The vulnerability stems from the asymmetric error handling between successful and failed execution paths in multisig transactions. The system assumes cleanup operations are infallible, but the Move code can abort during cleanup (particularly in `table::remove`), leading to partial state commits that violate atomicity guarantees.

The fix requires either making cleanup operations truly infallible or implementing a recovery mechanism for corrupted multisig accounts. Without intervention, affected accounts remain permanently unusable, requiring governance action or manual state repair.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L689-791)
```rust
    fn finish_aborted_transaction(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        status: ExecutionStatus,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> Result<VMOutput, VMStatus> {
        // Storage refund is zero since no slots are deleted in aborted transactions.
        const ZERO_STORAGE_REFUND: u64 = 0;

        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;

        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;

            let mut abort_hook_session_change_set =
                abort_hook_session.finish(change_set_configs, module_storage)?;
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };

            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);

            // Verify we charged sufficiently for creating an account slot
            let gas_params = self.gas_params(log_context)?;
            let gas_unit_price = u64::from(txn_data.gas_unit_price());
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
                    expect_only_successful_execution(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(
                                "Insufficient fee for storing account for lazy account creation"
                                    .to_string(),
                            )
                            .finish(Location::Undefined),
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )?;
                }
            }
            (abort_hook_session_change_set, fee_statement)
        } else {
            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
            (prologue_session_change_set, fee_statement)
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1312-1321)
```rust
        let epilogue_session = match execution_result {
            Err(execution_error) => self.failure_multisig_payload_cleanup(
                resolver,
                module_storage,
                prologue_session_change_set,
                execution_error,
                txn_data,
                cleanup_args,
                traversal_context,
            )?,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1413-1440)
```rust
        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            prologue_session_change_set.clone(),
        );
        let execution_error = ExecutionError::try_from(execution_error)
            .map_err(|_| VMStatus::error(StatusCode::UNREACHABLE, None))?;
        // Serialization is not expected to fail so we're using invariant_violation error here.
        cleanup_args.push(bcs::to_bytes(&execution_error).map_err(|_| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("MultiSig payload cleanup error.".to_string())
                .finish(Location::Undefined)
        })?);
        epilogue_session.execute(|session| {
            session
                .execute_function_bypass_visibility(
                    &MULTISIG_ACCOUNT_MODULE,
                    FAILED_TRANSACTION_EXECUTION_CLEANUP,
                    vec![],
                    cleanup_args,
                    &mut UnmeteredGasMeter,
                    traversal_context,
                    module_storage,
                )
                .map_err(|e| e.into_vm_status())
        })?;
        Ok(epilogue_session)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1968-1979)
```rust
        self.failed_transaction_cleanup(
            prologue_session_change_set,
            err,
            gas_meter,
            txn_data,
            resolver,
            module_storage,
            serialized_signers,
            log_context,
            change_set_configs,
            traversal_context,
        )
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1999-2012)
```rust
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2105-2118)
```rust
        let (vm_status, mut output) = result.unwrap_or_else(|err| {
            self.on_user_transaction_execution_failure(
                prologue_change_set,
                err,
                resolver,
                code_storage,
                &serialized_signers,
                &txn_data,
                log_context,
                gas_meter,
                change_set_configs,
                &mut traversal_context,
            )
        });
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1288-1292)
```text
    fun remove_executed_transaction(multisig_account_resource: &mut MultisigAccount): (u64, u64) {
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::remove(&mut multisig_account_resource.transactions, sequence_number);
        multisig_account_resource.last_executed_sequence_number = sequence_number;
        num_approvals_and_rejections_internal(&multisig_account_resource.owners, &transaction)
```
