# Audit Report

## Title
State Divergence via Non-Deterministic `discard_failed_blocks` Configuration in Block Execution

## Summary
The `execute_block()` implementation violates deterministic execution by using a local, per-node configuration parameter (`discard_failed_blocks`) that directly affects block execution outcomes. When block execution fails, validators with different configuration values produce different results for the same block, causing state divergence and consensus violations.

## Finding Description

The vulnerability exists in the block execution path where the `discard_failed_blocks` configuration parameter determines how execution failures are handled. This parameter is part of `BlockExecutorLocalConfig` (local, per-node configuration) rather than `BlockExecutorConfigFromOnchain` (required to be the same across all nodes). [1](#0-0) 

The parameter is set at node startup from the local execution configuration file with a default value of `false`: [2](#0-1) 

It is stored in a static `OnceCell` that is set once per node: [3](#0-2) [4](#0-3) 

During block execution, this local configuration value is used: [5](#0-4) 

When both parallel and sequential execution fail, the behavior diverges based on this configuration: [6](#0-5) 

**Attack Scenario:**

1. Attacker crafts or identifies a transaction that triggers a block execution failure (e.g., resource group serialization error, delayed field code invariant violation)
2. The network has validators with different `discard_failed_blocks` settings:
   - Some validators: `discard_failed_blocks = false` (default)
   - Other validators: `discard_failed_blocks = true` (custom config)
3. When processing the problematic block:
   - Validators with `false`: Return `Err(sequential_error)`, fail to produce output
   - Validators with `true`: Return `Ok(BlockOutput)` with all transactions discarded
4. Validators cannot reach consensus on the block outcome, causing chain fork

This breaks the fundamental consensus invariant: **"All validators must produce identical state roots for identical blocks"**

## Impact Explanation

This is a **Critical Severity** vulnerability per Aptos bug bounty criteria because it causes:

1. **Consensus/Safety violations**: Different validators produce different outputs for the same input, violating BFT consensus safety
2. **Non-recoverable network partition**: Validators fork into incompatible chains based on their local configuration, potentially requiring a hard fork to recover
3. **State divergence**: Validators with different configurations maintain incompatible state, breaking the blockchain's fundamental integrity

The vulnerability affects the entire validator set since any subset with different configurations will diverge when encountering execution failures.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is likely to occur because:

1. **Configuration variability is expected**: `discard_failed_blocks` is a legitimate configuration option that validators may set differently based on operational preferences
2. **Execution failures occur in production**: Block execution can fail due to various reasons (resource group serialization, delayed field issues, VM errors)
3. **No enforcement mechanism**: There is no protocol-level check ensuring all validators use the same value
4. **Silent divergence**: The issue may not be immediately detected since both outcomes appear valid at the local level

An attacker can deliberately trigger execution failures to exploit this vulnerability once they know validators have different configurations.

## Recommendation

Move `discard_failed_blocks` from local configuration to on-chain configuration to ensure all validators use the same value:

**1. Remove from local config:**
- Remove `discard_failed_blocks` from `BlockExecutorLocalConfig`
- Remove the static `DISCARD_FAILED_BLOCKS` OnceCell from `AptosVM`

**2. Add to on-chain config:**
- Add `discard_failed_blocks` to `BlockExecutorConfigFromOnchain` 
- Source the value from on-chain consensus configuration that all validators must follow

**3. Alternative short-term fix:**
- Force `discard_failed_blocks = false` for all validators in production to ensure consistent behavior
- Add validation that rejects block proposals if validators detect configuration mismatches

The proper fix ensures this critical execution parameter is consensus-controlled rather than locally configured.

## Proof of Concept

**Reproduction Steps:**

1. **Setup two validator nodes with different configurations:**

```yaml
# Validator A config (execution_config)
discard_failed_blocks: false

# Validator B config (execution_config)  
discard_failed_blocks: true
```

2. **Trigger a block execution failure:**
   - Submit a transaction that causes resource group serialization to fail
   - This can be triggered via failpoint: `fail-point-resource-group-serialization`
   
3. **Observe divergent behavior:**
   - Validator A: Block execution returns error, no output produced
   - Validator B: Block execution returns `Ok(BlockOutput)` with discarded transactions
   
4. **Result:**
   - Validators cannot agree on the same state root
   - Consensus stalls or network partitions based on configuration distribution

**Expected Behavior:**
All validators should handle execution failures identically, either all discarding or all propagating errors, based on a consensus-agreed configuration value.

**Notes**

The root cause is a design flaw where a critical execution parameter that affects consensus determinism is placed in local configuration (`BlockExecutorLocalConfig`) instead of on-chain configuration (`BlockExecutorConfigFromOnchain`). The comments in the code explicitly distinguish between these two configuration types, but `discard_failed_blocks` was incorrectly categorized.

This vulnerability demonstrates that any configuration parameter affecting block execution outcomes must be consensus-controlled to maintain the blockchain's fundamental safety properties.

### Citations

**File:** types/src/block_executor/config.rs (L51-64)
```rust
/// Local, per-node configuration.
#[derive(Clone, Debug)]
pub struct BlockExecutorLocalConfig {
    // If enabled, uses BlockSTMv2 algorithm / scheduler for parallel execution.
    pub blockstm_v2: bool,
    pub concurrency_level: usize,
    // If specified, parallel execution fallbacks to sequential, if issue occurs.
    // Otherwise, if there is an error in either of the execution, we will panic.
    pub allow_fallback: bool,
    // If true, we will discard the failed blocks and continue with the next block.
    // (allow_fallback needs to be set)
    pub discard_failed_blocks: bool,
    pub module_cache_config: BlockExecutorModuleCacheLocalConfig,
}
```

**File:** config/src/config/execution_config.rs (L30-46)
```rust
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct ExecutionConfig {
    #[serde(skip)]
    /// For testing purposes, the ability to add a genesis transaction directly
    pub genesis: Option<Transaction>,
    /// Location of the genesis file
    pub genesis_file_location: PathBuf,
    /// Number of threads to run execution.
    /// If 0, we use min of (num of cores/2, DEFAULT_CONCURRENCY_LEVEL) as default concurrency level
    pub concurrency_level: u16,
    /// Number of threads to read proofs
    pub num_proof_reading_threads: u16,
    /// Enables paranoid mode for types, which adds extra runtime VM checks
    pub paranoid_type_verification: bool,
    /// Enabled discarding blocks that fail execution due to BlockSTM/VM issue.
    pub discard_failed_blocks: bool,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L164-164)
```rust
static DISCARD_FAILED_BLOCKS: OnceCell<bool> = OnceCell::new();
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L470-482)
```rust
    /// Sets runtime config when invoked the first time.
    pub fn set_discard_failed_blocks(enable: bool) {
        // Only the first call succeeds, due to OnceCell semantics.
        DISCARD_FAILED_BLOCKS.set(enable).ok();
    }

    /// Get the discard failed blocks flag if already set, otherwise return default (false)
    pub fn get_discard_failed_blocks() -> bool {
        match DISCARD_FAILED_BLOCKS.get() {
            Some(enable) => *enable,
            None => false,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3110-3120)
```rust
        let config = BlockExecutorConfig {
            local: BlockExecutorLocalConfig {
                blockstm_v2: AptosVM::get_blockstm_v2_enabled(),
                concurrency_level: AptosVM::get_concurrency_level(),
                allow_fallback: true,
                discard_failed_blocks: AptosVM::get_discard_failed_blocks(),
                module_cache_config: BlockExecutorModuleCacheLocalConfig::default(),
            },
            onchain: onchain_config,
        };
        self.execute_block_with_config(txn_provider, state_view, config, transaction_slice_metadata)
```

**File:** aptos-move/block-executor/src/executor.rs (L2648-2665)
```rust
        if self.config.local.discard_failed_blocks {
            // We cannot execute block, discard everything (including block metadata and validator transactions)
            // (TODO: maybe we should add fallback here to first try BlockMetadataTransaction alone)
            let error_code = match sequential_error {
                BlockExecutionError::FatalBlockExecutorError(_) => {
                    StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                },
                BlockExecutionError::FatalVMError(_) => {
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                },
            };
            let ret = (0..signature_verified_block.num_txns())
                .map(|_| E::Output::discard_output(error_code))
                .collect();
            return Ok(BlockOutput::new(ret, None));
        }

        Err(sequential_error)
```
