# Audit Report

## Title
Diagnostic Health Check Bypass via On-Chain Gas Price Update Creates False Negatives and Masks Consensus Failures

## Summary
The diagnostic health check tool in `diag.rs` uses a compile-time constant for gas price (`aptos_global_constants::GAS_UNIT_PRICE = 100`) while validators validate transactions against the on-chain `min_price_per_gas_unit` parameter. If governance updates the on-chain minimum gas price above 100, all diagnostic transactions will be rejected as underpriced, causing health checks to fail even when the cluster is healthy and potentially masking real consensus failures.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Diagnostic Tool Gas Price** - The `diag()` function uses the hardcoded compile-time constant: [1](#0-0) 

2. **On-Chain Gas Schedule** - The `min_price_per_gas_unit` parameter is stored on-chain and can be updated via governance: [2](#0-1) 

3. **Validator Gas Price Validation** - Validators load the on-chain gas schedule and reject transactions below the minimum: [3](#0-2) 

**Attack Scenario:**

1. A governance proposal updates the on-chain `min_price_per_gas_unit` to 200 (or any value > 100) via: [4](#0-3) 

2. After epoch change, validators load the updated gas parameters from on-chain storage: [5](#0-4) 

3. The diagnostic tool submits transactions with `gas_unit_price = 100`: [6](#0-5) 

4. Validators reject these transactions with `GAS_UNIT_PRICE_BELOW_MIN_BOUND` because 100 < 200.

5. The diagnostic check fails and reports "Failed to submit txn": [7](#0-6) 

6. Operators see health check failures and may mistakenly diagnose consensus or network issues when the cluster is actually healthy.

## Impact Explanation

**Severity: High**

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for:

1. **Validator node operational issues** - The diagnostic health monitoring system becomes unreliable, causing operational confusion and potential service degradation as operators chase false alarms.

2. **Significant protocol violations** - The health check system is a critical operational component that ensures cluster reliability. Breaking this monitoring infrastructure represents a significant protocol violation.

3. **Masked Consensus Failures** - Most critically, if real consensus failures occur concurrently with this gas price mismatch, operators will incorrectly attribute the health check failures to the gas price issue, potentially allowing serious consensus problems to go undetected.

The impact affects all diagnostic health checks across all nodes, creating a systemic monitoring blind spot that could hide critical failures.

## Likelihood Explanation

**Likelihood: Medium to High**

1. **Governance Updates are Expected** - The gas schedule is designed to be updateable via governance, and the comment in the code suggests future updates are anticipated: [8](#0-7) 

2. **No Bounds Checking** - There's no validation preventing governance from setting `min_price_per_gas_unit` to values incompatible with the diagnostic tool.

3. **Compile-Time vs Runtime Mismatch** - The fundamental design flaw is that the diagnostic tool relies on compile-time constants while the system operates on runtime on-chain parameters.

4. **Unintentional or Malicious** - This could occur accidentally (governance members unaware of the diagnostic tool's dependency) or intentionally (malicious actor seeking to blind monitoring).

## Recommendation

**Fix: Query On-Chain Gas Price Before Creating Diagnostic Transactions**

The diagnostic tool should query the current on-chain `min_price_per_gas_unit` before creating transactions:

```rust
// In crates/transaction-emitter/src/diag.rs

pub async fn diag(cluster: &Cluster) -> Result<()> {
    let client = cluster.random_instance().rest_client();
    
    // Query on-chain gas parameters
    let gas_schedule = client
        .get_account_resource_bcs::<GasScheduleV2>(
            AccountAddress::from_hex_literal("0x1")?,
            "0x1::gas_schedule::GasScheduleV2"
        )
        .await?
        .into_inner();
    
    let gas_entries: BTreeMap<String, u64> = gas_schedule.into_btree_map();
    let min_gas_price = gas_entries
        .get("txn.min_price_per_gas_unit")
        .copied()
        .unwrap_or(aptos_global_constants::GAS_UNIT_PRICE);
    
    // Add safety margin to ensure acceptance
    let safe_gas_price = min_gas_price + 10;
    
    let mut coin_source_account = cluster.load_coin_source_account(&client).await?;
    let emitter = TxnEmitter::new(
        TransactionFactory::new(cluster.chain_id)
            .with_gas_unit_price(safe_gas_price),  // Use on-chain value
        StdRng::from_entropy(),
        client,
    );
    // ... rest of function
}
```

**Alternative Fix: Add Validation to Gas Schedule Updates**

Add a governance invariant check that prevents setting `min_price_per_gas_unit` to values that would break known system components:

```move
// In aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move

const EMIN_GAS_PRICE_TOO_HIGH: u64 = 4;
const MAX_SAFE_MIN_GAS_PRICE: u64 = 1000; // Conservative upper bound

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Validate min_price_per_gas_unit is within safe bounds
    // (would need helper function to extract this specific parameter)
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

## Proof of Concept

**Setup:**
1. Deploy an Aptos test network with the current codebase
2. Deploy the diagnostic tool

**Reproduction Steps:**

```bash
# Step 1: Verify current behavior (should succeed)
cargo run --bin transaction-emitter -- diag \
  --targets http://localhost:8080 \
  --chain-id 4

# Expected: "Looks like all full nodes are healthy!"

# Step 2: Submit governance proposal to update gas schedule
# This requires preparing a gas schedule blob with min_price_per_gas_unit = 200

aptos move run \
  --function-id 0x1::gas_schedule::set_for_next_epoch \
  --args "hex:<gas_schedule_blob_with_min_price_200>"

# Step 3: Trigger epoch change and wait for it to complete
aptos move run \
  --function-id 0x1::aptos_governance::reconfigure

# Step 4: Run diagnostic again (should now fail)
cargo run --bin transaction-emitter -- diag \
  --targets http://localhost:8080 \
  --chain-id 4

# Expected: "Failed to submit txn through <instance>: 
#  VmError with status code GAS_UNIT_PRICE_BELOW_MIN_BOUND"

# Step 5: Verify cluster is actually healthy by submitting 
# a transaction with correct gas price
aptos account transfer \
  --account <test_account> \
  --amount 1000 \
  --gas-unit-price 200

# Expected: Transaction succeeds, confirming cluster is healthy
# but diagnostic tool reports failure
```

**Expected vs Actual:**
- **Expected**: Diagnostic tool detects actual consensus/network failures
- **Actual**: Diagnostic tool fails due to gas price mismatch while cluster remains healthy, creating a false negative and potentially masking real issues

## Notes

1. **Compile-Time vs Runtime Constants**: The root cause is a fundamental mismatch between compile-time constants (`aptos_global_constants::GAS_UNIT_PRICE`) used by operational tools and runtime on-chain parameters used by validators.

2. **Governance Attack Vector**: While this can occur accidentally, a malicious governance participant could intentionally exploit this to blind the monitoring infrastructure by proposing a gas price update that breaks diagnostics.

3. **Cascading Failures**: If real consensus issues occur while diagnostics are broken, operators will waste time debugging the gas price issue instead of addressing the actual failure, potentially allowing the real problem to worsen.

4. **Similar Tools May Be Affected**: Other operational tools that use `aptos_global_constants::GAS_UNIT_PRICE` may have the same vulnerability and should be audited.

5. **Defense in Depth**: The recommended fix implements defense in depth by having the diagnostic tool query on-chain parameters, ensuring it adapts to governance changes automatically.

### Citations

**File:** crates/transaction-emitter/src/diag.rs (L19-20)
```rust
        TransactionFactory::new(cluster.chain_id)
            .with_gas_unit_price(aptos_global_constants::GAS_UNIT_PRICE),
```

**File:** crates/transaction-emitter/src/diag.rs (L28-36)
```rust
        let deadline = emitter
            .submit_single_transaction(
                &instance.rest_client(),
                &mut coin_source_account,
                &coin_source_account_address,
                10,
            )
            .await
            .map_err(|e| format_err!("Failed to submit txn through {}: {:?}", instance, e))?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L59-65)
```rust
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L174-192)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-247)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
```

**File:** crates/transaction-emitter-lib/src/emitter/mod.rs (L977-988)
```rust
    pub async fn submit_single_transaction(
        &self,
        client: &RestClient,
        sender: &mut LocalAccount,
        receiver: &AccountAddress,
        num_coins: u64,
    ) -> Result<Instant> {
        let txn = gen_transfer_txn_request(sender, receiver, num_coins, &self.txn_factory);
        client.submit(&txn).await?;
        let deadline = Instant::now() + Duration::from_secs(txn.expiration_timestamp_secs() + 30);
        Ok(deadline)
    }
```
