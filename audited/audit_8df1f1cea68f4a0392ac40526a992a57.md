# Audit Report

## Title
Backup Poisoning via Unverified FileHandle Tampering in Epoch Ending Manifests

## Summary
The `EpochEndingChunk` struct stores a `ledger_infos` FileHandle that can be modified after manifest creation to point to malicious data. When restoring backups without trusted waypoints and without a previous epoch ending ledger info, the first LedgerInfo is accepted without cryptographic verification, enabling an attacker with backup storage write access to corrupt validator sets and violate consensus safety.

## Finding Description

The vulnerability exists in the epoch ending backup restoration flow where manifests are stored as unsigned JSON files with mutable FileHandles.

**Architecture Overview:**

The `FileHandle` type is simply a String alias representing a URI to a file in backup storage. [1](#0-0) 

The `EpochEndingChunk` struct contains this FileHandle pointing to ledger info data. [2](#0-1) 

Manifests are serialized as plain JSON without cryptographic signatures or integrity protection. [3](#0-2) 

**Verification Gap:**

During restoration, the manifest is loaded and verified, but the `verify()` method only checks epoch range consistency, NOT FileHandle integrity or authenticity. [4](#0-3) 

The critical vulnerability occurs in the LedgerInfo verification logic. For each LedgerInfo, the system checks waypoints and performs cryptographic verification ONLY if certain conditions are met. [5](#0-4) 

**The Attack Path:**

For the FIRST LedgerInfo in a restoration:
1. `previous_li` is initialized to `None` [6](#0-5) 
2. Waypoints are computed and compared to manifest waypoints (lines 122-128) - but the manifest waypoints are attacker-controlled
3. If no trusted waypoint exists for that version, the first branch (lines 129-135) is skipped
4. If `previous_li` is `None`, the second branch (lines 136-146) is also skipped
5. The LedgerInfo is accepted WITHOUT signature verification at line 148

Subsequent LedgerInfos are verified against this unverified first LedgerInfo, creating a chain of trust based on corrupted data.

**Attack Scenario:**

An attacker with write access to backup storage (e.g., compromised S3 credentials) can:

1. Create malicious `LedgerInfoWithSignatures` with arbitrary validator sets
2. Serialize and store this in a chunk file
3. Modify the manifest JSON to:
   - Change the `ledger_infos` FileHandle to point to the malicious chunk
   - Update `waypoints` array to match the malicious data (computed from fake LedgerInfos)
4. Upload the tampered manifest

When a node performs restoration without trusted waypoints (which is a valid configuration scenario, as seen in production Helm templates where the waypoint list can be empty), [7](#0-6)  and when restoration is called with `None` as the previous epoch parameter (as done in db-tool oneoff restores), [8](#0-7)  the malicious LedgerInfos are accepted without verification.

The storage layer provides no integrity checks when opening files for reading. [9](#0-8) 

## Impact Explanation

This vulnerability achieves **Critical Severity** under the Aptos bug bounty program criteria:

**Consensus/Safety Violations:** The epoch ending LedgerInfos contain the validator set for each epoch. By poisoning this data, an attacker can:
- Install arbitrary validator sets in the restored node
- Cause the restored node to accept blocks signed by non-legitimate validators
- Create consensus splits where the poisoned node diverges from the legitimate chain
- Enable double-spending attacks through chain forks

**Non-recoverable Network Partition:** If multiple nodes restore from poisoned backups, they will form a partitioned network believing in fraudulent validator sets, potentially requiring a hardfork to recover.

**Validator Set Manipulation:** This directly violates the staking security invariant (#6) and consensus safety invariant (#2), as the restored node will have incorrect validator power calculations and accept invalid blocks.

The attack breaks the fundamental assumption that backup restoration produces an authentic copy of the blockchain state.

## Likelihood Explanation

**Attacker Requirements:**
- Write access to backup storage (e.g., compromised AWS/GCS credentials)
- Does NOT require validator node access or validator key compromise
- Does NOT require byzantine validator collusion

**Likelihood: MEDIUM-HIGH**

Backup storage credentials are typically:
- Shared among operations teams for legitimate backup management
- Stored in CI/CD systems for automated backups
- Potentially exposed through configuration files or environment variables
- Subject to cloud provider credential leaks

The attack is straightforward - just JSON manipulation and file replacement. No cryptographic forgery or complex protocol exploitation required.

The vulnerability is triggered in realistic scenarios:
- New node bootstrapping from backups without genesis waypoint configured
- Disaster recovery restores
- Testing/development environments using production backup data
- Oneoff restoration operations using db-tool

## Recommendation

**Immediate Fix: Cryptographically bind FileHandles to manifests**

1. **Add manifest signing:** Sign the entire manifest JSON with a trusted key during backup creation. Store the signature alongside the manifest. Verify the signature during restoration before processing any FileHandles.

2. **Content-addressed FileHandles:** Instead of arbitrary URIs, use cryptographic hashes of file contents as FileHandles (content-addressable storage). Verify the hash matches the file contents when opening.

3. **Enforce trusted waypoints:** Require at least a genesis waypoint for all restoration operations. Modify the verification logic to fail if the first LedgerInfo cannot be cryptographically verified:

```rust
// In restore.rs, after line 128:
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    // existing trusted waypoint check
} else if let Some(pre_li) = previous_li {
    // existing signature verification
} else {
    // NEW: Fail instead of accepting unverified LedgerInfo
    return Err(anyhow!(
        "Cannot verify first LedgerInfo at epoch {} without trusted waypoint. \
         Please provide --trust-waypoint for version {}",
        li.ledger_info().epoch(),
        li.ledger_info().version()
    ));
}
```

4. **Add file integrity checks:** Store checksums/hashes in manifests for each FileHandle. Verify checksums when opening files for reading.

**Long-term Fix:**
Implement a comprehensive backup authenticity system with:
- Manifest signatures by trusted operators
- Merkle tree of all backup files
- Content-addressed storage throughout
- Mandatory trusted waypoint configuration for genesis

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability by showing how to create
// a poisoned backup manifest that will be accepted during restore

use aptos_backup_cli::backup_types::epoch_ending::manifest::{EpochEndingBackup, EpochEndingChunk};
use aptos_types::{ledger_info::LedgerInfo, waypoint::Waypoint};
use std::fs;

fn create_poisoned_backup() -> Result<(), anyhow::Error> {
    // Step 1: Create a malicious LedgerInfo with arbitrary state
    let malicious_li = create_fake_ledger_info_with_signatures(
        0, // epoch
        100, // version  
        // Arbitrary state root hash (won't be verified!)
        HashValue::random(),
    );
    
    // Step 2: Serialize to chunk file
    let chunk_bytes = bcs::to_bytes(&malicious_li)?;
    fs::write("malicious_chunk.bin", &chunk_bytes)?;
    
    // Step 3: Compute waypoint from malicious LedgerInfo
    // This will pass the waypoint check since we control both!
    let malicious_waypoint = Waypoint::new_epoch_boundary(
        malicious_li.ledger_info()
    )?;
    
    // Step 4: Create manifest pointing to malicious chunk
    let manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![malicious_waypoint],
        chunks: vec![EpochEndingChunk {
            first_epoch: 0,
            last_epoch: 0,
            ledger_infos: "malicious_chunk.bin".to_string(), // Tampered FileHandle!
        }],
    };
    
    // Step 5: Write manifest as JSON
    fs::write(
        "epoch_ending.manifest",
        serde_json::to_vec(&manifest)?
    )?;
    
    // When restored with:
    // - No --trust-waypoint flags
    // - No previous_epoch_ending_ledger_info
    // This malicious backup will be ACCEPTED without verification!
    
    println!("Poisoned backup created successfully!");
    println!("The first LedgerInfo will bypass signature verification");
    println!("because neither trusted_waypoints nor previous_li exists.");
    
    Ok(())
}

// To test:
// 1. Create poisoned backup using above
// 2. Run: aptos-debugger aptos-db restore oneoff epoch-ending \
//         --epoch-ending-manifest epoch_ending.manifest \
//         --target-db-dir ./test_restore \
//         --local-fs-dir .
// 3. Observe that malicious data is accepted without verification
```

## Notes

This vulnerability specifically affects scenarios where restoration occurs without the full chain of trust anchored in a genesis waypoint. While production deployments may configure trusted waypoints, the system should enforce this as a mandatory security control rather than an optional configuration. The current implementation allows silent acceptance of unverified data, which violates the principle of secure defaults.

The attack requires backup storage compromise, not validator compromise, making it a different threat model from traditional Byzantine attacks. This highlights the importance of securing backup infrastructure with the same rigor as validator infrastructure.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L11-16)
```rust
#[derive(Deserialize, Serialize)]
pub struct EpochEndingChunk {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub ledger_infos: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L28-68)
```rust
impl EpochEndingBackup {
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch + 1;
        }

        // check last epoch in chunk matches manifest
        ensure!(
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
            "Last epoch in chunks: {}, in manifest: {}",
            next_epoch - 1,
            self.last_epoch,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L186-193)
```rust
        let (manifest_handle, mut manifest_file) = self
            .storage
            .create_for_write(backup_handle, Self::manifest_name())
            .await?;
        manifest_file
            .write_all(&serde_json::to_vec(&manifest)?)
            .await?;
        manifest_file.shutdown().await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L119-147)
```rust
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** terraform/helm/fullnode/templates/fullnode.yaml (L57-57)
```yaml
            {{ range .config.trusted_waypoints }} --trust-waypoint {{ . }}{{ end }} \
```

**File:** storage/db-tool/src/restore.rs (L80-80)
```rust
                        .run(None)
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```
