# Audit Report

## Title
Byzantine Validators Can Cause JWK Consensus Liveness Failure Through Undetected Equivocation

## Summary
The JWK consensus network interface lacks any mechanism to detect when Byzantine validators send conflicting signed observations to different peers. This enables Byzantine validators to strategically equivocate and prevent the network from reaching quorum on JWK updates, causing a liveness failure for JWK consensus that can freeze keyless account functionality.

## Finding Description

The JWK consensus protocol uses a pull-based reliable broadcast mechanism where each validator independently requests JWK observations from peer validators. The observation aggregation logic only validates signatures and checks for duplicate votes from the same validator on a single node, but provides no cross-validator mechanism to detect if a Byzantine validator sends different signed observations to different peers. [1](#0-0) 

This check prevents double-counting the same validator's vote on one node, but cannot detect when a Byzantine validator responds with observation A to validator V1 and observation B to validator V2.

In contrast, the main AptosBFT consensus protocol explicitly detects equivocation: [2](#0-1) 

The AptosBFT consensus maintains an `author_to_vote` map and logs a `SecurityEvent::ConsensusEquivocatingVote` when a validator votes for different proposals in the same round.

**Attack Path:**

1. An OIDC provider equivocates, showing JWK set X to f+1 honest validators and JWK set Y to f honest validators (where f is the maximum number of Byzantine validators tolerated)

2. f Byzantine validators strategically equivocate by signing both observations:
   - When Group A (f+1 honest validators observing X) requests observations, f/2 Byzantine validators respond with signed observation X
   - When Group B (f honest validators observing Y) requests observations, f/2 Byzantine validators respond with signed observation Y

3. Quorum calculation with 3f+1 total validators requiring 2f+1 votes:
   - Group A accumulates: (f+1) honest + (f/2) Byzantine = f + 1 + f/2 = 3f/2 + 1 votes for X
   - Group B accumulates: f honest + (f/2) Byzantine = f + f/2 = 3f/2 votes for Y
   - Neither group reaches the 2f+1 quorum threshold (since 3f/2 + 1 < 2f+1 for f â‰¥ 2)

4. No JWK update can be certified, causing permanent liveness failure for this issuer

5. The network interface provides no detection mechanism: [3](#0-2) 

The `send_rpc` method simply sends point-to-point messages with no gossip, echo, or cross-validator verification that all peers received identical observations from each validator.

## Impact Explanation

This qualifies as **Critical Severity** under the Aptos bug bounty program because it enables "Total loss of liveness/network availability" for the JWK consensus subsystem.

JWK updates are critical for maintaining the security of keyless accounts, which rely on up-to-date JSON Web Keys for authentication. The inability to update JWKs when providers rotate keys would:

- Freeze keyless account functionality (users cannot authenticate with new keys)
- Create a permanent security vulnerability (old keys remain trusted even if compromised)
- Require manual intervention or hard fork to recover

The attack requires f Byzantine validators but no coordination with external parties. With the standard BFT assumption of up to f Byzantine validators in a 3f+1 validator set, this attack is within the threat model and should be prevented by the protocol design.

The on-chain version check prevents safety violations (multiple conflicting updates cannot be committed), but provides no protection against this liveness attack: [4](#0-3) 

## Likelihood Explanation

**Likelihood: High** under adversarial conditions

Requirements for exploitation:
- f Byzantine validators (already assumed in BFT threat model)
- Provider equivocation or natural observation divergence (common during key rotations)
- Basic RPC manipulation (respond differently to different requesters)

The attack is:
- Undetectable (no logging or slashing mechanism)
- Repeatable (can be used for every JWK update)
- Risk-free for attackers (no accountability)
- Strategically valuable (blocking security updates)

The network interface's pull-based design makes equivocation trivial: [5](#0-4) 

Each validator independently requests observations, so Byzantine validators can easily provide different responses to different requesters without detection.

## Recommendation

Implement equivocation detection in the JWK consensus protocol similar to the main consensus:

1. **Add equivocation tracking**: Extend `ObservationAggregationState` to maintain a global record of what each validator has signed, shared via gossip among honest validators

2. **Implement echo/gossip phase**: Add a second round where validators share what observations they received from others, enabling cross-validator verification

3. **Log security events**: When equivocation is detected, log `SecurityEvent::ConsensusEquivocatingVote` similar to main consensus

4. **Add slashing mechanism**: Integrate with the staking system to penalize equivocating validators

Example conceptual fix:

```rust
// In ObservationAggregationState::add()
// After signature verification, add:

// Check if we've seen this author sign a different observation
if let Some(previous_observation) = self.get_previous_observation(&sender) {
    if previous_observation != peer_view {
        error!(
            SecurityEvent::JWKConsensusEquivocatingVote,
            remote_peer = sender,
            current_observation = peer_view,
            previous_observation = previous_observation
        );
        return Err(anyhow!("Equivocation detected"));
    }
}

// Store this observation for future equivocation checks
self.record_observation(sender, peer_view.clone());
```

Alternatively, adopt a push-based broadcast model like the main consensus, where all validators broadcast their observations to all peers, enabling direct equivocation detection.

## Proof of Concept

The existing test infrastructure demonstrates provider equivocation but not validator equivocation: [6](#0-5) 

To demonstrate validator equivocation, modify the test framework:

```rust
// Simulated Byzantine validator that equivocates
struct EquivocatingValidator {
    observation_a: ObservedUpdate,
    observation_b: ObservedUpdate,
    threshold: usize,
    requesters_seen: Mutex<HashSet<AccountAddress>>,
}

impl EquivocatingValidator {
    fn handle_rpc(&self, requester: AccountAddress) -> ObservedUpdateResponse {
        let mut seen = self.requesters_seen.lock();
        if seen.len() < self.threshold {
            seen.insert(requester);
            ObservedUpdateResponse {
                epoch: self.observation_a.epoch,
                update: self.observation_a.clone(),
            }
        } else {
            ObservedUpdateResponse {
                epoch: self.observation_b.epoch,
                update: self.observation_b.clone(),
            }
        }
    }
}

// Test case:
// 1. Setup 7 validators (f=2)
// 2. Provider equivocates, showing different JWKs to different validators
// 3. 2 Byzantine validators equivocate (1 supports each group)
// 4. Observe that neither group reaches quorum (need 5, each gets 4)
// 5. JWK update fails to certify - liveness failure
```

The vulnerability is confirmed by the fact that the observation aggregation only checks for local duplicates, not cross-validator equivocation: [7](#0-6) 

This test shows duplicate observations from the same author are ignored, but it doesn't test for or detect equivocation (different observations from the same author to different validators).

### Citations

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L77-79)
```rust
        if partial_sigs.contains_voter(&sender) {
            return Ok(None);
        }
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** crates/aptos-jwk-consensus/src/network_interface.rs (L40-50)
```rust
    pub async fn send_rpc(
        &self,
        peer: PeerId,
        message: JWKConsensusMsg,
        rpc_timeout: Duration,
    ) -> Result<JWKConsensusMsg, Error> {
        let peer_network_id = self.get_peer_network_id_for_peer(peer);
        self.network_client
            .send_to_peer_rpc(message, rpc_timeout, peer_network_id)
            .await
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L73-98)
```rust
    async fn send_rb_rpc(
        &self,
        receiver: AccountAddress,
        message: JWKConsensusMsg,
        timeout: Duration,
    ) -> anyhow::Result<JWKConsensusMsg> {
        if receiver == self.author {
            let (tx, rx) = oneshot::channel();
            let protocol = RPC[0];
            let self_msg = Event::RpcRequest(self.author, message, protocol, tx);
            self.self_sender.clone().send(self_msg).await?;
            if let Ok(Ok(Ok(bytes))) = tokio::time::timeout(timeout, rx).await {
                let response_msg =
                    tokio::task::spawn_blocking(move || protocol.from_bytes(&bytes)).await??;
                Ok(response_msg)
            } else {
                bail!("self rpc failed");
            }
        } else {
            let result = self
                .jwk_network_client
                .send_rpc(receiver, message, timeout)
                .await?;
            Ok(result)
        }
    }
```

**File:** testsuite/smoke-test/src/jwks/dummy_provider/request_handler.rs (L45-78)
```rust
/// The first `k` requesters will get content A forever, the rest will get content B forever.
pub struct EquivocatingServer {
    content_a: Vec<u8>,
    content_b: Vec<u8>,
    k: usize,
    requesters_observed: Mutex<HashSet<AccountAddress>>,
}

impl EquivocatingServer {
    pub fn new(content_a: Vec<u8>, content_b: Vec<u8>, k: usize) -> Self {
        Self {
            content_a,
            content_b,
            k,
            requesters_observed: Mutex::new(HashSet::new()),
        }
    }
}

impl RequestHandler for EquivocatingServer {
    fn handle(&self, request: Request<Body>) -> Vec<u8> {
        let mut requesters_observed = self.requesters_observed.lock();
        let origin = origin_from_cookie(&request);
        if requesters_observed.len() < self.k {
            requesters_observed.insert(origin);
        }

        if requesters_observed.contains(&origin) {
            self.content_a.clone()
        } else {
            self.content_b.clone()
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/tests.rs (L105-114)
```rust
    // `ObservedUpdate` from contributed author should be ignored.
    let result = ob_agg_state.add(addrs[3], ObservedUpdateResponse {
        epoch: 999,
        update: ObservedUpdate {
            author: addrs[3],
            observed: view_0.clone(),
            signature: private_keys[3].sign(&view_0).unwrap(),
        },
    });
    assert!(matches!(result, Ok(None)));
```
