# Audit Report

## Title
Bytecode Complexity Metering Bypass via Unmetered Simple Instructions Enables Validator DoS

## Summary
The `meter_code()` function in the Move binary complexity checker fails to charge any cost for simple bytecode instructions (Add, Sub, Mul, Div, bitwise operations, comparisons, casts, branches, etc.). This allows attackers to publish modules containing millions of these instructions that pass complexity checks but require extensive CPU time during bytecode verification, causing validator node slowdowns.

## Finding Description

The complexity checking system is designed to prevent publication of overly complex modules that would be expensive to verify. However, the implementation has a critical gap. [1](#0-0) 

The `meter_code()` function iterates through all bytecode instructions but only charges costs for generic instantiations and certain complex operations. For the vast majority of instructions—including all arithmetic operations (Add, Sub, Mul, Div, Mod, Negate), bitwise operations (BitOr, BitAnd, Xor, Shl, Shr), logical operations (Or, And, Not), comparison operations (Eq, Neq, Lt, Gt, Le, Ge), type casts (CastU8-CastU256, CastI8-I256), branches, constant loads, and many others—the function does nothing (lines 300-380). [2](#0-1) 

Each simple instruction is encoded as a single byte in the serialized format. The complexity budget formula is `2048 + blob.code().len() * 20`, where `blob.code().len()` is the byte size of the code section. [3](#0-2) 

**Attack Scenario:**

1. Attacker creates a Move module with a function containing 1 million Add instructions:
   - Each Add instruction = 1 byte in bytecode (opcode 0x16)
   - Total code size ≈ 1 million bytes
   - Complexity budget = 2048 + 1,000,000 × 20 = 20,002,048
   - Cost charged by `meter_code()` = ~0 (only locals signature is metered)
   - **Module passes complexity check**

2. During module publishing, the bytecode verifier must process all instructions: [4](#0-3) 

The verifier runs multiple passes (BoundsChecker, InstructionConsistency, CodeUnitVerifier with type checking, stack verification, control flow analysis), each iterating over all bytecode instructions. With 1 million instructions, this causes significant CPU load.

3. The gas charges for module publishing are based on byte size, not verification workload, meaning the attacker pays minimal gas while validators incur disproportionate CPU costs.

This breaks the invariant that **all operations must respect computational limits** and that gas/complexity charges should be proportional to actual resource consumption.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty program, specifically meeting the criterion of "Validator node slowdowns."

**Quantified Impact:**
- A single module with 1 million simple instructions could take seconds to verify
- Attacker can submit multiple such transactions in rapid succession  
- 100 malicious modules could tie up validator CPU for extended periods
- Network throughput degrades as validators spend time verifying malicious modules instead of processing legitimate transactions
- Transaction latency increases network-wide
- Consensus may slow down as validators struggle to keep up with block execution

The attack is **economically asymmetric**: the attacker pays gas proportional to module byte size (~1 MB), but validators pay CPU time proportional to instruction count × verification passes (millions of operations).

## Likelihood Explanation

**Likelihood: HIGH**

- **No privileged access required**: Any user can publish modules
- **Attack is trivial to execute**: Creating a module with repeated simple instructions requires minimal sophistication
- **Economically viable**: Gas costs are proportional to byte size, not verification cost
- **Difficult to detect**: Malicious modules appear legitimate and pass all checks
- **No rate limiting**: Attacker can submit multiple transactions with different modules

The only barrier is the gas cost for publishing large modules, but this is far cheaper than the CPU resources consumed by validators.

## Recommendation

Add per-instruction metering in the `meter_code()` function. Modify the code to charge a cost for ALL bytecode instructions, not just generic instantiations:

```rust
fn meter_code(&self, code: &CodeUnit) -> PartialVMResult<()> {
    use Bytecode::*;

    self.meter_signature(code.locals)?;

    // Charge cost per instruction
    const COST_PER_INSTRUCTION: u64 = 1;
    self.charge(code.code.len() as u64 * COST_PER_INSTRUCTION)?;

    for instr in &code.code {
        match instr {
            // ... existing generic instantiation metering ...
            CallGeneric(idx) | PackClosureGeneric(idx, ..) => {
                self.meter_function_instantiation(*idx)?;
            },
            // ... rest of metering logic ...
            _ => {
                // Simple instructions are already counted in the batch charge above
            }
        }
    }
    Ok(())
}
```

This ensures that functions with millions of simple instructions will exceed the complexity budget, preventing the DoS attack while maintaining backward compatibility for legitimate modules.

## Proof of Concept

**Move Module PoC:**

```move
module attacker::dos_module {
    public fun expensive_verification(x: u64): u64 {
        let result = x;
        // Repeat this pattern 1,000,000 times
        result = result + 0;
        result = result + 0;
        result = result + 0;
        // ... (generate programmatically)
        result
    }
}
```

**Attack Reproduction Steps:**

1. Generate a Move module with a function containing 1 million `Add` instructions (use a code generator to create the `.move` file)
2. Compile the module using the Move compiler
3. Verify the compiled module bytecode size is approximately 1 MB
4. Submit a transaction to publish this module on-chain
5. Observe that:
   - The complexity check passes (budget sufficient for ~1 MB code)
   - The module publishing transaction succeeds
   - Validator nodes experience CPU spikes during verification
   - If multiple such modules are published rapidly, network performance degrades

**Verification Command:**
```bash
# Check complexity budget calculation
aptos move compile --save-metadata
# Observe that module with 1M instructions passes complexity check despite high verification cost
```

The vulnerability is confirmed by the fact that the `meter_code()` function explicitly does not charge for simple instructions, while the bytecode verifier must process every single instruction through multiple verification passes.

### Citations

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L259-384)
```rust
    fn meter_code(&self, code: &CodeUnit) -> PartialVMResult<()> {
        use Bytecode::*;

        self.meter_signature(code.locals)?;

        for instr in &code.code {
            match instr {
                CallGeneric(idx) | PackClosureGeneric(idx, ..) => {
                    self.meter_function_instantiation(*idx)?;
                },
                PackGeneric(idx) | UnpackGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
                CallClosure(idx)
                | VecPack(idx, _)
                | VecLen(idx)
                | VecImmBorrow(idx)
                | VecMutBorrow(idx)
                | VecPushBack(idx)
                | VecPopBack(idx)
                | VecUnpack(idx, _)
                | VecSwap(idx) => {
                    self.meter_signature(*idx)?;
                },

                // List out the other options explicitly so there's a compile error if a new
                // bytecode gets added.
                Pop
                | Ret
                | Branch(_)
                | BrTrue(_)
                | BrFalse(_)
                | LdU8(_)
                | LdU16(_)
                | LdU32(_)
                | LdU64(_)
                | LdU128(_)
                | LdU256(_)
                | LdI8(_)
                | LdI16(_)
                | LdI32(_)
                | LdI64(_)
                | LdI128(_)
                | LdI256(_)
                | LdConst(_)
                | CastU8
                | CastU16
                | CastU32
                | CastU64
                | CastU128
                | CastU256
                | CastI8
                | CastI16
                | CastI32
                | CastI64
                | CastI128
                | CastI256
                | LdTrue
                | LdFalse
                | Call(_)
                | Pack(_)
                | Unpack(_)
                | PackVariant(_)
                | UnpackVariant(_)
                | TestVariant(_)
                | PackClosure(..)
                | ReadRef
                | WriteRef
                | FreezeRef
                | Add
                | Sub
                | Mul
                | Mod
                | Div
                | Negate
                | BitOr
                | BitAnd
                | Xor
                | Shl
                | Shr
                | Or
                | And
                | Not
                | Eq
                | Neq
                | Lt
                | Gt
                | Le
                | Ge
                | CopyLoc(_)
                | MoveLoc(_)
                | StLoc(_)
                | MutBorrowLoc(_)
                | ImmBorrowLoc(_)
                | MutBorrowField(_)
                | ImmBorrowField(_)
                | MutBorrowVariantField(_)
                | ImmBorrowVariantField(_)
                | MutBorrowGlobal(_)
                | ImmBorrowGlobal(_)
                | Exists(_)
                | MoveTo(_)
                | MoveFrom(_)
                | Abort
                | AbortMsg
                | Nop => (),
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L254-259)
```rust
    ADD                         = 0x16,
    SUB                         = 0x17,
    MUL                         = 0x18,
    MOD                         = 0x19,
    DIV                         = 0x1A,
    BIT_OR                      = 0x1B,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```
