# Audit Report

## Title
Lack of Graceful Degradation in StateStorageUsage Update During Epoch Transitions Leading to Blockchain Halt or Permanent Gas Pricing Errors

## Summary
The native function `native_get_usage()` calls `resolver.get_usage()` to update state storage metrics during epoch transitions. If this call fails repeatedly (e.g., due to storage layer errors), the system lacks any graceful degradation mechanism, causing either blockchain halt or permanently stale `StateStorageUsage` data that breaks storage gas price adjustments.

## Finding Description

During every block prologue execution, `state_storage::on_new_block()` is called to track storage usage metrics. When an epoch transition occurs, this function attempts to update the cached `StateStorageUsage` by calling the native function `get_state_storage_usage_only_at_epoch_beginning()`. [1](#0-0) 

The native implementation calls `resolver.get_usage()` which queries the underlying storage layer: [2](#0-1) 

**The Critical Flaw:** If `resolver.get_usage()` fails, it returns a `PartialVMError` with `VM_EXTENSION_ERROR`, causing the entire block prologue transaction to abort. This triggers a cascade of failures:

1. The block prologue abort is converted to `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`: [3](#0-2) 

2. Block metadata transactions return `ExecutionStatus::Abort`: [4](#0-3) 

3. This becomes `BlockExecutionError::FatalVMError`: [5](#0-4) 

4. With the default configuration (`discard_failed_blocks: false`): [6](#0-5) 

The error propagates up, halting block execution.

**If `discard_failed_blocks: true`**, blocks are discarded but `StateStorageUsage` remains stale: [7](#0-6) 

**Why StateStorageUsage Becomes Permanently Stale:**

Since `on_new_block()` is called in every block prologue, and it checks if the epoch has changed: [8](#0-7) 

If the initial epoch transition update fails:
- `StateStorageUsage.epoch` remains at the old value (transaction rolled back)
- Every subsequent block sees `current_epoch != StateStorageUsage.epoch`
- Every block attempts the update again
- If the storage failure is persistent, the cycle repeats indefinitely

**Impact on Gas Pricing:**

The stale `StateStorageUsage` breaks storage gas price calculations, as `storage_gas::on_reconfig()` relies on current usage data: [9](#0-8) 

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program: "State inconsistencies requiring intervention."

**Concrete impacts:**

1. **Blockchain Halt** (Default Configuration): With `discard_failed_blocks: false`, repeated `resolver.get_usage()` failures cause the blockchain to halt completely, requiring manual intervention or hardfork.

2. **Incorrect Gas Pricing** (If Blocks Discarded): With `discard_failed_blocks: true`, `StateStorageUsage` becomes permanently stale, causing:
   - Under-pricing of storage operations (if actual usage increased)
   - Over-pricing of storage operations (if actual usage decreased)
   - Economic model breakdown for storage gas pricing
   - Potential for storage spam attacks due to incorrect pricing

3. **State Inconsistency**: Different validators may have different `StateStorageUsage` values if failures occur non-deterministically, though this is less likely.

## Likelihood Explanation

**Likelihood: Low to Medium**

While this requires storage layer failures rather than direct attacker action, it is realistic because:

1. **Storage Layer Can Fail**: The database implementation shows failure paths:
   - Ledger pruned errors
   - Missing version data when `skip_usage: false` [10](#0-9) 

2. **Production Conditions**: Storage corruption, hardware failures, race conditions, or software bugs can trigger these failures during critical epoch transitions.

3. **No Retry Mechanism**: The system has zero resilience - a single persistent failure during epoch start creates a permanent problem.

4. **Increasing Probability Over Time**: As the blockchain grows and more pruning/archival operations occur, storage layer errors become more likely.

## Recommendation

Implement graceful degradation with multiple fallback strategies:

```move
public(friend) fun on_new_block(epoch: u64) acquires StateStorageUsage {
    assert!(
        exists<StateStorageUsage>(@aptos_framework),
        error::not_found(ESTATE_STORAGE_USAGE)
    );
    let usage = borrow_global_mut<StateStorageUsage>(@aptos_framework);
    if (epoch != usage.epoch) {
        usage.epoch = epoch;
        
        // Add try-catch equivalent behavior
        let new_usage = try_get_state_storage_usage_with_fallback();
        
        // Only update if retrieval succeeded, otherwise keep stale data
        // and log warning for monitoring
        if (option::is_some(&new_usage)) {
            usage.usage = option::extract(&mut new_usage);
        }
        // If retrieval failed, StateStorageUsage keeps previous epoch's data
        // Gas pricing continues with slightly stale data rather than halting
    }
}

// Native function that returns Option<Usage> instead of aborting
native fun try_get_state_storage_usage_with_fallback(): Option<Usage>;
```

In the native implementation:

```rust
fn native_get_usage_with_fallback(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(STATE_STORAGE_GET_USAGE_BASE_COST)?;
    
    let ctx = context.extensions().get::<NativeStateStorageContext>();
    
    // Try to get usage, but return None instead of aborting on error
    match ctx.resolver.get_usage() {
        Ok(usage) => {
            Ok(smallvec![Value::struct_(Struct::pack(vec![
                Value::bool(true),  // Some
                Value::u64(usage.items() as u64),
                Value::u64(usage.bytes() as u64),
            ]))])
        },
        Err(err) => {
            // Log the error for monitoring but don't abort
            eprintln!("Warning: Failed to get state storage usage: {}", err);
            
            // Return None - keep using stale data
            Ok(smallvec![Value::struct_(Struct::pack(vec![
                Value::bool(false),  // None
                Value::u64(0),
                Value::u64(0),
            ]))])
        }
    }
}
```

## Proof of Concept

```rust
// Simulation of storage failure during epoch transition
#[test]
fn test_persistent_storage_failure_at_epoch_start() {
    // Setup: Initialize blockchain at epoch 0
    let mut executor = TestExecutor::new();
    
    // Inject storage failure for get_usage() calls
    fail_point::set("storage::get_usage", "return(error)");
    
    // Attempt epoch transition from epoch 0 to epoch 1
    let block_metadata = BlockMetadata::new(
        HashValue::random(),
        1,  // epoch 1
        0,
        AccountAddress::random(),
        vec![],
        vec![],
        1000,
    );
    
    let result = executor.execute_block(vec![
        Transaction::BlockMetadata(block_metadata)
    ]);
    
    // With default config, this returns FatalVMError
    assert!(matches!(result, Err(BlockExecutionError::FatalVMError(_))));
    
    // StateStorageUsage still shows epoch 0
    let state_storage_usage = executor.read_state_storage_usage();
    assert_eq!(state_storage_usage.epoch, 0);
    
    // Subsequent blocks also fail
    for i in 1..10 {
        let result = executor.execute_block(vec![
            Transaction::BlockMetadata(BlockMetadata::new(
                HashValue::random(),
                1,  // still epoch 1
                i,
                AccountAddress::random(),
                vec![],
                vec![],
                1000 + i * 1000,
            ))
        ]);
        assert!(result.is_err());
    }
    
    // Blockchain is halted - no blocks can be processed
    // StateStorageUsage remains permanently stale at epoch 0
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/state_storage.move (L44-48)
```text
        let usage = borrow_global_mut<StateStorageUsage>(@aptos_framework);
        if (epoch != usage.epoch) {
            usage.epoch = epoch;
            usage.usage = get_state_storage_usage_only_at_epoch_beginning();
        }
```

**File:** aptos-move/framework/src/natives/state_storage.rs (L70-73)
```rust
    let usage = ctx.resolver.get_usage().map_err(|err| {
        PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
            .with_message(format!("Failed to get state storage usage: {}", err))
    })?;
```

**File:** aptos-move/aptos-vm/src/errors.rs (L290-303)
```rust
        status => {
            // Only trigger a warning here as some errors could be a result of the speculative parallel execution.
            // We will report the errors after we obtained the final transaction output in update_counters_for_processed_chunk
            let err_msg = format!(
                "[aptos_vm] Unexpected error from known Move function, '{}'. Error: {:?}",
                function_name, status
            );
            speculative_warn!(log_context, err_msg.clone());
            VMStatus::Error {
                status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                sub_status: status.sub_status(),
                message: Some(err_msg),
            }
        },
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L99-114)
```rust
            // execute_single_transaction only returns an error when transactions that should never fail
            // (BlockMetadataTransaction and GenesisTransaction) return an error themselves.
            Err(err) => {
                if err.status_code() == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                    ExecutionStatus::SpeculativeExecutionAbortError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else if err.status_code()
                    == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                {
                    ExecutionStatus::DelayedFieldsCodeInvariantError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else {
                    ExecutionStatus::Abort(err)
                }
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```

**File:** aptos-move/block-executor/src/executor.rs (L2648-2663)
```rust
        if self.config.local.discard_failed_blocks {
            // We cannot execute block, discard everything (including block metadata and validator transactions)
            // (TODO: maybe we should add fallback here to first try BlockMetadataTransaction alone)
            let error_code = match sequential_error {
                BlockExecutionError::FatalBlockExecutorError(_) => {
                    StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                },
                BlockExecutionError::FatalVMError(_) => {
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                },
            };
            let ret = (0..signature_verified_block.num_txns())
                .map(|_| E::Output::discard_output(error_code))
                .collect();
            return Ok(BlockOutput::new(ret, None));
        }
```

**File:** config/src/config/execution_config.rs (L88-88)
```rust
            discard_failed_blocks: false,
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L196-196)
```text
        state_storage::on_new_block(reconfiguration::current_epoch());
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L524-532)
```text
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
```

**File:** aptos-move/aptosdb/src/state_store/mod.rs (L238-247)
```rust

```
