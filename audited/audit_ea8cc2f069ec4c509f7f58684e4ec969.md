# Audit Report

## Title
`include_events` Flag Ignored When Transaction Outputs Are Returned in State Sync Protocol

## Summary
The `include_events` flag in `TransactionOrOutputData` requests is completely ignored when transaction outputs are returned instead of transactions. Events are always fetched from storage and included in output responses, violating the API contract and potentially causing resource exhaustion attacks.

## Finding Description

The `get_transaction_or_output_data_with_proof()` function properly creates a request with the `include_events` flag embedded in the `TransactionOrOutputData` struct: [1](#0-0) 

However, when this request is processed by the storage server, the flag is ignored for transaction outputs. The handler correctly passes the flag to the internal processing function: [2](#0-1) 

The `get_transactions_or_outputs_with_proof_by_size` function attempts to return outputs first, but when calling `get_transaction_outputs_with_proof_by_size`, it does NOT pass the `include_events` parameter: [3](#0-2) 

Inside `get_transaction_outputs_with_proof_by_size`, events are ALWAYS fetched from storage regardless of any flag: [4](#0-3) 

And these events are always included in the TransactionOutput: [5](#0-4) 

In contrast, when transactions are returned (the fallback path), the `include_events` flag IS properly respected: [6](#0-5) 

And events are conditionally included based on the flag: [7](#0-6) 

This creates a critical inconsistency: the same API request with `include_events=false` will sometimes exclude events (when transactions are returned) and sometimes include them (when outputs are returned).

**Attack Vector:**
1. Attacker makes `TransactionOrOutputData` requests with `include_events=false`
2. They craft requests where they know outputs will be returned (e.g., by controlling response size constraints)
3. Server always includes events in outputs despite the flag being false
4. Events can be very large (each transaction can have multiple events with arbitrary data)
5. This forces the server to read, serialize, and transmit unnecessary event data
6. Client receives much larger responses than expected, potentially causing memory exhaustion
7. Bandwidth and storage I/O resources are wasted on both sides

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria because it causes:

1. **State Inconsistencies Requiring Intervention**: Clients implementing logic based on the documented API behavior will receive inconsistent data sizes, potentially causing state sync failures or requiring manual intervention.

2. **Resource Exhaustion**: The issue enables a resource exhaustion attack where:
   - Unnecessary storage reads occur (fetching events that won't be used)
   - Network bandwidth is wasted transmitting unwanted events
   - Client memory usage increases unexpectedly
   - Multiple concurrent requests amplify the impact

3. **API Contract Violation**: This breaks the **Resource Limits** invariant - clients cannot reliably control response sizes through the documented `include_events` parameter.

While this doesn't directly compromise consensus or cause loss of funds, it affects the **State Consistency** invariant by causing unexpected resource consumption patterns in the state sync protocol, which is critical for node synchronization.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is triggered in normal operation:
- Any client using the v2 transaction data API with `include_events=false` will encounter this bug
- The output path is the default/preferred path (outputs are tried first)
- No special privileges or malicious validator access required
- Easy to trigger repeatedly for DoS amplification
- Affects all nodes running the state sync storage service

The bug occurs automatically when outputs are returned, which happens frequently in production as the system prefers outputs over transactions for bandwidth efficiency.

## Recommendation

Modify `get_transaction_outputs_with_proof_by_size` to accept an `include_events` parameter and conditionally fetch events only when needed: [8](#0-7) 

The function should:
1. Add `include_events: bool` parameter
2. Conditionally create the events iterator based on the flag (similar to the transaction path)
3. When `include_events=false`, create empty event vectors to avoid storage reads
4. Pass the flag through all call sites

Update the call site to pass the flag: [3](#0-2) 

## Proof of Concept

```rust
// Test demonstrating the bug
#[tokio::test]
async fn test_include_events_ignored_for_outputs() {
    // Create a storage service
    let (mut mock_client, mut service, _, _, _) = MockClient::new(None, None);
    tokio::spawn(service.start());
    
    // Request with include_events=false
    let request = DataRequest::get_transaction_or_output_data_with_proof(
        100,  // proof_version
        0,    // start_version
        10,   // end_version
        false, // include_events = FALSE
        1024 * 1024, // max_response_bytes
    );
    
    let response = send_storage_request(&mut mock_client, false, request)
        .await
        .unwrap();
    
    // If outputs are returned, verify events are present despite include_events=false
    if let DataResponse::TransactionDataWithProof(data) = response.get_data_response().unwrap() {
        if let Some(outputs) = data.transaction_output_list_with_proof {
            for (_, output) in outputs.get_output_list_with_proof().transactions_and_outputs {
                // BUG: Events are present even though include_events was false
                assert!(!output.events().is_empty(), "Events should be empty when include_events=false");
            }
        }
    }
}
```

This PoC demonstrates that when outputs are returned, events are always included regardless of the `include_events` flag setting, violating the API contract and enabling resource exhaustion attacks.

## Notes

This vulnerability represents a serious API inconsistency in the state sync protocol. The behavior diverges between two code paths that should be functionally equivalent from the client's perspective. The issue is compounded by the fact that events can be arbitrarily large, making this an effective vector for resource exhaustion attacks against state sync nodes.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L194-212)
```rust
    pub fn get_transaction_or_output_data_with_proof(
        proof_version: u64,
        start_version: u64,
        end_version: u64,
        include_events: bool,
        max_response_bytes: u64,
    ) -> Self {
        let transaction_data_request_type =
            TransactionDataRequestType::TransactionOrOutputData(TransactionOrOutputData {
                include_events,
            });
        Self::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
            transaction_data_request_type,
            proof_version,
            start_version,
            end_version,
            max_response_bytes,
        })
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L380-389)
```rust
        let transaction_events_iterator = if include_events {
            self.storage
                .get_events_iterator(start_version, num_transactions_to_fetch)?
        } else {
            // If events are not included, create a fake iterator (they will be dropped anyway)
            Box::new(std::iter::repeat_n(
                Ok(vec![]),
                num_transactions_to_fetch as usize,
            ))
        };
```

**File:** state-sync/storage-service/server/src/storage.rs (L483-487)
```rust
        let transaction_events = if include_events {
            Some(transaction_events)
        } else {
            None
        };
```

**File:** state-sync/storage-service/server/src/storage.rs (L565-574)
```rust
    /// Returns a transaction output with proof response (bound by the max response size in bytes)
    fn get_transaction_outputs_with_proof_by_size(
        &self,
        proof_version: u64,
        start_version: u64,
        end_version: u64,
        max_response_size: u64,
        is_transaction_or_output_request: bool,
        use_size_and_time_aware_chunking: bool,
    ) -> Result<TransactionDataWithProofResponse, Error> {
```

**File:** state-sync/storage-service/server/src/storage.rs (L602-604)
```rust
        let transaction_events_iterator = self
            .storage
            .get_events_iterator(start_version, num_outputs_to_fetch)?;
```

**File:** state-sync/storage-service/server/src/storage.rs (L639-646)
```rust
                    // Create the transaction output
                    let output = TransactionOutput::new(
                        write_set,
                        events,
                        info.gas_used(),
                        info.status().clone().into(),
                        TransactionAuxiliaryData::None, // Auxiliary data is no longer supported
                    );
```

**File:** state-sync/storage-service/server/src/storage.rs (L815-823)
```rust
        // Fetch the transaction outputs with proof
        let response = self.get_transaction_outputs_with_proof_by_size(
            proof_version,
            start_version,
            end_version,
            max_response_size,
            true, // This is a transaction or output request
            use_size_and_time_aware_chunking,
        )?;
```

**File:** state-sync/storage-service/server/src/storage.rs (L1179-1190)
```rust
            TransactionDataRequestType::TransactionOrOutputData(request) => {
                // Get the transaction or output list with proof
                self.get_transactions_or_outputs_with_proof_by_size(
                    proof_version,
                    start_version,
                    end_version,
                    request.include_events,
                    0, // Fetch all outputs, or return transactions
                    max_response_bytes,
                    self.config.enable_size_and_time_aware_chunking,
                )
            },
```
