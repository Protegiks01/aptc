# Audit Report

## Title
Missing Epoch Ending Ledger Info Verification Causes Bootstrap Synchronization Failure

## Summary
The bootstrapper's `get_end_of_epoch_ledger_info()` function calculates `payload_end_version` based on the actual number of transactions received rather than the requested range, then queries `verified_epoch_states` for an epoch ending ledger info at that version. When a malicious peer sends transactions beyond the requested version range that cross an unverified epoch boundary, the lookup returns `None`, causing the chunk executor to fail when it detects the epoch change during execution.

## Finding Description

The vulnerability exists in the state synchronization bootstrapping flow through a missing validation that allows peers to send more transactions than requested:

**Step 1: Bootstrapper requests bounded transaction range**
The bootstrapper calculates the next epoch ending version and requests transactions up to that boundary [1](#0-0) . This request is sent to peers via the data streaming service.

**Step 2: Missing payload boundary validation**
When receiving transaction payloads, the bootstrapper only verifies that `payload_start_version` matches expectations [2](#0-1) , but performs NO validation that the payload respects the requested `end_version` boundary.

**Step 3: Payload end version calculated from received data**
The `get_end_of_epoch_ledger_info()` function calculates `payload_end_version` as `payload_start_version + num_transactions - 1` based on the actual number of transactions received [3](#0-2) , not the requested range.

**Step 4: Epoch ending ledger info lookup fails**
The function queries `verified_epoch_states` for an epoch ending ledger info at the calculated `payload_end_version` [4](#0-3) . If a malicious peer sent transactions beyond the requested range to an unverified epoch boundary, this returns `None`.

**Step 5: Chunk executor detects mismatch and fails**
The chunk executor's verifier checks if an epoch change was detected during execution (`next_epoch_state` is `Some`) but no `epoch_change_li` was provided, returning an error that aborts synchronization [5](#0-4) .

**Why peers can send extra transactions:**
The cryptographic verification performed by `TransactionListWithProof::verify()` only checks that transaction hashes match transaction infos and that the infos are proven by the ledger info [6](#0-5) . It does NOT verify that transactions don't exceed a requested version boundary. Since the `proof_ledger_info` is typically the highest known ledger info (potentially many epochs ahead), transactions beyond the requested range will pass cryptographic verification.

The data streaming service's `bound_by_range()` function only affects internal tracking of stream progress [7](#0-6) , but the full payload with all transactions (including extras) is still returned to the bootstrapper [8](#0-7) .

## Impact Explanation

This vulnerability constitutes **High Severity** under Aptos bug bounty criteria:

**Validator Node Slowdowns:**
- Affected nodes cannot complete bootstrapping and remain stuck in a retry loop
- New validators cannot join the network
- Validators recovering from outages cannot resync
- Reduced number of operational nodes degrades network resilience

**Significant Protocol Violations:**
- The state synchronization protocol's security model assumes nodes can reliably fetch and verify epoch boundaries
- This vulnerability allows untrusted peers to provide data that violates version range assumptions
- The bootstrapper accepts cryptographically valid but semantically invalid payloads

**Network Impact:**
- Availability degradation during network stress or mass reboots
- Validators unable to participate in consensus lose rewards
- Fullnodes serving user queries cannot sync to current state

While this does not constitute Critical severity (no consensus violation, no fund loss), it significantly impacts network operations and node availability, qualifying as High Severity.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Capabilities Required:**
- Ability to act as a data streaming peer (malicious validator, fullnode, or network position)
- No cryptographic privileges or validator key compromise needed
- Can provide valid cryptographic proofs using publicly available ledger infos

**Triggering Conditions:**
- Node in bootstrapping mode (initial sync or recovery)
- Connection to malicious peer
- Peer sends payload with transactions beyond requested range that cross an epoch boundary

**Exploitation Complexity: LOW**
- Simply requires sending more transactions than requested
- If those transactions include an epoch change at an unverified version, vulnerability triggers automatically
- No timing requirements or race conditions

**Detection Difficulty: MEDIUM**
- Appears as normal synchronization errors in logs
- May be misattributed to network issues
- Root cause not immediately obvious without deep investigation

The vulnerability is especially concerning during network stress, upgrades, or incidents when many nodes bootstrap simultaneously.

## Recommendation

Add explicit validation in the bootstrapper to verify that received payloads respect the requested version range:

1. **Store requested end version** when creating the data stream
2. **Validate payload bounds** in `process_transaction_or_output_payload()`:
   - Calculate actual payload end version
   - Verify it does not exceed the requested end version
   - Reject payloads that exceed boundaries with appropriate feedback

Example validation:
```rust
// In process_transaction_or_output_payload()
let expected_end_version = self.get_speculative_stream_state()?.get_expected_end_version()?;
if payload_end_version > expected_end_version {
    self.reset_active_stream(Some(NotificationAndFeedback::new(
        notification_id,
        NotificationFeedback::PayloadProofFailed,
    ))).await?;
    return Err(Error::InvalidPayload(
        format!("Payload end version {} exceeds requested end version {}", 
                payload_end_version, expected_end_version)
    ));
}
```

3. **Additional safeguard**: Verify that if `payload_end_version` is different from a known epoch ending version, it must be less than the next known epoch ending version.

## Proof of Concept

The vulnerability requires a malicious peer in the network. A complete PoC would involve:

1. Setting up a node in bootstrapping mode
2. Configuring a malicious peer to respond to transaction requests
3. Having the malicious peer send valid transactions with correct proofs but extending beyond the requested `end_version` to cross an unverified epoch boundary
4. Observing the bootstrapper accept the payload, attempt execution, and fail during chunk verification

The core issue can be verified by code inspection showing:
- No validation of payload end version against requested range [9](#0-8) 
- Payload end version calculated from received data [10](#0-9) 
- Chunk executor failure on epoch change without ledger info [5](#0-4)

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L742-747)
```rust
        let end_version = self
            .verified_epoch_states
            .next_epoch_ending_version(highest_synced_version)
            .ok_or_else(|| {
                Error::UnexpectedError("No higher epoch ending version known!".into())
            })?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1149-1174)
```rust
        // Verify the payload starting version
        let expected_start_version = self
            .get_speculative_stream_state()?
            .expected_next_version()?;
        let payload_start_version = self
            .verify_payload_start_version(
                notification_metadata.notification_id,
                payload_start_version,
                expected_start_version,
            )
            .await?;

        // Get the expected proof ledger info for the payload
        let proof_ledger_info = self
            .get_speculative_stream_state()?
            .get_proof_ledger_info()?;

        // Get the end of epoch ledger info if the payload ends the epoch
        let end_of_epoch_ledger_info = self
            .get_end_of_epoch_ledger_info(
                notification_metadata.notification_id,
                payload_start_version,
                transaction_list_with_proof.as_ref(),
                transaction_outputs_with_proof.as_ref(),
            )
            .await?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1431-1441)
```rust
        let payload_end_version = payload_start_version
            .checked_add(num_versions as u64)
            .and_then(|v| v.checked_sub(1))
            .ok_or_else(|| {
                Error::IntegerOverflow("The payload end version has overflown!".into())
            })?; // payload_end_version = payload_start_version + num_versions - 1

        // Find any epoch ending ledger info at the payload end version
        Ok(self
            .verified_epoch_states
            .get_epoch_ending_ledger_info(payload_end_version))
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L118-123)
```rust
        } else {
            ensure!(
                next_epoch_state.is_none(),
                "End of epoch chunk based on local computation but no EoE LedgerInfo provided. version: {:?}",
                txn_accumulator.num_leaves().checked_sub(1),
            );
```

**File:** types/src/transaction/mod.rs (L2295-2336)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1728-1732)
```rust
        let last_received_version = bound_by_range(
            last_received_version,
            request_start_version,
            request_end_version,
        );
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2226-2236)
```rust
        ResponsePayload::TransactionsWithProof(transactions_chunk) => match stream_engine {
            StreamEngine::ContinuousTransactionStreamEngine(_) => {
                let target_ledger_info = target_ledger_info.ok_or_else(|| {
                    Error::UnexpectedErrorEncountered(
                        "The target ledger info was not provided".into(),
                    )
                })?;
                DataPayload::ContinuousTransactionsWithProof(target_ledger_info, transactions_chunk)
            },
            StreamEngine::TransactionStreamEngine(_) => {
                DataPayload::TransactionsWithProof(transactions_chunk)
```
