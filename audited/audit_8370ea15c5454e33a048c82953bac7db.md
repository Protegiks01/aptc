# Audit Report

## Title
Resource Group Creation with Delayed Fields Causes Execution Halt Due to Missing Metadata Check

## Summary
The `get_group_reads_needing_exchange_parallel()` function fails when a transaction creates a new resource group containing delayed fields and reads from it within the same transaction. The function attempts to retrieve metadata from the base storage layer for the group key, but for newly created groups, this metadata doesn't exist yet (returns None), causing a code invariant error that halts legitimate transaction execution.

## Finding Description
The vulnerability exists in the delayed field exchange finalization logic for resource groups. When a transaction:
1. Creates a new resource group (that doesn't exist in base storage)
2. Writes resources containing delayed fields to this group  
3. Reads from those resources within the same transaction

During finalization in `NativeAggregatorContext::into_change_set()`, the system calls `get_group_reads_needing_exchange()` to identify groups needing delayed field materialization. [1](#0-0) 

This function iterates through captured group reads and for those containing delayed fields, attempts to retrieve metadata for the group key: [2](#0-1) 

However, `get_resource_state_value_metadata()` reads from the view layer (MVHashMap or storage), NOT from the current transaction's write set. For a newly created group:
- The base value was initialized as a deletion when first accessed [3](#0-2) 
- The creation metadata exists in the GroupWrite's metadata_op but hasn't been committed yet
- Reading metadata from a deletion returns None [4](#0-3) 

This causes the error at lines 1416-1420, halting execution for a legitimate transaction operation.

The same issue affects the sequential path: [5](#0-4) 

## Impact Explanation
**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" and "Execution halt for legitimate reads" per the Aptos bug bounty criteria.

Impact:
- Legitimate transactions creating resource groups with delayed fields fail with code invariant errors
- Breaks deterministic execution invariant - valid Move code should execute successfully
- Affects any transaction pattern involving aggregator v2 (delayed fields) in newly created resource groups
- Causes transaction revert and potential transaction replay issues
- Could be triggered unintentionally by dApp developers using delayed fields

## Likelihood Explanation
**Medium to High Likelihood**:
- Occurs whenever Move code creates a resource group with delayed fields and performs read-after-write patterns
- Common in DeFi protocols using aggregators for counters/accumulators
- Does not require malicious intent - normal programming patterns trigger this
- Affects both parallel and sequential execution paths
- Likely to be encountered as aggregator v2 adoption increases

## Recommendation
The fix should check the current transaction's write set for group metadata before falling back to the base view. For `ExecutorViewWithChangeSet`, the metadata lookup already checks writes first: [6](#0-5) 

However, `get_group_reads_needing_exchange()` bypasses this by delegating directly to the base view: [7](#0-6) 

**Fix**: Modify `get_group_reads_needing_exchange_parallel()` and `get_group_reads_needing_exchange_sequential()` to accept an additional parameter for the write set, and check for group creation in the write set before returning an error for missing metadata. Alternatively, have these methods check if the group key exists in the skip set or write set before attempting metadata retrieval.

## Proof of Concept
```move
// Move module that triggers the bug
module 0xABCD::test_delayed_group {
    use std::string::String;
    use aptos_framework::aggregator_v2::{Aggregator, create_aggregator};
    
    struct ResourceWithAgg has key, store {
        agg: Aggregator<u64>,
        data: String,
    }
    
    // Creates a resource group and reads from it in same transaction
    public entry fun create_and_read(account: &signer) {
        // Create resource with delayed field in a group
        let agg = create_aggregator(1000);
        let resource = ResourceWithAgg { 
            agg, 
            data: b"test" 
        };
        
        // Write to group (implicitly creates it if new)
        move_to(account, resource);
        
        // Read from the same group (captures read with delayed field)
        let resource_ref = borrow_global<ResourceWithAgg>(@0xABCD);
        let _ = &resource_ref.agg; // Read triggers delayed field capture
        
        // Transaction finalization will call get_group_reads_needing_exchange
        // which fails to find metadata for the newly created group
    }
}
```

This transaction will fail during finalization with: "Metadata op not present for the group read"

## Notes
This vulnerability demonstrates a gap between the write set view and the metadata retrieval logic during delayed field exchange finalization. The system correctly handles metadata lookups for regular resource operations through `ExecutorViewWithChangeSet`, but the group exchange finalization path bypasses this layer, directly querying the base view where newly created groups don't yet exist.

### Citations

**File:** aptos-move/framework/src/natives/aggregator_natives/context.rs (L161-163)
```rust
                self.delayed_field_resolver
                    .get_group_reads_needing_exchange(&delayed_write_set_ids, &HashSet::new())?
            },
```

**File:** aptos-move/block-executor/src/view.rs (L1407-1420)
```rust
                match self.get_resource_state_value_metadata(&key)? {
                    Some(metadata) => match parallel_state.read_group_size(&key, self.txn_idx)? {
                        Some(group_size) => Ok(Some((key, (metadata, group_size.get())))),
                        None => Err(code_invariant_error(format!(
                            "Cannot compute metadata op size for the group read {:?}",
                            key
                        ))
                        .into()),
                    },
                    None => Err(code_invariant_error(format!(
                        "Metadata op not present for the group read {:?}",
                        key
                    ))
                    .into()),
```

**File:** aptos-move/block-executor/src/view.rs (L1472-1476)
```rust
                        None => Err(code_invariant_error(format!(
                            "Sequential cannot find metadata op for the group read {:?}",
                            key,
                        ))
                        .into()),
```

**File:** aptos-move/block-executor/src/view.rs (L1586-1599)
```rust
    fn initialize_mvhashmap_base_group_contents(&self, group_key: &T::Key) -> PartialVMResult<()> {
        let (base_group, metadata_op): (BTreeMap<T::Tag, Bytes>, _) =
            match self.get_raw_base_value(group_key)? {
                Some(state_value) => (
                    bcs::from_bytes(state_value.bytes()).map_err(|e| {
                        PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR)
                            .with_message(format!(
                                "Failed to deserialize the resource group at {:?}: {:?}",
                                group_key, e
                            ))
                    })?,
                    TransactionWrite::from_state_value(Some(state_value)),
                ),
                None => (BTreeMap::new(), TransactionWrite::from_state_value(None)),
```

**File:** types/src/write_set.rs (L438-442)
```rust
    // Note that even if WriteOp is DeletionWithMetadata, the method returns None, as a later
    // read would not read the metadata of the deletion op.
    fn as_state_value_metadata(&self) -> Option<StateValueMetadata> {
        self.as_state_value_opt().map(StateValue::metadata).cloned()
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L220-227)
```rust
    fn get_group_reads_needing_exchange(
        &self,
        delayed_write_set_keys: &HashSet<Self::Identifier>,
        skip: &HashSet<Self::ResourceKey>,
    ) -> PartialVMResult<BTreeMap<Self::ResourceKey, (StateValueMetadata, u64)>> {
        self.base_executor_view
            .get_group_reads_needing_exchange(delayed_write_set_keys, skip)
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L261-262)
```rust
            Some(AbstractResourceWriteOp::WriteResourceGroup(write_op)) => {
                Ok(write_op.metadata_op().as_state_value_metadata())
```
