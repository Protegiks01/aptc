# Audit Report

## Title
Commit Vote Equivocation Not Prevented by SafetyRules - Byzantine Validator Can Sign Multiple Different Commits for Same Round

## Summary
The `SafetyRules::guarded_sign_commit_vote` function fails to detect and prevent equivocation when called multiple times with different `commit_ledger_info` values for the same round. A Byzantine validator can exploit this to sign conflicting commit votes, violating consensus safety guarantees.

## Finding Description

The SafetyRules module is the critical defense mechanism that prevents validators from violating consensus safety rules, even if they attempt to do so maliciously. When signing commit votes, SafetyRules should maintain state to prevent a validator from signing two different commit votes for the same round (equivocation).

However, the `guarded_sign_commit_vote` function lacks this protection. [1](#0-0) 

The function performs several validation checks but **does not**:
1. Check if a commit vote was already signed for this round
2. Track which commit info was previously signed 
3. Update any state to prevent future equivocation

In contrast, the `guarded_construct_and_sign_vote_two_chain` function for regular voting **does** implement equivocation prevention. [2](#0-1) 

The `SafetyData` structure that stores safety-critical state only tracks `last_voted_round` for regular block votes, but has no field for tracking commit vote state. [3](#0-2) 

The `SigningPhase::process` function is stateless and simply forwards requests to SafetyRules without any duplicate detection. [4](#0-3) 

**Attack Path:**
1. A Byzantine validator receives an executed block for round R with legitimate `commit_ledger_info_1`
2. The validator calls `process()` → SafetyRules signs it → signature_1
3. The validator crafts malicious `commit_ledger_info_2` with different state root for same round R
4. The validator calls `process()` again → SafetyRules signs it → signature_2  
5. The validator broadcasts both (commit_ledger_info_1, signature_1) and (commit_ledger_info_2, signature_2)
6. Different honest validators may accept different commits, causing consensus divergence

The incomplete implementation is evidenced by TODO comments in the code. [5](#0-4) 

## Impact Explanation

**Severity: CRITICAL** (per Aptos Bug Bounty: "Consensus/Safety violations" - up to $1,000,000)

This vulnerability breaks the fundamental safety guarantee of BFT consensus: **no equivocation**. A single Byzantine validator can:

- Sign conflicting commits for the same round with different state roots
- Cause consensus divergence between honest validators
- Potentially enable double-spending if different validators commit different transaction sets
- Break the linearizability guarantee of the blockchain

This violates **Critical Invariant #2**: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"

The impact is severe even with a single Byzantine validator because:
- It defeats the entire purpose of SafetyRules as the last line of defense
- It can cause non-recoverable consensus forks requiring manual intervention
- It undermines trust in the finality of committed transactions

## Likelihood Explanation

**Likelihood: MEDIUM**

**Requirements:**
- Attacker must be a validator OR compromise a validator's consensus keys
- Attacker must run modified consensus software that bypasses `BufferManager` protections
- Attacker needs sufficient technical capability to craft valid-looking but conflicting commit ledger info

**Mitigating Factors:**
- Requires validator access (high barrier to entry)
- The honest `BufferManager` implementation prevents this in normal operation [6](#0-5) 
- Other validators would need to accept conflicting commits (depends on timing/network conditions)

**Aggravating Factors:**
- SafetyRules is supposed to be the last line of defense and should prevent this even from malicious validators
- No runtime detection or alerting for this behavior
- The test suite does not cover this case [7](#0-6) 

## Recommendation

Add commit vote equivocation detection to `SafetyData` and `SafetyRules`:

**1. Extend SafetyData structure:**
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    pub preferred_round: u64,
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    pub highest_timeout_round: u64,
    // NEW: Track last signed commit vote
    pub last_commit_vote_round: u64,
    pub last_commit_vote_hash: Option<HashValue>,
}
```

**2. Update guarded_sign_commit_vote:**
```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    let mut safety_data = self.persistent_storage.safety_data()?;
    
    // NEW: Check for equivocation
    let commit_round = new_ledger_info.round();
    if commit_round == safety_data.last_commit_vote_round {
        let new_hash = new_ledger_info.hash();
        if let Some(last_hash) = safety_data.last_commit_vote_hash {
            if last_hash != new_hash {
                return Err(Error::EquivocationDetected(
                    commit_round,
                    last_hash,
                    new_hash,
                ));
            }
        }
        // Return cached signature if available
    }
    
    // ... existing validation ...
    
    let signature = self.sign(&new_ledger_info)?;
    
    // NEW: Update tracking state
    safety_data.last_commit_vote_round = commit_round;
    safety_data.last_commit_vote_hash = Some(new_ledger_info.hash());
    self.persistent_storage.set_safety_data(safety_data)?;
    
    Ok(signature)
}
```

## Proof of Concept

Add this test to `consensus/safety-rules/src/tests/suite.rs`:

```rust
/// Test that signing multiple different commit votes for the same round is prevented
fn test_sign_commit_vote_equivocation(constructor: &Callback) {
    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    let round = genesis_qc.certified_block().round();
    safety_rules.initialize(&proof).unwrap();

    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);

    let ledger_info_with_sigs = a3.block().quorum_cert().ledger_info();
    let commit_info_1 = ledger_info_with_sigs.ledger_info().clone();
    
    // First signing succeeds
    assert!(safety_rules
        .sign_commit_vote(ledger_info_with_sigs.clone(), commit_info_1.clone())
        .is_ok());
    
    // Create a different commit info for the SAME round
    let mut commit_info_2 = commit_info_1.clone();
    // Modify the commit info to make it different
    let different_block_info = BlockInfo::new(
        commit_info_1.commit_info().epoch(),
        commit_info_1.round(),
        HashValue::random(), // Different hash
        commit_info_1.commit_info().executed_state_id(),
        commit_info_1.commit_info().version(),
        commit_info_1.commit_info().timestamp_usecs(),
        None,
    );
    commit_info_2 = LedgerInfo::new(different_block_info, HashValue::random());
    
    // Attempting to sign a DIFFERENT commit for the same round should FAIL
    // Currently this SUCCEEDS (vulnerability)
    let result = safety_rules.sign_commit_vote(
        ledger_info_with_sigs.clone(),
        commit_info_2
    );
    
    // This assertion SHOULD pass but currently FAILS:
    assert!(result.is_err(), "SafetyRules should prevent commit vote equivocation");
}
```

Run with:
```bash
cd consensus/safety-rules
cargo test test_sign_commit_vote_equivocation -- --nocapture
```

**Expected behavior:** Test should pass (error returned on equivocation attempt)  
**Actual behavior:** Test fails (SafetyRules signs both conflicting commits)

## Notes

This vulnerability exists because the commit vote signing path was implemented without the same equivocation protection that exists for regular block voting. The SafetyRules module correctly prevents equivocation for regular votes but fails to do so for commit votes, creating a critical gap in consensus safety guarantees.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L68-74)
```rust
        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/src/pipeline/signing_phase.rs (L72-98)
```rust
    async fn process(&self, req: SigningRequest) -> SigningResponse {
        let SigningRequest {
            ordered_ledger_info,
            commit_ledger_info,
            blocks,
        } = req;

        let signature_result = if let Some(fut) = blocks
            .last()
            .expect("Blocks can't be empty")
            .pipeline_futs()
        {
            fut.commit_vote_fut
                .clone()
                .await
                .map(|vote| vote.signature().clone())
                .map_err(|e| Error::InternalError(e.to_string()))
        } else {
            self.safety_rule_handle
                .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
        };

        SigningResponse {
            signature_result,
            commit_ledger_info,
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L478-480)
```rust
            if cursor == self.signing_root {
                let sender = self.signing_phase_tx.clone();
                Self::spawn_retry_request(sender, request, Duration::from_millis(100));
```

**File:** consensus/safety-rules/src/tests/suite.rs (L846-936)
```rust
fn test_sign_commit_vote(constructor: &Callback) {
    // we construct a chain of proposals
    // genesis -- a1 -- a2 -- a3

    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);

    let round = genesis_qc.certified_block().round();
    safety_rules.initialize(&proof).unwrap();

    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);

    // now we try to agree on a1's execution result
    let ledger_info_with_sigs = a3.block().quorum_cert().ledger_info();
    // make sure this is for a1
    assert!(ledger_info_with_sigs
        .ledger_info()
        .commit_info()
        .match_ordered_only(
            &a1.block()
                .gen_block_info(*ACCUMULATOR_PLACEHOLDER_HASH, 0, None,)
        ));

    assert!(safety_rules
        .sign_commit_vote(
            ledger_info_with_sigs.clone(),
            ledger_info_with_sigs.ledger_info().clone()
        )
        .is_ok());

    // check empty ledger info
    assert!(matches!(
        safety_rules
            .sign_commit_vote(
                a2.block().quorum_cert().ledger_info().clone(),
                a3.block().quorum_cert().ledger_info().ledger_info().clone()
            )
            .unwrap_err(),
        Error::InvalidOrderedLedgerInfo(_)
    ));

    // non-dummy blockinfo test
    assert!(matches!(
        safety_rules
            .sign_commit_vote(
                LedgerInfoWithSignatures::new(
                    LedgerInfo::new(
                        a1.block().gen_block_info(
                            *ACCUMULATOR_PLACEHOLDER_HASH,
                            100, // non-dummy value
                            None
                        ),
                        ledger_info_with_sigs.ledger_info().consensus_data_hash()
                    ),
                    AggregateSignature::empty(),
                ),
                ledger_info_with_sigs.ledger_info().clone()
            )
            .unwrap_err(),
        Error::InvalidOrderedLedgerInfo(_)
    ));

    // empty signature test
    assert!(matches!(
        safety_rules
            .sign_commit_vote(
                LedgerInfoWithSignatures::new(
                    ledger_info_with_sigs.ledger_info().clone(),
                    AggregateSignature::empty(),
                ),
                ledger_info_with_sigs.ledger_info().clone()
            )
            .unwrap_err(),
        Error::InvalidQuorumCertificate(_)
    ));

    // inconsistent ledger_info test
    let bad_ledger_info = LedgerInfo::new(
        BlockInfo::random(ledger_info_with_sigs.ledger_info().round()),
        ledger_info_with_sigs.ledger_info().consensus_data_hash(),
    );

    assert!(matches!(
        safety_rules
            .sign_commit_vote(ledger_info_with_sigs.clone(), bad_ledger_info,)
            .unwrap_err(),
        Error::InconsistentExecutionResult(_, _)
    ));
}
```
