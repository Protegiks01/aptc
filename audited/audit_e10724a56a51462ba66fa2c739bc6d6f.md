# Audit Report

## Title
Malicious Randomness Threshold Configuration Causes Validator Memory Exhaustion via Unbounded FFT Domain Allocation in DKG

## Summary
A malicious governance proposal can set randomness configuration thresholds (`secrecy_threshold` and `reconstruction_threshold`) to nearly identical values, causing the DKG (Distributed Key Generation) weight calculation to produce astronomically large total weights. This forces `BatchEvaluationDomain::new()` to allocate multi-terabyte vectors for FFT operations, exhausting validator memory and crashing nodes during epoch transitions.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Unvalidated Threshold Configuration**: The `randomness_config.move` module allows governance to set arbitrary threshold values without validation. [1](#0-0) 

2. **Weight Calculation with Minimal Delta**: When DKG rounding processes these thresholds, it enforces only a minimum delta of `U64F64::DELTA` (2^-64) between thresholds. [2](#0-1) 

3. **Unbounded Upper Bound Formula**: The total weight upper bound is calculated as `(n/2 + 2) / (reconstruct_threshold - secrecy_threshold)`. With thresholds separated by only 2^-64, this produces values like `52 * 2^64 ≈ 9.6 × 10^20` for 100 validators. [3](#0-2) 

4. **Unvalidated FFT Domain Allocation**: When creating the weighted config, `BatchEvaluationDomain::new(n)` computes the next power of 2 and allocates a vector without checking size limits. [4](#0-3) 

**Attack Flow:**

1. Malicious governance proposal sets `randomness_config` with:
   - `secrecy_threshold = 0.5`
   - `reconstruction_threshold = 0.5 + 2^-64` (barely above secrecy threshold)

2. During next epoch's DKG setup, `build_dkg_pvss_config()` calls `DKGRounding::new()` with these thresholds.

3. The weight calculation uses `stake_per_weight = 1` (minimum enforced by max on line 221-224) because the upper bound is so large. [5](#0-4) 

4. Each validator with voting power of 10^9 gets weight ≈ 10^9 (stake/stake_per_weight). [6](#0-5) 

5. Total weight for 100 validators = 100 × 10^9 = 10^11.

6. `WeightedConfigBlstrs::new()` creates `ThresholdConfigBlstrs::new(threshold, 10^11)`. [7](#0-6) 

7. This calls `BatchEvaluationDomain::new(10^11)`, which computes N = 2^37 (next power of 2).

8. The code attempts to allocate `Vec::with_capacity(2^37)` for Scalars, requiring ~4.4 TB of memory. [8](#0-7) 

9. All validators crash simultaneously during epoch transition, causing total network liveness loss.

**Broken Invariant**: Resource Limits (invariant #9) - "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability causes **Total loss of liveness/network availability**:

- All validators crash simultaneously when attempting epoch transition with malicious DKG config
- Network cannot progress blocks until governance fixes the randomness config
- Recovery requires emergency governance intervention or hard fork
- No individual validator can avoid the crash since DKG config is consensus-determined

The attack affects the entire network, not individual nodes, meeting the "Non-recoverable network partition" and "Total loss of liveness" criteria for Critical severity.

## Likelihood Explanation

**Likelihood: Medium**

**Requirements:**
- Malicious governance proposal must pass (requires 50%+ voting power)
- Proposal must specifically target randomness config with near-identical thresholds
- Attack is deterministic once malicious config is activated

**Mitigating Factors:**
- Requires governance compromise (not trivial)
- Validators can review proposals before voting
- Attack is detectable in proposal parameters

**Aggravating Factors:**
- Single malicious proposal causes immediate total network failure
- No technical barriers once governance is compromised
- Attack cannot be prevented by individual validators

## Recommendation

Add validation to randomness configuration to enforce minimum threshold separation:

**In `aptos-move/framework/aptos-framework/sources/configs/randomness_config.move`:**

```move
public fun new_v1(
    secrecy_threshold: FixedPoint64, 
    reconstruction_threshold: FixedPoint64
): RandomnessConfig {
    // Validate thresholds
    assert!(
        fixed_point64::greater(
            reconstruction_threshold,
            fixed_point64::add(
                secrecy_threshold,
                fixed_point64::create_from_rational(1, 100) // Minimum 1% separation
            )
        ),
        EINVALID_THRESHOLD_SEPARATION
    );
    assert!(
        fixed_point64::less_or_equal(
            reconstruction_threshold,
            fixed_point64::create_from_rational(2, 3) // Max 2/3
        ),
        EINVALID_RECONSTRUCTION_THRESHOLD
    );
    assert!(
        fixed_point64::greater(
            secrecy_threshold,
            fixed_point64::create_from_rational(1, 3) // Min 1/3
        ),
        EINVALID_SECRECY_THRESHOLD
    );
    
    RandomnessConfig {
        variant: copyable_any::pack(ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold
        })
    }
}
```

**Additionally, add defensive check in `crates/aptos-crypto/src/blstrs/evaluation_domain.rs`:**

```rust
pub fn new(n: usize) -> Self {
    let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
    
    // Prevent excessive memory allocation
    const MAX_LOG_N: usize = 30; // 2^30 = ~1B elements = ~32GB
    assert!(
        log_N <= MAX_LOG_N,
        "FFT domain size 2^{} exceeds maximum allowed 2^{}",
        log_N,
        MAX_LOG_N
    );
    
    let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);
    // ... rest of implementation
}
```

## Proof of Concept

```rust
// File: types/src/dkg/real_dkg/rounding/attack_test.rs

#[cfg(test)]
mod memory_exhaustion_attack {
    use super::*;
    use fixed::types::U64F64;
    
    #[test]
    #[should_panic(expected = "memory allocation")]
    fn test_malicious_threshold_causes_memory_exhaustion() {
        // Simulate 100 validators with 1 billion voting power each
        let validator_stakes: Vec<u64> = vec![1_000_000_000; 100];
        
        // Malicious thresholds: barely separated
        let secrecy_threshold = U64F64::from_num(0.5);
        let reconstruct_threshold = secrecy_threshold + U64F64::DELTA;
        
        // This will compute huge total_weight_upper_bound
        let upper_bound = total_weight_upper_bound(
            &validator_stakes,
            reconstruct_threshold,
            secrecy_threshold,
        );
        
        println!("Upper bound: {}", upper_bound); // Will be ~9.6 × 10^20
        
        // Attempt to create DKG config - will panic trying to allocate
        let rounding = DKGRounding::new(
            &validator_stakes,
            secrecy_threshold,
            reconstruct_threshold,
            None,
        );
        
        // If we get here, the WeightedConfigBlstrs::new() call
        // will attempt to create BatchEvaluationDomain with huge N
        // causing memory allocation failure
        let total_weight: u64 = rounding.profile.validator_weights.iter().sum();
        println!("Total weight: {}", total_weight); // Will be ~10^11
        
        // This panics due to massive allocation
        let _ = WeightedConfigBlstrs::new(
            rounding.profile.reconstruct_threshold_in_weights as usize,
            rounding.profile.validator_weights.iter().map(|w| *w as usize).collect(),
        );
    }
}
```

**Notes:**
- The vulnerability requires governance compromise but causes deterministic total network failure
- The fix requires both Move-level validation (prevention) and Rust-level bounds checking (defense-in-depth)
- Current default thresholds (1/2 and 2/3) are safe, but nothing prevents malicious reconfiguration

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-99)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L67-70)
```rust
        ) == (
            other.epoch,
            &other.wconfig,
            &other.fast_wconfig,
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L34-48)
```rust
pub fn total_weight_upper_bound(
    validator_stakes: &[u64],
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    secrecy_threshold_in_stake_ratio: U64F64,
) -> usize {
    reconstruct_threshold_in_stake_ratio = max(
        reconstruct_threshold_in_stake_ratio,
        secrecy_threshold_in_stake_ratio + U64F64::DELTA,
    );
    let two = U64F64::from_num(2);
    let n = U64F64::from_num(validator_stakes.len());
    ((n / two + two) / (reconstruct_threshold_in_stake_ratio - secrecy_threshold_in_stake_ratio))
        .ceil()
        .to_num::<usize>()
}
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L221-224)
```rust
            let stake_per_weight = max(
                U64F64::from_num(1),
                U64F64::from_num(stake_total) / U64F64::from_num(weight_mid),
            );
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L311-315)
```rust
        let ideal_weight_fixed = U64F64::from_num(*stake) / stake_per_weight;
        // rounded to the nearest integer
        let rounded_weight_fixed = (ideal_weight_fixed + (one / 2)).floor();
        let rounded_weight = rounded_weight_fixed.to_num::<u64>();
        validator_weights.push(rounded_weight);
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L120-131)
```rust
    pub fn new(n: usize) -> Self {
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);

        let mut omegas = Vec::with_capacity(N);
        omegas.push(Scalar::ONE);

        let mut acc = omega;
        for _ in 1..N {
            omegas.push(acc);
            acc *= omega; // $\omega^i$
        }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L96-106)
```rust
        let tc = TC::new(threshold_weight, W)?;
        Ok(WeightedConfig {
            tc,
            num_players: n,
            weights,
            starting_index,
            max_weight,
            min_weight,
        })
    }

```
