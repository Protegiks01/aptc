# Audit Report

## Title
Unauthenticated Build Information Disclosure Through Peer Monitoring Service on Public Networks

## Summary
The peer monitoring service exposes detailed build information (commit hash, build time, Rust version, build profile, etc.) to any peer connected to public networks without authentication or access controls, enabling node fingerprinting and version-based reconnaissance.

## Finding Description

The `get_build_information()` function exposes comprehensive build metadata including: [1](#0-0) 

This information is served through the peer monitoring service's `GetNodeInformation` RPC endpoint: [2](#0-1) 

The service is registered on ALL networks (validator, VFN, and public) without discrimination: [3](#0-2) 

Public networks operate with `mutual_authentication = false`, allowing untrusted connections: [4](#0-3) 

The server processes ALL requests without access control checks: [5](#0-4) 

**Attack Flow:**
1. Attacker connects to any VFN/PFN on the public network (no authentication required)
2. Sends `GetNodeInformation` RPC request  
3. Receives detailed build metadata in response
4. Uses commit hash and build time to identify nodes running vulnerable versions
5. Targets specific exploits against identified outdated nodes

## Impact Explanation

While this is primarily an **information disclosure** vulnerability, it enables:

- **Node Fingerprinting**: Exact commit hash identification allows mapping of the validator/VFN infrastructure
- **Vulnerability Targeting**: Attackers can identify nodes running commits with known vulnerabilities and launch targeted attacks
- **Infrastructure Reconnaissance**: Build timestamps and profiles reveal deployment patterns and testing vs. production environments

Per Aptos bug bounty criteria, this falls under **Low Severity** ("Minor information leaks") as it doesn't directly cause fund loss, consensus violations, or availability issues. However, it serves as a reconnaissance tool for higher-severity attacks.

## Likelihood Explanation

**Likelihood: High**

- No authentication required on public networks
- No special privileges needed
- Simple RPC call execution
- Service is enabled by default on all node types
- Only network-level byte-rate limiting exists (100 KiB/s), no request-specific limits

## Recommendation

**Option 1: Remove build information from public network responses**
```rust
fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
    // Only include build info for authenticated peers on validator/VFN networks
    let build_information = if self.network_id.is_public_network() {
        BTreeMap::new() // Empty for public networks
    } else {
        aptos_build_info::get_build_information()
    };
    // ... rest of implementation
}
```

**Option 2: Implement access controls**
- Restrict `GetNodeInformation` to authenticated peers only
- Add configuration flag to disable build info exposure per network

**Option 3: Sanitize build information**
- Only expose major version tags, not exact commit hashes
- Remove build timestamps and debug information

## Proof of Concept

```rust
use aptos_peer_monitoring_service_types::{
    request::PeerMonitoringServiceRequest,
    response::NodeInformationResponse,
};
use aptos_network::protocols::network::RpcError;

#[tokio::test]
async fn test_unauthenticated_build_info_disclosure() {
    // Setup: Create a mock public network peer (untrusted)
    let network_id = NetworkId::Public;
    let (client, mut server, _, _) = MockMonitoringServer::new(vec![network_id]);
    let peer = server.add_new_peer(network_id, PeerRole::Unknown);
    
    // Attack: Send GetNodeInformation request as untrusted peer
    let request = PeerMonitoringServiceRequest::GetNodeInformation;
    let _ = client.send_request(peer, request).await;
    
    // Verify: Server responds with build information
    let network_request = server.next_request(&network_id).await.unwrap();
    assert!(matches!(
        network_request.peer_monitoring_service_request,
        PeerMonitoringServiceRequest::GetNodeInformation
    ));
    
    // Server would respond with build_information map containing:
    // - BUILD_COMMIT_HASH: exact git commit
    // - BUILD_BRANCH: git branch name  
    // - BUILD_TIME: build timestamp
    // - BUILD_RUST_VERSION: compiler version
    // This enables version fingerprinting and vulnerability targeting
}
```

## Notes

This vulnerability exists because the peer monitoring service prioritizes operational observability over information security. While the exposed metadata is valuable for legitimate monitoring, it should be restricted to authenticated peers on trusted networks rather than exposed to any peer on public networks.

### Citations

**File:** crates/aptos-build-info/src/lib.rs (L59-105)
```rust
pub fn get_build_information() -> BTreeMap<String, String> {
    shadow!(build);

    let mut build_information = BTreeMap::new();

    // Get Git metadata from shadow_rs crate.
    // This is applicable for native builds where the cargo has
    // access to the .git directory.
    build_information.insert(BUILD_BRANCH.into(), build::BRANCH.into());
    build_information.insert(BUILD_CARGO_VERSION.into(), build::CARGO_VERSION.into());
    build_information.insert(BUILD_CLEAN_CHECKOUT.into(), build::GIT_CLEAN.to_string());
    build_information.insert(BUILD_COMMIT_HASH.into(), build::COMMIT_HASH.into());
    build_information.insert(BUILD_TAG.into(), build::TAG.into());
    build_information.insert(BUILD_TIME.into(), build::BUILD_TIME.into());
    build_information.insert(BUILD_OS.into(), build::BUILD_OS.into());
    build_information.insert(BUILD_RUST_CHANNEL.into(), build::RUST_CHANNEL.into());
    build_information.insert(BUILD_RUST_VERSION.into(), build::RUST_VERSION.into());

    // Compilation information
    build_information.insert(BUILD_IS_RELEASE_BUILD.into(), is_release().to_string());
    build_information.insert(BUILD_PROFILE_NAME.into(), get_build_profile_name());
    build_information.insert(
        BUILD_USING_TOKIO_UNSTABLE.into(),
        std::env!("USING_TOKIO_UNSTABLE").to_string(),
    );

    // Get Git metadata from environment variables set during build-time.
    // This is applicable for docker based builds  where the cargo cannot
    // access the .git directory, or to override shadow_rs provided info.
    if let Ok(git_sha) = std::env::var("GIT_SHA") {
        build_information.insert(BUILD_COMMIT_HASH.into(), git_sha);
    }

    if let Ok(git_branch) = std::env::var("GIT_BRANCH") {
        build_information.insert(BUILD_BRANCH.into(), git_branch);
    }

    if let Ok(git_tag) = std::env::var("GIT_TAG") {
        build_information.insert(BUILD_TAG.into(), git_tag);
    }

    if let Ok(build_date) = std::env::var("BUILD_DATE") {
        build_information.insert(BUILD_TIME.into(), build_date);
    }

    build_information
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-182)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L259-281)
```rust
    fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the node information
        let build_information = aptos_build_info::get_build_information();
        let current_time: Instant = self.time_service.now();
        let uptime = current_time.duration_since(self.start_time);
        let (highest_synced_epoch, highest_synced_version) =
            self.storage.get_highest_synced_epoch_and_version()?;
        let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
        let lowest_available_version = self.storage.get_lowest_available_version()?;

        // Create and return the response
        let node_information_response = NodeInformationResponse {
            build_information,
            highest_synced_epoch,
            highest_synced_version,
            ledger_timestamp_usecs,
            lowest_available_version,
            uptime,
        };
        Ok(PeerMonitoringServiceResponse::NodeInformation(
            node_information_response,
        ))
    }
```

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```
