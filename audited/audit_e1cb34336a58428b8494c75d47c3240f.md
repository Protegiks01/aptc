# Audit Report

## Title
URL Encoding Bypass in NFT Metadata Crawler Blacklist Validation

## Summary
The `is_blacklisted_uri()` function in the NFT metadata crawler performs blacklist validation using simple string matching without URL decoding, allowing attackers to bypass blacklisted domains using percent-encoded characters (e.g., `%65%76%69%6c.com` bypasses `evil.com`).

## Finding Description

The NFT metadata crawler implements a URI blacklist to prevent processing of malicious or unwanted content. However, the blacklist check implementation is vulnerable to URL encoding bypass. [1](#0-0) 

The function performs a simple string `contains()` check without normalizing or decoding the URI. This allows an attacker to bypass blacklist restrictions by using percent-encoded versions of blacklisted domains.

**Attack Flow:**

1. An attacker creates an NFT with metadata containing a percent-encoded malicious domain (e.g., `https://%65%76%69%6c.com/malicious.png` where `%65%76%69%6c` decodes to `evil`)
2. The NFT metadata is indexed from the blockchain and queued for processing
3. The blacklist check at line 94 (for `asset_uri`) or line 206 (for `raw_image_uri`) is performed [2](#0-1) 
4. The encoded URI `%65%76%69%6c.com` does not match the literal string `evil.com` in the blacklist
5. The crawler proceeds to fetch and process the malicious content
6. Malicious content is stored in GCS and the database [3](#0-2) 

The vulnerability exists because URL decoding is not performed before blacklist matching. The standard library `url` crate is imported but only used for validation, not for extracting and normalizing the hostname for comparison. [4](#0-3) 

## Impact Explanation

This vulnerability allows attackers to bypass security controls designed to protect the NFT metadata crawler infrastructure. The impact includes:

1. **Blacklist Bypass**: Complete circumvention of the URI blacklist security control
2. **Resource Exhaustion**: Processing of resource-intensive content from blacklisted domains could cause service degradation
3. **SSRF Potential**: If the blacklist protects internal resources, encoded URIs could enable Server-Side Request Forgery attacks
4. **Storage Pollution**: Malicious content stored in GCS and database, potentially violating terms of service or legal requirements
5. **API Service Disruption**: Processing malicious content could crash the crawler service

This qualifies as **High Severity** under Aptos bug bounty criteria as it can cause API crashes and service disruptions. While not affecting core blockchain consensus, it compromises a critical ecosystem service that indexes NFT metadata for the Aptos network.

## Likelihood Explanation

**Likelihood: HIGH**

- **No special privileges required**: Any user can create NFTs with arbitrary metadata URIs
- **Trivial to exploit**: Simple percent-encoding of domain names
- **Currently undetected**: Blacklist appears to be in active use based on configuration structure [5](#0-4) 
- **Multiple attack vectors**: Both `asset_uri` and `raw_image_uri` are vulnerable

## Recommendation

Decode and normalize URIs before blacklist validation. The recommended fix uses the `url` crate to parse and extract the hostname for comparison:

```rust
fn is_blacklisted_uri(&mut self, uri: &str) -> bool {
    // First check raw string for exact matches (backward compatibility)
    if self.parser_config
        .uri_blacklist
        .iter()
        .any(|blacklist_uri| uri.contains(blacklist_uri))
    {
        return true;
    }
    
    // Parse URL and check decoded hostname
    if let Ok(parsed_url) = Url::parse(uri) {
        if let Some(host) = parsed_url.host_str() {
            // Check if decoded hostname contains any blacklisted string
            return self.parser_config
                .uri_blacklist
                .iter()
                .any(|blacklist_uri| host.contains(blacklist_uri));
        }
    }
    
    false
}
```

Alternatively, use percent-decoding from the `percent-encoding` crate (already available in the workspace):

```rust
use percent_encoding::percent_decode_str;

fn is_blacklisted_uri(&mut self, uri: &str) -> bool {
    // Decode the URI
    let decoded_uri = percent_decode_str(uri)
        .decode_utf8()
        .unwrap_or(std::borrow::Cow::Borrowed(uri));
    
    self.parser_config
        .uri_blacklist
        .iter()
        .any(|blacklist_uri| decoded_uri.contains(blacklist_uri))
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_blacklist_bypass_with_url_encoding() {
        // Setup
        let mut config = ParserConfig {
            uri_blacklist: vec!["evil.com".to_string()],
            // ... other config fields
        };
        
        // These should be blocked but currently are not:
        let encoded_evil = "https://%65%76%69%6c.com/malicious.png";
        let double_encoded = "https://%2565%2576%2569%256c.com/bad.jpg";
        
        // Current (vulnerable) implementation
        assert_eq!(encoded_evil.contains("evil.com"), false); // Bypass!
        
        // Expected behavior: should detect encoded version
        let parsed = Url::parse(encoded_evil).unwrap();
        assert_eq!(parsed.host_str().unwrap(), "evil.com"); // Decoded by url crate
        
        // Exploitation scenario:
        // 1. Attacker creates NFT with asset_uri = "https://%65%76%69%6c.com/phishing.json"
        // 2. Crawler receives URI from blockchain
        // 3. is_blacklisted_uri() returns false (bypass!)
        // 4. Malicious content is fetched, processed, and stored
    }
}
```

**Notes:**

While this vulnerability affects an ecosystem service rather than core blockchain consensus, it represents a significant security control bypass. The NFT metadata crawler is a critical infrastructure component that processes untrusted user input from blockchain transactions. The blacklist mechanism exists as a security control, and its bypass could enable various attacks including SSRF, resource exhaustion, and content policy violations.

The severity assessment depends on the specific domains in the production blacklist - if protecting against known malicious actors or internal infrastructure, the impact is elevated to High severity as categorized in the original security question.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L29-29)
```rust
use url::Url;
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L93-100)
```rust
        // Check asset_uri against the URI blacklist
        if self.is_blacklisted_uri(&self.asset_uri.clone()) {
            self.log_info("Found match in URI blacklist, marking as do_not_parse");
            self.model.set_do_not_parse(true);
            self.upsert();
            SKIP_URI_COUNT.with_label_values(&["blacklist"]).inc();
            return Ok(());
        }
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L142-161)
```rust
                let cdn_json_uri_result = write_json_to_gcs(
                    &self.parser_config.bucket,
                    &self.asset_uri,
                    &json,
                    &self.gcs_client,
                )
                .await;

                if let Err(e) = cdn_json_uri_result.as_ref() {
                    self.log_warn(
                        "Failed to write JSON to GCS, maybe upload timed out?",
                        Some(e),
                    );
                }

                let cdn_json_uri = cdn_json_uri_result
                    .map(|value| format!("{}{}", self.parser_config.cdn_prefix, value))
                    .ok();
                self.model.set_cdn_json_uri(cdn_json_uri);
            }
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L386-391)
```rust
    fn is_blacklisted_uri(&mut self, uri: &str) -> bool {
        self.parser_config
            .uri_blacklist
            .iter()
            .any(|blacklist_uri| uri.contains(blacklist_uri))
    }
```

**File:** ecosystem/nft-metadata-crawler/src/parser/config.rs (L29-29)
```rust
    pub uri_blacklist: Vec<String>,
```
