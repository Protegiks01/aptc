# Audit Report

## Title
Gas Estimation Cache Bypass Enables API Performance Degradation via Unvalidated cache_expiration_ms Configuration

## Summary
The `GasEstimationConfig` sanitizer fails to validate `cache_expiration_ms`, allowing it to be set to 0. When combined with a large `aggressive_block_history` value, this causes every gas estimation API call to bypass caching and perform expensive database operations, leading to severe API performance degradation and potential node unresponsiveness.

## Finding Description

The gas estimation configuration sanitizer validates `aggressive_block_history`, `market_block_history`, and `low_block_history` to ensure they are greater than zero and properly ordered, but **completely omits validation for `cache_expiration_ms`**. [1](#0-0) 

When `cache_expiration_ms` is set to 0, the cache validity check in `cached_gas_estimation()` always fails because the comparison `time.elapsed().as_millis() as u64 < 0` is always false: [2](#0-1) 

This breaks the intended caching behavior. Every call to the public `/estimate_gas_price` endpoint triggers the full estimation computation: [3](#0-2) 

With large `aggressive_block_history` (default 120, but can be set much higher), the system must:

1. Acquire a write lock on the gas estimation cache (causing contention)
2. Iterate up to `aggressive_block_history` times to fetch block metadata
3. For blocks not in the persistent min_inclusion_prices cache, call `block_min_inclusion_price()` which reads all transactions in each block
4. Sort and compute percentiles over potentially thousands of values
5. Never benefit from the time-based cache [4](#0-3) 

The `block_min_inclusion_price()` function performs expensive database reads for each block: [5](#0-4) 

**Attack Scenario:**
1. Node operator sets `cache_expiration_ms = 0` (mistakenly thinking 0 means "unlimited" or "no expiration")
2. Sets `aggressive_block_history = 10000` (or leaves at high value)
3. Users call `/estimate_gas_price` endpoint repeatedly (common for wallet/dapp operations)
4. Each call:
   - First call in epoch: Reads 10,000 blocks from database and all their transactions (potentially millions of transactions)
   - Subsequent calls: Still acquire write lock, iterate through 10,000 cached entries, sort them, compute percentiles
   - All calls experience severe slowdown
5. Concurrent calls block each other on the write lock
6. API becomes unresponsive, affecting node availability

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: The API server becomes slow or unresponsive, affecting the node's ability to serve requests
- **API crashes**: Repeated calls with large `aggressive_block_history` could exhaust resources and crash the API service

The vulnerability affects:
- Any node with this misconfiguration (API nodes, fullnodes running REST API)
- All users attempting to call `/estimate_gas_price` endpoint
- Potential cascade effects on dependent services (wallets, dapps, indexers)

While this requires misconfiguration by the node operator, the configuration sanitizer exists specifically to prevent such dangerous settings. The omission of `cache_expiration_ms` validation is a security bug in the validation logic.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Misconfiguration likelihood**: Moderate
   - Semantic confusion: `cache_expiration_ms = 0` could be interpreted as "no expiration" rather than "cache always invalid"
   - Operators may intentionally set to 0 to "disable caching" without understanding the consequences
   - Default value is 500ms, but custom configurations are common

2. **Exploitation likelihood**: High once misconfigured
   - `/estimate_gas_price` is a public endpoint requiring no authentication
   - Commonly called by wallets and dapps for transaction fee estimation
   - Any user can trigger the performance degradation

3. **Detection difficulty**: Moderate
   - Issue may go unnoticed initially as first few calls work (using persistent cache)
   - Performance degradation becomes apparent under load
   - Operators may not immediately connect the issue to configuration

## Recommendation

Add validation for `cache_expiration_ms` in the `ConfigSanitizer` implementation to enforce a minimum value:

```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Validate aggressive price takes the most history
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be > low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        // NEW: Validate cache_expiration_ms
        const MIN_CACHE_EXPIRATION_MS: u64 = 100;
        if gas_estimation_config.cache_expiration_ms < MIN_CACHE_EXPIRATION_MS {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "cache_expiration_ms {} must be >= {}ms to prevent cache bypass",
                    gas_estimation_config.cache_expiration_ms,
                    MIN_CACHE_EXPIRATION_MS
                ),
            ));
        }

        Ok(())
    }
}
```

Alternatively, handle `cache_expiration_ms = 0` as a special case meaning "infinite cache" in the `cached_gas_estimation()` function, though explicit validation is clearer and safer.

## Proof of Concept

```rust
#[cfg(test)]
mod test_gas_estimation_performance {
    use super::*;
    use std::time::Instant;

    #[tokio::test]
    async fn test_cache_expiration_zero_performance_degradation() {
        // Create node config with cache_expiration_ms = 0 and large block history
        let mut node_config = NodeConfig::default();
        node_config.api.gas_estimation.enabled = true;
        node_config.api.gas_estimation.cache_expiration_ms = 0; // Vulnerability trigger
        node_config.api.gas_estimation.aggressive_block_history = 1000;
        
        let mut context = new_test_context_with_config(
            "test_cache_expiration_zero",
            node_config,
            false,
            false,
        );

        // Create blocks with transactions
        for _ in 0..200 {
            let account = context.gen_account();
            let txn = context.create_user_account_transaction(&account);
            context.commit_block(&vec![txn]).await;
        }

        // First call - establishes persistent cache
        let start1 = Instant::now();
        context.get("/estimate_gas_price").await;
        let duration1 = start1.elapsed();

        // Second call - should use cache but doesn't due to cache_expiration_ms=0
        let start2 = Instant::now();
        context.get("/estimate_gas_price").await;
        let duration2 = start2.elapsed();

        // Third call - still no caching benefit
        let start3 = Instant::now();
        context.get("/estimate_gas_price").await;
        let duration3 = start3.elapsed();

        println!("Call 1 duration: {:?}", duration1);
        println!("Call 2 duration: {:?}", duration2);
        println!("Call 3 duration: {:?}", duration3);

        // With proper caching, subsequent calls should be much faster
        // With cache_expiration_ms=0, all calls are similarly slow
        // This demonstrates the performance degradation
        
        // Verify that cache is not being used (durations remain high)
        assert!(duration2.as_millis() > 50, "Call 2 should be slow without cache");
        assert!(duration3.as_millis() > 50, "Call 3 should be slow without cache");
    }

    #[tokio::test]
    #[should_panic(expected = "ConfigSanitizerFailed")]
    async fn test_sanitizer_rejects_zero_cache_expiration() {
        // This test should pass once the fix is implemented
        let mut node_config = NodeConfig::default();
        node_config.api.gas_estimation.cache_expiration_ms = 0;
        
        // Sanitizer should reject this configuration
        GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        ).expect("Should fail validation");
    }
}
```

**Notes:**

The vulnerability is exploitable once the misconfiguration is in place. While it requires node operator action to set the dangerous configuration, the config sanitizer's purpose is to prevent exactly this type of dangerous setting. The lack of validation for `cache_expiration_ms` is a security bug that enables severe performance degradation affecting API availability.

### Citations

**File:** config/src/config/gas_estimation_config.rs (L53-95)
```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Validate aggressive price takes the most history
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be > low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        Ok(())
    }
}
```

**File:** api/src/context.rs (L1138-1155)
```rust
    fn cached_gas_estimation<T>(&self, cache: &T, current_epoch: u64) -> Option<GasEstimation>
    where
        T: Deref<Target = GasEstimationCache>,
    {
        if let Some(epoch) = cache.last_updated_epoch {
            if let Some(time) = cache.last_updated_time {
                if let Some(estimation) = cache.estimation {
                    if epoch == current_epoch
                        && (time.elapsed().as_millis() as u64)
                            < self.node_config.api.gas_estimation.cache_expiration_ms
                    {
                        return Some(estimation);
                    }
                }
            }
        }
        None
    }
```

**File:** api/src/context.rs (L1168-1223)
```rust
    fn get_gas_prices_and_used(
        &self,
        start_version: Version,
        limit: u64,
        ledger_version: Version,
        count_majority_use_case: bool,
    ) -> Result<(Vec<(u64, u64)>, Vec<BlockEndInfo>, Option<f32>)> {
        if start_version > ledger_version || limit == 0 {
            return Ok((vec![], vec![], None));
        }

        // This is just an estimation, so we can just skip over errors
        let limit = std::cmp::min(limit, ledger_version - start_version + 1);
        let txns = self.db.get_transaction_iterator(start_version, limit)?;
        let infos = self
            .db
            .get_transaction_info_iterator(start_version, limit)?;

        let mut gas_prices = Vec::new();
        let mut block_end_infos = Vec::new();
        let mut count_by_use_case = HashMap::new();
        for (txn, info) in txns.zip(infos) {
            match txn.as_ref() {
                Ok(Transaction::UserTransaction(txn)) => {
                    if let Ok(info) = info.as_ref() {
                        gas_prices.push((txn.gas_unit_price(), info.gas_used()));
                        if count_majority_use_case {
                            let use_case_key = txn.parse_use_case();
                            *count_by_use_case.entry(use_case_key).or_insert(0) += 1;
                        }
                    }
                },
                Ok(Transaction::BlockEpilogue(txn)) => {
                    if let Some(block_end_info) = txn.try_as_block_end_info() {
                        block_end_infos.push(block_end_info.clone());
                    }
                },
                _ => {},
            }
        }

        let majority_use_case_fraction = if count_majority_use_case {
            count_by_use_case.iter().max_by_key(|(_, v)| *v).and_then(
                |(max_use_case, max_value)| {
                    if let UseCaseKey::ContractAddress(_) = max_use_case {
                        Some(*max_value as f32 / count_by_use_case.values().sum::<u64>() as f32)
                    } else {
                        None
                    }
                },
            )
        } else {
            None
        };
        Ok((gas_prices, block_end_infos, majority_use_case_fraction))
    }
```

**File:** api/src/context.rs (L1325-1359)
```rust
        let max_block_history = config.aggressive_block_history;
        // 1. Get the block metadata txns
        let mut lookup_version = ledger_info.ledger_version.0;
        let mut blocks = vec![];
        // Skip the first block, which may be partial
        if let Ok((first, _, block)) = self.db.get_block_info_by_version(lookup_version) {
            if block.epoch() == epoch {
                lookup_version = first.saturating_sub(1);
            }
        }
        let mut cached_blocks_hit = false;
        for _i in 0..max_block_history {
            if cache
                .min_inclusion_prices
                .contains_key(&(epoch, lookup_version))
            {
                cached_blocks_hit = true;
                break;
            }
            match self.db.get_block_info_by_version(lookup_version) {
                Ok((first, last, block)) => {
                    if block.epoch() != epoch {
                        break;
                    }
                    lookup_version = first.saturating_sub(1);
                    blocks.push((first, last));
                    if lookup_version == 0 {
                        break;
                    }
                },
                Err(_) => {
                    break;
                },
            }
        }
```

**File:** api/src/transactions.rs (L811-826)
```rust
    #[oai(
        path = "/estimate_gas_price",
        method = "get",
        operation_id = "estimate_gas_price",
        tag = "ApiTags::Transactions"
    )]
    async fn estimate_gas_price(&self, accept_type: AcceptType) -> BasicResult<GasEstimation> {
        fail_point_poem("endpoint_encode_submission")?;
        self.context
            .check_api_output_enabled("Estimate gas price", &accept_type)?;

        let context = self.context.clone();
        api_spawn_blocking(move || {
            let latest_ledger_info = context.get_latest_ledger_info()?;
            let gas_estimation = context.estimate_gas_price(&latest_ledger_info)?;
            Self::log_gas_estimation(&gas_estimation);
```
