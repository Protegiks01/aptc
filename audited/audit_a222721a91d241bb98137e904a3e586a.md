# Audit Report

## Title
Private View Functions Exposed Through REST API Breaking Module Encapsulation

## Summary
The Aptos REST API allows external callers to invoke private view functions marked with `#[view]`, violating Move's visibility guarantees and module encapsulation. The API's `find_function()` method does not filter by visibility, and the view function validation only checks for the `#[view]` attribute without enforcing public visibility requirements.

## Finding Description

The vulnerability exists across multiple layers of the view function execution path:

**1. API Function Discovery (Bytecode Layer)**

The `find_function()` method retrieves any function by name regardless of visibility: [1](#0-0) 

This method is used by the API to locate view functions when processing requests: [2](#0-1) 

**2. Compiler Does Not Enforce Public Visibility for View Functions**

The compiler's extended checks validate view function parameters and return types but do NOT enforce that view functions must be public: [3](#0-2) 

**3. Runtime Validation Does Not Check Visibility**

The `validate_view_function()` only verifies the `#[view]` attribute is present but does NOT validate function visibility: [4](#0-3) 

**4. Runtime Visibility Checks Only Apply to Cross-Module Calls**

Visibility enforcement exists for cross-module function calls during execution: [5](#0-4) 

However, these checks do NOT apply to the entry point function being called from the API, as there is no caller context.

**Attack Scenario:**

1. Developer creates a Move module with a private helper function for internal state inspection:
```move
module 0xCAFE::sensitive {
    struct Secret has key { value: u64 }
    
    // Intended for internal use only
    #[view]
    fun get_secret_internal(addr: address): u64 acquires Secret {
        borrow_global<Secret>(addr).value
    }
    
    public fun authorized_query(caller: &signer): u64 acquires Secret {
        // Only authorized callers should access this
        assert!(signer::address_of(caller) == @admin, 1);
        get_secret_internal(@admin)
    }
}
```

2. Attacker discovers the private function name through bytecode inspection or source code review
3. Attacker calls the private function via the REST API: `POST /v1/view` with function identifier `0xCAFE::sensitive::get_secret_internal`
4. The API executes the private function, bypassing the intended access control in `authorized_query()`

## Impact Explanation

**Medium Severity** - This vulnerability breaks the **Access Control** invariant by allowing external access to functions that should only be callable within their defining module.

Impact areas:
- **Module Encapsulation Violation**: Private functions marked with `#[view]` become externally callable, defeating Move's visibility system
- **Information Disclosure**: Sensitive internal state or calculations intended to be hidden can be exposed
- **Access Control Bypass**: Functions that should only be accessible through authorized entry points can be called directly
- **Protocol Trust Violation**: Developers may incorrectly assume private view functions are protected

This does not directly lead to:
- Funds loss or theft (view functions are read-only)
- Consensus violations (no state modifications)
- Network liveness issues

However, it represents a **significant protocol violation** where the Move language's fundamental access control guarantees are not honored by the REST API layer, meeting the Medium severity criteria per the bug bounty program.

## Likelihood Explanation

**High Likelihood**:
- No special privileges required - any attacker with API access can exploit this
- Attack is straightforward: discover function name and call via `/view` endpoint
- Developers may unknowingly create vulnerable code by marking private functions with `#[view]` for internal testing or debugging
- The compiler provides no warning or error for this pattern
- Module bytecode is public, making function discovery trivial

## Recommendation

Implement visibility enforcement at multiple layers:

**1. Compiler-Level Fix (Strongest Protection)**

Add visibility validation in `check_and_record_view_functions()`:

```rust
fn check_and_record_view_functions(&mut self, module: &ModuleEnv) {
    for ref fun in module.get_functions() {
        if !self.has_attribute(fun, VIEW_FUN_ATTRIBUTE) {
            continue;
        }
        
        // NEW: Enforce public visibility for view functions
        if fun.visibility() != Visibility::Public {
            self.env.error(
                &fun.get_id_loc(), 
                "`#[view]` functions must have public visibility"
            );
            continue;
        }
        
        // ... existing checks ...
    }
}
``` [6](#0-5) 

**2. Runtime Validation Fix (Defense in Depth)**

Add visibility check in `validate_view_function()`:

```rust
pub(crate) fn validate_view_function(
    // ... existing params ...
) -> PartialVMResult<Vec<Vec<u8>>> {
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }
    
    // NEW: Check function visibility
    if !func.is_public() {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("view function must be public".to_string()),
        );
    }
    
    // ... rest of validation ...
}
``` [7](#0-6) 

**3. API-Level Fix (Additional Safety)**

Filter by visibility in `find_function()` or add check in `convert_view_function()`:

```rust
pub fn convert_view_function(&self, view_request: ViewRequest) -> Result<ViewFunction> {
    // ... existing code ...
    let func = code
        .find_function(function.name.0.as_ident_str())
        .ok_or_else(|| format_err!("could not find view function by {}", function))?;
    
    // NEW: Verify function is public
    if func.visibility != MoveFunctionVisibility::Public {
        bail!("view function must be public, but {} has {:?} visibility", 
              function, func.visibility);
    }
    
    // ... rest of conversion ...
}
``` [8](#0-7) 

## Proof of Concept

**Step 1: Create vulnerable Move module**

```move
module 0xCAFE::vuln_demo {
    use std::signer;
    
    struct AdminConfig has key {
        admin: address,
        secret_value: u64
    }
    
    // This private view function should NOT be callable externally
    #[view]
    fun get_secret_value(addr: address): u64 acquires AdminConfig {
        borrow_global<AdminConfig>(addr).secret_value
    }
    
    // Only this public function should allow access
    public entry fun authorized_get(caller: &signer) acquires AdminConfig {
        let config = borrow_global<AdminConfig>(@0xCAFE);
        assert!(signer::address_of(caller) == config.admin, 1);
        // Use get_secret_value internally
        let _ = get_secret_value(@0xCAFE);
    }
}
```

**Step 2: Compile and publish the module**

The compiler will accept this code without error, as it does not validate view function visibility.

**Step 3: Call private view function via REST API**

```bash
curl -X POST https://fullnode.mainnet.aptoslabs.com/v1/view \
  -H "Content-Type: application/json" \
  -d '{
    "function": "0xCAFE::vuln_demo::get_secret_value",
    "type_arguments": [],
    "arguments": ["0xCAFE"]
  }'
```

**Expected (Secure) Behavior**: Request should fail with "function not found" or "function not public"

**Actual (Vulnerable) Behavior**: Request succeeds and returns the secret value, bypassing the intended access control in `authorized_get()`

**Step 4: Verification**

The private function `get_secret_value` is successfully invoked despite having private visibility, confirming the vulnerability.

## Notes

This vulnerability affects all Aptos nodes running the current codebase and impacts any Move modules that use private view functions for internal purposes. The fix should be implemented at the compiler level (preferred) with additional runtime checks for defense in depth. Existing modules with private view functions should be identified and either updated to use public visibility or have the `#[view]` attribute removed.

### Citations

**File:** api/types/src/bytecode.rs (L263-271)
```rust
    fn find_function(&self, name: &IdentStr) -> Option<MoveFunction> {
        self.function_defs
            .iter()
            .find(|def| {
                let fhandle = ModuleAccess::function_handle_at(self, def.function);
                ModuleAccess::identifier_at(self, fhandle.name) == name
            })
            .map(|def| self.new_move_function(def))
    }
```

**File:** api/types/src/convert.rs (L1024-1035)
```rust
    pub fn convert_view_function(&self, view_request: ViewRequest) -> Result<ViewFunction> {
        let ViewRequest {
            function,
            type_arguments,
            arguments,
        } = view_request;

        let module = function.module.clone();
        let code = self.inner.view_existing_module(&module.clone().into())? as Arc<dyn Bytecode>;
        let func = code
            .find_function(function.name.0.as_ident_str())
            .ok_or_else(|| format_err!("could not find view function by {}", function))?;
```

**File:** aptos-move/framework/src/extended_checks.rs (L689-741)
```rust
    fn check_and_record_view_functions(&mut self, module: &ModuleEnv) {
        for ref fun in module.get_functions() {
            if !self.has_attribute(fun, VIEW_FUN_ATTRIBUTE) {
                continue;
            }
            self.check_transaction_args(&fun.get_parameters());
            if fun.get_return_count() == 0 {
                self.env
                    .error(&fun.get_id_loc(), "`#[view]` function must return values")
            }

            fun.get_parameters()
                .iter()
                .for_each(
                    |Parameter(_sym, parameter_type, param_loc)| match parameter_type {
                        Type::Primitive(inner) => {
                            if inner == &PrimitiveType::Signer {
                                self.env.error(
                                    param_loc,
                                    "`#[view]` function cannot use a `signer` parameter",
                                )
                            }
                        },
                        Type::Reference(mutability, inner) => {
                            if let Type::Primitive(inner) = inner.as_ref() {
                                if inner == &PrimitiveType::Signer
                                // Avoid a redundant error message for `&mut signer`, which is
                                // always disallowed for transaction entries, not just for
                                // `#[view]`.
                                    && mutability == &ReferenceKind::Immutable
                                {
                                    self.env.error(
                                        param_loc,
                                        "`#[view]` function cannot use the `&signer` parameter",
                                    )
                                }
                            }
                        },
                        _ => (),
                    },
                );

            // Remember the runtime info that this is a view function
            let module_id = self.get_runtime_module_id(module);
            self.output
                .entry(module_id)
                .or_default()
                .fun_attributes
                .entry(fun.get_simple_name_string().to_string())
                .or_default()
                .push(KnownAttribute::view_function());
        }
    }
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L35-53)
```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // Must be marked as view function.
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L945-981)
```rust
    fn check_cross_module_regular_call_visibility(
        caller: &LoadedFunction,
        callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if callee.is_private() {
            let msg = format!(
                "Function {}::{} cannot be called because it is private",
                callee.module_or_script_id(),
                callee.name()
            );
            return Err(
                PartialVMError::new_invariant_violation(msg).with_sub_status(EPARANOID_FAILURE)
            );
        }

        if callee.is_friend() {
            let callee_module = callee.owner_as_module().map_err(|err| err.to_partial())?;
            if !caller
                .module_id()
                .is_some_and(|id| callee_module.friends.contains(id))
            {
                let msg = format!(
                    "Function {}::{} cannot be called because it has friend visibility, but {} \
                     is not {}'s friend",
                    callee.module_or_script_id(),
                    callee.name(),
                    caller.module_or_script_id(),
                    callee.module_or_script_id()
                );
                return Err(
                    PartialVMError::new_invariant_violation(msg).with_sub_status(EPARANOID_FAILURE)
                );
            }
        }

        Ok(())
    }
```
