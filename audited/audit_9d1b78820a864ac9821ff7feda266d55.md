# Audit Report

## Title
EventKey Collision in V2-to-V1 Translation Causes Indexer Corruption

## Summary
The event indexing system allows V1 events and translated V2 events to silently overwrite each other in the `EventByKeySchema` index when they share the same `(EventKey, sequence_number)` tuple, causing indexer corruption and event data loss.

## Finding Description

The Aptos event system maintains two formats: V1 events (legacy, with EventHandles) and V2 events (module events). For backward compatibility, the indexer translates V2 events to V1 format. [1](#0-0) 

Both native V1 events and translated V2 events are indexed in `EventByKeySchema` using `(EventKey, sequence_number)` as the key. [2](#0-1) 

The vulnerability occurs in the indexer's batch processing where events are indexed sequentially without collision detection. [3](#0-2) 

The sequence number management for translated V2 events is independent of V1 events. [4](#0-3)  When the translator reads the default sequence number from an on-chain resource (e.g., `CoinStore.deposit_events().count()`), it can assign sequence numbers that collide with existing V1 events.

**Attack Scenario:**
1. Account has `CoinStore` with `deposit_events` EventHandle at `EventKey(2, account_addr)`, counter=10
2. Transaction emits V1 event via deprecated `emit_event()` → indexed as `(EventKey(2, addr), seq=10)`
3. Later transaction emits V2 `CoinDeposit` event
4. Translator reads `CoinStore`, sees counter=10, assigns seq=10 to translated event
5. Translated V2 event overwrites V1 event in index → first event is lost

The `CoinStore` struct retains V1 EventHandles for backward compatibility. [5](#0-4) 

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The indexer database becomes corrupted with missing or incorrect event mappings
- External indexers, wallets, and analytics services rely on `EventByKeySchema` for event queries
- When collisions occur, legitimate events become invisible to queries, causing:
  - Wallets displaying incorrect transaction history
  - DApps processing incomplete event data
  - Off-chain systems missing critical state updates

The impact doesn't reach High/Critical because it doesn't affect consensus, validator operation, or directly cause fund loss.

## Likelihood Explanation

Likelihood is **Low to Medium**:
- Requires mixed usage of deprecated V1 events and modern V2 events
- Most current code paths use only V2 events [6](#0-5) 
- However, deprecated `emit_event()` remains public and callable [7](#0-6) 
- Legacy contracts or custom implementations may still emit V1 events
- The sequence number collision becomes more likely as event counters increase over time

## Recommendation

Add collision detection to the event indexing logic:

```rust
// In db_indexer.rs process_a_batch()
// Before indexing translated V2 event:
if batch.contains::<EventByKeySchema>(&(key, sequence_number))? {
    // Log warning and increment sequence number
    warn!("EventKey collision detected for {:?} seq {}, reassigning", 
          key, sequence_number);
    sequence_number = self.event_v2_translation_engine
        .get_next_available_sequence_number(&key, sequence_number)?;
}
```

Additionally:
1. Maintain separate index namespaces for native V1 vs translated V2 events
2. Implement sequence number synchronization between V1 EventHandle counters and V2 translation cache
3. Add validation in `EventByKeySchema::put()` to detect overwrites
4. Deprecate and phase out V1 event emission completely

## Proof of Concept

```move
// Move test demonstrating collision scenario
#[test(account = @0x123)]
fun test_event_collision(account: &signer) {
    use aptos_framework::coin;
    use aptos_framework::event;
    
    // Setup: account has CoinStore with EventHandle
    coin::register<AptosCoin>(account);
    
    // Emit V1 event using deprecated API (if accessible)
    let handle = ...; // Get reference to deposit_events handle
    event::emit_event(&mut handle, DepositEvent { amount: 100 });
    
    // Emit V2 event
    coin::deposit(@0x123, coin::withdraw<AptosCoin>(account, 50));
    
    // Both events should be indexed, but collision may cause loss
    // Query indexer: only one event visible at that sequence number
}
```

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L60-66)
```rust
pub trait EventV2Translator: Send + Sync {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1>;
}
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer_schemas/src/schema/event_by_key/mod.rs (L23-29)
```rust
define_pub_schema!(EventByKeySchema, Key, Value, EVENT_BY_KEY_CF_NAME);

type SeqNum = u64;
type Key = (EventKey, SeqNum);

type Index = u64;
type Value = (Version, Index);
```

**File:** storage/indexer/src/db_indexer.rs (L432-487)
```rust
            if self.indexer_db.event_enabled() {
                events.iter().enumerate().try_for_each(|(idx, event)| {
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
                    }
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
                    Ok::<(), AptosDbError>(())
                })?;
            }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L149-154)
```text
    struct CoinStore<phantom CoinType> has key {
        coin: Coin<CoinType>,
        frozen: bool,
        deposit_events: EventHandle<DepositEvent>,
        withdraw_events: EventHandle<WithdrawEvent>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L914-918)
```text
    public fun deposit<CoinType>(
        account_addr: address, coin: Coin<CoinType>
    ) acquires CoinConversionMap, CoinInfo {
        primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L52-60)
```text
    #[deprecated]
    /// Emit an event with payload `msg` by using `handle_ref`'s key and counter.
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```
