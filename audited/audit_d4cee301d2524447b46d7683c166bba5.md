# Audit Report

## Title
Race Condition in Consensus Observer: Double Execution of Ordered Blocks via Shared Arc<PipelinedBlock> State Mutation

## Summary
The `ObservedOrderedBlock` enum derives `Clone` and wraps `Arc<PipelinedBlock>` instances with interior mutable state. When cloned instances are processed through different code paths, the same `PipelinedBlock` instances have their pipeline futures, transaction channels, and abort handles overwritten, causing the original pipeline tasks to become orphaned and unabortable. This leads to resource leaks, duplicate block execution, and potential consensus divergence.

## Finding Description

The vulnerability exists in the consensus observer's block processing flow. The `ObservedOrderedBlock` enum derives `Clone` [1](#0-0)  and contains `OrderedBlock` which stores `Vec<Arc<PipelinedBlock>>` [2](#0-1) .

The `PipelinedBlock` struct contains multiple `Mutex` fields for pipeline state [3](#0-2) , providing interior mutability through shared references. When blocks are processed, these fields are set via methods that unconditionally overwrite existing values [4](#0-3) .

**Attack Scenario:**

1. In `process_ordered_block`, when a block arrives and state sync is NOT active, the block is stored (as a clone) AND finalized immediately [5](#0-4) . The `finalize_ordered_block` method calls `build_for_observer` which sets pipeline futures/tx/abort handles on the shared `Arc<PipelinedBlock>` instances [6](#0-5) .

2. Later, when `process_commit_sync_notification` is called after state sync completes, it retrieves ALL ordered blocks from the store [7](#0-6) .

3. For each retrieved block (including previously finalized ones), `consume_ordered_block()` is called followed by `finalize_ordered_block()` again. This second call to `build_for_observer` **overwrites** the pipeline state on the same shared `Arc<PipelinedBlock>` instances.

4. The original pipeline abort handles are lost when overwritten, making the first set of pipeline tasks unabortable. Both sets of tasks attempt to execute the same blocks concurrently.

This breaks the **Deterministic Execution** invariant - the same blocks should not be executed multiple times concurrently, potentially producing different state results. It also violates **Resource Limits** - orphaned tasks consume unbounded resources.

## Impact Explanation

**High Severity** - This vulnerability causes:

1. **Resource Exhaustion**: Orphaned pipeline tasks cannot be aborted and continue consuming CPU, memory, and network resources indefinitely. A malicious consensus publisher can trigger this repeatedly by controlling the timing of ordered block messages relative to state sync operations.

2. **Duplicate Block Execution**: The same blocks are executed twice through separate pipeline tasks, wasting computational resources and potentially causing state inconsistencies if execution results differ due to timing or non-deterministic factors.

3. **Validator Node Slowdowns**: The accumulation of orphaned tasks degrades node performance, potentially causing the observer to fall behind the network, miss consensus messages, and fail to maintain chain synchronization.

4. **Potential Consensus Divergence**: If the two execution attempts produce different state compute results due to race conditions in shared state access, this could cause the observer to commit a state different from the canonical chain, requiring manual intervention.

This qualifies as **High Severity** per the bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**High Likelihood** - This vulnerability triggers automatically in normal operations whenever:

1. An ordered block arrives while state sync is NOT active (common case)
2. The block gets finalized immediately (line 791)
3. Before the block is committed and removed from the store, state sync is triggered for any reason
4. State sync completes and `process_commit_sync_notification` processes all stored blocks again

This sequence occurs naturally during epoch transitions, network partitions, or any scenario where an observer temporarily falls behind and needs to sync. The vulnerability does not require any attacker action beyond being able to publish ordered blocks (which is the normal function of consensus validators).

A malicious consensus publisher with control over block timing could deliberately trigger this by:
- Sending ordered blocks
- Triggering commit sync operations
- Exploiting the timing window before blocks are removed from the store

## Recommendation

**Immediate Fix**: Add a check in `build_for_observer` to prevent overwriting existing pipeline state:

```rust
fn build(
    &self,
    pipelined_block: &PipelinedBlock,
    parent_futs: PipelineFutures,
    block_store_callback: Box<
        dyn FnOnce(WrappedLedgerInfo, LedgerInfoWithSignatures) + Send + Sync,
    >,
    observer_enabled: bool,
) {
    // Check if pipeline futures already exist
    if pipelined_block.pipeline_futs().is_some() {
        warn!(
            "Pipeline futures already set for block {} {} {}, skipping rebuild",
            pipelined_block.id(),
            pipelined_block.epoch(),
            pipelined_block.round()
        );
        return;
    }
    
    let (futs, tx, abort_handles) = self.build_internal(
        parent_futs,
        Arc::new(pipelined_block.block().clone()),
        block_store_callback,
        observer_enabled,
    );
    pipelined_block.set_pipeline_futs(futs);
    pipelined_block.set_pipeline_tx(tx);
    pipelined_block.set_pipeline_abort_handles(abort_handles);
}
```

**Long-term Fix**: Refactor the design to avoid cloning `ObservedOrderedBlock` with shared mutable state. Consider:
1. Using unique ownership instead of `Arc` where possible
2. Removing blocks from the store immediately after finalization
3. Adding explicit lifecycle management to prevent double-processing
4. Using `OnceCell` instead of `Mutex<Option<T>>` for pipeline state to enforce single initialization

## Proof of Concept

```rust
// Reproduction steps (conceptual - requires full node environment):

#[tokio::test]
async fn test_double_execution_race_condition() {
    // 1. Setup consensus observer with mock execution client
    let mut observer = create_test_consensus_observer();
    
    // 2. Create and send an ordered block message
    let ordered_block = create_test_ordered_block(epoch=1, round=10);
    let observed_block = ObservedOrderedBlock::new(ordered_block.clone());
    
    // 3. Process the ordered block (not during state sync)
    // This will store the block AND finalize it immediately
    observer.process_ordered_block_message(observed_block, peer_id).await;
    
    // 4. Verify pipeline state is set on the PipelinedBlock
    let block = ordered_block.first_block();
    assert!(block.pipeline_futs().is_some());
    let original_futs = block.pipeline_futs().unwrap();
    
    // 5. Simulate state sync completing and processing commit notification
    // This retrieves ALL ordered blocks (including the already-finalized one)
    observer.process_commit_sync_notification(commit_decision).await;
    
    // 6. Verify the pipeline state was overwritten
    let new_futs = block.pipeline_futs().unwrap();
    assert_ne!(
        Arc::as_ptr(&original_futs.prepare_fut), 
        Arc::as_ptr(&new_futs.prepare_fut)
    ); // Different future instances
    
    // 7. Original pipeline tasks are now orphaned and unabortable
    // Both sets of tasks will attempt to execute the same blocks
}
```

## Notes

The root cause is the combination of:
1. `Clone` derivation on `ObservedOrderedBlock` allowing multiple owned copies
2. Internal use of `Arc<PipelinedBlock>` causing sharing of the underlying block instances
3. Interior mutability via `Mutex` fields in `PipelinedBlock` 
4. Unconditional overwriting of pipeline state without checking if already initialized
5. Multiple code paths (`process_ordered_block` line 791 and `process_commit_sync_notification` line 1055) that can finalize the same blocks

The vulnerability is exploitable without validator access - any network peer acting as a consensus publisher can trigger this through normal protocol operations combined with timing manipulation.

### Citations

**File:** consensus/src/consensus_observer/observer/execution_pool.rs (L12-16)
```rust
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ObservedOrderedBlock {
    Ordered(OrderedBlock),
    OrderedWithWindow(OrderedBlockWithWindow),
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L181-184)
```rust
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L198-217)
```rust
pub struct PipelinedBlock {
    /// Block data that cannot be regenerated.
    block: Block,
    /// A window of blocks that are needed for execution with the execution pool, EXCLUDING the current block
    block_window: OrderedBlockWindow,
    /// Input transactions in the order of execution. DEPRECATED stay for serialization compatibility.
    input_transactions: Vec<SignedTransaction>,
    /// The state_compute_result is calculated for all the pending blocks prior to insertion to
    /// the tree. The execution results are not persisted: they're recalculated again for the
    /// pending blocks upon restart.
    state_compute_result: Mutex<StateComputeResult>,
    randomness: OnceCell<Randomness>,
    pipeline_insertion_time: OnceCell<Instant>,
    execution_summary: OnceCell<ExecutionSummary>,
    /// pipeline related fields
    pipeline_futs: Mutex<Option<PipelineFutures>>,
    pipeline_tx: Mutex<Option<PipelineInputTx>>,
    pipeline_abort_handle: Mutex<Option<Vec<AbortHandle>>>,
    block_qc: Mutex<Option<Arc<QuorumCert>>>,
}
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L512-522)
```rust
    pub fn set_pipeline_futs(&self, pipeline_futures: PipelineFutures) {
        *self.pipeline_futs.lock() = Some(pipeline_futures);
    }

    pub fn set_pipeline_tx(&self, pipeline_tx: PipelineInputTx) {
        *self.pipeline_tx.lock() = Some(pipeline_tx);
    }

    pub fn set_pipeline_abort_handles(&self, abort_handles: Vec<AbortHandle>) {
        *self.pipeline_abort_handle.lock() = Some(abort_handles);
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L785-792)
```rust
            self.observer_block_data
                .lock()
                .insert_ordered_block(observed_ordered_block.clone());

            // If state sync is not syncing to a commit, finalize the ordered blocks
            if !self.state_sync_manager.is_syncing_to_commit() {
                self.finalize_ordered_block(ordered_block).await;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1051-1061)
```rust
        let all_ordered_blocks = self.observer_block_data.lock().get_all_ordered_blocks();
        for (_, (observed_ordered_block, commit_decision)) in all_ordered_blocks {
            // Finalize the ordered block
            let ordered_block = observed_ordered_block.consume_ordered_block();
            self.finalize_ordered_block(ordered_block).await;

            // If a commit decision is available, forward it to the execution pipeline
            if let Some(commit_decision) = commit_decision {
                self.forward_commit_decision(commit_decision.clone());
            }
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L407-425)
```rust
    fn build(
        &self,
        pipelined_block: &PipelinedBlock,
        parent_futs: PipelineFutures,
        block_store_callback: Box<
            dyn FnOnce(WrappedLedgerInfo, LedgerInfoWithSignatures) + Send + Sync,
        >,
        observer_enabled: bool,
    ) {
        let (futs, tx, abort_handles) = self.build_internal(
            parent_futs,
            Arc::new(pipelined_block.block().clone()),
            block_store_callback,
            observer_enabled,
        );
        pipelined_block.set_pipeline_futs(futs);
        pipelined_block.set_pipeline_tx(tx);
        pipelined_block.set_pipeline_abort_handles(abort_handles);
    }
```
