# Audit Report

## Title
Control Character Injection in DNS Name Validation Enables HTTP Proxy Header Injection

## Summary
The `DnsName::validate()` function in `types/src/network_address/mod.rs` does not reject ASCII control characters (including null bytes, newlines, carriage returns), despite the fuzzing implementation explicitly excluding them. This allows injection of control characters into DNS names, which can lead to HTTP request smuggling when nodes connect via HTTP proxies. [1](#0-0) 

## Finding Description

The `DnsName` validation only checks that input is ASCII using `s.is_ascii()`, which accepts all ASCII characters in the range 0x00-0x7F, including control characters. [2](#0-1) 

However, the `Arbitrary` implementation for property-based testing explicitly excludes control characters using the regex pattern `r"[^/\pC]{1,255}"`, indicating they should not be allowed. [3](#0-2) 

When nodes connect via HTTP proxies, the DNS name is formatted directly into an HTTP CONNECT request without sanitization: [4](#0-3) 

An attacker providing a network address with embedded newlines (CR/LF: `\r\n`) in the DNS name can inject arbitrary HTTP headers or smuggle additional HTTP requests through the proxy.

**Attack Example:**
```
/dns/malicious.com\r\nX-Evil-Header: injected\r\n\r\n/tcp/6180/noise-ik/<pubkey>/handshake/0
```

This produces:
```
CONNECT malicious.com
X-Evil-Header: injected

:6180 HTTP/1.0

```

The validation in `validate_address()` accepts this malicious address because it passes both `NetworkAddress::from_str()` and `is_aptosnet_addr()` checks. [5](#0-4) 

## Impact Explanation

This vulnerability is assessed as **Medium severity** based on:

1. **HTTP Request Smuggling**: Attackers can inject arbitrary HTTP headers into proxy CONNECT requests, potentially bypassing proxy access controls or authentication mechanisms
2. **Log Injection**: Control characters in DNS names propagate to system logs, enabling log poisoning attacks that could hide malicious activity or inject false entries
3. **Limited Scope**: Exploitation requires either:
   - Attacker control over seed peer configuration (limited to node operators in most cases)
   - Command-line access to network-checker tool
   - Node configured to use HTTP proxy (not default configuration)

While this doesn't directly cause "Limited funds loss" or "State inconsistencies requiring intervention" per the strict bug bounty categories, it represents a security control bypass that could be chained with other attacks.

## Likelihood Explanation

**Likelihood: Low-Medium**

- The vulnerability exists in production code and is easily exploitable once triggered
- However, exploitation requires specific preconditions:
  - Node must use HTTP proxy configuration (opt-in feature)
  - Attacker must control network address input (seed peers or CLI arguments)
  - Seed peer addresses are typically controlled by trusted node operators
- The network-checker tool is more accessible but is diagnostic, not consensus-critical
- Most nodes don't use HTTP proxies, limiting the attack surface

## Recommendation

Add explicit control character validation to the `DnsName::validate()` function to match the fuzzing implementation's intent:

```rust
fn validate(s: &str) -> Result<(), ParseError> {
    if s.is_empty() {
        Err(ParseError::EmptyDnsNameString)
    } else if s.len() > MAX_DNS_NAME_SIZE {
        Err(ParseError::DnsNameTooLong(s.len()))
    } else if s.contains('/') {
        Err(ParseError::InvalidDnsNameCharacter)
    } else if !s.is_ascii() {
        Err(ParseError::DnsNameNonASCII(s.into()))
    } else if s.chars().any(|c| c.is_ascii_control()) {
        Err(ParseError::DnsNameContainsControlCharacters)
    } else {
        Ok(())
    }
}
```

Add corresponding error variant:
```rust
#[error("dns name contains control characters")]
DnsNameContainsControlCharacters,
```

## Proof of Concept

```rust
// File: test_control_char_injection.rs
use aptos_types::network_address::NetworkAddress;
use std::str::FromStr;

#[test]
fn test_control_character_injection() {
    // Test that control characters are currently accepted (vulnerability)
    let malicious_addr = "/dns/evil.com\r\nX-Injected: malicious\r\n\r\n/tcp/6180/noise-ik/080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0";
    
    let result = NetworkAddress::from_str(malicious_addr);
    
    // Currently this succeeds (vulnerability)
    assert!(result.is_ok(), "Control characters should be rejected but are accepted");
    
    let addr = result.unwrap();
    assert!(addr.is_aptosnet_addr(), "Malicious address passes validation");
    
    // When used with HTTP proxy, this would result in header injection
    println!("Malicious address accepted: {}", addr);
}

#[test]
fn test_null_byte_injection() {
    let null_byte_addr = "/dns/malicious.com\x00legitimate.com/tcp/6180/noise-ik/080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0";
    
    let result = NetworkAddress::from_str(null_byte_addr);
    
    // Null bytes are ASCII and currently pass validation
    assert!(result.is_ok(), "Null bytes should be rejected");
}
```

To demonstrate HTTP injection impact, deploy a node with HTTP proxy configuration and provide the malicious seed peer address. The proxy logs will show the injected headers in the CONNECT request.

### Citations

**File:** types/src/network_address/mod.rs (L667-679)
```rust
    fn validate(s: &str) -> Result<(), ParseError> {
        if s.is_empty() {
            Err(ParseError::EmptyDnsNameString)
        } else if s.len() > MAX_DNS_NAME_SIZE {
            Err(ParseError::DnsNameTooLong(s.len()))
        } else if s.contains('/') {
            Err(ParseError::InvalidDnsNameCharacter)
        } else if !s.is_ascii() {
            Err(ParseError::DnsNameNonASCII(s.into()))
        } else {
            Ok(())
        }
    }
```

**File:** types/src/network_address/mod.rs (L736-741)
```rust
    fn arbitrary_with(_args: Self::Parameters) -> Self::Strategy {
        // generate arbitrary unicode strings
        // + without '/'
        // + without control characters (so we can print them easily)
        // + between 1-255 bytes in length
        r"[^/\pC]{1,255}"
```

**File:** network/netcore/src/transport/tcp.rs (L269-271)
```rust
        stream
            .write_all(&format!("CONNECT {0}:{1} HTTP/1.0\r\n\r\n", host, port).into_bytes())
            .await?;
```

**File:** crates/aptos-network-checker/src/args.rs (L62-68)
```rust
pub fn validate_address(address: &str) -> Result<NetworkAddress> {
    let address = NetworkAddress::from_str(address)
        .with_context(|| format!("Invalid address: {}", address))?;
    if !address.is_aptosnet_addr() {
        bail!("Address must have IP / DNS, TCP, noise key, and handshake")
    }
    Ok(address)
```
