# Audit Report

## Title
Empty Validator Set Vulnerability via Minimum Stake Filtering in Epoch Transition

## Summary
The `on_new_epoch()` function in the staking module can result in an empty validator set if all validators' voting power drops below the minimum stake threshold, causing total network halt. Additionally, if `total_voting_power` reaches zero, the voting power increase limit is bypassed, allowing unlimited validators to join in a single epoch.

## Finding Description

The epoch change mechanism's `verify()` function does not enforce Sybil resistance directlyâ€”it only validates cryptographic signatures and epoch chain integrity. [1](#0-0)  Sybil resistance is delegated to the staking layer.

However, a critical flaw exists in the validator set management during epoch transitions. In `on_new_epoch()`, validators are filtered based on minimum stake requirements, but there is **no check ensuring at least one validator remains active**. [2](#0-1) 

The filtering logic removes validators with `voting_power < minimum_stake`, but if ALL validators fall below this threshold, the `next_epoch_validators` vector remains empty and `total_voting_power` becomes 0. The filtered validator set is then unconditionally assigned as the active set. [3](#0-2) 

Critically, the voting power increase limit enforcement contains a conditional bypass: when `total_voting_power == 0`, the limit check is entirely skipped, allowing unlimited voting power to join in a single epoch. [4](#0-3) 

While explicit validator leaving is protected by `ELAST_VALIDATOR` check, [5](#0-4)  the automatic filtering in `on_new_epoch()` has no equivalent protection.

The formal specifications require `on_new_epoch` to not abort, [6](#0-5)  but do not require a non-empty validator set. The validator set validity check verifies initialization and indices but not set size. [7](#0-6) 

The reconfiguration layer calls `stake::on_new_epoch()` without subsequent validation of the resulting validator set. [8](#0-7) 

When an empty validator set is passed to the consensus layer, `ValidatorVerifier::new()` sets `quorum_voting_power` to 0, effectively creating a verifier that cannot validate any blocks. [9](#0-8) 

## Impact Explanation

**Critical Severity** - This vulnerability can cause:

1. **Total Loss of Liveness**: With zero validators and `quorum_voting_power` set to 0, the network cannot produce blocks or reach consensus. No validator can propose blocks, and no quorum can be formed for block finalization. This requires emergency intervention or hard fork to recover, matching the Critical severity criteria of "Total loss of liveness/network availability" (Bug Bounty Category #4).

2. **Voting Power Increase Limit Bypass**: If the network enters the zero-validator state, the voting power increase limit enforcement is bypassed, allowing unlimited validators to join in a single epoch. This could enable an attacker to immediately gain >1/3 or >2/3 voting power, compromising BFT safety guarantees and matching "Consensus/Safety violations" (Bug Bounty Category #2).

## Likelihood Explanation

**Medium to Low Likelihood** - Requires specific conditions:

- All validators' stake must simultaneously drop below `minimum_stake` through stake unlocking, governance-increased minimum stake threshold, or exploitation of other stake calculation bugs
- More likely in testnets or early network stages with few validators  
- Natural economic incentives discourage validators from reducing stake below minimum
- However, configuration errors (e.g., governance miscalculating impact of minimum stake increase) or lack of coordination during threshold changes could trigger this state

The vulnerability exists in production code and has catastrophic consequences, but requires unusual circumstances to trigger.

## Recommendation

Add a safety check in `on_new_epoch()` after validator filtering to ensure at least one validator remains:

```move
// After line 1399, before line 1401:
assert!(vector::length(&next_epoch_validators) > 0, error::invalid_state(ENO_ACTIVE_VALIDATORS));
```

Additionally, add a check in the voting power increase limit enforcement to prevent the bypass:

```move
// Replace lines 1864-1869 with:
assert!(
    validator_set.total_voting_power > 0,
    error::invalid_state(ENO_ACTIVE_VALIDATORS)
);
assert!(
    validator_set.total_joining_power <= validator_set.total_voting_power * voting_power_increase_limit / 100,
    error::invalid_argument(EVOTING_POWER_INCREASE_EXCEEDS_LIMIT),
);
```

Define the new error constant:
```move
const ENO_ACTIVE_VALIDATORS: u64 = 15;
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x10001, location = aptos_framework::reconfiguration)]
fun test_empty_validator_set_vulnerability(aptos_framework: &signer) {
    // Setup: Initialize staking with validators
    stake::initialize_validator_set(aptos_framework, 100, 10000, 1000000, true, 1, 100, 1000000);
    
    // Add validators with minimum stake
    let validator1 = create_validator_with_min_stake();
    let validator2 = create_validator_with_min_stake();
    
    // Governance increases minimum stake significantly
    staking_config::update_required_stake(aptos_framework, 10000000, 100000000);
    
    // Trigger epoch change - all validators now below minimum
    // This will create an empty validator set, causing network halt
    reconfiguration::reconfigure();
    
    // Network is now halted - no validators can produce blocks
}
```

## Notes

This vulnerability represents a missing safety invariant in the staking protocol. While the likelihood is reduced by economic incentives and coordination mechanisms, the absence of a fundamental safety check (ensuring at least one validator remains active) creates a single point of failure that could result in total network unavailability. The formal verification specifications should also be updated to include this invariant.

### Citations

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1402)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1857-1869)
```text
    fun update_voting_power_increase(increase_amount: u64) acquires ValidatorSet {
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let voting_power_increase_limit =
            (staking_config::get_voting_power_increase_limit(&staking_config::get()) as u128);
        validator_set.total_joining_power = validator_set.total_joining_power + (increase_amount as u128);

        // Only validator voting power increase if the current validator set's voting power > 0.
        if (validator_set.total_voting_power > 0) {
            assert!(
                validator_set.total_joining_power <= validator_set.total_voting_power * voting_power_increase_limit / 100,
                error::invalid_argument(EVOTING_POWER_INCREASE_EXCEEDS_LIMIT),
            );
        }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L108-115)
```text
    spec fun validator_set_is_valid_impl(validator_set: ValidatorSet): bool {
        spec_validators_are_initialized(validator_set.active_validators) &&
            spec_validators_are_initialized(validator_set.pending_inactive) &&
            spec_validators_are_initialized(validator_set.pending_active) &&
            spec_validator_indices_are_valid(validator_set.active_validators) &&
            spec_validator_indices_are_valid(validator_set.pending_inactive)
            && spec_validator_indices_active_pending_inactive(validator_set)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L453-465)
```text
    spec on_new_epoch {
        pragma verify = false; // TODO: set because of timeout (property proved).
        pragma disable_invariants_in_body;
        // The following resource requirement cannot be discharged by the global
        // invariants because this function is called during genesis.
        include ResourceRequirement;
        include GetReconfigStartTimeRequirement;
        include staking_config::StakingRewardsConfigRequirement;
        include aptos_framework::aptos_coin::ExistsAptosCoin;
        // This function should never abort.
        /// [high-level-req-4]
        aborts_if false;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L133-134)
```text
        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```
