# Audit Report

## Title
Memory Accounting State Pollution in Non-Generic Native Function Calls After Table/Event Operations

## Summary
The `should_leak_memory_for_native` flag in `MemoryTrackedGasMeterImpl` persists across multiple function calls within a transaction, causing non-generic native functions to incorrectly skip memory release when called after generic table/event native functions. This leads to inflated memory accounting and potential spurious `MEMORY_LIMIT_EXCEEDED` transaction failures.

## Finding Description
The memory tracker maintains a boolean flag `should_leak_memory_for_native` that controls whether argument memory is released before native function execution. This flag is set in `charge_call_generic()` based on the module being called (true for table/event modules, false otherwise), but is never updated when `charge_call()` is invoked for non-generic function calls. [1](#0-0) 

The flag is initialized to false when the gas meter is created: [2](#0-1) 

In `charge_call_generic()`, the flag is set based on the module ID: [3](#0-2) 

However, `charge_call()` for non-generic calls is delegated to the base meter and never touches this flag: [4](#0-3) 

The flag is then used in `charge_native_function_before_execution()` to decide whether to release argument memory: [5](#0-4) 

**Execution Flow Demonstrating the Bug:**

The Move VM interpreter handles function calls: [6](#0-5) 

For generic calls: [7](#0-6) 

Both call paths invoke `call_native()`, which calls `charge_native_function_before_execution()`: [8](#0-7) 

**Attack Scenario:**
1. Transaction calls `table::add<K, V>(...)` (generic table native)
   - `charge_call_generic()` sets `should_leak_memory_for_native = true`
   - Argument memory NOT released (intentional for table operations)

2. Same transaction calls `aptos_std::aptos_hash::sip_hash(bytes)` (non-generic native)
   - `charge_call()` invoked (does NOT modify the flag)
   - Flag remains `true` from previous call
   - `charge_native_function_before_execution()` does NOT release argument memory (INCORRECT!)
   - Memory accounting inflated by size of `bytes` argument [9](#0-8) 

3. Repeated non-generic native calls accumulate inflated memory accounting
4. Transaction hits the memory quota limit prematurely: [10](#0-9) 

## Impact Explanation
This is a **Medium severity** vulnerability based on the following:

1. **Breaks Move VM Safety Invariant**: The invariant "Bytecode execution must respect gas limits and memory constraints" is violated - memory limit enforcement is based on incorrect accounting, causing legitimate transactions to be rejected.

2. **State Inconsistency**: While this doesn't corrupt blockchain state, it creates an inconsistency between actual memory usage and tracked usage, causing deterministic but incorrect transaction rejections.

3. **Availability Impact**: Users submitting transactions with common patterns (table operations followed by hashing/other non-generic natives) will experience spurious failures with `MEMORY_LIMIT_EXCEEDED`, wasting gas and requiring intervention to restructure transaction logic.

4. **Not Consensus-Breaking**: All validators execute identically (deterministic behavior), so this doesn't cause chain splits. However, it does cause network-wide transaction rejection that shouldn't occur.

This does NOT qualify as Critical or High severity because:
- No funds can be stolen or minted
- No consensus violations or safety breaks occur  
- Validators continue operating normally
- The issue causes over-accounting (false positives) not under-accounting (security bypass)

## Likelihood Explanation
**Likelihood: Medium**

This will occur whenever:
1. A transaction calls a generic table or event native function (common pattern in DeFi/storage applications)
2. Followed by any non-generic native function call in the same transaction

Common affected patterns:
- Smart contracts that store data in tables and perform cryptographic operations (hashing, signature verification)
- Applications using both event emissions and hash functions
- Any complex transaction combining storage and computation

The likelihood is medium rather than high because:
- Not all transactions use both table/event AND non-generic natives
- Many simple transactions won't trigger this pattern
- Developers may not notice if their transactions stay under the inflated limit

## Recommendation
Reset the `should_leak_memory_for_native` flag appropriately in `charge_call()` for non-generic native function calls. The flag should be set to `false` by default for all non-table/event natives.

**Recommended Fix:**

In `charge_call()`, explicitly reset the flag before delegating:

```rust
fn charge_call(
    &mut self,
    module_id: &ModuleId,
    func_name: &str,
    args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    num_locals: NumArgs,
) -> PartialVMResult<()> {
    // Non-generic calls should not leak memory for natives by default
    // Only table and event modules (which use generic calls) should leak
    self.should_leak_memory_for_native = false;
    
    self.base.charge_call(module_id, func_name, args, num_locals)
}
```

Alternatively, redesign to use per-call context rather than persistent state:
- Pass the leak flag as a parameter to `charge_native_function_before_execution()`
- Determine the flag value at the call site based on the specific function being invoked
- This eliminates state pollution entirely

## Proof of Concept

```move
module 0xCAFE::memory_accounting_bug {
    use std::table::{Self, Table};
    use aptos_std::aptos_hash;
    
    public entry fun demonstrate_bug(account: &signer) {
        // Create a table with large values
        let table = table::new<u64, vector<u8>>();
        
        // Step 1: Call generic table native - sets should_leak_memory_for_native = true
        table::add(&mut table, 1, vector[1, 2, 3, 4, 5]); // ~5 bytes
        
        // Step 2: Call non-generic native multiple times
        // Each call should release argument memory, but won't due to persisted flag
        let i = 0;
        while (i < 100) {
            // Create a large vector to hash
            let data = vector::empty<u8>();
            let j = 0;
            while (j < 10000) {
                vector::push_back(&mut data, (j as u8));
                j = j + 1;
            };
            
            // This call's argument memory (~10KB) won't be released due to flag pollution
            // Accounting will incorrectly accumulate ~1MB total
            let _ = aptos_hash::sip_hash(data);
            i = i + 1;
        };
        
        // If memory quota is 10MB, this transaction might fail around iteration 100
        // with MEMORY_LIMIT_EXCEEDED despite actual memory usage being much lower
        
        table::destroy_empty(table);
    }
}
```

**Expected behavior**: Transaction should succeed as actual peak memory is well under the 10MB quota.

**Actual behavior**: Transaction fails with `MEMORY_LIMIT_EXCEEDED` due to inflated accounting from non-released hash function argument memory (~1MB cumulative leak).

## Notes

The root cause is architectural: using mutable state (`should_leak_memory_for_native`) that persists across multiple function calls within a transaction creates implicit coupling between unrelated operations. The TODO comment at line 327 references issue #5485 regarding the intentional table native memory leak, but the flag persistence bug is a separate issue not addressed by that design decision.

This vulnerability affects all transactions mixing table/event operations with non-generic native functions since feature version 3 (when memory tracking was enabled) and feature version 4 (when event leak behavior was added).

### Citations

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L134-134)
```rust
    should_leak_memory_for_native: bool,
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L151-160)
```rust
    pub fn new(base: G) -> Self {
        let memory_quota = base.vm_gas_params().txn.memory_quota;
        let feature_version = base.feature_version();

        Self {
            base,
            algebra: A::new(memory_quota, feature_version),
            should_leak_memory_for_native: false,
        }
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L230-245)
```rust
    delegate_mut! {
        fn charge_simple_instr(&mut self, instr: SimpleInstruction) -> PartialVMResult<()>;

        fn charge_br_true(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;

        fn charge_br_false(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;

        fn charge_branch(&mut self, target_offset: CodeOffset) -> PartialVMResult<()>;

        fn charge_call(
            &mut self,
            module_id: &ModuleId,
            func_name: &str,
            args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
            num_locals: NumArgs,
        ) -> PartialVMResult<()>;
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L302-319)
```rust
    fn charge_call_generic(
        &mut self,
        module_id: &ModuleId,
        func_name: &str,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
        num_locals: NumArgs,
    ) -> PartialVMResult<()> {
        // Save the info for charge_native_function_before_execution.
        self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS
            && module_id.name().as_str() == "table")
            || (self.feature_version() >= 4
                && *module_id.address() == CORE_CODE_ADDRESS
                && module_id.name().as_str() == "event");

        self.base
            .charge_call_generic(module_id, func_name, ty_args, args, num_locals)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L322-344)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,
        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,
    ) -> PartialVMResult<()> {
        // TODO(Gas): https://github.com/aptos-labs/aptos-core/issues/5485
        if !self.should_leak_memory_for_native {
            self.release_heap_memory(args.clone().try_fold(
                AbstractValueSize::zero(),
                |acc, val| {
                    let heap_size = self
                        .vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?;
                    Ok::<_, PartialVMError>(acc + heap_size)
                },
            )?);
        }

        self.base
            .charge_native_function_before_execution(ty_args, args)
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L509-519)
```rust
                    // Charge gas
                    gas_meter
                        .charge_call(
                            function.owner_as_module()?.self_id(),
                            function.name(),
                            self.operand_stack
                                .last_n(function.param_tys().len())
                                .map_err(|e| set_err_info!(current_frame, e))?,
                            (function.local_tys().len() as u64).into(),
                        )
                        .map_err(|e| set_err_info!(current_frame, e))?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L622-639)
```rust
                    // Charge gas
                    gas_meter
                        .charge_call_generic(
                            function.owner_as_module()?.self_id(),
                            function.name(),
                            function
                                .ty_args()
                                .iter()
                                .map(|ty| TypeWithRuntimeEnvironment {
                                    ty,
                                    runtime_environment: self.loader.runtime_environment(),
                                }),
                            self.operand_stack
                                .last_n(function.param_tys().len())
                                .map_err(|e| set_err_info!(current_frame, e))?,
                            (function.local_tys().len() as u64).into(),
                        )
                        .map_err(|e| set_err_info!(current_frame, e))?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1088-1096)
```rust
        let native_function = function.get_native()?;

        gas_meter.charge_native_function_before_execution(
            ty_args.iter().map(|ty| TypeWithRuntimeEnvironment {
                ty,
                runtime_environment: self.loader.runtime_environment(),
            }),
            args.iter(),
        )?;
```

**File:** aptos-move/framework/aptos-stdlib/sources/hash.move (L25-25)
```text
    native public fun sip_hash(bytes: vector<u8>): u64;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```
