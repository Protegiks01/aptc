# Audit Report

## Title
Log Injection Vulnerability via Unvalidated ASCII Control Characters in NetworkAddress DNS Names

## Summary
The `DnsName` validation in `NetworkAddress` parsing accepts ASCII control characters (including newlines, carriage returns, ANSI escape sequences) which can be injected into log messages. When logged in text format (the default), these control characters are written unescaped to stdout/files, enabling log injection attacks that can manipulate log parsing systems, evade security monitoring, and potentially exploit downstream log processing tools.

## Finding Description

The `DnsName::validate()` function only checks that DNS names are valid ASCII strings without '/' characters, but does not filter ASCII control characters (0x00-0x1F, 0x7F). [1](#0-0) 

When a `NetworkAddress` containing a malicious DNS name is formatted via its `Display` implementation (which `Debug` delegates to), the control characters are output directly without escaping. [2](#0-1) 

The `Protocol::Display` implementation for DNS protocols directly outputs the domain name via `write!(f, "/dns/{}", domain)`. [3](#0-2) 

**Attack Path:**
1. Attacker provides a malicious network address via CLI argument, configuration file, or network message: `/dns/evil\nINJECTED/tcp/80`
2. The address passes validation since newline (0x0A) is valid ASCII
3. Network operation fails and address is logged: `warn!(..., "Failed to resolve network address {:?}: {}", network_address, error)` [4](#0-3) 
4. The error message is formatted into `LogEntry.message` without escaping [5](#0-4) 
5. In text format (the default), the message is written directly via `write!(w, " {}", message)?` without escaping [6](#0-5) 
6. The log output is written to stdout/files with control characters intact [7](#0-6) 

## Impact Explanation

**Medium Severity** - This vulnerability enables:
- **Log Injection**: Creating fake log entries that appear legitimate, evading security monitoring
- **Log Parser Confusion**: Breaking log aggregation tools that assume one line = one entry
- **Terminal Manipulation**: ANSI escape sequences can manipulate terminal output, hiding malicious activity
- **Potential Command Injection**: If logs are processed by scripts that don't properly sanitize input

While this doesn't directly compromise consensus or validator operations, it undermines operational security and monitoring capabilities, which are critical for detecting and responding to attacks on validator infrastructure.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily triggered because:
1. Network addresses are accepted from external input (CLI args, configs, peer discovery)
2. The default logging format (text) is vulnerable [8](#0-7) 
3. Network address validation failures are commonly logged during normal operations
4. No special privileges or timing requirements needed
5. The attack works against default configurations

## Recommendation

**Fix 1: Validate DNS names to exclude control characters**

Modify `DnsName::validate()` to reject ASCII control characters: [1](#0-0) 

Replace with validation that checks for printable ASCII only (0x20-0x7E), similar to the fuzzer's approach:

```rust
fn validate(s: &str) -> Result<(), ParseError> {
    if s.is_empty() {
        Err(ParseError::EmptyDnsNameString)
    } else if s.len() > MAX_DNS_NAME_SIZE {
        Err(ParseError::DnsNameTooLong(s.len()))
    } else if s.contains('/') {
        Err(ParseError::InvalidDnsNameCharacter)
    } else if !s.chars().all(|c| c.is_ascii() && !c.is_ascii_control()) {
        Err(ParseError::DnsNameNonASCII(s.into()))
    } else {
        Ok(())
    }
}
```

**Fix 2: Escape control characters in text log format**

Modify `text_format()` to escape the message field before writing, ensuring control characters are rendered safely.

## Proof of Concept

```rust
#[test]
fn test_log_injection_via_dns_name() {
    use aptos_types::network_address::{NetworkAddress, Protocol, DnsName};
    use std::str::FromStr;
    
    // Create malicious DNS name with newline
    let malicious_addr = "/dns/evil\nINJECTED.com/tcp/80";
    
    // This should fail but currently succeeds
    let addr = NetworkAddress::from_str(malicious_addr);
    assert!(addr.is_ok(), "Malicious address was accepted!");
    
    let addr = addr.unwrap();
    let formatted = format!("{:?}", addr);
    
    // The formatted output contains unescaped newline
    assert!(formatted.contains('\n'), "Newline was not filtered!");
    
    // When logged, this creates multiple lines:
    // Line 1: "...address /dns/evil"
    // Line 2: "INJECTED.com/tcp/80..."
    println!("Vulnerable output:\n{}", formatted);
}
```

## Notes

While JSON log format properly escapes control characters via `serde_json`, the text format (which is the default) does not. This creates an inconsistency where the same malicious input is safe in one format but vulnerable in another. The vulnerability affects all network address logging throughout the codebase, including connection failures, peer discovery, and configuration validation.

### Citations

**File:** types/src/network_address/mod.rs (L514-527)
```rust
impl fmt::Display for NetworkAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for protocol in self.0.iter() {
            protocol.fmt(f)?;
        }
        Ok(())
    }
}

impl fmt::Debug for NetworkAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(self, f)
    }
}
```

**File:** types/src/network_address/mod.rs (L598-619)
```rust
impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use self::Protocol::*;
        match self {
            Ip4(addr) => write!(f, "/ip4/{}", addr),
            Ip6(addr) => write!(f, "/ip6/{}", addr),
            Dns(domain) => write!(f, "/dns/{}", domain),
            Dns4(domain) => write!(f, "/dns4/{}", domain),
            Dns6(domain) => write!(f, "/dns6/{}", domain),
            Tcp(port) => write!(f, "/tcp/{}", port),
            Memory(port) => write!(f, "/memory/{}", port),
            NoiseIK(pubkey) => write!(
                f,
                "/noise-ik/{}",
                pubkey
                    .to_encoded_string()
                    .expect("ValidCryptoMaterialStringExt::to_encoded_string is infallible")
            ),
            Handshake(version) => write!(f, "/handshake/{}", version),
        }
    }
}
```

**File:** types/src/network_address/mod.rs (L667-679)
```rust
    fn validate(s: &str) -> Result<(), ParseError> {
        if s.is_empty() {
            Err(ParseError::EmptyDnsNameString)
        } else if s.len() > MAX_DNS_NAME_SIZE {
            Err(ParseError::DnsNameTooLong(s.len()))
        } else if s.contains('/') {
            Err(ParseError::InvalidDnsNameCharacter)
        } else if !s.is_ascii() {
            Err(ParseError::DnsNameNonASCII(s.into()))
        } else {
            Ok(())
        }
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1164-1169)
```rust
                warn!(
                    NetworkSchema::new(&network_context),
                    "Failed to resolve network address {:?}: {}", network_address, error
                );
                return;
            },
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L190-195)
```rust
        let metadata = *event.metadata();
        let thread_name = thread_name.map(ToOwned::to_owned);
        let message = event
            .message()
            .map(fmt::format)
            .map(|s| TruncatedLogString::from(s).into());
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L452-453)
```rust
                formatter: self.custom_format.take().unwrap_or(text_format),
            });
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L704-715)
```rust
impl Writer for StdoutWriter {
    /// Write log to stdout
    fn write(&self, log: String) {
        println!("{}", log);
    }

    fn write_buferred(&mut self, log: String) {
        self.buffer
            .write_fmt(format_args!("{}\n", log))
            .unwrap_or_default();
    }
}
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L769-771)
```rust
    if let Some(message) = &entry.message {
        write!(w, " {}", message)?;
    }
```
