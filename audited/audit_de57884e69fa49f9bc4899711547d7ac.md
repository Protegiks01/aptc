# Audit Report

## Title
Lack of TLS Enforcement in GrpcAddress Configuration Enables Downgrade Attacks on Indexer Infrastructure

## Summary
The `GrpcAddress` type defined in the indexer-grpc-manager configuration provides no distinction between TLS and non-TLS endpoints, relying solely on URL scheme parsing by the tonic library. This allows configuration of unencrypted HTTP connections without validation, enabling potential downgrade attacks if configuration is compromised. [1](#0-0) 

## Finding Description
The `GrpcAddress` type is defined as a simple `String` alias with no type-level enforcement or validation of TLS usage. This address type is used throughout the indexer-grpc-manager for critical inter-service communications:

- Communication with peer GRPC managers [2](#0-1) 
- Communication with fullnodes to fetch transaction data [3](#0-2) 
- Self-advertised address for service discovery [4](#0-3) 

When these addresses are used to establish gRPC connections, the code simply passes them to `Channel::from_shared()` without any TLS configuration or validation: [5](#0-4) [6](#0-5) 

The tonic library determines TLS usage based solely on the URL scheme:
- `https://` → TLS-encrypted connection
- `http://` → Unencrypted plaintext connection

**Attack Scenario:**
1. An attacker with configuration access (through compromised deployment pipeline, supply chain attack, or insider threat) modifies the configuration file
2. They replace `https://` prefixes with `http://` in the `grpc_manager_addresses` or `fullnode_addresses` fields
3. The system accepts this configuration without validation or warning
4. All inter-service communications occur over unencrypted channels
5. The attacker can intercept transaction data streams via man-in-the-middle attacks

The system transmits sensitive blockchain data including transaction batches through these connections: [7](#0-6) 

While blockchain transaction data is public by design, unencrypted transmission enables:
- Metadata analysis (query patterns, timing, client identification)
- Potential data manipulation via MITM attacks before verification
- Privacy violations for indexer clients
- Compromise of service coordination between grpc-manager instances

## Impact Explanation
This qualifies as **Medium severity** per the Aptos bug bounty criteria for the following reasons:

1. **Limited Scope**: Affects indexer infrastructure only, not consensus validators or core blockchain security
2. **State Inconsistency Risk**: If MITM attacks succeed in manipulating data streams, could cause inconsistencies in indexed data requiring manual intervention
3. **Configuration-Level Access Required**: Cannot be exploited without access to modify configuration files or deployment processes

The vulnerability does not meet Critical or High severity because:
- No direct loss of funds
- No consensus safety violations
- No impact on validator node operations
- Requires privileged access to configuration

## Likelihood Explanation
**Medium-to-Low likelihood** due to:

**Prerequisites:**
- Attacker must have configuration-level access (deployment pipeline, config management, or filesystem access)
- Requires either insider threat, compromised CI/CD, or supply chain attack
- Not exploitable by external unprivileged attackers

**Factors increasing likelihood:**
- No validation makes accidental misconfiguration possible
- Operators might not recognize the security implications of `http://` vs `https://` 
- Configuration changes may not be audited for TLS enforcement
- The system silently accepts insecure configurations

**Mitigation by other controls:**
- Configuration is typically managed through secure deployment processes
- Most production environments enforce TLS at infrastructure level
- Blockchain data is public, limiting confidentiality impact

## Recommendation

Implement type-safe TLS enforcement at the configuration level:

```rust
// Define a validated address type
pub struct SecureGrpcAddress(String);

impl SecureGrpcAddress {
    pub fn new(address: String) -> Result<Self, &'static str> {
        if !address.starts_with("https://") {
            return Err("GrpcAddress must use https:// scheme for TLS encryption");
        }
        Ok(SecureGrpcAddress(address))
    }
    
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

// Update configuration structs
pub struct IndexerGrpcManagerConfig {
    // ... other fields ...
    pub(crate) self_advertised_address: SecureGrpcAddress,
    pub(crate) grpc_manager_addresses: Vec<SecureGrpcAddress>,
    pub(crate) fullnode_addresses: Vec<SecureGrpcAddress>,
    // ... other fields ...
}
```

Additionally, configure explicit TLS settings when creating channels rather than relying on URL scheme:

```rust
use tonic::transport::ClientTlsConfig;

let tls_config = ClientTlsConfig::new();
let channel = Channel::from_shared(address.as_str())
    .expect("Invalid address")
    .tls_config(tls_config)
    .expect("TLS configuration failed")
    .connect_lazy();
```

## Proof of Concept

**Step 1**: Create a malicious configuration with HTTP endpoints:

```yaml
# malicious_config.yaml
chain_id: 1
service_config:
  listen_address: 0.0.0.0:50051
cache_config:
  max_cache_size: 5368709120
  target_cache_size: 4294967296
file_store_config:
  file_store_type: GcsFileStore
  gcs_file_store_bucket_name: test-bucket
self_advertised_address: "http://manager1.example.com:50051"  # Downgraded to HTTP
grpc_manager_addresses:
  - "http://manager2.example.com:50051"  # Downgraded to HTTP
fullnode_addresses:
  - "http://fullnode1.example.com:50051"  # Downgraded to HTTP
is_master: true
allow_fn_fallback: true
```

**Step 2**: The system will accept this configuration and establish unencrypted connections

**Step 3**: Verify unencrypted traffic using network capture:

```bash
# Run the indexer with malicious config
cargo run -- -c malicious_config.yaml

# Capture traffic (in separate terminal)
sudo tcpdump -i any -A 'tcp port 50051'

# Observe plaintext gRPC traffic including transaction data
```

**Expected Result**: Transaction data and service coordination messages will be transmitted in plaintext, visible in the network capture, demonstrating the lack of TLS enforcement.

## Notes

The core issue is that `GrpcAddress` provides no type-level safety or runtime validation to ensure TLS is used for sensitive communications. While the tonic library supports TLS through the `tls-roots` feature [8](#0-7) , the application code does not enforce its use.

Other parts of the Aptos ecosystem properly distinguish between TLS and non-TLS configurations, such as the indexer-grpc-data-service which has separate configuration structures for TLS and non-TLS endpoints. The grpc-manager should follow similar patterns with explicit TLS validation and configuration.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L16-16)
```rust
pub(crate) type GrpcAddress = String;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L37-37)
```rust
    pub(crate) self_advertised_address: GrpcAddress,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L38-38)
```rust
    pub(crate) grpc_manager_addresses: Vec<GrpcAddress>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L39-39)
```rust
    pub(crate) fullnode_addresses: Vec<GrpcAddress>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L45-48)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L67-70)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L217-220)
```rust
            let (address, mut fullnode_client) =
                self.metadata_manager.get_fullnode_for_request(&request);
            trace!("Fullnode ({address}) is picked for request.");
            let response = fullnode_client.get_transactions_from_node(request).await;
```

**File:** Cargo.toml (L835-842)
```text
tonic = { version = "0.12.3", features = [
    "tls-roots",
    "transport",
    "prost",
    "gzip",
    "codegen",
    "zstd",
] }
```
