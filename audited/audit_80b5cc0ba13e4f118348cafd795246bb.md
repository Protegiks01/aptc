# Audit Report

## Title
Panic-Induced Denial of Service in Indexer gRPC Ping Endpoint Due to Unchecked Duration Subtraction

## Summary
The `ping()` function in the indexer-grpc fullnode service performs unchecked Duration subtraction when calculating block latency, causing a panic and service crash when block timestamps are in the future due to legitimate clock skew between validators and indexer nodes.

## Finding Description

The vulnerability exists in the latency calculation within the `ping()` endpoint. [1](#0-0) 

The code performs direct subtraction between two `Duration` values. In Rust, the `Sub` trait implementation for `Duration` will panic if the right-hand side is greater than the left-hand side, as `Duration` cannot represent negative time spans.

Aptos consensus explicitly allows blocks to have timestamps up to 5 minutes in the future relative to a validator's local clock to accommodate clock skew in distributed systems. [2](#0-1) 

When an indexer node's clock is behind (or a validator's clock is ahead), blocks stored in the database will have timestamps in the future relative to `SystemTime::now()`. When `ping()` is called, the subtraction `SystemTime::now().duration_since(UNIX_EPOCH).unwrap() - Duration::from_micros(timestamp_us)` will panic.

The indexer-grpc service has a global panic handler that terminates the entire process. [3](#0-2) 

This contrasts with proper handling elsewhere in the codebase. The consensus tracing code safely handles this exact scenario using `checked_sub`. [4](#0-3) 

## Impact Explanation

**Severity: Low** (per Aptos Bug Bounty Program - up to $1,000)

This vulnerability causes denial of service of the indexer-grpc fullnode service, classified as a "non-critical implementation bug" because:

1. **No consensus impact**: The indexer-grpc service is not part of consensus or blockchain state management
2. **No fund risk**: No user funds or staked assets are at risk
3. **Recoverable**: The service can be restarted to restore functionality
4. **Limited scope**: Only affects the ping health check endpoint
5. **No data corruption**: No blockchain data or state is affected

However, it does cause service disruption requiring manual intervention to restart the crashed process.

## Likelihood Explanation

**Likelihood: Medium**

Clock skew between validators and indexer nodes is a common occurrence in distributed systems due to:
- NTP synchronization delays
- Different time zones or clock drift
- Network latency variations
- Validator and indexer nodes running on different infrastructure

The 5-minute tolerance window is specifically designed to handle such skew. Any client (including health monitoring systems) calling `ping()` when this natural condition exists will trigger the crash.

## Recommendation

Replace the unchecked subtraction with `checked_sub` and handle the `None` case gracefully, following the pattern used in consensus tracing code:

```rust
if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
    if let Some(latency) = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .checked_sub(Duration::from_micros(timestamp_us))
    {
        LATENCY_MS.set(latency.as_millis() as i64);
    }
    // If checked_sub returns None (timestamp is in future), skip metric recording
}
```

## Proof of Concept

**Reproduction Steps:**

1. Run an Aptos indexer-grpc fullnode service
2. Ensure the node syncs blocks from validators with clocks ahead by 1-5 minutes (within TIMEBOUND)
3. Call the `ping()` gRPC endpoint: `grpcurl -plaintext localhost:50051 aptos.internal.fullnode.v1.FullnodeData/PingFullnode`
4. Observe service panic with message about Duration subtraction overflow
5. Service terminates with exit code 12

**Test Case:**

The vulnerability can be demonstrated by mocking `get_block_timestamp()` to return a future timestamp, then invoking `ping()` to observe the panic.

## Notes

This is a **Low severity** finding as explicitly marked in the security question. While it represents a real denial-of-service vulnerability with a clear fix, it does not meet the Critical/High/Medium severity thresholds due to its limited impact scope (indexer service only, no consensus or fund implications).

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L228-232)
```rust
            if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
                let latency = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
                    - Duration::from_micros(timestamp_us);
                LATENCY_MS.set(latency.as_millis() as i64);
            }
```

**File:** consensus/consensus-types/src/block.rs (L534-539)
```rust
            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-167)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
```

**File:** consensus/src/dag/observability/tracing.rs (L26-30)
```rust
fn observe(counter: &HistogramVec, timestamp: u64, name: &str) {
    if let Some(t) = duration_since_epoch().checked_sub(Duration::from_micros(timestamp)) {
        counter.with_label_values(&[name]).observe(t.as_secs_f64());
    }
}
```
