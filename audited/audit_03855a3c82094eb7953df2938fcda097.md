# Audit Report

## Title
Type-Basis Mismatch in SRS Deserialization Allowing Cryptographic Algorithm Confusion

## Summary
The `SrsBasis<C>` enum in the SRS (Structured Reference String) implementation can be deserialized with a mismatch between the declared basis type (via enum tag) and the actual mathematical representation of the group elements. While runtime checks verify the enum variant, they do not validate the semantic correctness of the basis, potentially causing cryptographic operations to use incorrect algorithms.

## Finding Description

The vulnerability exists in the deserialization path of `SrsBasis<C>` enum used in cryptographic protocols for distributed key generation (DKG) and batch threshold encryption. [1](#0-0) 

During deserialization, only the variant tag (0 for Lagrange, 1 for PowersOfTau) determines the enum type. The `Valid::check()` implementation only validates that individual curve points are valid, not that they semantically match the claimed basis: [2](#0-1) 

This allows construction of `SrsBasis::Lagrange` containing Powers of Tau elements, or vice versa. The vulnerability propagates through the chunky PVSS system used in batch threshold encryption: [3](#0-2) 

The consensus layer uses this for encrypted transaction decryption: [4](#0-3) 

While runtime checks exist to verify the enum variant: [5](#0-4) 

These checks only verify the enum tag, not whether the actual group elements represent the correct mathematical basis. When the wrong basis is used, cryptographic operations apply incorrect algorithms: [6](#0-5) 

## Impact Explanation

**Severity: High** (potentially Critical depending on parameter distribution mechanism)

This vulnerability could cause:

1. **Consensus disagreement**: Validators using different public parameters would compute different range proofs and transcript verifications, failing to reach consensus on DKG transcript validity.

2. **DKG failure**: Invalid transcripts might be accepted or valid ones rejected, breaking distributed key generation for encrypted transaction decryption.

3. **Cryptographic incorrectness**: Using Lagrange basis algorithms with Powers of Tau elements (or vice versa) produces mathematically incorrect commitments and proofs.

However, **exploitation requires the ability to supply malicious public parameters to validators**. The attack path depends on how `PublicParameters` are distributed in production: [7](#0-6) 

The `Valid` trait implementation provides no validation: [8](#0-7) 

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires:
1. Ability to inject malicious serialized `PublicParameters` into the system
2. Validators to deserialize and use these parameters
3. No detection before cryptographic operations fail

**Reducing factors:**
- Public parameters may be hardcoded, generated locally, or distributed through trusted channels
- The normal code path through `setup()` correctly maps basis types
- Cryptographic operation failures may be detected before consensus impact

**Without evidence that public parameters can be externally influenced in production deployment**, this remains a theoretical vulnerability.

## Recommendation

Implement semantic validation in the `Valid::check()` method for `SrsBasis<C>`:

```rust
impl<C: CurveGroup> Valid for SrsBasis<C> {
    fn check(&self) -> Result<(), SerializationError> {
        match self {
            SrsBasis::Lagrange { lagr: lagr_g1 } => {
                for g in lagr_g1 {
                    g.check()?;
                }
                // TODO: Add semantic validation that elements form Lagrange basis
                // This requires knowing the evaluation domain and tau, which may not be available
            },
            SrsBasis::PowersOfTau { tau_powers: tau_powers_g1 } => {
                for g in tau_powers_g1 {
                    g.check()?;
                }
                // TODO: Add validation that consecutive elements have correct ratios
            },
        }
        Ok(())
    }
}
```

Additionally, implement validation in `PublicParameters::Valid`: [8](#0-7) 

Replace the no-op implementation with actual validation of all contained cryptographic parameters.

## Proof of Concept

```rust
#[test]
fn test_srs_basis_type_confusion() {
    use ark_bn254::{Bn254, G1Projective};
    use ark_ec::CurveGroup;
    use aptos_crypto::arkworks::srs::{powers_of_tau, SrsBasis};
    use ark_serialize::{CanonicalSerialize, CanonicalDeserialize, Compress, Validate};
    
    // Create Powers of Tau basis
    let g = G1Projective::generator();
    let tau = ark_ff::Field::from(42u64);
    let pow_tau_elements = powers_of_tau::<G1Projective>(g, tau, 8);
    
    // Construct as PowersOfTau
    let correct_basis = SrsBasis::PowersOfTau { tau_powers: pow_tau_elements.clone() };
    
    // Serialize
    let mut bytes = Vec::new();
    correct_basis.serialize_with_mode(&mut bytes, Compress::Yes).unwrap();
    
    // Tamper: change tag from 1 (PowersOfTau) to 0 (Lagrange)
    bytes[0] = 0u8;
    
    // Deserialize as Lagrange (but contains PowersOfTau elements!)
    let confused_basis = SrsBasis::<G1Projective>::deserialize_with_mode(
        &bytes[..], 
        Compress::Yes, 
        Validate::Yes
    ).unwrap();
    
    // Verify it deserialized as Lagrange variant
    match confused_basis {
        SrsBasis::Lagrange { lagr } => {
            // Success: tag says Lagrange but elements are Powers of Tau
            assert_eq!(lagr.len(), 8);
            println!("Type confusion successful: Lagrange tag with PowersOfTau elements");
        },
        _ => panic!("Expected Lagrange variant"),
    }
}
```

**Critical Gap**: This PoC demonstrates the deserialization vulnerability exists, but does not prove it's exploitable in production without establishing how an attacker can inject malicious `PublicParameters` into the consensus/DKG system.

## Notes

This finding identifies a **defense-in-depth weakness** rather than a directly exploitable vulnerability. The actual exploitability depends on:

1. How `PublicParameters` are distributed to validators in production
2. Whether they're loaded from trusted sources (hardcoded, trusted setup ceremony) or untrusted sources (network, on-chain state, configuration files)
3. Whether additional validation occurs at the application layer

The codebase shows `PublicParameters::new()` creates parameters locally, but the `TryFrom<&[u8]>` implementation suggests they can be loaded from external sources. Without complete visibility into the deployment architecture and parameter distribution mechanism, the real-world risk cannot be fully assessed.

**Recommendation for Aptos team**: Even if parameters are currently distributed through trusted channels, implement the semantic validation as defense-in-depth against future architectural changes or supply chain attacks.

### Citations

**File:** crates/aptos-crypto/src/arkworks/srs.rs (L81-99)
```rust
impl<C: CurveGroup> Valid for SrsBasis<C> {
    fn check(&self) -> Result<(), SerializationError> {
        match self {
            SrsBasis::Lagrange { lagr: lagr_g1 } => {
                for g in lagr_g1 {
                    g.check()?;
                }
            },
            SrsBasis::PowersOfTau {
                tau_powers: tau_powers_g1,
            } => {
                for g in tau_powers_g1 {
                    g.check()?;
                }
            },
        }
        Ok(())
    }
}
```

**File:** crates/aptos-crypto/src/arkworks/srs.rs (L101-126)
```rust
impl<C: CurveGroup> CanonicalDeserialize for SrsBasis<C> {
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: Validate,
    ) -> Result<Self, SerializationError> {
        // Read the variant tag first
        let tag = u8::deserialize_with_mode(&mut reader, compress, validate)?;

        match tag {
            0 => {
                // Lagrange variant
                let lagr =
                    Vec::<C::Affine>::deserialize_with_mode(&mut reader, compress, validate)?;
                Ok(SrsBasis::Lagrange { lagr })
            },
            1 => {
                // Powers-of-Tau variant
                let tau_powers =
                    Vec::<C::Affine>::deserialize_with_mode(&mut reader, compress, validate)?;
                Ok(SrsBasis::PowersOfTau { tau_powers })
            },
            _ => Err(SerializationError::InvalidData),
        }
    }
}
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L225-225)
```rust
    type SubTranscript = aptos_dkg::pvss::chunky::WeightedSubtranscript<Pairing>;
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L92-93)
```rust
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L371-376)
```rust
        let lagr_g1: &[E::G1Affine] = match msm_basis {
            SrsBasis::Lagrange { lagr: lagr_g1 } => lagr_g1,
            SrsBasis::PowersOfTau { .. } => {
                panic!("Expected Lagrange basis, somehow got PowersOfTau basis instead")
            },
        };
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L206-233)
```rust
        let q_vals = match &ck.msm_basis {
            SrsBasis::Lagrange { .. } => {
                // Lagrange basis expects f_vals to be evaluations, and we return q_vals with evaluations
                // The `quotient_evaluations_batch()` function divides over `(theta_i - x)` for `theta_i` an m-th root of unity, hence:
                if ck.roots_of_unity_in_eval_dom.contains(&x) {
                    panic!("x is not allowed to be a root of unity");
                }
                polynomials::quotient_evaluations_batch(
                    &f_vals,
                    &ck.roots_of_unity_in_eval_dom,
                    x,
                    y,
                )
            },
            SrsBasis::PowersOfTau { .. } => {
                // Powers-of-Tau expects f_vals to be coefficients, and we return q_vals with coefficients
                // For some reason arkworks only implemented `divide_with_q_and_r()` for `DenseOrSparsePolynomial`
                let f_dense = DensePolynomial { coeffs: f_vals };
                let f = DenseOrSparsePolynomial::DPolynomial(Cow::Owned(f_dense));
                let divisor_dense = DensePolynomial {
                    coeffs: vec![-x, E::ScalarField::ONE],
                };
                let divisor = DenseOrSparsePolynomial::DPolynomial(Cow::Owned(divisor_dense));

                let (q, _) = f.divide_with_q_and_r(&divisor).expect("Could not divide polynomial, but that shouldn't happen because the divisor is nonzero");
                q.coeffs
            },
        };
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L120-123)
```rust
impl<E: Pairing> Valid for PublicParameters<E> {
    fn check(&self) -> Result<(), SerializationError> {
        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L149-156)
```rust
impl<E: Pairing> TryFrom<&[u8]> for PublicParameters<E> {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        bcs::from_bytes::<PublicParameters<E>>(bytes)
            .map_err(|_| CryptoMaterialError::DeserializationError)
    }
}
```
