# Audit Report

## Title
Authentication Credential Exposure via Plaintext HTTP in Admin Service

## Summary
The Aptos admin service lacks TLS/HTTPS support and transmits authentication passcodes in plaintext over the network via URL query parameters. This enables network-level attackers to intercept credentials and gain unauthorized access to highly sensitive validator internal state, including consensus databases, block data, and transaction information.

## Finding Description

The admin service implements HTTP-only communication without TLS encryption support. [1](#0-0) 

The `AdminServiceConfig` structure contains no TLS-related configuration fields (unlike the API service which has `tls_cert_path` and `tls_key_path`). [2](#0-1) 

There is an explicit TODO comment acknowledging missing SSL support. [3](#0-2) 

Authentication is implemented by extracting passcodes from URL query parameters and comparing their SHA256 hashes. [4](#0-3) 

The service binds to all network interfaces (`0.0.0.0`) by default, making it accessible over the network. [5](#0-4) 

**Attack Scenario:**
1. Administrator issues legitimate request: `http://validator-ip:9102/debug/consensus/consensusdb?passcode=mysecretpasscode`
2. Attacker positioned on network path (same LAN, compromised router, ISP monitoring) captures HTTP traffic using packet sniffer (tcpdump, Wireshark, etc.)
3. Attacker extracts plaintext passcode `mysecretpasscode` from captured URL
4. Attacker uses stolen credentials: `curl http://validator-ip:9102/debug/consensus/consensusdb?passcode=mysecretpasscode`
5. Attacker exfiltrates sensitive validator data

The service exposes critical endpoints including consensus database dumps, quorum store data, block dumps with transactions, and mempool information. [6](#0-5) 

**Invariant Violated:** Access Control (Invariant #8) - Administrative endpoints exposing consensus-critical data must be protected from unauthorized access. The lack of transport encryption enables credential theft, breaking this fundamental security guarantee.

## Impact Explanation

**Critical Severity** per Aptos Bug Bounty criteria:

This vulnerability enables **unauthorized access to validator internal state**, which falls under multiple critical categories:

1. **Consensus/Safety Implications**: Exposing consensus database dumps reveals validator voting patterns, block authorship, quorum certificates, and round state. An attacker gaining this information could:
   - Analyze validator behavior patterns to optimize consensus-level attacks
   - Identify timing windows for equivocation attempts
   - Map validator network topology and relationships

2. **Information Disclosure of Sensitive State**: The endpoints expose:
   - Complete consensus database contents (votes, blocks, QCs) [7](#0-6) 
   - Transaction data within blocks [8](#0-7) 
   - Mempool state information

3. **Credential Theft**: Unlike typical API keys that can be rotated easily, this affects validator operational security directly.

While this does not directly cause consensus safety violations or fund loss, it provides critical intelligence that could facilitate subsequent attacks on validator operations, making it a significant security compromise affecting the core infrastructure.

## Likelihood Explanation

**High Likelihood:**

1. **Attack Complexity: Trivial**
   - Passive network sniffing requires no authentication
   - Tools like tcpdump/Wireshark are freely available
   - No exploit development needed - simple observation

2. **Attacker Position: Realistic**
   - Same LAN as validator (cloud provider networks, data center LANs)
   - Compromised network equipment (routers, switches, load balancers)
   - ISP-level monitoring (legal intercept, compromised ISP infrastructure)
   - Public WiFi if administrator accesses remotely
   - Proxy/load balancer logs (URLs are typically logged)

3. **Deployment Reality:**
   - Service binds to `0.0.0.0` by default (all interfaces)
   - Enabled by default on non-mainnet chains [9](#0-8) 
   - Required for legitimate administrative access during operations

4. **No Compensating Controls:**
   - No IP whitelisting in the code
   - No additional authentication layers
   - No rate limiting on authentication attempts
   - Passcode appears in URL (logged by proxies, browsers, access logs)

## Recommendation

**Immediate Actions:**

1. **Implement TLS Support** following the pattern used in the API service:

Add TLS configuration fields to `AdminServiceConfig`:
```rust
pub struct AdminServiceConfig {
    // ... existing fields ...
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_cert_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_key_path: Option<String>,
}
```

Implement conditional TLS listener similar to API service pattern (see [10](#0-9) ):
```rust
let listener = match (&config.tls_cert_path, &config.tls_key_path) {
    (Some(cert_path), Some(key_path)) => {
        // Load TLS certificates and configure RustlsConfig
        TcpListener::bind(address).rustls(rustls_config).boxed()
    },
    _ => TcpListener::bind(address).boxed(),
};
```

2. **Move Authentication to Headers**: Replace query parameter authentication with HTTP header-based authentication (e.g., `Authorization: Bearer <token>`) to prevent logging in URLs.

3. **Add Config Sanitizer**: Require TLS on mainnet similar to API authentication requirements.

4. **Documentation**: Document that admin service should only be exposed via TLS and preferably via VPN/bastion hosts, not directly to public networks.

## Proof of Concept

**Setup:**
1. Configure validator with admin service enabled:
```yaml
admin_service:
  enabled: true
  address: "0.0.0.0"
  port: 9102
  authentication_configs:
    - passcode_sha256: "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"  # SHA256("abc")
```

2. Start validator node

**Exploitation Steps:**

```bash
# Terminal 1: Attacker runs packet capture on validator network
sudo tcpdump -i eth0 -A 'tcp port 9102'

# Terminal 2: Administrator makes legitimate request
curl http://validator-ip:9102/debug/consensus/consensusdb?passcode=abc

# Terminal 1 output shows:
# GET /debug/consensus/consensusdb?passcode=abc HTTP/1.1
# Host: validator-ip:9102
# [Plaintext passcode "abc" visible in capture]

# Terminal 3: Attacker uses stolen passcode
curl http://validator-ip:9102/debug/consensus/consensusdb?passcode=abc
# Successfully retrieves consensus database dump

# Attacker can now access all admin endpoints:
curl http://validator-ip:9102/debug/consensus/block?passcode=abc
curl http://validator-ip:9102/debug/consensus/quorumstoredb?passcode=abc
curl http://validator-ip:9102/debug/mempool/parking-lot/addresses?passcode=abc
```

**Expected Result:** Attacker successfully exfiltrates sensitive validator internal state without authorization by replaying captured credentials.

## Notes

- This vulnerability affects all deployments where the admin service is enabled and accessible over a network
- The issue is exacerbated by the default `0.0.0.0` binding which exposes the service on all network interfaces
- While the API service has proper TLS support, the admin service was left without this critical security feature
- The TODO comment indicates this was a known gap in the implementation
- Production deployments should implement network-level isolation (VPN, firewall rules) as a compensating control until TLS is implemented, but this is defense-in-depth, not a substitute for proper transport encryption

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L136-136)
```rust
            let server = Server::bind(&address).serve(make_service);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L161-170)
```rust
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L194-229)
```rust
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
```

**File:** config/src/config/admin_service_config.rs (L17-24)
```rust
pub struct AdminServiceConfig {
    pub enabled: Option<bool>,
    pub address: String,
    pub port: u16,
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
    pub malloc_stats_max_len: usize,
}
```

**File:** config/src/config/admin_service_config.rs (L38-38)
```rust
    // TODO(grao): Add SSL support if necessary.
```

**File:** config/src/config/admin_service_config.rs (L45-45)
```rust
            address: "0.0.0.0".to_string(),
```

**File:** config/src/config/admin_service_config.rs (L93-103)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-215)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }

    if body.is_empty() {
        if let Some(block_id) = block_id {
            body.push_str(&format!("Done, block ({block_id:?}) is not found."));
        } else {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
}
```

**File:** api/src/runtime.rs (L191-210)
```rust
    let listener = match (&config.api.tls_cert_path, &config.api.tls_key_path) {
        (Some(tls_cert_path), Some(tls_key_path)) => {
            info!("Using TLS for API");
            let cert = std::fs::read_to_string(tls_cert_path).context(format!(
                "Failed to read TLS cert from path: {}",
                tls_cert_path
            ))?;
            let key = std::fs::read_to_string(tls_key_path).context(format!(
                "Failed to read TLS key from path: {}",
                tls_key_path
            ))?;
            let rustls_certificate = RustlsCertificate::new().cert(cert).key(key);
            let rustls_config = RustlsConfig::new().fallback(rustls_certificate);
            TcpListener::bind(address).rustls(rustls_config).boxed()
        },
        _ => {
            info!("Not using TLS for API");
            TcpListener::bind(address).boxed()
        },
    };
```
