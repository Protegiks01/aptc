# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Faucet IP Filtering

## Summary
The Aptos faucet's IP filtering mechanism fails to normalize IPv4-mapped IPv6 addresses (e.g., `::ffff:192.0.2.1`), allowing attackers to bypass IP-based blocklists and allowlists by connecting through IPv6-formatted versions of blocked IPv4 addresses. The logger in `aptos-warp-webserver/src/log.rs` exacerbates detection difficulties by logging these addresses without normalization.

## Finding Description

The vulnerability exists in the IP filtering implementation used by the Aptos faucet service. When the faucet checks IP addresses against blocklists or allowlists, it treats IPv4 and IPv6 addresses as completely separate address families without normalizing IPv4-mapped IPv6 addresses. [1](#0-0) 

The `IpBlocklistChecker` separates IPv4 and IPv6 addresses and checks them against separate lists. The underlying `IpRangeManager` uses the same pattern: [2](#0-1) 

This separation means that if an IPv4 address like `192.0.2.1` is in the blocklist, an attacker can bypass the filter by connecting using the IPv4-mapped IPv6 equivalent `::ffff:192.0.2.1`. The code will treat this as an IPv6 address and check only the IPv6 blocklist, missing the IPv4 entry.

The attack becomes feasible when:
1. The faucet is configured to bind to an IPv6 address (e.g., `::`)
2. On Linux systems (default), this creates a dual-stack socket accepting both native IPv6 and IPv4-mapped IPv6 addresses [3](#0-2) 

The source IP extraction happens here: [4](#0-3) 

The `RealIp` extractor returns an `IpAddr` without any IPv4-mapped IPv6 normalization. The codebase contains **no usage** of Rust's standard `Ipv6Addr::to_ipv4()`, `to_ipv4_mapped()`, or `is_ipv4_mapped()` methods, confirming the absence of normalization logic.

Additionally, the logger does not normalize these addresses: [5](#0-4) 

This means logs will show `192.0.2.1` and `::ffff:192.0.2.1` as distinct IP addresses, making manual detection and log-based analysis significantly harder.

## Impact Explanation

This vulnerability allows attackers to:
1. **Bypass IP blocklists**: Continue abusing the faucet after being banned
2. **Bypass rate limiting**: If rate limiting is IP-based, appear as multiple distinct IPs
3. **Evade detection**: Log analysis won't correlate IPv4 and IPv4-mapped IPv6 connections
4. **Drain faucet resources**: Request funds at a higher rate than intended limits

While this is marked as **Low severity** in the security question, it represents a **security control bypass** that could lead to:
- Accelerated depletion of faucet funds
- Unfair distribution of testnet tokens
- Increased operational costs

The severity is appropriately Low because:
- The faucet is not consensus-critical
- No direct impact on validator operations, consensus, or mainnet funds
- Primarily affects testnet token distribution
- Does not compromise blockchain state or integrity

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable when:
1. The faucet is configured to listen on an IPv6 address (common in modern deployments)
2. The system allows dual-stack sockets (default on Linux)
3. An attacker has been IP-blocked

Attack complexity is **Low**:
- No special privileges required
- Trivial to execute (simply connect via IPv6)
- Works from any IPv6-capable network
- Can be automated

However, exploitation requires:
- IPv6-enabled server configuration
- Prior knowledge of being blocked
- IPv6 network connectivity

## Recommendation

Implement IPv4-mapped IPv6 address normalization at the IP extraction point and in filtering logic:

```rust
// In endpoints/fund.rs, after extracting source_ip:
let source_ip = match source_ip.0 {
    Some(IpAddr::V6(ipv6)) => {
        // Normalize IPv4-mapped IPv6 to IPv4
        if let Some(ipv4) = ipv6.to_ipv4() {
            IpAddr::V4(ipv4)
        } else {
            IpAddr::V6(ipv6)
        }
    },
    Some(ip) => ip,
    None => { /* error handling */ }
};
```

Apply the same normalization in:
1. `IpRangeManager::contains_ip()` before checking
2. All logging functions (`HttpRequestLog` structs)
3. Rate limiting logic (`MemoryRatelimitChecker`)

Additionally, document in the IP range file format that IPv4-mapped IPv6 addresses should be added as IPv4 entries (e.g., `192.0.2.1/32` instead of `::ffff:192.0.2.1/128`).

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    
    #[test]
    fn test_ipv4_mapped_ipv6_bypass() {
        // Simulate IPv4 address that should be blocked
        let blocked_ipv4 = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 1));
        
        // Create IPv4-mapped IPv6 version
        let ipv4_mapped = IpAddr::V6(
            Ipv4Addr::new(192, 0, 2, 1).to_ipv6_mapped()
        );
        
        // Current code treats these as different addresses
        match blocked_ipv4 {
            IpAddr::V4(_) => println!("Blocked: IPv4"),
            IpAddr::V6(_) => println!("Would check IPv6 list"),
        }
        
        match ipv4_mapped {
            IpAddr::V4(_) => println!("Would check IPv4 list"),
            IpAddr::V6(_) => println!("Bypasses: treated as IPv6"),
        }
        
        // Demonstrate they represent the same host
        if let IpAddr::V6(v6) = ipv4_mapped {
            assert!(v6.is_ipv4_mapped());
            assert_eq!(v6.to_ipv4().unwrap(), Ipv4Addr::new(192, 0, 2, 1));
        }
        
        // But current IpAddr comparison treats them as different
        assert_ne!(blocked_ipv4, ipv4_mapped);
    }
}
```

To test in the actual faucet environment:
1. Configure faucet to listen on `[::]:8080`
2. Add `192.0.2.1` to the IP blocklist
3. Attempt connection from `192.0.2.1` - should be blocked
4. Attempt connection that appears as `::ffff:192.0.2.1` - will bypass the block
5. Observe logs show both as distinct addresses

## Notes

This vulnerability is **correctly classified as Low severity** because:
- It affects only the faucet service, not core blockchain operations
- No impact on consensus, validators, or mainnet security
- The faucet is designed for testnet token distribution with limited real-world value
- While it represents a security control bypass, the blast radius is contained

The issue is exacerbated by the lack of normalization in logging functions across multiple components (warp-webserver, API logger, faucet logger), making detection and forensic analysis more difficult. However, the primary vulnerability lies in the IP filtering logic, not the logger itself.

For production deployments with real-value token distribution, this should be elevated to Medium severity as it enables "limited funds loss or manipulation."

### Citations

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L195-199)
```rust
        let listener = TcpListener::bind((
            self.server_config.listen_address.clone(),
            self.server_config.listen_port,
        ))
        .await?;
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-warp-webserver/src/log.rs (L18-19)
```rust
        let log = HttpRequestLog {
            remote_addr: info.remote_addr(),
```
