# Audit Report

## Title
Serde Deserialization Bypasses Identifier Validation in API Wrapper Types

## Summary
The `IdentifierWrapper` type uses Serde's derived deserialization which bypasses the validation rules enforced by its `FromStr` implementation and `verify()` method, allowing invalid Move identifiers to be constructed through JSON deserialization.

## Finding Description

The `IdentifierWrapper` struct wraps Move's `Identifier` type and has both `FromStr` and Serde deserialization support: [1](#0-0) 

The `FromStr` implementation properly validates identifiers by calling `Identifier::from_str(s)?`: [2](#0-1) 

The `verify()` method also validates using `Identifier::is_valid()`: [3](#0-2) 

However, the underlying `Identifier` type also has a derived Serde implementation: [4](#0-3) 

The `Identifier` struct wraps a `Box<str>`. When Serde deserializes it with the derived implementation, it directly constructs `Identifier(Box<str>)` **without** calling `Identifier::new()` which performs validation via `is_valid()`: [5](#0-4) 

The validation rules specify that identifiers must start with a letter or underscore/dollar followed by valid characters: [6](#0-5) 

**Critical Invariant Violation**: The `Identifier::Deref` implementation assumes all identifiers are valid with this comment: "Identifier and IdentStr maintain the same invariants, so it is safe to convert." [7](#0-6) 

This assumption is broken when Serde deserialization bypasses validation, creating `Identifier` instances with invalid content.

**Usage in Security-Critical Contexts**: `IdentifierWrapper` is used as map keys in `MoveStructValue`: [8](#0-7) 

It's also used in `MoveStructTag` for module and struct names, which are used in type checking and state key construction.

## Impact Explanation

**Severity Assessment: Medium**

While this is a validation bypass vulnerability, the impact is limited because:

1. **Limited Attack Surface**: After thorough investigation, I could not identify user-facing API endpoints that accept `MoveStructValue`, `MoveResource`, or other types containing `IdentifierWrapper` as POST/PUT request bodies. These types appear to be primarily used in API responses.

2. **Potential for State Corruption**: If any internal code paths or future features deserialize JSON containing these types from untrusted sources, invalid identifiers could:
   - Cause panics when code assumes identifiers are valid
   - Lead to incorrect module/function lookups
   - Corrupt state keys in storage operations
   - Potentially cause consensus divergence if validators deserialize different invalid identifiers

3. **Latent Vulnerability**: Even without current exploitation, this creates a dangerous pattern where any future code using JSON deserialization for these types will bypass validation.

## Likelihood Explanation

**Likelihood: Low to Medium**

Current exploitation is unlikely because:
- Transactions use BCS encoding, not JSON
- The API primarily uses these types for responses, not requests
- I found no evidence of JSON deserialization from untrusted sources in production code paths

However, the likelihood increases if:
- Future features add endpoints accepting these types as input
- Internal tools or debugging interfaces deserialize from JSON
- State sync or backup mechanisms use JSON format

## Recommendation

Implement custom Serde deserialization for `Identifier` that enforces validation:

```rust
// In third_party/move/move-core/types/src/identifier.rs

impl<'de> Deserialize<'de> for Identifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        Identifier::new(s).map_err(serde::de::Error::custom)
    }
}
```

This ensures that all deserialization paths (FromStr, Serde JSON, Serde BCS) enforce the same validation rules.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use move_core_types::identifier::Identifier;
    use serde_json;

    #[test]
    fn test_identifier_validation_bypass() {
        // This should fail - identifiers cannot start with digits
        let invalid_json = r#""123invalid""#;
        
        // FromStr properly validates and rejects
        let from_str_result = invalid_json.trim_matches('"').parse::<Identifier>();
        assert!(from_str_result.is_err(), "FromStr should reject invalid identifier");
        
        // But Serde deserialization bypasses validation!
        let from_serde: Result<Identifier, _> = serde_json::from_str(invalid_json);
        assert!(from_serde.is_ok(), "Serde deserialization bypasses validation");
        
        let invalid_identifier = from_serde.unwrap();
        
        // Now we have an Identifier with invalid content
        // This violates the invariant that Identifier maintains valid content
        assert!(!Identifier::is_valid(invalid_identifier.as_str()));
        
        // This could cause issues in code that assumes identifiers are valid
        // For example, when constructing state keys or performing module lookups
    }
}
```

**Notes**

After extensive investigation, I identified that `IdentifierWrapper` (and its underlying `Identifier` type) can bypass validation during JSON deserialization. However, I could not find a concrete attack path in the current codebase where an unprivileged attacker could exploit this to affect consensus, steal funds, or compromise node security.

The issue is primarily a **code quality and defense-in-depth concern** rather than an immediately exploitable vulnerability. The validation bypass creates technical debt and a latent risk for future features.

For `EventGuid` and `StateKeyWrapper`:
- **EventGuid**: Safe - only contains validated primitive types (`U64` and `Address`)
- **StateKeyWrapper**: Safe - `StateKey` has a custom Deserialize implementation that calls validation via `from_deserialized()` [9](#0-8)

### Citations

**File:** api/types/src/wrappers.rs (L22-23)
```rust
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, Deserialize)]
pub struct IdentifierWrapper(pub Identifier);
```

**File:** api/types/src/wrappers.rs (L25-33)
```rust
impl VerifyInput for IdentifierWrapper {
    fn verify(&self) -> anyhow::Result<()> {
        if Identifier::is_valid(self.as_str()) {
            Ok(())
        } else {
            bail!("Identifier is invalid {}", self)
        }
    }
}
```

**File:** api/types/src/wrappers.rs (L35-41)
```rust
impl FromStr for IdentifierWrapper {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        Ok(IdentifierWrapper(Identifier::from_str(s)?))
    }
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L109-114)
```rust
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, Deserialize)]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
pub struct Identifier(Box<str>);
```

**File:** third_party/move/move-core/types/src/identifier.rs (L119-126)
```rust
    pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
        let s = s.into();
        if Self::is_valid(&s) {
            Ok(Self(s))
        } else {
            bail!("Invalid identifier '{}'", s);
        }
    }
```

**File:** third_party/move/move-core/types/src/identifier.rs (L196-197)
```rust
        // Identifier and IdentStr maintain the same invariants, so it is safe to
        // convert.
```

**File:** api/types/src/move_types.rs (L235-235)
```rust
pub struct MoveStructValue(pub BTreeMap<IdentifierWrapper, serde_json::Value>);
```

**File:** types/src/state_store/state_key/mod.rs (L251-259)
```rust
impl<'de> Deserialize<'de> for StateKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let inner = StateKeyInner::deserialize(deserializer)?;
        Self::from_deserialized(inner).map_err(Error::custom)
    }
}
```
