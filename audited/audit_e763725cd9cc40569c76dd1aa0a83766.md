# Audit Report

## Title
Man-in-the-Middle Attack on Move Package Resolution via Unauthenticated Network Version Queries

## Summary
The Move package resolver's `resolve_network_version()` function fetches ledger version information from fullnodes without cryptographic verification. An attacker exploiting DNS or BGP hijacking can redirect these requests to malicious servers that provide fake version numbers, leading to the download and compilation of malicious Move package bytecode.

## Finding Description

The vulnerability exists in the package resolution workflow used by Move developers when building projects with on-chain dependencies: [1](#0-0) 

This function creates an unauthenticated HTTP client and queries the fullnode for ledger information: [2](#0-1) 

The REST client performs a simple HTTP request without cryptographic proof verification: [3](#0-2) 

Critically, Aptos provides cryptographic verification mechanisms (`TrustedState::verify_and_ratchet()`, `StateProof`, `LedgerInfoWithSignatures`) that could verify the authenticity of ledger state, but these are **not used** by the package resolver.

When fetching packages, there is also no integrity verification: [4](#0-3) 

**Attack Flow:**
1. Developer builds a Move project with on-chain dependencies specified in `Move.toml`
2. Attacker performs DNS hijacking (compromising domain registrar) or BGP hijacking (manipulating routing tables) to redirect `fullnode_url` to malicious server
3. `resolve_network_version()` connects to attacker's server, which returns an arbitrary version number
4. This fake version is cached in the lock file
5. `fetch_on_chain_package()` fetches package bytecode from the malicious server using the fake version
6. Developer compiles and potentially deploys malicious Move modules
7. If deployed, users interacting with the malicious contract could lose funds

## Impact Explanation

This vulnerability could lead to **Loss of Funds** (Critical severity) through the following path:
- Malicious packages compiled into developer's application
- Developer deploys compromised contracts to mainnet without detecting the substitution
- Users interact with malicious contracts and lose assets

However, the impact is **indirect** and requires:
- Sophisticated network-level attack capability (DNS/BGP hijacking)
- Developer failing to notice unexpected behavior during testing
- Successful deployment to production

While HTTPS provides transport security against passive eavesdropping, it does **not** protect against:
- DNS hijacking where attacker controls the domain resolution
- BGP hijacking where traffic is routed to attacker's infrastructure with valid certificates
- Compromised or malicious fullnode operators

The severity is mitigated by the fact that this affects **developer tooling** rather than the blockchain protocol itself, and requires both network-level attack and developer error to materialize into actual harm.

## Likelihood Explanation

**Likelihood: Medium-Low**

DNS/BGP hijacking attacks require significant capability but are not theoretical:
- BGP hijacking has successfully targeted cryptocurrency services (e.g., MyEtherWallet 2018)
- DNS hijacking via compromised registrars has occurred multiple times
- Developers may use untrusted or compromised fullnode URLs

Mitigating factors:
- Most developers use official/trusted fullnode URLs
- HTTPS certificate validation provides partial protection
- Code review processes may catch unexpected changes
- The attack requires precise timing during package resolution

## Recommendation

Implement cryptographic verification of fullnode responses using Aptos's existing `TrustedState` mechanism:

1. **For version queries**: Verify `LedgerInfoWithSignatures` using `TrustedState::verify_and_ratchet()`
2. **For package fetching**: Verify Merkle proofs against the authenticated state root
3. **For cached packages**: Implement content integrity verification (as noted in TODO comment)

The package resolver should:
- Initialize with a trusted genesis state or well-known validator set
- Request state proofs alongside version information
- Verify validator signatures before accepting version numbers
- Validate Merkle proofs for all downloaded package bytecode

This aligns with Aptos's security architecture where state proofs enable trustless verification.

## Proof of Concept

**Setup Malicious Server:**
```rust
// Proof of concept demonstrating the vulnerability
// Note: Requires setting up a mock HTTP server

use warp::Filter;

#[tokio::main]
async fn main() {
    // Malicious server that returns fake ledger info
    let route = warp::path::end()
        .map(|| {
            warp::reply::json(&serde_json::json!({
                "chain_id": 1,
                "epoch": "1000",
                "ledger_version": "999999999", // Fake version
                "ledger_timestamp": "1234567890",
                "oldest_ledger_version": "0",
                "oldest_block_height": "0",
                "block_height": "999999"
            }))
        });
    
    warp::serve(route).run(([127, 0, 0, 1], 8080)).await;
}
```

**Exploitation Steps:**
1. Modify `/etc/hosts` or DNS to point fullnode domain to malicious server
2. Run Move package resolver: `aptos move compile`
3. Observe that fake version `999999999` is written to lock file
4. Package fetching queries non-existent version from malicious server
5. Malicious server can serve arbitrary bytecode

**Notes**

This vulnerability represents a gap between Aptos's robust cryptographic security architecture (which includes state proofs and validator signatures) and its practical implementation in developer tooling. While the blockchain protocol itself maintains strong security guarantees, the developer tools do not leverage these mechanisms, creating a potential supply chain attack vector.

The issue is particularly concerning because:
1. Developers trust the package resolution system for dependency management
2. The lock file mechanism is designed for build reproducibility but can be poisoned
3. There's an explicit TODO comment acknowledging the lack of integrity verification

However, it's important to note that this affects the **development workflow** rather than the blockchain runtime, and successful exploitation requires both sophisticated network-level attacks and failures in development/deployment processes.

### Citations

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L90-106)
```rust
    pub async fn resolve_network_version(&mut self, fullnode_url: &Url) -> Result<u64> {
        let node_identity = CanonicalNodeIdentity::new(fullnode_url)?;

        let res = match self.on_chain.entry(node_identity.to_string()) {
            btree_map::Entry::Occupied(entry) => *entry.get(),
            btree_map::Entry::Vacant(entry) => {
                let client = aptos_rest_client::Client::new(fullnode_url.clone());
                let version = client.get_ledger_information().await?.into_inner().version;

                entry.insert(version);

                version
            },
        };

        Ok(res)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L397-414)
```rust
    pub async fn get_ledger_information(&self) -> AptosResult<Response<State>> {
        let response = self.get_index_bcs().await?.map(|r| State {
            chain_id: r.chain_id,
            epoch: r.epoch.into(),
            version: r.ledger_version.into(),
            timestamp_usecs: r.ledger_timestamp.into(),
            oldest_ledger_version: r.oldest_ledger_version.into(),
            oldest_block_height: r.oldest_block_height.into(),
            block_height: r.block_height.into(),
            cursor: None,
        });
        assert_eq!(response.inner().chain_id, response.state().chain_id);
        assert_eq!(response.inner().epoch, response.state().epoch);
        assert_eq!(response.inner().version, response.state().version);
        assert_eq!(response.inner().block_height, response.state().block_height);

        Ok(response)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L300-305)
```rust
        // If the package directory already exists, assume it has been cached.
        if cached_package_path.exists() {
            // TODO: In the future, consider verifying data integrity,
            //       e.g. hash of metadata or full contents.
            return Ok(cached_package_path);
        }
```
