# Audit Report

## Title
Struct Name Index Map Cache Size Enforcement Only at Block Boundaries Enables Intra-Block Memory Exhaustion

## Summary
The `struct_name_index_map` cache in the Move VM runtime environment is only checked and flushed at block boundaries, not during transaction execution within a block. This allows an attacker to publish multiple modules with many unique struct names in a single block, causing the cache to grow unbounded during block execution and potentially exhausting validator memory before the size limit is enforced.

## Finding Description

The vulnerability exists due to three critical design decisions that interact unsafely:

**1. Cache Population Without Size Checks During Execution**

When modules are loaded, `Module::new()` iterates through ALL struct handles and populates the cache without any size validation: [1](#0-0) 

The `struct_name_to_idx()` function inserts entries using a double-checked locking pattern with NO size limit enforcement during insertion: [2](#0-1) 

**2. Shared Cache Architecture**

The `struct_name_index_map` is wrapped in an `Arc` within the `RuntimeEnvironment`: [3](#0-2) 

When the environment is cloned for module publishing, it uses `Arc::clone()`, meaning ALL clones share the SAME underlying cache: [4](#0-3) 

During module publishing, a cloned environment is created but it modifies the shared global cache: [5](#0-4) 

**3. Block-Boundary-Only Size Enforcement**

The cache size is ONLY checked in `ModuleCacheManager::check_ready()`, which runs at block boundaries: [6](#0-5) 

This method is called exactly ONCE at the beginning of block execution via `try_lock()`: [7](#0-6) 

**4. No Production Limits on Struct Definitions**

The Aptos production verifier configuration sets no limit on struct definitions per module: [8](#0-7) 

While the default cache limit is 1 million entries: [9](#0-8) 

**Attack Path:**

1. Attacker creates modules with many struct handles (references to both local and external structs). Note that `StructHandle` includes a `module` field allowing external references: [10](#0-9) 

2. Within a single block, attacker publishes multiple such modules across different transactions (limited only by block gas limit and complexity budget of 80,000,000 per module): [11](#0-10) 

3. During each transaction's execution, modules are staged and verified, eventually calling `Module::new()` which populates the shared `struct_name_index_map` 

4. Cache grows beyond the 1,000,000 entry limit during block execution

5. Memory exhaustion occurs on validators before the next block's `check_ready()` call

**Why This Breaks Security Invariants:**

This violates the Move VM's fundamental safety guarantee that "bytecode execution must respect gas limits and memory constraints." While gas is charged for module complexity, the global shared cache can grow unbounded within a block because size enforcement happens AFTER block completion, not during execution.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

**Validator Node Slowdowns/Crashes (High):**
- Memory exhaustion during block execution can cause validators to slow down significantly or crash due to out-of-memory conditions
- Matches the bounty category: "DoS through resource exhaustion"

**Consensus Disruption:**
- If multiple validators crash simultaneously while processing the same block, consensus can stall
- All validators execute the same transactions deterministically, so all validators experience identical memory pressure

**Why Not Critical:**
- Does not directly cause fund loss or permanent state corruption
- Is recoverable (validators restart, cache flushes at next block)
- Requires sustained attack across multiple blocks to be persistently disruptive

However, it represents a significant protocol violation that can degrade network performance and availability, qualifying as HIGH severity under the bug bounty program's definition of "Significant performance degradation affecting consensus."

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to publish modules (requires gas payment but no special privileges)
- Understanding of Move module structure and bytecode format
- Sufficient funds for gas costs across multiple transactions

**Feasibility Analysis:**
- Complexity budget of 80,000,000 per module allows many struct handles
- Block gas limit allows hundreds of transactions per block
- With conservative estimates (2,000 unique struct names per module Ã— 500 modules), the 1,000,000 entry limit is reachable
- Modules can reference external structs, multiplying the cache entries

**Detection Difficulty:**
- Attack is visible in transaction history (module publishing transactions)
- However, damage occurs before mitigation can be applied
- Monitoring cache size during execution would require runtime instrumentation

The attack is technically feasible for any motivated actor with moderate resources.

## Recommendation

Implement intra-block cache size monitoring with two approaches:

1. **Add size checks during cache population:**
   - Modify `struct_name_to_idx()` to check cache size before insertion
   - Return an error if adding the entry would exceed the limit
   - This provides immediate protection but may cause transaction failures

2. **Implement per-transaction cache growth limits:**
   - Track cache growth per transaction
   - Charge additional gas or reject transactions that cause excessive cache growth
   - This aligns with the principle that resource consumption should be metered

3. **Consider enabling production limits:**
   - Set `max_struct_definitions` to a reasonable value in production config
   - This provides defense-in-depth by limiting per-module impact

## Proof of Concept

A full PoC would require:
1. Creating multiple Move modules, each with the maximum allowed struct handles referencing unique external modules
2. Submitting these modules in separate transactions within a single block
3. Monitoring validator memory consumption during block execution
4. Demonstrating that cache size exceeds 1M entries before the next block boundary check

The conceptual PoC is validated by the code paths shown above, though a runnable implementation would require significant setup and resources to trigger on a test network.

## Notes

This vulnerability demonstrates a gap between per-transaction resource metering (via gas) and global shared resource management (via cache size limits). The cache is designed as a performance optimization, but its unbounded growth during block execution creates a security risk. The fix should ensure that resource constraints are enforced continuously during execution, not just at block boundaries.

### Citations

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L195-203)
```rust
        for struct_handle in module.struct_handles() {
            let struct_name = module.identifier_at(struct_handle.name);
            let module_handle = module.module_handle_at(struct_handle.module);
            let module_id = module.module_id_for_handle(module_handle);
            let struct_name =
                StructIdentifier::new(module_id_pool, module_id, struct_name.to_owned());
            struct_idxs.push(struct_name_index_map.struct_name_to_idx(&struct_name)?);
            struct_names.push(struct_name)
        }
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L70-99)
```rust
    pub fn struct_name_to_idx(
        &self,
        struct_name: &StructIdentifier,
    ) -> PartialVMResult<StructNameIndex> {
        {
            let index_map = self.0.read();
            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }
        }

        // Possibly need to insert, so make the copies outside of the lock.
        let forward_key = struct_name.clone();
        let backward_value = Arc::new(struct_name.clone());

        let idx = {
            let mut index_map = self.0.write();

            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }

            let idx = index_map.backward_map.len() as u32;
            index_map.backward_map.push(backward_value);
            index_map.forward_map.insert(forward_key, idx);
            idx
        };

        Ok(StructNameIndex(idx))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L63-63)
```rust
    struct_name_index_map: Arc<StructNameIndexMap>,
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L435-435)
```rust
            struct_name_index_map: Arc::clone(&self.struct_name_index_map),
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L128-128)
```rust
        let staged_runtime_environment = existing_module_storage.runtime_environment().clone();
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L136-146)
```rust
        let struct_name_index_map_size = runtime_environment
            .struct_name_index_map_size()
            .map_err(|err| err.finish(Location::Undefined).into_vm_status())?;
        STRUCT_NAME_INDEX_MAP_NUM_ENTRIES.set(struct_name_index_map_size as i64);

        // If the environment caches too many struct names, flush type caches. Also flush module
        // caches because they contain indices for struct names.
        if struct_name_index_map_size > config.max_struct_name_index_map_num_entries {
            runtime_environment.flush_all_caches();
            self.module_cache.flush();
        }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L539-543)
```rust
        let mut module_cache_manager_guard = module_cache_manager.try_lock(
            &state_view,
            &config.local.module_cache_config,
            transaction_slice_metadata,
        )?;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-168)
```rust
        max_struct_definitions: None,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L176-176)
```rust
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** types/src/block_executor/config.rs (L38-38)
```rust
            max_struct_name_index_map_num_entries: 1_000_000,
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L279-281)
```rust
pub struct StructHandle {
    /// The module that defines the type.
    pub module: ModuleHandleIndex,
```
