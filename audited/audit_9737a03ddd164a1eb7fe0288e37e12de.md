# Audit Report

## Title
Rosetta API Reports Inflated Staking Balance Including Non-Withdrawable Pending Active Stake

## Summary
The Rosetta API balance calculation for staking contracts incorrectly includes `pending_active` stake in the reported balance, which cannot be withdrawn until the next epoch. This misleads users about their immediately available liquidity and violates the expectation that reported balances reflect withdrawable amounts.

## Finding Description

The vulnerability exists in how the Rosetta API calculates staking contract balances. When users query their staking balance through the `/account/balance` endpoint with an "active_stake" sub-account, the API reports a balance that includes both `active` and `pending_active` stake, but only `active` stake can actually be withdrawn.

**Code Flow:**

1. The Rosetta API iterates through staking contracts in `get_staking_info()`: [1](#0-0) 

2. For each contract, it calls `get_stake_balances()` which queries the `staking_contract_amounts` view function: [2](#0-1) 

3. The Move function `get_staking_contract_amounts_internal()` calculates `total_active_stake` as the sum of `active` + `pending_active`: [3](#0-2) 

4. However, when users attempt withdrawal via `unlock_stake()`, only the `active` portion can be unlocked: [4](#0-3) 

**The Discrepancy:**

According to the stake pool documentation, `pending_active` represents newly added stake that won't become active until the next epoch: [5](#0-4) 

**Example Scenario:**
- Active stake: 1,000 APT
- Pending active stake: 200 APT (recently added, not yet activated)
- Principal: 1,000 APT
- Commission rate: 10%

Rosetta reports: `(1,000 + 200) - 20 = 1,180 APT`
Actually withdrawable: `1,000 APT` (minus extracted commission â‰ˆ 990 APT)

The user sees 1,180 APT but can only withdraw ~990 APT, a discrepancy of ~190 APT.

**Additional Issue - Future Slashing Vulnerability:**

If slashing were ever implemented and reduced stake below the original principal, line 1067 would cause arithmetic underflow: [6](#0-5) 

This would abort the view function, causing the Rosetta API to report zero balance for slashed pools instead of showing remaining withdrawable funds.

## Impact Explanation

**Primary Issue - Medium Severity ($10,000 category):**
This constitutes "Limited funds loss or manipulation" as users may make incorrect financial decisions based on inflated balance reports. While no funds are directly stolen, users are misled about liquidity, potentially causing:
- Incorrect trading decisions based on perceived available liquidity
- Failed withdrawal attempts when users expect to withdraw the full reported balance
- Loss of trust in the Rosetta API balance reporting

The TODO comment at line 342 of `misc.rs` indicates developers were aware of potential accuracy issues: [7](#0-6) 

**Secondary Issue (if slashing implemented) - High Severity:**
If slashing is implemented, the arithmetic underflow would cause complete balance reporting failure for affected pools, potentially hiding remaining recoverable funds from users.

## Likelihood Explanation

**High Likelihood:** This occurs whenever:
1. A user has a staking contract with pending_active stake
2. They query their balance through the Rosetta API with "active_stake" sub-account
3. No special conditions or attacker actions required - this is normal protocol behavior

The issue affects all staking contract users who add stake between epochs, making it a systematic problem rather than an edge case.

## Recommendation

**Fix 1: Report only `active` stake for "active_stake" queries**

Modify `get_staking_contract_amounts_internal()` to return both `active` and `pending_active` separately, or create a new view function that returns only immediately withdrawable amounts.

**Fix 2: Update Rosetta API documentation**

Clearly document that "active_stake" balance includes pending_active and may not be immediately withdrawable. Provide separate sub-account types for:
- `immediately_withdrawable_stake`: Returns only `active` minus pending commission
- `total_active_stake`: Returns `active + pending_active` (current behavior)

**Fix 3: Prevent future underflow if slashing implemented**

Replace line 1067 with safe arithmetic:
```move
let accumulated_rewards = if (total_active_stake >= staking_contract.principal) {
    total_active_stake - staking_contract.principal
} else {
    0  // Pool has been slashed below principal
};
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::staking_contract_balance_test {
    use aptos_framework::staking_contract;
    use aptos_framework::stake;
    use aptos_framework::account;
    use std::signer;
    
    #[test(aptos_framework = @aptos_framework, staker = @0x123, operator = @0x456)]
    public entry fun test_balance_discrepancy(
        aptos_framework: &signer,
        staker: &signer,
        operator: &signer,
    ) {
        // Setup staking contract
        let staker_addr = signer::address_of(staker);
        let operator_addr = signer::address_of(operator);
        
        // Initial stake: 1000 APT
        staking_contract::create_staking_contract(
            staker,
            operator_addr,
            operator_addr,
            1000_00000000,  // 1000 APT
            10,  // 10% commission
            vector::empty()
        );
        
        // Add more stake which goes to pending_active: 200 APT
        staking_contract::add_stake(staker, operator_addr, 200_00000000);
        
        // Query balance through staking_contract_amounts
        let (total_active, rewards, commission) = 
            staking_contract::staking_contract_amounts(staker_addr, operator_addr);
        
        // Rosetta would report: total_active - commission
        let reported_balance = total_active - commission;
        
        // Try to unlock the reported balance
        // This will fail or only unlock the active portion
        staking_contract::unlock_stake(staker, operator_addr, reported_balance);
        
        // The actual unlocked amount will be less than reported_balance
        // because pending_active cannot be unlocked
        
        // Assert: reported_balance > actually_withdrawable
        // This demonstrates the discrepancy
    }
}
```

**Notes:**
- The Rosetta API balance calculation systematically overstates withdrawable amounts when `pending_active` stake exists
- This breaks user trust and violates the reasonable expectation that reported balances reflect available funds
- The TODO comment suggests this may be a known limitation, but it remains unfixed
- If slashing is implemented without fixing the underflow issue, the problem becomes more severe

### Citations

**File:** crates/aptos-rosetta/src/account.rs (L218-242)
```rust
    if let Ok(response) = rest_client
        .get_account_resource_at_version_bcs(owner_address, "0x1::staking_contract::Store", version)
        .await
    {
        let store: Store = response.into_inner();
        maybe_operators = Some(vec![]);
        for (operator, contract) in store.staking_contracts {
            // Keep track of operators
            maybe_operators.as_mut().unwrap().push(operator);
            match get_stake_balances(rest_client, account, contract.pool_address, version).await {
                Ok(Some(balance_result)) => {
                    if let Some(balance) = balance_result.balance {
                        has_staking = true;
                        total_balance += u64::from_str(&balance.value).unwrap_or_default();
                    }
                    // TODO: This seems like it only works if there's only one staking contract (hopefully it stays that way)
                    lockup_expiration = balance_result.lockup_expiration;
                },
                result => {
                    warn!(
                        "Failed to retrieve requested balance for account: {}, address: {}: {:?}",
                        owner_address, contract.pool_address, result
                    )
                },
            }
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L325-347)
```rust
        let staking_contract_amounts_response = view::<Vec<u64>>(
            rest_client,
            version,
            AccountAddress::ONE,
            ident_str!(STAKING_CONTRACT_MODULE),
            ident_str!("staking_contract_amounts"),
            vec![],
            vec![
                bcs::to_bytes(&owner_address)?,
                bcs::to_bytes(&operator_address)?,
            ],
        )
        .await?;
        let total_active_stake = staking_contract_amounts_response[0];
        let accumulated_rewards = staking_contract_amounts_response[1];
        let commission_amount = staking_contract_amounts_response[2];

        // TODO: I think all of these are off, probably need to recalculate all of them
        // see the get_staking_contract_amounts_internal function in staking_contract.move for more
        // information on why commission is only subtracted from active and total stake
        if owner_account.is_active_stake() {
            // active stake is principal and rewards (including commission) so subtract the commission
            requested_balance = Some((total_active_stake - commission_amount).to_string());
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L761-767)
```text
        // If there's less active stake remaining than the amount requested (potentially due to commission),
        // only withdraw up to the active amount.
        let (active, _, _, _) = stake::get_stake(staking_contract.pool_address);
        if (active < amount) {
            amount = active;
        };
        staking_contract.principal = staking_contract.principal - amount;
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1057-1072)
```text
    fun get_staking_contract_amounts_internal(
        staking_contract: &StakingContract
    ): (u64, u64, u64) {
        // Pending_inactive is not included in the calculation because pending_inactive can only come from:
        // 1. Outgoing commissions. This means commission has already been extracted.
        // 2. Stake withdrawals from stakers. This also means commission has already been extracted as
        // request_commission_internal is called in unlock_stake
        let (active, _, pending_active, _) =
            stake::get_stake(staking_contract.pool_address);
        let total_active_stake = active + pending_active;
        let accumulated_rewards = total_active_stake - staking_contract.principal;
        let commission_amount =
            accumulated_rewards * staking_contract.commission_percentage / 100;

        (total_active_stake, accumulated_rewards, commission_amount)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L114-124)
```text
    /// Each validator has a separate StakePool resource and can provide a stake.
    /// Changes in stake for an active validator:
    /// 1. If a validator calls add_stake, the newly added stake is moved to pending_active.
    /// 2. If validator calls unlock, their stake is moved to pending_inactive.
    /// 2. When the next epoch starts, any pending_inactive stake is moved to inactive and can be withdrawn.
    ///    Any pending_active stake is moved to active and adds to the validator's voting power.
    ///
    /// Changes in stake for an inactive validator:
    /// 1. If a validator calls add_stake, the newly added stake is moved directly to active.
    /// 2. If validator calls unlock, their stake is moved directly to inactive.
    /// 3. When the next epoch starts, the validator can be activated if their active stake is more than the minimum.
```
