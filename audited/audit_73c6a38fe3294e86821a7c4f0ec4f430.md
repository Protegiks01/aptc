# Audit Report

## Title
Unvalidated Config Values Cause Table Info Indexer Service Panic on Zero Values

## Summary
The `IndexerTableInfoConfig` struct accepts `parser_batch_size` value of 0 through YAML deserialization without validation, causing a panic in `TableInfoService::process_transactions_in_parallel()` when the Rust `chunks()` method is called with a zero-sized chunk. This permanently crashes the table info indexer service, requiring manual node restart and configuration fix.

## Finding Description

The `IndexerTableInfoConfig` struct defines two configuration parameters without validation: [1](#0-0) 

These fields are deserialized directly from YAML configuration files using serde with no range validation. The default values are non-zero, but an operator can override them: [2](#0-1) 

The configuration values are passed directly to the `TableInfoService` without validation: [3](#0-2) 

The panic occurs in `process_transactions_in_parallel()` when `parser_batch_size` is 0: [4](#0-3) 

In Rust, calling `.chunks(0)` on a slice panics with "chunk size must be non-zero". The service spawns in a tokio task without panic recovery: [5](#0-4) 

**Attack Path:**
1. Operator (or attacker with config file access) sets `parser_batch_size: 0` in fullnode.yaml
2. Node starts successfully and loads the invalid configuration
3. When the indexer service processes its first batch of transactions, it calls `.chunks(0)`
4. The Rust runtime panics: "thread panicked at 'chunk size must be non-zero'"
5. The indexer service task terminates permanently
6. Table info indexing stops completely until manual intervention

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **API Crashes**: The table info indexer service crash impacts API endpoints that depend on table metadata, causing degraded API functionality.

2. **Service Disruption**: The indexer service cannot self-recover and requires manual node restart with corrected configuration.

3. **Lack of Graceful Degradation**: Instead of failing gracefully with a validation error at startup or configuration load time, the service panics during operation.

While this does not bring down the entire validator/fullnode process (the panic is contained to the spawned tokio task), it permanently disables a critical indexing service that API nodes and ecosystem tools depend on.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through:
- **Configuration Error**: Operator typo or misconfiguration (e.g., `parser_batch_size: 0` instead of `parser_batch_size: 1000`)
- **Automated Config Generation**: Scripts generating invalid configurations
- **Compromised Systems**: Attacker with filesystem access modifying configuration files
- **Copy-Paste Errors**: Operators copying incomplete configuration examples

The lack of validation at any layer (deserialization, sanitization, or runtime) makes this easily triggerable. There is no ConfigSanitizer implementation for IndexerTableInfoConfig to catch invalid values before service startup: [6](#0-5) 

## Recommendation

Implement validation at multiple layers:

**1. Add ConfigSanitizer implementation for IndexerTableInfoConfig:**

```rust
impl ConfigSanitizer for IndexerTableInfoConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.indexer_table_info;
        
        if config.table_info_service_mode.is_enabled() {
            if config.parser_task_count == 0 {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "parser_task_count must be greater than 0".to_string(),
                ));
            }
            if config.parser_batch_size == 0 {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "parser_batch_size must be greater than 0".to_string(),
                ));
            }
        }
        Ok(())
    }
}
```

**2. Add runtime validation in TableInfoService::new():**

```rust
pub fn new(
    context: Arc<ApiContext>,
    request_start_version: u64,
    parser_task_count: u16,
    parser_batch_size: u16,
    backup_restore_operator: Option<Arc<GcsBackupRestoreOperator>>,
    indexer_async_v2: Arc<IndexerAsyncV2>,
) -> anyhow::Result<Self> {
    if parser_batch_size == 0 {
        return Err(anyhow!("parser_batch_size must be greater than 0"));
    }
    if parser_task_count == 0 {
        return Err(anyhow!("parser_task_count must be greater than 0"));
    }
    
    Ok(Self {
        current_version: AtomicU64::new(request_start_version),
        parser_task_count,
        parser_batch_size,
        context,
        backup_restore_operator,
        indexer_async_v2,
        aborted: AtomicBool::new(false),
    })
}
```

**3. Add serde validation using custom deserializer or const generic bounds (Rust 1.51+):**

```rust
use serde::{Deserialize, Deserializer};

fn deserialize_nonzero_u16<'de, D>(deserializer: D) -> Result<u16, D::Error>
where
    D: Deserializer<'de>,
{
    let value = u16::deserialize(deserializer)?;
    if value == 0 {
        return Err(serde::de::Error::custom("value must be greater than 0"));
    }
    Ok(value)
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerTableInfoConfig {
    #[serde(deserialize_with = "deserialize_nonzero_u16")]
    pub parser_task_count: u16,
    
    #[serde(deserialize_with = "deserialize_nonzero_u16")]
    pub parser_batch_size: u16,
    
    pub table_info_service_mode: TableInfoServiceMode,
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[should_panic(expected = "chunk size must be non-zero")]
    fn test_zero_parser_batch_size_causes_panic() {
        // This demonstrates the panic when parser_batch_size is 0
        let transactions = vec![1, 2, 3, 4, 5];
        let parser_batch_size: usize = 0;
        
        // This will panic with "chunk size must be non-zero"
        let _chunks: Vec<_> = transactions.chunks(parser_batch_size).collect();
    }
    
    #[test]
    fn test_config_accepts_zero_values() {
        // Demonstrates that the config accepts 0 values without validation
        let yaml = r#"
parser_task_count: 0
parser_batch_size: 0
table_info_service_mode: !IndexingOnly
"#;
        
        let config: IndexerTableInfoConfig = serde_yaml::from_str(yaml).unwrap();
        assert_eq!(config.parser_task_count, 0);
        assert_eq!(config.parser_batch_size, 0);
        // No validation error occurs during deserialization
    }
}
```

**Notes**

The vulnerability is present in the current codebase but would only manifest when:
1. The table info service is enabled (`table_info_service_mode` is not `Disabled`)
2. Invalid configuration values (0) are provided
3. The service attempts to process transactions

While the panic is contained to the indexer service task and doesn't crash the entire node process, it represents a failure to implement defensive validation and graceful error handling. This violates the principle of fail-safe defaults and could lead to unexpected service outages in production environments.

### Citations

**File:** config/src/config/indexer_table_info_config.rs (L7-8)
```rust
pub const DEFAULT_PARSER_TASK_COUNT: u16 = 20;
pub const DEFAULT_PARSER_BATCH_SIZE: u16 = 1000;
```

**File:** config/src/config/indexer_table_info_config.rs (L29-36)
```rust
pub struct IndexerTableInfoConfig {
    /// Number of processor tasks to fan out
    pub parser_task_count: u16,

    /// Number of transactions each parser will process
    pub parser_batch_size: u16,
    pub table_info_service_mode: TableInfoServiceMode,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/runtime.rs (L83-110)
```rust
    runtime.spawn(async move {
        let context = Arc::new(Context::new(
            chain_id,
            db_rw.reader.clone(),
            mp_sender,
            node_config.clone(),
            None,
        ));

        // DB backup is optional
        let backup_restore_operator = match node_config.indexer_table_info.table_info_service_mode {
            TableInfoServiceMode::Backup(gcs_bucket_name) => Some(Arc::new(
                GcsBackupRestoreOperator::new(gcs_bucket_name).await,
            )),
            _ => None,
        };

        let parser = TableInfoService::new(
            context,
            indexer_async_v2_clone.next_version(),
            node_config.indexer_table_info.parser_task_count,
            node_config.indexer_table_info.parser_batch_size,
            backup_restore_operator,
            indexer_async_v2_clone,
        );

        parser.run().await;
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L258-262)
```rust
        for (chunk_idx, batch_size) in transactions
            .chunks(self.parser_batch_size as usize)
            .enumerate()
            .map(|(idx, chunk)| (idx, chunk.len()))
        {
```

**File:** config/src/config/indexer_grpc_config.rs (L103-128)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
}
```
