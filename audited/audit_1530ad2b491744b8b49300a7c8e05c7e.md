# Audit Report

## Title
Feature Flag Proposal Generation Bypass via Multi-Entry Update Sequence Manipulation

## Summary
The `has_modified()` function in the feature flag release builder performs individual validation on each `FeatureFlag` entry in an update sequence, rather than on the consolidated result after squashing. This allows an attacker to craft governance proposals with conflicting feature flag entries where some entries bypass proposal script generation, resulting in a final on-chain state that differs from the expected consolidated state.

## Finding Description

The vulnerability exists in the mismatch between **proposal generation** and **validation** logic for feature flags:

**During Generation**: Each `FeatureFlag` entry in `update_sequence` is processed individually. The `has_modified()` function checks each entry against the current on-chain state to determine if a proposal script should be generated. [1](#0-0) 

**During Validation**: Multiple `FeatureFlag` entries are consolidated using the `squash()` method before validation. [2](#0-1) 

The `has_modified()` function only detects modifications by checking if features in the `enabled` list are not currently enabled, or if features in the `disabled` list are currently enabled: [3](#0-2) 

**Attack Scenario**:

An attacker creates a proposal with `update_sequence` containing:
- **Entry 1**: `FeatureFlag { enabled: [CriticalFeatureX], disabled: [] }`
- **Entry 2**: `FeatureFlag { enabled: [], disabled: [CriticalFeatureX] }`

Assume `CriticalFeatureX` is currently **disabled** on-chain.

**Processing Entry 1**:
- `has_modified()` checks: "Is CriticalFeatureX not enabled on-chain?" → YES (it's disabled)
- Returns `true`, proposal script generated to **enable** CriticalFeatureX

**Processing Entry 2**:
- `has_modified()` checks: "Is CriticalFeatureX enabled on-chain?" → NO (still disabled, Entry 1 hasn't executed yet)
- Returns `false`, **NO proposal script generated**

**Expected Behavior** (based on `squash()` logic):
The `squash()` method processes conflicting entries by giving precedence to the later disable operation, so the final state should have CriticalFeatureX **disabled**. [4](#0-3) 

**Actual Behavior**:
Only Entry 1's script is generated, so CriticalFeatureX ends up **enabled** instead of disabled.

This breaks the **Governance Integrity** invariant because the actual on-chain state differs from what the consolidated proposal indicates.

## Impact Explanation

**Severity: High** - This qualifies as a "Significant protocol violation" under the Aptos Bug Bounty program.

**Security Impact**:
1. **Feature Flag Manipulation**: An attacker can craft proposals that appear to disable critical security features but actually enable them
2. **Governance Bypass**: The proposal validation logic (`validate_upgrade()`) uses consolidated effects, so it would check for the wrong final state
3. **State Inconsistency**: The release builder's expected state diverges from actual on-chain state
4. **Security Control Bypass**: Critical features that gate security mechanisms could be manipulated contrary to governance intent

**Example Attack**:
- Disable `CHARGE_INVARIANT_VIOLATION` (appears to disable in consolidated view, but actually keeps enabled)
- Enable deprecated features that should remain disabled
- Manipulate VM binary format flags to enable vulnerable bytecode versions

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements**:
- Ability to submit governance proposals (requires sufficient voting power or proposal creation rights)
- Knowledge of the release builder's internal logic
- Access to create YAML configuration files with multiple `FeatureFlag` entries

**Feasibility**:
- The attack is straightforward once the vulnerability is understood
- No special privileges beyond normal governance participation required
- The YAML configuration format directly supports multiple entries in `update_sequence`
- No runtime checks prevent this attack pattern

**Detection Difficulty**:
- The consolidated view in validation logic masks the issue
- Reviewers examining the YAML might only look at the consolidated effect
- The individual proposal scripts are generated separately, making the bypass hard to spot

## Recommendation

**Fix**: Modify the proposal generation logic to check `has_modified()` on the **consolidated** feature flags rather than on individual entries.

**Implementation**:

1. In `generate_release_proposal_scripts()`, consolidate all `FeatureFlag` entries before processing:

```rust
// Consolidate FeatureFlag entries first
let mut consolidated_features = Features::empty();
for entry in &proposal.update_sequence {
    if let ReleaseEntry::FeatureFlag(features) = entry {
        consolidated_features.squash(features.clone());
    }
}

// Then process the consolidated entry
if !consolidated_features.is_empty() {
    let feature_entry = ReleaseEntry::FeatureFlag(consolidated_features);
    feature_entry.generate_release_script(client.as_ref(), &mut result, proposal.execution_mode).await?;
}
```

2. Alternatively, add validation in `ReleaseConfig::load_config()` to reject proposals with multiple `FeatureFlag` entries:

```rust
// Validate no duplicate FeatureFlag entries
let feature_flag_count = proposal.update_sequence.iter()
    .filter(|e| matches!(e, ReleaseEntry::FeatureFlag(_)))
    .count();
if feature_flag_count > 1 {
    bail!("Proposal {} contains {} FeatureFlag entries, only 1 is allowed", 
          proposal.name, feature_flag_count);
}
```

## Proof of Concept

**Malicious YAML Configuration**:

```yaml
name: "malicious-feature-proposal"
remote_endpoint: "https://fullnode.mainnet.aptoslabs.com/v1"
proposals:
  - name: "feature_manipulation"
    metadata:
      title: "Feature Flag Update"
      description: "Appears to disable critical features"
      source_code_url: "https://github.com/aptos-labs/aptos-core"
      discussion_url: "https://github.com/aptos-labs/aptos-core"
    execution_mode: MultiStep
    update_sequence:
      # Entry 1: Enable dangerous feature
      - FeatureFlag:
          enabled:
            - charge_invariant_violation
          disabled: []
      # Entry 2: Appears to disable it (but won't generate proposal)
      - FeatureFlag:
          enabled: []
          disabled:
            - charge_invariant_violation
```

**Expected Consolidated Result**: `charge_invariant_violation` should be **disabled**

**Actual Result**: Only the first entry generates a proposal script, so `charge_invariant_violation` remains **enabled**

**Verification Steps**:
1. Save the above YAML as `malicious-proposal.yaml`
2. Run: `cargo run --bin aptos-release-builder -- generate-proposals --input malicious-proposal.yaml --output ./output`
3. Observe that only ONE proposal script is generated (for enabling the feature)
4. The validation would check against the consolidated state (disabled), but execution results in the feature being enabled

## Notes

This vulnerability specifically affects the governance proposal generation workflow in the Aptos release builder. The core issue is the architectural mismatch where individual entries are validated during generation but consolidated during validation, creating an exploitable gap. The fix should ensure consistency between generation and validation logic by either consolidating before generation or restricting to single FeatureFlag entries per proposal.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L69-95)
```rust
    fn consolidated_side_effects(&self) -> Vec<ReleaseEntry> {
        let mut ret = vec![];
        let mut features_diff = Features::empty();
        for entry in &self.update_sequence {
            match entry {
                ReleaseEntry::FeatureFlag(feature_flags) => {
                    features_diff.squash(feature_flags.clone())
                },
                ReleaseEntry::Framework(_)
                | ReleaseEntry::Gas { .. }
                | ReleaseEntry::Version(_)
                | ReleaseEntry::Consensus(_)
                | ReleaseEntry::Execution(_)
                | ReleaseEntry::JwkConsensus(_)
                | ReleaseEntry::Randomness(_)
                | ReleaseEntry::RawScript(_) => ret.push(entry.clone()),
                // Deprecated by `JwkConsensus`.
                ReleaseEntry::OidcProviderOps(_) => {},
            }
        }

        if !features_diff.is_empty() {
            ret.push(ReleaseEntry::FeatureFlag(features_diff));
        }

        ret
    }
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L306-334)
```rust
            ReleaseEntry::FeatureFlag(feature_flags) => {
                let mut needs_update = true;
                if let Some(client) = client {
                    let features = block_on(async {
                        client
                            .get_account_resource_bcs::<aptos_types::on_chain_config::Features>(
                                CORE_CODE_ADDRESS,
                                "0x1::features::Features",
                            )
                            .await
                    })?;
                    // Only update the feature flags section when there's a divergence between the local configs and on chain configs.
                    // If any flag in the release config diverges from the on chain value, we will emit a script that includes all flags
                    // we would like to enable/disable, regardless of their current on chain state.
                    needs_update = feature_flags.has_modified(features.inner());
                }
                if needs_update {
                    result.append(&mut feature_flags::generate_feature_upgrade_proposal(
                        feature_flags,
                        is_testnet,
                        if is_multi_step {
                            get_execution_hash(result)
                        } else {
                            None
                        },
                        is_multi_step,
                    )?);
                }
            },
```

**File:** aptos-move/aptos-release-builder/src/components/feature_flags.rs (L30-44)
```rust
    pub fn squash(&mut self, rhs: Self) {
        let mut enabled: HashSet<_> = self.enabled.iter().cloned().collect();
        let mut disabled: HashSet<_> = self.disabled.iter().cloned().collect();
        let to_enable: HashSet<_> = rhs.enabled.into_iter().collect();
        let to_disable: HashSet<_> = rhs.disabled.into_iter().collect();

        disabled = disabled.difference(&to_enable).cloned().collect();
        enabled.extend(to_enable);

        enabled = enabled.difference(&to_disable).cloned().collect();
        disabled.extend(to_disable);

        self.enabled = enabled.into_iter().collect();
        self.disabled = disabled.into_iter().collect();
    }
```

**File:** aptos-move/aptos-release-builder/src/components/feature_flags.rs (L611-619)
```rust
    pub(crate) fn has_modified(&self, on_chain_features: &AptosFeatures) -> bool {
        self.enabled
            .iter()
            .any(|f| !on_chain_features.is_enabled(AptosFeatureFlag::from(f.clone())))
            || self
                .disabled
                .iter()
                .any(|f| on_chain_features.is_enabled(AptosFeatureFlag::from(f.clone())))
    }
```
