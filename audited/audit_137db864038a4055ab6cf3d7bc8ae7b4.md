# Audit Report

## Title
OnDiskStorage Lacks Durability Guarantees Enabling Consensus Double-Voting via Safety Data Reversion

## Summary

The `OnDiskStorage` implementation used for consensus safety data persistence lacks atomic write ordering guarantees and durability mechanisms. The `set()` method performs non-atomic read-modify-write operations without fsync, version checking, or file locking. This allows validator crashes to revert `last_voted_round` to older states, enabling double-voting that violates AptosBFT consensus safety. [1](#0-0) 

## Finding Description

The vulnerability exists in the consensus safety rules persistence layer. SafetyRules maintains critical state including `last_voted_round` to enforce the first voting rule: validators can only vote on rounds strictly greater than their `last_voted_round`. This data is persisted via `PersistentSafetyStorage` which uses a configurable storage backend. [2](#0-1) 

Production validator configurations use `OnDiskStorage` as the safety rules backend: [3](#0-2) 

The `OnDiskStorage.set()` method performs a read-modify-write operation without durability guarantees: [4](#0-3) 

The critical flaws are:

1. **No fsync before rename**: The `write()` method writes to a temp file and renames it, but never calls `file.sync_all()` or `file.sync_data()`. This means file contents may not be flushed to disk before the rename operation.

2. **No version checking**: Unlike `VaultStorage` which supports optional CAS (Compare-And-Set), `OnDiskStorage` blindly overwrites data without checking if it was modified concurrently or if a newer version exists.

3. **No file locking**: The README explicitly states "OnDisk storage does not currently support concurrent data accesses." [5](#0-4) 

**Attack Scenario:**

1. Validator votes on proposal at round 10
2. `SafetyRules` updates `safety_data.last_voted_round = 10` in memory
3. Calls `persistent_storage.set_safety_data(safety_data)` [6](#0-5) 

4. `OnDiskStorage.write()` writes to temp file without fsync
5. **Crash/power loss** occurs before data is flushed to disk
6. On restart, validator reads `last_voted_round` from disk = 5 (old value)
7. Validator receives proposal for round 8
8. `verify_and_update_last_vote_round()` checks: 8 > 5 âœ“ (passes!) [7](#0-6) 

9. Validator votes on round 8
10. **DOUBLE VOTE**: Validator has voted on both round 10 and round 8 in the same epoch

The deduplication check only prevents voting on the same round twice, not voting on earlier rounds after a crash: [8](#0-7) 

## Impact Explanation

This is a **CRITICAL** severity vulnerability per Aptos bug bounty criteria:

- **Consensus Safety Violation**: Enables double-voting which directly violates AptosBFT's safety guarantees. A validator can vote for different blocks in different rounds within the same epoch, breaking the fundamental assumption that honest validators follow voting rules.

- **Chain Split Potential**: If different validators observe different votes from the same validator, they may build on conflicting blocks, causing chain splits that require hard fork intervention.

- **Byzantine Behavior**: The validator exhibits Byzantine behavior (equivocation) without being actually malicious, undermining the consensus protocol's 1/3 Byzantine fault tolerance assumption.

The vulnerability affects ALL validators using `OnDiskStorage` in production environments, which includes the default validator configurations. [9](#0-8) 

## Likelihood Explanation

**HIGH** likelihood due to:

1. **Production Usage**: OnDiskStorage IS used in production validator deployments despite README warnings
2. **Natural Occurrence**: Validator crashes are expected in production (OOM, kernel panics, power loss, upgrades)
3. **No Mitigation**: No compensating controls exist - no checksums, version checks, or durability guarantees
4. **Timing Window**: The window between write and fsync is significant enough for crashes to occur
5. **File System Behavior**: Modern file systems delay writes for performance, making data loss on crash likely without explicit fsync

The attack requires no privileged access - simply operating a validator under normal conditions with occasional crashes.

## Recommendation

**Immediate Fix**: Add durability guarantees to `OnDiskStorage.write()`:

```rust
fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut file = File::create(self.temp_path.path())?;
    file.write_all(&contents)?;
    
    // Add fsync to ensure data is persisted to disk
    file.sync_all()?;
    
    fs::rename(&self.temp_path, &self.file_path)?;
    
    // Fsync the directory to ensure the rename is persisted
    if let Some(parent) = self.file_path.parent() {
        File::open(parent)?.sync_all()?;
    }
    
    Ok(())
}
```

**Additional Improvements**:

1. **Add version checking**: Implement optimistic locking similar to VaultStorage's CAS mechanism
2. **Add file locking**: Use `fs2::FileExt::lock_exclusive()` to prevent concurrent access
3. **Add integrity checks**: Include checksums or sequence numbers in SafetyData
4. **Deprecate OnDiskStorage**: Document that only VaultStorage should be used in production

**Long-term Fix**: Enforce VaultStorage in production: [10](#0-9) 

Add validation to reject OnDiskStorage on mainnet similar to the InMemoryStorage check.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_consensus_types::safety_data::SafetyData;
    use aptos_secure_storage::Storage;
    use aptos_temppath::TempPath;
    use std::process;

    #[test]
    fn test_double_vote_via_crash_data_loss() {
        // Setup OnDiskStorage
        let temp_path = TempPath::new();
        temp_path.create_as_file().unwrap();
        let storage_path = temp_path.path().to_path_buf();
        let mut storage = Storage::from(OnDiskStorage::new(storage_path.clone()));
        
        // Initialize with last_voted_round = 5
        let initial_data = SafetyData::new(1, 5, 0, 0, None, 0);
        storage.set("safety_data", initial_data).unwrap();
        
        // Simulate voting on round 10
        let vote_round_10 = SafetyData::new(1, 10, 0, 0, None, 0);
        storage.set("safety_data", vote_round_10).unwrap();
        
        // Simulate crash by NOT calling fsync and forcibly dropping
        // In real scenario, this would be a power loss/kernel panic
        drop(storage);
        
        // Simulate restart - reopen storage
        let storage = Storage::from(OnDiskStorage::new(storage_path));
        
        // Read safety_data - may get old value due to no fsync
        let recovered_data: GetResponse<SafetyData> = storage.get("safety_data").unwrap();
        
        // If recovered last_voted_round < 10, we can vote on rounds 6-9
        // This demonstrates the vulnerability
        if recovered_data.value.last_voted_round < 10 {
            println!("VULNERABILITY CONFIRMED: last_voted_round reverted from 10 to {}",
                     recovered_data.value.last_voted_round);
            println!("Validator can now double-vote on rounds {} through 9",
                     recovered_data.value.last_voted_round + 1);
            panic!("Double-voting enabled!");
        }
    }
}
```

**Notes**

The vulnerability is particularly insidious because:

1. **Silent Failure**: The validator doesn't detect it has reverted to an older state
2. **Intermittent**: Only occurs on crashes at specific timing windows
3. **Production Impact**: Affects real validator deployments using default configurations
4. **Safety Critical**: Breaks the most fundamental consensus safety guarantee

While VaultStorage with CAS enabled provides protection, the codebase allows OnDiskStorage in production environments where it should never be used for consensus-critical data. [11](#0-10)

### Citations

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** secure/storage/src/on_disk.rs (L85-93)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L8-13)
```yaml
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L68-74)
```rust
        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L77-92)
```rust
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L12-15)
```yaml
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
```

**File:** config/src/config/secure_backend_config.rs (L174-186)
```rust
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
```
