# Audit Report

## Title
Root Private Key Leak via TempPath Variable Shadowing in ValidateProposals Handler

## Summary
The `ValidateProposals` command handler in `aptos-release-builder` leaks the root private key to disk when using the `FromArgs` input option. The vulnerability occurs due to variable shadowing that defeats the `TempPath` RAII cleanup mechanism, leaving a file containing the BCS-encoded root private key in the system temp directory indefinitely. If `get_ledger_information().await` fails (or any subsequent operation), the sensitive key file is never cleaned up.

## Finding Description

The vulnerability exists in the resource management pattern used when handling the `ValidateProposals` command with the `FromArgs` input option. [1](#0-0) 

A `TempPath` is initially created to ensure automatic cleanup via its `Drop` implementation. [2](#0-1) 

However, in the `FromArgs` branch, the variable is shadowed: [3](#0-2) 

**Critical issue**: At line 303, the variable name `root_key_path` is reused (shadowed) with a `PathBuf`. In Rust, this causes the original `TempPath` to be dropped immediately, triggering cleanup of `/tmp/<random>`. However, the code then adds a `.key` extension (line 304) and writes the root private key to `/tmp/<random>.key` (line 306). This new file is **never tracked by any RAII mechanism**.

The `PathBuf` is then stored in `NetworkConfig`: [4](#0-3) [5](#0-4) 

The `NetworkConfig` struct does not implement `Drop` for cleanup, meaning the key file persists indefinitely.

When `get_ledger_information().await` fails at the specified location: [6](#0-5) 

The function returns early via the `?` operator. All local variables go out of scope, but since `network_config.root_key_path` is just a `PathBuf` (not a `TempPath`), no cleanup occurs. The root private key remains exposed in the temp directory.

**Security Invariant Broken**: Access Control (#8) - System addresses and cryptographic keys must be protected. The root key gives full control over network governance, token minting, and system configuration.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

1. **Information Disclosure**: The root private key is leaked to a world-readable temp directory on most Unix systems
2. **Limited Scope**: The tool explicitly prevents use on mainnet/testnet via a chain ID check, limiting impact to test networks
3. **Privileged Access**: The leaked root key can:
   - Mint unlimited tokens on test networks
   - Modify governance parameters
   - Execute arbitrary system transactions
   - Bypass all access controls

In shared environments (CI/CD pipelines, development servers, multi-user systems), the leaked key could be accessed by:
- Other users with read access to `/tmp`
- Malicious processes monitoring the filesystem
- Attackers who have gained any foothold on the system

The persistence is indefinite - the file remains until manual cleanup or system reboot.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically under the following conditions:
1. Running `ValidateProposals` command with `FromArgs` input option
2. The `mint_to_validator` flag is set (common in testing workflows)
3. Any async operation fails after key creation (not just `get_ledger_information`)

The vulnerability also occurs even on **successful execution** - the key file is leaked regardless of whether the function completes or fails, making this a guaranteed leak rather than an edge case.

Common scenarios:
- CI/CD pipelines running release validation
- Developer machines running local test validation
- Automated testing environments

## Recommendation

Replace the variable shadowing pattern with proper resource management. Use a separate `TempPath` for the key file or explicitly track and clean up the `.key` file:

**Option 1: Use TempPath for the key file**
```rust
InputOptions::FromArgs {
    root_key,
    validator_address,
    validator_key,
} => {
    let root_key = Ed25519PrivateKey::from_encoded_string(&root_key)?;
    let validator_key = Ed25519PrivateKey::from_encoded_string(&validator_key)?;
    let validator_account = AccountAddress::from_hex(validator_address.as_bytes())?;

    // Create a new TempPath for the actual key file
    let key_file = aptos_temppath::TempPath::new();
    key_file.create_as_file()?;
    let mut key_path = key_file.path().to_path_buf();
    key_path.set_extension("key");
    
    std::fs::write(key_path.as_path(), bcs::to_bytes(&root_key)?)?;

    // Store the TempPath in NetworkConfig to ensure cleanup
    aptos_release_builder::validate::NetworkConfig {
        root_key_path: key_path,
        _key_file_guard: Some(key_file), // Keep TempPath alive
        validator_account,
        validator_key,
        framework_git_rev: None,
        endpoint: endpoint.clone(),
    }
},
```

**Option 2: Explicit cleanup at function exit**
```rust
// At the end of ValidateProposals handler, before Ok(())
if let InputOptions::FromArgs { .. } = input_option {
    // Clean up the key file
    let _ = std::fs::remove_file(&network_config.root_key_path);
}
Ok(())
```

Additionally, modify `NetworkConfig` to hold the `TempPath` or implement `Drop` for cleanup.

## Proof of Concept

**Reproduction Steps**:

1. Run the `aptos-release-builder` tool with `ValidateProposals` and `FromArgs`:
```bash
cargo run --bin aptos-release-builder -- validate-proposals \
  --release-config config.yaml \
  --endpoint http://localhost:8080 \
  --mint-to-validator \
  from-args \
    --root-key 0x1234... \
    --validator-address 0xabcd... \
    --validator-key 0x5678...
```

2. Force `get_ledger_information().await` to fail by using an invalid endpoint or stopping the node

3. Check the temp directory:
```bash
ls -la /tmp/*.key
# Expected: File(s) containing BCS-encoded root private key
cat /tmp/<random>.key | xxd
# Expected: Binary key data visible
```

4. Verify the key is never cleaned up:
```bash
# Wait for the process to exit
# Check that the key file still exists
ls -la /tmp/*.key
# Expected: File(s) still present
```

**Alternative PoC - Successful execution still leaks**:
Even if `get_ledger_information().await` succeeds, the key file is still leaked because there's no cleanup at function exit. This can be verified by running the tool successfully and checking `/tmp` afterward.

### Citations

**File:** aptos-move/aptos-release-builder/src/main.rs (L284-285)
```rust
            let root_key_path = aptos_temppath::TempPath::new();
            root_key_path.create_as_file()?;
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L303-306)
```rust
                    let mut root_key_path = root_key_path.path().to_path_buf();
                    root_key_path.set_extension("key");

                    std::fs::write(root_key_path.as_path(), bcs::to_bytes(&root_key)?)?;
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L308-314)
```rust
                    aptos_release_builder::validate::NetworkConfig {
                        root_key_path,
                        validator_account,
                        validator_key,
                        framework_git_rev: None,
                        endpoint: endpoint.clone(),
                    }
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L325-330)
```rust
                let chain_id = client
                    .build()
                    .get_ledger_information()
                    .await?
                    .inner()
                    .chain_id;
```

**File:** crates/aptos-temppath/src/lib.rs (L20-28)
```rust
impl Drop for TempPath {
    fn drop(&mut self) {
        if !self.persist {
            fs::remove_dir_all(&self.path_buf)
                .or_else(|_| fs::remove_file(&self.path_buf))
                .unwrap_or(());
        }
    }
}
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L28-35)
```rust
#[derive(Clone, Debug)]
pub struct NetworkConfig {
    pub endpoint: Url,
    pub root_key_path: PathBuf,
    pub validator_account: AccountAddress,
    pub validator_key: Ed25519PrivateKey,
    pub framework_git_rev: Option<String>,
}
```
