# Audit Report

## Title
API Server DoS via Unbounded Type Parameters in MoveStructTag Leading to Memory Exhaustion

## Summary
The API layer validates only the recursion depth of `MoveStructTag` types but does not limit the number of type parameters at each nesting level. An attacker can craft a malicious API request with a deeply nested struct tag containing excessive type parameters, causing memory exhaustion when `to_canonical_string()` is invoked, resulting in API server crashes.

## Finding Description

The Aptos API accepts `MoveStructTag` inputs and validates them using the `VerifyInputWithRecursion` trait, which only checks recursion depth against `MAX_RECURSIVE_TYPES_ALLOWED` (8 levels) but does not validate the number of type parameters in the `generic_type_params` vector. [1](#0-0) 

When processing API requests (e.g., resource lookups that fail), the API calls `to_canonical_string()` on user-supplied struct tags to generate error messages: [2](#0-1) [3](#0-2) 

The `to_canonical_string()` method recursively formats struct tags without bounds checking, causing exponential string growth with multiple type parameters at each level: [4](#0-3) 

**Attack Scenario:**
1. Attacker sends API request with `MoveStructTag` containing:
   - 8 levels of nesting (passes depth validation)
   - 100+ type parameters at each level (no validation)
2. API validates depth only, accepts the input
3. During error message generation or response formatting, `to_canonical_string()` is called
4. String size grows exponentially: ~580 bytes → ~58KB → ~5.6MB → ~588MB → Out of Memory
5. API server crashes (DoS)

While production VM execution has type cost metering that would reject such types during execution: [5](#0-4) 

This protection does NOT apply to API input validation, which only checks depth: [6](#0-5) 

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria: "API crashes". An attacker can repeatedly crash API servers without authentication or special privileges, causing:
- Denial of service for API users
- Disruption of indexer services
- Impact on wallets and dApps relying on API endpoints
- Potential cascade failures if multiple API nodes are targeted

The attack requires minimal resources (single HTTP request) and can be automated for sustained DoS.

## Likelihood Explanation

**High Likelihood**:
- No authentication required
- Trivial to exploit (single malicious API request)
- API endpoints are publicly accessible
- No rate limiting on struct tag complexity
- Attack pattern is difficult to distinguish from legitimate requests with complex types

## Recommendation

Add validation for the number of type parameters in `MoveStructTag`:

```rust
impl VerifyInputWithRecursion for MoveStructTag {
    fn verify(&self, recursion_count: u8) -> anyhow::Result<()> {
        if recursion_count > MAX_RECURSIVE_TYPES_ALLOWED {
            bail!(/* existing error */);
        }
        
        // Add limit on type parameter count
        const MAX_TYPE_PARAMS_PER_STRUCT: usize = 32;
        if self.generic_type_params.len() > MAX_TYPE_PARAMS_PER_STRUCT {
            bail!(
                "Move struct tag {} has {} type parameters, exceeding limit of {}",
                self,
                self.generic_type_params.len(),
                MAX_TYPE_PARAMS_PER_STRUCT
            );
        }
        
        verify_module_identifier(self.module.as_str())?;
        verify_identifier(self.name.as_str())?;
        for param in self.generic_type_params.iter() {
            param.verify(recursion_count + 1)?;
        }
        Ok(())
    }
}
```

Additionally, consider implementing a total cost metric (similar to VM's `type_max_cost`) for API input validation to bound the total complexity of type tags before calling `to_canonical_string()`.

## Proof of Concept

```rust
#[test]
fn test_api_dos_via_unbounded_type_params() {
    use api_types::{MoveStructTag, MoveType, Address, IdentifierWrapper};
    
    // Craft deeply nested struct tag with many type parameters
    fn create_nested_type(depth: u8, params_per_level: usize) -> MoveType {
        if depth == 0 {
            return MoveType::U64;
        }
        
        let inner = create_nested_type(depth - 1, params_per_level);
        let type_params = vec![inner; params_per_level];
        
        MoveType::Struct(MoveStructTag {
            address: Address::from_hex_literal("0x1").unwrap(),
            module: IdentifierWrapper::from("module"),
            name: IdentifierWrapper::from("Struct"),
            generic_type_params: type_params,
        })
    }
    
    // Create struct tag with depth 8 and 50 params per level
    let malicious_tag = create_nested_type(8, 50);
    
    // This passes API validation (only checks depth)
    assert!(malicious_tag.verify(0).is_ok());
    
    // Convert to StructTag and attempt to_canonical_string()
    // This will attempt to allocate exponentially growing memory
    let struct_tag: StructTag = malicious_tag.try_into().unwrap();
    
    // This line will cause memory exhaustion:
    // String size = 50^8 * 580 bytes = ~195 TB
    let canonical = struct_tag.to_canonical_string();
    
    // API server crashes before reaching this point
}
```

**Notes**

The vulnerability is specific to the API layer's validation gap. The core VM execution path has proper protections via type cost metering. The fix should align API validation with the production VM configuration limiting type parameters to 32 per struct. [7](#0-6)

### Citations

**File:** api/types/src/move_types.rs (L511-536)
```rust
impl VerifyInputWithRecursion for MoveStructTag {
    fn verify(&self, recursion_count: u8) -> anyhow::Result<()> {
        if recursion_count > MAX_RECURSIVE_TYPES_ALLOWED {
            bail!(
                "Move struct tag {} has gone over the limit of recursive types {}",
                self,
                MAX_RECURSIVE_TYPES_ALLOWED
            );
        }
        verify_module_identifier(self.module.as_str())
            .map_err(|_| anyhow::anyhow!("invalid struct tag: {}", self))?;
        verify_identifier(self.name.as_str())
            .map_err(|_| anyhow::anyhow!("invalid struct tag: {}", self))?;
        for param in self.generic_type_params.iter() {
            param.verify(recursion_count + 1).map_err(|err| {
                anyhow::anyhow!(
                    "Invalid struct tag for generic type params: {} {}",
                    self,
                    err
                )
            })?;
        }

        Ok(())
    }
}
```

**File:** api/types/src/move_types.rs (L688-688)
```rust
pub const MAX_RECURSIVE_TYPES_ALLOWED: u8 = 8;
```

**File:** api/src/accounts.rs (L664-668)
```rust
            .context(format!(
                "Failed to query DB to check for {} at {}",
                resource_type.to_canonical_string(),
                self.address
            ))
```

**File:** api/src/response.rs (L696-701)
```rust
        format!(
            "Address({}), Struct tag({}) and Ledger version({})",
            address,
            struct_tag.to_canonical_string(),
            ledger_version
        ),
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L267-291)
```rust
    pub fn to_canonical_string(&self) -> String {
        let generics = if self.type_args.is_empty() {
            "".to_string()
        } else {
            format!(
                "<{}>",
                self.type_args
                    .iter()
                    .map(|t| t.to_canonical_string())
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        };
        format!(
            // Note:
            //   For historical reasons, we convert addresses as strings using 0x... and trimming
            //   leading zeroes. This cannot be changed easily because 0x1::any::Any relies on that
            //   and may store bytes of these strings on-chain.
            "0x{}::{}::{}{}",
            self.address.short_str_lossless(),
            self.module,
            self.name,
            generics
        )
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L15-63)
```rust
struct PseudoGasContext {
    // Parameters for metering type tag construction:
    //   - maximum allowed cost,
    //   - base cost for any type to tag conversion,
    //   - cost for size of a struct tag.
    max_cost: u64,
    cost: u64,
    cost_base: u64,
    cost_per_byte: u64,
}

impl PseudoGasContext {
    fn new(vm_config: &VMConfig) -> Self {
        Self {
            max_cost: vm_config.type_max_cost,
            cost: 0,
            cost_base: vm_config.type_base_cost,
            cost_per_byte: vm_config.type_byte_cost,
        }
    }

    fn current_cost(&mut self) -> u64 {
        self.cost
    }

    fn charge_base(&mut self) -> PartialVMResult<()> {
        self.charge(self.cost_base)
    }

    fn charge_struct_tag(&mut self, struct_tag: &StructTag) -> PartialVMResult<()> {
        let size =
            (struct_tag.address.len() + struct_tag.module.len() + struct_tag.name.len()) as u64;
        self.charge(size * self.cost_per_byte)
    }

    fn charge(&mut self, amount: u64) -> PartialVMResult<()> {
        self.cost += amount;
        if self.cost > self.max_cost {
            Err(
                PartialVMError::new(StatusCode::TYPE_TAG_LIMIT_EXCEEDED).with_message(format!(
                    "Exceeded maximum type tag limit of {} when charging {}",
                    self.max_cost, amount
                )),
            )
        } else {
            Ok(())
        }
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L158-158)
```rust
        max_generic_instantiation_length: Some(32),
```
