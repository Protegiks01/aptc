# Audit Report

## Title
Protocol Negotiation Manipulation Allowing Byzantine Validators to Cause Inconsistent Message Processing

## Summary
Byzantine validators can advertise different supported protocols to different honest validators during the handshake phase, causing inconsistent protocol selection when honest validators communicate with the Byzantine validator. This violates the assumption of consistent protocol negotiation across the network.

## Finding Description

The JWK consensus network layer uses `to_bytes_by_protocol()` to serialize messages based on each peer's supported protocols. However, there is no mechanism to ensure that Byzantine validators advertise the same protocol capabilities to all honest validators.

**Attack Flow:**

1. **Handshake Manipulation**: During connection establishment, a Byzantine validator (BV) can send different `HandshakeMsg` values to different honest validators. The handshake creates a `HandshakeMsg` containing `supported_protocols`: [1](#0-0) 

2. **Protocol Negotiation**: The `perform_handshake()` method only validates chain_id, network_id, and that at least one common protocol exists - it does NOT verify that the peer advertises consistent protocols to all validators: [2](#0-1) 

3. **Different Protocol Views**: Honest validators store different `application_protocols` in their `ConnectionMetadata`: [3](#0-2) 

4. **Protocol Selection Inconsistency**: When `to_bytes_by_protocol()` is called, it selects protocols based on each validator's local view: [4](#0-3) 

The `get_preferred_protocol_for_peer()` method returns different protocols for different validators based on their stored metadata: [5](#0-4) 

5. **Inconsistent Communication**: This causes honest validators A and B to use different protocols (e.g., Compressed vs JSON) when communicating with the Byzantine validator, potentially leading to different serialization characteristics, error handling, or performance.

## Impact Explanation

This issue represents a **High Severity** vulnerability because:

1. **Protocol Violation**: It violates the assumption that protocol negotiation is consistent across the network
2. **Potential for Exploitation**: Byzantine validators can exploit protocol-specific behaviors (different size limits, recursion limits, compression failures) to cause inconsistent message handling
3. **No Detection**: There is no mechanism to detect or prevent this manipulation

While I cannot demonstrate concrete serialization inconsistencies without deeper testing, the architectural flaw enables Byzantine validators to create asymmetric communication patterns that could be exploited in protocol-specific edge cases.

## Likelihood Explanation

**Likelihood: High**

- Byzantine validators have complete control over their handshake messages
- No validation exists to prevent inconsistent protocol advertisement
- The attack requires no special resources beyond running modified validator software
- The handshake protocol provides no authenticity guarantees about advertised capabilities

## Recommendation

Implement protocol capability verification through one of these approaches:

1. **Consensus-based Protocol Registry**: Store validator protocol capabilities in on-chain state during validator registration, verified by all validators
2. **Gossip-based Validation**: Validators gossip observed protocol capabilities of peers, detecting inconsistencies
3. **Strict Protocol Requirements**: Require all validators to support a fixed set of protocols, removing negotiation flexibility

Example fix for approach 3:

```rust
// In UpgradeContext, enforce mandatory protocols
pub fn validate_handshake(remote_handshake: &HandshakeMsg) -> Result<(), HandshakeError> {
    let required_protocols = ProtocolIdSet::from_iter([
        ProtocolId::JWKConsensusRpcCompressed,
        ProtocolId::JWKConsensusRpcBcs,
        ProtocolId::JWKConsensusRpcJson,
    ]);
    
    for protocol in required_protocols.iter() {
        if !remote_handshake.supported_protocols
            .values()
            .any(|protocols| protocols.contains(protocol)) 
        {
            return Err(HandshakeError::MissingRequiredProtocol(protocol));
        }
    }
    Ok(())
}
```

## Proof of Concept

```rust
// Modified validator node that advertises different protocols to different peers
impl CustomHandshake {
    fn create_handshake_for_peer(&self, peer_id: PeerId) -> HandshakeMsg {
        let protocols = if self.should_limit_protocols(peer_id) {
            // Advertise only JSON to specific peers
            ProtocolIdSet::from_iter([ProtocolId::JWKConsensusRpcJson])
        } else {
            // Advertise full suite to others
            ProtocolIdSet::from_iter([
                ProtocolId::JWKConsensusRpcCompressed,
                ProtocolId::JWKConsensusRpcBcs,
                ProtocolId::JWKConsensusRpcJson,
            ])
        };
        
        let mut supported_protocols = BTreeMap::new();
        supported_protocols.insert(MessagingProtocolVersion::V1, protocols);
        
        HandshakeMsg {
            supported_protocols,
            chain_id: self.chain_id,
            network_id: self.network_id,
        }
    }
}
```

This PoC demonstrates that a Byzantine validator can selectively advertise protocol capabilities, causing honest validators to have different views of the Byzantine validator's capabilities, leading to inconsistent protocol selection during message exchange.

**Notes**

The core vulnerability is the lack of protocol advertisement validation. While I cannot demonstrate specific serialization bugs between Compressed/BCS/JSON protocols without extensive testing, the architectural flaw enables Byzantine validators to create inconsistent communication patterns. The three protocols have different characteristics (compression, recursion limits, error handling) that could be exploited in edge cases. The fix should enforce protocol consistency through consensus or remove protocol negotiation flexibility entirely.

### Citations

**File:** crates/aptos-jwk-consensus/src/network_interface.rs (L14-26)
```rust
/// Supported protocols in preferred order (from highest priority to lowest).
pub const DIRECT_SEND: &[ProtocolId] = &[
    ProtocolId::JWKConsensusDirectSendCompressed,
    ProtocolId::JWKConsensusDirectSendBcs,
    ProtocolId::JWKConsensusDirectSendJson,
];

/// Supported protocols in preferred order (from highest priority to lowest).
pub const RPC: &[ProtocolId] = &[
    ProtocolId::JWKConsensusRpcCompressed,
    ProtocolId::JWKConsensusRpcBcs,
    ProtocolId::JWKConsensusRpcJson,
];
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/transport/mod.rs (L298-331)
```rust
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket)
        .await
        .map_err(|err| add_pp_addr(proxy_protocol_enabled, err, &addr))?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/application/interface.rs (L288-304)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
        message: Message,
    ) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);
        // Convert to bytes per protocol
        let mut bytes_per_peer = HashMap::new();
        for (protocol_id, peers) in peers_per_protocol {
            let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
            for peer in peers {
                bytes_per_peer.insert(peer, bytes.clone());
            }
        }

        Ok(bytes_per_peer)
    }
```
