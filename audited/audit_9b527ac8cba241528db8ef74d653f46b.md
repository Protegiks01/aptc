# Audit Report

## Title
Division by Zero and Undefined Behavior in Block Partitioner with Invalid num_executor_shards Configuration

## Summary
The block partitioner implementation contains critical vulnerabilities when `num_executor_shards` is set to 0, causing division by zero panics and undefined behavior from floating-point infinity conversions. This can be triggered through command-line arguments in the transaction benchmark binary, leading to validator node crashes and denial of service.

## Finding Description

The `num_executor_shards` configuration parameter lacks proper validation at multiple entry points, allowing a value of 0 to propagate through the partitioning logic. This triggers three distinct failure modes:

**Vulnerability 1: Division by Zero in UniformPartitioner**

The `UniformPartitioner.process()` function performs direct integer division and modulo operations without checking if `num_chunks` (which equals `num_shards`) is zero: [1](#0-0) 

When `num_executor_shards` is 0, this causes a **division by zero panic** at runtime.

**Vulnerability 2: Undefined Behavior in LocalExecutorService**

The `setup_local_executor_shards()` function performs floating-point division by `num_shards` and converts the result to `usize`: [2](#0-1) 

When `num_shards` is 0:
1. Division by 0.0 produces floating-point infinity
2. `.ceil()` on infinity returns infinity
3. Converting infinity `as usize` is **undefined behavior** in Rust

**Vulnerability 3: Undefined Behavior in ConnectedComponentPartitioner**

Similar issue exists in the connected component partitioner: [3](#0-2) 

**Attack Vector**

The vulnerability is exploitable through the `aptos-transaction-benchmarks` binary, which accepts `num_executor_shards` from command-line arguments: [4](#0-3) 

The critical flaw is in `TransactionBenchState::with_size()`, which only checks if `num_executor_shards == 1` but NOT if it's 0: [5](#0-4) 

When `num_executor_shards` is 0, the condition `num_executor_shards == 1` is false, so it proceeds to the `else` branch and calls `LocalExecutorService::setup_local_executor_shards(0, None)`, triggering the undefined behavior.

**Exploitation Path:**
1. Attacker runs: `aptos-transaction-benchmarks execute --num-executor-shards 0`
2. Code flows through `TransactionBenchState::with_size` with `num_executor_shards = 0`
3. Triggers undefined behavior in `LocalExecutorService::setup_local_executor_shards`
4. Alternatively, if partitioner is invoked, triggers division by zero in `UniformPartitioner.process()`
5. Node crashes or exhibits undefined behavior

## Impact Explanation

**Severity: High**

This vulnerability meets the **High Severity** criteria from the Aptos bug bounty program:
- **Validator node crashes**: The undefined behavior and division by zero cause immediate node termination
- **API crashes**: Benchmark tools and executor services crash when processing the invalid configuration
- **Significant protocol violations**: Breaks the availability invariant

While this is primarily exploitable in benchmark/testing tools rather than production validator nodes, it demonstrates a systemic lack of input validation that could affect other code paths. The undefined behavior is particularly concerning as it can lead to unpredictable runtime behavior beyond simple crashes.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is easily triggered:
- **Attack Complexity**: Trivial - single command-line argument
- **Attacker Requirements**: No special privileges required
- **Availability**: Any user with access to the `aptos-transaction-benchmarks` binary

However, the impact is currently limited to benchmark tools rather than production validator infrastructure. The main concern is that the same validation gaps may exist in other code paths that accept `num_executor_shards` from external sources.

## Recommendation

Implement comprehensive validation for `num_executor_shards` at all entry points:

**Fix 1: Add validation in TransactionBenchState**
```rust
pub(crate) fn with_size(
    strategy: S,
    num_accounts: usize,
    num_transactions: usize,
    num_executor_shards: usize,
    remote_executor_addresses: Option<Vec<SocketAddr>>,
    account_pick_style: AccountPickStyle,
) -> Self {
    // Add validation
    assert!(
        num_executor_shards >= 1,
        "num_executor_shards must be at least 1, got {}",
        num_executor_shards
    );
    
    Self::with_universe(
        strategy,
        transactions::universe_strategy(num_accounts, num_transactions, account_pick_style),
        num_transactions,
        num_executor_shards,
        remote_executor_addresses,
    )
}
```

**Fix 2: Add validation in LocalExecutorService**
```rust
pub fn setup_local_executor_shards(
    num_shards: usize,
    num_threads: Option<usize>,
) -> LocalExecutorClient<S> {
    assert!(
        num_shards >= 1,
        "num_shards must be at least 1, got {}",
        num_shards
    );
    
    let (global_executor, global_cross_shard_tx) = Self::setup_global_executor();
    // ... rest of function
}
```

**Fix 3: Add validation in UniformPartitioner**
```rust
fn process(&self, num_txns: usize, num_shards: usize) -> Vec<Vec<PrePartitionedTxnIdx>> {
    assert!(
        num_shards >= 1,
        "num_shards must be at least 1, got {}",
        num_shards
    );
    
    let num_chunks = num_shards;
    // ... rest of function
}
```

**Fix 4: Add validation in PartitionerV2**
```rust
fn partition(
    &self,
    txns: Vec<AnalyzedTransaction>,
    num_executor_shards: usize,
) -> PartitionedTransactions {
    assert!(
        num_executor_shards >= 1,
        "num_executor_shards must be at least 1, got {}",
        num_executor_shards
    );
    
    let _timer = BLOCK_PARTITIONING_SECONDS.start_timer();
    // ... rest of function
}
```

## Proof of Concept

```bash
# Build the aptos-transaction-benchmarks binary
cd aptos-move/aptos-transaction-benchmarks
cargo build --release

# Trigger the vulnerability with num_executor_shards = 0
./target/release/aptos-transaction-benchmarks execute \
    --num-executor-shards 0 \
    --num-accounts 100 \
    --block-size 10 \
    --num-blocks 1

# Expected result: Process crashes with division by zero or undefined behavior
# Actual result should be: panic or undefined behavior leading to crash
```

Alternatively, create a minimal Rust test:

```rust
#[test]
#[should_panic(expected = "num_shards must be at least 1")]
fn test_zero_shards_panics() {
    use crate::transaction_bench_state::TransactionBenchState;
    use aptos_language_e2e_tests::account_universe::AccountPickStyle;
    use proptest::prelude::*;
    
    let strategy = any::<()>();
    let _state = TransactionBenchState::with_size(
        &strategy,
        100,
        10,
        0,  // Invalid: num_executor_shards = 0
        None,
        AccountPickStyle::Unlimited,
    );
}
```

## Notes

While this vulnerability currently manifests primarily in benchmark tooling, the systemic lack of validation for `num_executor_shards` represents a broader security concern. The undefined behavior from infinity-to-usize conversion is particularly dangerous as it could lead to memory corruption or other unpredictable runtime behavior beyond simple crashes. Production validator code should be audited to ensure similar validation gaps don't exist in critical paths.

### Citations

**File:** execution/block-partitioner/src/pre_partition/uniform_partitioner/mod.rs (L21-35)
```rust
    fn process(&self, num_txns: usize, num_shards: usize) -> Vec<Vec<PrePartitionedTxnIdx>> {
        let num_chunks = num_shards;
        let num_big_chunks = num_txns % num_chunks;
        let small_chunk_size = num_txns / num_chunks;
        let mut ret = Vec::with_capacity(num_chunks);
        let mut next_chunk_start = 0;
        for chunk_id in 0..num_chunks {
            let extra = if chunk_id < num_big_chunks { 1 } else { 0 };
            let next_chunk_end = next_chunk_start + small_chunk_size + extra;
            let chunk: Vec<usize> = (next_chunk_start..next_chunk_end).collect();
            next_chunk_start = next_chunk_end;
            ret.push(chunk);
        }
        ret
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L77-87)
```rust
    pub fn setup_local_executor_shards(
        num_shards: usize,
        num_threads: Option<usize>,
    ) -> LocalExecutorClient<S> {
        let (global_executor, global_cross_shard_tx) = Self::setup_global_executor();
        let num_threads = num_threads
            .unwrap_or_else(|| (num_cpus::get() as f64 / num_shards as f64).ceil() as usize);
        let (command_txs, command_rxs): (
            Vec<Sender<ExecutorShardCommand<S>>>,
            Vec<Receiver<ExecutorShardCommand<S>>>,
        ) = (0..num_shards).map(|_| unbounded()).unzip();
```

**File:** execution/block-partitioner/src/pre_partition/connected_component/mod.rs (L88-92)
```rust
        // Calculate txn group size limit.
        let group_size_limit = ((state.num_txns() as f32) * self.load_imbalance_tolerance
            / (state.num_executor_shards as f32))
            .ceil() as usize;

```

**File:** aptos-move/aptos-transaction-benchmarks/src/main.rs (L72-76)
```rust
    #[clap(long, default_value_t = 8)]
    pub concurrency_level_per_shard: usize,

    #[clap(long, default_value_t = 1)]
    pub num_executor_shards: usize,
```

**File:** aptos-move/aptos-transaction-benchmarks/src/transaction_bench_state.rs (L100-116)
```rust
        let (parallel_block_executor, block_partitioner) = if num_executor_shards == 1 {
            (None, None)
        } else {
            let client =
                LocalExecutorService::setup_local_executor_shards(num_executor_shards, None);
            let parallel_block_executor = Arc::new(ShardedBlockExecutor::new(client));
            (
                Some(parallel_block_executor),
                Some(
                    PartitionerV2Config::default()
                        .max_partitioning_rounds(4)
                        .cross_shard_dep_avoid_threshold(0.9)
                        .partition_last_round(true)
                        .build(),
                ),
            )
        };
```
