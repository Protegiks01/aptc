# Audit Report

## Title
Block-STM Dependency Loss via Partial AbortManager State on Error Path Causes Consensus Divergence

## Summary
In Block-STM's BlockSTMv2 implementation, read dependencies extracted via `split_off()` can be permanently lost if error conditions occur during transaction output processing. When `write_v2()` or `remove_v2()` split off dependencies from versioned entries and pass them to `AbortManager` for invalidation, a subsequent error causes the `AbortManager` to be dropped without calling `finish_execution()`, resulting in lost dependencies. Transactions with these lost dependencies never receive abort notifications, allowing them to commit with stale reads and violating deterministic execution.

## Finding Description
The vulnerability exists in the dependency invalidation flow of Block-STM's push validation mechanism: [1](#0-0) 

When a transaction re-executes with a new incarnation, the `split_off()` method **permanently removes** dependencies from the old entry: [2](#0-1) 

These split-off dependencies are returned to the caller to be invalidated: [3](#0-2) 

In the executor, these dependencies are passed to `AbortManager.invalidate_dependencies()`: [4](#0-3) 

The `invalidate_dependencies()` method iterates over dependencies and adds them to the abort manager's internal state: [5](#0-4) 

During iteration, if `invalidate()` encounters certain error conditions, it returns a `PanicError`: [6](#0-5) [7](#0-6) 

When this error propagates up from `process_resource_output_v2()` or `process_resource_group_output_v2()`, the function returns early before reaching `finish_execution()`: [8](#0-7) 

The `AbortManager` has no `Drop` implementation, so when it's dropped due to the error, all dependencies stored in `invalidated_dependencies` are lost. These transactions never receive abort notifications and may commit with stale data.

**Attack Scenario:**
1. Transaction T5 reads value X written by T3
2. T3 re-executes (incarnation 1), triggering `write_v2()`
3. `split_off()` removes T5's dependency from T3's old entry
4. The dependency is returned to be invalidated
5. `invalidate_dependencies()` processes multiple dependencies
6. For one dependency, an invariant violation error occurs (e.g., attempting to invalidate T3's own incarnation due to a bug)
7. The error causes early return from `process_resource_output_v2()`
8. `AbortManager` is dropped, T5's dependency is lost
9. T5 never learns its read is invalid and commits with stale data from T3's incarnation 0
10. Validators may execute T3 differently, leading to state divergence

## Impact Explanation
This is a **Critical Severity** vulnerability because it violates **Consensus Safety**:

1. **Deterministic Execution Violation**: Different validators may handle errors differently or at different times, causing some to lose dependencies while others process them correctly. This leads to non-deterministic transaction outcomes across validators.

2. **State Divergence**: Transactions committing with stale reads produce different state transitions. Validators will compute different state roots for the same block, violating the fundamental consensus invariant.

3. **Chain Split Risk**: Persistent state divergence can prevent validators from reaching consensus on subsequent blocks, potentially requiring manual intervention or a hard fork to resolve.

4. **No Recovery Mechanism**: Once dependencies are lost from the data structure and the `AbortManager`, there's no way to reconstruct them. The affected transactions will permanently proceed with invalid reads.

This meets the **Critical Severity** criteria: "Consensus/Safety violations" potentially leading to "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Likelihood: Medium-High**

The vulnerability can be triggered when:
1. Transactions have read dependencies on earlier transaction writes
2. The earlier transaction re-executes with a new incarnation
3. An error condition occurs during dependency processing

Error conditions that trigger this include:
- Code invariant violations in `check_lowest_dependency_idx()`
- Attempting to invalidate a transaction index <= owner transaction index
- Attempting to invalidate a higher incarnation when a lower one was already invalidated by the same `AbortManager`
- Any `PanicError` returned from `write_v2()`, `remove_v2()`, or related operations

While these are designed to be "impossible" conditions indicating bugs, they exist as error paths in production code. Under high concurrency with complex dependency graphs, race conditions or timing issues could trigger these paths. Additionally, any future bugs in Block-STM logic could activate these error conditions, making this a latent vulnerability.

## Recommendation
Implement robust error handling to ensure dependencies are never lost, even on error paths:

**Solution 1: Ensure AbortManager is always consumed**
```rust
// In executor.rs process_resource_output_v2()
fn process_resource_output_v2(
    maybe_output: Option<&E::Output>,
    idx_to_execute: TxnIndex,
    incarnation: Incarnation,
    last_input_output: &TxnLastInputOutput<T, E::Output>,
    versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
    abort_manager: &mut AbortManager,
) -> Result<(), PanicError> {
    // Wrap the entire function body in a result that ensures cleanup
    let result = (|| {
        // ... existing logic ...
    })();
    
    // If error occurred, still need to handle partial state in abort_manager
    if result.is_err() {
        // Log warning about partial invalidation state
        warn!("Error during resource output processing with partial dependencies invalidated");
    }
    
    result
}
```

**Solution 2: Make AbortManager failure-atomic**
Modify `AbortManager::invalidate_dependencies()` to use a two-phase approach:
```rust
pub(crate) fn invalidate_dependencies(
    &mut self,
    dependencies: BTreeMap<TxnIndex, Incarnation>,
) -> Result<(), PanicError> {
    // Phase 1: Validate all dependencies first
    for (txn_idx, incarnation) in &dependencies {
        self.validate_can_invalidate(*txn_idx, *incarnation)?;
    }
    
    // Phase 2: Only proceed with invalidation if all validations passed
    for (txn_idx, incarnation) in dependencies {
        self.invalidate(txn_idx, incarnation)?;
    }
    Ok(())
}
```

**Solution 3: Implement Drop handler**
```rust
impl<'a> Drop for AbortManager<'a> {
    fn drop(&mut self) {
        if !self.invalidated_dependencies.is_empty() {
            // Log critical error if dependencies are being dropped
            error!(
                "AbortManager dropped with {} unprocessed dependencies for txn ({}, {})",
                self.invalidated_dependencies.len(),
                self.owner_txn_idx,
                self.owner_incarnation
            );
            // Potentially halt the node to prevent consensus divergence
            panic!("Unprocessed dependencies in AbortManager");
        }
    }
}
```

**Recommended Approach:** Combine Solutions 2 and 3. Solution 2 makes the operation atomic (all-or-nothing), preventing partial state. Solution 3 adds defense-in-depth to catch any bugs and halt the node rather than silently allowing consensus divergence.

## Proof of Concept
```rust
// Reproduction scenario for integration testing
#[test]
fn test_dependency_loss_on_error() {
    // Setup: Block with transactions where T5 depends on T3
    let mut executor = create_test_executor();
    let mut versioned_cache = MVHashMap::new();
    let scheduler = SchedulerV2::new(num_txns);
    
    // Step 1: T3 executes (incarnation 0), writes to key X
    executor.execute(3, 0, write_transaction(X, value1));
    
    // Step 2: T5 executes, reads X from T3
    // This registers T5 as dependent on T3's write
    executor.execute(5, 0, read_transaction(X));
    
    // Step 3: T3 re-executes (incarnation 1) with different value
    // This should trigger dependency invalidation for T5
    let mut abort_manager = AbortManager::new(3, 1, &scheduler);
    
    // Step 4: Inject error condition during invalidate_dependencies
    // For example, attempt to invalidate T3 itself (txn_idx <= owner_txn_idx)
    let malformed_deps = BTreeMap::from([
        (5, 0), // Valid dependency on T5
        (3, 0), // Invalid: trying to invalidate self (triggers error)
    ]);
    
    // This should fail with PanicError at the second dependency
    let result = abort_manager.invalidate_dependencies(malformed_deps);
    assert!(result.is_err());
    
    // Step 5: abort_manager is dropped here without finish_execution()
    drop(abort_manager);
    
    // Step 6: Verify that T5's dependency is lost
    // T5 should have been aborted but wasn't
    let t5_status = scheduler.get_status(5);
    assert_ne!(t5_status, Aborted); // Bug: T5 is still executing
    
    // Step 7: T5 commits with stale read
    executor.commit(5);
    
    // Result: Consensus violation - T5 committed with value1 
    // but should have re-read to get value2 from T3's new incarnation
}
```

This vulnerability represents a critical flaw in Block-STM's dependency tracking mechanism that can lead to consensus divergence and state inconsistencies across the Aptos network.

### Citations

**File:** aptos-move/mvhashmap/src/registered_dependencies.rs (L120-122)
```rust
    pub(crate) fn split_off(&mut self, txn_idx: TxnIndex) -> BTreeMap<TxnIndex, Incarnation> {
        self.dependencies.split_off(&txn_idx)
    }
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L170-171)
```rust
                // Take dependencies above txn_idx
                affected_deps = dependencies.lock().split_off(txn_idx + 1);
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L684-711)
```rust
        let (affected_dependencies, validation_passed) = v
            .split_off_affected_read_dependencies::<ONLY_COMPARE_METADATA>(
                txn_idx,
                &data,
                &maybe_layout,
            );

        // Asserted (local, easily checkable invariant), since affected dependencies are obtained
        // by calling split_off at txn_idx + 1.
        assert!(check_lowest_dependency_idx(&affected_dependencies, txn_idx).is_ok());

        // If validation passed, keep the dependencies (pass to write_impl), o.w. return them
        // (invalidated read dependencies) to the caller.
        let (deps_to_retain, deps_to_return) = if validation_passed {
            (affected_dependencies, BTreeMap::new())
        } else {
            (BTreeMap::new(), affected_dependencies)
        };

        Self::write_impl(
            &mut v,
            txn_idx,
            incarnation,
            ValueWithLayout::Exchanged(data, maybe_layout),
            deps_to_retain,
        );

        Ok(deps_to_return)
```

**File:** aptos-move/block-executor/src/executor.rs (L192-200)
```rust
                        abort_manager.invalidate_dependencies(
                            versioned_cache.data().write_v2::<false>(
                                key,
                                idx_to_execute,
                                incarnation,
                                value,
                                maybe_layout,
                            )?,
                        )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L512-512)
```rust
        if let Some(module_validation_requirements) = scheduler.finish_execution(abort_manager)? {
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L147-157)
```rust
    pub(crate) fn invalidate_dependencies(
        &mut self,
        dependencies: BTreeMap<TxnIndex, Incarnation>,
    ) -> Result<(), PanicError> {
        // Might want to consider iterating over incarnations in reverse order to ensure
        // that invalidate method implementation can avoid outdated try_abort calls.
        for (txn_idx, incarnation) in dependencies {
            self.invalidate(txn_idx, incarnation)?;
        }
        Ok(())
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L164-171)
```rust
        if invalidated_txn_idx <= self.owner_txn_idx {
            return Err(code_invariant_error(format!(
                "Execution of version ({}, {}) may not invalidate lower version ({}, {})",
                self.owner_txn_idx,
                self.owner_incarnation,
                invalidated_txn_idx,
                invalidated_incarnation,
            )));
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L198-203)
```rust
                    return Err(code_invariant_error(format!(
                        "Lower incarnation {} than {} already invalidated by Abort Manager for txn version ({}, {})",
                        *stored_successful_abort_incarnation, invalidated_incarnation,
                        self.owner_txn_idx, self.owner_incarnation
                    )));
                }
```
