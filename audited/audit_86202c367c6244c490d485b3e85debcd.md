# Audit Report

## Title
Inconsistent Expiration Validation in Batch Reception Allows Storage Exhaustion by Malicious Validators

## Summary
The quorum store batch handling has inconsistent expiration validation between `SignedBatchInfo::verify()` and `Batch::verify()`. While SignedBatchInfo verification enforces an upper bound on expiration times, the Batch verification path used when receiving batch data does not validate expiration bounds. This allows a malicious validator to create batches with far-future expiration times that will remain in storage indefinitely, exhausting per-peer storage quota on victim nodes.

## Finding Description

The vulnerability exists due to a verification gap in the batch reception flow:

**Path 1 - SignedBatchInfo (properly validates expiration):** [1](#0-0) 

This verification checks that expiration is not more than `max_batch_expiry_gap_usecs` (60 seconds default) beyond current time.

**Path 2 - BatchMsg/Batch (missing expiration validation):** [2](#0-1) 

This verification only checks payload integrity (hash, author, transaction counts, gas prices) but **does not validate expiration bounds**.

When batches are received via `BatchMsg`, they follow the unvalidated path: [3](#0-2) 

The batch storage only checks the lower bound (expiration must be greater than last_certified_time): [4](#0-3) 

The cleanup mechanism uses expiration times to determine when batches can be removed: [5](#0-4) 

**Attack Flow:**
1. Malicious validator modifies their batch generator to set expiration = current_time + 1 year (instead of the default 60 seconds)
2. They broadcast BatchMsg containing these batches to other validators
3. Victim validators verify via `Batch::verify()` which does NOT check expiration bounds
4. Batches are persisted via `batch_store.save()` which only checks lower bound
5. Batches remain in storage consuming the per-peer quota (300 MB per validator) until the far-future expiration time
6. Once quota is exhausted, legitimate batches from that validator cannot be stored

## Impact Explanation

**Medium Severity** - This meets the Medium severity criteria for "State inconsistencies requiring intervention":

- Each malicious validator can tie up 300 MB of storage on every other validator node for extended periods
- In a network with N validators, if M are malicious, total tied storage = M × N × 300 MB
- Storage quota exhaustion prevents legitimate batch processing from affected validators
- Requires manual intervention to identify and remove malicious batches
- Does not directly cause consensus failure but degrades network performance

The per-peer quota system limits the damage: [6](#0-5) 

However, this is still concerning because multiple malicious validators can collectively exhaust significant storage across the network.

## Likelihood Explanation

**Low to Medium Likelihood:**

**Requirements:**
- Attacker must be a validator (privileged insider)
- Attacker must modify their node software to generate malicious batches
- This is an insider threat scenario

**Mitigating Factors:**
- Per-peer quota limits damage from each malicious validator
- Validators are typically operated by reputable entities
- Epoch transitions provide natural cleanup boundaries for old batches

However, the inconsistency in validation represents a **defense gap** - if expiration bounds are security-critical (as evidenced by SignedBatchInfo checking them), they should be enforced consistently across all batch reception paths.

## Recommendation

Add expiration bound validation to `Batch::verify()` to match the security properties enforced by `SignedBatchInfo::verify()`:

```rust
pub fn verify(&self, max_expiry_gap_usecs: u64) -> anyhow::Result<()> {
    ensure!(
        self.payload.author() == self.author(),
        "Payload author doesn't match the info"
    );
    ensure!(
        self.payload.hash() == *self.digest(),
        "Payload hash doesn't match the digest"
    );
    ensure!(
        self.payload.num_txns() as u64 == self.num_txns(),
        "Payload num txns doesn't match batch info"
    );
    ensure!(
        self.payload.num_bytes() as u64 == self.num_bytes(),
        "Payload num bytes doesn't match batch info"
    );
    
    // Add expiration validation
    if self.expiration()
        > aptos_infallible::duration_since_epoch().as_micros() as u64
            + max_expiry_gap_usecs
    {
        bail!(
            "Batch expiration too far in future: {} > {}",
            self.expiration(),
            aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_expiry_gap_usecs
        );
    }
    
    for txn in self.payload.txns() {
        ensure!(
            txn.gas_unit_price() >= self.gas_bucket_start(),
            "Payload gas unit price doesn't match batch info"
        );
        ensure!(
            !txn.payload().is_encrypted_variant(),
            "Encrypted transaction is not supported yet"
        );
    }
    Ok(())
}
```

Update `BatchMsg::verify()` to pass the max_expiry_gap parameter and ensure both verification paths enforce the same security invariant.

## Proof of Concept

**Note:** This vulnerability requires insider access (malicious validator with code modification capabilities), which is outside the scope of typical bug bounty programs per the trust model. However, the proof demonstrates the defense gap:

```rust
// Malicious validator modification in batch_generator.rs
// Instead of:
let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
    + self.config.batch_expiry_gap_when_init_usecs; // 60 seconds

// Malicious validator sets:
let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
    + 365 * 24 * 60 * 60 * 1_000_000; // 1 year in microseconds

// The batch will pass Batch::verify() on victim nodes
// It will be stored until expiry_time is reached
// Consuming per-peer storage quota for extended period
```

**Validation Checklist Assessment:**
- ❌ Exploitable by unprivileged attacker: NO - requires validator access
- ❌ No insider access required: FAILS - requires malicious validator
- ✓ Breaks resource limits invariant
- ✓ Clear defense gap in validation logic
- ⚠️ Impact limited by per-peer quota system

Given the strict validation criteria requiring exploitation "without privileged validator access," this finding has **limited applicability** but highlights an important **consistency issue** in the security design.

## Notes

While this represents a genuine inconsistency in the validation logic, it **does not meet the strict criteria** for a valid vulnerability report because:

1. Requires validator insider access (malicious validator)
2. Requires code modification by the attacker
3. Trust model explicitly excludes malicious validators unless insider threats are the focus
4. Per-peer quotas provide significant mitigation

The finding is more accurately described as a **defense-in-depth gap** rather than an exploitable vulnerability for external attackers. The recommendation to add consistent validation remains valid for hardening the system against insider threats.

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L459-482)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        if sender != self.signer {
            bail!("Sender {} mismatch signer {}", sender, self.signer);
        }

        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }

        Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L173-244)
```rust
    pub(crate) async fn handle_batches_msg(
        &mut self,
        author: PeerId,
        batches: Vec<Batch<BatchInfoExt>>,
    ) {
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }

        let Some(batch) = batches.first() else {
            error!("Empty batch received from {}", author.short_str().as_str());
            return;
        };

        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }

        let approx_created_ts_usecs = batch
            .info()
            .expiration()
            .saturating_sub(self.batch_expiry_gap_when_init_usecs);

        if approx_created_ts_usecs > 0 {
            observe_batch(
                approx_created_ts_usecs,
                batch.author(),
                BatchStage::RECEIVED,
            );
        }

        let mut persist_requests = vec![];
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
        }
        counters::RECEIVED_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        if author != self.my_peer_id {
            counters::RECEIVED_REMOTE_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        }
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
```

**File:** consensus/src/quorum_store/batch_store.rs (L419-439)
```rust
    pub(crate) fn save(&self, value: &PersistedValue<BatchInfoExt>) -> anyhow::Result<bool> {
        let last_certified_time = self.last_certified_time();
        if value.expiration() > last_certified_time {
            fail_point!("quorum_store::save", |_| {
                // Skip caching and storing value to the db
                Ok(false)
            });
            counters::GAP_BETWEEN_BATCH_EXPIRATION_AND_CURRENT_TIME_WHEN_SAVE.observe(
                Duration::from_micros(value.expiration() - last_certified_time).as_secs_f64(),
            );

            return self.insert_to_cache(value);
        }
        counters::NUM_BATCH_EXPIRED_WHEN_SAVE.inc();
        bail!(
            "Incorrect expiration {} in epoch {}, last committed timestamp {}",
            value.expiration(),
            self.epoch(),
            last_certified_time,
        );
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L443-472)
```rust
    pub(crate) fn clear_expired_payload(&self, certified_time: u64) -> Vec<HashValue> {
        // To help slow nodes catch up via execution without going to state sync we keep the blocks for 60 extra seconds
        // after the expiration time. This will help remote peers fetch batches that just expired but are within their
        // execution window.
        let expiration_time = certified_time.saturating_sub(self.expiration_buffer_usecs);
        let expired_digests = self.expirations.lock().expire(expiration_time);
        let mut ret = Vec::new();
        for h in expired_digests {
            let removed_value = match self.db_cache.entry(h) {
                Occupied(entry) => {
                    // We need to check up-to-date expiration again because receiving the same
                    // digest with a higher expiration would update the persisted value and
                    // effectively extend the expiration.
                    if entry.get().expiration() <= expiration_time {
                        self.persist_subscribers.remove(entry.get().digest());
                        Some(entry.remove())
                    } else {
                        None
                    }
                },
                Vacant(_) => unreachable!("Expired entry not in cache"),
            };
            // No longer holding the lock on db_cache entry.
            if let Some(value) = removed_value {
                self.free_quota(value);
                ret.push(h);
            }
        }
        ret
    }
```

**File:** config/src/config/quorum_store_config.rs (L133-135)
```rust
            memory_quota: 120_000_000,
            db_quota: 300_000_000,
            batch_quota: 300_000,
```
