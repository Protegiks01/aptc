# Audit Report

## Title
Critical Consensus Failure via Incomplete Runtime Validation When Config Sanitizer and Optimizer Are Skipped

## Summary
When both `skip_config_optimizer=true` and `skip_config_sanitizer=true` are set in a validator's node configuration, the runtime validation is insufficient to prevent a validator from starting with an incorrect `network_id` for the validator network. This allows a validator to start successfully but without any consensus protocol registered, causing complete consensus participation failure and potential network liveness issues.

## Finding Description

The vulnerability exists due to incomplete defense-in-depth validation. The system relies on three layers of validation:

1. **Config Optimizer** - Automatically sets `network_id` to `NetworkId::Validator` and `mutual_authentication` to `true` for validator networks [1](#0-0) 

2. **Config Sanitizer** - Validates that validator networks have `is_validator_network()` returning true AND `mutual_authentication` enabled [2](#0-1) 

3. **Runtime Check** - Only validates `mutual_authentication`, does NOT validate `network_id` [3](#0-2) 

When both optimizer and sanitizer are skipped (via the node startup config flags): [4](#0-3) 

The runtime check only validates `mutual_authentication` but crucially does NOT validate the `network_id`. This allows a misconfigured validator to proceed to network setup.

During network setup, consensus protocols are only registered when `network_id.is_validator_network()` returns true: [5](#0-4) 

The `is_validator_network()` method only returns true for `NetworkId::Validator`: [6](#0-5) 

**Attack Scenario:**
A validator operator creates a configuration file with:
```yaml
validator_network:
  network_id: "Public"  # Wrong - should be "Validator"
  mutual_authentication: true  # Correct
node_startup:
  skip_config_optimizer: true
  skip_config_sanitizer: true
```

**Execution Flow:**
1. Config optimizer is skipped - doesn't correct the `network_id`
2. Config sanitizer is skipped - doesn't validate `network_id.is_validator_network()`
3. Runtime check passes - only checks `mutual_authentication` which is correctly set to true
4. Network setup code evaluates `network_id.is_validator_network()` â†’ returns `false`
5. Consensus, DKG, and JWK consensus network handles are NOT registered
6. Validator starts successfully but has NO functioning consensus layer
7. Consensus runtime creation returns `None`: [7](#0-6) 

## Impact Explanation

This is a **CRITICAL** severity vulnerability (up to $1,000,000 per Aptos bug bounty) because it causes:

1. **Consensus Safety/Liveness Violation**: A validator that appears to be running but cannot participate in consensus breaks the Byzantine Fault Tolerance assumptions. If enough validators are misconfigured, the network cannot reach quorum.

2. **Total Loss of Network Availability**: If multiple validators are affected, the network may experience liveness failure requiring manual intervention or hard fork to recover.

3. **Difficult Detection**: The node starts successfully without obvious errors, making the misconfiguration hard to detect until consensus participation is expected.

4. **Breaks Critical Invariant**: Violates the "Consensus Safety" invariant that AptosBFT must prevent chain splits and ensure liveness under < 1/3 Byzantine failures.

## Likelihood Explanation

**Moderate to High Likelihood:**

- Validator operators may set these flags during debugging or testing and forget to remove them
- Configuration templates or deployment scripts could inadvertently include these flags
- Social engineering attacks could trick operators into using "optimized" configs with these flags
- The misconfiguration is not immediately obvious as the node appears to start successfully
- No runtime panic or error prevents the node from starting in this state

## Recommendation

Add comprehensive runtime validation that checks BOTH `mutual_authentication` AND `network_id` for validator networks. The runtime check should be enhanced as follows:

**In `aptos-node/src/network.rs`, function `extract_network_configs`:**

```rust
fn extract_network_configs(node_config: &NodeConfig) -> Vec<NetworkConfig> {
    let mut network_configs: Vec<NetworkConfig> = node_config.full_node_networks.to_vec();
    if let Some(network_config) = node_config.validator_network.as_ref() {
        // Ensure that mutual authentication is enabled by default!
        if !network_config.mutual_authentication {
            panic!("Validator networks must always have mutual_authentication enabled!");
        }
        
        // ADDED: Ensure that network_id is correct for validator networks!
        if !network_config.network_id.is_validator_network() {
            panic!("Validator network must have network_id set to NetworkId::Validator! Found: {:?}", network_config.network_id);
        }
        
        network_configs.push(network_config.clone());
    }
    network_configs
}
```

This creates defense-in-depth by ensuring that even if both the optimizer and sanitizer are skipped, the runtime check will catch the misconfiguration before the node can start in an invalid state.

## Proof of Concept

Create a test configuration file `test_validator_misconfigured.yaml`:

```yaml
base:
  role: "validator"
  data_dir: "/tmp/aptos-test"

node_startup:
  skip_config_optimizer: true
  skip_config_sanitizer: true

validator_network:
  network_id: "Public"  # Intentionally wrong
  mutual_authentication: true
  listen_address: "/ip4/0.0.0.0/tcp/6180"
  identity:
    type: "from_config"
    key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"

execution:
  genesis_file_location: "genesis.blob"
```

**Expected behavior with current code:**
- Node starts successfully
- Consensus network handle is NOT created
- Validator cannot participate in consensus

**Expected behavior with fix:**
- Node panics at runtime with error: "Validator network must have network_id set to NetworkId::Validator! Found: Public"
- Prevents misconfigured validator from starting

## Notes

This vulnerability demonstrates a critical gap in the runtime validation that assumes the config optimizer and sanitizer will always run. The system should enforce critical security invariants at runtime regardless of configuration preprocessing steps. The fix ensures that validators cannot start with configurations that would render them unable to participate in consensus, maintaining the Byzantine Fault Tolerance properties of the AptosBFT protocol.

### Citations

**File:** config/src/config/config_optimizer.rs (L252-261)
```rust
        if local_network_config_yaml["network_id"].is_null() {
            validator_network_config.network_id = NetworkId::Validator;
            modified_config = true;
        }

        // We must enable mutual authentication for the validator network
        if local_network_config_yaml["mutual_authentication"].is_null() {
            validator_network_config.mutual_authentication = true;
            modified_config = true;
        }
```

**File:** config/src/config/config_sanitizer.rs (L176-197)
```rust
        if !network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config must have a validator network ID!".into(),
            ));
        }

        // Verify that the node is a validator
        if !node_type.is_validator() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config cannot be set for non-validators!".into(),
            ));
        }

        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** aptos-node/src/network.rs (L220-226)
```rust
    if let Some(network_config) = node_config.validator_network.as_ref() {
        // Ensure that mutual authentication is enabled by default!
        if !network_config.mutual_authentication {
            panic!("Validator networks must always have mutual_authentication enabled!");
        }
        network_configs.push(network_config.clone());
    }
```

**File:** aptos-node/src/network.rs (L293-334)
```rust
        let network_id = network_config.network_id;
        if network_id.is_validator_network() {
            // A validator node must have only a single consensus network handle
            if consensus_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    consensus_network_configuration(node_config),
                    true,
                );
                consensus_network_handle = Some(network_handle);
            }

            if dkg_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    dkg_network_configuration(node_config),
                    true,
                );
                dkg_network_handle = Some(network_handle);
            }

            if jwk_consensus_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    jwk_consensus_network_configuration(node_config),
                    true,
                );
                jwk_consensus_network_handle = Some(network_handle);
            }
        }
```

**File:** config/src/config/node_startup_config.rs (L8-11)
```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/network_id.rs (L168-170)
```rust
    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** aptos-node/src/consensus.rs (L50-50)
```rust
    consensus_network_interfaces.map(|consensus_network_interfaces| {
```
