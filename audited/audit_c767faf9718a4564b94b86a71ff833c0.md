# Audit Report

## Title
DKG Panic Vulnerability: Malicious Empty Vector in `get_dealt_public_key()` Causes Node Crash

## Summary
The `get_dealt_public_key()` function in the DKG (Distributed Key Generation) weighted protocol calls `.last().unwrap()` on the `V_hat` vector without validating it is non-empty. A malicious validator can craft a transcript with an empty `V_hat` vector, send it to peers, and cause their DKG processes to panic and crash when the transcript is processed before full verification.

## Finding Description

The vulnerability exists in the DKG transcript verification flow where `verify_transcript_extra()` is called before `verify_transcript()`. This ordering issue allows unsafe access to unvalidated data structures.

**Vulnerable Code Location:** [1](#0-0) 

The function assumes `V_hat` is non-empty and directly calls `.last().unwrap()`. The `V_hat` vector should contain `W + 1` elements (where `W` is the total weight), with the last element being the dealt public key commitment.

**Attack Path:**

1. A malicious validator crafts a `Transcript` with `V_hat = []` (empty vector)
2. The transcript is serialized and broadcast to peers via the DKG network protocol
3. Honest validators receive and deserialize the malicious transcript: [2](#0-1) 

4. The deserialization succeeds because BCS deserialization only validates type structure, not business logic invariants: [3](#0-2) 

5. The system calls `verify_transcript_extra()` BEFORE `verify_transcript()`: [4](#0-3) 

6. Inside `verify_transcript_extra()`, the code calls `get_dealt_public_key()` to compare transcripts: [5](#0-4) 

7. This triggers the panic on the empty vector, crashing the DKG process

**Why Size Validation Comes Too Late:**

The `check_sizes()` function validates that `V_hat.len() == W + 1`: [6](#0-5) 

However, this check is only called inside `verify()`, which happens AFTER `verify_transcript_extra()` has already called the vulnerable `get_dealt_public_key()` function.

**Production Usage Confirmation:**

The production DKG system uses the vulnerable weighted protocol: [7](#0-6) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Validator Node Crashes**: Any validator processing the malicious transcript will panic and crash their DKG process
2. **DKG Protocol Disruption**: The DKG is critical for epoch transitions and randomness generation in consensus
3. **Network-Wide Impact**: A single malicious validator can broadcast the crafted transcript to all peers, potentially halting DKG network-wide
4. **Liveness Failure**: While this doesn't cause permanent state corruption, it disrupts critical protocol operations

The impact qualifies as "Validator node slowdowns" and "Significant protocol violations" under the High Severity category (up to $50,000).

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- No special privileges required beyond being a network peer
- Crafting the malicious transcript requires only setting `V_hat = []` during serialization
- The vulnerability is deterministic - it will panic 100% of the time when triggered
- The vulnerable code path is executed during normal DKG operation whenever peers exchange transcripts

The only complexity is that the attacker must participate in the DKG protocol, but this is straightforward for any validator or even a malicious node that can inject messages into the DKG network layer.

## Recommendation

**Fix 1: Safe Vector Access**

Replace `.unwrap()` with proper error handling:

```rust
fn get_dealt_public_key(&self) -> Self::DealtPubKey {
    Self::DealtPubKey::new(
        *self.V_hat.last()
            .ok_or_else(|| anyhow::anyhow!("V_hat vector is empty"))
            .expect("V_hat should contain dealt public key")
    )
}
```

However, this only converts a panic to a different panic. Better approach:

**Fix 2: Validate Before Unsafe Operations**

Reorder the verification to call `verify_transcript()` before `verify_transcript_extra()`: [4](#0-3) 

Change to:
```rust
S::verify_transcript(&self.dkg_pub_params, &transcript)
    .context("transcript verification failed")?;

S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
    .context("extra verification failed")?;
```

**Fix 3: Add Early Size Validation**

Add size validation immediately after deserialization as a defensive measure:

```rust
let transcript = bcs::from_bytes(transcript_bytes.as_slice())?;
// Validate basic structural invariants before any processing
if let Err(e) = transcript.main.check_sizes(&self.dkg_pub_params.pvss_config.wconfig) {
    bail!("Invalid transcript structure: {}", e);
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
fn test_empty_v_hat_panic() {
    use aptos_dkg::pvss::das::weighted_protocol::Transcript;
    use blstrs::{G1Projective, G2Projective};
    
    // Create a malicious transcript with empty V_hat
    let malicious_transcript = Transcript {
        soks: vec![],
        R: vec![],
        R_hat: vec![],
        V: vec![],
        V_hat: vec![], // Empty vector - this is the malicious input
        C: vec![],
    };
    
    // This will panic when trying to get the dealt public key
    let _ = malicious_transcript.get_dealt_public_key();
}

#[test]
fn test_malicious_transcript_via_deserialization() {
    use aptos_dkg::pvss::das::weighted_protocol::Transcript;
    
    // Craft a minimal transcript with empty V_hat
    let malicious_transcript = Transcript {
        soks: vec![],
        R: vec![],
        R_hat: vec![],
        V: vec![],
        V_hat: vec![],
        C: vec![],
    };
    
    // Serialize it
    let serialized = bcs::to_bytes(&malicious_transcript)
        .expect("serialization should succeed");
    
    // Deserialize (this succeeds - no validation yet)
    let deserialized: Transcript = bcs::from_bytes(&serialized)
        .expect("deserialization should succeed");
    
    // Attempting to get dealt public key will panic
    // This simulates what happens in verify_transcript_extra
    let result = std::panic::catch_unwind(|| {
        deserialized.get_dealt_public_key()
    });
    
    assert!(result.is_err(), "Should panic on empty V_hat");
}
```

## Notes

The same vulnerability pattern exists in two other DKG implementations:
- [8](#0-7) 
- [9](#0-8) 

The chunky weighted transcript variants (v1 and v2) are NOT vulnerable as they use direct field access to `V0` instead of `.last().unwrap()`:
- [10](#0-9) 

All three vulnerable implementations should be fixed to prevent this attack vector across different DKG protocol variants.

### Citations

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L82-90)
```rust
impl TryFrom<&[u8]> for Transcript {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        // NOTE: The `serde` implementation in `blstrs` already performs the necessary point validation
        // by ultimately calling `GroupEncoding::from_bytes`.
        bcs::from_bytes::<Transcript>(bytes).map_err(|_| CryptoMaterialError::DeserializationError)
    }
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L215-217)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V_hat.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L426-432)
```rust
        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L88-90)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-38)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
```

**File:** types/src/dkg/real_dkg/mod.rs (L324-327)
```rust
        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L173-175)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/insecure_field/transcript.rs (L125-127)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L565-567)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(self.subtrs.V0.into_affine())
    }
```
