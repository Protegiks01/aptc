# Audit Report

## Title
Case-Sensitive Collection Names Enable NFT Phishing and User Confusion Attacks

## Summary
Collection names in Aptos Token Objects (v2) are case-sensitive, allowing attackers to create multiple collections with the same name but different capitalizations (e.g., "MyCollection" and "mycollection") at the same creator address. This enables phishing attacks and causes user confusion about legitimate NFT ownership.

## Finding Description

The collection address derivation mechanism in Aptos treats collection names as case-sensitive byte sequences without any normalization. When a collection is created, its address is computed by hashing the creator address concatenated with the collection name's raw bytes. [1](#0-0) [2](#0-1) 

The Move framework's collection creation uses this mechanism directly without case normalization: [3](#0-2) [4](#0-3) 

The object creation system only prevents exact duplicate addresses, not case variations: [5](#0-4) 

**Attack Path:**
1. Attacker observes a popular collection "PremiumNFTs" at creator address 0xABCD
2. Attacker creates collections with variations: "premiumnfts", "PREMIUMNFTS", "PremiumNfts", "premiumNFTs" at their own address 0xEVIL
3. Each variation produces a unique collection address and successfully creates
4. Users searching for "premium nfts" find multiple collections with similar names
5. Marketplace interfaces that perform case-insensitive searches display both legitimate and fake collections
6. Users purchase NFTs from attacker's fake collections, believing they are legitimate

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **Limited funds loss**: Users can be tricked into purchasing worthless NFTs from fake collections, resulting in financial loss
- **User confusion**: Legitimate collection owners suffer reputation damage when fake collections appear with similar names
- **Marketplace integrity**: Indexers and marketplaces that don't implement strict case-sensitive filtering may display incorrect collection metadata

While not directly causing consensus violations or protocol-level failures, this vulnerability enables systematic phishing attacks against NFT users and undermines the trustworthiness of the NFT ecosystem.

## Likelihood Explanation

**High Likelihood:**
- Zero barriers to exploitation - any user can create collections
- No special permissions or validator access required
- Simple to execute - just call collection creation with different case variations
- Profitable for attackers targeting popular collections
- Difficult for average users to distinguish legitimate collections from fakes based on name alone

The attack becomes even more effective when:
- Collection names use mixed case or special characters
- Marketplaces implement case-insensitive search
- Users rely on collection names rather than addresses for verification

## Recommendation

Implement case-insensitive collection name validation by normalizing collection names to lowercase before deriving addresses:

**Rust Implementation (`types/src/account_address.rs`):**
```rust
pub fn create_collection_address(creator: AccountAddress, collection: &str) -> AccountAddress {
    // Normalize to lowercase to prevent case variation attacks
    let normalized_name = collection.to_lowercase();
    create_object_address(creator, normalized_name.as_bytes())
}
```

**Move Implementation (`aptos-move/framework/aptos-token-objects/sources/collection.move`):**
```move
public fun create_collection_seed(name: &String): vector<u8> {
    assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));
    // Convert to lowercase before using as seed
    let lowercase_name = to_lowercase(name);
    *lowercase_name.bytes()
}
```

Additionally, add validation to reject collection names that normalize to existing collections:
1. Before creating a collection, compute the normalized address
2. Check if any collection at the creator address normalizes to the same lowercase name
3. Reject creation if a case-insensitive collision is detected

This maintains backward compatibility for existing collections while preventing future exploitation.

## Proof of Concept

```move
#[test_only]
module test_address::collection_case_sensitivity_test {
    use std::string;
    use std::signer;
    use aptos_token_objects::collection;
    use aptos_framework::object;

    #[test(creator = @0x123)]
    fun test_case_sensitive_collections_allowed(creator: &signer) {
        let creator_addr = signer::address_of(creator);
        
        // Create collection with uppercase
        let name_upper = string::utf8(b"MyCollection");
        collection::create_unlimited_collection(
            creator,
            string::utf8(b"Description 1"),
            name_upper,
            option::none(),
            string::utf8(b"https://example.com/1")
        );
        
        // Create collection with lowercase - SHOULD FAIL BUT SUCCEEDS
        let name_lower = string::utf8(b"mycollection");
        collection::create_unlimited_collection(
            creator,
            string::utf8(b"Description 2"),
            name_lower,
            option::none(),
            string::utf8(b"https://example.com/2")
        );
        
        // Verify both collections exist with different addresses
        let addr_upper = collection::create_collection_address(&creator_addr, &name_upper);
        let addr_lower = collection::create_collection_address(&creator_addr, &name_lower);
        
        assert!(addr_upper != addr_lower, 0); // Different addresses - VULNERABILITY
        assert!(object::object_exists<collection::Collection>(addr_upper), 1);
        assert!(object::object_exists<collection::Collection>(addr_lower), 2);
        
        // Both collections exist simultaneously, enabling phishing attacks
    }
}
```

**Expected Behavior:** The second collection creation should fail with a case-insensitive name collision error.

**Actual Behavior:** Both collections are created successfully with different addresses, allowing an attacker to create confusingly similar collections.

## Notes

This vulnerability is categorized as Medium severity because while it doesn't directly compromise consensus or protocol safety, it enables practical attacks that result in financial loss for users. The issue is particularly concerning for:

1. **High-value NFT collections** where name recognition is critical
2. **Marketplace platforms** that implement case-insensitive search functionality
3. **Mobile applications** where users may not carefully verify collection addresses

The fix requires careful consideration of backward compatibility, as existing collections with case variations would need migration logic or grandfathering.

### Citations

**File:** types/src/account_address.rs (L148-150)
```rust
pub fn create_collection_address(creator: AccountAddress, collection: &str) -> AccountAddress {
    create_object_address(creator, collection.as_bytes())
}
```

**File:** types/src/account_address.rs (L175-181)
```rust
pub fn create_object_address(creator: AccountAddress, seed: &[u8]) -> AccountAddress {
    let mut input = bcs::to_bytes(&creator).unwrap();
    input.extend(seed);
    input.push(Scheme::DeriveObjectAddressFromSeed as u8);
    let hash = HashValue::sha3_256_of(&input);
    AccountAddress::from_bytes(hash.as_ref()).unwrap()
}
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L367-370)
```text
    public fun create_collection_seed(name: &String): vector<u8> {
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));
        *name.bytes()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L215-220)
```text
    public fun create_object_address(source: &address, seed: vector<u8>): address {
        let bytes = bcs::to_bytes(source);
        bytes.append(seed);
        bytes.push_back(OBJECT_FROM_SEED_ADDRESS_SCHEME);
        from_bcs::to_address(hash::sha3_256(bytes))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L318-339)
```text
    fun create_object_internal(
        creator_address: address,
        object: address,
        can_delete: bool,
    ): ConstructorRef {
        assert!(!exists<ObjectCore>(object), error::already_exists(EOBJECT_EXISTS));

        let object_signer = create_signer(object);
        let guid_creation_num = INIT_GUID_CREATION_NUM;
        let transfer_events_guid = guid::create(object, &mut guid_creation_num);

        move_to(
            &object_signer,
            ObjectCore {
                guid_creation_num,
                owner: creator_address,
                allow_ungated_transfer: true,
                transfer_events: event::new_event_handle(transfer_events_guid),
            },
        );
        ConstructorRef { self: object, can_delete }
    }
```
