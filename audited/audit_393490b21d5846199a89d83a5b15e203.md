# Audit Report

## Title
Gas Metering Bypass via UTF-8 Validation Before Charge in native_format_list

## Summary
The `native_format_list` function performs UTF-8 validation on the format string before charging gas. When validation fails, the function aborts without charging for the O(n) validation work performed, violating the documented gas charging principle and enabling attackers to execute computation without proportional gas payment.

## Finding Description

The vulnerability exists in `native_format_list` where UTF-8 validation occurs before gas charging, violating the documented principle in SafeNativeContext: "Always remember: first charge gas, then execute! In other words, this function **MUST** always be called **BEFORE** executing **any** gas-metered operation or library call within a native function." [1](#0-0) 

The execution flow in `native_format_list` is:

1. Arguments are popped (lines 601-607)
2. UTF-8 validation is performed on line 609 using `std::str::from_utf8()` - O(n) operation
3. If validation fails, returns `SafeNativeError::Abort` with `abort_code: EINVALID_FORMAT`
4. Gas charging only happens on line 613 - AFTER validation [2](#0-1) 

When the abort is converted to `NativeResult`, it uses `context.legacy_gas_used` which is 0 at this point: [3](#0-2) 

The VM then charges only this 0 amount: [4](#0-3) 

**Comparison with Correct Implementation:**

The stdlib's `native_check_utf8` correctly charges gas BEFORE performing UTF-8 validation: [5](#0-4) 

**Attack Path:**
1. Attacker constructs a large byte vector with invalid UTF-8 (e.g., valid UTF-8 with an invalid byte near the end)
2. Calls `format1()`, `format2()`, `format3()`, or `format4()` from `aptos_std::string_utils` (public functions): [6](#0-5) 

3. The native function performs O(n) UTF-8 validation scanning all bytes
4. Validation fails, returning abort with 0 gas cost
5. Attacker repeats across multiple transactions, getting free O(n) computation

## Impact Explanation

This vulnerability enables a gas metering bypass that violates the fundamental security property that "all computation must be paid for." 

While UTF-8 validation is optimized in Rust's standard library, attackers can amplify the impact by:
- Storing large invalid UTF-8 vectors once (one-time cost)
- Repeatedly calling format functions on these vectors (minimal cost per call)
- Each call performs O(n) validation work without charging proportional gas

This contributes to validator performance degradation through unpaid computation, though the practical impact is limited by:
- Transaction base costs
- Fast UTF-8 validation performance  
- Transaction rate limits

The vulnerability represents a protocol-level violation of documented gas charging principles and creates inconsistency with other native functions that handle UTF-8 validation correctly.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Any unprivileged transaction sender
- **Complexity**: Trivial - single transaction calling `format1(&invalid_utf8_vector, value)`
- **Cost**: Minimal (base transaction cost only, no gas for validation work)
- **Detection**: Indistinguishable from legitimate failed format operations
- **Scalability**: Repeatable across unlimited transactions

No special permissions, validator access, or complex setup required.

## Recommendation

Charge gas BEFORE performing UTF-8 validation, consistent with the documented principle and other native functions:

```rust
fn native_format_list(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ... argument popping code ...
    
    let fmt_ref = safely_pop_arg!(arguments, VectorRef);
    let fmt_ref2 = fmt_ref.as_bytes_ref();
    
    // Charge gas BEFORE validation
    context.charge(STRING_UTILS_PER_BYTE * NumBytes::new(fmt_ref2.as_slice().len() as u64))?;
    
    // Then perform validation
    let fmt = std::str::from_utf8(fmt_ref2.as_slice()).map_err(|_| SafeNativeError::Abort {
        abort_code: EINVALID_FORMAT,
    })?;
    
    // ... rest of function ...
}
```

## Proof of Concept

```move
#[test]
fun test_gas_bypass_via_invalid_utf8() {
    use aptos_std::string_utils;
    
    // Create large vector with invalid UTF-8
    // Valid UTF-8 followed by invalid byte
    let mut invalid_utf8 = vector[];
    let i = 0;
    while (i < 100000) {
        vector::push_back(&mut invalid_utf8, 0x41); // Valid ASCII 'A'
        i = i + 1;
    };
    vector::push_back(&mut invalid_utf8, 0xFF); // Invalid UTF-8 byte
    
    // This performs O(n) UTF-8 validation but charges 0 gas when it fails
    string_utils::format1(&invalid_utf8, 0); // Will abort with EINVALID_FORMAT
}
```

## Notes

The gas parameters for string_utils are defined as: [7](#0-6) 

With `string_utils_base` = 1102 and `string_utils_per_byte` = 3, a 1MB format string should charge 3,001,102 gas units. However, when validation fails before charging, 0 gas is charged despite performing the O(n) validation work.

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-72)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
```

**File:** aptos-move/framework/src/natives/string_utils.rs (L606-613)
```rust
    let fmt_ref = safely_pop_arg!(arguments, VectorRef);
    let fmt_ref2 = fmt_ref.as_bytes_ref();
    // Could use unsafe here, but it's forbidden in this crate.
    let fmt = std::str::from_utf8(fmt_ref2.as_slice()).map_err(|_| SafeNativeError::Abort {
        abort_code: EINVALID_FORMAT,
    })?;

    context.charge(STRING_UTILS_PER_BYTE * NumBytes::new(fmt.len() as u64))?;
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L134-136)
```rust
                    Abort { abort_code } => {
                        Ok(NativeResult::err(context.legacy_gas_used, abort_code))
                    },
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1150-1152)
```rust
            NativeResult::Abort { cost, abort_code } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
                Err(PartialVMError::new(StatusCode::ABORTED).with_sub_status(abort_code))
```

**File:** aptos-move/framework/move-stdlib/src/natives/string.rs (L37-54)
```rust
fn native_check_utf8(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 1);
    let s_arg = safely_pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();

    context.charge(
        STRING_CHECK_UTF8_BASE
            + STRING_CHECK_UTF8_PER_BYTE * NumBytes::new(s_ref.as_slice().len() as u64),
    )?;

    let ok = std::str::from_utf8(s_ref.as_slice()).is_ok();
    // TODO: extensible native cost tables

    Ok(smallvec![Value::bool(ok)])
```

**File:** aptos-move/framework/aptos-stdlib/sources/string_utils.move (L39-50)
```text
    public fun format1<T0: drop>(fmt: &vector<u8>, a: T0): String {
        native_format_list(fmt, &list1(a))
    }
    public fun format2<T0: drop, T1: drop>(fmt: &vector<u8>, a: T0, b: T1): String {
        native_format_list(fmt, &list2(a, b))
    }
    public fun format3<T0: drop, T1: drop, T2: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2): String {
        native_format_list(fmt, &list3(a, b, c))
    }
    public fun format4<T0: drop, T1: drop, T2: drop, T3: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2, d: T3): String {
        native_format_list(fmt, &list4(a, b, c, d))
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L357-358)
```rust
        [string_utils_base: InternalGas, { 8.. => "string_utils.format.base" }, 1102],
        [string_utils_per_byte: InternalGasPerByte, { 8.. =>"string_utils.format.per_byte" }, 3],
```
