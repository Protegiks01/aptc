# Audit Report

## Title
Missing Chunk Size Validation in State Sync Allows Memory Exhaustion Attack

## Summary
The `StateValueChunkWithProof` struct in the state synchronization layer lacks validation on the number of items in the `raw_values` Vec when received from remote peers. While honest nodes limit chunks to 4,000 state values, a malicious peer can send chunks with tens or hundreds of thousands of values (bounded only by the 64 MiB network message size), causing memory spikes and potential validator performance degradation or OOM crashes.

## Finding Description

The state synchronization protocol expects chunks to contain at most `max_state_chunk_size = 4000` state values, as configured in the storage service. [1](#0-0) 

Honest nodes enforce this limit when creating chunks using `max_num_state_values = min(expected_num_state_values, max_num_state_values)` before sending. [2](#0-1) 

However, when **receiving** a `StateValueChunkWithProof` from a remote peer, the code only validates that the indices are consistent with the vector length, without checking if the length exceeds the expected maximum. [3](#0-2) 

The validation only ensures `expected_num_state_values == raw_values.len()` based on the attacker-controlled `first_index` and `last_index` fields, but does NOT verify that this length is â‰¤ 4000.

After passing validation, the entire `raw_values` Vec is passed directly to `add_chunk()` without size checks. [4](#0-3) 

During processing, the code:
1. Clones the entire Vec [5](#0-4) 
2. Iterates through every item to calculate storage usage [6](#0-5) 
3. Converts the Vec into a HashMap [7](#0-6) 

**Attack Scenario:**
1. Malicious peer crafts a `StateValueChunkWithProof` with `raw_values` containing 100,000+ small state values
2. Sets `first_index = 0`, `last_index = 99999` to pass validation
3. Ensures total serialized size < 64 MiB (network limit) [8](#0-7) 
4. Victim node deserializes this chunk, allocating memory for 100,000+ items
5. Processing clones and converts to HashMap, causing memory spike
6. If multiple such chunks arrive concurrently across different connections, memory usage multiplies
7. Result: increased GC pressure, slowdowns, or OOM crashes

## Impact Explanation

This is **High Severity** per the Aptos bug bounty criteria:
- **Validator node slowdowns**: Processing excessively large chunks causes CPU and memory pressure, degrading validator performance
- Potential for OOM crashes if memory is constrained, affecting node availability
- Multiple concurrent malicious peers can amplify the attack

While not reaching Critical severity (no consensus break or fund loss), it significantly impacts validator operations and network health.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires ability to connect as a state sync peer (no validator keys needed)
- **Complexity**: Low - attacker simply needs to craft a valid BCS-serialized `StateValueChunkWithProof` with inflated `raw_values`
- **Detection**: The attack traffic appears as legitimate state sync, making it hard to distinguish from normal operations
- **Feasibility**: The network message size limit (64 MiB) allows for 10-100x the expected chunk size depending on state value sizes

## Recommendation

Add explicit validation in `verify_states_values_indices()` to enforce the maximum chunk size:

```rust
// After line 945 in bootstrapper.rs
let num_state_values = state_value_chunk_with_proof.raw_values.len() as u64;

// Add this validation:
const MAX_STATE_CHUNK_SIZE: u64 = 4000; // Or import from config
if num_state_values > MAX_STATE_CHUNK_SIZE {
    self.reset_active_stream(Some(NotificationAndFeedback::new(
        notification_id,
        NotificationFeedback::InvalidPayloadData,
    )))
    .await?;
    return Err(Error::VerificationError(format!(
        "State chunk size {} exceeds maximum allowed {}",
        num_state_values, MAX_STATE_CHUNK_SIZE
    )));
}

if expected_num_state_values != num_state_values {
    // existing validation...
}
```

Alternatively, add the check in `save_state_values()` before passing to the snapshot receiver.

## Proof of Concept

```rust
// Add to state-sync/state-sync-driver/src/tests/bootstrapper.rs

#[tokio::test]
async fn test_oversized_state_chunk_rejection() {
    use aptos_types::state_store::{StateKey, StateValue, StateValueChunkWithProof};
    use aptos_crypto::HashValue;
    use aptos_types::proof::SparseMerkleRangeProof;
    
    // Create a bootstrapper instance (setup omitted for brevity)
    let mut bootstrapper = create_test_bootstrapper().await;
    
    // Create an oversized chunk with 10,000 state values (exceeds limit of 4,000)
    let mut raw_values = vec![];
    for i in 0..10000 {
        let key = StateKey::raw(format!("key_{}", i).into_bytes());
        let value = StateValue::new_legacy(vec![0u8; 100].into());
        raw_values.push((key, value));
    }
    
    let malicious_chunk = StateValueChunkWithProof {
        first_index: 0,
        last_index: 9999, // Matches raw_values.len() - 1
        first_key: HashValue::zero(),
        last_key: HashValue::zero(),
        raw_values, // 10,000 items - 2.5x the expected maximum
        proof: SparseMerkleRangeProof::new(vec![]),
        root_hash: HashValue::zero(),
    };
    
    // Attempt to process the oversized chunk
    let result = bootstrapper.process_state_values_payload(
        1, // notification_id
        malicious_chunk
    ).await;
    
    // Should be rejected due to excessive size
    assert!(result.is_err(), "Oversized chunk should be rejected");
    assert!(result.unwrap_err().to_string().contains("exceeds maximum"));
}
```

**Notes:**

This vulnerability violates the **Resource Limits** invariant: all operations must respect computational and memory constraints. The missing validation allows an attacker to bypass the intended 4,000 item limit, causing uncontrolled memory allocation and processing overhead that can degrade validator performance or trigger OOM conditions.

### Citations

**File:** config/src/config/state_sync_config.rs (L25-25)
```rust
const MAX_STATE_CHUNK_SIZE: u64 = 4000;
```

**File:** state-sync/storage-service/server/src/storage.rs (L908-911)
```rust
        // Calculate the number of state values to fetch
        let expected_num_state_values = inclusive_range_len(start_index, end_index)?;
        let max_num_state_values = self.config.max_state_chunk_size;
        let num_state_values_to_fetch = min(expected_num_state_values, max_num_state_values);
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L937-956)
```rust
        // Verify the end index and number of state values is valid
        let expected_num_state_values = state_value_chunk_with_proof
            .last_index
            .checked_sub(state_value_chunk_with_proof.first_index)
            .and_then(|version| version.checked_add(1)) // expected_num_state_values = last_index - first_index + 1
            .ok_or_else(|| {
                Error::IntegerOverflow("The expected number of state values has overflown!".into())
            })?;
        let num_state_values = state_value_chunk_with_proof.raw_values.len() as u64;
        if expected_num_state_values != num_state_values {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::InvalidPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(format!(
                "The expected number of state values was invalid! Expected: {:?}, received: {:?}",
                expected_num_state_values, num_state_values,
            )));
        }
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L878-881)
```rust
                    let result = state_snapshot_receiver.add_chunk(
                        states_with_proof.raw_values,
                        states_with_proof.proof.clone(),
                    );
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L112-114)
```rust
        for (k, v) in chunk.iter() {
            usage.add_item(k.key_size() + v.value_size());
        }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L117-120)
```rust
        let kv_batch: StateValueBatch<K, Option<V>> = chunk
            .into_iter()
            .map(|(k, v)| ((k, self.version), Some(v)))
            .collect();
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L235-235)
```rust
                .add_chunk(chunk.clone())
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
