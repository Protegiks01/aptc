# Audit Report

## Title
Remote Panic in Indexer gRPC Service via Unvalidated Address String in EventFilter

## Summary
The `From<aptos_protos::indexer::v1::EventFilter>` implementation lacks input validation, allowing an attacker to provide a `MoveStructTagFilter` with an address string exceeding 64 characters. When this filter is used to match transactions, the `standardize_address()` function attempts an out-of-bounds slice operation, causing a panic and crashing the gRPC stream handler.

## Finding Description
The vulnerability exists across three interconnected code paths:

**1. Missing Validation During Deserialization**

The `From` trait implementation for `EventFilter` directly assigns protobuf fields without any validation: [1](#0-0) 

Similarly, `MoveStructTagFilter` accepts arbitrary strings: [2](#0-1) 

While a `validate_state()` method exists to check for at least one non-None field: [3](#0-2) 

This validation is **never called** during protobuf deserialization. The filter parsing only checks size limits: [4](#0-3) [5](#0-4) 

**2. Panic-Prone Address Standardization**

The `standardize_address()` function performs unchecked arithmetic that panics when given addresses longer than 64 hex characters: [6](#0-5) 

At line 33, when `trimmed.len() > 64`, the expression `64 - trimmed.len()` underflows in unsigned arithmetic, attempting to slice `ZEROS` beyond its 64-character length, causing a panic.

**3. Attack Path Through Filter Matching**

When the live data service processes filtered transaction streams, it calls `matches()` on each transaction: [7](#0-6) 

This triggers the filtering chain: [8](#0-7) [9](#0-8) [10](#0-9) 

**Attack Scenario:**
1. Attacker sends `GetTransactionsRequest` with `transaction_filter` containing an `EventFilter`
2. The `EventFilter.struct_type` contains a `MoveStructTagFilter` with `address` field set to a 100-character string (e.g., "0x" + 100 'a's)
3. Filter is parsed without validation and accepted
4. When streaming begins and `matches()` is called on the first transaction with events
5. `standardize_address()` panics on the oversized address
6. The stream handler crashes with a panic

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos Bug Bounty categories for the following reasons:

- **API Crashes**: The bug causes immediate panic/crash of the gRPC stream handler, which is explicitly listed as High severity (up to $50,000)
- **Remote Denial of Service**: Any unauthenticated client can crash indexer service streams by sending a malicious filter
- **Availability Impact**: While this doesn't affect consensus nodes directly, indexer services are critical infrastructure for dApps, explorers, and wallets relying on transaction data

The severity is NOT Critical because:
- No consensus/validator nodes are affected
- No funds can be stolen or frozen
- The service can be restarted (not permanent failure)
- Only the indexer-grpc service is impacted, not the blockchain itself

## Likelihood Explanation
**Likelihood: High**

- **No Authentication Required**: The gRPC API is typically publicly accessible
- **Trivial Exploitation**: Attack requires only sending a standard protobuf message with a long string
- **Deterministic**: The panic occurs reliably on any address string > 64 characters
- **Low Complexity**: No timing, race conditions, or special state required
- **Immediate Impact**: Crash occurs on the first transaction match attempt

The attack is highly likely to be discovered and exploited because:
- The vulnerability is in a public-facing API
- Exploitation requires minimal technical knowledge
- There are no rate limits or protections mentioned in the code

## Recommendation

**Immediate Fix:**
Add length validation to `standardize_address()` to prevent panic:

```rust
pub fn standardize_address(address: &str) -> String {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate length to prevent panic
    if trimmed.len() > 64 {
        // Return the address as-is or truncate - depends on requirements
        // For safety, just pad to 64 chars
        let truncated = &trimmed[..64];
        let mut result = String::with_capacity(66);
        result.push_str("0x");
        result.push_str(truncated);
        return result;
    }
    
    // ... rest of function unchanged
}
```

**Proper Solution:**
Call `is_valid()` after parsing the filter from protobuf:

```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    let filter = BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))?;
    
    // Validate the filter state
    filter.is_valid()
        .map_err(|e| Status::invalid_argument(format!("Filter validation failed: {e:?}.")))?;
    
    Ok(filter)
}
```

Additionally, add explicit length validation in `MoveStructTagFilter::validate_state()`:

```rust
fn validate_state(&self) -> Result<(), FilterError> {
    if self.address.is_none() && self.module.is_none() && self.name.is_none() {
        return Err(anyhow!("At least one of address, module or name must be set").into());
    }
    
    // Validate address length
    if let Some(addr) = &self.address {
        let trimmed = addr.strip_prefix("0x").unwrap_or(addr);
        if trimmed.len() > 64 {
            return Err(anyhow!("Address exceeds maximum length of 64 hex characters").into());
        }
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::indexer::v1::{EventFilter as ProtoEventFilter, MoveStructTagFilter as ProtoMoveStructTagFilter};
    
    #[test]
    #[should_panic(expected = "range end index")]
    fn test_oversized_address_causes_panic() {
        // Create a malicious filter with an address > 64 chars
        let long_address = "0x".to_string() + &"a".repeat(100);
        
        let proto_filter = ProtoEventFilter {
            struct_type: Some(ProtoMoveStructTagFilter {
                address: Some(long_address),
                module: None,
                name: None,
            }),
            data_substring_filter: None,
        };
        
        // Convert to Rust type (no validation occurs)
        let event_filter: EventFilter = proto_filter.into();
        
        // Create a dummy event to match against
        let dummy_event = aptos_protos::transaction::v1::Event {
            r#type: Some(aptos_protos::transaction::v1::MoveType {
                content: Some(aptos_protos::transaction::v1::move_type::Content::Struct(
                    aptos_protos::transaction::v1::MoveStructTag {
                        address: "0x1".to_string(),
                        module: "coin".to_string(),
                        name: "Transfer".to_string(),
                        generic_type_params: vec![],
                    }
                )),
            }),
            data: "{}".to_string(),
            ..Default::default()
        };
        
        // This will panic when standardize_address is called
        event_filter.matches(&dummy_event);
    }
}
```

**Notes**
- This vulnerability is specific to the indexer-grpc service and does not affect blockchain consensus or validator operations
- The panic occurs in the stream handler, not the main service process, but still results in connection termination
- The same validation gap exists in other filter types (`UserTransactionFilter`, `EntryFunctionFilter`) but they don't have panic-prone operations
- The `prost` library correctly validates UTF-8 encoding during protobuf deserialization, so invalid UTF-8 is not a concern
- "Null pointer" concerns are not applicable in Rust due to its type system using `Option<T>` instead

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L44-51)
```rust
impl From<aptos_protos::indexer::v1::EventFilter> for EventFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EventFilter) -> Self {
        Self {
            data_substring_filter: proto_filter.data_substring_filter,
            struct_type: proto_filter.struct_type.map(|f| f.into()),
            data_substring_finder: OnceCell::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L65-72)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.data_substring_filter.is_none() && self.struct_type.is_none() {
            return Err(Error::msg("At least one of data or struct_type must be set").into());
        };

        self.data_substring_filter.is_valid()?;
        self.struct_type.is_valid()?;
        Ok(())
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L76-87)
```rust
    fn matches(&self, item: &Event) -> bool {
        if let Some(struct_type_filter) = &self.struct_type {
            if let Some(Content::Struct(struct_tag)) =
                &item.r#type.as_ref().and_then(|t| t.content.as_ref())
            {
                if !struct_type_filter.matches(struct_tag) {
                    return false;
                }
            } else {
                return false;
            }
        }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L39-45)
```rust
    fn get_standardized_address(&self) -> &Option<String> {
        self.standardized_address.get_or_init(|| {
            self.address
                .as_ref()
                .map(|address| standardize_address(address))
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L48-61)
```rust
impl From<aptos_protos::indexer::v1::MoveStructTagFilter> for MoveStructTagFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::MoveStructTagFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module,
            name: proto_filter.name,
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L84-89)
```rust
    fn matches(&self, struct_tag: &MoveStructTag) -> bool {
        self.get_standardized_address()
            .matches(&standardize_address(&struct_tag.address))
            && self.module.matches(&struct_tag.module)
            && self.name.matches(&struct_tag.name)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L88-94)
```rust
                if let Some(transaction) = data_manager.get_data(version).as_ref() {
                    // NOTE: We allow 1 more txn beyond the size limit here, for simplicity.
                    if filter.is_none() || filter.as_ref().unwrap().matches(transaction) {
                        total_bytes += transaction.encoded_len();
                        result.push(transaction.as_ref().clone());
                    }
                    version += 1;
```
