# Audit Report

## Title
Safety Rules Sanitizer Bypass via Missing Genesis File Allows InMemoryStorage on Mainnet

## Summary
The `SafetyRulesConfig` sanitizer contains a critical bypass that allows mainnet validators to use insecure storage backends (e.g., `InMemoryStorage`) or test configurations when the genesis file is not properly loaded. This occurs because the sanitizer's mainnet-specific checks are only executed when `chain_id` is successfully extracted from the genesis transaction. If the genesis file is missing or invalid, `chain_id` becomes `None`, bypassing all safety checks and allowing configurations that can lead to double-signing.

## Finding Description
The vulnerability exists in the configuration validation flow across multiple files: [1](#0-0) 

The sanitizer only enforces critical mainnet restrictions when `chain_id.is_some()`. These restrictions include preventing `InMemoryStorage` backends and test configurations. [2](#0-1) 

The `extract_node_type_and_chain_id` function catches errors from `get_chain_id` and returns `None` for `chain_id` instead of failing validation. [3](#0-2) 

The `get_chain_id` function depends on the genesis transaction being present. [4](#0-3) 

Genesis is loaded from `config.execution.genesis`, which can be `None`. [5](#0-4) 

Genesis loading is skipped entirely if `genesis_file_location` is empty.

**Attack Path:**
1. Validator operator creates mainnet config with empty `execution.genesis_file_location`
2. Genesis file is not loaded, `execution.genesis` remains `None`
3. During config loading, `get_chain_id()` fails and returns error
4. `extract_node_type_and_chain_id()` catches error and returns `(node_type, None)`
5. Sanitizer is called with `chain_id = None`
6. Mainnet safety checks at lines 87-96 are skipped (not inside the `if let Some(chain_id)` block)
7. Validator configures `safety_rules.backend = InMemoryStorage`
8. Configuration passes validation and node starts

**Double-Signing Scenario:** [6](#0-5) 

When using `InMemoryStorage`, safety data (including `last_voted_round`) is stored only in memory. On validator restart, this data is lost. The storage reinitializes with default values `SafetyData::new(1, 0, 0, 0, None, 0)`, causing the validator to "forget" previous votes and allowing double-signing in the same round.

## Impact Explanation
**Critical Severity** - This vulnerability enables violations of Consensus Safety (Invariant #2), specifically:
- **Double-signing**: Validators can sign conflicting blocks after restart
- **Chain splits**: Different validators may commit different blocks for the same round
- **BFT assumption violation**: Safety guarantees break even with <1/3 Byzantine nodes

This meets the Critical severity criteria from the Aptos Bug Bounty program: "Consensus/Safety violations" with potential for "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**High Likelihood** - This can occur through simple operator error:
- New validator operators unfamiliar with configuration requirements
- Copy-paste errors from testnet configs to mainnet
- Incomplete configuration migrations during network upgrades
- Automated deployment scripts with missing genesis file paths

The misconfiguration is not immediately obvious because the node starts successfully and appears to function normally until a restart occurs.

## Recommendation
The sanitizer must fail-fast when `chain_id` cannot be extracted for validator nodes:

```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        // For validators, chain_id MUST be present
        let chain_id = chain_id.ok_or_else(|| {
            Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "Validator nodes must have a valid genesis file to extract chain ID for safety checks!".to_string(),
            )
        })?;

        // Verify that the secure backend is appropriate for mainnet validators
        if chain_id.is_mainnet()
            && node_type.is_validator()
            && safety_rules_config.backend.is_in_memory()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The secure backend should not be set to in memory storage in mainnet!"
                    .to_string(),
            ));
        }

        // ... rest of checks
    }
}
```

Additionally, improve error handling in `extract_node_type_and_chain_id`:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, Option<ChainId>), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    if node_type.is_validator() {
        // For validators, genesis must be present
        let chain_id = get_chain_id(node_config)?;
        Ok((node_type, Some(chain_id)))
    } else {
        // For fullnodes, chain_id is optional
        match get_chain_id(node_config) {
            Ok(chain_id) => Ok((node_type, Some(chain_id))),
            Err(_) => Ok((node_type, None)),
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::config::{ConsensusConfig, ExecutionConfig, NodeConfig, SafetyRulesConfig, SecureBackend};
    use aptos_types::chain_id::ChainId;
    
    #[test]
    fn test_sanitizer_bypass_via_missing_genesis() {
        // Create a mainnet validator config with InMemoryStorage
        // but WITHOUT a genesis file
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                safety_rules: SafetyRulesConfig {
                    backend: SecureBackend::InMemoryStorage, // This should be blocked on mainnet!
                    ..Default::default()
                },
                ..Default::default()
            },
            execution: ExecutionConfig {
                genesis: None, // No genesis loaded
                genesis_file_location: PathBuf::new(), // Empty path
                ..Default::default()
            },
            base: BaseConfig {
                role: RoleType::Validator,
                ..Default::default()
            },
            ..Default::default()
        };

        // Extract node type and chain_id - chain_id will be None due to missing genesis
        let (node_type, chain_id) = extract_node_type_and_chain_id(&node_config);
        assert_eq!(node_type, NodeType::Validator);
        assert!(chain_id.is_none()); // Genesis missing -> chain_id is None

        // This should FAIL but currently PASSES because chain_id is None
        let result = SafetyRulesConfig::sanitize(
            &node_config,
            node_type,
            chain_id, // None bypasses the mainnet checks!
        );

        // Currently passes (BUG) - should fail to prevent InMemoryStorage on mainnet
        assert!(result.is_ok(), "BUG: InMemoryStorage allowed when genesis is missing!");
        
        // After fix, this should fail:
        // assert!(result.is_err(), "InMemoryStorage must be blocked for validators");
    }
}
```

## Notes
This vulnerability affects the configuration validation layer and represents a defense-in-depth failure. While validator operators are trusted roles, configuration validation exists specifically to prevent operator errors that could compromise network safety. The bypass condition effectively nullifies the sanitizer's purpose, allowing dangerous misconfigurations that can lead to consensus violations requiring network-wide intervention or hardforks to resolve.

### Citations

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/node_config_loader.rs (L112-124)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
}
```

**File:** config/src/config/node_config_loader.rs (L158-165)
```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

```

**File:** config/src/utils.rs (L220-222)
```rust
pub fn get_genesis_txn(config: &NodeConfig) -> Option<&Transaction> {
    config.execution.genesis.as_ref()
}
```

**File:** config/src/config/execution_config.rs (L100-109)
```rust
    pub fn load_from_path(&mut self, root_dir: &RootPath) -> Result<(), Error> {
        if !self.genesis_file_location.as_os_str().is_empty() {
            // Ensure the genesis file exists
            let genesis_path = root_dir.full_path(&self.genesis_file_location);
            if !genesis_path.exists() {
                return Err(Error::Unexpected(format!(
                    "The genesis file could not be found! Ensure the given path is correct: {:?}",
                    genesis_path.display()
                )));
            }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L33-60)
```rust
    pub fn initialize(
        mut internal_store: Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
        waypoint: Waypoint,
        enable_cached_safety_data: bool,
    ) -> Self {
        // Initialize the keys and accounts
        Self::initialize_keys_and_accounts(&mut internal_store, author, consensus_private_key)
            .expect("Unable to initialize keys and accounts in storage");

        // Create the new persistent safety storage
        let safety_data = SafetyData::new(1, 0, 0, 0, None, 0);
        let mut persisent_safety_storage = Self {
            enable_cached_safety_data,
            cached_safety_data: Some(safety_data.clone()),
            internal_store,
        };

        // Initialize the safety data and waypoint
        persisent_safety_storage
            .set_safety_data(safety_data)
            .expect("Unable to initialize safety data");
        persisent_safety_storage
            .set_waypoint(&waypoint)
            .expect("Unable to initialize waypoint");

        persisent_safety_storage
```
