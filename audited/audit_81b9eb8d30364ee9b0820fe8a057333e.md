# Audit Report

## Title
Server-Side Request Forgery (SSRF) in Aptos CLI Package Dependency Resolution

## Summary
The Aptos CLI's `maybe_download_package()` function accepts user-controlled URLs from Move.toml manifest files without validation, allowing attackers to craft malicious package dependencies that trigger HTTP requests to internal services, cloud metadata endpoints, or private network resources when developers compile Move packages.

## Finding Description

The vulnerability exists in the custom dependency resolution mechanism for Aptos packages. When a Move.toml manifest specifies a custom `aptos` dependency, the `node_url` value is parsed and used directly to create an HTTP client without any validation against private IP ranges or sensitive endpoints. [1](#0-0) 

The `node_url` originates from the Move.toml manifest file, parsed by the manifest parser: [2](#0-1) 

This URL is then used to create an HTTP client without validation: [3](#0-2) 

The `Client::new()` constructor accepts any URL without filtering: [4](#0-3) 

**Attack Path:**
1. Attacker creates a malicious Move package with a crafted Move.toml:
```toml
[dependencies]
MaliciousPackage = { aptos = "http://169.254.169.254", address = "0x1", package = "Framework" }
```
2. Victim downloads and attempts to compile the package using `aptos move compile`
3. The CLI makes an HTTP GET request to `http://169.254.169.254/v1/accounts/0x1/resource/0x1::code::PackageRegistry`
4. Attacker receives information from the metadata endpoint or internal service

## Impact Explanation

This vulnerability qualifies as **High Severity** in deployment scenarios where the Aptos CLI is used in sensitive environments:

**High Impact Scenarios:**
- **CI/CD Pipelines on Cloud Infrastructure**: If the CLI runs in GitHub Actions, Jenkins, or similar CI/CD systems on AWS EC2, GCP Compute Engine, or Azure VMs, attackers can access cloud metadata endpoints (169.254.169.254) to steal:
  - IAM role credentials
  - Instance metadata and user data
  - API tokens and secrets
  - This could lead to full cloud account compromise

- **Validator Node Operations**: If validator operators use the CLI on their validator infrastructure for deploying or testing Move modules, attackers could:
  - Access internal validator services
  - Probe internal network topology
  - Potentially access validator key management systems

**Medium Impact Scenarios:**
- **Developer Workstations**: Access to localhost services (127.0.0.1) running on developer machines, potentially exposing development databases, admin panels, or other sensitive services

While this doesn't directly affect blockchain consensus or validator operations, it represents a significant attack vector for compromising infrastructure that manages the Aptos blockchain.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attack Complexity**: Low - attacker only needs to create a malicious Move.toml file
- **User Interaction Required**: Yes - victim must download and compile the malicious package
- **Distribution Vectors**: 
  - GitHub repositories with malicious Move packages
  - Dependency confusion attacks if packages are hosted
  - Supply chain attacks through compromised dependencies
  - Social engineering (sharing "example" Move projects)

The attack is particularly likely because:
1. Developers frequently download and compile example Move projects
2. No warning is displayed to users about external network requests
3. CI/CD systems automatically compile dependencies without human review

## Recommendation

Implement URL validation to block requests to private IP ranges and sensitive endpoints:

```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let url = Url::parse(info.node_url.as_str())?;
        
        // Validate URL is not pointing to private/internal resources
        validate_url_is_safe(&url)?;
        
        let registry = CachedPackageRegistry::create(
            url,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}

fn validate_url_is_safe(url: &Url) -> anyhow::Result<()> {
    let host = url.host_str().ok_or_else(|| anyhow::anyhow!("Invalid URL: no host"))?;
    
    // Block localhost variations
    if host == "localhost" || host == "127.0.0.1" || host.starts_with("127.") {
        bail!("URL points to localhost, which is not allowed");
    }
    
    // Block private IP ranges
    if let Ok(ip) = host.parse::<std::net::IpAddr>() {
        match ip {
            std::net::IpAddr::V4(ipv4) => {
                if ipv4.is_private() || ipv4.is_loopback() || ipv4.is_link_local() {
                    bail!("URL points to private IP address: {}", ipv4);
                }
                // Block cloud metadata endpoint
                if ipv4.octets() == [169, 254, 169, 254] {
                    bail!("URL points to cloud metadata endpoint");
                }
            }
            std::net::IpAddr::V6(ipv6) => {
                if ipv6.is_loopback() {
                    bail!("URL points to localhost (IPv6)");
                }
            }
        }
    }
    
    // Only allow https for production use
    if url.scheme() != "https" {
        // Could make this a warning instead of error
        println!("Warning: Using non-HTTPS URL for package download: {}", url);
    }
    
    Ok(())
}
```

Additionally, consider:
1. Implementing a whitelist of allowed package registry domains
2. Adding user confirmation prompts for network requests
3. Logging all external network requests made during compilation
4. Documenting this security consideration in the CLI documentation

## Proof of Concept

**Step 1**: Create a malicious Move.toml file:

```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
# This will attempt to access AWS metadata endpoint
AptosFramework = { aptos = "http://169.254.169.254", address = "0x1", package = "aptos_framework" }

[addresses]
malicious = "0x42"
```

**Step 2**: Create a minimal Move source file (sources/test.move):

```move
module malicious::test {
    public fun dummy() {}
}
```

**Step 3**: Run the Aptos CLI on a cloud instance:

```bash
# On an AWS EC2 instance or in CI/CD
aptos move compile --package-dir .
```

**Expected Result**: The CLI will make an HTTP request to `http://169.254.169.254/v1/accounts/0x0000000000000000000000000000000000000000000000000000000000000001/resource/0x1::code::PackageRegistry`, attempting to access the AWS metadata endpoint.

**To verify the vulnerability**: Monitor network traffic using tcpdump or similar tool:
```bash
sudo tcpdump -i any -n host 169.254.169.254
```

The SSRF request will be visible in the network capture when the compilation is attempted.

---

## Notes

This vulnerability affects the Aptos CLI tool rather than the blockchain consensus or validator nodes directly. However, given that:

1. The CLI is used in CI/CD environments that may have access to sensitive cloud resources
2. Validator operators may use the CLI for deployment and testing
3. The explicit security question requested analysis of this component

This represents a valid security concern in the Aptos ecosystem. While it doesn't directly compromise blockchain consensus, it provides an attack vector for compromising infrastructure that operates the Aptos blockchain network.

### Citations

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-55)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L402-416)
```rust
                    let node_url = custom_key
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = PathBuf::from(MOVE_HOME.clone()).join(format!(
                        "{}_{}_{}",
                        url_to_file_name(node_url),
                        address,
                        package_name
                    ));
                    node_info = Some(PM::CustomDepInfo {
                        node_url: Symbol::from(node_url),
                        package_address: address,
                        package_name,
                        download_to: local_path.clone(),
                    });
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L43-53)
```rust
    pub async fn create(
        url: Url,
        addr: AccountAddress,
        with_bytecode: bool,
    ) -> anyhow::Result<Self> {
        let client = Client::new(url);
        // Need to use a different type to deserialize JSON
        let inner = client
            .get_account_resource_bcs::<PackageRegistry>(addr, "0x1::code::PackageRegistry")
            .await?
            .into_inner();
```

**File:** crates/aptos-rest-client/src/lib.rs (L134-136)
```rust
    pub fn new(base_url: Url) -> Self {
        Self::builder(AptosBaseUrl::Custom(base_url)).build()
    }
```
