# Audit Report

## Title
Unhandled Panic in Sharded Aggregator Service Can Crash Validator Process During Parallel Block Execution

## Summary
The `DeltaU128::add_delta()` function performs unchecked u128 subtraction that can panic on underflow during parallel block execution. With `overflow-checks = true` in release builds, this panic propagates through rayon worker threads and triggers the crash handler, causing validator process termination.

## Finding Description

The `DeltaU128::add_delta()` function contains a critical flaw at line 55: [1](#0-0) 

When `self.is_positive` is false (negative delta) and `self.delta > other`, the subtraction `other - self.delta` underflows. The code comment explicitly acknowledges this: [2](#0-1) 

This function is called within parallel iterators during block execution: [3](#0-2) [4](#0-3) 

The Cargo.toml configuration enables overflow checks in release builds: [5](#0-4) 

When a panic occurs in a rayon worker thread, the crash handler kills the validator process: [6](#0-5) 

This panic does NOT occur during bytecode verification/deserialization, so the exception at lines 52-54 does not apply.

The vulnerable code path is reached during validator block execution: [7](#0-6) [8](#0-7) 

## Impact Explanation

This represents a **High Severity** issue under the Aptos bug bounty criteria:

1. **Validator node crashes**: Any validator executing a block that triggers this condition will immediately terminate, causing loss of liveness for that validator
2. **Consensus disruption**: If multiple validators hit this condition, network liveness could degrade
3. **Deterministic crash**: Once triggered, the same block will crash all validators attempting to execute it

While the normal operation should prevent this condition (transactions use `TOTAL_SUPPLY_AGGR_BASE_VAL = 2^127` as the base value), edge cases in the aggregator implementation, Move VM bugs, or state corruption could trigger the underflow.

## Likelihood Explanation

**Likelihood: Low to Medium**

Under normal operation, the condition should not trigger because:
- All transactions in sharded execution use the overridden state view: [9](#0-8) 

- Transaction outputs should have `txn_total_supply ≈ TOTAL_SUPPLY_AGGR_BASE_VAL ± small_changes`

However, the likelihood increases if:
- Bugs exist in aggregator snapshot/materialization logic
- Edge cases in state synchronization or recovery
- Unforeseen interactions in complex parallel execution scenarios
- The developers' explicit acknowledgment that it doesn't handle underflow suggests they anticipated edge cases

## Recommendation

Replace the panic-prone subtraction with proper error handling:

```rust
fn add_delta(self, other: u128) -> Result<u128, String> {
    if self.is_positive {
        other.checked_add(self.delta)
            .ok_or_else(|| format!("Overflow adding delta {} to {}", self.delta, other))
    } else {
        other.checked_sub(self.delta)
            .ok_or_else(|| format!("Underflow subtracting delta {} from {}", self.delta, other))
    }
}
```

Update all call sites to handle the Result, allowing graceful error propagation instead of process termination:

```rust
txn_outputs.par_iter_mut().try_for_each(|txn_output| {
    if let Some(txn_total_supply) = txn_output.write_set().get_total_supply() {
        let updated_supply = delta_for_round.add_delta(txn_total_supply)
            .map_err(|e| VMStatus::Error(StatusCode::INTERNAL_ERROR, Some(e)))?;
        txn_output.update_total_supply(updated_supply);
    }
    Ok(())
})?;
```

Alternatively, add explicit validation before the subtraction:

```rust
fn add_delta(self, other: u128) -> u128 {
    if self.is_positive {
        self.delta.checked_add(other).expect("Delta addition overflow")
    } else {
        assert!(other >= self.delta, 
            "Invalid delta operation: attempting to subtract {} from {} in total supply aggregation. \
             This indicates a bug in aggregator logic or state corruption.", 
            self.delta, other);
        other - self.delta
    }
}
```

## Proof of Concept

While I cannot provide a concrete exploit that an unprivileged attacker can execute (as it requires triggering edge cases in the aggregator system), here is a test demonstrating the panic condition:

```rust
#[test]
#[should_panic(expected = "attempt to subtract with overflow")]
fn test_add_delta_underflow_panic() {
    // Simulates the condition where txn_total_supply < delta_for_round.delta
    let delta = DeltaU128 {
        delta: 1000,
        is_positive: false,
    };
    
    // This will panic in debug/overflow-checks builds
    let _result = delta.add_delta(500);
}
```

The existing test only covers the case where `delta <= other`: [10](#0-9) 

This missing test case demonstrates the defensive programming gap.

## Notes

The vulnerability is **valid as a defensive programming and crash resilience issue**, meeting the "High Severity" criteria for validator node crashes. However, **I cannot demonstrate a concrete attack path** that an unprivileged attacker could reliably execute without triggering separate bugs in the aggregator or Move VM implementation first.

The code explicitly acknowledges it will panic to "indicate faulty logic" [2](#0-1) , but using panics for error signaling in production validator code that runs in parallel contexts is a dangerous pattern that violates defensive programming principles.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L26-29)
```rust
/// This class ensures that deltas can use all 128 bits without having to let go of the sign bit for
/// cases where the delta is negative. That is, we don't have to use conversions to i128.
/// However, it does not handle overflow and underflow. That is, it will indicate to the caller of
/// the faulty logic with their usage of deltas.
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L51-56)
```rust
    fn add_delta(self, other: u128) -> u128 {
        if self.is_positive {
            self.delta + other
        } else {
            other - self.delta
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L127-131)
```rust
        let delta2 = DeltaU128 {
            delta: 50,
            is_positive: false,
        };
        assert_eq!(delta2.add_delta(50), 0);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L229-237)
```rust
                        .for_each(|txn_output| {
                            if let Some(txn_total_supply) =
                                txn_output.write_set().get_total_supply()
                            {
                                txn_output.update_total_supply(
                                    delta_for_round.add_delta(txn_total_supply),
                                );
                            }
                        });
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L247-255)
```rust
            .par_iter_mut()
            .with_min_len(optimal_min_len(num_txn_outputs, 32))
            .for_each(|txn_output| {
                if let Some(txn_total_supply) = txn_output.write_set().get_total_supply() {
                    txn_output.update_total_supply(
                        delta_for_global_shard_ref.add_delta(txn_total_supply),
                    );
                }
            });
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L215-222)
```rust
        sharded_aggregator_service::aggregate_and_update_total_supply(
            &mut sharded_output,
            &mut global_output,
            state_view.as_ref(),
            self.global_executor.get_executor_thread_pool(),
        );

        Ok(ShardedExecutionOutput::new(sharded_output, global_output))
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L123-126)
```rust
        let aggr_overridden_state_view = Arc::new(AggregatorOverriddenStateView::new(
            cross_shard_state_view.as_ref(),
            TOTAL_SUPPLY_AGGR_BASE_VAL,
        ));
```
