# Audit Report

## Title
Processor Status Timestamp Staleness Can Hide Indexer Failures Due to Conditional Update Logic

## Summary
The `processor_status` table's `last_updated` timestamp can become stale when a processor attempts to process older transaction versions than what is already recorded in the database, due to a WHERE clause that prevents the update. This allows processor failures or stuck states to remain undetected since health checks only verify `last_success_version > 0` without checking timestamp freshness.

## Finding Description
The indexer's `update_last_processed_version` function contains a conditional upsert that only updates the database when the new version is greater than or equal to the existing version: [1](#0-0) 

The critical issue is on line 188, which appends a WHERE clause: `WHERE processor_status.last_success_version <= EXCLUDED.last_success_version`. This means:
- If a processor tries to update with version 100, but the database already has version 200, the WHERE clause evaluates to FALSE (200 <= 100 = false)
- The UPDATE operation is skipped entirely
- The `last_updated` timestamp is NOT refreshed

The `ProcessorStatusV2` struct intentionally excludes the `last_updated` field: [2](#0-1) 

However, the health check implementation only verifies that `last_success_version > 0`, completely ignoring the `last_updated` timestamp: [3](#0-2) 

**Attack Scenarios:**

1. **Multiple Processor Instances**: Two processors with the same name run concurrently. Processor A reaches version 2000 and stops. Processor B continues from version 1000 but cannot update the database. The `last_updated` shows Processor A's timestamp and becomes stale while Processor B runs indefinitely without detection.

2. **Configuration Rollback**: An administrator accidentally configures a processor to restart from an old version (e.g., version 1000 when database shows 5000). The processor runs continuously but all updates are blocked, causing `last_updated` to remain frozen at the old timestamp.

3. **Database Manipulation**: An attacker with database access sets `last_success_version` to a very high value (e.g., 999999999). The processor continues running but can never update the database, causing `last_updated` to become permanently stale while appearing healthy.

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention." While it doesn't directly affect blockchain consensus or on-chain funds, it creates operational state inconsistencies where:

- Indexer processors appear healthy but are actually stale or stuck
- Users query stale indexed data thinking it's current
- Monitoring systems fail to detect processor failures
- Manual intervention is required to identify and resolve the staleness

The indexer is critical infrastructure for applications and users querying blockchain state, making reliability monitoring essential. This bug systematically undermines that monitoring capability.

## Likelihood Explanation
**Likelihood: Medium to High**

This issue can occur through:
- **Operational errors**: Common during deployments, rollbacks, or configuration changes
- **Misconfiguration**: Multiple instances accidentally using the same processor name
- **Database tampering**: Requires database access but is feasible for insider threats
- **Processor bugs**: Any bug causing version reprocessing triggers this behavior

The main processor loop calls `update_last_processed_version` on every batch: [4](#0-3) 

Given the frequent update calls and various operational scenarios, this is a realistic vulnerability.

## Recommendation

**Fix 1: Add timestamp-based staleness check to health checker**

Modify the health checker to verify `last_updated` is recent:

```rust
// In health_checker.rs, modify the Processor health check
HealthChecker::Processor(connection_string, processor_name) => {
    let mut connection = AsyncPgConnection::establish(connection_string)
        .await
        .context("Failed to connect to postgres to check processor status")?;
    
    let result = processor_status::table
        .select((
            processor_status::last_success_version,
            processor_status::last_updated,
        ))
        .filter(processor_status::processor.eq(processor_name))
        .first::<(i64, chrono::NaiveDateTime)>(&mut connection)
        .await
        .optional()
        .context("Failed to look up processor status")?;
    
    match result {
        Some((version, last_updated)) => {
            if version > 0 {
                let now = chrono::Utc::now().naive_utc();
                let elapsed = now.signed_duration_since(last_updated);
                const MAX_STALENESS_SECONDS: i64 = 300; // 5 minutes
                
                if elapsed.num_seconds() > MAX_STALENESS_SECONDS {
                    Err(anyhow!(
                        "Processor {} has stale last_updated timestamp: {:?} ago",
                        processor_name, elapsed
                    ))
                } else {
                    Ok(())
                }
            } else {
                Err(anyhow!("Processor {} last_success_version is zero", processor_name))
            }
        },
        None => Err(anyhow!("Processor {} not found in database", processor_name)),
    }
}
```

**Fix 2: Always update timestamp regardless of version check**

Remove the WHERE clause restriction for the `last_updated` field:

```rust
// In tailer.rs update_last_processed_version
execute_with_better_error(
    &mut conn,
    diesel::insert_into(processor_status::table)
        .values(&status)
        .on_conflict(processor_status::processor)
        .do_update()
        .set(processor_status::last_updated.eq(diesel::dsl::now)),
    None,
)?;

// Separately update last_success_version only if it increases
diesel::update(processor_status::table)
    .filter(processor_status::processor.eq(processor_name))
    .filter(processor_status::last_success_version.le(version as i64))
    .set(processor_status::last_success_version.eq(version as i64))
    .execute(&mut conn)?;
```

**Fix 3: Add monitoring alerts for stale timestamps**

Implement automated monitoring that alerts when `last_updated` exceeds a threshold, independent of the health check.

## Proof of Concept

```rust
// Test demonstrating the staleness issue
#[tokio::test]
async fn test_processor_status_timestamp_staleness() {
    // Setup database connection
    let database_url = std::env::var("INDEXER_DATABASE_URL")
        .expect("INDEXER_DATABASE_URL must be set");
    let conn_pool = new_db_pool(&database_url).unwrap();
    
    // Simulate processor processing version 1000
    let processor_name = "test_processor";
    let mut conn = conn_pool.get().unwrap();
    
    let status_v1 = ProcessorStatusV2 {
        processor: processor_name.to_owned(),
        last_success_version: 1000,
    };
    
    diesel::insert_into(processor_status::table)
        .values(&status_v1)
        .execute(&mut conn)
        .unwrap();
    
    // Get initial timestamp
    let initial_status = ProcessorStatusV2Query::get_by_processor(
        &processor_name.to_string(),
        &mut conn,
    ).unwrap().unwrap();
    
    println!("Initial version: {}, timestamp: {:?}", 
        initial_status.last_success_version,
        initial_status.last_updated
    );
    
    // Wait 5 seconds
    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
    
    // Try to process older version (simulating rollback/multiple instances)
    let status_v2 = ProcessorStatusV2 {
        processor: processor_name.to_owned(),
        last_success_version: 500, // Older version!
    };
    
    diesel::insert_into(processor_status::table)
        .values(&status_v2)
        .on_conflict(processor_status::processor)
        .do_update()
        .set((
            processor_status::last_success_version
                .eq(excluded(processor_status::last_success_version)),
            processor_status::last_updated.eq(excluded(processor_status::last_updated)),
        ))
        .execute(&mut conn)
        .unwrap();
    
    // Get updated status
    let final_status = ProcessorStatusV2Query::get_by_processor(
        &processor_name.to_string(),
        &mut conn,
    ).unwrap().unwrap();
    
    println!("Final version: {}, timestamp: {:?}",
        final_status.last_success_version,
        final_status.last_updated
    );
    
    // VULNERABILITY: Timestamp should be 5+ seconds newer, but it's unchanged!
    assert_eq!(initial_status.last_updated, final_status.last_updated,
        "Timestamp was not updated despite processor continuing to run!");
    assert_eq!(final_status.last_success_version, 1000,
        "Version should remain at 1000 due to WHERE clause");
}
```

## Notes

This vulnerability is specific to the indexer's internal monitoring mechanisms and does not directly affect blockchain consensus, on-chain state, or validator operations. However, it represents a significant operational security issue as the indexer is critical infrastructure for applications querying blockchain data. The ability to hide processor staleness could lead to users consuming outdated data while believing it to be current, creating trust and reliability issues for the Aptos ecosystem.

### Citations

**File:** crates/indexer/src/indexer/tailer.rs (L170-191)
```rust
    pub fn update_last_processed_version(&self, processor_name: &str, version: u64) -> Result<()> {
        let mut conn = self.connection_pool.get()?;

        let status = ProcessorStatusV2 {
            processor: processor_name.to_owned(),
            last_success_version: version as i64,
        };
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
        Ok(())
    }
```

**File:** crates/indexer/src/models/processor_status.rs (L7-13)
```rust
#[derive(AsChangeset, Debug, Insertable)]
#[diesel(table_name = processor_status)]
/// Only tracking the latest version successfully processed
pub struct ProcessorStatusV2 {
    pub processor: String,
    pub last_success_version: i64,
}
```

**File:** crates/aptos-localnet/src/health_checker.rs (L86-118)
```rust
            HealthChecker::Processor(connection_string, processor_name) => {
                let mut connection = AsyncPgConnection::establish(connection_string)
                    .await
                    .context("Failed to connect to postgres to check processor status")?;
                let result = processor_status::table
                    .select((processor_status::last_success_version,))
                    .filter(processor_status::processor.eq(processor_name))
                    .first::<(i64,)>(&mut connection)
                    .await
                    .optional()
                    .context("Failed to look up processor status")?;
                match result {
                    Some(result) => {
                        // This is last_success_version.
                        if result.0 > 0 {
                            info!(
                                "Processor {} started processing successfully (currently at version {})",
                                processor_name, result.0
                            );
                            Ok(())
                        } else {
                            Err(anyhow!(
                                "Processor {} found in DB but last_success_version is zero",
                                processor_name
                            ))
                        }
                    },
                    None => Err(anyhow!(
                        "Processor {} has not processed any transactions",
                        processor_name
                    )),
                }
            },
```

**File:** crates/indexer/src/runtime.rs (L251-261)
```rust
        tailer
            .update_last_processed_version(&processor_name, batch_end_version)
            .unwrap_or_else(|e| {
                error!(
                    processor_name = processor_name,
                    end_version = batch_end_version,
                    error = format!("{:?}", e),
                    "Failed to update last processed version!"
                );
                panic!("Failed to update last processed version: {:?}", e);
            });
```
