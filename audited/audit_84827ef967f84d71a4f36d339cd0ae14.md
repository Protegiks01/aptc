# Audit Report

## Title
Genesis Failure via Duplicate Owner Address in Non-Mainnet Validator Configuration

## Summary
Non-mainnet genesis configurations (testnet, devnet) lack validation to prevent duplicate validator `owner_address` values. When multiple validators share the same `owner_address`, the genesis Move execution aborts with `EALREADY_REGISTERED`, causing total chain initialization failure and preventing network launch.

## Finding Description

The vulnerability exists in the genesis validation flow for non-mainnet chains. The security guarantee that is broken is **chain liveness** - the network cannot start if genesis fails.

**Vulnerability Location:**

In mainnet genesis, the `validate_validators` function is called to check for duplicate owner addresses: [1](#0-0) 

However, for non-mainnet chains, the `fetch_genesis_info` function bypasses all validator validation: [2](#0-1) 

The `ValidatorConfiguration::try_from()` function only validates individual validator fields, not uniqueness across validators: [3](#0-2) 

**Attack Path:**

1. An attacker (or accidental misconfiguration) creates multiple validator configurations with identical `owner_address` values in a non-mainnet genesis setup.

2. These configurations pass Rust-side validation since `fetch_genesis_info` does not call `validate_validators`.

3. During genesis execution, the Move code calls `create_initialize_validator` for each validator: [4](#0-3) 

4. The first validator successfully calls `stake::initialize_stake_owner`, which internally calls `initialize_owner` to create a `StakePool`: [5](#0-4) 

5. When the second validator with the same `owner_address` attempts initialization, the `initialize_owner` function detects the duplicate: [6](#0-5) 

6. The assertion `assert!(!stake_pool_exists(owner_address), error::already_exists(EALREADY_REGISTERED))` fails with error code 8.

7. The VM genesis executor catches this abort and panics: [7](#0-6) 

8. The entire genesis process fails, preventing the chain from starting.

## Impact Explanation

**Severity: Critical**

This vulnerability meets the **Critical** severity criteria per the Aptos bug bounty program:
- **"Total loss of liveness/network availability"** - The chain cannot start until genesis is regenerated with valid configurations.
- **"Non-recoverable network partition (requires hardfork)"** - Recovery requires regenerating genesis from scratch.

**Scope:**
- Affects all non-mainnet networks (testnet, devnet, private chains) that use `fetch_genesis_info`.
- Mainnet is protected by the `validate_validators` call in `fetch_mainnet_genesis_info`.
- The entire validator set and network is affected - no blocks can be produced.

**Damage:**
- Complete denial of service preventing chain launch
- Requires identifying the error, fixing configurations, and regenerating genesis
- Potential reputational damage if a testnet or devnet fails to launch publicly

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can manifest in two scenarios:

1. **Accidental Misconfiguration (High Probability):**
   - During testnet/devnet setup, multiple operators might accidentally use the same address
   - Copy-paste errors in configuration files
   - Miscommunication in distributed setup processes

2. **Malicious Attack (Medium Probability):**
   - Requires attacker to submit validator configurations during genesis setup
   - Attack window exists during the genesis ceremony phase
   - More difficult in production but trivial in test environments

The vulnerability is **easy to trigger** - it requires no special privileges beyond participating in genesis setup, and the impact is immediate and total.

## Recommendation

Add duplicate owner address validation to `fetch_genesis_info`, mirroring the protection already present in `fetch_mainnet_genesis_info`.

**Fix:** Modify the `fetch_genesis_info` function in `crates/aptos/src/genesis/mod.rs`:

```rust
pub fn fetch_genesis_info(git_options: GitOptions) -> CliTypedResult<GenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;

    if layout.root_key.is_none() {
        return Err(CliError::UnexpectedError(
            "Layout field root_key was not set. Please provide a hex encoded Ed25519PublicKey."
                .to_string(),
        ));
    }

    let validators = get_validator_configs(&client, &layout, false).map_err(parse_error)?;
    
    // ADD VALIDATION HERE
    let mut unique_accounts = BTreeSet::new();
    let mut unique_network_keys = HashSet::new();
    let mut unique_consensus_keys = HashSet::new();
    let mut unique_consensus_pop = HashSet::new();
    let mut unique_hosts = HashSet::new();
    let mut seen_owners = BTreeMap::new();
    
    validate_validators(
        &layout,
        &validators,
        &BTreeMap::new(), // Empty initialized_accounts for non-mainnet
        &mut unique_accounts,
        &mut unique_network_keys,
        &mut unique_consensus_keys,
        &mut unique_consensus_pop,
        &mut unique_hosts,
        &mut seen_owners,
        false,
    )?;
    // END VALIDATION
    
    let framework = client.get_framework()?;
    Ok(GenesisInfo::new(
        layout.chain_id,
        layout.root_key.unwrap(),
        validators,
        framework,
        &GenesisConfiguration { /* ... */ },
    )?)
}
```

Note: The `validate_validators` function currently checks against `initialized_accounts`, which may not be available for non-mainnet. You may need to either:
1. Make the balance checks conditional/optional, or
2. Create a minimal validator for non-mainnet that skips balance validation but keeps uniqueness checks

## Proof of Concept

**Setup:**
1. Create a non-mainnet genesis layout with 2 validators
2. Configure both validators with the same `owner_account_address`
3. Run `aptos genesis generate-genesis`

**Expected Result:** Genesis generation should fail with duplicate owner validation error (after fix).

**Actual Result (before fix):** Genesis generation succeeds at Rust level, but genesis execution fails with panic message:
```
Error calling 0x1.genesis.create_initialize_validators_with_commission: (0x8) EALREADY_REGISTERED
```

**Reproduction Steps:**

Create two validator owner files with the same address:

`validators/validator1/owner.yaml`:
```yaml
owner_account_address: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
owner_account_public_key: "0x..."
operator_account_address: "0xaaaa..."
operator_account_public_key: "0x..."
voter_account_address: "0xbbbb..."
voter_account_public_key: "0x..."
stake_amount: 100000000000000
commission_percentage: 10
join_during_genesis: true
```

`validators/validator2/owner.yaml`:
```yaml
owner_account_address: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"  # DUPLICATE!
owner_account_public_key: "0x..."  # Different key
operator_account_address: "0xcccc..."
operator_account_public_key: "0x..."
voter_account_address: "0xdddd..."
voter_account_public_key: "0x..."
stake_amount: 100000000000000
commission_percentage: 10
join_during_genesis: true
```

Execute genesis generation for a non-mainnet chain - the process will fail during Move execution with the `EALREADY_REGISTERED` error.

## Notes

- Mainnet genesis is **not affected** because `fetch_mainnet_genesis_info` already includes the necessary validation.
- The vulnerability only affects non-mainnet chains using `fetch_genesis_info`.
- The error manifests at Move execution time rather than configuration validation time, making debugging more difficult.
- This is a **Critical** severity issue that can completely prevent chain launch.

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L210-234)
```rust
    let mut seen_owners = BTreeMap::new();
    validate_validators(
        &layout,
        &employee_validators,
        &initialized_accounts,
        &mut unique_accounts,
        &mut unique_network_keys,
        &mut unique_consensus_keys,
        &mut unique_consensus_pop,
        &mut unique_hosts,
        &mut seen_owners,
        true,
    )?;
    validate_validators(
        &layout,
        &validators,
        &initialized_accounts,
        &mut unique_accounts,
        &mut unique_network_keys,
        &mut unique_consensus_keys,
        &mut unique_consensus_pop,
        &mut unique_hosts,
        &mut seen_owners,
        false,
    )?;
```

**File:** crates/aptos/src/genesis/mod.rs (L270-312)
```rust
pub fn fetch_genesis_info(git_options: GitOptions) -> CliTypedResult<GenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;

    if layout.root_key.is_none() {
        return Err(CliError::UnexpectedError(
            "Layout field root_key was not set.  Please provide a hex encoded Ed25519PublicKey."
                .to_string(),
        ));
    }

    let validators = get_validator_configs(&client, &layout, false).map_err(parse_error)?;
    let framework = client.get_framework()?;
    Ok(GenesisInfo::new(
        layout.chain_id,
        layout.root_key.unwrap(),
        validators,
        framework,
        &GenesisConfiguration {
            allow_new_validators: layout.allow_new_validators,
            epoch_duration_secs: layout.epoch_duration_secs,
            is_test: layout.is_test,
            min_stake: layout.min_stake,
            min_voting_threshold: layout.min_voting_threshold,
            max_stake: layout.max_stake,
            recurring_lockup_duration_secs: layout.recurring_lockup_duration_secs,
            required_proposer_stake: layout.required_proposer_stake,
            rewards_apy_percentage: layout.rewards_apy_percentage,
            voting_duration_secs: layout.voting_duration_secs,
            voting_power_increase_limit: layout.voting_power_increase_limit,
            employee_vesting_start: layout.employee_vesting_start,
            employee_vesting_period_duration: layout.employee_vesting_period_duration,
            consensus_config: layout.on_chain_consensus_config,
            execution_config: layout.on_chain_execution_config,
            gas_schedule: default_gas_schedule(),
            initial_features_override: None,
            randomness_config_override: None,
            jwk_consensus_config_override: layout.jwk_consensus_config_override.clone(),
            initial_jwks: layout.initial_jwks.clone(),
            keyless_groth16_vk: layout.keyless_groth16_vk_override.clone(),
        },
    )?)
}
```

**File:** crates/aptos-genesis/src/config.rs (L190-273)
```rust
impl TryFrom<ValidatorConfiguration> for Validator {
    type Error = anyhow::Error;

    fn try_from(config: ValidatorConfiguration) -> Result<Self, Self::Error> {
        let validator_addresses = if let Some(validator_host) = config.validator_host {
            if let Some(validator_network_public_key) = config.validator_network_public_key {
                vec![validator_host
                    .as_network_address(validator_network_public_key)
                    .unwrap()]
            } else {
                return Err(anyhow::Error::msg(
                    "Validator addresses specified, but not validator network key",
                ));
            }
        } else {
            vec![]
        };

        let full_node_addresses = if let Some(full_node_host) = config.full_node_host {
            if let Some(full_node_network_key) = config.full_node_network_public_key {
                vec![full_node_host
                    .as_network_address(full_node_network_key)
                    .unwrap()]
            } else {
                return Err(anyhow::Error::msg(
                    "Full node host specified, but not full node network key",
                ));
            }
        } else {
            vec![]
        };

        let auth_key = AuthenticationKey::ed25519(&config.owner_account_public_key);
        let account_address = auth_key.account_address();
        let owner_address = AccountAddress::from(config.owner_account_address);
        if owner_address != account_address {
            return Err(anyhow::Error::msg(format!(
                "owner_account_address {} does not match account key derived one {}",
                owner_address, account_address
            )));
        }

        let auth_key = AuthenticationKey::ed25519(&config.operator_account_public_key);
        let account_address = auth_key.account_address();
        let operator_address = AccountAddress::from(config.operator_account_address);
        if operator_address != account_address {
            return Err(anyhow::Error::msg(format!(
                "operator_account_address {} does not match account key derived one {}",
                operator_address, account_address
            )));
        }

        let auth_key = AuthenticationKey::ed25519(&config.voter_account_public_key);
        let account_address = auth_key.account_address();
        let voter_address = AccountAddress::from(config.voter_account_address);
        if voter_address != account_address {
            return Err(anyhow::Error::msg(format!(
                "voter_account_address {} does not match account key derived one {}",
                voter_address, account_address
            )));
        }

        let consensus_pubkey = if let Some(consensus_public_key) = config.consensus_public_key {
            consensus_public_key.to_bytes().to_vec()
        } else {
            vec![]
        };
        let proof_of_possession = if let Some(pop) = config.proof_of_possession {
            pop.to_bytes().to_vec()
        } else {
            vec![]
        };

        Ok(Validator {
            owner_address,
            operator_address,
            voter_address,
            consensus_pubkey,
            proof_of_possession,
            network_addresses: bcs::to_bytes(&validator_addresses).unwrap(),
            full_node_network_addresses: bcs::to_bytes(&full_node_addresses).unwrap(),
            stake_amount: config.stake_amount,
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L338-373)
```text
    fun create_initialize_validator(
        aptos_framework: &signer,
        commission_config: &ValidatorConfigurationWithCommission,
        use_staking_contract: bool,
    ) {
        let validator = &commission_config.validator_config;

        let owner = &create_account(aptos_framework, validator.owner_address, validator.stake_amount);
        create_account(aptos_framework, validator.operator_address, 0);
        create_account(aptos_framework, validator.voter_address, 0);

        // Initialize the stake pool and join the validator set.
        let pool_address = if (use_staking_contract) {
            staking_contract::create_staking_contract(
                owner,
                validator.operator_address,
                validator.voter_address,
                validator.stake_amount,
                commission_config.commission_percentage,
                x"",
            );
            staking_contract::stake_pool_address(validator.owner_address, validator.operator_address)
        } else {
            stake::initialize_stake_owner(
                owner,
                validator.stake_amount,
                validator.operator_address,
                validator.voter_address,
            );
            validator.owner_address
        };

        if (commission_config.join_during_genesis) {
            initialize_validator(pool_address, validator);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L641-667)
```text
    public entry fun initialize_stake_owner(
        owner: &signer,
        initial_stake_amount: u64,
        operator: address,
        voter: address,
    ) acquires AllowedValidators, OwnerCapability, StakePool, ValidatorSet {
        check_stake_permission(owner);
        initialize_owner(owner);
        move_to(owner, ValidatorConfig {
            consensus_pubkey: vector::empty(),
            network_addresses: vector::empty(),
            fullnode_addresses: vector::empty(),
            validator_index: 0,
        });

        if (initial_stake_amount > 0) {
            add_stake(owner, initial_stake_amount);
        };

        let account_address = signer::address_of(owner);
        if (account_address != operator) {
            set_operator(owner, operator)
        };
        if (account_address != voter) {
            set_delegated_voter(owner, voter)
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L694-698)
```text
    fun initialize_owner(owner: &signer) acquires AllowedValidators {
        check_stake_permission(owner);
        let owner_address = signer::address_of(owner);
        assert!(is_allowed(owner_address), error::not_found(EINELIGIBLE_VALIDATOR));
        assert!(!stake_pool_exists(owner_address), error::already_exists(EALREADY_REGISTERED));
```

**File:** aptos-move/vm-genesis/src/lib.rs (L461-470)
```rust
        .unwrap_or_else(|e| {
            panic!(
                "Error calling {}.{}.{}: ({:#x}) {}",
                address,
                module_name,
                function_name,
                e.sub_status().unwrap_or_default(),
                e,
            )
        });
```
