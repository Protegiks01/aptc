# Audit Report

## Title
Config Sanitizer Bypass Allows Failpoints to be Enabled on Mainnet Validators Leading to Consensus Liveness Attacks

## Summary
The Aptos node lacks runtime enforcement to prevent failpoints (debug/testing features) from being enabled on mainnet validators. While the config sanitizer checks for failpoints on mainnet, this protection can be completely bypassed by setting `skip_config_sanitizer=true`. Unlike the hard assertions for `testing` and `fuzzing` features, failpoints only generate a warning, allowing misconfigured production validators to run with critical debug injection points active in consensus, execution, and mempool paths.

## Finding Description

The `are_failpoints_enabled()` function in [1](#0-0)  checks whether the failpoints feature flag is compiled into the binary. While the config sanitizer in [2](#0-1)  validates that failpoints are not enabled on mainnet nodes, this entire sanitization layer can be bypassed by setting `skip_config_sanitizer=true` as shown in [3](#0-2) .

At node startup, the code in [4](#0-3)  performs runtime checks but handles features inconsistently:
- **Testing/fuzzing features**: Hard assertion that panics if compiled in (lines 251-254)
- **Failpoints**: Only logs a warning if enabled (lines 257-258), allowing the node to continue starting

This creates a dangerous operational scenario where a validator operator could accidentally:
1. Compile aptos-node with `--features failpoints` (visible in build configuration [5](#0-4) )
2. Use a config file with `skip_config_sanitizer=true` from testing
3. Deploy to mainnet, where the node starts successfully despite failpoints being active

Once running, failpoints expose critical attack surfaces throughout the consensus layer. The network message sending in [6](#0-5)  and [7](#0-6)  and [8](#0-7)  shows that the `consensus::send::any` failpoint can block ALL consensus message transmission. Similarly, [9](#0-8)  demonstrates that proposal processing can be completely blocked.

If the misconfigured validator also has `api.failpoints_enabled=true` (checked in [10](#0-9) ), an attacker with API access could dynamically inject failures to:
- Halt consensus participation via `consensus::send::any`
- Block proposal processing via `consensus::process_proposal_msg`
- Disrupt quorum store operations
- Cause execution delays or failures

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criteria:

**Validator Node Slowdowns/Availability Issues**: A misconfigured mainnet validator with failpoints enabled could experience complete consensus participation failure if failpoints are triggered (whether accidentally through config or maliciously via API). This affects network liveness as the validator stops voting and proposing blocks.

**Significant Protocol Violations**: Injecting failures at critical consensus points could potentially cause message ordering issues, delayed block production, or validator set participation problems, degrading overall network performance.

The impact extends beyond a single misconfigured node because:
- If multiple validators are misconfigured (e.g., using the same deployment automation), the network could lose significant validator stake
- An attacker gaining API access to even one misconfigured validator could weaponize failpoints to cause targeted disruptions
- The attack surface includes 30+ failpoint locations in consensus alone, each capable of disrupting specific protocol operations

## Likelihood Explanation

**Likelihood: Medium**

While this requires operational errors, the scenario is realistic in production environments:

1. **Build Misconfiguration**: Developers may enable failpoints for local testing/debugging and forget to disable them before creating production builds. The build script in [11](#0-10)  shows failpoints can be enabled via the `FEATURES` environment variable.

2. **Config File Reuse**: The `skip_config_sanitizer` flag exists as documented in [12](#0-11)  and defaults to false, but test configurations with this set to `true` might accidentally be promoted to production.

3. **No Hard Stop**: Unlike testing/fuzzing features which cause immediate panic, failpoints only warn, making the misconfiguration silent and potentially unnoticed during deployment.

4. **CI/CD Separation**: While proper CI/CD uses separate builds ( [13](#0-12) ), custom deployment pipelines might not enforce this separation.

The likelihood is not "High" because it requires multiple configuration errors, but it's not "Low" because production misconfigurations are common, especially in complex distributed systems.

## Recommendation

Implement defense-in-depth by adding a runtime assertion that prevents mainnet validators from starting with failpoints enabled, matching the existing protection for testing/fuzzing features:

```rust
// In aptos-node/src/lib.rs, around line 254, add:

assert!(
    !cfg!(feature = "testing") && !cfg!(feature = "fuzzing"),
    "Testing features shouldn't be compiled"
);

// ADD THIS:
if let Some(chain_id) = fetch_chain_id(&db).ok() {
    assert!(
        !fail::has_failpoints() || !chain_id.is_mainnet(),
        "Failpoints are not allowed on mainnet validators! This binary was compiled with \
        --features failpoints which should never be used in production. {}",
        ERROR_MSG_BAD_FEATURE_FLAGS
    );
}
```

Additionally, consider:
1. **Prevent sanitizer bypass on mainnet**: Add validation that rejects `skip_config_sanitizer=true` when `chain_id.is_mainnet()`
2. **Build-time warnings**: Add cargo build warnings when compiling with failpoints feature
3. **Binary metadata**: Embed feature flags in binary metadata for runtime inspection
4. **Deployment validation**: Add pre-deployment checks in deployment tooling to verify production binaries don't have debug features

## Proof of Concept

```rust
// Steps to reproduce the vulnerability:

// 1. Build aptos-node with failpoints enabled
// cargo build --release --features failpoints -p aptos-node

// 2. Create a mainnet config file with sanitizer bypass:
// config.yaml:
/*
base:
  role: "validator"
  
node_startup:
  skip_config_sanitizer: true  # BYPASS SANITIZER
  
api:
  enabled: true
  failpoints_enabled: true  # ENABLE API ACCESS TO FAILPOINTS
  
failpoints:
  "consensus::send::any": "return"  # BLOCK ALL CONSENSUS MESSAGES
*/

// 3. Start the node with mainnet genesis
// ./aptos-node -f config.yaml
// 
// Expected: Node panics with error about failpoints on mainnet
// Actual: Node starts successfully and logs "Failpoints are enabled!" warning

// 4. Trigger failpoint via API (if accessible):
// curl -X POST "http://validator-api:8080/set_failpoint?name=consensus::send::any&actions=return"
//
// Result: Validator stops sending all consensus messages, becoming non-participating
// Impact: Validator loses rewards, network loses stake from active set

// 5. Verify consensus participation stopped:
// - Check validator metrics: consensus_timeout_count increases
// - Check logs: "Injected error in send_rpc" messages appear
// - Check validator status: stops proposing/voting on blocks
```

The vulnerability is confirmed by the asymmetry in runtime checks: testing/fuzzing features have hard assertions ( [14](#0-13) ) while failpoints only warn ( [15](#0-14) ), combined with the sanitizer bypass mechanism ( [3](#0-2) ).

### Citations

**File:** config/src/config/utils.rs (L40-48)
```rust
pub fn are_failpoints_enabled() -> bool {
    cfg_if! {
        if #[cfg(feature = "failpoints")] {
            true
        } else {
            false
        }
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L74-109)
```rust
fn sanitize_failpoints_config(
    node_config: &NodeConfig,
    _node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints = &node_config.failpoints;

    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }

    // Ensure that the failpoints config is populated appropriately
    if let Some(failpoints) = failpoints {
        if failpoints_enabled && failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are enabled, but the failpoints config is empty?".into(),
            ));
        } else if !failpoints_enabled && !failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are disabled, but the failpoints config is not empty!".into(),
            ));
        }
    }

    Ok(())
}
```

**File:** aptos-node/src/lib.rs (L251-273)
```rust
    assert!(
        !cfg!(feature = "testing") && !cfg!(feature = "fuzzing"),
        "Testing features shouldn't be compiled"
    );

    // Ensure failpoints are configured correctly
    if fail::has_failpoints() {
        warn!("Failpoints are enabled!");

        // Set all of the failpoints
        if let Some(failpoints) = &config.failpoints {
            for (point, actions) in failpoints {
                fail::cfg(point, actions).unwrap_or_else(|_| {
                    panic!(
                        "Failed to set actions for failpoint! Failpoint: {:?}, Actions: {:?}",
                        point, actions
                    )
                });
            }
        }
    } else if config.failpoints.is_some() {
        warn!("Failpoints is set in the node config, but the binary didn't compile with this feature!");
    }
```

**File:** aptos-node/Cargo.toml (L95-95)
```text
failpoints = ["fail/failpoints", "aptos-consensus/failpoints", "aptos-executor/failpoints", "aptos-mempool/failpoints", "aptos-api/failpoints", "aptos-config/failpoints"]
```

**File:** consensus/src/network.rs (L283-285)
```rust
        fail_point!("consensus::send::any", |_| {
            Err(anyhow::anyhow!("Injected error in request_block"))
        });
```

**File:** consensus/src/network.rs (L340-342)
```rust
        fail_point!("consensus::send::any", |_| {
            Err(anyhow::anyhow!("Injected error in send_rpc"))
        });
```

**File:** consensus/src/network.rs (L364-364)
```rust
        fail_point!("consensus::send::any", |_| ());
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** api/src/set_failpoints.rs (L27-39)
```rust
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
```

**File:** docker/builder/build-node.sh (L29-31)
```shellscript
    if [ -n "$FEATURES" ] && [ "$PACKAGE" = "aptos-node" ]; then
        echo "Building aptos-node with features ${FEATURES}"
        env "${BUILD_ENV[@]}" cargo build --profile=$PROFILE --features=$FEATURES -p $PACKAGE "$@"
```

**File:** config/src/config/node_startup_config.rs (L10-10)
```rust
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
```

**File:** .github/workflows/docker-build-test.yaml (L152-166)
```yaml
  rust-images-failpoints:
    needs: [permission-check, determine-docker-build-metadata]
    uses: aptos-labs/aptos-core/.github/workflows/workflow-run-docker-rust-build.yaml@main
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      contains(github.event.pull_request.labels.*.name, 'CICD:build-failpoints-images')
    secrets: inherit
    with:
      GIT_SHA: ${{ needs.determine-docker-build-metadata.outputs.gitSha }}
      TARGET_CACHE_ID: ${{ needs.determine-docker-build-metadata.outputs.targetCacheId }}
      PROFILE: release
      FEATURES: failpoints
      BUILD_ADDL_TESTING_IMAGES: true
      TARGET_REGISTRY: ${{ needs.determine-docker-build-metadata.outputs.targetRegistry }}
```
