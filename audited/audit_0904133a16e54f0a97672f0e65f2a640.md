# Audit Report

## Title
Insufficient Key Size Validation in Raw State Value API Allows Memory Exhaustion DoS

## Summary
The `/experimental/state_values/raw` API endpoint accepts unbounded state keys through the `RawStateValueRequest` struct without application-level size validation. While HTTP-level `Content-Length` limits exist (default 8 MB), operators who increase this limit for legitimate reasons inadvertently enable attackers to submit multi-megabyte hex-encoded keys, causing memory exhaustion and API server crashes through concurrent malicious requests.

## Finding Description
The vulnerability exists in the deserialization flow of `RawStateValueRequest`: [1](#0-0) 

The `key` field is of type `HexEncodedBytes`, which wraps a `Vec<u8>`: [2](#0-1) 

During deserialization, `HexEncodedBytes` deserializes a string and then hex-decodes it without any size validation: [3](#0-2) [4](#0-3) 

The only protection is the HTTP-level `PostSizeLimit` middleware that checks the `Content-Length` header: [5](#0-4) [6](#0-5) 

The default limit is 8 MB: [7](#0-6) 

However, this limit is configurable and can be set arbitrarily high: [8](#0-7) 

**Attack Flow:**
1. Attacker crafts POST request to `/experimental/state_values/raw` with JSON body: `{"key": "0x<massive_hex_string>"}`
2. `PostSizeLimit` middleware checks `Content-Length` (passes if under configured limit)
3. Poem framework deserializes JSON, allocating memory for:
   - The hex string itself (~N bytes)
   - The decoded `Vec<u8>` (~N/2 bytes)
   - Total: ~1.5N bytes per request
4. Multiple concurrent requests amplify memory consumption
5. API server experiences memory pressure or OOM crash

**Normal State Key Sizes:**
Typical state keys are small - a `TableHandle` (32 bytes) plus serialized key data (8-200 bytes), totaling under 1 KB: [9](#0-8) 

The API accepts keys up to ~7 MB (default config) or potentially hundreds of MB (custom config) - **thousands of times larger** than legitimate keys.

## Impact Explanation
This is a **High Severity** denial-of-service vulnerability per the Aptos bug bounty criteria ("API crashes").

**With Default Configuration (8 MB limit):**
- Single request: ~12 MB memory (8 MB string + 4 MB decoded)
- 50 concurrent requests: ~600 MB consumed
- 100 concurrent requests: ~1.2 GB consumed
- Impact: Memory pressure, degraded performance, potential OOM on resource-constrained nodes

**With Increased Configuration (e.g., 100 MB limit):**
- Single request: ~150 MB memory
- 20 concurrent requests: ~3 GB consumed
- Impact: Guaranteed OOM on most API servers, complete service outage

The attack:
- Requires no authentication
- Can be executed from any network location
- Bypasses rate limiting (each request is "valid")
- Affects availability of critical API infrastructure
- Forces node operators to restart API servers

## Likelihood Explanation
**High Likelihood** - The vulnerability is easily exploitable:

1. **No authentication required** - Public API endpoint
2. **Simple attack** - Standard HTTP POST with large JSON payload
3. **Operators likely to increase limits** - Legitimate use cases (large batch submissions) may prompt operators to raise `content_length_limit` without understanding the state key implications
4. **No application-level validation** - The code lacks any sanity checks on key sizes before processing
5. **Concurrent amplification** - Modern HTTP clients trivially send parallel requests

## Recommendation
Implement explicit key size validation before deserialization:

```rust
// In api/src/state.rs, raw_value() function, add validation after line 535:
pub fn raw_value(
    &self,
    accept_type: &AcceptType,
    request: RawStateValueRequest,
    ledger_version: Option<U64>,
) -> BasicResultWith404<MoveValue> {
    // Validate key size before processing
    const MAX_STATE_KEY_BYTES: usize = 10 * 1024; // 10 KB is generous for state keys
    if request.key.0.len() > MAX_STATE_KEY_BYTES {
        return Err(BasicErrorWith404::bad_request_with_code(
            format!(
                "State key too large: {} bytes (max: {} bytes)",
                request.key.0.len(),
                MAX_STATE_KEY_BYTES
            ),
            AptosErrorCode::InvalidInput,
            &self.context.get_latest_ledger_info()?,
        ));
    }
    
    // ... rest of existing code
}
```

Additionally, add similar validation to `RawTableItemRequest` handling in the `raw_table_item()` function: [10](#0-9) 

## Proof of Concept
```rust
#[tokio::test]
async fn test_raw_state_value_rejects_oversized_key() {
    use aptos_api_test_context::{new_test_context, current_function_name};
    
    let mut context = new_test_context(current_function_name!());
    
    // Create a 5 MB hex string (10 million hex characters)
    let huge_key = format!("0x{}", "a".repeat(10_000_000));
    
    let resp = context
        .expect_status_code(400) // Should reject with Bad Request
        .post(
            "/experimental/state_values/raw",
            serde_json::json!({
                "key": huge_key
            }),
        )
        .await;
    
    // Verify error message indicates key too large
    assert!(resp.contains("key") || resp.contains("too large"));
}

#[tokio::test]
async fn test_concurrent_oversized_keys_memory_exhaustion() {
    use aptos_api_test_context::{new_test_context, current_function_name};
    use tokio::task::JoinSet;
    
    let context = new_test_context(current_function_name!());
    
    // Create 50 concurrent requests with 7 MB keys each
    let huge_key = format!("0x{}", "b".repeat(7_000_000));
    
    let mut set = JoinSet::new();
    for _ in 0..50 {
        let ctx = context.clone();
        let key = huge_key.clone();
        set.spawn(async move {
            ctx.post(
                "/experimental/state_values/raw",
                serde_json::json!({"key": key}),
            ).await
        });
    }
    
    // Without the fix, this will cause memory pressure/OOM
    // With the fix, all requests should be rejected early
    while let Some(_) = set.join_next().await {}
}
```

## Notes
The vulnerability stems from treating `HexEncodedBytes` as a generic binary wrapper without domain-specific validation. State keys have well-defined size bounds based on their structure (`AccessPath`, `TableItem`, `Raw`), but the API lacks enforcement of these invariants at the deserialization boundary. This breaks the "Resource Limits" invariant that all operations must respect computational and storage limits.

### Citations

**File:** api/types/src/state.rs (L10-12)
```rust
pub struct RawStateValueRequest {
    pub key: HexEncodedBytes,
}
```

**File:** api/types/src/move_types.rs (L147-147)
```rust
pub struct HexEncodedBytes(pub Vec<u8>);
```

**File:** api/types/src/move_types.rs (L155-171)
```rust
impl FromStr for HexEncodedBytes {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        let hex_str = if let Some(hex) = s.strip_prefix("0x") {
            hex
        } else {
            s
        };
        Ok(Self(hex::decode(hex_str).map_err(|e| {
            format_err!(
                "decode hex-encoded string({:?}) failed, caused by error: {}",
                s,
                e
            )
        })?))
    }
```

**File:** api/types/src/move_types.rs (L187-194)
```rust
impl<'de> Deserialize<'de> for HexEncodedBytes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = <String>::deserialize(deserializer)?;
        s.parse().map_err(D::Error::custom)
    }
```

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** api/src/runtime.rs (L255-255)
```rust
            .with(PostSizeLimit::new(size_limit))
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** config/src/config/api_config.rs (L155-160)
```rust
    pub fn content_length_limit(&self) -> u64 {
        match self.content_length_limit {
            Some(v) => v,
            None => DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT,
        }
    }
```

**File:** types/src/state_store/state_key/inner.rs (L46-59)
```rust
#[derive(Clone, CryptoHasher, Eq, PartialEq, Serialize, Deserialize, Ord, PartialOrd, Hash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
#[serde(rename = "StateKey")]
pub enum StateKeyInner {
    AccessPath(AccessPath),
    TableItem {
        handle: TableHandle,
        #[serde(with = "serde_bytes")]
        key: Vec<u8>,
    },
    // Only used for testing
    #[serde(with = "serde_bytes")]
    Raw(Vec<u8>),
}
```

**File:** api/src/state.rs (L472-485)
```rust
    pub fn raw_table_item(
        &self,
        accept_type: &AcceptType,
        table_handle: Address,
        table_item_request: RawTableItemRequest,
        ledger_version: Option<U64>,
    ) -> BasicResultWith404<MoveValue> {
        // Retrieve local state
        let (ledger_info, ledger_version, state_view) = self
            .context
            .state_view(ledger_version.map(|inner| inner.0))?;

        let state_key =
            StateKey::table_item(&TableHandle(table_handle.into()), &table_item_request.key.0);
```
