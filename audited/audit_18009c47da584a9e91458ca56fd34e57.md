# Audit Report

## Title
Missing Signature Verification During Database Recovery Allows Consensus Randomness Corruption

## Summary
The `RandStorage` trait does not specify validation requirements, and critically, the `AugDataStore::new()` recovery path loads `CertifiedAugData` from persistent storage without verifying the aggregated signatures. This allows corrupted or malicious augmented data to bypass signature verification and corrupt the randomness generation protocol, potentially breaking consensus safety.

## Finding Description

The vulnerability exists in two layers:

**1. Trait Design Flaw:**
The `RandStorage` trait defines storage operations but specifies no validation requirements. [1](#0-0) 

Both implementations (`RandDb` and `InMemRandDb`) persist data directly without any validation checks. [2](#0-1) 

**2. Missing Verification During Recovery:**
When a validator node restarts, `AugDataStore::new()` loads all `CertifiedAugData` from the database and directly uses it to augment the randomness configuration WITHOUT verifying the aggregated signatures. [3](#0-2) 

The `CertifiedAugData` type has a `verify()` method that validates aggregated signatures. [4](#0-3) 

The `RandConfig` passed to `AugDataStore::new()` contains a `ValidatorVerifier` that should be used for verification. [5](#0-4) 

However, the recovery code never calls `certified_data.verify()` before using the data.

**Attack Path:**

1. Attacker gains file system access to a validator node (through container escape, OS vulnerability, backup manipulation, or another exploit)
2. Attacker modifies the RandDB files to inject malicious `CertifiedAugData` with invalid signatures or malicious delta values
3. Validator node restarts
4. `AugDataStore::new()` loads the corrupted data from database
5. Corrupted data is used to augment `RandConfig` through `add_certified_delta()` [6](#0-5) 
6. Corrupted augmented public keys (APKs) are stored in the randomness configuration
7. These corrupted APKs are used for randomness share verification and aggregation, breaking the randomness generation protocol

While the normal network message path validates signatures through the verification task [7](#0-6) , the recovery path bypasses all validation.

## Impact Explanation

**Severity: HIGH to CRITICAL**

This vulnerability breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure."

The corrupted augmented data affects consensus-critical randomness generation:
- Corrupted APKs can cause randomness share verification failures
- Different validators may compute different randomness values
- Could lead to consensus liveness failures or safety violations
- Potential for predictable randomness if attacker controls the delta values

This meets the **Consensus/Safety violations** criteria for Critical severity. While exploitation requires file system access (not purely network-based), this represents a fundamental defense-in-depth failure where signature verification is skipped during a critical recovery path.

## Likelihood Explanation

**Likelihood: MEDIUM**

Exploitation requires:
1. File system access to the validator node (through container escape, OS vulnerability, backup/restore manipulation, or another vulnerability)
2. Knowledge of the RandDB format and CertifiedAugData structure
3. Node restart to trigger the vulnerable recovery path

While not trivially exploitable over the network, this is realistic for:
- Attackers who have compromised the host system
- Supply chain attacks on validator infrastructure
- Insider threats with system access
- Exploitation chains combining this with other vulnerabilities

The lack of verification during recovery violates defense-in-depth principles and creates a persistent attack vector.

## Recommendation

**Fix 1: Add signature verification during recovery**

In `AugDataStore::new()`, verify all loaded `CertifiedAugData` before using it:

```rust
pub fn new(
    epoch: u64,
    signer: Arc<ValidatorSigner>,
    config: RandConfig,
    fast_config: Option<RandConfig>,
    db: Arc<dyn RandStorage<D>>,
) -> Self {
    // ... existing filtering code ...

    // ADDED: Verify signatures before using certified data
    let mut verified_certified_data = vec![];
    for (id, certified_data) in certified_data {
        if let Err(e) = certified_data.verify(&config.validator) {
            error!(
                "[AugDataStore] Signature verification failed for certified aug data from {}: {}",
                certified_data.author(), e
            );
            // Remove invalid data from DB
            if let Err(e) = db.remove_certified_aug_data(vec![certified_data]) {
                error!("[AugDataStore] Failed to remove invalid certified aug data: {}", e);
            }
            continue;
        }
        verified_certified_data.push((id, certified_data));
    }

    for (_, certified_data) in &verified_certified_data {
        certified_data
            .data()
            .augment(&config, &fast_config, certified_data.author());
    }

    Self {
        // ... use verified_certified_data instead of certified_data ...
    }
}
```

**Fix 2: Document validation requirements in trait**

Add documentation to the `RandStorage` trait specifying that callers MUST verify data before persisting:

```rust
/// Storage interface for randomness generation data.
/// 
/// # Security Requirements
/// Implementations MUST NOT perform validation - callers are responsible for:
/// - Verifying CertifiedAugData signatures before calling save_certified_aug_data()
/// - Verifying AugData before calling save_aug_data()
/// - Re-verifying all data loaded from storage during recovery
pub trait RandStorage<D>: Send + Sync + 'static {
    // ... existing methods ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::bls12381::Signature;
    use aptos_types::aggregate_signature::AggregateSignature;
    
    #[test]
    fn test_unverified_recovery_accepts_invalid_signatures() {
        // Setup: Create a mock RandDb with invalid CertifiedAugData
        let db = create_mock_rand_db();
        
        // Create CertifiedAugData with INVALID signatures
        let aug_data = AugData::new(1, author, AugmentedData { 
            delta: malicious_delta,
            fast_delta: None 
        });
        
        // Create aggregate signature with WRONG signers (not enough for quorum)
        let invalid_signatures = AggregateSignature::new(vec![/* only 1 signature */]);
        let certified_aug_data = CertifiedAugData::new(aug_data, invalid_signatures);
        
        // Persist to DB (current code doesn't verify)
        db.save_certified_aug_data(&certified_aug_data).unwrap();
        
        // Simulate node restart - recovery loads from DB
        let aug_data_store = AugDataStore::new(
            epoch,
            signer,
            config.clone(),
            None,
            db,
        );
        
        // BUG: The invalid data is loaded and used WITHOUT verification
        // The malicious delta has corrupted the RandConfig's certified APKs
        
        // Verify the bug: Check that malicious data was accepted
        assert!(aug_data_store.certified_data.contains_key(&author));
        
        // With the fix, this should fail because signatures don't verify
    }
}
```

## Notes

This vulnerability represents a critical defense-in-depth failure. While the normal network-based code path correctly validates signatures before persistence, the recovery path creates a persistent attack surface. Any compromise that allows database corruption—whether through file system access, backup manipulation, or a separate vulnerability—can inject malicious randomness data that bypasses signature verification and corrupts consensus-critical state. The fix requires adding verification during recovery and documenting the trait's security contract.

### Citations

**File:** consensus/src/rand/rand_gen/storage/interface.rs (L6-23)
```rust
pub trait RandStorage<D>: Send + Sync + 'static {
    fn save_key_pair_bytes(&self, epoch: u64, key_pair: Vec<u8>) -> anyhow::Result<()>;
    fn save_aug_data(&self, aug_data: &AugData<D>) -> anyhow::Result<()>;
    fn save_certified_aug_data(
        &self,
        certified_aug_data: &CertifiedAugData<D>,
    ) -> anyhow::Result<()>;

    fn get_key_pair_bytes(&self) -> anyhow::Result<Option<(u64, Vec<u8>)>>;
    fn get_all_aug_data(&self) -> anyhow::Result<Vec<(AugDataId, AugData<D>)>>;
    fn get_all_certified_aug_data(&self) -> anyhow::Result<Vec<(AugDataId, CertifiedAugData<D>)>>;

    fn remove_aug_data(&self, aug_data: Vec<AugData<D>>) -> anyhow::Result<()>;
    fn remove_certified_aug_data(
        &self,
        certified_aug_data: Vec<CertifiedAugData<D>>,
    ) -> anyhow::Result<()>;
}
```

**File:** consensus/src/rand/rand_gen/storage/db.rs (L94-96)
```rust
    fn save_certified_aug_data(&self, certified_aug_data: &CertifiedAugData<D>) -> Result<()> {
        Ok(self.put::<CertifiedAugDataSchema<D>>(&certified_aug_data.id(), certified_aug_data)?)
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L57-71)
```rust
        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
        if let Err(e) = db.remove_certified_aug_data(to_remove) {
            error!(
                "[AugDataStore] failed to remove certified aug data: {:?}",
                e
            );
        }

        for (_, certified_data) in &certified_data {
            certified_data
                .data()
                .augment(&config, &fast_config, certified_data.author());
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L555-558)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        verifier.verify_multi_signatures(&self.aug_data, &self.signatures)?;
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L581-591)
```rust
pub struct RandConfig {
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    // public parameters of the weighted VUF
    vuf_pp: WvufPP,
    // key shares for weighted VUF
    keys: Arc<RandKeys>,
    // weighted config for weighted VUF
    wconfig: WeightedConfigBlstrs,
}
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-60)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
            RandMessage::FastShare(share) => {
                share.share.verify(fast_rand_config.as_ref().ok_or_else(|| {
                    anyhow::anyhow!("[RandMessage] rand config for fast path not found")
                })?)
            },
            _ => bail!("[RandMessage] unexpected message type"),
        }
    }
```
