# Audit Report

## Title
Unbounded Block History Configuration Enables Database Query Amplification DoS via Gas Estimation API

## Summary
The `GasEstimationConfig.aggressive_block_history` parameter lacks upper bound validation in the configuration sanitizer, allowing node operators to set arbitrarily large values. When the public `/estimate_gas_price` API endpoint is called, it triggers a loop that iterates up to `aggressive_block_history` times, with each iteration making multiple expensive database queries. This enables resource exhaustion attacks where a single API request can cause database timeouts and API crashes.

## Finding Description

The gas estimation configuration sanitizer validates that block history values are non-zero and properly ordered, but critically fails to enforce upper bounds. [1](#0-0) 

This allows `aggressive_block_history` to be set to extremely large values (e.g., 100,000 or 1,000,000). The configuration is then used directly in a database query loop without additional validation: [2](#0-1) 

Each loop iteration makes a database call to `get_block_info_by_version`, and subsequently calls `block_min_inclusion_price`, which invokes `get_gas_prices_and_used`: [3](#0-2) 

This function makes two additional database queries per block (`get_transaction_iterator` and `get_transaction_info_iterator`), resulting in approximately **3 Ã— aggressive_block_history** total database operations per API request.

The `/estimate_gas_price` endpoint is a public GET endpoint with no parameters: [4](#0-3) 

**Attack Scenario:**
1. Node operator sets `aggressive_block_history: 100000` in configuration file (due to misconfiguration, malicious template, or misunderstanding)
2. Attacker sends HTTP GET request to `/estimate_gas_price`
3. System executes loop 100,000 times, making ~300,000 database queries
4. Database connection pool exhaustion occurs, queries timeout
5. API becomes unresponsive, cascading to node availability issues

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:
- **API crashes**: Excessive database queries can cause API endpoint timeouts and crashes
- **Validator node slowdowns**: Database resource exhaustion affects overall node performance
- **Availability impact**: Public-facing API becomes unresponsive, affecting all users

The impact is amplified because:
- The endpoint is public and unauthenticated
- Rate limiting (100 req/min default) doesn't protect against cost-per-request exploitation
- A single malicious request can trigger hundreds of thousands of database operations
- The cache also grows unboundedly, consuming memory proportional to `aggressive_block_history` [5](#0-4) 

## Likelihood Explanation

**Likelihood: Medium-High**

The attack has low technical barriers:
- Requires only a simple HTTP GET request
- No authentication needed
- No special parameters required

The prerequisite is that a node operator must have configured an excessively high `aggressive_block_history` value. This can occur through:
- **Accidental misconfiguration**: Operators may not understand the performance implications
- **Malicious configuration templates**: Attackers could distribute configs with high values
- **Future default changes**: If defaults are increased without adding upper bounds
- **Insufficient documentation**: No warnings about reasonable upper limits

Once misconfigured, exploitation is trivial and immediate. Given that node operators frequently copy configuration templates and may not thoroughly validate all parameters, this scenario is realistic.

## Recommendation

Add strict upper bound validation in the configuration sanitizer:

```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Add upper bound checks
        const MAX_BLOCK_HISTORY: usize = 1000; // Reasonable limit for API responsiveness
        
        if gas_estimation_config.aggressive_block_history > MAX_BLOCK_HISTORY {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive_block_history {} exceeds maximum allowed value of {}",
                    gas_estimation_config.aggressive_block_history,
                    MAX_BLOCK_HISTORY
                ),
            ));
        }

        // Existing validation checks...
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be >= low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        Ok(())
    }
}
```

Additionally, consider:
1. Adding runtime circuit breakers that abort expensive operations after a timeout
2. Implementing cost-based rate limiting, not just request-count limiting
3. Adding metrics/alerts for API endpoints with high database query counts
4. Documenting recommended configuration values with performance implications

## Proof of Concept

```rust
#[cfg(test)]
mod test_gas_estimation_dos {
    use super::*;
    use aptos_api_test_context::{new_test_context, TestContext};
    
    #[tokio::test]
    async fn test_excessive_block_history_causes_timeout() {
        // Create a malicious configuration
        let mut node_config = NodeConfig::default();
        node_config.api.gas_estimation.enabled = true;
        node_config.api.gas_estimation.aggressive_block_history = 100000; // Excessive value
        node_config.api.gas_estimation.market_block_history = 30;
        node_config.api.gas_estimation.low_block_history = 10;
        
        // This should fail sanitization with the fix, but currently passes
        let sanitize_result = GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );
        
        // Without fix: sanitization passes (vulnerability)
        assert!(sanitize_result.is_ok()); 
        
        // Create test context with malicious config
        let mut context = new_test_context_with_config(
            "test_excessive_block_history",
            node_config,
            false,
            false,
        );
        
        // Create some blocks
        for _ in 0..200 {
            context.commit_block(&[]).await;
        }
        
        // Measure time for API call - should timeout or take excessive time
        let start = std::time::Instant::now();
        let response = context.get("/estimate_gas_price").await;
        let duration = start.elapsed();
        
        println!("API call took: {:?}", duration);
        println!("Response status: {:?}", response.status());
        
        // With the vulnerability, this will either:
        // 1. Take excessive time (multiple seconds)
        // 2. Timeout and return error
        // 3. Exhaust database connections
        assert!(duration.as_secs() > 5 || response.status() == 500);
    }
}
```

## Notes

This vulnerability demonstrates a common pattern where configuration validation focuses on logical consistency (relationships between values) but fails to enforce absolute resource limits. The public nature of the API endpoint combined with unbounded database query amplification creates a significant attack surface for availability-impacting exploits.

### Citations

**File:** config/src/config/gas_estimation_config.rs (L53-95)
```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Validate aggressive price takes the most history
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be > low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        Ok(())
    }
}
```

**File:** api/src/context.rs (L1168-1223)
```rust
    fn get_gas_prices_and_used(
        &self,
        start_version: Version,
        limit: u64,
        ledger_version: Version,
        count_majority_use_case: bool,
    ) -> Result<(Vec<(u64, u64)>, Vec<BlockEndInfo>, Option<f32>)> {
        if start_version > ledger_version || limit == 0 {
            return Ok((vec![], vec![], None));
        }

        // This is just an estimation, so we can just skip over errors
        let limit = std::cmp::min(limit, ledger_version - start_version + 1);
        let txns = self.db.get_transaction_iterator(start_version, limit)?;
        let infos = self
            .db
            .get_transaction_info_iterator(start_version, limit)?;

        let mut gas_prices = Vec::new();
        let mut block_end_infos = Vec::new();
        let mut count_by_use_case = HashMap::new();
        for (txn, info) in txns.zip(infos) {
            match txn.as_ref() {
                Ok(Transaction::UserTransaction(txn)) => {
                    if let Ok(info) = info.as_ref() {
                        gas_prices.push((txn.gas_unit_price(), info.gas_used()));
                        if count_majority_use_case {
                            let use_case_key = txn.parse_use_case();
                            *count_by_use_case.entry(use_case_key).or_insert(0) += 1;
                        }
                    }
                },
                Ok(Transaction::BlockEpilogue(txn)) => {
                    if let Some(block_end_info) = txn.try_as_block_end_info() {
                        block_end_infos.push(block_end_info.clone());
                    }
                },
                _ => {},
            }
        }

        let majority_use_case_fraction = if count_majority_use_case {
            count_by_use_case.iter().max_by_key(|(_, v)| *v).and_then(
                |(max_use_case, max_value)| {
                    if let UseCaseKey::ContractAddress(_) = max_use_case {
                        Some(*max_value as f32 / count_by_use_case.values().sum::<u64>() as f32)
                    } else {
                        None
                    }
                },
            )
        } else {
            None
        };
        Ok((gas_prices, block_end_infos, majority_use_case_fraction))
    }
```

**File:** api/src/context.rs (L1325-1359)
```rust
        let max_block_history = config.aggressive_block_history;
        // 1. Get the block metadata txns
        let mut lookup_version = ledger_info.ledger_version.0;
        let mut blocks = vec![];
        // Skip the first block, which may be partial
        if let Ok((first, _, block)) = self.db.get_block_info_by_version(lookup_version) {
            if block.epoch() == epoch {
                lookup_version = first.saturating_sub(1);
            }
        }
        let mut cached_blocks_hit = false;
        for _i in 0..max_block_history {
            if cache
                .min_inclusion_prices
                .contains_key(&(epoch, lookup_version))
            {
                cached_blocks_hit = true;
                break;
            }
            match self.db.get_block_info_by_version(lookup_version) {
                Ok((first, last, block)) => {
                    if block.epoch() != epoch {
                        break;
                    }
                    lookup_version = first.saturating_sub(1);
                    blocks.push((first, last));
                    if lookup_version == 0 {
                        break;
                    }
                },
                Err(_) => {
                    break;
                },
            }
        }
```

**File:** api/src/context.rs (L1447-1452)
```rust
        // GC old entries
        if cache.min_inclusion_prices.len() > max_block_history {
            for _i in max_block_history..cache.min_inclusion_prices.len() {
                cache.min_inclusion_prices.pop_first();
            }
        }
```

**File:** api/src/transactions.rs (L811-847)
```rust
    #[oai(
        path = "/estimate_gas_price",
        method = "get",
        operation_id = "estimate_gas_price",
        tag = "ApiTags::Transactions"
    )]
    async fn estimate_gas_price(&self, accept_type: AcceptType) -> BasicResult<GasEstimation> {
        fail_point_poem("endpoint_encode_submission")?;
        self.context
            .check_api_output_enabled("Estimate gas price", &accept_type)?;

        let context = self.context.clone();
        api_spawn_blocking(move || {
            let latest_ledger_info = context.get_latest_ledger_info()?;
            let gas_estimation = context.estimate_gas_price(&latest_ledger_info)?;
            Self::log_gas_estimation(&gas_estimation);

            match accept_type {
                AcceptType::Json => BasicResponse::try_from_json((
                    gas_estimation,
                    &latest_ledger_info,
                    BasicResponseStatus::Ok,
                )),
                AcceptType::Bcs => {
                    let gas_estimation_bcs = GasEstimationBcs {
                        gas_estimate: gas_estimation.gas_estimate,
                    };
                    BasicResponse::try_from_bcs((
                        gas_estimation_bcs,
                        &latest_ledger_info,
                        BasicResponseStatus::Ok,
                    ))
                },
            }
        })
        .await
    }
```
