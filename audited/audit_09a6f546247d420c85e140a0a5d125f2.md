# Audit Report

## Title
Byzantine Peers Can Force Minimum Chunk Sizes to Cause State Sync Denial of Service

## Summary
Byzantine peers can advertise maliciously small chunk sizes (as low as 1) in their storage summaries without validation. If attackers control a majority of connected peers, the median-based chunk size calculation will select the malicious value, forcing victim nodes to request data one item at a time instead of in normal ~3000-item chunks. This causes a ~3000x increase in network requests, resulting in severe state sync performance degradation and potential synchronization failure.

## Finding Description

The state sync data client calculates optimal chunk sizes by taking the median of chunk sizes advertised by all connected peers. [1](#0-0) 

When a peer advertises its storage capabilities, it includes `ProtocolMetadata` specifying maximum chunk sizes for different data types. [2](#0-1) 

**Critical Vulnerability**: There is **no minimum validation** on advertised chunk sizes. Peers can advertise chunk sizes as low as 1, and these values are accepted without scrutiny. [3](#0-2) 

The median calculation uses a simple sort-and-pick-middle approach: [4](#0-3) 

The only validation is that chunk sizes must not be zero: [5](#0-4) 

**Attack Scenario**:
1. Attacker runs multiple malicious peers configured with `max_transaction_chunk_size = 1` (and similar for other chunk types)
2. These peers connect to victim nodes (fullnodes can accept up to 100 inbound connections) [6](#0-5) 
3. When polled, Byzantine peers advertise chunk size = 1 in their `StorageServerSummary`
4. If attackers control ≥50% of connected peers, the median becomes 1
5. Victim calculates `optimal_chunk_sizes` with these malicious medians
6. When creating data requests, each request now fetches only `min(total_items, 1) = 1` item: [7](#0-6) 

**Why Scoring Doesn't Help**: The peer scoring system only penalizes peers for bad responses (NotUseful or Malicious errors), not for advertising low chunk sizes. [8](#0-7)  Byzantine peers advertising chunk_size=1 remain trusted and contribute to the median calculation.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program because it causes **validator node slowdowns** and **significant protocol violations**.

**Quantified Impact**:
- Normal throughput: 6 concurrent requests × 3000 items = 18,000 items per round-trip
- Attack throughput: 6 concurrent requests × 1 item = 6 items per round-trip  
- **Performance degradation: 3000x reduction**

For a node syncing 1 million transactions:
- Normal: ~56 request rounds, ~5.6 seconds (at 100ms RTT)
- Attack: ~166,667 request rounds, ~16,667 seconds (~4.6 hours)

**Consequences**:
1. **State Sync Failure**: Nodes cannot catch up if blocks arrive faster than sync progresses
2. **Resource Exhaustion**: Excessive network overhead, CPU for request processing
3. **Validator Impact**: Validators falling behind consensus cannot participate, reducing network decentralization
4. **Availability Degradation**: Fullnodes unable to serve users effectively

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements**:
- Run malicious peers with modified chunk size configuration
- Connect to victim nodes (trivial for fullnodes accepting inbound connections)
- Control >50% of victim's connected peers

**Feasibility Analysis**:
- Fullnodes accept up to 100 inbound connections. Attacker needs 51+ connections to control median
- For nodes with fewer peers (e.g., new nodes with 6-10 connections), attack is easier
- No special privileges required - any peer can advertise arbitrary chunk sizes
- No cost to attacker beyond running network nodes
- Attack is undetectable until performance degradation occurs

**Real-World Scenarios**:
1. Bootstrapping nodes with few initial peers are highly vulnerable
2. Isolated networks or testnets with limited peer diversity
3. Sybil attacks where attacker floods network with malicious peers

## Recommendation

Implement minimum chunk size validation at multiple layers:

**1. Validation on Receipt** (primary fix):
Add minimum chunk size constants and validate peer advertisements:

```rust
// In config/src/config/state_sync_config.rs
const MIN_EPOCH_CHUNK_SIZE: u64 = 10;
const MIN_STATE_CHUNK_SIZE: u64 = 100;
const MIN_TRANSACTION_CHUNK_SIZE: u64 = 100;
const MIN_TRANSACTION_OUTPUT_CHUNK_SIZE: u64 = 100;
```

Validate in `update_summary()`:
```rust
// In state-sync/aptos-data-client/src/peer_states.rs
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Validate chunk sizes meet minimum requirements
    let metadata = &storage_summary.protocol_metadata;
    if metadata.max_epoch_chunk_size < MIN_EPOCH_CHUNK_SIZE
        || metadata.max_state_chunk_size < MIN_STATE_CHUNK_SIZE
        || metadata.max_transaction_chunk_size < MIN_TRANSACTION_CHUNK_SIZE
        || metadata.max_transaction_output_chunk_size < MIN_TRANSACTION_OUTPUT_CHUNK_SIZE
    {
        warn!("Peer {} advertised invalid chunk sizes, ignoring", peer);
        // Optionally: penalize peer score
        self.update_score_error(peer, ErrorType::Malicious);
        return;
    }
    
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}
```

**2. Defense-in-Depth** (additional protection):
Add floor to median calculation:
```rust
fn median_or_max<T: Ord + Copy>(mut values: Vec<T>, max_value: T, min_value: T) -> T {
    values.sort_unstable();
    let idx = values.len() / 2;
    let median = values.get(idx).copied();
    
    // Ensure result is within [min_value, max_value]
    std::cmp::max(min_value, std::cmp::min(median.unwrap_or(max_value), max_value))
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_config::config::AptosDataClientConfig;

    #[test]
    fn test_byzantine_chunk_size_median_attack() {
        // Setup: 5 peers, 3 Byzantine advertising chunk_size=1, 2 honest advertising 3000
        let config = AptosDataClientConfig::default();
        
        // Byzantine peers advertise minimum chunk sizes
        let byzantine_chunk_size = 1u64;
        let honest_chunk_size = 3000u64;
        
        // Simulate 5 peers: 3 Byzantine, 2 honest
        let max_transaction_chunk_sizes = vec![
            byzantine_chunk_size,  // Byzantine peer 1
            byzantine_chunk_size,  // Byzantine peer 2
            byzantine_chunk_size,  // Byzantine peer 3
            honest_chunk_size,     // Honest peer 1
            honest_chunk_size,     // Honest peer 2
        ];
        
        // Calculate optimal chunk sizes (current vulnerable implementation)
        let optimal = calculate_optimal_chunk_sizes(
            &config,
            max_transaction_chunk_sizes.clone(),
            max_transaction_chunk_sizes.clone(),
            max_transaction_chunk_sizes.clone(),
            max_transaction_chunk_sizes,
        );
        
        // VULNERABILITY: Median is controlled by Byzantine peers
        assert_eq!(optimal.transaction_chunk_size, 1);
        assert_eq!(optimal.state_chunk_size, 1);
        
        // Impact demonstration: Syncing 1 million transactions
        let total_transactions = 1_000_000u64;
        let concurrent_requests = 6u64;
        
        // Normal case: ~334 rounds needed
        let normal_rounds = total_transactions / (honest_chunk_size * concurrent_requests);
        
        // Attack case: ~166,667 rounds needed  
        let attack_rounds = total_transactions / (byzantine_chunk_size * concurrent_requests);
        
        println!("Normal sync: {} rounds", normal_rounds);
        println!("Attack sync: {} rounds", attack_rounds);
        println!("Performance degradation: {}x", attack_rounds / normal_rounds);
        
        // This demonstrates ~500x degradation (actually 3000x without concurrency limit)
        assert!(attack_rounds > normal_rounds * 100);
    }
}
```

## Notes

This vulnerability affects the **Resource Limits** invariant by allowing Byzantine peers to cause excessive resource consumption. While not directly a consensus or funds vulnerability, it severely impacts network availability and node operation, qualifying as High Severity.

The attack is particularly effective because:
1. No authentication or authorization prevents malicious chunk size advertisements
2. The median calculation assumes honest majority without validation
3. Peer scoring only applies to response quality, not advertisement quality
4. Fullnodes' liberal connection policies (100 inbound) make controlling the median feasible

**Mitigation Priority**: HIGH - This should be fixed immediately as it's easily exploitable and can significantly degrade network performance.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L168-174)
```rust
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L416-418)
```rust
/// To calculate the optimal chunk size, we take the median for each
/// chunk size parameter. This works well when we have an honest
/// majority that mostly agrees on the same chunk sizes.
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L448-456)
```rust
fn median_or_max<T: Ord + Copy>(mut values: Vec<T>, max_value: T) -> T {
    // Calculate median
    values.sort_unstable();
    let idx = values.len() / 2;
    let median = values.get(idx).copied();

    // Return median or max
    min(median.unwrap_or(max_value), max_value)
}
```

**File:** state-sync/storage-service/types/src/responses.rs (L636-642)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProtocolMetadata {
    pub max_epoch_chunk_size: u64, // The max number of epochs the server can return in a single chunk
    pub max_state_chunk_size: u64, // The max number of states the server can return in a single chunk
    pub max_transaction_chunk_size: u64, // The max number of transactions the server can return in a single chunk
    pub max_transaction_output_chunk_size: u64, // The max number of transaction outputs the server can return in a single chunk
}
```

**File:** state-sync/aptos-data-client/src/client.rs (L213-214)
```rust
    pub fn update_peer_storage_summary(&self, peer: PeerNetworkId, summary: StorageServerSummary) {
        self.peer_states.update_summary(peer, summary)
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L478-490)
```rust
fn verify_optimal_chunk_sizes(optimal_chunk_sizes: &OptimalChunkSizes) -> Result<(), Error> {
    if optimal_chunk_sizes.state_chunk_size == 0
        || optimal_chunk_sizes.epoch_chunk_size == 0
        || optimal_chunk_sizes.transaction_chunk_size == 0
        || optimal_chunk_sizes.transaction_output_chunk_size == 0
    {
        Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Found at least one optimal chunk size of zero: {:?}",
            optimal_chunk_sizes
        )))
    } else {
        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L43-44)
```rust
pub const MAX_FULLNODE_OUTBOUND_CONNECTIONS: usize = 6;
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2070-2072)
```rust
    while total_items_to_fetch > 0 && num_requests_made < max_number_of_requests {
        // Calculate the number of items to fetch in this request
        let num_items_to_fetch = cmp::min(total_items_to_fetch, optimal_chunk_size);
```
