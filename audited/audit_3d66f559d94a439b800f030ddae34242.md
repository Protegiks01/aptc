# Audit Report

## Title
Consensus Data Hash Validation Bypass in Fast-Forward Sync Special Case

## Summary
The `guarded_sign_commit_vote()` function in `consensus/safety-rules/src/safety_rules.rs` contains a validation gap where identical `commit_info` (BlockInfo) from different consensus contexts are treated as valid without verifying that the `consensus_data_hash` field remains consistent. This allows a validator to sign ledger infos with manipulated consensus data under specific conditions.

## Finding Description

The `guarded_sign_commit_vote()` function is designed to validate commit votes during the consensus process. [1](#0-0) 

The critical validation logic includes two checks:

**Check 1 (Line 381-392)**: Special case handling for fast-forward sync [2](#0-1) 

This check compares `old_ledger_info.commit_info() != new_ledger_info.commit_info()` - comparing only the `BlockInfo` structure, which contains epoch, round, block ID, executed state, version, timestamp, and next epoch state. [3](#0-2) 

**Check 2 (Line 395-403)**: Ordering-only field matching [4](#0-3) 

The `match_ordered_only()` function only verifies that epoch, round, block ID, and timestamp match. [5](#0-4) 

**The Vulnerability**: The `LedgerInfo` structure contains TWO fields: `commit_info` (BlockInfo) and `consensus_data_hash`. [6](#0-5) 

The validation checks only compare the `commit_info` field but **never verify that `consensus_data_hash` is consistent** between old and new ledger infos. The `consensus_data_hash` commits to the `VoteData` (proposed and parent blocks) which is fundamental to consensus agreement.

**Attack Scenario**:
1. During fast-forward sync when `order_vote_enabled=true`, the system sets root ordered cert to commit cert. [7](#0-6) 

2. If an attacker can access the safety rules service (which can be exposed over network in Process mode without authentication [8](#0-7) ), they can send crafted `SignCommitVote` requests. [9](#0-8) 

3. Attacker provides:
   - `old_ledger_info`: A valid commit certificate for block B (with valid 2f+1 signatures and `consensus_data_hash=H1`)
   - `new_ledger_info`: Same BlockInfo but with `consensus_data_hash=H2` (where H2 â‰  H1)

4. The checks pass because only `commit_info` is compared, not the full `LedgerInfo` including `consensus_data_hash`.

5. The validator signs the malicious ledger info with incorrect consensus data.

## Impact Explanation

This qualifies as **HIGH severity** per Aptos bug bounty criteria ("Significant protocol violations"):

- **Consensus Safety Violation**: The `consensus_data_hash` is supposed to cryptographically commit to the consensus decision (VoteData containing proposed and parent blocks). Allowing validators to sign ledger infos with arbitrary `consensus_data_hash` values breaks this fundamental guarantee.

- **Potential for Equivocation**: A validator signing different consensus data for the same block could enable equivocation attacks if combined with other vulnerabilities.

- **Protocol Integrity**: The validation gap means the safety rules don't enforce the critical invariant that consensus data must match what was actually agreed upon during ordering.

While full consensus break requires 2f+1 validators to sign the malicious data, getting even one validator to sign incorrect consensus data is a significant protocol violation.

## Likelihood Explanation

**Likelihood: Medium to Low** depending on deployment configuration:

**Factors increasing likelihood**:
- The validation gap exists in production code
- Process mode can expose the service over network
- No authentication on the remote service [10](#0-9) 
- Attacker can obtain valid commit certificates from network monitoring

**Factors decreasing likelihood**:
- Requires Process mode deployment (not default Local mode)
- Requires network access to the safety rules service
- Requires obtaining valid LedgerInfoWithSignatures with 2f+1 signatures
- In normal flow, `generate_commit_ledger_info()` copies consensus_data_hash correctly [11](#0-10) 
- Single validator signing isn't sufficient for consensus break without other validators

## Recommendation

Add explicit validation that `consensus_data_hash` is consistent between old and new ledger infos:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;

    let old_ledger_info = ledger_info.ledger_info();

    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() != new_ledger_info.commit_info()
    {
        return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
    }

    // ADD THIS CHECK: Verify consensus_data_hash consistency
    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() == new_ledger_info.commit_info()
        && old_ledger_info.consensus_data_hash() != new_ledger_info.consensus_data_hash()
    {
        return Err(Error::InconsistentExecutionResult(
            format!("consensus_data_hash mismatch: old={}, new={}", 
                    old_ledger_info.consensus_data_hash(),
                    new_ledger_info.consensus_data_hash()),
            String::new(),
        ));
    }

    if !old_ledger_info
        .commit_info()
        .match_ordered_only(new_ledger_info.commit_info())
    {
        return Err(Error::InconsistentExecutionResult(
            old_ledger_info.commit_info().to_string(),
            new_ledger_info.commit_info().to_string(),
        ));
    }

    // ... rest of function
}
```

Additionally, add authentication/authorization to the remote safety rules service or ensure it's only accessible via secure internal networks.

## Proof of Concept

```rust
#[test]
fn test_consensus_data_hash_mismatch_vulnerability() {
    use aptos_consensus_types::block::Block;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::AggregateSignature,
    };
    use aptos_crypto::HashValue;
    
    // Create a valid BlockInfo
    let block_info = BlockInfo::new(
        1,  // epoch
        10, // round
        HashValue::random(),
        HashValue::random(),
        100,
        1234567890,
        None,
    );
    
    // Create two LedgerInfos with SAME BlockInfo but DIFFERENT consensus_data_hash
    let ledger_info_1 = LedgerInfo::new(
        block_info.clone(),
        HashValue::zero(),  // consensus_data_hash_1
    );
    
    let ledger_info_2 = LedgerInfo::new(
        block_info.clone(),
        HashValue::random(), // consensus_data_hash_2 (DIFFERENT!)
    );
    
    // Create old_ledger_info with signatures (simulating valid 2f+1 signatures)
    let old_ledger_info = LedgerInfoWithSignatures::new(
        ledger_info_1,
        AggregateSignature::empty(), // In real attack, would have valid signatures
    );
    
    // The vulnerability: sign_commit_vote should reject this because
    // consensus_data_hash differs, but currently it doesn't check
    
    // Expected: Error due to consensus_data_hash mismatch
    // Actual: Would succeed (validation gap)
    assert!(
        old_ledger_info.ledger_info().commit_info() == &block_info,
        "BlockInfo should match"
    );
    assert!(
        old_ledger_info.ledger_info().consensus_data_hash() != ledger_info_2.consensus_data_hash(),
        "consensus_data_hash should differ - this is the vulnerability"
    );
}
```

## Notes

While this validation gap exists in the code, practical exploitation requires specific conditions (Process mode deployment with network exposure). The issue represents a defense-in-depth failure where safety-critical validation is incomplete. Even if not immediately exploitable in all deployments, such validation gaps should be closed to prevent future exploitation vectors and maintain robust consensus safety guarantees.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L27-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** consensus/src/persistent_liveness_storage.rs (L244-250)
```rust
        let (root_ordered_cert, root_commit_cert) = if order_vote_enabled {
            // We are setting ordered_root same as commit_root. As every committed block is also ordered, this is fine.
            // As the block store inserts all the fetched blocks and quorum certs and execute the blocks, the block store
            // updates highest_ordered_cert accordingly.
            let root_ordered_cert =
                WrappedLedgerInfo::new(VoteData::dummy(), latest_ledger_info_sig.clone());
            (root_ordered_cert.clone(), root_ordered_cert)
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-54)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}

fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L25-38)
```rust
fn generate_commit_ledger_info(
    commit_info: &BlockInfo,
    ordered_proof: &LedgerInfoWithSignatures,
    order_vote_enabled: bool,
) -> LedgerInfo {
    LedgerInfo::new(
        commit_info.clone(),
        if order_vote_enabled {
            HashValue::zero()
        } else {
            ordered_proof.ledger_info().consensus_data_hash()
        },
    )
}
```
