# Audit Report

## Title
Event Storage Fees Missing in V2 Pricing - Potential Validator Disk Space Pressure

## Summary
In DiskSpacePricing V2 (active when gas_feature_version >= 13 and refundable_bytes feature is enabled), events are charged only IO gas but zero persistent storage fees, failing to properly account for the cost of storing event data on validator nodes. This allows attackers to emit large volumes of events at significantly reduced cost compared to state writes, potentially causing disk space pressure and I/O performance degradation on validators.

## Finding Description

The Aptos gas metering system has two pricing models for storage operations: V1 and V2. In V2 pricing, the `legacy_storage_fee_per_event` function explicitly returns zero, meaning events incur no long-term storage fees. [1](#0-0) 

When processing storage fees for all operations in a transaction, events in V2 pricing only pay IO gas (charged per byte for immediate write operations) but no persistent storage fees: [2](#0-1) 

Events are stored persistently in the database using BCS serialization of the full ContractEvent structure (including TypeTag, event data, and metadata): [3](#0-2) 

The event write native function charges based on abstract value size, which represents in-memory Move value size, not the full serialized storage size: [4](#0-3) 

An attacker can exploit this by:
1. Crafting transactions that emit the maximum allowed events (10MB per transaction)
2. Paying only IO gas (~89 internal gas per byte) without storage fees
3. Forcing validators to store this data until pruning occurs (default 90M versions ≈ days to weeks of retention)

The ChangeSetConfigs validation only checks `event.event_data().len()`, not the full serialized size including TypeTag overhead: [5](#0-4) 

This breaks the "Resource Limits" invariant: operations should properly account for gas, storage, and computational costs.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria:
- **Validator node slowdowns**: Sustained event spam can cause disk I/O pressure and performance degradation
- **Significant protocol violation**: The pricing model fails to properly charge for persistent storage resources

Cost calculation:
- 10MB events per transaction: ~930M internal gas (930 external gas units)
- At minimum gas price (100 octas/gas): 93,000 octas = 0.00093 APT
- To force 1TB of validator disk usage: ~100,000 transactions ≈ 93 APT
- Compare to state writes which pay both IO gas AND storage fees

While events are eventually pruned (default window: 90M versions), during the retention period validators must:
- Store the full event data on disk
- Maintain database indices (EventSchema, EventByKeySchema, EventByVersionSchema)
- Service queries for this data

## Likelihood Explanation

**Likelihood: Medium to High**

Factors enabling exploitation:
- Any unprivileged user can submit transactions with events
- V2 pricing may be active on current networks (depends on gas_feature_version and feature flags)
- Transaction throughput limits provide natural rate limiting but don't prevent sustained attacks
- Cost is significantly lower than equivalent state writes

Factors reducing likelihood:
- Events are pruned after the prune window (not stored forever)
- IO gas still provides some cost barrier
- Network throughput limits cap maximum damage rate
- Requires sustained transaction volume to cause meaningful impact

## Recommendation

**Fix Option 1: Add storage fees for events in V2 pricing**
Modify `legacy_storage_fee_per_event` to charge appropriate storage fees even in V2, or introduce a new non-legacy storage fee for events that accounts for the full serialized size and retention period.

**Fix Option 2: Include TypeTag in size validation**
Update the ChangeSetConfigs check to validate `event.size()` instead of just `event.event_data().len()` to account for TypeTag overhead:

```rust
// In change_set_configs.rs
for event in change_set.events_iter() {
    let size = event.size() as u64; // Changed from event.event_data().len()
    if size > self.max_bytes_per_event {
        return storage_write_limit_reached(None);
    }
    total_event_size += size;
    // ... rest of validation
}
```

**Fix Option 3: Adjust IO gas parameters**
Increase `storage_io_per_event_byte_write` to better reflect the true cost of storing and maintaining event data through the pruning window. [6](#0-5) 

## Proof of Concept

```rust
// Move module to demonstrate event spam
module attacker::event_spam {
    use std::vector;
    use aptos_framework::event;
    
    struct LargeEvent has drop, store {
        data: vector<u8>,
    }
    
    public entry fun spam_events(account: &signer) {
        let i = 0;
        // Emit multiple large events up to transaction limit
        while (i < 10) {
            let large_data = vector::empty<u8>();
            let j = 0;
            // Create ~1MB event data
            while (j < 1048576) {
                vector::push_back(&mut large_data, (j % 256) as u8);
                j = j + 1;
            };
            
            event::emit(LargeEvent { data: large_data });
            i = i + 1;
        };
    }
}
```

**Expected behavior**: Transaction succeeds, emitting 10MB of event data while paying only IO gas (~0.001 APT) and no persistent storage fees in V2 pricing.

**Impact**: Repeated execution forces validators to store 10MB per transaction on disk until pruning, at cost significantly below equivalent state writes.

## Notes

- Actual exploitability depends on whether V2 pricing is enabled on the target network
- Default pruning configuration provides eventual cleanup but creates temporary storage pressure
- The vulnerability represents an economic underpricing issue rather than a critical safety violation
- Validators with inadequate disk provisioning could experience more severe impacts

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L58-69)
```rust
    pub fn legacy_storage_fee_per_event(
        &self,
        params: &TransactionGasParameters,
        event: &ContractEvent,
    ) -> Fee {
        match self {
            Self::V1 => {
                NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
            },
            Self::V2 => 0.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L195-203)
```rust
        // Events (no event fee in v2)
        let event_fee = change_set.events_iter().fold(Fee::new(0), |acc, event| {
            acc + pricing.legacy_storage_fee_per_event(params, event)
        });
        let event_discount = pricing.legacy_storage_discount_for_events(params, event_fee);
        let event_net_fee = event_fee
            .checked_sub(event_discount)
            .expect("event discount should always be less than or equal to total amount");

```

**File:** storage/aptosdb/src/schema/event/mod.rs (L49-57)
```rust
impl ValueCodec<EventSchema> for ContractEvent {
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
}
```

**File:** aptos-move/framework/src/natives/event.rs (L116-119)
```rust
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L133-136)
```rust
            storage_io_per_event_byte_write: InternalGasPerByte,
            { RELEASE_V1_11.. => "storage_io_per_event_byte_write" },
            89,
        ],
```
