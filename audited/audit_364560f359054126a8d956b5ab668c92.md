# Audit Report

## Title
State Bloat via Forced Primary Fungible Store Creation (Griefing Attack)

## Summary
Attackers can create permanent state bloat by deploying numerous custom coin types and sending dust amounts to victim accounts, forcing automatic creation of primary fungible stores that cannot be deleted by victims. This attack vector exploits the automatic store creation mechanism and the inability to clean up zero-balance stores.

## Finding Description

The Aptos framework has migrated from the deprecated `CoinStore` structure to a fungible asset system using primary stores. When fungible assets are deposited to an account, the system automatically creates a primary store via `primary_fungible_store::ensure_primary_store_exists`. [1](#0-0) 

The critical issue is that primary stores are created WITHOUT a `DeleteRef`, making them permanent: [2](#0-1) 

The `fungible_asset::remove_store` function requires a `DeleteRef` to delete stores: [3](#0-2) 

**Attack Path:**

1. Attacker deploys multiple Move modules, each containing a unique `CoinType` struct
2. Attacker calls `coin::initialize<CoinType>` for each coin type, creating `CoinInfo` resources
3. Attacker mints minimal amounts (e.g., 1 unit) of each coin type
4. Attacker sends these tiny amounts to victim addresses via `coin::transfer` or `primary_fungible_store::deposit`
5. Each deposit triggers automatic primary store creation for that (victim, coin_type) pair
6. Victim accounts accumulate hundreds/thousands of permanent primary stores with dust balances
7. These stores cannot be deleted even when balances reach zero

**State Bloat Mechanism:**

The deposit flow automatically creates stores: [4](#0-3) 

Each `FungibleStore` resource consumes permanent state storage: [5](#0-4) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Concrete Impact:**

1. **Validator Performance Degradation**: All validators must store and sync these permanent resources, increasing state size and sync times for new nodes
2. **Victim Account Bloat**: Accounts accumulate unbounded numbers of stores they cannot delete
3. **Database Growth**: AptosDB StateKV storage grows permanently as state is never pruned (pruning only removes historical versions, not current state)
4. **API/Query Performance**: Accounts with thousands of stores will experience degraded performance when querying resources

The state pruner only removes historical state versions, not current live resources: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is **feasible** but **expensive**:

- Module deployment costs gas but has no hard limits on number of modules per account
- Each coin initialization incurs storage fees
- Each transfer incurs gas and storage creation fees

However, the attack is economically viable because:
- Attacker can spread costs across many transactions
- A single attacker can target many victims
- The cost is one-time upfront, but state bloat persists indefinitely
- No per-account resource limits exist to prevent accumulation

The maximum transaction size is bounded but doesn't prevent the attack: [7](#0-6) 

## Recommendation

**Short-term Mitigation:**

1. Implement a `burn_empty_store` function that allows users to delete primary stores with zero balance
2. Add rate limiting on new coin type creation per account
3. Implement minimum balance requirements for store creation (e.g., refuse deposits below threshold)

**Long-term Solution:**

Add a `generate_delete_ref()` call during primary store creation and store the `DeleteRef` in a retrievable location:

```move
public fun create_primary_store<T: key>(
    owner_addr: address,
    metadata: Object<T>,
): Object<FungibleStore> acquires DeriveRefPod {
    let metadata_addr = metadata.object_address();
    object::address_to_object<Metadata>(metadata_addr);
    let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;
    let constructor_ref = &object::create_user_derived_object(owner_addr, derive_ref);
    let transfer_ref = &constructor_ref.generate_transfer_ref();
    transfer_ref.disable_ungated_transfer();
    
    // ADD: Generate delete ref for cleanup capability
    let delete_ref = constructor_ref.generate_delete_ref();
    // Store delete_ref in a resource the owner can access
    
    fungible_asset::create_store(constructor_ref, metadata)
}
```

Then add:

```move
public entry fun remove_empty_primary_store<T: key>(
    owner: &signer,
    metadata: Object<T>
) acquires DeleteRefStorage {
    let store = primary_store(signer::address_of(owner), metadata);
    assert!(balance(signer::address_of(owner), metadata) == 0, EBALANCE_NOT_ZERO);
    let delete_ref = retrieve_delete_ref(owner, store);
    fungible_asset::remove_store(&delete_ref);
}
```

## Proof of Concept

```move
#[test_only]
module test_addr::griefing_attack {
    use aptos_framework::coin::{Self, MintCapability};
    use aptos_framework::primary_fungible_store;
    use std::signer;
    use std::string;

    // Define 100 different coin types
    struct CoinType1 {}
    struct CoinType2 {}
    // ... CoinType3 through CoinType100
    
    #[test(attacker = @0xBAD, victim = @0x123, aptos_framework = @aptos_framework)]
    fun test_state_bloat_attack(
        attacker: &signer,
        victim: &signer, 
        aptos_framework: &signer
    ) {
        // Setup framework
        coin::create_coin_conversion_map(aptos_framework);
        
        let victim_addr = signer::address_of(victim);
        
        // Attacker creates 100 different coin types
        let (burn1, _, mint1) = coin::initialize<CoinType1>(
            attacker,
            string::utf8(b"Coin1"),
            string::utf8(b"C1"),
            8,
            false
        );
        
        // Mint and send tiny amount to victim
        let coin1 = coin::mint(1, &mint1);
        coin::deposit(victim_addr, coin1);
        
        // Repeat for CoinType2...CoinType100
        // Each creates a permanent primary store on victim's account
        
        // Victim now has 100 primary stores
        // Victim cannot delete these stores even though balances are minimal
        // All validators must store this state permanently
        
        coin::destroy_mint_cap(mint1);
        coin::destroy_burn_cap(burn1);
    }
}
```

**Execution demonstrates:**
- Victim accumulates multiple permanent stores
- Each store consumes state storage across all validators
- Stores cannot be removed by victim
- Attack scales with number of coin types and victims

## Notes

This vulnerability is a **griefing attack** rather than a direct fund theft. The economic costs bound the attack's scale but do not prevent a sufficiently motivated attacker from causing significant state bloat. The lack of cleanup mechanisms for empty stores is the root cause, violating the **Resource Limits** invariant (#9) which states "All operations must respect gas, storage, and computational limits." While gas limits are respected per transaction, there is no global limit preventing unbounded state accumulation across transactions.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L62-72)
```text
    public fun ensure_primary_store_exists<T: key>(
        owner: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let store_addr = primary_store_address(owner, metadata);
        if (fungible_asset::store_exists(store_addr)) {
            object::address_to_object(store_addr)
        } else {
            create_primary_store(owner, metadata)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L75-88)
```text
    public fun create_primary_store<T: key>(
        owner_addr: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let metadata_addr = metadata.object_address();
        object::address_to_object<Metadata>(metadata_addr);
        let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;
        let constructor_ref = &object::create_user_derived_object(owner_addr, derive_ref);
        // Disable ungated transfer as deterministic stores shouldn't be transferrable.
        let transfer_ref = &constructor_ref.generate_transfer_ref();
        transfer_ref.disable_ungated_transfer();

        fungible_asset::create_store(constructor_ref, metadata)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L880-903)
```text
    public fun create_store<T: key>(
        constructor_ref: &ConstructorRef, metadata: Object<T>
    ): Object<FungibleStore> {
        let store_obj = &constructor_ref.generate_signer();
        move_to(
            store_obj,
            FungibleStore { metadata: metadata.convert(), balance: 0, frozen: false }
        );

        if (is_untransferable(metadata)) {
            constructor_ref.set_untransferable();
        };

        if (default_to_concurrent_fungible_balance()) {
            move_to(
                store_obj,
                ConcurrentFungibleBalance {
                    balance: aggregator_v2::create_unbounded_aggregator()
                }
            );
        };

        constructor_ref.object_from_constructor_ref<FungibleStore>()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L905-936)
```text
    /// Used to delete a store.  Requires the store to be completely empty prior to removing it
    public fun remove_store(
        delete_ref: &DeleteRef
    ) acquires FungibleStore, FungibleAssetEvents, ConcurrentFungibleBalance {
        let store = delete_ref.object_from_delete_ref<FungibleStore>();
        let addr = store.object_address();
        let FungibleStore { metadata, balance, frozen: _ } =
            move_from<FungibleStore>(addr);
        assert!(balance == 0, error::permission_denied(EBALANCE_IS_NOT_ZERO));

        if (concurrent_fungible_balance_exists_inline(addr)) {
            let ConcurrentFungibleBalance { balance } =
                move_from<ConcurrentFungibleBalance>(addr);
            assert!(balance.read() == 0, error::permission_denied(EBALANCE_IS_NOT_ZERO));
        };

        // Cleanup deprecated event handles if exist.
        if (exists<FungibleAssetEvents>(addr)) {
            let FungibleAssetEvents { deposit_events, withdraw_events, frozen_events } =
                move_from<FungibleAssetEvents>(addr);
            event::destroy_handle(deposit_events);
            event::destroy_handle(withdraw_events);
            event::destroy_handle(frozen_events);
        };
        event::emit(
            FungibleStoreDeletion {
                store: addr,
                owner: store.owner(),
                metadata: metadata.object_address()
            }
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L914-918)
```text
    public fun deposit<CoinType>(
        account_addr: address, coin: Coin<CoinType>
    ) acquires CoinConversionMap, CoinInfo {
        primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/mod.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```

**File:** crates/aptos/src/move_tool/mod.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
