# Audit Report

## Title
Unbounded Range Query DoS in Backup Service Transaction Endpoint

## Summary
The backup service's `/transactions/<start_version>/<num_transactions>` endpoint accepts an unbounded `num_transactions` parameter without validation, allowing attackers with network access to the backup service to request billions of versions, causing excessive database I/O and node resource exhaustion.

## Finding Description

The backup service exposes an HTTP endpoint that allows querying transaction data by version range. This endpoint lacks input validation on the range size, bypassing the `MAX_REQUEST_LIMIT` protection that exists in public-facing APIs.

**Vulnerable Code Path:**

The backup service handler accepts unbounded range requests: [1](#0-0) 

This calls the backup handler without limit validation: [2](#0-1) 

The event iterator is created with the full requested range, scanning the database for every version: [3](#0-2) 

**Bypass of Protection:**

While the public-facing `DbReader::get_events_iterator()` enforces a limit check: [4](#0-3) 

The limit is defined as: [5](#0-4) 

The backup service bypasses this by calling internal database methods directly.

**Deployment Context:**

By design, the backup service should be localhost-only: [6](#0-5) 

However, production fullnode deployments bind to all interfaces: [7](#0-6) 

And a Kubernetes service exposes the port: [8](#0-7) 

The service has no authentication or authorization layer, relying solely on network-level access control.

## Impact Explanation

This vulnerability enables a Denial of Service attack against validator nodes:

1. **High Severity - Validator Node Slowdowns**: An attacker requesting ranges of billions of versions forces the database to perform extensive I/O operations, degrading node performance and consensus participation.

2. **Potential API Crashes**: Resource exhaustion from excessive database scanning can lead to node instability or crashes.

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

The attack requires network access to port 6186. While this is typically restricted to localhost or cluster-internal by default, the production configuration binding to `0.0.0.0:6186` indicates scenarios where backup services may be network-accessible (e.g., for distributed backup operations, misconfiguration, or cluster-internal attacks).

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Attack Complexity**: Trivial - single HTTP GET request
2. **Attacker Requirements**: Network access to backup service port 6186
3. **Deployment Scenarios**:
   - **High risk**: Operators exposing backup service externally for backup infrastructure
   - **Medium risk**: Compromised services within Kubernetes cluster
   - **Low risk**: Strict localhost-only deployments

The production helm configuration using `0.0.0.0:6186` suggests network accessibility is an intended use case, increasing likelihood.

## Recommendation

**Immediate Fix**: Add `MAX_REQUEST_LIMIT` validation to backup service endpoints.

In `storage/aptosdb/src/backup/backup_handler.rs`, add limit validation:

```rust
pub fn get_transaction_iter(
    &self,
    start_version: Version,
    num_transactions: usize,
) -> Result<...> {
    // Add limit check
    if num_transactions > MAX_REQUEST_LIMIT as usize {
        return Err(AptosDbError::TooManyRequested(
            num_transactions as u64, 
            MAX_REQUEST_LIMIT
        ));
    }
    
    // existing code...
}
```

**Long-term Solutions**:
1. Implement authentication/authorization for backup service
2. Add rate limiting per client
3. Enforce strict network policies (localhost or authenticated cluster-internal only)
4. Add monitoring/alerting for large range queries
5. Consider paginated backup endpoints with mandatory smaller chunk sizes

## Proof of Concept

```bash
#!/bin/bash
# PoC: DoS attack via unbounded backup service query

BACKUP_SERVICE_URL="http://<node-ip>:6186"

# Request 10 billion transaction versions
# This will cause the database to scan billions of keys
curl -v "${BACKUP_SERVICE_URL}/transactions/0/10000000000" \
  --output /dev/null \
  --max-time 300

# Monitor node metrics during attack:
# - Database I/O bandwidth saturation
# - Node API response time degradation  
# - Consensus participation delays
```

**Expected Behavior**: Node experiences significant I/O load as the database iterator scans through billions of version keys, leading to performance degradation affecting consensus and API responsiveness.

**Notes:**
- Attack requires network access to port 6186
- Default configuration restricts to localhost (127.0.0.1:6186)
- Production fullnode deployments may expose to cluster network (0.0.0.0:6186)
- No authentication layer protects the endpoint
- Severity depends on actual deployment network exposure

### Citations

**File:** storage/backup/backup-service/src/handlers/mod.rs (L101-110)
```rust
    // GET transactions/<start_version>/<num_transactions>
    let bh = backup_handler.clone();
    let transactions = warp::path!(Version / usize)
        .map(move |start_version, num_transactions| {
            reply_with_bytes_sender(&bh, TRANSACTIONS, move |bh, sender| {
                bh.get_transaction_iter(start_version, num_transactions)?
                    .try_for_each(|record_res| sender.send_size_prefixed_bcs_bytes(record_res?))
            })
        })
        .recover(handle_rejection);
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L41-67)
```rust
    pub fn get_transaction_iter(
        &self,
        start_version: Version,
        num_transactions: usize,
    ) -> Result<
        impl Iterator<
                Item = Result<(
                    Transaction,
                    PersistedAuxiliaryInfo,
                    TransactionInfo,
                    Vec<ContractEvent>,
                    WriteSet,
                )>,
            > + '_,
    > {
        let txn_iter = self
            .ledger_db
            .transaction_db()
            .get_transaction_iter(start_version, num_transactions)?;
        let mut txn_info_iter = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_iter(start_version, num_transactions)?;
        let mut event_vec_iter = self
            .ledger_db
            .event_db()
            .get_events_by_version_iter(start_version, num_transactions)?;
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L100-115)
```rust
    pub(crate) fn get_events_by_version_iter(
        &self,
        start_version: Version,
        num_versions: usize,
    ) -> Result<EventsByVersionIter<'_>> {
        let mut iter = self.db.iter::<EventSchema>()?;
        iter.seek(&start_version)?;

        Ok(EventsByVersionIter::new(
            iter,
            start_version,
            start_version.checked_add(num_versions as u64).ok_or(
                AptosDbError::TooManyRequested(num_versions as u64, Version::MAX),
            )?,
        ))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L511-517)
```rust
    fn get_events_iterator(
        &self,
        start_version: Version,
        limit: u64,
    ) -> Result<Box<dyn Iterator<Item = Result<Vec<ContractEvent>>> + '_>> {
        gauged_api("get_events_iterator", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
```

**File:** storage/storage-interface/src/lib.rs (L56-58)
```rust
// This is last line of defense against large queries slipping through external facing interfaces,
// like the API and State Sync, etc.
pub const MAX_REQUEST_LIMIT: u64 = 20_000;
```

**File:** storage/README.md (L64-66)
```markdown
  # Address the backup service listens on. By default the port is open to only
  # the localhost, so the backup cli tool can only access data in the same host.
  backup_service_address: "127.0.0.1:6186"
```

**File:** terraform/helm/fullnode/files/fullnode-base.yaml (L67-68)
```yaml
storage:
  backup_service_address: "0.0.0.0:6186"
```

**File:** terraform/helm/fullnode/templates/service.yaml (L52-54)
```yaml
  ports:
  - name: backup
    port: 6186
```
