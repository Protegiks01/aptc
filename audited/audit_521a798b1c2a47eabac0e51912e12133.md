# Audit Report

## Title
DKG Sessions Complete with Outdated Security Parameters When Randomness Config Changes Between Epochs

## Summary
When the randomness configuration is changed via governance during an epoch, in-flight DKG (Distributed Key Generation) sessions can complete using the old security parameters. The completed DKG session is then used in the next epoch without validating that its security parameters match the current configuration, allowing randomness to operate with weaker (or incorrect) security guarantees than intended.

## Finding Description

The vulnerability exists in the epoch transition logic where DKG sessions capture randomness configuration at session start but are not invalidated when the configuration changes.

**Attack Flow:**

1. **DKG Session Initialization (Epoch N):** When a DKG session starts, it captures the current randomness configuration into `DKGSessionMetadata`: [1](#0-0) 

The `randomness_config::current()` captures the active configuration including secrecy and reconstruction thresholds into the session metadata: [2](#0-1) 

2. **Configuration Change (During Epoch N):** Governance changes the randomness configuration for increased security: [3](#0-2) 

The new configuration is buffered but the in-flight DKG session continues with the old configuration captured in its metadata.

3. **DKG Session Completion (Still Epoch N):** Before the epoch transition, validators complete the DKG session. The validator transaction processing validates the transcript against parameters derived from the in-progress session's metadata: [4](#0-3) 

The public parameters are constructed from the **old** configuration stored in the session metadata, and the completed session is stored: [5](#0-4) 

4. **Epoch Transition (Epoch N → N+1):** During reconfiguration, the incomplete session clearing only affects `in_progress`, not `last_completed`: [6](#0-5) 

The new configuration is applied: [7](#0-6) 

5. **Vulnerability Trigger (Epoch N+1):** When setting up randomness for the new epoch, the system retrieves the completed DKG session and validates only the epoch number, **not the configuration parameters**: [8](#0-7) 

The public parameters are then derived from the metadata containing the **old** security parameters: [9](#0-8) 

**Security Invariant Broken:**

The system violates the randomness security guarantee that validator subsets with voting power ≤ `secrecy_threshold` cannot reconstruct randomness. If governance increases the threshold from 33% to 50% but a DKG session completes with 33%, then validator coalitions with 34-49% voting power can break randomness in epoch N+1 despite the active configuration requiring 50%.

## Impact Explanation

**Severity: HIGH** (Significant Protocol Violation)

This vulnerability allows randomness security parameters to be bypassed, violating the cryptographic correctness invariant. The impact manifests in two scenarios:

1. **Security Downgrade (More Critical):** When governance increases security parameters (e.g., secrecy_threshold from 33% to 50%), the next epoch operates with the weaker old threshold. Validator coalitions with voting power between the old and new thresholds can break randomness security.

2. **Availability Impact:** When governance decreases thresholds (e.g., from 50% to 33%), the next epoch operates with the stronger old threshold. Validator subsets that should be able to reconstruct randomness (power >33% but <50%) cannot, potentially causing randomness generation failures.

This meets the **High Severity** criteria per Aptos bug bounty: "Significant protocol violations" that compromise randomness security guarantees without requiring a hardfork to fix.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability triggers automatically when:
1. Governance proposes a randomness configuration change (legitimate operation)
2. The proposal passes and is executed during an epoch
3. A DKG session is in progress or completes before the epoch transition

Given that:
- Randomness configuration changes are legitimate governance operations expected to occur
- DKG sessions run continuously for each epoch transition
- The window for this race condition spans the entire epoch duration
- No validation prevents the mismatch

The vulnerability will occur naturally whenever governance updates randomness parameters, making it a systematic issue rather than an edge case.

## Recommendation

Add validation in `try_get_rand_config_for_new_epoch` to verify that the completed DKG session's randomness configuration matches the current active configuration:

```rust
fn try_get_rand_config_for_new_epoch(
    &self,
    consensus_key: Arc<PrivateKey>,
    new_epoch_state: &EpochState,
    onchain_randomness_config: &OnChainRandomnessConfig,
    maybe_dkg_state: anyhow::Result<DKGState>,
    consensus_config: &OnChainConsensusConfig,
) -> Result<(RandConfig, Option<RandConfig>), NoRandomnessReason> {
    // ... existing validation ...
    
    if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
        return Err(NoRandomnessReason::CompletedSessionTooOld);
    }
    
    // NEW VALIDATION: Verify config matches
    let session_config = dkg_session.metadata.randomness_config_derived()
        .ok_or(NoRandomnessReason::InvalidSessionConfig)?;
    
    if !configs_match(&session_config, onchain_randomness_config) {
        return Err(NoRandomnessReason::ConfigMismatch);
    }
    
    // ... rest of function ...
}

fn configs_match(
    session_config: &OnChainRandomnessConfig,
    current_config: &OnChainRandomnessConfig
) -> bool {
    match (session_config, current_config) {
        (OnChainRandomnessConfig::Off, OnChainRandomnessConfig::Off) => true,
        (OnChainRandomnessConfig::V1(s), OnChainRandomnessConfig::V1(c)) => {
            s.secrecy_threshold() == c.secrecy_threshold() &&
            s.reconstruct_threshold() == c.reconstruct_threshold()
        },
        (OnChainRandomnessConfig::V2(s), OnChainRandomnessConfig::V2(c)) => {
            s.secrecy_threshold() == c.secrecy_threshold() &&
            s.reconstruct_threshold() == c.reconstruct_threshold() &&
            s.fast_path_secrecy_threshold() == c.fast_path_secrecy_threshold()
        },
        _ => false,
    }
}
```

Additionally, when a randomness configuration change is detected during `reconfiguration_with_dkg::finish()`, the system should clear the completed DKG session to force a new session with the updated parameters:

```move
public(friend) fun finish(framework: &signer) {
    system_addresses::assert_aptos_framework(framework);
    
    // If config is changing, clear both incomplete AND completed sessions
    if (config_buffer::does_exist<RandomnessConfig>()) {
        dkg::try_clear_all_sessions(framework);
    } else {
        dkg::try_clear_incomplete_session(framework);
    }
    
    // Apply configs...
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::dkg_config_mismatch_test {
    use aptos_framework::dkg;
    use aptos_framework::randomness_config;
    use aptos_framework::reconfiguration_with_dkg;
    use aptos_framework::timestamp;
    use aptos_std::fixed_point64;
    
    #[test(framework = @0x1)]
    fun test_dkg_completes_with_old_config(framework: signer) {
        // Setup: Initialize with config A (33% threshold)
        let config_a = randomness_config::new_v1(
            fixed_point64::create_from_rational(33, 100),
            fixed_point64::create_from_rational(67, 100)
        );
        randomness_config::initialize(&framework, config_a);
        
        // Start DKG session with config A
        let dealer_validators = vector[/* validator set */];
        let target_validators = vector[/* validator set */];
        dkg::start(0, config_a, dealer_validators, target_validators);
        
        // Change config to B (50% threshold) - governance action
        let config_b = randomness_config::new_v1(
            fixed_point64::create_from_rational(50, 100),
            fixed_point64::create_from_rational(67, 100)
        );
        randomness_config::set_for_next_epoch(&framework, config_b);
        
        // DKG completes with config A parameters
        let transcript = vector[/* completed transcript with 33% threshold */];
        dkg::finish(transcript);
        
        // Apply new config and start next epoch
        randomness_config::on_new_epoch(&framework);
        
        // BUG: The completed DKG session has 33% threshold
        // but the active config says 50% threshold
        let dkg_state = dkg::get_state();
        let completed_session = option::borrow(&dkg_state.last_completed);
        
        // This shows the mismatch:
        // completed_session.metadata.randomness_config has 33% threshold
        // but randomness_config::current() returns 50% threshold
        assert!(
            completed_session.metadata.randomness_config.secrecy_threshold !=
            randomness_config::current().secrecy_threshold,
            1
        );
    }
}
```

## Notes

This vulnerability demonstrates a critical gap in the epoch transition validation logic where security parameter changes are not synchronized with in-flight DKG sessions. The issue is systematic rather than requiring attacker action - it occurs automatically whenever governance legitimately updates randomness configuration during normal operation. The fix requires validating configuration consistency at epoch boundaries and potentially forcing new DKG sessions when parameters change.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L34-39)
```text
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L68-73)
```text
        let new_session_metadata = DKGSessionMetadata {
            dealer_epoch,
            randomness_config,
            dealer_validator_set,
            target_validator_set,
        };
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L90-96)
```text
    public(friend) fun finish(transcript: vector<u8>) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        assert!(option::is_some(&dkg_state.in_progress), error::invalid_state(EDKG_NOT_IN_PROGRESS));
        let session = option::extract(&mut dkg_state.in_progress);
        session.transcript = transcript;
        dkg_state.last_completed = option::some(session);
        dkg_state.in_progress = option::none();
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L100-106)
```text
    public fun try_clear_incomplete_session(fx: &signer) acquires DKGState {
        system_addresses::assert_aptos_framework(fx);
        if (exists<DKGState>(@aptos_framework)) {
            let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
            dkg_state.in_progress = option::none();
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L53-56)
```text
    public fun set_for_next_epoch(framework: &signer, new_config: RandomnessConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(new_config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L59-68)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires RandomnessConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<RandomnessConfig>()) {
            let new_config = config_buffer::extract_v2<RandomnessConfig>();
            if (exists<RandomnessConfig>(@aptos_framework)) {
                *borrow_global_mut<RandomnessConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            }
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L105-112)
```rust
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** consensus/src/epoch_manager.rs (L1040-1046)
```rust
        let dkg_session = dkg_state
            .last_completed
            .ok_or_else(|| NoRandomnessReason::DKGCompletedSessionResourceMissing)?;
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
        let dkg_pub_params = DefaultDKG::new_public_params(&dkg_session.metadata);
```

**File:** types/src/dkg/real_dkg/mod.rs (L199-224)
```rust
    fn new_public_params(dkg_session_metadata: &DKGSessionMetadata) -> RealDKGPublicParams {
        let randomness_config = dkg_session_metadata
            .randomness_config_derived()
            .unwrap_or_else(OnChainRandomnessConfig::default_enabled);
        let secrecy_threshold = randomness_config
            .secrecy_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_SECRECY_THRESHOLD);
        let reconstruct_threshold = randomness_config
            .reconstruct_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_RECONSTRUCT_THRESHOLD);
        let maybe_fast_path_secrecy_threshold = randomness_config.fast_path_secrecy_threshold();

        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
        let verifier = ValidatorVerifier::new(dkg_session_metadata.dealer_consensus_infos_cloned());
        RealDKGPublicParams {
            session_metadata: dkg_session_metadata.clone(),
            pvss_config,
            verifier: verifier.into(),
        }
    }
```
