# Audit Report

## Title
Node Checker Transaction Correctness Validation Bypass via API Spoofing - Missing Cryptographic Proof Verification

## Summary
The node checker's transaction correctness validation can be completely bypassed by a malicious target node that spoofs the `get_transaction_by_version_bcs` API endpoint. The checker only compares `accumulator_root_hash` values between baseline and target without any cryptographic proof verification, allowing a malicious node to return fabricated transaction data with a forged hash that matches the baseline.

## Finding Description

The `TransactionCorrectnessChecker` is designed to verify that target nodes execute transactions correctly by comparing transaction data with a trusted baseline node. However, the implementation contains a critical security flaw. [1](#0-0) 

The checker calls `get_transaction_by_version_bcs()` which returns a `TransactionData` enum containing `TransactionOnChainData`: [2](#0-1) 

The critical issue is that `TransactionOnChainData` includes `accumulator_root_hash` as a plain field **without any cryptographic proof** that binds this hash to the transaction data. The validation logic only performs a simple comparison: [3](#0-2) 

**Attack Scenario:**

A malicious node operator can exploit this by:

1. **Direct API Proxying**: Modify their API server to proxy requests to the baseline node and return identical responses, making the node appear correct while actually executing transactions incorrectly in its local database.

2. **Selective Hash Forgery**: Execute transactions incorrectly (e.g., crediting wrong amounts, stealing funds) but store or return the correct `accumulator_root_hash` obtained from honest nodes during state sync. When the checker queries, return the incorrect transaction data with the correct hash.

3. **Database Manipulation**: Store incorrect execution results locally but maintain correct `accumulator_root_hash` values. The API endpoint constructs `TransactionOnChainData` from storage without verifying the cryptographic relationship between the transaction info and accumulator hash: [4](#0-3) [5](#0-4) 

The accumulator root hash is simply retrieved from the database with no verification: [6](#0-5) 

**Broken Invariant:**

This violates the "State Consistency: State transitions must be atomic and verifiable via Merkle proofs" invariant. The accumulator root hash should cryptographically commit to all transaction executions up to that version, but the checker doesn't verify this commitment.

**Contrast with Proper Verification:**

The codebase contains `TransactionWithProof` which includes cryptographic proofs and a `verify()` method: [7](#0-6) 

This verification ensures the transaction hash matches the proof and validates the accumulator proof chain to the ledger info. However, the node checker uses the BCS API endpoint which strips these proofs and returns only the plain data structure. [8](#0-7) 

## Impact Explanation

**Critical Severity** - This vulnerability allows complete bypass of transaction correctness validation:

1. **Consensus Safety Violation**: A malicious node can execute transactions with incorrect state transitions (wrong balances, unauthorized transfers) while appearing to pass validation checks. This breaks deterministic execution guarantees.

2. **Loss of Funds**: Validators or full nodes could steal funds by executing transactions incorrectly (e.g., crediting themselves instead of the intended recipient) while passing all node checker validations.

3. **Network Trust Breakdown**: The node checker is designed to ensure nodes are executing correctly. If it can be easily bypassed, malicious nodes can masquerade as legitimate, undermining the entire validation infrastructure.

4. **No Recovery Path**: Once incorrect execution is accepted as valid, there's no mechanism to detect or revert it without external auditing.

This meets the **Critical Severity** criteria for "Consensus/Safety violations" and potential "Loss of Funds" as defined in the Aptos bug bounty program.

## Likelihood Explanation

**High Likelihood:**

1. **Trivial to Exploit**: A malicious node operator only needs to modify their API server code to return forged data. No sophisticated cryptographic attacks or complex state manipulation required.

2. **Low Barrier to Entry**: Any node operator can implement this attack. No special privileges, stake requirements, or collusion needed.

3. **Difficult to Detect**: The forged responses appear identical to legitimate responses at the API level. Only deep inspection of actual transaction execution would reveal the fraud.

4. **Practical Attack Scenarios**:
   - Malicious validators trying to appear legitimate for rewards
   - Compromised full nodes serving incorrect data to light clients
   - Bad actors running node infrastructure services

## Recommendation

**Immediate Fix**: Implement cryptographic proof verification in the transaction correctness checker.

**Solution 1: Use State Sync Protocol** (Recommended)

Instead of using the public API, use the state-sync protocol which includes cryptographic proofs:

```rust
// In get_transaction_by_version, instead of calling the API:
// 1. Retrieve TransactionWithProof from baseline
// 2. Verify the proof against baseline's LedgerInfo
// 3. Retrieve TransactionWithProof from target  
// 4. Verify the proof against target's LedgerInfo
// 5. Compare the verified transaction data

async fn get_transaction_with_proof_and_verify(
    client: &AptosRestClient,
    version: u64,
    ledger_info: &LedgerInfo,
) -> Result<TransactionWithProof, CheckerError> {
    let txn_with_proof = client.get_transaction_with_proof(version).await?;
    
    // Cryptographically verify the proof
    txn_with_proof.verify(ledger_info)
        .map_err(|e| CheckerError::NonRetryableEndpointError(
            TRANSACTIONS_ENDPOINT,
            anyhow::Error::from(e).context("Proof verification failed")
        ))?;
    
    Ok(txn_with_proof)
}
```

**Solution 2: Add Proof Verification to API Response**

Modify the API endpoint to include proofs and verify them:

```rust
// In check() method:
let baseline_ledger_info = baseline_api_index_provider.get_ledger_info().await?;
let target_ledger_info = target_api_index_provider.get_ledger_info().await?;

let baseline_txn = Self::get_transaction_with_proof_and_verify(
    &baseline_client,
    middle_shared_version,
    &baseline_ledger_info,
).await?;

let target_txn = Self::get_transaction_with_proof_and_verify(
    &target_client,
    middle_shared_version,
    &target_ledger_info,
).await?;

// Now compare the verified transactions
if baseline_txn.transaction.hash() == target_txn.transaction.hash() &&
   baseline_txn.proof.transaction_info() == target_txn.proof.transaction_info() {
    // Verified match
}
```

**Additional Hardening:**

1. Compare full `TransactionInfo` including `state_root_hash`, not just `accumulator_root_hash`
2. Verify event root hashes match if events are present
3. Add rate limiting and anomaly detection for API responses
4. Log all validation failures for forensic analysis

## Proof of Concept

```rust
// Malicious API server that bypasses validation:
// File: malicious_node_api_spoof.rs

use actix_web::{web, App, HttpResponse, HttpServer};
use reqwest::Client;
use aptos_api_types::TransactionData;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/v1/transactions/by_version/{version}", 
                   web::get().to(spoof_transaction))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}

async fn spoof_transaction(version: web::Path<u64>) -> HttpResponse {
    // Attack Strategy 1: Direct Proxying
    // Simply forward the request to the baseline node
    let baseline_url = format!(
        "https://baseline-node.aptos.dev/v1/transactions/by_version/{}", 
        version
    );
    
    let client = Client::new();
    let response = client
        .get(&baseline_url)
        .header("Accept", "application/x-bcs")
        .send()
        .await
        .unwrap();
    
    // Return baseline's response as our own
    // The node checker cannot distinguish this from legitimate execution
    HttpResponse::Ok()
        .content_type("application/x-bcs")
        .body(response.bytes().await.unwrap())
}

// Alternative Attack Strategy 2: Selective Forgery
async fn spoof_with_forged_data(version: web::Path<u64>) -> HttpResponse {
    // 1. Execute transaction INCORRECTLY in local database
    //    (e.g., credit funds to attacker instead of intended recipient)
    
    // 2. Query baseline to get the correct accumulator_root_hash
    let correct_hash = query_baseline_for_hash(*version).await;
    
    // 3. Construct TransactionOnChainData with:
    //    - Our incorrectly executed transaction
    //    - The correct accumulator_root_hash from baseline
    let spoofed_data = TransactionData::OnChain(TransactionOnChainData {
        version: *version,
        transaction: get_our_incorrect_transaction(*version),
        info: get_our_incorrect_info(*version), // Wrong state_root_hash!
        events: vec![],
        accumulator_root_hash: correct_hash, // But correct accumulator hash!
        changes: Default::default(),
    });
    
    // 4. Serialize and return
    let bytes = bcs::to_bytes(&spoofed_data).unwrap();
    HttpResponse::Ok()
        .content_type("application/x-bcs")
        .body(bytes)
}

// The node checker will compare accumulator_root_hash values,
// find they match, and pass validation - despite completely
// different transaction execution results!
```

**Demonstration Steps:**

1. Set up two nodes: honest baseline and malicious target
2. Malicious target executes a transaction incorrectly (modifies state differently)
3. Malicious target modifies its API to return forged `accumulator_root_hash`
4. Run node checker against both nodes
5. Observe that validation passes despite incorrect execution

**Notes**

The vulnerability exists because the API endpoint strips cryptographic proofs from the response, reducing verification to simple field comparison. The `TransactionOnChainData` struct design treats `accumulator_root_hash` as an independent field rather than a cryptographically verified commitment, enabling trivial forgery. This is a fundamental architectural flaw in the node checker's trust model that assumes API responses are honest, when they should be cryptographically verified.

### Citations

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L34-52)
```rust
    async fn get_transaction_by_version(
        client: &AptosRestClient,
        version: u64,
        node_name: &str,
    ) -> Result<TransactionData, CheckerError> {
        Ok(client
            .get_transaction_by_version_bcs(version)
            .await
            .map_err(|e| {
                CheckerError::NonRetryableEndpointError(
                    TRANSACTIONS_ENDPOINT,
                    anyhow::Error::from(e).context(format!(
                        "The {} node API failed to return the requested transaction at version: {}",
                        node_name, version
                    )),
                )
            })?
            .into_inner())
    }
```

**File:** ecosystem/node-checker/src/checker/transaction_correctness.rs (L189-221)
```rust
            Ok(middle_target_transaction) => {
                match Self::unwrap_accumulator_root_hash(&middle_target_transaction) {
                    Ok(middle_target_accumulator_root_hash) => {
                        if middle_baseline_accumulator_root_hash
                            == middle_target_accumulator_root_hash
                        {
                            Self::build_result(
                                "Target node produced valid recent transaction".to_string(),
                                100,
                                format!(
                                    "We were able to pull the same transaction (version: {}) \
                                    from both your node and the baseline node. Great! This \
                                    implies that your node is returning valid transaction data.",
                                    middle_shared_version,
                                ),
                            )
                        } else {
                            Self::build_result(
                                "Target node produced recent transaction, but it was invalid"
                                    .to_string(),
                                0,
                                format!(
                                    "We were able to pull the same transaction (version: {}) \
                                    from both your node and the baseline node. However, the \
                                    transaction was invalid compared to the baseline as the \
                                    accumulator root hash of the transaction ({}) was different \
                                    compared to the baseline ({}).",
                                    middle_shared_version,
                                    middle_target_accumulator_root_hash,
                                    middle_baseline_accumulator_root_hash,
                                ),
                            )
                        }
```

**File:** api/types/src/transaction.rs (L98-115)
```rust
/// A committed transaction
///
/// This is a representation of the onchain payload, outputs, events, and proof of a transaction.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TransactionOnChainData {
    /// The ledger version of the transaction
    pub version: u64,
    /// The transaction submitted
    pub transaction: aptos_types::transaction::Transaction,
    /// Information about the transaction
    pub info: aptos_types::transaction::TransactionInfo,
    /// Events emitted by the transaction
    pub events: Vec<ContractEvent>,
    /// The accumulator root hash at this version
    pub accumulator_root_hash: aptos_crypto::HashValue,
    /// Final state of resources changed by the transaction
    pub changes: aptos_types::write_set::WriteSet,
}
```

**File:** api/src/context.rs (L1066-1068)
```rust
    pub fn get_accumulator_root_hash(&self, version: u64) -> Result<HashValue> {
        Ok(self.db.get_accumulator_root_hash(version)?)
    }
```

**File:** api/src/context.rs (L1070-1082)
```rust
    fn convert_into_transaction_on_chain_data(
        &self,
        txn: TransactionWithProof,
    ) -> Result<TransactionOnChainData> {
        // the type is Vec<(Transaction, TransactionOutput)> - given we have one transaction here, there should only ever be one value in this array
        let (_, txn_output) = &self
            .db
            .get_transaction_outputs(txn.version, 1, txn.version)?
            .consume_output_list_with_proof()
            .transactions_and_outputs[0];
        self.get_accumulator_root_hash(txn.version)
            .map(|h| (txn, h, txn_output).into())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L832-839)
```rust
    fn get_accumulator_root_hash(&self, version: Version) -> Result<HashValue> {
        gauged_api("get_accumulator_root_hash", || {
            self.error_if_ledger_pruned("Transaction accumulator", version)?;
            self.ledger_db
                .transaction_accumulator_db()
                .get_root_hash(version)
        })
    }
```

**File:** types/src/transaction/mod.rs (L1395-1439)
```rust
pub struct TransactionWithProof {
    pub version: Version,
    pub transaction: Transaction,
    pub events: Option<Vec<ContractEvent>>,
    pub proof: TransactionInfoWithProof,
}

impl TransactionWithProof {
    pub fn new(
        version: Version,
        transaction: Transaction,
        events: Option<Vec<ContractEvent>>,
        proof: TransactionInfoWithProof,
    ) -> Self {
        Self {
            version,
            transaction,
            events,
            proof,
        }
    }

    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        let txn_hash = self.transaction.hash();
        ensure!(
            txn_hash == self.proof.transaction_info().transaction_hash(),
            "Transaction hash ({}) not expected ({}).",
            txn_hash,
            self.proof.transaction_info().transaction_hash(),
        );

        if let Some(events) = &self.events {
            let event_hashes: Vec<_> = events.iter().map(CryptoHash::hash).collect();
            let event_root_hash =
                InMemoryEventAccumulator::from_leaves(&event_hashes[..]).root_hash();
            ensure!(
                event_root_hash == self.proof.transaction_info().event_root_hash(),
                "Event root hash ({}) not expected ({}).",
                event_root_hash,
                self.proof.transaction_info().event_root_hash(),
            );
        }

        self.proof.verify(ledger_info, self.version)
    }
```

**File:** api/src/transactions.rs (L1052-1057)
```rust
            AcceptType::Bcs => BasicResponse::try_from_bcs((
                transaction_data,
                ledger_info,
                BasicResponseStatus::Ok,
            )),
        }
```
