# Audit Report

## Title
Unverified Advertised Ledger Info Used in Waypoint Satisfiability Check Enables Bootstrapping DoS

## Summary
The `verify_waypoint_is_satisfiable()` function uses unverified advertised `LedgerInfoWithSignatures` data to determine if a node's waypoint can be satisfied. Malicious peers can advertise fake ledger infos with arbitrarily high versions without valid signatures, causing the waypoint check to pass incorrectly and potentially blocking node bootstrapping through repeated failed data requests.

## Finding Description

The state synchronization system collects `LedgerInfoWithSignatures` from peer advertisements without cryptographic validation. These unverified ledger infos are aggregated into a global summary and used in critical bootstrapping decisions.

**Attack Flow:**

1. **Unverified Data Collection**: When peers advertise their storage summaries, their `synced_ledger_info` is collected without signature verification: [1](#0-0) 

2. **Highest Selection Without Validation**: The `highest_synced_ledger_info()` function selects the ledger info with the maximum version using only `position_max()` on versions, with no signature verification: [2](#0-1) 

3. **Critical Usage in Waypoint Check**: The `verify_waypoint_is_satisfiable()` function uses this unverified highest ledger info to check if the waypoint can be satisfied, comparing only versions without validating signatures: [3](#0-2) 

4. **Slow Peer Penalization**: When malicious peers fail to provide data, the peer scoring system is too lenient. With a starting score of 50.0, "NotUseful" error multiplier of 0.95, and ignore threshold of 25.0, it requires approximately 14 consecutive failures to ignore a peer: [4](#0-3) 

5. **Limited Retry Before Stream Termination**: Streams retry failed requests only 5 times before terminating, leaving the malicious peer with a score of ~38.7 (still above the 25.0 ignore threshold): [5](#0-4) 

**Exploitation Scenario:**

A malicious peer advertises a `LedgerInfoWithSignatures` with version 1,000,000,000 but invalid/no signatures. When a bootstrapping node with waypoint at version 1,000 queries the network:
- The waypoint satisfiability check passes (1B > 1K)
- The node proceeds to fetch epoch ending ledger infos
- If the malicious peer is selected, requests fail or return invalid data
- After 5 failures, the stream terminates but the peer score is still ~38.7
- The bootstrapper restarts, recalculates the global summary with the same malicious data
- The cycle repeats, preventing bootstrapping progress

## Impact Explanation

This vulnerability represents a **High Severity** issue per the Aptos bug bounty criteria, causing validator node slowdowns and significant protocol violations:

- **Liveness Impact**: Bootstrapping nodes cannot make progress due to repeated failed synchronization attempts
- **Resource Waste**: Nodes waste network bandwidth and CPU cycles on invalid sync attempts
- **Network Disruption**: Multiple malicious peers can amplify the effect, significantly degrading network bootstrapping capabilities
- **Validator Impact**: New validators cannot join the network efficiently, affecting network decentralization

While not a permanent denial of service (the peer would eventually be ignored after ~14 failures across multiple retry cycles), the attack significantly impedes node bootstrapping and network growth.

## Likelihood Explanation

**High Likelihood:**
- **Low Attack Barrier**: Any peer can advertise arbitrary storage summaries without proof
- **No Cryptographic Verification**: The advertised ledger info is never validated before critical usage
- **Minimal Attacker Resources**: A single malicious peer node can execute the attack
- **Realistic Scenario**: Bootstrapping nodes are common during network growth or after outages
- **Amplification**: Multiple malicious peers increase attack effectiveness

The attack is trivial to execute and requires no special privileges or validator access.

## Recommendation

**Immediate Fix**: Validate `LedgerInfoWithSignatures` signatures before using advertised data in critical decisions.

**Implementation Approach:**

1. **Add signature verification in waypoint check**:
```rust
pub fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    // ... existing local storage check ...
    
    // Get highest advertised ledger info
    let highest_advertised_ledger_info = global_data_summary
        .advertised_data
        .highest_synced_ledger_info()
        .ok_or_else(|| Error::UnsatisfiableWaypoint(...))?;
    
    // NEW: Verify signatures before using
    self.latest_epoch_state
        .verify(&highest_advertised_ledger_info)
        .map_err(|error| {
            Error::VerificationError(format!(
                "Highest advertised ledger info failed signature verification: {:?}",
                error
            ))
        })?;
    
    // ... rest of function ...
}
```

2. **Filter unverified ledger infos during collection**: Modify `calculate_global_data_summary()` to only include ledger infos that can be verified against known epoch states: [1](#0-0) 

3. **Increase peer penalization**: Adjust the scoring multipliers to more aggressively penalize peers providing invalid data, reducing the number of failures needed to ignore a peer from ~14 to ~5-7.

4. **Add signature validation in stream target selection**: Update `select_target_ledger_info()` to verify signatures before selecting a sync target: [6](#0-5) 

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be integrated into the test suite

#[tokio::test]
async fn test_malicious_peer_blocks_bootstrapping() {
    // Setup: Create a bootstrapping node with waypoint at version 1000
    let waypoint = Waypoint::new_any(LedgerInfo::mock_genesis(Some(1000)));
    let mut bootstrapper = setup_bootstrapper_with_waypoint(waypoint);
    
    // Malicious peer advertises fake high-version ledger info
    let malicious_peer = PeerNetworkId::random();
    let fake_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                999999, // Fake high epoch
                0,
                HashValue::zero(),
                HashValue::zero(),
                1_000_000_000, // Fake high version
                0,
                None,
            ),
            HashValue::zero(),
        ),
        AggregateSignature::empty(), // No valid signatures!
    );
    
    // Add malicious peer's data to global summary
    peer_states.update_summary(
        malicious_peer,
        StorageServerSummary {
            data_summary: DataSummary {
                synced_ledger_info: Some(fake_ledger_info),
                ..DataSummary::empty()
            },
            ..StorageServerSummary::default()
        },
    );
    
    let global_summary = peer_states.calculate_global_data_summary();
    
    // Vulnerability: Waypoint check passes even though ledger info has no valid signatures
    assert!(bootstrapper.verify_waypoint_is_satisfiable(&global_summary).is_ok());
    
    // When attempting to bootstrap, requests to malicious peer fail repeatedly
    // After max_request_retry (5) failures, stream terminates but peer score is still ~38.7
    // Bootstrapping restarts with same malicious data â†’ DoS
    
    // Expected: Waypoint check should FAIL due to invalid signatures
    // Actual: Check PASSES, allowing bootstrapping to proceed with invalid target
}
```

**Notes:**
- The vulnerability violates the cryptographic correctness invariant that all verifiable data must be verified before use
- This breaks the security assumption that state sync decisions are based on cryptographically validated network state
- The fix requires minimal changes but significantly improves bootstrapping robustness against malicious peers

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-377)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L893-914)
```rust
        // Get the highest advertised synced ledger info version
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();

        // Compare the highest advertised version with our waypoint
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
```

**File:** config/src/config/state_sync_config.rs (L277-277)
```rust
            max_request_retry: 5,
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L522-534)
```rust
        // We don't have a final target, select the highest to make progress
        if let Some(highest_synced_ledger_info) = advertised_data.highest_synced_ledger_info() {
            let (next_request_version, _) = self.next_request_version_and_epoch;
            if next_request_version > highest_synced_ledger_info.ledger_info().version() {
                Ok(None) // We're already at the highest synced ledger info. There's no known target.
            } else {
                Ok(Some(highest_synced_ledger_info))
            }
        } else {
            Err(Error::DataIsUnavailable(
                "Unable to find the highest synced ledger info!".into(),
            ))
        }
```
