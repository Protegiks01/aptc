# Audit Report

## Title
Aptos Debugger Lacks Comprehensive Audit Logging Enabling Forensics-Resistant Information Disclosure

## Summary
The Aptos debugger tool performs security-sensitive operations (database queries, consensus data access, transaction decoding) without comprehensive audit logging. An attacker with node-level access can use the debugger to extract sensitive blockchain data without leaving a forensic trail, enabling information gathering and track-covering attacks.

## Finding Description

The Aptos debugger (`aptos-debugger`) is a CLI tool that provides direct access to sensitive blockchain data through four main command categories: database operations, transaction decoding, consensus data extraction, and Move transaction execution. While the main entry point initializes a logger at Level::Info, **none of the sensitive operations performed by the debugger are actually logged**. [1](#0-0) 

The debugger delegates to multiple subsystems, all of which lack audit logging:

**1. Database Debugger (`db_debugger`)**: Performs direct database queries without logging what data is accessed: [2](#0-1) 

The `print_raw_data_by_version` command queries transactions, write sets, events, and transaction info without any audit trail: [3](#0-2) 

**2. State Value Queries**: The `get_value` command queries state values by key and version, iterating through historical versions without logging: [4](#0-3) 

**3. Consensus Data Extraction**: The `dump_pending_txns` command extracts pending transactions from consensus and quorum store databases without logging: [5](#0-4) 

**4. Transaction Decoding**: The BCS transaction decoder reads transaction data, looks up versions, and can re-execute transactions without comprehensive logging: [6](#0-5) 

**5. Transaction Execution**: The `execute_past_transactions` command replays historical transactions without logging which transactions are accessed: [7](#0-6) 

**Attack Scenario:**
1. Attacker gains filesystem access to a validator node (compromised SSH credentials, insider threat, or privilege escalation)
2. Uses `aptos-debugger` to query specific accounts, transactions, or state data to identify high-value targets
3. Extracts consensus data or transaction information for reconnaissance
4. Redirects stdout to `/dev/null` or captures it without storing, leaving no trace
5. Post-incident forensic investigation cannot determine what data was accessed, when, or by whom

## Impact Explanation

This vulnerability falls under **Medium Severity** ($10,000 category) per the Aptos bug bounty program for the following reasons:

1. **Information Disclosure**: Enables unauthorized extraction of sensitive blockchain data including transaction details, account states, consensus information, and write sets.

2. **Forensics Evasion**: Violates security logging best practices by not maintaining an audit trail of security-sensitive operations. This prevents effective forensic investigation after a security incident.

3. **Insider Threat Facilitation**: Malicious node operators or administrators can extract data without detection, enabling abuse of privileged access.

4. **Attack Enablement**: Information gathered through unlogged debugger operations can facilitate more sophisticated attacks against the network or specific accounts.

While this does not directly cause consensus violations or fund theft, it represents a **state inconsistency** (lack of proper security state/logging) that requires intervention to address, fitting the Medium severity category: "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Medium to High**

**Prerequisites:**
- Attacker requires filesystem access to the node (read access to database directories)
- Debugger binary must be available (typically is on validator nodes)
- No additional privileges beyond filesystem access needed

**Likelihood Factors:**
- **Common Attack Path**: Node compromise through SSH, credential theft, or insider threats is a common attack vector
- **Easy to Execute**: Once access is gained, running debugger commands is trivial
- **Detection Difficulty**: Without audit logging, these operations are invisible to security monitoring
- **Operational Reality**: The debugger is a legitimate operational tool, making it available on production nodes

The likelihood is elevated because the vulnerability can be exploited by both external attackers who compromise a node and malicious insiders with legitimate access.

## Recommendation

**Implement comprehensive audit logging for all debugger operations:**

```rust
// In crates/aptos-debugger/src/main.rs
use aptos_logger::{Level, Logger, info};
use std::env;

#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);
    
    // Log debugger invocation with full command line
    let args: Vec<String> = env::args().collect();
    info!(
        security_event = true,
        operation = "debugger_invocation",
        command_line = ?args,
        user = env::var("USER").unwrap_or_default(),
        "Aptos debugger invoked"
    );
    
    let result = Cmd::parse().run().await;
    
    // Log completion or failure
    match &result {
        Ok(_) => info!(
            security_event = true,
            operation = "debugger_completion",
            status = "success",
            "Aptos debugger completed"
        ),
        Err(e) => info!(
            security_event = true,
            operation = "debugger_completion",
            status = "error",
            error = ?e,
            "Aptos debugger failed"
        ),
    }
    
    result
}
```

**Add operation-specific logging:**

```rust
// In storage/aptosdb/src/db_debugger/examine/print_raw_data_by_version.rs
impl Cmd {
    pub fn run(self) -> Result<()> {
        // Log the query operation
        info!(
            security_event = true,
            operation = "db_query",
            query_type = "print_raw_data",
            version = self.version,
            db_path = ?self.db_dir,
            "Querying transaction data by version"
        );
        
        // ... existing query code ...
        
        info!(
            security_event = true,
            operation = "db_query_complete",
            version = self.version,
            "Transaction data query completed"
        );
        
        Ok(())
    }
}
```

**Similar logging should be added to:**
- All `db_debugger` subcommands
- `consensus/src/util/db_tool.rs` (dump_pending_txns)
- `bcs_txn_decoder.rs` (transaction decoding operations)
- `execute_past_transactions.rs` and `execute_pending_block.rs`

**Additional Security Controls:**
1. Configure log aggregation to send debugger logs to a centralized, tamper-evident logging system
2. Generate alerts for debugger usage outside of maintenance windows
3. Require additional authentication/authorization for debugger operations
4. Consider implementing a read-only mode vs privileged mode with different logging levels

## Proof of Concept

**Step 1: Demonstrate lack of logging for database query**

```bash
# Set up logging output to file
export RUST_LOG=info
aptos-debugger aptos-db debug examine print-raw-data-by-version \
    --db-dir /opt/aptos/data \
    --version 1000000 2>&1 | tee debugger.log

# Check logs for audit trail
grep "security_event" debugger.log || echo "No security audit events logged"
grep "print_raw_data" debugger.log || echo "No operation-specific logging found"
```

**Expected Result**: The debugger outputs transaction data but no security audit events are logged.

**Step 2: Demonstrate forensics evasion**

```bash
# Attacker can suppress output entirely
aptos-debugger aptos-db debug examine print-raw-data-by-version \
    --db-dir /opt/aptos/data \
    --version 1000000 > /dev/null 2>&1

# Check system logs - no record of what was accessed
journalctl -u aptos-node | grep "version 1000000"  # No entries
```

**Step 3: Demonstrate consensus data extraction without logging**

```bash
# Extract pending transactions from consensus
aptos-debugger dump-pending-txns \
    --db-dir /opt/aptos/consensus \
    > pending_txns.json 2>&1

# Verify no audit logging occurred
grep -i "dump.*txn" /var/log/aptos/*.log || echo "No audit trail"
```

**Expected Result**: Sensitive consensus data is extracted without any logged record of the operation, enabling forensics-resistant information gathering.

---

**Notes**

This vulnerability represents a security logging deficiency rather than a direct exploitation path. However, it significantly impacts the security posture of Aptos nodes by:

1. Enabling undetectable information disclosure by attackers with node access
2. Preventing effective forensic investigation of security incidents
3. Facilitating insider threats without accountability
4. Violating defense-in-depth principles by lacking complete mediation logging

The Medium severity classification is appropriate as this issue requires intervention to address the security state inconsistency and protect against information disclosure attacks.

### Citations

**File:** crates/aptos-debugger/src/main.rs (L15-19)
```rust
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);

    Cmd::parse().run().await
```

**File:** storage/aptosdb/src/db_debugger/mod.rs (L48-60)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        match self {
            Cmd::StateTree(cmd) => cmd.run(),
            Cmd::StateKv(cmd) => cmd.run(),
            Cmd::Checkpoint(cmd) => cmd.run(),
            Cmd::Ledger(cmd) => cmd.run(),
            Cmd::Truncate(cmd) => cmd.run(),
            Cmd::Examine(cmd) => cmd.run(),
            Cmd::IndexerValidation(cmd) => cmd.run(),
            Cmd::Watch(cmd) => cmd.run(),
        }
    }
```

**File:** storage/aptosdb/src/db_debugger/examine/print_raw_data_by_version.rs (L42-77)
```rust
        println!(
            "Transaction: {:?}",
            ledger_db.transaction_db().get_transaction(self.version)?
        );

        println!(
            "PersistedAuxiliaryInfo: {:?}",
            ledger_db
                .persisted_auxiliary_info_db()
                .get_persisted_auxiliary_info(self.version)?
        );

        println!(
            "WriteSet: {:?}",
            ledger_db.write_set_db().get_write_set(self.version)?
        );

        println!(
            "Events: {:?}",
            ledger_db.event_db().get_events_by_version(self.version)?
        );

        println!(
            "TransactionInfo: {:?}",
            ledger_db
                .transaction_info_db()
                .get_transaction_info(self.version)?
        );

        println!(
            "TransactionAccumulatorHash: {:?}",
            ledger_db
                .transaction_accumulator_db()
                .get_root_hash(self.version)?
        );

```

**File:** storage/aptosdb/src/db_debugger/state_kv/get_value.rs (L70-89)
```rust
        let mut start_version = self.version;
        let mut count = 0;
        while count < 10 {
            match db.get_state_value_with_version_by_version(&key, start_version)? {
                None => {
                    if count == 0 {
                        println!("{}", "Value not found.".to_string().yellow());
                    }
                    break;
                },
                Some((version, value)) => {
                    Self::print_value(version, value);
                    count += 1;
                    if version == 0 {
                        break;
                    }
                    start_version = version - 1;
                },
            }
        }
```

**File:** consensus/src/util/db_tool.rs (L44-66)
```rust
    pub fn dump_pending_txns(&self) -> Result<Vec<Transaction>> {
        let quorum_store_db = QuorumStoreDB::new(self.db_dir.clone());
        let all_batches = quorum_store_db.get_all_batches().unwrap();

        let consensus_db = ConsensusDB::new(self.db_dir.clone());
        let (_, _, blocks, _) = consensus_db.get_data()?;

        let mut txns = Vec::new();
        for block in blocks {
            let id = block.id();
            #[allow(clippy::unwrap_in_result)]
            if self.block_id.is_none() || id == self.block_id.unwrap() {
                txns.extend(
                    extract_txns_from_block(&block, &all_batches)?
                        .into_iter()
                        .cloned()
                        .map(Transaction::UserTransaction),
                );
            }
        }

        Ok(txns)
    }
```

**File:** aptos-move/aptos-debugger/src/bcs_txn_decoder.rs (L23-80)
```rust
    pub async fn run(self) -> Result<()> {
        let mut buffer = String::new();
        io::stdin().read_line(&mut buffer)?;
        let re = Regex::new(r"\d+").unwrap();
        let bytes = re
            .find_iter(&buffer)
            .filter_map(|m| m.as_str().parse::<u8>().ok())
            .collect::<Vec<u8>>();

        let txn: SignedTransaction = bcs::from_bytes::<SignedTransaction>(&bytes)?;
        let chain_id = txn.chain_id();
        println!("===================");
        println!("Transaction Summary");
        println!("===================");
        println!("Sender: {:?}", txn.sender());
        println!("Sequence number: {:?}", txn.sequence_number());

        let network = if chain_id.is_mainnet() {
            "mainnet".to_string()
        } else if chain_id.is_testnet() {
            "testnet".to_string()
        } else {
            "devnet".to_string()
        };
        println!("Chain ID: {}", chain_id.id());
        println!("Network: {}", network);

        let endpoint = format!("https://{}.aptoslabs.com/v1", network);
        let debugger = AptosDebugger::rest_client(Client::new(Url::parse(&endpoint)?))?;
        let version = debugger
            .get_version_by_account_sequence(txn.sender(), txn.sequence_number())
            .await?
            .unwrap();
        println!("Version: {:?}", version);
        println!(
            "Overview: https://explorer.aptoslabs.com/txn/{:?}/userTxnOverview?network={}",
            version, network
        );
        println!(
            "Payload: https://explorer.aptoslabs.com/txn/{:?}/payload?network={}",
            version, network
        );

        if self.execute {
            println!();
            println!("===============================");
            println!("Transaction re-execution result");
            println!("===============================");
            println!(
                "{:#?}",
                debugger
                    .execute_past_transactions(version, 1, false, 1, &[self.concurrency_level])
                    .await?
            );
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-debugger/src/execute_past_transactions.rs (L32-56)
```rust
    pub async fn run(self) -> Result<()> {
        let debugger = if let Some(rest_endpoint) = self.opts.target.rest_endpoint {
            AptosDebugger::rest_client(Client::new(Url::parse(&rest_endpoint)?))?
        } else if let Some(db_path) = self.opts.target.db_path {
            AptosDebugger::db(db_path)?
        } else {
            unreachable!("Must provide one target.");
        };

        let result = debugger
            .execute_past_transactions(
                self.begin_version,
                self.limit,
                self.use_same_block_boundaries,
                self.repeat_execution_times.unwrap_or(1),
                &self.opts.concurrency_level,
            )
            .await?;

        if !self.skip_result {
            println!("{result:#?}",);
        }

        Ok(())
    }
```
