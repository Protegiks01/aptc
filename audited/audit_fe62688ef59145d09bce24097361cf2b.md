# Audit Report

## Title
Indexer Crash Due to Missing Table Info Causes Service Disruption and Data Inconsistency

## Summary
When table metadata is unavailable, the API layer returns transactions with `data: None` for table items to "avoid crash", but the indexer layer expects this data to always be present and panics when processing such transactions. This causes complete indexer service disruption and creates a divergence between blockchain state and indexed data.

## Finding Description

The vulnerability exists in the table item conversion logic between the API layer and the indexer layer. When processing table operations (write or delete), the system fails to handle missing table metadata consistently across layers.

**API Layer Behavior:**

In `try_write_table_item_into_decoded_table_data()` and `try_delete_table_item_into_deleted_table_data()`, when table info is missing, the functions log a debug message and return `Ok(None)`: [1](#0-0) [2](#0-1) 

The comment explicitly states "return None anyway to avoid crash", treating missing table info as acceptable. This creates `WriteTableItem` and `DeleteTableItem` structures with `data: None`: [3](#0-2) [4](#0-3) 

**Indexer Layer Behavior:**

However, the indexer unconditionally unwraps the `data` field, expecting it to always be present: [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

**Execution Flow:**

1. Transaction with table operations is executed and committed to blockchain
2. API's `MoveConverter::get_table_info()` returns `None` when `indexer_reader` is not configured or table info is unavailable: [9](#0-8) 
3. API successfully returns transaction with `data: None` for table items
4. Indexer processes transaction via `WriteSetChangeModel::from_write_set_changes()`: [10](#0-9) 
5. Indexer calls `from_write_table_item()` which unwraps the None value
6. **PANIC**: "called `Option::unwrap()` on a `None` value"
7. Panic propagates to indexer runtime loop: [11](#0-10) 
8. Indexer process crashes with exit code 12

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: The blockchain successfully commits transactions, but the indexer fails to process them, creating a permanent divergence between on-chain state and indexed state
- **Service disruption**: Complete indexer denial of service requiring manual restart
- **Misleading data**: Users querying via API receive incomplete data (raw bytes without decoded JSON) with no clear indication of incompleteness
- **Cascading failure**: All subsequent transactions fail to be indexed until the problematic transaction is handled

The vulnerability doesn't affect consensus or validator operations (blockchain continues functioning), so it doesn't reach Critical or High severity. However, it causes significant operational disruption for indexer infrastructure and downstream applications.

## Likelihood Explanation

**High likelihood** in production environments:

1. **Common configuration**: Validator nodes and some fullnodes run without `indexer_table_info` enabled for performance reasons
2. **Natural occurrence**: New tables may not have metadata available immediately in the indexer reader
3. **No warning**: The debug log message suggests this is "OK for simulation", implying developers may consider it benign
4. **Automatic trigger**: Any user creating table operations on such nodes will trigger the vulnerability
5. **No attacker sophistication required**: Regular transactions naturally trigger this condition

The inconsistency between the API comment ("avoid crash") and the indexer implementation (unconditional unwrap) suggests this is an unintended design mismatch rather than deliberate handling.

## Recommendation

**Option 1 - Fail fast in API layer (preferred):**

Modify the API conversion to return an error when table info is missing for non-simulation contexts:

```rust
pub fn try_write_table_item_into_decoded_table_data(
    &self,
    handle: TableHandle,
    key: &[u8],
    value: &[u8],
) -> Result<Option<DecodedTableData>> {
    let table_info = match self.get_table_info(handle)? {
        Some(ti) => ti,
        None => {
            log_missing_table_info(handle);
            // Fail if indexer is expected to process this
            bail!("Table info not found for handle {:?}, cannot decode table item for indexer", handle);
        },
    };
    // ... rest of implementation
}
```

**Option 2 - Handle None gracefully in indexer:**

Add null checks in the indexer models:

```rust
pub fn from_write_table_item(
    write_table_item: &WriteTableItem,
    write_set_change_index: i64,
    transaction_version: i64,
    transaction_block_height: i64,
) -> Result<(Self, CurrentTableItem)> {
    let data = write_table_item.data.as_ref()
        .ok_or_else(|| anyhow::anyhow!(
            "Missing table data for write table item at version {}",
            transaction_version
        ))?;
    
    Ok((
        Self {
            transaction_version,
            write_set_change_index,
            transaction_block_height,
            key: write_table_item.key.to_string(),
            table_handle: standardize_address(&write_table_item.handle.to_string()),
            decoded_key: data.key.clone(),
            decoded_value: Some(data.value.clone()),
            is_deleted: false,
        },
        // ... CurrentTableItem construction
    ))
}
```

**Option 3 - Skip transactions with missing table info:**

Add filtering logic in the indexer processing to skip transactions with incomplete table data and log warnings.

## Proof of Concept

```rust
// Reproduction steps:

// 1. Start a node with indexer disabled (indexer_table_info = None in config)
// 2. Submit a transaction that creates/modifies table items:

#[test]
fn test_missing_table_info_crash() {
    use aptos_api_types::{WriteTableItem, HexEncodedBytes};
    use crate::models::move_tables::TableItem;
    
    // Create a WriteTableItem with None data (as API would return)
    let write_item = WriteTableItem {
        state_key_hash: "test_hash".to_string(),
        handle: HexEncodedBytes::from(vec![0u8; 32]),
        key: HexEncodedBytes::from(vec![1u8; 32]),
        value: HexEncodedBytes::from(vec![2u8; 64]),
        data: None, // Missing table info!
    };
    
    // Indexer tries to process this
    let result = std::panic::catch_unwind(|| {
        TableItem::from_write_table_item(&write_item, 0, 100, 50)
    });
    
    // This will panic with: "called `Option::unwrap()` on a `None` value"
    assert!(result.is_err());
    println!("Indexer crashed as expected: {:?}", result);
}

// 3. The indexer process will crash when processing this transaction
// 4. All subsequent transaction processing stops
// 5. Manual intervention required to restart indexer
```

**Notes:**

This vulnerability represents a critical design inconsistency between the API and indexer layers. The API's defensive programming to "avoid crash" inadvertently creates a crash condition in the downstream indexer. The root cause is that `get_table_info()` returns `None` when no indexer_reader is configured, but the system still attempts to process and index these transactions, expecting the data to be present. This architectural mismatch needs resolution at the API configuration level to ensure nodes serving indexer data always have table info available.

### Citations

**File:** api/types/src/convert.rs (L561-566)
```rust
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
```

**File:** api/types/src/convert.rs (L585-590)
```rust
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
```

**File:** api/types/src/convert.rs (L1060-1065)
```rust
    fn get_table_info(&self, handle: TableHandle) -> Result<Option<TableInfo>> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            return Ok(indexer_reader.get_table_info(handle).unwrap_or(None));
        }
        Ok(None)
    }
```

**File:** api/types/src/transaction.rs (L1126-1134)
```rust
pub struct DeleteTableItem {
    pub state_key_hash: String,
    pub handle: HexEncodedBytes,
    pub key: HexEncodedBytes,
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DeletedTableData>,
}
```

**File:** api/types/src/transaction.rs (L1178-1187)
```rust
pub struct WriteTableItem {
    pub state_key_hash: String,
    pub handle: HexEncodedBytes,
    pub key: HexEncodedBytes,
    pub value: HexEncodedBytes,
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DecodedTableData>,
}
```

**File:** crates/indexer/src/models/move_tables.rs (L66-67)
```rust
                decoded_key: write_table_item.data.as_ref().unwrap().key.clone(),
                decoded_value: Some(write_table_item.data.as_ref().unwrap().value.clone()),
```

**File:** crates/indexer/src/models/move_tables.rs (L74-75)
```rust
                decoded_key: write_table_item.data.as_ref().unwrap().key.clone(),
                decoded_value: Some(write_table_item.data.as_ref().unwrap().value.clone()),
```

**File:** crates/indexer/src/models/move_tables.rs (L88-96)
```rust
        let decoded_key = delete_table_item
            .data
            .as_ref()
            .unwrap_or_else(|| {
                panic!(
                    "Could not extract data from DeletedTableItem '{:?}'",
                    delete_table_item
                )
            })
```

**File:** crates/indexer/src/models/move_tables.rs (L127-128)
```rust
            key_type: table_item.data.as_ref().unwrap().key_type.clone(),
            value_type: table_item.data.as_ref().unwrap().value_type.clone(),
```

**File:** crates/indexer/src/models/write_set_changes.rs (L119-124)
```rust
                let (ti, cti) = TableItem::from_write_table_item(
                    table_item,
                    index,
                    transaction_version,
                    transaction_block_height,
                );
```

**File:** crates/indexer/src/runtime.rs (L239-242)
```rust
                    panic!(
                        "Error in '{}' while processing batch: {:?}",
                        processor_name, err
                    );
```
