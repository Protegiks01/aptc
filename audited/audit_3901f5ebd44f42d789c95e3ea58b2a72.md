# Audit Report

## Title
Lack of Forward Secrecy in FPTX Batch Encryption Scheme Enables Decryption of All Historical Ciphertexts with Compromised Keys

## Summary
The FPTX batch threshold encryption scheme does not implement forward secrecy. If validator master secret key (MSK) shares from any epoch are compromised, an attacker can decrypt all historical encrypted transactions from that epoch, even if the compromise occurs long after the epoch has ended.

## Finding Description

The batch encryption scheme generates new master secret keys per epoch via DKG (Distributed Key Generation), but critically lacks forward secrecy properties. This breaks the **Cryptographic Correctness** invariant by allowing compromised old keys to decrypt all historical data.

**Key Design Flaw:**

The encryption key for each epoch is derived from that epoch's master secret key. [1](#0-0) 

Decryption key shares are deterministically derived from the master secret key share and the digest. [2](#0-1) 

**Why This Enables Historical Decryption:**

1. **Persistent Key Storage**: Master secret key shares are persisted with epoch identifiers but never automatically deleted. [3](#0-2) 

2. **Deterministic Decryption**: Given a compromised MSK share from epoch N and historical ciphertexts from epoch N (stored on-chain), an attacker can:
   - Reconstruct the digest from the ciphertexts (deterministic process) [4](#0-3) 
   - Derive decryption key shares using the compromised MSK share
   - Collect threshold shares to reconstruct the full decryption key
   - Decrypt all transactions from that epoch

3. **On-Chain Availability**: Encrypted transactions are permanently stored in blocks on-chain, accessible to anyone. [5](#0-4) 

4. **No Re-encryption**: Historical ciphertexts are never re-encrypted with new epoch keys, remaining vulnerable indefinitely.

**Epoch Isolation Insufficient**: While the system validates that shares match the current epoch during processing [6](#0-5) , this only prevents cross-epoch share usage during consensus. It doesn't prevent offline decryption of historical data using compromised keys.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria for "Significant protocol violations")

This vulnerability constitutes a significant protocol-level privacy violation:

- **Scope**: All encrypted transactions from any compromised epoch are exposed
- **Permanence**: The exposure is irreversible - historical data cannot be re-encrypted
- **Scale**: Affects potentially millions of encrypted transactions across blockchain history
- **Privacy Violation**: Breaks fundamental confidentiality guarantees of the encryption scheme

While not directly causing "loss of funds," this violates the core security property that encrypted transactions should remain confidential even if future keys are compromised (forward secrecy).

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

Several factors make this vulnerability practically exploitable:

1. **Long-lived Keys**: Validators must retain MSK shares across multiple epochs for operational continuity and recovery scenarios
2. **Multiple Attack Surfaces**: Keys can be compromised through:
   - Infrastructure breaches (server compromise, backup exposure)
   - Supply chain attacks on validator hardware/software
   - Operational errors (accidental key exposure in logs, backups)
3. **Threshold Requirement**: Only requires compromising threshold validators (e.g., 2/3), not all validators
4. **Time-unlimited Window**: Attack can occur years after original encryption - no time pressure
5. **Public Data**: All ciphertexts are permanently on-chain, readily available

## Recommendation

Implement forward secrecy through one of these approaches:

**Option 1: Ephemeral Session Keys**
- Generate per-round ephemeral encryption keys
- Derive these from a combination of MSK and round-specific randomness that is discarded after use
- Ensure old rounds cannot be decrypted even with current MSK

**Option 2: Re-encryption Protocol**
- Implement periodic re-encryption of historical ciphertexts with new epoch keys
- Phase out old keys after successful re-encryption
- Add on-chain governance for re-encryption triggers

**Option 3: Time-based Key Deletion**
- Implement automatic deletion of MSK shares after N epochs
- Ensure sufficient redundancy for active decryption needs
- Document the limited decryption window

**Immediate Mitigation:**
Add key lifecycle management:
```rust
// In SecretShareConfig or similar
pub fn should_retain_msk_share(current_epoch: u64, share_epoch: u64) -> bool {
    // Only keep MSK shares for recent epochs (e.g., last 10)
    current_epoch - share_epoch <= 10
}

pub fn cleanup_old_msk_shares(&mut self, current_epoch: u64) {
    // Remove MSK shares beyond retention window
    // This limits exposure window but doesn't provide true forward secrecy
}
```

## Proof of Concept

This demonstrates the vulnerability conceptually (not executable as it requires simulating key compromise):

```rust
// Conceptual PoC - NOT executable
// Demonstrates how historical decryption works

// Step 1: Attacker obtains historical encrypted transactions from epoch N
let historical_block = blockchain.get_block_from_epoch(epoch_n);
let encrypted_txns: Vec<Ciphertext> = historical_block
    .transactions()
    .filter(|tx| tx.is_encrypted())
    .map(|tx| tx.ciphertext().clone())
    .collect();

// Step 2: Attacker compromises threshold validator MSK shares from epoch N
// (e.g., through infrastructure breach, backup exposure, etc.)
let compromised_msk_shares: Vec<MasterSecretKeyShare> = 
    attacker.compromise_validator_keys(epoch_n, threshold_count);

// Step 3: Reconstruct digest from historical ciphertexts (deterministic)
let (digest, _) = FPTXWeighted::digest(
    &digest_key_from_epoch_n,
    &encrypted_txns,
    round_from_epoch_n
)?;

// Step 4: Derive decryption key shares from compromised MSK shares
let decryption_key_shares: Vec<_> = compromised_msk_shares
    .iter()
    .map(|msk| FPTXWeighted::derive_decryption_key_share(msk, &digest))
    .collect::<Result<Vec<_>>>()?;

// Step 5: Reconstruct full decryption key
let decryption_key = FPTXWeighted::reconstruct_decryption_key(
    &decryption_key_shares,
    &threshold_config
)?;

// Step 6: Decrypt all historical transactions
let eval_proofs = compute_eval_proofs(&encrypted_txns, &digest);
for (ct, eval_proof) in encrypted_txns.iter().zip(eval_proofs) {
    let plaintext: DecryptedPayload = FPTXWeighted::decrypt_individual(
        &decryption_key,
        ct,
        &digest,
        &eval_proof
    )?;
    // Attacker now has access to historical transaction contents
    attacker.exfiltrate(plaintext);
}
```

## Notes

This vulnerability represents a fundamental cryptographic design limitation rather than an implementation bug. The FPTX scheme correctly implements its intended cryptographic operations, but the overall system architecture lacks forward secrecy - a critical property for long-term data confidentiality.

The epoch-based key rotation provides operational security by limiting the scope of any single key compromise, but it does not provide forward secrecy since historical data remains decryptable with old keys. True forward secrecy requires that compromise of current keys cannot reveal past encrypted data.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L241-243)
```rust
        let mpk_g2: G2Affine = subtranscript.get_dealt_public_key().as_g2();

        let ek = EncryptionKey::new(mpk_g2, digest_key.tau_g2);
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L107-115)
```rust
    pub fn derive_decryption_key_share(&self, digest: &Digest) -> Result<BIBEDecryptionKeyShare> {
        let hashed_encryption_key: G1Affine = symmetric::hash_g2_element(self.mpk_g2)?;

        Ok((self.player, BIBEDecryptionKeyShareValue {
            signature_share_eval: G1Affine::from(
                (digest.as_g1() + hashed_encryption_key) * self.shamir_share_eval,
            ),
        }))
    }
```

**File:** consensus/src/epoch_manager.rs (L1114-1120)
```rust
            self.rand_storage
                .save_key_pair_bytes(
                    new_epoch,
                    bcs::to_bytes(&(augmented_key_pair.clone(), fast_augmented_key_pair.clone()))
                        .map_err(NoRandomnessReason::KeyPairSerializationError)?,
                )
                .map_err(NoRandomnessReason::KeyPairPersistError)?;
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L106-136)
```rust
    pub fn digest(
        &self,
        ids: &mut IdSet<UncomputedCoeffs>,
        round: u64,
    ) -> Result<(Digest, EvalProofsPromise)> {
        let round: usize = round as usize;
        if round >= self.tau_powers_g1.len() {
            Err(anyhow!(
                "Tried to compute digest with round greater than setup length."
            ))
        } else if ids.capacity() > self.tau_powers_g1[round].len() - 1 {
            Err(anyhow!(
                "Tried to compute a batch digest with size {}, where setup supports up to size {}",
                ids.capacity(),
                self.tau_powers_g1[round].len() - 1
            ))?
        } else {
            let ids = ids.compute_poly_coeffs();
            let mut coeffs = ids.poly_coeffs();
            coeffs.resize(self.tau_powers_g1[round].len(), Fr::zero());

            let digest = Digest {
                digest_g1: G1Projective::msm(&self.tau_powers_g1[round], &coeffs)
                    .unwrap()
                    .into(),
                round,
            };

            Ok((digest.clone(), EvalProofsPromise::new(digest, ids)))
        }
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L244-244)
```rust
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
```
