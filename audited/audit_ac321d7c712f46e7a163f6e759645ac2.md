# Audit Report

## Title
Index Out-of-Bounds Vulnerability in SecretShareConfig Verification Due to Missing Length Validation

## Summary
The `SecretShareConfig::new()` constructor does not validate that the length of the `verification_keys` vector matches the number of validators in the `ValidatorVerifier`. This missing validation, combined with unchecked array access in `SecretShare::verify()`, creates a latent vulnerability that would allow denial-of-service attacks against consensus nodes when the secret sharing feature is enabled.

## Finding Description

The vulnerability exists in the secret sharing verification logic: [1](#0-0) 

The `verify()` function retrieves a validator index via `get_id()` and directly accesses `config.verification_keys[index]` without bounds checking. The code contains an explicit TODO comment acknowledging this missing validation. [2](#0-1) 

The `get_id()` function returns an index from the `ValidatorVerifier` without verifying it's within the bounds of `verification_keys`. [3](#0-2) 

The constructor accepts `verification_keys` without validating its length matches the validator count.

**Attack Scenario (when feature is enabled):**

1. A `SecretShareConfig` is created during epoch setup with `verification_keys.len() < number_of_validators` (due to a configuration error or bug in the setup code)
2. A network peer sends a `SecretShareMessage::Share` with an `author` field set to a validator whose index â‰¥ `verification_keys.len()`
3. The message is deserialized and passed to the verification task: [4](#0-3) 

4. When `msg.verify()` is called: [5](#0-4) 

5. This triggers the unchecked array access, causing a Rust panic and crashing the verification task
6. Repeated attacks prevent the node from processing secret shares, breaking consensus participation

**Current Status:** The secret sharing feature is currently disabled in production code: [6](#0-5) 

The `secret_sharing_config` parameter is hardcoded to `None`, meaning this vulnerability is **not currently exploitable**. However, the infrastructure exists and the TODO comment indicates this is planned functionality.

## Impact Explanation

**When the feature is enabled**, this would qualify as **High Severity** (validator node crashes/slowdowns):
- Malicious network peers can crash the secret sharing verification task on consensus nodes
- Repeated crashes prevent nodes from participating in secret sharing protocol
- This breaks consensus liveness if secret sharing becomes a required component
- No funds are directly at risk, but network availability is compromised

**Current Impact**: None (feature disabled)

## Likelihood Explanation

**If feature enabled:**
- **High likelihood** if there's any bug in the DKG/setup code that creates mismatched lengths
- **Medium likelihood** for malicious exploitation (requires network access but no validator privileges)
- An attacker can send crafted messages with arbitrary `author` fields

**Current likelihood:** Zero (feature not enabled)

## Recommendation

Add validation in the `SecretShareConfig::new()` constructor:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> anyhow::Result<Self> {
    // Validate verification_keys length matches validator count
    let num_validators = validator.len();
    anyhow::ensure!(
        verification_keys.len() == num_validators,
        "verification_keys length ({}) must match validator count ({})",
        verification_keys.len(),
        num_validators
    );
    
    Ok(Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights: HashMap::new(),
    })
}
```

Additionally, add defensive bounds checking in `verify()`:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author());
    anyhow::ensure!(
        index < config.verification_keys.len(),
        "Validator index {} out of bounds for verification_keys length {}",
        index,
        config.verification_keys.len()
    );
    let decryption_key_share = self.share().clone();
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

## Proof of Concept

Since the feature is currently disabled, a full PoC cannot run in the current codebase. However, the vulnerability can be demonstrated with this unit test (would need feature enabled):

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_verify_with_mismatched_verification_keys() {
    // Setup: Create a config with fewer verification keys than validators
    let validator_set = create_validator_set(5); // 5 validators
    let verification_keys = vec![create_verification_key(); 3]; // Only 3 keys
    
    let config = SecretShareConfig::new(
        author,
        epoch,
        Arc::new(validator_set),
        digest_key,
        msk_share,
        verification_keys, // Length mismatch!
        threshold_config,
        encryption_key,
    );
    
    // Create a share from validator at index 4 (>= verification_keys.len())
    let share = SecretShare::new(
        validator_addresses[4], // Index 4
        metadata,
        secret_key_share,
    );
    
    // This will panic with index out of bounds
    share.verify(&config).unwrap();
}
```

**Note:** This vulnerability is not currently exploitable in production but represents incomplete defensive programming that must be fixed before the secret sharing feature is enabled.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L149-170)
```rust
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L543-558)
```rust
        let maybe_rand_msg_tx = self.spawn_decoupled_execution(
            maybe_consensus_key,
            commit_signer_provider,
            epoch_state.clone(),
            rand_config,
            fast_rand_config,
            None,
            onchain_consensus_config,
            rand_msg_rx,
            secret_sharing_msg_rx,
            highest_committed_round,
            self.consensus_config.enable_pre_commit,
            self.consensus_observer_config,
            self.consensus_publisher.clone(),
            network_sender.clone(),
        );
```
