# Audit Report

## Title
Inlining Optimization Bypasses Access Control via Unchecked Nested Patterns in Match Expressions

## Summary
The `has_privileged_operations()` function in the Move compiler's inlining optimization fails to check nested struct patterns within match expression arms, allowing unauthorized cross-module struct unpacking when functions are inlined. This breaks Move's access control invariants and violates the principle that struct fields can only be accessed by authorized modules.

## Finding Description

The vulnerability exists in the pattern checking logic for Match expressions in the inlining optimization pass. [1](#0-0) 

For `ExpData::Match`, the function only checks if the discriminator (the value being matched) comes from a different module. It does NOT recursively check if patterns within the match arms contain struct unpacking operations from other modules.

In contrast, for `ExpData::Assign`, `ExpData::Block`, and `ExpData::Lambda`, the function correctly visits all nested patterns: [2](#0-1) 

This inconsistency creates an access control bypass. Consider this scenario:

**Module A** defines a friend-visible struct:
```move
friend struct Secret has drop { value: u64 }
```

**Module C** (NOT a friend of A) defines an enum containing this type:
```move
public enum Container has drop { Box(A::Secret) }
```

**Module B** (friend of A) has a function that unpacks the nested struct:
```move
public fun extract(c: C::Container): u64 {
    match (c) {
        C::Container::Box(A::Secret { value }) => value
    }
}
```

When module C calls `B::extract()`, the inlining optimizer checks:
1. Discriminator type is `C::Container` from module C
2. Check: `module_C == module_C`? YES
3. Nested pattern `A::Secret { value }` is **NOT checked**
4. Inlining proceeds
5. C now has inlined code that unpacks `A::Secret`, violating access control

The function_checker correctly validates these patterns during the checking phase: [3](#0-2) 

However, the inlining optimization runs in a later pipeline stage and uses its own incomplete check.

## Impact Explanation

**Critical Severity** - This vulnerability breaks Move's fundamental access control model:

1. **Deterministic Execution Violation**: Different compilation optimization settings could lead to different access control enforcement, causing validator consensus divergence
2. **Access Control Bypass**: Modules gain unauthorized ability to unpack private/friend structs from other modules
3. **Framework Security Compromise**: System modules using friend visibility for security boundaries can be bypassed
4. **Staking/Governance Impact**: If governance or staking modules use friend structs for internal state, unauthorized access could enable manipulation

This meets the **Critical** threshold: it violates a core security invariant (Access Control) and could lead to consensus divergence if validators compile with different optimization levels. [4](#0-3) 

## Likelihood Explanation

**High Likelihood**:
- The inlining optimization is enabled by default in the compilation pipeline
- The pattern of friend structs nested in public enums is a reasonable API design
- No explicit warnings prevent developers from creating vulnerable patterns
- The vulnerability is triggered automatically during compilation without attacker interaction

The inlining decision is made based on size heuristics and does not require specific attacker-controlled inputs. [5](#0-4) 

## Recommendation

Fix `has_privileged_operations()` to recursively check all patterns within match arms, consistent with how Assign/Block/Lambda are handled:

```rust
ExpData::Match(_, discriminator, arms) => {
    let did = discriminator.node_id();
    if let Type::Struct(mid, ..) = env.get_node_type(did).drop_reference() {
        if mid != caller_mid {
            found = true;
        }
    }
    // NEW: Check patterns in all match arms
    for arm in arms {
        arm.pattern.visit_pre_post(&mut |post, pat| {
            if !post {
                if let Pattern::Struct(_, sid, ..) = pat {
                    let struct_mid = sid.module_id;
                    if struct_mid != caller_mid {
                        found = true;
                    }
                }
            }
        });
    }
},
```

Additionally, the discriminator check should respect visibility rules (public/friend/private) rather than simply blocking all cross-module matches, to align with function_checker's behavior. [6](#0-5) 

## Proof of Concept

```move
// Module A: Defines friend struct
module 0x1::A {
    friend 0x1::B;
    
    friend struct Secret has drop { 
        value: u64 
    }
    
    public fun make_secret(v: u64): Secret {
        Secret { value: v }
    }
}

// Module C: Defines enum containing Secret (type reference allowed)
module 0x1::C {
    use 0x1::A::Secret;
    
    public enum Container has drop {
        Box(Secret)
    }
    
    public fun make_container(s: Secret): Container {
        Container::Box(s)
    }
}

// Module B: Friend of A, can unpack Secret
module 0x1::B {
    friend 0x1::A;
    use 0x1::A::Secret;
    use 0x1::C::Container;
    
    // This function will be inlined into C
    public fun extract_secret(c: Container): u64 {
        match (c) {
            Container::Box(Secret { value }) => value
        }
    }
}

// Module C continued: Attempts to steal secret via inlining
module 0x1::C {
    use 0x1::B;
    
    // After inlining, C can unpack Secret!
    public fun steal_secret(c: Container): u64 {
        B::extract_secret(c)  // Gets inlined
    }
    
    #[test]
    fun test_access_violation() {
        let secret = 0x1::A::make_secret(42);
        let container = make_container(secret);
        // C should NOT be able to extract the secret value
        // but inlining gives it this capability
        assert!(steal_secret(container) == 42, 0);
    }
}
```

Compile with inlining optimization enabled (default) to observe the access control violation.

## Notes

This vulnerability affects the Move Compiler v2 optimization pipeline. The issue is not in the language semantics or VM execution, but in the compiler optimization that incorrectly transforms source code while breaking access control invariants. This could lead to consensus divergence if validators use different compiler versions or optimization flags.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L75-117)
```rust
pub fn optimize(env: &mut GlobalEnv, across_package: bool, allow_non_primary_targets: bool) {
    let mut targets = RewriteTargets::create(env, RewritingScope::CompilationTarget);
    let skip_functions = find_cycles_in_call_graph(env, &targets);
    targets.filter(|target, _| {
        if let RewriteTarget::MoveFun(function_id) = target {
            let function = env.get_function(*function_id);
            // We will consider inlining the callees in a function only if it satisfies all of:
            // - is not a part of a cycle in the call graph
            // - is in a primary target module (if `allow_non_primary_targets` is false)
            // - is not in a script module
            // - is not a test only function
            // - is not a verify only function
            // - is not a native function
            // - is not an inline function
            // - does not have the `#[module_lock]` attribute
            !skip_functions.contains(function_id)
                && (allow_non_primary_targets || function.module_env.is_primary_target())
                && !function.module_env.is_script_module()
                && !function.is_test_only()
                && !function.is_verify_only()
                && !function.is_native()
                && !function.is_inline()
                && !has_module_lock_attribute(&function)
        } else {
            // only move functions are considered for inlining optimization
            false
        }
    });
    let mut todo: Vec<_> = targets.keys().collect();
    // Each time you unroll, a call site may be substituted with the original body of the callee.
    for _ in 0..*UNROLL_DEPTH {
        if todo.is_empty() {
            break;
        }
        todo = inline_call_sites(env, &mut targets, todo, across_package);
    }
    // Update the changed function definitions due to inlining.
    targets.write_to_env(env);
    // Inlining can cause direct calls to `package` functions that were previously
    // indirect. Thus, it may require additional caller modules to become friends
    // of the callee modules.
    env.update_friend_decls_in_targets();
}
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L249-254)
```rust
                || has_abort(&callee_env, caller_func_env)
                || has_privileged_operations(caller_mid, &callee_env)
                || has_invisible_calls(caller_module, &callee_env, across_package)
                || has_module_lock_attribute(&callee_env)
                || has_access_controls(&callee_env)
            {
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L434-445)
```rust
                    ExpData::Assign(_, pat, _)
                    | ExpData::Block(_, pat, ..)
                    | ExpData::Lambda(_, pat, ..) => pat.visit_pre_post(&mut |post, pat| {
                        if !post {
                            if let Pattern::Struct(_, sid, ..) = pat {
                                let struct_mid = sid.module_id;
                                if struct_mid != caller_mid {
                                    found = true;
                                }
                            }
                        }
                    }),
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inlining_optimization.rs (L446-453)
```rust
                    ExpData::Match(_, discriminator, _) => {
                        let did = discriminator.node_id();
                        if let Type::Struct(mid, ..) = env.get_node_type(did).drop_reference() {
                            if mid != caller_mid {
                                found = true;
                            }
                        }
                    },
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/function_checker.rs (L232-280)
```rust
/// Check for access error or warning for a struct operation.
/// storage operations include `exists`, `move_to`, `move_from`, `borrow_global`, `borrow_global_mut`
fn check_for_access_error_or_warning<F>(
    env: &GlobalEnv,
    fun_env: &FunctionEnv,
    struct_env: &StructEnv,
    caller_module_id: &ModuleId,
    storage_operation: bool,
    id: &NodeId,
    oper: &str,
    msg_maker: F,
    module_env: &ModuleEnv,
    cross_module: bool,
    caller_is_inline_non_private: bool,
) where
    F: Fn() -> String,
{
    if cross_module {
        let mut err_msg = None;
        // storage operations cannot be cross-module, even for public structs
        if !storage_operation && env.language_version().language_version_for_public_struct() {
            match struct_env.get_visibility() {
                Visibility::Public => {
                    return;
                },
                Visibility::Friend => {
                    if struct_env.module_env.has_friend(caller_module_id) {
                        return;
                    }
                    let friend_str = if struct_env.has_package_visibility() {
                        "modules in the same package".to_string()
                    } else {
                        "friend modules".to_string()
                    };
                    err_msg = Some(format!("or {}", friend_str));
                },
                Visibility::Private => {},
            }
        }
        access_error(env, fun_env, id, oper, msg_maker(), err_msg, module_env);
    } else if caller_is_inline_non_private {
        if !storage_operation
            && env.language_version().language_version_for_public_struct()
            && struct_env.get_visibility() == Visibility::Public
        {
            return;
        }
        access_warning(env, fun_env, id, oper, msg_maker(), module_env);
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/function_checker.rs (L433-456)
```rust
                    ExpData::Assign(_, pat, _)
                    | ExpData::Block(_, pat, _, _)
                    | ExpData::Lambda(_, pat, _, _, _) => {
                        pat.visit_pre_post(&mut |_, pat| {
                            if let Pattern::Struct(id, str, _, _) = pat {
                                let module_id = str.module_id;
                                let struct_env = env.get_struct(str.to_qualified_id());
                                let msg_maker =
                                    || format!("unpack of `{}`", struct_env.get_full_name_str(),);
                                check_for_access_error_or_warning(
                                    env,
                                    fun_env,
                                    &struct_env,
                                    &caller_module_id,
                                    false,
                                    id,
                                    "unpacked",
                                    msg_maker,
                                    &struct_env.module_env,
                                    module_id != caller_module_id,
                                    caller_is_inline_non_private,
                                );
                            }
                        });
```
