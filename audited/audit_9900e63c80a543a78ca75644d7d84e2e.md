# Audit Report

## Title
Backup Restore System Bypasses Cryptographic Signature Verification Allowing State Corruption via Modified Backup Files

## Summary
The `read_record_bytes()` function performs no cryptographic integrity checks on backup data, and multiple restore code paths completely bypass validator signature verification. Attackers with access to backup storage can modify transaction and state snapshot data, which will be restored to validator nodes without cryptographic validation, leading to state corruption.

## Finding Description

The backup/restore system has three distinct paths that bypass cryptographic signature verification:

**Path 1: Oneoff Transaction Restore** [1](#0-0) 

The oneoff transaction restore command explicitly passes `None` for `epoch_history`, completely bypassing signature verification.

**Path 2: Oneoff State Snapshot Restore** [2](#0-1) 

Similarly, oneoff state snapshot restore passes `None` for `epoch_history`.

**Path 3: Skip Epoch Endings Flag** [3](#0-2) 

When `--skip-epoch-endings` flag is used, `epoch_history` is set to `None`.

When `epoch_history` is `None`, the signature verification is skipped: [4](#0-3) 

The core `read_record_bytes()` function that reads backup data performs no integrity checks: [5](#0-4) 

It only reads a 4-byte length prefix and the corresponding data bytes, with no signature or checksum validation.

**Attack Scenario:**
1. Attacker compromises backup storage (cloud storage, S3 bucket, network share)
2. Attacker modifies transaction backup files and corresponding proof files to create internally consistent but malicious data
3. Victim runs: `aptos-node-tool db restore oneoff transaction --transaction-manifest <malicious_backup>`
4. The restore process loads the malicious data and only verifies Merkle tree consistency (which the attacker can forge)
5. No validator signature verification occurs because `epoch_history = None`
6. Malicious state is written to the validator node's database

This breaks the **Cryptographic Correctness** and **State Consistency** invariants, as backup data should be cryptographically verified before restoration to validator nodes.

## Impact Explanation

This is a **HIGH severity** vulnerability approaching **CRITICAL**:

- **State Corruption**: Attackers can inject arbitrary state into validator nodes via modified backups, corrupting the database with transactions that were never validated by the network
- **Potential Consensus Violations**: If multiple validators restore from the same compromised backup, they could participate in consensus with corrupted state, potentially causing consensus safety violations
- **Loss of Funds**: Malicious state could include modified balances, minted tokens, or stolen funds
- **Validator Node Compromise**: Corrupted validator nodes may fail to validate blocks correctly or produce invalid state roots

The vulnerability meets HIGH severity criteria per the Aptos bug bounty (significant protocol violations, state inconsistencies requiring intervention). It approaches CRITICAL if multiple validators are affected simultaneously, as it could cause consensus safety violations.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Attacker Requirements:**
- Access to backup storage system (achievable via cloud storage misconfiguration, compromised credentials, or insider threat)
- Ability to create internally consistent Merkle proofs (technically feasible)
- Victim must use oneoff restore commands or `--skip-epoch-endings` flag

**Realistic Scenarios:**
- Many organizations use cloud storage (S3, GCS, Azure) for backups with potential security misconfigurations
- Backup storage often has weaker access controls than validator nodes
- Oneoff restore commands are documented production tools, not debug-only features
- Disaster recovery scenarios frequently involve restoring from backups

The documentation comment acknowledges this design: [6](#0-5) 

This indicates awareness that LedgerInfos are NOT checked during one-shot restoring, but lacks clear security warnings about the implications.

## Recommendation

**Immediate Fixes:**

1. **Add mandatory signature verification** to all restore paths. Remove the ability to restore with `epoch_history = None` except for genesis/bootstrap scenarios with trusted waypoints.

2. **Add cryptographic checksums** to backup files at creation time and verify them in `read_record_bytes()`:
```rust
async fn read_record_bytes(&mut self) -> Result<Option<Bytes>> {
    // Read record size + checksum
    let mut header = BytesMut::with_capacity(36); // 4 bytes size + 32 bytes hash
    self.read_full_buf_or_none(&mut header).await?;
    if header.is_empty() { return Ok(None); }
    
    let record_size = u32::from_be_bytes(header[0..4].try_into()?) as usize;
    let expected_hash = HashValue::from_slice(&header[4..36])?;
    
    // Read and verify record
    let mut record_buf = BytesMut::with_capacity(record_size);
    self.read_full_buf_or_none(&mut record_buf).await?;
    
    let actual_hash = CryptoHash::hash(&record_buf);
    ensure!(actual_hash == expected_hash, "Checksum mismatch");
    
    Ok(Some(record_buf.freeze()))
}
```

3. **Add security warnings** to oneoff restore commands documenting the lack of signature verification and recommending use only with trusted waypoints.

4. **Require trusted waypoints** for oneoff restores to provide at least checkpoint-based verification.

**Long-term Solutions:**

1. Implement end-to-end authenticated encryption for backup data using validator keys
2. Add backup manifest signatures that cover all backup files
3. Implement backup versioning and tamper-evident logs
4. Add restore validation mode that verifies restored state against live network before committing

## Proof of Concept

**Reproduction Steps:**

1. Create a legitimate backup of transaction data
2. Modify the backup files to inject malicious transactions:
   - Parse the transaction records from the backup file
   - Modify transaction data (e.g., change recipient addresses, amounts)
   - Recompute transaction hashes to maintain internal consistency
   - Create matching Merkle proofs
   - Regenerate the proof file with a fake (unsigned) LedgerInfoWithSignatures
3. Run oneoff restore command:
```bash
aptos-node-tool db restore oneoff transaction \
    --transaction-manifest ./malicious_backup/manifest.json \
    --target-db-dir ./test_db \
    --storage-backend local \
    --local-path ./malicious_backup
```
4. Verify that the restore succeeds without signature verification
5. Inspect the database to confirm malicious data was written

**Expected Result:** The restore completes successfully without any signature verification errors, and the malicious data is written to the database.

**Actual Result:** The system has no defense against modified backup data when using oneoff restore commands or `--skip-epoch-endings` flag.

## Notes

The vulnerability is exacerbated by an additional bypass in the epoch verification code: [7](#0-6) 

Even when `epoch_history` is provided, if the backup data claims to be from a newer epoch than available in the epoch history, verification is bypassed with only a warning. This provides a second attack vector that doesn't require the victim to use oneoff commands.

The core issue is that `read_record_bytes()` is a low-level I/O utility with no security awareness, and the higher-level restore logic has multiple code paths where security validation is optional or bypassable. Defense-in-depth principles suggest that even low-level utilities should provide basic integrity checks, and critical security operations like signature verification should be mandatory, not optional.

### Citations

**File:** storage/db-tool/src/restore.rs (L83-95)
```rust
                    Oneoff::StateSnapshot {
                        storage,
                        opt,
                        global,
                    } => {
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/utils/read_record_bytes.rs (L44-67)
```rust
    async fn read_record_bytes(&mut self) -> Result<Option<Bytes>> {
        let _timer = BACKUP_TIMER.timer_with(&["read_record_bytes"]);
        // read record size
        let mut size_buf = BytesMut::with_capacity(4);
        self.read_full_buf_or_none(&mut size_buf).await?;
        if size_buf.is_empty() {
            return Ok(None);
        }

        // empty record
        let record_size = u32::from_be_bytes(size_buf.as_ref().try_into()?) as usize;
        if record_size == 0 {
            return Ok(Some(Bytes::new()));
        }

        // read record
        let mut record_buf = BytesMut::with_capacity(record_size);
        self.read_full_buf_or_none(&mut record_buf).await?;
        if record_buf.is_empty() {
            bail!("Hit EOF when reading record.")
        }

        Ok(Some(record_buf.freeze()))
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```
