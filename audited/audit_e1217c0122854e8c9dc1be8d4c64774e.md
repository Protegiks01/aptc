# Audit Report

## Title
Unverified Database Proofs in StateSummary.update() Enable Consensus Violations Through Invalid Sparse Merkle Tree Construction

## Summary
The `StateSummary::update()` function uses a `ProofRead` implementation that returns database proofs without cryptographic verification in 99.99% of cases for cold state and 100% of cases for hot state. These unverified proofs are directly used by `batch_update_sorted_uniq` to construct the Sparse Merkle Tree, allowing invalid proofs from database bugs or corruption to produce incorrect state root hashes and cause consensus violations.

## Finding Description

The vulnerability exists in the proof verification flow within the state summary update mechanism:

**1. Insufficient Proof Verification**

In `ProvableStateSummary::get_proof()`, proofs are only verified probabilistically: [1](#0-0) 

For cold state, only 1 out of 10,000 proofs are cryptographically verified against the expected root hash. For hot state, there is an explicit TODO stating proofs cannot be verified at all.

**2. Unverified Proofs Used in SMT Construction**

The unverified proofs are passed to `batch_update_sorted_uniq()`: [2](#0-1) [3](#0-2) 

**3. Proofs Used Without Cryptographic Validation**

In `SubTreeUpdater`, when encountering persisted subtrees, proofs are retrieved and used with only a depth check: [4](#0-3) 

The proof structure (siblings, leaf nodes) is trusted without verifying it cryptographically matches the expected root hash. Invalid proofs with correct depth but wrong sibling hashes or leaf values will pass this check.

**4. Propagation to Consensus**

The incorrect state root hash flows into consensus: [5](#0-4) 

The `state_checkpoint_hash` from the incorrectly computed `StateSummary` becomes part of `TransactionInfo`, which is hashed into the transaction accumulator, ultimately affecting the `executed_state_id` in consensus votes.

**Attack Scenarios:**

1. **Deterministic Database Bug**: A bug in `JellyfishMerkleTree::get_with_proof_ext()` (e.g., in sharding logic, single-child node handling, or version management) returns incorrect proofs for certain edge cases. All validators hit the same bug when processing the same transaction, compute the same incorrect state root hash, and reach consensus on invalid state.

2. **Non-Deterministic Database Bug**: Race conditions or caching bugs cause some validators to receive incorrect proofs while others get correct ones. Validators disagree on state root hashes, preventing quorum and causing network partition.

3. **Database Corruption**: Disk errors or bit flips corrupt stored Merkle tree nodes. The corrupted validator computes incorrect state root hashes and cannot participate in consensus.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact categories:

1. **Consensus/Safety Violation**: If a deterministic database bug exists that affects all validators identically, they will collectively commit to an incorrect state root hash, violating the fundamental "Deterministic Execution" invariant that requires all validators to produce identical state roots for identical blocks.

2. **Network Partition**: If database bugs affect different validators differently, they will compute different state root hashes for the same block, causing irreconcilable disagreement and requiring a hard fork to resolve.

3. **State Consistency Violation**: Invalid proofs lead to incorrect Sparse Merkle Tree construction, breaking the "State Consistency" invariant that state transitions must be verifiable via Merkle proofs.

The 99.99% lack of verification for cold state and 100% lack for hot state means these errors propagate silently into production consensus without detection.

## Likelihood Explanation

**Medium to High Likelihood:**

1. **Database Implementation Complexity**: The Jellyfish Merkle tree implementation is complex with features like sharding, single-child node optimization, versioning, and caching. Bugs in this logic are plausible.

2. **Edge Cases**: The code at line 744-751 shows special handling for nodes with single children during sharding, and line 729-797 shows complex traversal logic with multiple edge cases where bugs could exist. [6](#0-5) 

3. **Acknowledged Issue**: The TODO comment explicitly acknowledges that hot state proofs cannot be verified, indicating the team is aware of the verification gap.

4. **Natural Occurrence**: Database corruption from hardware failures, though rare, can occur naturally without attacker involvement.

5. **Detection Difficulty**: The 1/10000 verification rate means bugs could go undetected through extensive testing and only manifest in production under specific conditions.

## Recommendation

**Immediate Fix: Always Verify Proofs Cryptographically**

```rust
fn get_proof(
    &self,
    key: &HashValue,
    version: Version,
    root_depth: usize,
    use_hot_state: bool,
) -> Result<SparseMerkleProofExt> {
    let expected_root = if use_hot_state {
        self.state_summary.hot_state_summary.root_hash()
    } else {
        self.state_summary.global_state_summary.root_hash()
    };
    
    let (val_opt, proof) = self.db.get_state_value_with_proof_by_version_ext(
        key,
        version,
        root_depth,
        use_hot_state,
    )?;
    
    // ALWAYS verify the proof before using it
    proof.verify(expected_root, *key, val_opt.as_ref())?;
    
    Ok(proof)
}
```

**For Hot State**: Implement proper value reconstruction to enable verification, or use an alternative validation mechanism that doesn't require full value reconstruction.

**Performance Mitigation**: If verification performance is a concern:
- Cache verified proofs per key-version pair
- Use parallel verification for batched proof requests
- Optimize the `SparseMerkleProofExt::verify()` implementation

**Defense in Depth**: Add explicit state root hash cross-validation between validators before finalizing blocks to detect divergence early.

## Proof of Concept

```rust
// This test demonstrates the vulnerability by showing that batch_update_sorted_uniq
// accepts and uses unverified proofs without checking them against the root hash

#[cfg(test)]
mod poc {
    use aptos_crypto::HashValue;
    use aptos_scratchpad::{ProofRead, SparseMerkleTree};
    use aptos_types::proof::{SparseMerkleProofExt, SparseMerkleLeafNode, NodeInProof};
    
    // Malicious ProofRead that returns invalid proofs
    struct MaliciousProofReader {
        wrong_sibling_hash: HashValue,
    }
    
    impl ProofRead for MaliciousProofReader {
        fn get_proof(&self, _key: &HashValue, _root_depth: usize) -> Option<SparseMerkleProofExt> {
            // Return a proof with an incorrect sibling hash
            Some(SparseMerkleProofExt::new_partial(
                None,
                vec![NodeInProof::Other(self.wrong_sibling_hash)],
                0,
            ))
        }
    }
    
    #[test]
    fn test_unverified_proof_accepted() {
        // Create a base SMT
        let base_smt = SparseMerkleTree::new_empty();
        let frozen = base_smt.freeze(&base_smt);
        
        // Create malicious proof reader with wrong hash
        let malicious_reader = MaliciousProofReader {
            wrong_sibling_hash: HashValue::random(),
        };
        
        // Create an update
        let key = HashValue::random();
        let value = HashValue::random();
        let updates = vec![(key, Some(value))];
        
        // batch_update_sorted_uniq accepts the invalid proof without verification
        // This will produce an incorrect SMT structure
        let result = frozen.batch_update_sorted_uniq(&updates, &malicious_reader);
        
        // The update succeeds despite invalid proofs
        assert!(result.is_ok(), "Invalid proof was accepted without verification");
        
        // The resulting SMT has an incorrect structure
        let new_smt = result.unwrap().unfreeze();
        
        // This root hash is wrong because it was computed using invalid proofs
        let root_hash = new_smt.root_hash();
        println!("Incorrect root hash computed: {:?}", root_hash);
        
        // In a real scenario, different validators would get different proofs
        // and compute different root hashes, breaking consensus
    }
}
```

**Notes:**
- The vulnerability is architectural: the system trusts database proofs without verification
- The 1/10000 verification rate for cold state is insufficient for production security
- The 0/infinity verification rate for hot state is explicitly acknowledged as unimplemented
- Database bugs or corruption can occur naturally without attacker involvement
- The impact is consensus violation, which is Critical severity per Aptos bug bounty program
- Fixing requires always verifying proofs cryptographically before using them in SMT construction

### Citations

**File:** storage/storage-interface/src/state_store/state_summary.rs (L135-139)
```rust
        Ok(self
            .hot_state_summary
            .freeze(&persisted.hot_state_summary)
            .batch_update_sorted_uniq(&hot_smt_updates, &HotProvableStateSummary::new(persisted))?
            .unfreeze())
```

**File:** storage/storage-interface/src/state_store/state_summary.rs (L169-173)
```rust
        Ok(self
            .global_state_summary
            .freeze(&persisted.global_state_summary)
            .batch_update_sorted_uniq(&smt_updates, &ColdProvableStateSummary::new(persisted))?
            .unfreeze())
```

**File:** storage/storage-interface/src/state_store/state_summary.rs (L300-323)
```rust
        // TODO(HotState): we cannot verify proof yet. In order to verify the proof, we need to
        // fetch and construct the corresponding `HotStateValue` for `key` at `version`, including
        // `hot_since_version`. However, the current in-memory hot state does not support this
        // query, and we might need persist hot state KV to db first.
        if !use_hot_state && rand::random::<usize>() % 10000 == 0 {
            // 1 out of 10000 times, verify the proof.
            let (val_opt, proof) = self
                .db
                // check the full proof
                .get_state_value_with_proof_by_version_ext(
                    key, version, /* root_depth = */ 0, /* use_hot_state = */ false,
                )?;
            proof.verify(
                self.state_summary.global_state_summary.root_hash(),
                *key,
                val_opt.as_ref(),
            )?;
            Ok(proof)
        } else {
            Ok(self
                .db
                .get_state_proof_by_version_ext(key, version, root_depth, use_hot_state)?)
        }
    }
```

**File:** storage/scratchpad/src/sparse_merkle/updater.rs (L150-166)
```rust
    fn from_persisted(
        a_descendant_key: &HashValue,
        depth: usize,
        proof_reader: &impl ProofRead,
    ) -> Result<Self> {
        let proof = proof_reader
            .get_proof(a_descendant_key, depth)
            .ok_or(UpdateError::MissingProof)?;
        if depth > proof.bottom_depth() {
            return Err(UpdateError::ShortProof {
                key: *a_descendant_key,
                num_siblings: proof.bottom_depth(),
                depth,
            });
        }
        Ok(Self::new_on_proof_path(proof, depth))
    }
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L68-88)
```rust
                let state_checkpoint_hash = state_checkpoint_hashes[i];
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
                let write_set_hash = CryptoHash::hash(txn_output.write_set());
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
                );
```

**File:** storage/jellyfish-merkle/src/lib.rs (L743-752)
```rust
                Node::Internal(internal_node) => {
                    if internal_node.leaf_count() == 1 {
                        // Logically this node should be a leaf node, it got pushed down for
                        // sharding, skip the siblings.
                        let (only_child_nibble, Child { version, .. }) =
                            internal_node.children_sorted().next().unwrap();
                        next_node_key =
                            next_node_key.gen_child_node_key(*version, *only_child_nibble);
                        continue;
                    }
```
