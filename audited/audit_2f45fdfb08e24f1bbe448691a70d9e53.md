# Audit Report

## Title
Access Control Bypass via Empty Inclusions with Non-Empty Exclusions in Move VM

## Summary
The `AccessSpecifier::enables()` function contains logic that grants access when inclusions are empty but exclusions are non-empty, creating an "allow-by-default" semantics that contradicts the documented "deny-by-default" security model. This enables unauthorized resource access in the Move VM.

## Finding Description

The access control system in the Move VM uses `AccessSpecifier::Constraint(inclusions, exclusions)` to enforce resource access permissions. [1](#0-0) 

The documented semantics state: "Access is allowed if (a) any of the inclusion specifiers allows it (union of inclusion specifiers) (b) none of the exclusions specifiers disallows it (intersection of exclusion specifiers)." [2](#0-1) 

However, the implementation at line 149 contains special-case logic: [3](#0-2) 

This logic evaluates `(incls.is_empty() && !excls.is_empty())` first. When true, it grants access to ANY resource that doesn't match an exclusion, effectively creating "allow-all-except" semantics instead of the documented "deny-by-default" model.

**Attack Scenario:**

1. A developer writes a Move function with access specifier `!reads CriticalGovernanceResource`, intending to deny all access while specifically prohibiting reads of critical governance data
2. The developer expects this to require additional explicit inclusions (like `reads SafeResource`) to grant any access
3. Instead, the function can read ANY resource in the system except `CriticalGovernanceResource`, including validator stake pools, user balances, and other sensitive state
4. When `borrow_global` operations execute, the access check is performed: [4](#0-3) 
5. The check calls into `AccessControlState::check_access()`: [5](#0-4) 
6. This invokes `enables()` which incorrectly grants access due to the short-circuit logic

**Invariant Violation:**

This breaks **Critical Invariant #8: Access Control** - "System addresses (@aptos_framework, @core_resources) must be protected" - as functions with only exclusions can access protected resources they shouldn't be able to access.

The property tests inadequately validate this behavior, only testing accesses that match exclusions: [6](#0-5) 

The tests never verify that accesses NOT matching exclusions are denied when inclusions are empty.

## Impact Explanation

**High Severity** - This enables unauthorized resource access that could lead to:

1. **Consensus splits**: Different validator implementations or versions interpreting the ambiguous semantics differently could cause divergent execution outcomes for the same transaction
2. **Access control bypass**: Functions can access sensitive resources (governance state, stake pools, user funds) without explicit permission
3. **Privilege escalation**: Malicious modules deployed with "minimal" access specifiers (only exclusions) gain broad access to the system

While not directly causing fund loss, this violates the Move VM's security model and could enable sophisticated attacks when combined with other vulnerabilities.

## Likelihood Explanation

**Medium likelihood** - Requires:
- A developer misunderstanding the access control semantics (plausible given documentation inconsistency)
- Deployment of a module using only exclusion specifiers
- Exploitation through unexpected resource access

The semantic ambiguity makes this realistic, especially as the codebase scales and more developers write Move code.

## Recommendation

Remove the special-case logic and enforce deny-by-default semantics:

```rust
pub fn enables(&self, access: &AccessInstance) -> bool {
    use AccessSpecifier::*;
    match self {
        Any => true,
        Constraint(incls, excls) => {
            // Access requires at least one inclusion match AND no exclusion matches
            incls.iter().any(|c| c.includes(access))
                && excls.iter().all(|c| !c.excludes(access))
        },
    }
}
```

Update documentation to clarify that empty inclusions always deny access, and pure-exclusion specifiers are invalid (should be rejected at compile time or treated as denying all access).

## Proof of Concept

```move
module 0x1::exploit {
    use std::signer;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    struct CriticalResource has key { value: u64 }
    
    // Developer intends to deny all access except to prohibit reads of CriticalResource
    // But due to the bug, this can read ANY other resource including user balances
    public fun bypass_access() !reads CriticalResource acquires coin::CoinStore {
        // This should FAIL but will SUCCEED due to empty inclusions with non-empty exclusions
        // Can read user coin balances without explicit permission
        let balance = coin::balance<AptosCoin>(@victim_address);
        // Exploit continues...
    }
}
```

Compile and deploy this module, then call `bypass_access()`. The access check will incorrectly grant access to `CoinStore` resources despite no explicit inclusion allowing it.

### Citations

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L50-53)
```rust
    /// The inclusions are a _disjunction_ and the exclusions a _conjunction_ of
    /// access clauses. An access is valid if it is enabled by any of the
    /// inclusions, and not enabled for each of the exclusions.
    Constraint(Vec<AccessSpecifierClause>, Vec<AccessSpecifierClause>),
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L148-151)
```rust
            Constraint(incls, excls) => {
                (incls.is_empty() && !excls.is_empty() || incls.iter().any(|c| c.includes(access)))
                    && excls.iter().all(|c| !c.excludes(access))
            },
```

**File:** third_party/move/move-model/src/model.rs (L5111-5115)
```rust
    /// If this is `None`, all accesses are allowed. If the list is empty,
    /// no accesses are allowed. Otherwise the list is divided into _inclusions_ and _exclusions_,
    /// the later being negated specifiers. Access is allowed if (a) any of the inclusion
    /// specifiers allows it (union of inclusion specifiers) (b) none of the exclusions
    /// specifiers disallows it (intersection of exclusion specifiers).
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1389-1398)
```rust
        self.check_access(
            runtime_environment,
            if is_mut {
                AccessKind::Writes
            } else {
                AccessKind::Reads
            },
            ty,
            addr,
        )?;
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L69-77)
```rust
    pub(crate) fn check_access(&self, access: AccessInstance) -> PartialVMResult<()> {
        for specifier in self.specifier_stack.iter().rev() {
            if !specifier.enables(&access) {
                return Err(PartialVMError::new(StatusCode::ACCESS_DENIED)
                    .with_message(format!("not allowed to perform `{}`", access)));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifiers_prop_tests.rs (L33-39)
```rust
        let excl = AccessSpecifier::Constraint(vec![], clauses.clone());
        assert!(incl.enables(&access1));
        assert!(incl.enables(&access2));
        assert!(!incl_excl.enables(&access1));
        assert!(!incl_excl.enables(&access2));
        assert!(!excl.enables(&access1));
        assert!(!excl.enables(&access2));
```
