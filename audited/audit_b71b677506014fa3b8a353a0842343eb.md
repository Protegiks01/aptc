# Audit Report

## Title
Concurrent File Write Race Condition in On-Chain Package Cache Leads to Data Corruption

## Summary
The `fetch_on_chain_package()` function in the Move package cache spawns concurrent tasks that write module files without synchronization. When a maliciously crafted `PackageMetadata` contains duplicate module names, multiple threads write to the same file simultaneously, causing a race condition that can corrupt cached bytecode files.

## Finding Description

The vulnerability exists in the package fetching logic that downloads on-chain Move packages for local compilation and dependency resolution. [1](#0-0) 

The code iterates through `package.modules` and spawns concurrent tasks to download and write each module. The file path is constructed solely from the module name, with no deduplication check: [2](#0-1) 

If two modules have the same name, both tasks compute identical file paths and concurrently execute `File::create()` and `write_all()` operations in separate `spawn_blocking` threads, creating a data race.

**Attack Vector**: An attacker can publish a package with duplicate module names in its metadata by exploiting a validation gap in the publishing logic.

The Move code validation extracts module names without checking for duplicates within the same package: [3](#0-2) 

The `check_coexistence` function only validates that module names don't clash with OTHER packages, not within the same package: [4](#0-3) 

When the module names are passed to the native function, they are converted to a `BTreeSet` which deduplicates them: [5](#0-4) 

The VM's validation checks that the bytecode modules match the expected set, but since the set is deduplicated, an attacker can provide PackageMetadata with `modules: [M1, M2, M1]` and bytecode `[M1_bytes, M2_bytes]`: [6](#0-5) [7](#0-6) 

The malformed PackageMetadata is then stored on-chain without modification: [8](#0-7) 

**Exploitation Steps**:
1. Attacker constructs PackageMetadata with duplicate module entries: `modules: [ModuleMetadata{name:"M1"}, ModuleMetadata{name:"M2"}, ModuleMetadata{name:"M1"}]`
2. Provides bytecode for only 2 unique modules: `[M1_bytes, M2_bytes]`
3. Calls `publish_package_txn()` with the crafted metadata
4. Validation passes because `expected_modules = {"M1", "M2"}` (deduplicated) matches the bytecode
5. PackageMetadata with duplicates is stored on-chain
6. When any developer or node fetches this package, concurrent downloads of "M1" trigger the race condition
7. `File::create()` truncates the file, and concurrent writes from both threads cause non-deterministic file corruption

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **API Crashes**: Corrupted cached modules cause compilation failures when other packages depend on the malicious package. This can crash developer tools and potentially API services that perform package resolution.

2. **Denial of Service**: The attack can prevent legitimate developers from compiling packages that depend on the corrupted package, disrupting the development ecosystem.

3. **Validator Node Slowdowns**: If validator nodes attempt to compile or verify packages with this issue during operations (e.g., when processing governance proposals involving code), repeated failures could cause node slowdowns.

4. **State Inconsistency**: Different nodes may cache different corrupted versions depending on the race condition outcome, leading to non-deterministic compilation results across the network.

The race condition involves `File::create()` which truncates the file. If Thread A creates and partially writes, then Thread B truncates and writes, the final file may be incomplete or corrupted depending on thread scheduling.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements**:
- Attacker needs code publishing permission (typically granted to user accounts)
- Must craft malicious BCS-serialized PackageMetadata
- No validator-level access required

**Complexity**: 
- Moderate - requires understanding of BCS serialization and the validation gap
- The attack is deterministic once the malformed package is published

**Triggering**:
- Automatic - occurs whenever anyone attempts to fetch the malicious package
- Affects all developers and nodes trying to compile dependencies

The validation gap is non-obvious but exploitable by any sophisticated attacker with basic publishing permissions. Once exploited, it affects all users of the package cache.

## Recommendation

**Fix 1**: Add duplicate detection in the Move code before storing PackageMetadata:

```move
fun get_module_names(pack: &PackageMetadata): vector<String> {
    let module_names = vector::empty();
    vector::for_each_ref(&pack.modules, |pack_module| {
        let pack_module: &ModuleMetadata = pack_module;
        let name = pack_module.name;
        // Check for duplicates within the same package
        assert!(!vector::contains(&module_names, &name), 
                error::already_exists(EMODULE_NAME_CLASH));
        vector::push_back(&mut module_names, name);
    });
    module_names
}
```

**Fix 2**: Add synchronization in package_cache.rs to prevent concurrent writes:

```rust
// Before the concurrent download loop
let mut module_paths = std::collections::HashSet::new();
for module in &package.modules {
    let module_file_path = temp.path().join(&module.name).with_extension("mv");
    if !module_paths.insert(module_file_path) {
        bail!("Duplicate module name detected in package: {}", module.name);
    }
}
```

**Recommended**: Implement both fixes for defense-in-depth.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_duplicate_module_race_condition() {
    use aptos_framework::natives::code::{PackageMetadata, ModuleMetadata, UpgradePolicy};
    use move_package_cache::PackageCache;
    
    // Create malicious PackageMetadata with duplicate module names
    let malicious_metadata = PackageMetadata {
        name: "MaliciousPackage".to_string(),
        upgrade_policy: UpgradePolicy::compat(),
        upgrade_number: 0,
        source_digest: "hash".to_string(),
        manifest: vec![],
        modules: vec![
            ModuleMetadata {
                name: "DuplicateModule".to_string(),
                source: vec![],
                source_map: vec![],
                extension: None,
            },
            ModuleMetadata {
                name: "NormalModule".to_string(),
                source: vec![],
                source_map: vec![],
                extension: None,
            },
            ModuleMetadata {
                name: "DuplicateModule".to_string(), // DUPLICATE!
                source: vec![],
                source_map: vec![],
                extension: None,
            },
        ],
        deps: vec![],
        extension: None,
    };
    
    // Serialize and publish via publish_package_txn
    let metadata_bytes = bcs::to_bytes(&malicious_metadata).unwrap();
    
    // Create bytecode for only 2 unique modules
    let module_bytecode = vec![
        create_dummy_module_bytecode("DuplicateModule"),
        create_dummy_module_bytecode("NormalModule"),
    ];
    
    // Publish to blockchain (would pass validation due to deduplication)
    // publish_package_txn(owner, metadata_bytes, module_bytecode);
    
    // Later, when fetching the package:
    let cache = PackageCache::new(temp_dir).unwrap();
    
    // This triggers the race condition with 2 threads writing to "DuplicateModule.mv"
    let result = cache.fetch_on_chain_package(
        &fullnode_url,
        network_version,
        address,
        "MaliciousPackage"
    ).await;
    
    // File may be corrupted due to concurrent writes
    assert!(result.is_err() || file_is_corrupted(&result.unwrap()));
}
```

### Citations

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L366-397)
```rust
        let fetch_futures = package.modules.iter().map(|module| {
            let client = client.clone();
            let temp_path = temp.path().to_owned();
            let package_name = package_name.to_string();
            let module_name = module.name.clone();

            async move {
                let module_bytes = client
                    .get_account_module_bcs_at_version(address, &module_name, network_version)
                    .await?
                    .into_inner();

                let module_file_path = temp_path.join(&module_name).with_extension("mv");

                // Use blocking file write in spawn_blocking to avoid blocking the async runtime
                tokio::task::spawn_blocking(move || {
                    fs::create_dir_all(module_file_path.parent().unwrap())?;
                    let mut file = File::create(&module_file_path)?;
                    file.write_all(&module_bytes)?;
                    Ok::<(), std::io::Error>(())
                })
                .await??;

                // Notify listener after writing
                self.listener.on_bytecode_package_receive_module(
                    address,
                    &package_name,
                    &module_name,
                );
                Ok::<(), anyhow::Error>(())
            }
        });
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L207-214)
```text
        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L282-293)
```text
    fun check_coexistence(old_pack: &PackageMetadata, new_modules: &vector<String>) {
        // The modules introduced by each package must not overlap with `names`.
        vector::for_each_ref(&old_pack.modules, |old_mod| {
            let old_mod: &ModuleMetadata = old_mod;
            let j = 0;
            while (j < vector::length(new_modules)) {
                let name = vector::borrow(new_modules, j);
                assert!(&old_mod.name != name, error::already_exists(EMODULE_NAME_CLASH));
                j = j + 1;
            };
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L355-362)
```text
    fun get_module_names(pack: &PackageMetadata): vector<String> {
        let module_names = vector::empty();
        vector::for_each_ref(&pack.modules, |pack_module| {
            let pack_module: &ModuleMetadata = pack_module;
            vector::push_back(&mut module_names, pack_module.name);
        });
        module_names
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L326-333)
```rust
    let mut expected_modules = BTreeSet::new();
    for name in safely_pop_arg!(args, Vec<Value>) {
        let str = get_move_string(name)?;

        // TODO(Gas): fine tune the gas formula
        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(str.len() as u64))?;
        expected_modules.insert(str);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1692-1698)
```rust
        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1733-1737)
```rust
        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
```
