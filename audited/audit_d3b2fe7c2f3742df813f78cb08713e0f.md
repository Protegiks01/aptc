# Audit Report

## Title
Write Lock Contention in Gas Price Estimation Causes API Denial of Service

## Summary
The `estimate_gas_price()` function in `api/src/context.rs` holds a write lock on `gas_estimation_cache` while performing expensive database queries spanning up to 120 blocks. This allows unprivileged attackers to cause API denial of service by sending concurrent requests to the `/estimate_gas_price` endpoint, blocking all other threads waiting for the lock.

## Finding Description
The vulnerability exists in the gas price estimation logic which uses a read-write lock pattern with database operations performed while holding the write lock. [1](#0-0) 

After acquiring the write lock, the function performs expensive database operations while still holding it: [2](#0-1) 

For each block, it calls `block_min_inclusion_price()` which performs additional database queries: [3](#0-2) 

The `block_min_inclusion_price()` function calls `get_gas_prices_and_used()` which creates transaction iterators: [4](#0-3) 

With the default configuration, this processes up to 120 blocks: [5](#0-4) 

The `/estimate_gas_price` API endpoint is publicly accessible: [6](#0-5) 

**Attack Path:**
1. Attacker sends multiple concurrent GET requests to `/estimate_gas_price`
2. When cache expires (every 500ms by default), the first request acquires the write lock
3. While holding the lock, the thread processes up to 120 blocks worth of transactions from the database
4. All other concurrent requests are blocked at the `write()` lock acquisition
5. Requests queue up, eventually timing out or exhausting thread pool resources
6. Legitimate API users experience degraded service or timeouts

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" by allowing unbounded lock contention to exhaust API resources.

## Impact Explanation
This is a **Low Severity** vulnerability as explicitly indicated in the security question. While it can cause API denial of service, the impact is limited to:
- Only affects the `/estimate_gas_price` endpoint, not core blockchain operations
- Does not impact consensus, execution, or storage layers
- Does not affect validator operations or funds
- Automatic recovery once attack traffic subsides
- Natural mitigation through cache expiration (500ms)

Per the Aptos bug bounty criteria, this falls under "Low Severity: Non-critical implementation bugs" rather than "High Severity: API crashes" because it causes slowdown/unresponsiveness rather than actual crashes.

## Likelihood Explanation
**Likelihood: High**

The attack requires:
- No authentication or special privileges
- Simple HTTP GET requests to a public endpoint
- Minimal resources (standard HTTP client)
- No knowledge of internal implementation details

The vulnerability triggers whenever:
- Cache is expired (every 500ms)
- Multiple concurrent requests arrive
- Node is configured with default gas estimation settings

## Recommendation
Implement one of the following mitigations:

**Option 1: Perform expensive work outside the write lock**
```rust
// Compute gas estimation without holding the lock
let estimation = self.compute_gas_estimation_unlocked(ledger_info, config, &execution_config)?;

// Acquire lock only for cache update
let mut cache = self.gas_estimation_cache.write().unwrap();
if let Some(cached) = self.cached_gas_estimation(&cache, epoch) {
    return Ok(cached);
}
self.update_cached_gas_estimation(&mut cache, epoch, estimation);
```

**Option 2: Use async mutex with timeout**
Replace `RwLock` with `tokio::sync::RwLock` and implement request timeout to prevent indefinite blocking.

**Option 3: Add rate limiting**
Implement per-IP rate limiting on the `/estimate_gas_price` endpoint to prevent concurrent request floods.

**Option 4: Use optimistic concurrency**
Allow multiple threads to compute gas estimation concurrently, only use lock for final cache update with last-write-wins semantics.

## Proof of Concept

```rust
// Concurrent request PoC - Rust test
#[tokio::test]
async fn test_gas_estimation_lock_contention() {
    use std::sync::Arc;
    use tokio::task;
    
    // Setup test node with API context
    let context = Arc::new(/* initialize test context */);
    
    // Spawn 50 concurrent requests
    let mut handles = vec![];
    for _ in 0..50 {
        let ctx = context.clone();
        handles.push(task::spawn(async move {
            let start = std::time::Instant::now();
            // Call estimate_gas_price
            let result = ctx.estimate_gas_price(&ledger_info);
            let duration = start.elapsed();
            (result, duration)
        }));
    }
    
    // Wait for all requests
    let results: Vec<_> = futures::future::join_all(handles).await;
    
    // Verify: Most requests should experience significant delays
    // due to lock contention (>100ms when first request holds lock)
    let delayed_count = results.iter()
        .filter(|r| r.as_ref().unwrap().1 > Duration::from_millis(100))
        .count();
    
    assert!(delayed_count > 40, "Expected lock contention delays");
}
```

**HTTP-based PoC:**
```bash
# Send 100 concurrent requests
for i in {1..100}; do
  curl -X GET http://node-api:8080/v1/estimate_gas_price &
done
wait

# Monitor response times - later requests will show significant delays
```

## Notes
The cache expiration time is 500ms by default [7](#0-6) , meaning this contention occurs frequently under load. The double-checked locking pattern [8](#0-7)  prevents redundant computation but doesn't prevent the lock contention issue when cache is genuinely expired.

### Citations

**File:** api/src/context.rs (L1181-1184)
```rust
        let txns = self.db.get_transaction_iterator(start_version, limit)?;
        let infos = self
            .db
            .get_transaction_info_iterator(start_version, limit)?;
```

**File:** api/src/context.rs (L1313-1317)
```rust
        let mut cache = self.gas_estimation_cache.write().unwrap();
        // Retry cached result after acquiring write lock
        if let Some(cached_gas_estimation) = self.cached_gas_estimation(&cache, epoch) {
            return Ok(cached_gas_estimation);
        }
```

**File:** api/src/context.rs (L1325-1359)
```rust
        let max_block_history = config.aggressive_block_history;
        // 1. Get the block metadata txns
        let mut lookup_version = ledger_info.ledger_version.0;
        let mut blocks = vec![];
        // Skip the first block, which may be partial
        if let Ok((first, _, block)) = self.db.get_block_info_by_version(lookup_version) {
            if block.epoch() == epoch {
                lookup_version = first.saturating_sub(1);
            }
        }
        let mut cached_blocks_hit = false;
        for _i in 0..max_block_history {
            if cache
                .min_inclusion_prices
                .contains_key(&(epoch, lookup_version))
            {
                cached_blocks_hit = true;
                break;
            }
            match self.db.get_block_info_by_version(lookup_version) {
                Ok((first, last, block)) => {
                    if block.epoch() != epoch {
                        break;
                    }
                    lookup_version = first.saturating_sub(1);
                    blocks.push((first, last));
                    if lookup_version == 0 {
                        break;
                    }
                },
                Err(_) => {
                    break;
                },
            }
        }
```

**File:** api/src/context.rs (L1371-1379)
```rust
        for (first, last) in blocks {
            let min_inclusion_price = self
                .block_min_inclusion_price(ledger_info, first, last, config, &execution_config)
                .unwrap_or(min_gas_unit_price);
            min_inclusion_prices.push(min_inclusion_price);
            cache
                .min_inclusion_prices
                .insert((epoch, last), min_inclusion_price);
        }
```

**File:** config/src/config/gas_estimation_config.rs (L46-46)
```rust
            aggressive_block_history: 120,
```

**File:** config/src/config/gas_estimation_config.rs (L47-47)
```rust
            cache_expiration_ms: 500,
```

**File:** api/src/transactions.rs (L811-825)
```rust
    #[oai(
        path = "/estimate_gas_price",
        method = "get",
        operation_id = "estimate_gas_price",
        tag = "ApiTags::Transactions"
    )]
    async fn estimate_gas_price(&self, accept_type: AcceptType) -> BasicResult<GasEstimation> {
        fail_point_poem("endpoint_encode_submission")?;
        self.context
            .check_api_output_enabled("Estimate gas price", &accept_type)?;

        let context = self.context.clone();
        api_spawn_blocking(move || {
            let latest_ledger_info = context.get_latest_ledger_info()?;
            let gas_estimation = context.estimate_gas_price(&latest_ledger_info)?;
```
