# Audit Report

## Title
Unfiltered Consensus Metrics Exposure via Inspection Service Enables Validator Profiling and Timing Analysis

## Summary
The Aptos inspection service exposes all Prometheus metrics including sensitive consensus state information (round numbers, voting patterns, timeout values) through unauthenticated HTTP endpoints at `/json_metrics` and `/metrics` without any access control or filtering mechanism.

## Finding Description
The inspection service's metrics endpoints expose comprehensive consensus state information to any network-accessible client: [1](#0-0) 

This function calls into the metrics utility that gathers ALL registered Prometheus metrics: [2](#0-1) 

The metrics gathering function collects all metrics from the global Prometheus registry without any filtering: [3](#0-2) 

This exposes highly sensitive consensus metrics defined in the consensus counters module, including: [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

The service binds to all network interfaces by default with no authentication: [9](#0-8) 

Unlike other sensitive endpoints (configuration, identity, peer information), there is NO configuration flag to disable metrics exposure, and tests confirm metrics are always accessible: [10](#0-9) 

The voting power metrics are updated in real-time as votes are processed: [11](#0-10) 

## Impact Explanation
This vulnerability represents an **information disclosure** issue rather than a direct consensus attack. Per the Aptos bug bounty program criteria, this falls under **Low Severity** ("Minor information leaks" - up to $1,000).

While the exposed information includes consensus-critical data (round numbers, voting patterns, validator participation), it does **not** directly:
- Cause loss of funds
- Violate consensus safety or liveness
- Create state inconsistencies
- Enable validator slowdowns or crashes

The primary attack vectors this information enables—timing-based network attacks, coordinated message delays, targeted validator DoS—are **explicitly out of scope** per the bug bounty rules ("Network-level DoS attacks are out of scope").

## Likelihood Explanation
**Likelihood: HIGH** - Any attacker with network access to a validator node's inspection service port (default 9101) can trivially extract this information via simple HTTP GET requests. The service binds to `0.0.0.0` by default, making it accessible from any network interface unless specifically firewalled.

However, the **severity impact remains LOW** because:
1. The information disclosed does not directly break consensus invariants
2. Exploiting this information requires out-of-scope network attacks
3. The design appears intentional (no disable flag, always returns 200 OK)
4. Similar metric exposure is common in other blockchain implementations

## Recommendation
While this is LOW severity per bug bounty criteria, best practices suggest:

1. **Add access control**: Implement authentication for metrics endpoints similar to the admin service
2. **Add configuration flag**: Add `expose_metrics` boolean to `InspectionServiceConfig`
3. **Filter sensitive metrics**: Create allowlist of safe metrics for public exposure
4. **Network isolation**: Document that inspection service should be firewalled or bound to localhost
5. **Metric sanitization**: Implement filtering logic in `get_metric_families()` to exclude consensus-sensitive counters

Example fix structure (not full implementation):
```rust
// In inspection_service_config.rs
pub struct InspectionServiceConfig {
    pub expose_metrics: bool,  // Add flag
    pub expose_filtered_metrics_only: bool,  // Add filtering option
    // ... existing fields
}

// In metrics.rs
pub fn handle_json_metrics_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    if !node_config.inspection_service.expose_metrics {
        return (StatusCode::FORBIDDEN, Body::from("Metrics disabled"), CONTENT_TYPE_TEXT.into());
    }
    // ... existing code with optional filtering
}
```

## Proof of Concept
```bash
# Extract all consensus metrics from a validator node
curl http://<validator-ip>:9101/json_metrics | jq '.' | grep -E "(current_round|voted_power|voting_power|timeout)"

# Expected output includes:
# "aptos_consensus_current_round": "12345"
# "aptos_consensus_last_committed_round": "12344"  
# "aptos_consensus_current_round_voted_power{peer_id=\"0x...\",hash_index=\"0\"}": "100"
# "aptos_consensus_round_timeout_s": "3000"
# ... and many more sensitive consensus metrics

# This information can be polled continuously to track:
# - Real-time consensus progress
# - Which validators are voting and when
# - Voting power distribution
# - Round timeout values
# - Validator participation patterns
```

**Note:** This is classified as **Low Severity** per bug bounty criteria despite containing consensus-critical information, because the enabled attacks are out of scope and the disclosure does not directly violate protocol invariants.

### Citations

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L66-70)
```rust
/// Handles a new metrics request (with JSON encoding)
pub fn handle_json_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(JsonEncoder);
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_JSON.into())
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L31-47)
```rust
/// A simple utility function that encodes the metrics using the given encoder
pub fn get_encoded_metrics(encoder: impl Encoder) -> Vec<u8> {
    // Gather and encode the metrics
    let metric_families = get_metric_families();
    let mut encoded_buffer = vec![];
    if let Err(error) = encoder.encode(&metric_families, &mut encoded_buffer) {
        error!("Failed to encode metrics! Error: {}", error);
        return vec![];
    }

    // Update the total metric bytes counter
    NUM_METRICS
        .with_label_values(&["total_bytes"])
        .inc_by(encoded_buffer.len() as u64);

    encoded_buffer
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L49-79)
```rust
/// A simple utility function that returns all metric families
fn get_metric_families() -> Vec<MetricFamily> {
    let metric_families = aptos_metrics_core::gather();
    let mut total: u64 = 0;
    let mut families_over_2000: u64 = 0;

    // Take metrics of metric gathering so we know possible overhead of this process
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
        }
        total = total.saturating_add(family_count as u64);
    }

    // These metrics will be reported on the next pull, rather than create a new family
    NUM_METRICS.with_label_values(&["total"]).inc_by(total);
    NUM_METRICS
        .with_label_values(&["families_over_2000"])
        .inc_by(families_over_2000);

    metric_families
}
```

**File:** consensus/src/counters.rs (L78-85)
```rust
/// This counter is set to the round of the highest committed block.
pub static LAST_COMMITTED_ROUND: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_last_committed_round",
        "This counter is set to the round of the highest committed block."
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L557-564)
```rust
pub static CONSENSUS_CURRENT_ROUND_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id", "hash_index"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L587-594)
```rust
pub static CONSENSUS_LAST_VOTE_ROUND: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_voted_round",
        "for each peer_id, last round we've seen consensus vote",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L619-626)
```rust
/// This counter is set to the last round reported by the local round_state.
pub static CURRENT_ROUND: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_current_round",
        "This counter is set to the last round reported by the local round_state."
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L674-681)
```rust
/// The timeout of the current round.
pub static ROUND_TIMEOUT_MS: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_round_timeout_s",
        "The timeout of the current round."
    )
    .unwrap()
});
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/tests.rs (L98-112)
```rust
#[tokio::test]
async fn test_inspect_json_metrics() {
    // Create a validator config
    let config = NodeConfig::get_default_validator_config();

    // Increment a counter and get the JSON metrics
    INT_COUNTER.inc();
    let mut response = send_get_request_to_path(&config, JSON_METRICS_PATH).await;
    let response_body = body::to_bytes(response.body_mut()).await.unwrap();
    let response_body_string = read_to_string(response_body.as_ref()).unwrap();

    // Verify that the response contains the expected information
    assert_eq!(response.status(), StatusCode::OK);
    assert!(response_body_string.contains(INT_COUNTER_NAME));
}
```

**File:** consensus/src/pending_votes.rs (L342-357)
```rust
        let cur_epoch = vote.vote_data().proposed().epoch() as i64;
        let cur_round = vote.vote_data().proposed().round() as i64;
        counters::CONSENSUS_CURRENT_ROUND_QUORUM_VOTING_POWER
            .set(validator_verifier.quorum_voting_power() as f64);

        if !vote.is_timeout() {
            counters::CONSENSUS_CURRENT_ROUND_VOTED_POWER
                .with_label_values(&[&vote.author().to_string(), &hash_index_to_str(*hash_index)])
                .set(validator_voting_power as f64);
            counters::CONSENSUS_LAST_VOTE_EPOCH
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_epoch);
            counters::CONSENSUS_LAST_VOTE_ROUND
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_round);
        }
```
