# Audit Report

## Title
DAG Consensus Parent Selection Vulnerability Allowing Reputation Manipulation Through Selective Parent Inclusion

## Summary
In Aptos DAG consensus, validators can selectively choose which parent nodes to include when creating new nodes, as long as the parents collectively satisfy the 2f+1 voting power requirement. This allows malicious validators to manipulate the `previous_block_votes_bitvec` field in block metadata, systematically excluding certain validators from reputation tracking and potentially influencing leader election.

## Finding Description

The vulnerability exists in the DAG consensus parent validation logic. When a validator creates a new DAG node, the only requirements for parent selection are:

1. All parents must be from round - 1 [1](#0-0) 

2. Parents must collectively satisfy 2f+1 voting power [2](#0-1) 

There is **no requirement** to include ALL available certified nodes from the previous round. While the honest implementation retrieves all certified nodes [3](#0-2) , a malicious validator can manually construct a node with only a selective subset of parents.

When such a node becomes an anchor through the election mechanism [4](#0-3) , the `parents_bitvec` is constructed based on these selective parents [5](#0-4) .

This bitvec becomes the `previous_block_votes_bitvec` in block metadata [6](#0-5)  and is subsequently used by the leader reputation system to track validator participation [7](#0-6) .

**Attack Path:**
1. Malicious validator creates node for round N with selective parents from round N-1 (omitting validator X's node)
2. Node satisfies 2f+1 voting power requirement and passes validation
3. Node receives 2f+1 votes and becomes certified
4. When malicious validator is selected as anchor, their node's parent list is used
5. `parents_bitvec` excludes validator X
6. This becomes `previous_block_votes_bitvec` in NewBlockEvent [8](#0-7) 
7. Leader reputation system doesn't credit validator X with participation
8. Over multiple rounds, validator X's reputation score is artificially reduced
9. This affects future leader/anchor selection probabilities

## Impact Explanation

This vulnerability allows manipulation of the consensus leader election mechanism, which qualifies as a **High Severity** issue under "Significant protocol violations." The impact includes:

- **Reputation System Manipulation**: Malicious validators can systematically suppress honest validators' reputation scores
- **Leader Election Bias**: Over time, this creates unfair advantage in leader/anchor selection
- **Byzantine Behavior Concealment**: The voting history misrepresents actual validator participation, making it harder to detect Byzantine validators
- **Potential Liveness Impact**: If Byzantine validators gain disproportionate leader selection, they could more easily cause liveness issues

While this doesn't directly break consensus safety (requires >1/3 Byzantine), it violates the fairness guarantees expected in the consensus protocol and could be a stepping stone for more severe attacks.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Low Barrier to Entry**: Any validator can execute this attack when selected as anchor
- **No Collusion Required**: Single malicious validator can perform the attack
- **Stealthy**: Difficult to detect without detailed analysis of parent inclusion patterns
- **Guaranteed Opportunity**: With round-robin or reputation-based anchor election, every validator eventually becomes anchor
- **Validation Passes**: Malicious nodes pass all existing validation checks

The attack is practical and requires no special privileges beyond being a validator (which is part of the standard BFT adversary model assuming up to 1/3 Byzantine validators).

## Recommendation

Add validation to enforce that DAG nodes include ALL available certified nodes from the previous round (not just 2f+1 voting power worth). Modify the `Node::verify()` method:

```rust
// In consensus/src/dag/types.rs, Node::verify() method
pub fn verify(&self, sender: Author, verifier: &ValidatorVerifier, 
              available_parents: &[NodeCertificate]) -> anyhow::Result<()> {
    // ... existing checks ...
    
    // NEW: Verify all available parents are included
    let available_authors: HashSet<_> = available_parents.iter()
        .map(|p| p.metadata().author())
        .collect();
    let included_authors: HashSet<_> = self.parents()
        .iter()
        .map(|p| p.metadata().author())
        .collect();
    
    ensure!(
        included_authors == available_authors,
        "Node must include all available certified parents from previous round"
    );
    
    Ok(())
}
```

Additionally, add validation in the DAG store when accepting new nodes to verify completeness of parent set.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_selective_parent_inclusion_vulnerability() {
        // Setup: Create 4 validators with equal voting power (25% each)
        let validators = create_test_validators(4);
        let verifier = ValidatorVerifier::new(validators.clone());
        
        // Round 1: All validators create and certify nodes
        let round1_nodes: Vec<CertifiedNode> = validators.iter()
            .map(|v| create_and_certify_node(v, 1, vec![], &verifier))
            .collect();
        
        // Round 2: Malicious validator creates node with selective parents
        // Includes only 3 out of 4 parents (75% voting power, exceeds 2f+1=67%)
        // Intentionally omits validator[3]'s node
        let malicious_parents: Vec<NodeCertificate> = round1_nodes.iter()
            .take(3)  // Only include first 3 validators
            .map(|n| n.certificate())
            .collect();
        
        let malicious_node = Node::new(
            1, // epoch
            2, // round
            *validators[0].author(), // malicious author
            timestamp(),
            vec![],
            Payload::empty(true, false),
            malicious_parents, // Selective parents
            Extensions::empty()
        );
        
        // Verify this node passes validation (IT SHOULD PASS - that's the bug!)
        assert!(malicious_node.verify(
            *validators[0].author(),
            &verifier
        ).is_ok());
        
        // The malicious node gets certified
        let certified_malicious = certify_node(malicious_node, &validators[0..3], &verifier);
        
        // When this becomes anchor, parents_bitvec excludes validator[3]
        let parents_bitvec = construct_parents_bitvec(&certified_malicious, &validators);
        
        // Assert: Validator[3] is NOT in the bitvec (vulnerability demonstrated)
        assert!(!parents_bitvec.is_set(3));
        
        // This bitvec becomes previous_block_votes_bitvec in metadata
        // Leader reputation system will not credit validator[3] with participation
        // Over time, validator[3]'s reputation artificially decreases
    }
}
```

## Notes

**Severity Justification**: While this doesn't directly break consensus safety, it represents a significant protocol violation that undermines the fairness and integrity of the leader election mechanism - a critical component of the consensus protocol. The ability to systematically manipulate reputation scores and hide Byzantine behavior qualifies this as High Severity under the "Significant protocol violations" category.

The vulnerability is specific to DAG consensus mode. Traditional AptosBFT consensus using quorum certificates does not have this issue, as the `previous_block_votes_bitvec` comes directly from cryptographically verified QC signatures [9](#0-8) .

### Citations

**File:** consensus/src/dag/types.rs (L320-327)
```rust
        let prev_round = node_round - 1;
        // check if the parents' round is the node's round - 1
        ensure!(
            self.parents()
                .iter()
                .all(|parent| parent.metadata().round() == prev_round),
            "invalid parent round"
        );
```

**File:** consensus/src/dag/types.rs (L330-340)
```rust
        ensure!(
            verifier
                .check_voting_power(
                    self.parents()
                        .iter()
                        .map(|parent| parent.metadata().author()),
                    true,
                )
                .is_ok(),
            "not enough parents to satisfy voting power"
        );
```

**File:** consensus/src/dag/dag_driver.rs (L214-219)
```rust
            let strong_links = dag_reader
                .get_strong_links_for_round(new_round - 1, &self.epoch_state.verifier)
                .unwrap_or_else(|| {
                    assert_eq!(new_round, 1, "Only expect empty strong links for round 1");
                    vec![]
                });
```

**File:** consensus/src/dag/order_rule.rs (L111-115)
```rust
            let anchor_author = self.anchor_election.get_anchor(start_round);
            // I "think" it's impossible to get ordered/committed node here but to double check
            if let Some(anchor_node) =
                dag_reader.get_node_by_round_author(start_round, &anchor_author)
            {
```

**File:** consensus/src/dag/adapter.rs (L163-173)
```rust
        let mut parents_bitvec = BitVec::with_num_bits(self.epoch_state.verifier.len() as u16);
        for parent in anchor.parents().iter() {
            if let Some(idx) = self
                .epoch_state
                .verifier
                .address_to_validator_index()
                .get(parent.metadata().author())
            {
                parents_bitvec.set(*idx as u16);
            }
        }
```

**File:** consensus/consensus-types/src/block.rs (L570-578)
```rust
    fn previous_bitvec(&self) -> BitVec {
        match self.block_data.block_type() {
            BlockType::DAGBlock { parents_bitvec, .. } => parents_bitvec.clone(),
            BlockType::OptimisticProposal(p) => {
                p.grandparent_qc().ledger_info().get_voters_bitvec().clone()
            },
            _ => self.quorum_cert().ledger_info().get_voters_bitvec().clone(),
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L580-594)
```rust
    pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
        BlockMetadata::new(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
        )
```

**File:** consensus/src/liveness/leader_reputation.rs (L375-377)
```rust
                match Self::bitvec_to_voters(
                    &epoch_to_candidates[&meta.epoch()],
                    &meta.previous_block_votes_bitvec().clone().into(),
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L181-190)
```text
        let new_block_event = NewBlockEvent {
            hash,
            epoch,
            round,
            height: block_metadata_ref.height,
            previous_block_votes_bitvec,
            proposer,
            failed_proposer_indices,
            time_microseconds: timestamp,
        };
```
