# Audit Report

## Title
Malformed JWKs Can Be Signed and Committed On-Chain Without Validation, Breaking Keyless Authentication

## Summary
The `process_new_observation()` function in the JWK consensus manager signs and propagates JWK observations without validating their cryptographic parameters (modulus size, exponent validity, base64 encoding). Malformed JWKs from compromised or misconfigured OIDC providers can reach quorum, be committed on-chain, and subsequently break all keyless authentication for affected providers.

## Finding Description
The vulnerability exists in the JWK observation and consensus flow. When validators fetch JWKs from OIDC providers, they perform only minimal parsing validation - checking that fields exist and are strings, and that `kty == "RSA"`. [1](#0-0) 

These JWKs are then immediately signed with validator consensus keys without any cryptographic validation of the actual parameter values. [2](#0-1) 

The JWK observation flow proceeds as follows:

1. **Fetching**: The `JWKObserver` fetches JWKs from external OIDC provider URLs [3](#0-2) 

2. **Parsing**: JWKs are parsed from JSON, converting any JWK that doesn't match RSA format into `UnsupportedJWK`, but RSA JWKs only validate field presence, not cryptographic validity [4](#0-3) 

3. **Signing Without Validation**: In `process_new_observation()`, these JWKs are signed with the validator's consensus key without checking if the modulus `n` and exponent `e` are valid base64-encoded integers, if the modulus is the correct size (256 bytes for the circuit), or if they form a valid RSA public key [5](#0-4) 

4. **Consensus**: The signed observations are propagated to peers and can reach quorum if enough validators observe the same malformed JWKs

5. **On-Chain Commitment**: The validator transaction processing only validates the multi-signature and version, not the JWK parameter validity [6](#0-5) 

6. **Authentication Failure**: When these on-chain JWKs are used for keyless authentication, `DecodingKey::from_rsa_components()` fails because the RSA parameters are malformed [7](#0-6) 

**Attack Scenarios:**
- A compromised OIDC provider serves JWKs with invalid base64 encoding in `n` or `e` fields
- A misconfigured provider serves JWKs with incorrect modulus sizes
- A MITM attacker intercepts JWK fetches and injects malformed parameters
- An OIDC provider temporarily serves malformed JWKs during key rotation

This breaks the **Cryptographic Correctness** invariant, as malformed cryptographic material gets consensus-certified and stored on-chain.

## Impact Explanation
This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

**Availability Impact**: When malformed JWKs are committed on-chain, all users attempting keyless authentication using that OIDC provider and key ID will experience authentication failures. The `from_rsa_components()` call will fail during signature verification [8](#0-7) , causing transaction validation to return `invalid_signature!("RSA signature verification failed for OpenIdSig")`.

**Scope**: Major OIDC providers (Google, Facebook, Apple) could be affected if they temporarily serve malformed JWKs. Thousands of keyless accounts could become inaccessible.

**Recovery**: Requires emergency governance intervention to patch the on-chain JWKs using the `Patches` mechanism, which takes time and coordination.

This qualifies as "Significant protocol violations" under High Severity, as it breaks a critical authentication mechanism for an entire class of users.

## Likelihood Explanation
**Medium to High Likelihood:**

- OIDC providers occasionally misconfigure JWK endpoints during key rotations
- The external dependency on third-party OIDC providers introduces risk
- No validation exists to prevent this issue, making it inevitable when providers serve bad data
- The attack requires no privileged access - just a compromised or misconfigured OIDC provider
- Multiple validators independently observing the same malformed JWKs from the provider would naturally reach consensus on the bad data

## Recommendation
Add comprehensive JWK parameter validation in `process_new_observation()` before signing:

```rust
pub fn process_new_observation(
    &mut self,
    issuer: Issuer,
    jwks: Vec<JWKMoveStruct>,
) -> Result<()> {
    // Validate JWK parameters before signing
    for jwk_move_struct in &jwks {
        let jwk = JWK::try_from(jwk_move_struct)
            .context("Failed to convert JWKMoveStruct to JWK")?;
        
        if let JWK::RSA(rsa_jwk) = jwk {
            // Validate that we can create a decoding key (validates base64 and RSA structure)
            DecodingKey::from_rsa_components(&rsa_jwk.n, &rsa_jwk.e)
                .context("Invalid RSA JWK parameters - cannot create decoding key")?;
            
            // Validate modulus size matches circuit requirements
            let modulus = base64::decode_config(&rsa_jwk.n, base64::URL_SAFE_NO_PAD)
                .context("Invalid base64 encoding in RSA modulus")?;
            if modulus.len() != RSA_JWK::RSA_MODULUS_BYTES {
                bail!(
                    "RSA modulus size is {} bytes, expected {} bytes",
                    modulus.len(),
                    RSA_JWK::RSA_MODULUS_BYTES
                );
            }
            
            // Validate algorithm is supported
            if rsa_jwk.alg != "RS256" {
                bail!("Unsupported algorithm: {}", rsa_jwk.alg);
            }
        }
    }
    
    // Existing code continues...
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    // ... rest of function
}
```

Additionally, add validation in the Move code's `upsert_into_observed_jwks` using a native function to double-check parameter validity before committing on-chain.

## Proof of Concept

```rust
#[test]
fn test_malformed_jwk_rejection() {
    use aptos_types::jwks::jwk::JWKMoveStruct;
    use aptos_types::jwks::rsa::RSA_JWK;
    
    // Create a JWK with invalid base64 in the modulus
    let malformed_jwk = RSA_JWK {
        kid: "test_key".to_string(),
        kty: "RSA".to_string(),
        alg: "RS256".to_string(),
        e: "AQAB".to_string(),
        n: "!@#$%^&*()_INVALID_BASE64".to_string(), // Invalid base64
    };
    
    let jwk_move_struct: JWKMoveStruct = malformed_jwk.into();
    
    // Attempt to create a DecodingKey - this should fail
    let jwk = JWK::try_from(&jwk_move_struct).unwrap();
    if let JWK::RSA(rsa_jwk) = jwk {
        let result = DecodingKey::from_rsa_components(&rsa_jwk.n, &rsa_jwk.e);
        assert!(result.is_err(), "Should fail on invalid RSA parameters");
    }
    
    // Without validation, process_new_observation would sign this malformed JWK
    // With the fix, it should reject it before signing
}
```

## Notes
- The vulnerability affects the keyless authentication subsystem, which is critical for user experience
- The lack of validation before signing is a design oversight - external data should never be trusted without validation
- The fix should include both pre-signing validation in Rust and potentially a native Move function for on-chain validation
- Consider adding monitoring/alerts when JWK observations fail validation to detect provider issues early

### Citations

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L132-178)
```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;

    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        let kty = json_value
            .get("kty")
            .ok_or_else(|| anyhow!("Field `kty` not found"))?
            .as_str()
            .ok_or_else(|| anyhow!("Field `kty` is not a string"))?
            .to_string();

        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );

        let ret = Self {
            kty,
            kid: json_value
                .get("kid")
                .ok_or_else(|| anyhow!("Field `kid` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `kid` is not a string"))?
                .to_string(),
            alg: json_value
                .get("alg")
                .ok_or_else(|| anyhow!("Field `alg` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `alg` is not a string"))?
                .to_string(),
            e: json_value
                .get("e")
                .ok_or_else(|| anyhow!("Field `e` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `e` is not a string"))?
                .to_string(),
            n: json_value
                .get("n")
                .ok_or_else(|| anyhow!("Field `n` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `n` is not a string"))?
                .to_string(),
        };

        Ok(ret)
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L184-228)
```rust
    pub fn process_new_observation(
        &mut self,
        issuer: Issuer,
        jwks: Vec<JWKMoveStruct>,
    ) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-142)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L391-395)
```rust
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
```
