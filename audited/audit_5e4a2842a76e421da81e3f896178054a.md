# Audit Report

## Title
Inverted Union-By-Rank Logic Causes O(n) Tree Degradation in Block Partitioner

## Summary
The `union()` function in the union-find implementation has inverted parent assignment logic in the `Ordering::Less` and `Ordering::Greater` cases, causing it to consistently attach taller trees under shorter trees instead of the reverse. This defeats the union-by-rank optimization and enables construction of worst-case O(n) height trees instead of the expected O(log n) balanced structures.

## Finding Description
The union-by-rank optimization is designed to maintain balanced trees by always attaching the shorter tree as a child of the taller tree. However, the implementation has inverted logic: [1](#0-0) 

When `height_of[px] < height_of[py]` (px is shorter), the code executes `self.parent_of[py] = px`, which makes px (the shorter tree) the parent of py (the taller tree). This is backwards - it should attach the shorter px under the taller py.

Similarly, when `height_of[px] > height_of[py]` (px is taller), the code executes `self.parent_of[px] = py`, making py (the shorter tree) the parent of px (the taller tree), again inverted.

**Exploitation Sequence:**
Given elements 0,1,2,3,4,5:
1. `union(0,1)`: Equal heights → `parent_of[0]=1, height_of[1]=1` (correct)
2. `union(1,2)`: `height_of[1]=1 > height_of[2]=0` → Greater case → `parent_of[1]=2` (inverted!)
   - Tree: `2(h=0) ← 1(h=1) ← 0` (chain of length 2)
3. `union(2,3)`: Equal heights → `parent_of[2]=3, height_of[3]=1` (correct)
   - Tree: `3(h=1) ← 2(h=0) ← 1(h=1) ← 0` (chain of length 3)
4. Continue pattern to create linear O(n) chains

This union-find is used in `ConnectedComponentPartitioner` to group conflicting transactions during block partitioning: [2](#0-1) 

## Impact Explanation
This qualifies as **High Severity** per the Aptos bug bounty criteria ("Validator node slowdowns"). The inverted logic causes:

1. **Degraded Performance**: Find operations degrade from O(α(n)) to O(n) in worst case
2. **Validator Slowdowns**: Block partitioning becomes slower, potentially impacting validator performance during high transaction volume
3. **Resource Inefficiency**: More CPU cycles wasted on find() traversals during transaction grouping

However, **path compression** in the `find()` function partially mitigates this by flattening trees after traversal: [3](#0-2) 

The impact does NOT include:
- Consensus safety violations (execution remains deterministic)
- Incorrect partitioning results (find() still returns correct roots)
- Fund loss or state corruption

## Likelihood Explanation
**Medium-High likelihood** of performance degradation occurring:
- Every block partitioning operation uses this union-find
- Common transaction patterns (many senders writing to shared keys) trigger the Less/Greater cases
- Path compression reduces but doesn't eliminate the performance impact
- No external attacker control needed - this happens naturally during normal operation

**Low likelihood** of severe security impact:
- Block partitioning is an optimization, not a correctness requirement
- Path compression mitigates worst-case scenarios
- No direct attack vector for external exploitation

## Recommendation
Fix the inverted parent assignment logic by swapping the assignments in the Less and Greater cases:

```rust
match self.height_of[px].cmp(&self.height_of[py]) {
    Ordering::Less => {
        self.parent_of[px] = py;  // FIX: Attach shorter (px) under taller (py)
    },
    Ordering::Greater => {
        self.parent_of[py] = px;  // FIX: Attach shorter (py) under taller (px)
    },
    Ordering::Equal => {
        self.parent_of[px] = py;
        self.height_of[py] += 1;
    },
}
```

## Proof of Concept
```rust
#[test]
fn test_union_by_rank_bug() {
    let mut uf = UnionFind::new(6);
    
    // Build a sequence that creates a linear chain due to inverted logic
    uf.union(0, 1); // Equal: parent_of[0]=1, height_of[1]=1
    uf.union(1, 2); // Greater (1>0): parent_of[1]=2 (WRONG! Creates chain)
    uf.union(2, 3); // Equal: parent_of[2]=3, height_of[3]=1
    uf.union(3, 4); // Greater (1>0): parent_of[3]=4 (WRONG! Extends chain)
    uf.union(4, 5); // Equal: parent_of[4]=5, height_of[5]=1
    
    // Verify chain: 5←4←3←2←1←0
    // Finding 0 should traverse 5 edges in the worst case
    let mut test_uf = uf; // Copy for testing
    
    // Before path compression, manually verify tree structure
    assert_eq!(test_uf.parent_of[0], 1);
    assert_eq!(test_uf.parent_of[1], 2);
    assert_eq!(test_uf.parent_of[2], 3);
    assert_eq!(test_uf.parent_of[3], 4);
    assert_eq!(test_uf.parent_of[4], 5);
    assert_eq!(test_uf.parent_of[5], 5);
    
    // This demonstrates O(n) tree height instead of O(log n)
}
```

## Notes
While this is a valid implementation bug that violates the documented O(α(n)) time complexity guarantee, the **security impact is limited** to validator performance degradation. The union-find still produces correct results (find() returns the right roots), and path compression provides partial mitigation. This does not affect consensus safety, execution determinism, or fund security.

### Citations

**File:** execution/block-partitioner/src/v2/union_find.rs (L37-42)
```rust
        let mut element = a;
        while element != root {
            let next_element = self.parent_of[element];
            self.parent_of[element] = root;
            element = next_element;
        }
```

**File:** execution/block-partitioner/src/v2/union_find.rs (L53-64)
```rust
        match self.height_of[px].cmp(&self.height_of[py]) {
            Ordering::Less => {
                self.parent_of[py] = px;
            },
            Ordering::Greater => {
                self.parent_of[px] = py;
            },
            Ordering::Equal => {
                self.parent_of[px] = py;
                self.height_of[py] += 1;
            },
        }
```

**File:** execution/block-partitioner/src/pre_partition/connected_component/mod.rs (L48-56)
```rust
        let mut uf = UnionFind::new(num_senders + num_keys);
        for txn_idx in 0..state.num_txns() {
            let sender_idx = state.sender_idx(txn_idx);
            let write_set = state.write_sets[txn_idx].read().unwrap();
            for &key_idx in write_set.iter() {
                let key_idx_in_uf = num_senders + key_idx;
                uf.union(key_idx_in_uf, sender_idx);
            }
        }
```
