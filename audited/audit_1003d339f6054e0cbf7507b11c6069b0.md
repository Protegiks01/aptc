# Audit Report

## Title
Rosetta API Commission and Rewards Balance Query Denial of Service Due to Flawed Sub-Account Type Detection

## Summary
The `SubAccountIdentifier` semantic overloading causes commission and rewards balance queries to fail silently, returning zero balances instead of actual values. The flawed `is_operator_stake()` method incorrectly identifies these sub-account types as operator stakes, triggering operator address extraction that fails and prevents correct balance retrieval.

## Finding Description

The `address` field in `SubAccountIdentifier` serves dual purposes: identifying stake types ("stake", "active_stake", etc.) and encoding operator information ("stake-{operator_address}"). This semantic overload creates a logic flaw in type detection. [1](#0-0) 

The `is_operator_stake()` method uses negative logic to identify operator stakes by excluding known basic stake types: [2](#0-1) 

However, this exclusion list is incompleteâ€”it doesn't include "commission" or "rewards" types defined at: [3](#0-2) 

When a user queries commission or rewards balances, the execution flow is:

1. User requests balance with sub_account.address = "commission" or "rewards"
2. `get_staking_info` calls `get_stake_balances` for each staking contract
3. `get_stake_balances` evaluates `is_operator_stake()` which incorrectly returns `true`
4. The code attempts to extract operator address: [4](#0-3) 

5. `operator_address()` fails because "commission"/"rewards" don't match the "stake-{address}" pattern: [5](#0-4) 

6. The error is caught and logged as a warning in `get_staking_info`, causing that stake pool's balance to be skipped: [6](#0-5) 

7. The final response returns zero or empty commission/rewards balance despite actual on-chain balances existing

## Impact Explanation

This qualifies as **Low Severity** per the Aptos bug bounty criteria as a "Non-critical implementation bug." While users cannot query commission/rewards balances via Rosetta API, the actual on-chain state remains intact and accessible through alternative interfaces. The Rosetta API is an external integration layer, not a core consensus or execution component. No funds are at risk, and state consistency is preserved.

## Likelihood Explanation

**High Likelihood** - This bug triggers deterministically whenever any user queries commission or rewards balances through the Rosetta API's `/account/balance` endpoint with appropriate sub-account identifiers. No special conditions or race conditions are required.

## Recommendation

Fix the `is_operator_stake()` method to explicitly exclude commission and rewards types:

```rust
pub fn is_operator_stake(&self) -> bool {
    if let Some(ref inner) = self.sub_account {
        !(inner.is_total_stake()
            || inner.is_active_stake()
            || inner.is_pending_active_stake()
            || inner.is_inactive_stake()
            || inner.is_pending_inactive_stake()
            || inner.is_commission()
            || inner.is_rewards())
    } else {
        false
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_commission_misidentified_as_operator_stake() {
    let commission_account = AccountIdentifier {
        address: "0x1".to_string(),
        sub_account: Some(SubAccountIdentifier::new_commission()),
    };
    
    // Bug: commission is incorrectly identified as operator stake
    assert!(commission_account.is_commission());
    assert!(commission_account.is_operator_stake()); // Should be false!
    
    // This causes operator_address() to fail
    assert!(commission_account.operator_address().is_err());
}

#[test]
fn test_rewards_misidentified_as_operator_stake() {
    let rewards_account = AccountIdentifier {
        address: "0x1".to_string(),
        sub_account: Some(SubAccountIdentifier::new_rewards()),
    };
    
    // Bug: rewards is incorrectly identified as operator stake  
    assert!(rewards_account.is_rewards());
    assert!(rewards_account.is_operator_stake()); // Should be false!
    
    // This causes operator_address() to fail
    assert!(rewards_account.operator_address().is_err());
}
```

## Notes

This vulnerability affects only the Rosetta API external interface layer and does not impact core blockchain functionality, consensus, or on-chain state. The issue stems from incomplete negative logic in type detection rather than semantic overloading per se. While commission and rewards balance queries fail, users can still access these balances through direct node queries or other API interfaces.

### Citations

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L194-204)
```rust
    pub fn is_operator_stake(&self) -> bool {
        if let Some(ref inner) = self.sub_account {
            !(inner.is_total_stake()
                || inner.is_active_stake()
                || inner.is_pending_active_stake()
                || inner.is_inactive_stake()
                || inner.is_pending_inactive_stake())
        } else {
            false
        }
    }
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L228-235)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct SubAccountIdentifier {
    /// Hex encoded AccountAddress beginning with 0x
    pub address: String,
    /// Metadata only used for delegated staking
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<SubAccountIdentifierMetadata>,
}
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L237-243)
```rust
const STAKE: &str = "stake";
const PENDING_ACTIVE_STAKE: &str = "pending_active_stake";
const ACTIVE_STAKE: &str = "active_stake";
const PENDING_INACTIVE_STAKE: &str = "pending_inactive_stake";
const INACTIVE_STAKE: &str = "inactive_stake";
const COMMISSION: &str = "commission";
const REWARDS: &str = "rewards";
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L379-394)
```rust
    pub fn operator_address(&self) -> ApiResult<AccountAddress> {
        let mut parts = self.address.split(ACCOUNT_SEPARATOR);

        if let Some(stake) = parts.next() {
            if stake == STAKE {
                if let Some(operator) = parts.next() {
                    return str_to_account_address(operator);
                }
            }
        }

        Err(ApiError::InvalidInput(Some(format!(
            "Sub account isn't an operator address {:?}",
            self
        ))))
    }
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L310-317)
```rust
        // If the operator address is different, skip
        if owner_account.is_operator_stake()
            && owner_account.operator_address()? != stake_pool.operator_address
        {
            return Err(ApiError::InvalidInput(Some(
                "Stake pool not for matching operator".to_string(),
            )));
        }
```

**File:** crates/aptos-rosetta/src/account.rs (L227-242)
```rust
            match get_stake_balances(rest_client, account, contract.pool_address, version).await {
                Ok(Some(balance_result)) => {
                    if let Some(balance) = balance_result.balance {
                        has_staking = true;
                        total_balance += u64::from_str(&balance.value).unwrap_or_default();
                    }
                    // TODO: This seems like it only works if there's only one staking contract (hopefully it stays that way)
                    lockup_expiration = balance_result.lockup_expiration;
                },
                result => {
                    warn!(
                        "Failed to retrieve requested balance for account: {}, address: {}: {:?}",
                        owner_address, contract.pool_address, result
                    )
                },
            }
```
