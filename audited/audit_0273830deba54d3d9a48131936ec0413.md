# Audit Report

## Title
Namespace Escape via Path Traversal in Secure Storage Key Parameter

## Summary
The `Namespaced` storage wrapper in the secure storage system does not sanitize key parameters before concatenating them with namespaces. This allows path traversal sequences (e.g., "../") to potentially escape namespace isolation when using VaultStorage backend, enabling unauthorized access to keys in other namespaces.

## Finding Description
The vulnerability exists in the `namespaced()` function which constructs storage keys by simple string concatenation without validation: [1](#0-0) 

When a Namespaced storage wrapper receives a key parameter containing path traversal sequences like "../" or absolute paths like "/other_namespace/key", it blindly concatenates with the namespace separator: [2](#0-1) 

For VaultStorage backend, the constructed key is directly embedded into HTTP URL paths without sanitization: [3](#0-2) 

**Attack Path:**
1. Component A operates under namespace "validator_a" with its own Namespaced storage
2. Attacker with code execution in Component A calls `storage.get("../../validator_b/consensus")`
3. The namespaced key becomes: "validator_a/../../validator_b/consensus"
4. VaultStorage constructs URL: `{host}/v1/secret/data/validator_a/../../validator_b/consensus`
5. HTTP path normalization resolves to: `{host}/v1/secret/data/validator_b/consensus`
6. Component A successfully retrieves validator_b's consensus key

The namespace separator is defined as "/" which is interpreted as a path separator by HTTP clients and Vault: [4](#0-3) 

**Security Boundary Violation:**
The Namespaced wrapper is explicitly designed to isolate data between components using different namespaces, as demonstrated in tests: [5](#0-4) 

However, this isolation can be bypassed through unvalidated key parameters.

## Impact Explanation
**Severity: High**

This vulnerability breaks the namespace isolation security boundary in the secure storage system, which stores critical cryptographic material including:
- Consensus private keys (CONSENSUS_KEY)
- Safety data for AptosBFT
- Validator authentication credentials [6](#0-5) 

In multi-tenant scenarios where multiple components or validators share a Vault instance with different namespaces, a compromised component could:
1. **Access consensus keys** from other validators, enabling equivocation attacks
2. **Read safety data** to understand voting history and manipulate consensus
3. **Extract private keys** for impersonation attacks

While current usage in SafetyRules uses only hardcoded constants, this represents a defense-in-depth failure that could be exploited if:
- Future code introduces dynamic key construction
- Plugin or extension systems allow untrusted code to access storage
- Multi-validator deployments share storage infrastructure [7](#0-6) 

## Likelihood Explanation
**Likelihood: Low to Medium**

Current exploitation barriers:
1. All observed storage usage employs hardcoded constant strings
2. The secure storage system is internal validator infrastructure, not exposed via external APIs
3. Requires code execution context within a validator process to call storage methods

However, likelihood increases if:
- Code refactoring introduces dynamic key construction from configuration
- Shared Vault deployments become common in validator infrastructure
- Third-party plugins or extensions gain storage access

The vulnerability is latent and represents a time bomb - it will remain unexploitable until development patterns change.

## Recommendation
Implement strict key parameter validation in the `namespaced()` function to prevent path traversal:

```rust
fn namespaced(&self, name: &str) -> String {
    // Validate key parameter
    if name.contains("..") || name.starts_with('/') || name.contains(NAMESPACE_SEPARATOR) {
        panic!("Invalid key parameter: path traversal or namespace separator detected");
    }
    
    // Additional validation: only allow alphanumeric, underscore, hyphen
    if !name.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '-') {
        panic!("Invalid key parameter: only alphanumeric characters, underscore, and hyphen allowed");
    }
    
    format!("{}{}{}", self.namespace, NAMESPACE_SEPARATOR, name)
}
```

Alternatively, use URL-safe encoding for keys before concatenation to neutralize special characters.

## Proof of Concept

```rust
#[cfg(test)]
mod namespace_escape_test {
    use super::*;
    use crate::{KVStorage, Namespaced, OnDiskStorage};
    use aptos_temppath::TempPath;

    #[test]
    fn test_namespace_escape_attempt() {
        let path_buf = TempPath::new().path().to_path_buf();
        
        // Create two namespaced storages
        let mut storage_a = Namespaced::new("namespace_a", OnDiskStorage::new(path_buf.clone()));
        let mut storage_b = Namespaced::new("namespace_b", OnDiskStorage::new(path_buf));
        
        // Store secret in namespace_b
        storage_b.set("secret_key", "confidential_data").unwrap();
        
        // Attempt to access from namespace_a using path traversal
        // This demonstrates the vulnerability - the key contains "../"
        let malicious_key = "../namespace_b/secret_key";
        
        // For OnDiskStorage (HashMap), this won't work as "../" is literal
        // But for VaultStorage with HTTP URLs, path normalization would resolve "../"
        // making this a real vulnerability
        match storage_a.get::<String>(malicious_key) {
            Ok(_) => println!("VULNERABLE: Namespace escape successful!"),
            Err(_) => println!("OnDiskStorage not vulnerable (uses HashMap), but VaultStorage would be"),
        }
    }
}
```

For VaultStorage, the attack would succeed because HTTP clients normalize paths, resolving `namespace_a/../namespace_b/secret_key` to `namespace_b/secret_key`, bypassing namespace isolation.

## Notes
This vulnerability is currently unexploited in production because all key parameters are hardcoded constants. However, it violates defense-in-depth principles and creates future risk. The namespace isolation security boundary should be enforced through input validation regardless of current usage patterns.

### Citations

**File:** secure/storage/src/namespaced.rs (L11-11)
```rust
pub const NAMESPACE_SEPARATOR: &str = "/";
```

**File:** secure/storage/src/namespaced.rs (L45-47)
```rust
    fn namespaced(&self, name: &str) -> String {
        format!("{}{}{}", self.namespace, NAMESPACE_SEPARATOR, name)
    }
```

**File:** secure/storage/src/namespaced.rs (L66-68)
```rust
    fn get<T: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<T>, Error> {
        self.inner.get(&self.namespaced(key))
    }
```

**File:** secure/storage/vault/src/lib.rs (L255-262)
```rust
    pub fn read_secret(&self, secret: &str, key: &str) -> Result<ReadResponse<Value>, Error> {
        let request = self
            .agent
            .get(&format!("{}/v1/secret/data/{}", self.host, secret));
        let resp = self.upgrade_request(request).call();

        process_secret_read_response(secret, key, resp)
    }
```

**File:** secure/storage/src/tests/vault.rs (L76-84)
```rust
fn test_suite_multiple_namespaces() {
    let mut storage_1 = Storage::from(create_vault_with_namespace(VAULT_NAMESPACE_1));
    let mut storage_2 = Storage::from(create_vault_with_namespace(VAULT_NAMESPACE_2));
    let mut storage_3 = Storage::from(create_vault_with_namespace(VAULT_NAMESPACE_3));

    suite::execute_all_storage_tests(&mut storage_1);
    suite::execute_all_storage_tests(&mut storage_2);
    suite::execute_all_storage_tests(&mut storage_3);
}
```

**File:** config/global-constants/src/lib.rs (L11-17)
```rust
/// Definitions of global cryptographic keys (e.g., as held in secure storage)
pub const CONSENSUS_KEY: &str = "consensus";
pub const OWNER_ACCOUNT: &str = "owner_account";

/// Definitions of global data items (e.g., as held in secure storage)
pub const SAFETY_DATA: &str = "safety_data";
pub const WAYPOINT: &str = "waypoint";
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-116)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
```
