# Audit Report

## Title
REST Client Accepts Inconsistent State Metadata from Malicious Servers Without Validation

## Summary
The Aptos REST client (`aptos-rest-client`) does not validate state metadata consistency across API responses. A malicious REST API server can provide responses with inconsistent `chain_id`, rolled-back `version`, or decreased `epoch` values, causing clients to accept invalid blockchain state, execute transactions on wrong chains, or make incorrect decisions based on stale or forged state information.

## Finding Description

The REST client's `Response::new()` function and state handling mechanism lack any validation of state metadata consistency. The vulnerability spans multiple components:

**1. Response Constructor Performs No Validation** [1](#0-0) 

The `Response::new()` constructor blindly accepts any `State` metadata without validation, simply storing it alongside the response data.

**2. State Extraction Only Checks Header Presence** [2](#0-1) 

The `State::from_headers()` method extracts metadata from HTTP headers but only validates that headers are present and parseable—it performs no semantic validation of the values themselves.

**3. Client Has No State Tracking Mechanism** [3](#0-2) 

The `Client` struct stores no previous state information and performs no cross-request validation. Each API call is independent, with no memory of prior responses.

**4. No Use of Cryptographic State Validation**

While Aptos provides `TrustedState` for proper light client validation: [4](#0-3) 

The REST client completely bypasses this mechanism. The `TrustedState::verify_and_ratchet()` method ensures version staleness checks and cryptographic verification, but is never used by the REST client.

**Attack Scenarios:**

1. **Chain ID Mismatch Attack**: Server returns `chain_id=1` (mainnet) in one response, then `chain_id=2` (testnet) in the next. Client accepts both, potentially submitting transactions to the wrong network.

2. **Version Rollback Attack**: Server returns `version=1000`, then `version=500`. Client accepts the stale state, making decisions based on outdated blockchain information.

3. **Epoch Rollback Attack**: Server returns `epoch=100`, then `epoch=50`. Client accepts the invalid epoch transition, confusing epoch-dependent logic like validator set selection.

4. **Mixed State Attack**: Server provides responses with internally inconsistent state (e.g., high version but low epoch), causing logic errors in client applications.

**Broken Invariants:**

This breaks the **State Consistency** invariant (#4): "State transitions must be atomic and verifiable via Merkle proofs." The client accepts unverifiable state without cryptographic proof.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria)

This qualifies as HIGH severity under "Significant protocol violations" because:

1. **Cross-Chain Transaction Risk**: Clients may submit signed transactions to the wrong blockchain if `chain_id` validation is absent. While some higher-level code (like Rosetta) performs spot checks: [5](#0-4) 

Many client applications using the REST client directly have no such protection.

2. **State Confusion Attacks**: Applications making decisions based on ledger state (e.g., checking account balances before transfers, verifying governance proposal status) could be fed stale or forged state, leading to incorrect actions.

3. **Epoch-Dependent Logic Failures**: Any logic depending on epoch numbers (validator set selection, epoch-specific feature flags) could malfunction with manipulated epoch values.

4. **Widespread Impact**: All applications using `aptos-rest-client` are vulnerable, including wallets, explorers, indexers, and other infrastructure.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack requires:
- Attacker controls or compromises a REST API server endpoint
- Client connects to the malicious server (via misconfiguration, DNS hijacking, or man-in-the-middle attack)
- No additional authentication or authorization barriers

**Factors Increasing Likelihood:**
- Many users point clients at third-party API providers for convenience
- Load balancers may rotate between compromised and legitimate backends
- Development/testing environments often use untrusted endpoints
- No built-in tamper detection alerts users to state inconsistencies

**Factors Decreasing Likelihood:**
- Official Aptos API endpoints are trustworthy
- TLS prevents network-level tampering (but not compromised server)
- Some applications implement their own validation layers

## Recommendation

The REST client should implement stateful validation using `TrustedState` or an equivalent mechanism:

**Solution 1: Add Optional TrustedState Tracking**

Modify the `Client` struct to optionally track and validate state:

```rust
pub struct Client {
    inner: ReqwestClient,
    base_url: Url,
    version_path_base: String,
    // Add optional trusted state tracking
    trusted_state: Option<Arc<Mutex<TrustedState>>>,
}

impl Client {
    // New method to enable state validation
    pub fn with_trusted_state(mut self, waypoint: Waypoint) -> Self {
        self.trusted_state = Some(Arc::new(Mutex::new(
            TrustedState::from_epoch_waypoint(waypoint)
        )));
        self
    }
}
```

**Solution 2: Add Explicit State Validation Methods**

Add validation helpers in `State`:

```rust
impl State {
    pub fn validate_monotonic(&self, previous: &State) -> Result<()> {
        ensure!(
            self.chain_id == previous.chain_id,
            "Chain ID changed from {} to {}",
            previous.chain_id,
            self.chain_id
        );
        ensure!(
            self.version >= previous.version,
            "Version rolled back from {} to {}",
            previous.version,
            self.version
        );
        ensure!(
            self.epoch >= previous.epoch,
            "Epoch decreased from {} to {}",
            previous.epoch,
            self.epoch
        );
        Ok(())
    }
}
```

**Solution 3: Mandatory Chain ID Validation**

At minimum, add chain ID validation on client initialization:

```rust
impl Client {
    pub async fn new(base_url: Url) -> Result<Self> {
        let client = Self::builder(AptosBaseUrl::Custom(base_url)).build();
        
        // Fetch and store expected chain_id on initialization
        let initial_state = client.get_ledger_information().await?;
        
        Ok(client.with_expected_chain_id(initial_state.inner().chain_id))
    }
    
    fn validate_chain_id(&self, state: &State) -> Result<()> {
        ensure!(
            state.chain_id == self.expected_chain_id,
            "Unexpected chain_id: expected {}, got {}",
            self.expected_chain_id,
            state.chain_id
        );
        Ok(())
    }
}
```

## Proof of Concept

```rust
// Proof of Concept: Malicious REST server provides inconsistent state
use aptos_rest_client::{Client, Response, State};
use reqwest::Url;

#[tokio::test]
async fn test_inconsistent_state_acceptance() {
    // Simulate client connecting to malicious server
    let malicious_server = MockMaliciousServer::new();
    let client = Client::new(Url::parse(&malicious_server.url()).unwrap());
    
    // First request returns mainnet state
    let response1 = client.get_ledger_information().await.unwrap();
    assert_eq!(response1.state().chain_id, 1); // Mainnet
    assert_eq!(response1.state().version, 1000);
    assert_eq!(response1.state().epoch, 100);
    
    // Second request returns TESTNET state - should be rejected!
    // But client accepts it without validation
    malicious_server.set_response_headers(
        chain_id: 2,  // Testnet - DIFFERENT CHAIN!
        version: 500,  // Rolled back version
        epoch: 50,     // Decreased epoch
    );
    
    let response2 = client.get_ledger_information().await.unwrap();
    
    // BUG: Client accepts inconsistent state without any validation
    assert_eq!(response2.state().chain_id, 2);  // Changed chain!
    assert_eq!(response2.state().version, 500); // Version went backwards!
    assert_eq!(response2.state().epoch, 50);    // Epoch decreased!
    
    // A properly implemented client should have rejected response2
    // with an error like: "Chain ID mismatch: expected 1, got 2"
}

struct MockMaliciousServer {
    // Implementation provides HTTP server returning controlled headers
    // X-APTOS-CHAIN-ID, X-APTOS-LEDGER-VERSION, X-APTOS-EPOCH
}
```

## Notes

**Additional Context:**

1. **Partial Mitigations Exist**: Some higher-level code (Rosetta API layer) performs spot chain_id validation, but this is inconsistent across the codebase and not enforced at the REST client level.

2. **TrustedState Exists But Unused**: Aptos already has proper cryptographic state validation via `TrustedState` in the types crate, but the REST client doesn't use it. This suggests the REST client was designed for trusted environments only.

3. **Multiple Attack Vectors**: Beyond malicious servers, compromised load balancers, BGP hijacking, or DNS poisoning could all inject malicious responses with inconsistent state.

4. **Impact on Ecosystem**: Wallets, explorers, indexers, and other tools using the REST client are all vulnerable to state manipulation attacks.

The fix should balance security with backward compatibility—consider making state validation opt-in initially, then mandatory in a future major version.

### Citations

**File:** crates/aptos-rest-client/src/response.rs (L13-15)
```rust
    pub fn new(inner: T, state: State) -> Self {
        Self { inner, state }
    }
```

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L80-85)
```rust
#[derive(Clone, Debug)]
pub struct Client {
    inner: ReqwestClient,
    base_url: Url,
    version_path_base: String,
}
```

**File:** types/src/trusted_state.rs (L137-159)
```rust
    pub fn verify_and_ratchet<'a>(
        &self,
        state_proof: &'a StateProof,
    ) -> Result<TrustedStateChange<'a>> {
        self.verify_and_ratchet_inner(
            state_proof.latest_ledger_info_w_sigs(),
            state_proof.epoch_changes(),
        )
    }

    pub fn verify_and_ratchet_inner<'a>(
        &self,
        latest_li: &'a LedgerInfoWithSignatures,
        epoch_change_proof: &'a EpochChangeProof,
    ) -> Result<TrustedStateChange<'a>> {
        // Abort early if the response is stale.
        let curr_version = self.version();
        let target_version = latest_li.ledger_info().version();
        ensure!(
            target_version >= curr_version,
            "The target latest ledger info version is stale ({}) and behind our current trusted version ({})",
            target_version, curr_version,
        );
```

**File:** crates/aptos-rosetta/src/construction.rs (L461-463)
```rust
    if server_context.chain_id.id() != response.state().chain_id {
        return Err(ApiError::ChainIdMismatch);
    }
```
