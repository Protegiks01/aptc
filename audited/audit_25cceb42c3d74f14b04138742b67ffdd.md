# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Breaks JWK Consensus Hash Agreement

## Summary
The `UnsupportedJWK` type uses non-canonical JSON serialization when converting from `serde_json::Value`, causing different validators to produce different BCS hashes for the same logical JWK. This breaks consensus on JWK updates, potentially causing permanent liveness failures for keyless account authentication.

## Finding Description

The JWK consensus mechanism relies on validators reaching agreement on `QuorumCertifiedUpdate` structures that contain `ProviderJWKs` with embedded `UnsupportedJWK` entries. These structures are BCS-serialized and cryptographically hashed for signature verification. [1](#0-0) 

The vulnerability exists in the `From<serde_json::Value>` implementation for `UnsupportedJWK`. The code calls `json_value.to_string()` which preserves the **insertion order** of JSON object keys from the original parsed JSON, not a canonical alphabetical ordering. The TODO comment explicitly acknowledges this issue.

When validators fetch JWKs from OIDC providers: [2](#0-1) 

Each validator parses the JSON response into `Vec<serde_json::Value>`, then converts to `JWK` enum: [3](#0-2) 

If the OIDC provider returns JSON with different key orderings to different validators (due to CDN caching, server updates, or load balancing), `serde_json::Value` preserves those different orderings. When `to_string()` is called, it serializes keys in insertion order, producing **different byte sequences** for the same logical JWK.

These different payloads result in different `id` hashes (SHA3-256), creating distinct `UnsupportedJWK` instances. When wrapped in the consensus structure: [4](#0-3) 

The `ProviderJWKs` structure (which derives `BCSCryptoHash`) will serialize differently: [5](#0-4) 

This means validators signing their observations produce signatures over **different hashes**, preventing quorum formation: [6](#0-5) 

The consensus mechanism cannot aggregate signatures for different hashes, causing permanent liveness failure for JWK updates.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the **Deterministic Execution** invariant and causes **Total loss of liveness** for JWK consensus:

1. **Consensus Liveness Failure**: Validators cannot reach quorum on `QuorumCertifiedUpdate` because they're signing different payloads. JWK updates become permanently blocked.

2. **Keyless Authentication Unavailability**: JWKs are critical for keyless account operations. If JWKs cannot be updated when OIDC providers rotate keys, all keyless accounts become unusable.

3. **Non-Recoverable Without Hardfork**: Once validators have diverged on their observed JWK payloads, there's no automatic recovery mechanism. The network would require manual intervention or a hardfork to reset the JWK state.

4. **No Malicious Actor Required**: This can occur naturally when:
   - OIDC providers update their systems and change JSON formatting
   - CDNs serve cached responses with different orderings
   - Different validators fetch at different times during a provider update

This meets the Critical Severity criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** - This vulnerability can trigger without any malicious actors:

1. **JSON Has No Canonical Ordering**: The JSON specification explicitly states object keys are unordered. OIDC providers are not required to maintain consistent key ordering across requests.

2. **Common in Production**: Web services frequently change JSON formatting during:
   - Code deployments
   - CDN cache refreshes  
   - Load balancer routing changes
   - Server infrastructure updates

3. **Existing TODO Comment**: The developers are aware of this issue but haven't fixed it, suggesting it may already be causing operational problems.

4. **Reproducible**: The vulnerability can be demonstrated by simply parsing two JSON strings with different key orderings for the same JWK.

## Recommendation

Implement canonical JSON serialization when creating `UnsupportedJWK` payloads. Use a deterministic ordering (alphabetical by key) before serialization:

**Fix Implementation:**
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Canonicalize by serializing with sorted keys
        let payload = canonicalize_json(&json_value);
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}

fn canonicalize_json(value: &serde_json::Value) -> Vec<u8> {
    // Use serde_json with canonical formatting
    // Keys must be sorted alphabetically
    match value {
        serde_json::Value::Object(map) => {
            let mut sorted_map = std::collections::BTreeMap::new();
            for (k, v) in map.iter() {
                sorted_map.insert(k.clone(), canonicalize_json(v));
            }
            serde_json::to_vec(&serde_json::Value::Object(
                sorted_map.into_iter().collect()
            )).expect("JSON serialization should not fail")
        },
        serde_json::Value::Array(arr) => {
            let canonical_arr: Vec<_> = arr.iter()
                .map(canonicalize_json)
                .map(|bytes| serde_json::from_slice(&bytes).unwrap())
                .collect();
            serde_json::to_vec(&serde_json::Value::Array(canonical_arr))
                .expect("JSON serialization should not fail")
        },
        _ => serde_json::to_vec(value).expect("JSON serialization should not fail")
    }
}
```

Alternatively, consider using an existing canonical JSON library like `canonical_json` or following RFC 8785 (JSON Canonicalization Scheme).

## Proof of Concept

```rust
#[test]
fn test_unsupported_jwk_non_canonical_serialization() {
    use aptos_types::jwks::unsupported::UnsupportedJWK;
    use serde_json::json;

    // Same logical JWK, different key orderings
    let json_variant_1 = json!({
        "kty": "oct",
        "kid": "key-123",
        "k": "secret_value"
    });
    
    let json_variant_2 = json!({
        "kid": "key-123",
        "kty": "oct",
        "k": "secret_value"
    });

    // Convert to UnsupportedJWK
    let jwk1 = UnsupportedJWK::from(json_variant_1);
    let jwk2 = UnsupportedJWK::from(json_variant_2);

    // These should be equal for consensus, but they're not!
    println!("JWK1 payload: {:?}", String::from_utf8(jwk1.payload.clone()));
    println!("JWK2 payload: {:?}", String::from_utf8(jwk2.payload.clone()));
    println!("JWK1 id: {:?}", hex::encode(&jwk1.id));
    println!("JWK2 id: {:?}", hex::encode(&jwk2.id));
    
    // This assertion FAILS - same logical JWK, different hashes
    assert_ne!(jwk1.payload, jwk2.payload);
    assert_ne!(jwk1.id, jwk2.id);
    
    // Now show this breaks BCS consensus
    use aptos_types::jwks::{ProviderJWKs, jwk::JWKMoveStruct, JWK};
    
    let provider1 = ProviderJWKs {
        issuer: b"https://accounts.google.com".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(jwk1))],
    };
    
    let provider2 = ProviderJWKs {
        issuer: b"https://accounts.google.com".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(jwk2))],
    };
    
    // BCS serialization produces different bytes
    let bcs1 = bcs::to_bytes(&provider1).unwrap();
    let bcs2 = bcs::to_bytes(&provider2).unwrap();
    
    assert_ne!(bcs1, bcs2, "Different BCS encodings break consensus!");
    
    // This means validators cannot reach quorum
    use aptos_crypto::hash::CryptoHash;
    let hash1 = provider1.hash();
    let hash2 = provider2.hash();
    
    assert_ne!(hash1, hash2, "Different hashes prevent signature aggregation!");
}
```

**Notes**

This vulnerability is explicitly marked with a TODO comment in the source code, indicating the development team is aware of the issue but has not yet implemented a fix. The non-canonical JSON serialization represents a critical consensus safety violation that can cause network liveness failures without requiring any malicious actors, as OIDC providers naturally serve JSON with varying key orderings across different requests, CDN nodes, or deployment updates.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L455-461)
```rust
            fn hash(&self) -> aptos_crypto::hash::HashValue {
                use aptos_crypto::hash::CryptoHasher;

                let mut state = Self::Hasher::default();
                bcs::serialize_into(&mut state, &self).expect(#error_msg);
                state.finish()
            }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L196-206)
```rust
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
```
