# Audit Report

## Title
Path Traversal Vulnerability in Backup Storage System Allows Arbitrary File Read During Restore Operations

## Summary
The `BackupStorage` trait implementations in `LocalFs` and `CommandAdapter` lack validation of `FileHandle` values during `open_for_read()` operations. An attacker who can tamper with backup manifest files can inject path traversal sequences (e.g., `../../etc/passwd`) to read arbitrary files outside the backup directory during restore operations, potentially exposing validator private keys, consensus secrets, and sensitive configuration data.

## Finding Description

The backup storage system defines `FileHandle` as an unvalidated `String` type alias, contrasting with `ShellSafeName` which has strict regex validation. [1](#0-0) 

During backup operations, `FileHandle` values are embedded in manifest JSON files that contain metadata about backup chunks. These manifests include structures like `EpochEndingChunk`, `TransactionChunk`, and `StateSnapshotChunk`, all containing `FileHandle` fields: [2](#0-1) [3](#0-2) [4](#0-3) 

The critical vulnerability occurs in `LocalFs::open_for_read()`, which directly joins the base directory with the `FileHandle` without any validation or canonicalization: [5](#0-4) 

During restore operations, manifests are deserialized from JSON and their `FileHandle` values are passed directly to `open_for_read()`: [6](#0-5) 

**Attack Path:**
1. Attacker gains write access to backup storage (compromised credentials, weak filesystem permissions, supply chain attack)
2. Attacker modifies a manifest JSON file to replace legitimate FileHandle (e.g., `"backup_1/chunk_0.data"`) with malicious path traversal (e.g., `"../../../../../../home/validator/.aptos/validator.key"`)
3. When restore operation executes, it loads the tampered manifest via `load_json_file()`
4. The malicious `FileHandle` is passed to `open_for_read()`
5. Rust's `PathBuf::join()` preserves the `../` sequences without normalization
6. Operating system resolves path traversal when opening file, reading `/home/validator/.aptos/validator.key` instead of a file in the backup directory
7. Attacker exfiltrates sensitive data through backup system channels

## Impact Explanation

This vulnerability qualifies as **Critical Severity** (up to $1,000,000) under Aptos Bug Bounty criteria for the following reasons:

**Loss of Funds**: Exposing validator private keys allows direct theft of staked APT tokens and compromises consensus participation.

**Consensus Safety Violations**: Leaked consensus secrets (SafetyRules keys, voting keys) enable malicious validators to violate BFT safety guarantees, potentially causing chain splits or double-spend attacks.

**System-Wide Compromise**: Arbitrary file read can expose:
- Validator private keys (`validator.key`, `consensus_key`)
- Database credentials and connection strings
- Network authentication tokens
- System configuration revealing infrastructure topology
- Other validators' endpoints and credentials if stored locally

The vulnerability affects all validator nodes performing restore operations from compromised backup sources, making it a network-wide security risk during disaster recovery scenarios when validators are most vulnerable.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attack Prerequisites:**
1. Write access to backup storage (S3/GCS buckets, local filesystem)
2. Knowledge of target file paths on validator systems
3. Timing during restore operation

**Realistic Scenarios:**
- **Compromised Cloud Credentials**: AWS/GCS access keys leaked through CI/CD, developer workstations, or insider threats
- **Supply Chain Attacks**: Malicious backup provider or compromised backup infrastructure
- **Weak Filesystem Permissions**: LocalFs backups with world-writable directories
- **Man-in-the-Middle**: Interception and tampering of backup transfers if not properly encrypted/authenticated

The attack is more likely than it appears because:
- Backup storage is often less protected than production databases
- Restore operations typically occur during emergencies with reduced security vigilance
- Multiple validators may share backup infrastructure, amplifying impact
- JSON manifest files are human-readable and easy to modify

## Recommendation

**Immediate Fix**: Implement path validation in `open_for_read()` to prevent directory traversal:

```rust
// In storage/backup/backup-cli/src/storage/local_fs/mod.rs
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Validate file_handle doesn't contain path traversal
    let file_path = Path::new(file_handle);
    
    // Reject absolute paths
    ensure!(
        file_path.is_relative(),
        "FileHandle must be relative path, got: {}",
        file_handle
    );
    
    // Reject paths with parent directory references
    for component in file_path.components() {
        ensure!(
            !matches!(component, std::path::Component::ParentDir),
            "FileHandle contains illegal '..' component: {}",
            file_handle
        );
    }
    
    let path = self.dir.join(file_handle);
    
    // Canonicalize and verify path is within backup directory
    let canonical_path = path.canonicalize()
        .map_err(|e| anyhow!("Failed to canonicalize path: {}", e))?;
    let canonical_base = self.dir.canonicalize()
        .map_err(|e| anyhow!("Failed to canonicalize base directory: {}", e))?;
    
    ensure!(
        canonical_path.starts_with(&canonical_base),
        "FileHandle resolves outside backup directory: {}",
        file_handle
    );
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical_path)
        .await
        .err_notes(&canonical_path)?;
    Ok(Box::new(file))
}
```

**Additional Hardening:**
1. Apply similar validation to `CommandAdapter::backup_metadata_file()`: [7](#0-6) 

2. Add integrity protection to manifest files (HMAC/signatures)
3. Implement FileHandle format validation at deserialization time
4. Add security audit logging for all file access during restore
5. Consider making FileHandle a validated newtype instead of String alias

## Proof of Concept

```rust
// Test demonstrating path traversal vulnerability
#[cfg(test)]
mod security_tests {
    use super::*;
    use tempfile::TempDir;
    use tokio::fs;
    use std::path::PathBuf;

    #[tokio::test]
    async fn test_path_traversal_vulnerability() {
        // Setup: Create backup directory and sensitive file outside it
        let temp_root = TempDir::new().unwrap();
        let backup_dir = temp_root.path().join("backups");
        let sensitive_dir = temp_root.path().join("secrets");
        
        fs::create_dir(&backup_dir).await.unwrap();
        fs::create_dir(&sensitive_dir).await.unwrap();
        
        // Create sensitive file
        let secret_file = sensitive_dir.join("private.key");
        fs::write(&secret_file, b"VALIDATOR_PRIVATE_KEY_SECRET").await.unwrap();
        
        // Initialize LocalFs storage
        let storage = LocalFs::new(backup_dir.clone());
        
        // Attack: Construct path traversal FileHandle
        let malicious_handle = "../secrets/private.key";
        
        // Exploit: Read sensitive file through backup API
        let result = storage.open_for_read(malicious_handle).await;
        
        // Vulnerability: This succeeds and reads the private key!
        assert!(result.is_ok(), "Path traversal should succeed (vulnerability)");
        
        let mut reader = result.unwrap();
        let mut content = String::new();
        reader.read_to_string(&mut content).await.unwrap();
        
        assert_eq!(content, "VALIDATOR_PRIVATE_KEY_SECRET");
        println!("❌ VULNERABILITY CONFIRMED: Read sensitive file outside backup directory");
    }
    
    #[tokio::test]
    async fn test_manifest_based_attack() {
        // Demonstrates full attack via manifest manipulation
        let temp_dir = TempDir::new().unwrap();
        let backup_dir = temp_dir.path().join("backups");
        let secret_file = temp_dir.path().join("validator.key");
        
        fs::create_dir(&backup_dir).await.unwrap();
        fs::write(&secret_file, b"SECRET_CONSENSUS_KEY").await.unwrap();
        
        // Create malicious manifest
        let manifest = serde_json::json!({
            "first_epoch": 0,
            "last_epoch": 1,
            "waypoints": ["0x1234"],
            "chunks": [{
                "first_epoch": 0,
                "last_epoch": 1,
                "ledger_infos": "../validator.key"  // Path traversal
            }]
        });
        
        // Write manifest to backup storage
        let manifest_path = backup_dir.join("metadata").join("epoch_ending.json");
        fs::create_dir_all(manifest_path.parent().unwrap()).await.unwrap();
        fs::write(&manifest_path, manifest.to_string()).await.unwrap();
        
        // Simulate restore operation
        let storage = LocalFs::new(backup_dir);
        let manifest_data: serde_json::Value = 
            serde_json::from_slice(&fs::read(&manifest_path).await.unwrap()).unwrap();
        
        let malicious_handle = manifest_data["chunks"][0]["ledger_infos"]
            .as_str().unwrap();
        
        // Attack succeeds
        let mut reader = storage.open_for_read(malicious_handle).await.unwrap();
        let mut leaked = String::new();
        reader.read_to_string(&mut leaked).await.unwrap();
        
        assert_eq!(leaked, "SECRET_CONSENSUS_KEY");
        println!("❌ CRITICAL: Validator keys leaked via manifest path traversal");
    }
}
```

## Notes

This vulnerability is particularly dangerous because:

1. **Silent Exploitation**: No error logs or alerts when path traversal succeeds
2. **Disaster Recovery Window**: Exploitable when validators are recovering from failures and security monitoring may be degraded
3. **Infrastructure Access**: Backup systems often have broad access to validator infrastructure
4. **Persistent Threat**: Once manifests are tampered with, every restore operation exposes sensitive data

The contrast between `ShellSafeName` (which has strict validation) and `FileHandle` (which has none) suggests this was an oversight in the security design rather than an intentional decision.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L12-16)
```rust
pub struct EpochEndingChunk {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub ledger_infos: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L19-34)
```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L12-27)
```rust
pub struct StateSnapshotChunk {
    /// index of the first account in this chunk over all accounts.
    pub first_idx: usize,
    /// index of the last account in this chunk over all accounts.
    pub last_idx: usize,
    /// key of the first account in this chunk.
    pub first_key: HashValue,
    /// key of the last account in this chunk.
    pub last_key: HashValue,
    /// Repeated `len(record) + record` where `record` is BCS serialized tuple
    /// `(key, state_value)`
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L160-172)
```rust
    async fn read_chunk(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Vec<LedgerInfoWithSignatures>> {
        let mut file = self.storage.open_for_read(file_handle).await?;
        let mut chunk = vec![];

        while let Some(record_bytes) = file.read_record_bytes().await? {
            chunk.push(bcs::from_bytes(&record_bytes)?);
        }

        Ok(chunk)
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L142-160)
```rust
    async fn backup_metadata_file(&self, file_handle: &FileHandleRef) -> Result<()> {
        // extract the file name from the file_handle
        let name = Path::new(file_handle)
            .file_name()
            .and_then(OsStr::to_str)
            .ok_or_else(|| format_err!("cannot extract filename from {}", file_handle))?;
        let child = self
            .cmd(
                self.config
                    .commands
                    .backup_metadata_file
                    .as_ref()
                    .expect("metadata backup command not defined !"),
                vec![EnvVar::file_name(name)],
            )
            .spawn()?;
        child.join().await?;
        Ok(())
    }
```
