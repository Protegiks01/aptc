# Audit Report

## Title
Production Configuration Allows Unlimited Struct Definitions Despite Test Assumptions, Enabling Resource Exhaustion Attack

## Summary
The Aptos production configuration sets `max_struct_definitions: None` (unlimited), while test configurations assume a maximum of 200 struct definitions. This discrepancy allows attackers to publish modules with thousands of struct definitions (up to ~3,000 within transaction size limits), potentially causing validator node performance degradation through excessive verification overhead.

## Finding Description
The bytecode verifier test file defines `MAX_STRUCTS = 200` and tests validate that modules exceeding this limit are rejected. [1](#0-0) 

However, the actual production configuration explicitly sets no limit on struct definitions: [2](#0-1) 

The `VerifierConfig::production()` method (used only in tests) incorrectly approximates production with `max_struct_definitions: Some(200)`: [3](#0-2) 

**Attack Path:**
1. Attacker crafts a Move module with ~3,000 minimal struct definitions (empty structs with short names)
2. Module fits within 64KB transaction size limit (each struct ~20 bytes of bytecode)
3. Module passes `BinaryComplexityMeter` checks (only meters field signatures, not struct count): [4](#0-3) 
4. Module passes limits verification (no `max_struct_definitions` limit enforced): [5](#0-4) 
5. `RecursiveStructDefChecker` builds a graph with 3,000 nodes and performs topological sort: [6](#0-5) 
6. Every validator that loads this module incurs verification overhead for 3,000 struct definitions

**Broken Invariant**: "Move VM Safety: Bytecode execution must respect gas limits and memory constraints" and "Resource Limits: All operations must respect gas, storage, and computational limits"

## Impact Explanation
This qualifies as **High Severity** under "Validator node slowdowns" criteria. While individual module verification with 3,000 structs may complete in reasonable time, an attacker could:

1. Publish multiple such modules across different transactions
2. Force validators to repeatedly verify large struct graphs during state sync
3. Cause cumulative performance degradation across the network

The issue is exacerbated because the `BinaryComplexityMeter` does not charge for struct definition count—only for field type complexity. Attackers can maximize struct count while minimizing complexity charges.

## Likelihood Explanation
**High likelihood** - The attack is straightforward:
- No special privileges required (any account can publish modules)
- Attack vector is direct and deterministic
- No race conditions or timing dependencies
- Gas costs are proportional to transaction size, not struct count
- Multiple malicious modules can be published incrementally

## Recommendation
Add explicit struct definition limit to production configuration:

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    // ... existing code ...
    VerifierConfig {
        // ... other fields ...
        max_struct_definitions: Some(200),  // Add explicit limit matching test assumptions
        max_struct_variants: Some(90),
        max_fields_in_struct: Some(30),
        // ... remaining fields ...
    }
}
```

Additionally, enhance `BinaryComplexityMeter` to charge for struct definition count, not just field signatures.

## Proof of Concept
```move
// malicious_module.move
module 0x1::dos_attack {
    struct S0 {}
    struct S1 {}
    struct S2 {}
    // ... repeat for S3 through S2999 ...
    struct S2999 {}
    
    // Minimal bytecode size: ~20 bytes per struct × 3000 = 60KB
    // Passes all production limits
    // Forces expensive graph verification on all validators
}
```

**Compilation and deployment:**
```bash
# Compile module to bytecode (will fit in 64KB)
aptos move compile --package-dir malicious_module

# Publish via transaction (costs normal gas for 64KB payload)
aptos move publish --package-dir malicious_module

# All validators must now verify 3000-node struct dependency graph
# RecursiveStructDefChecker performs O(V+E) topological sort
# Verification time scales linearly with struct count
```

**Notes**

The vulnerability exists because production and test configurations diverge on struct definition limits. The production environment uses `aptos_prod_vm_config()` which calls `aptos_prod_verifier_config()`, setting `max_struct_definitions: None`. This was likely intentional to avoid artificial restrictions, but creates an attack surface not covered by tests. The `BinaryComplexityMeter` provides partial protection by limiting overall module complexity, but doesn't directly limit struct count, allowing attackers to maximize struct definitions while minimizing per-struct complexity.

### Citations

**File:** third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/limit_tests.rs (L285-285)
```rust
const MAX_STRUCTS: usize = 200;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-168)
```rust
        max_struct_definitions: None,
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L297-297)
```rust
            max_struct_definitions: Some(200),
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L238-244)
```rust
        for sdef in struct_defs {
            match &sdef.field_information {
                StructFieldInformation::Native => continue,
                StructFieldInformation::Declared(fields) => {
                    for field in fields {
                        self.charge(field.signature.0.num_nodes() as u64)?;
                    }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L207-214)
```rust
        if let Some(defs) = self.resolver.struct_defs() {
            if let Some(max_struct_definitions) = config.max_struct_definitions {
                if defs.len() > max_struct_definitions {
                    return Err(PartialVMError::new(
                        StatusCode::MAX_STRUCT_DEFINITIONS_REACHED,
                    ));
                }
            }
```

**File:** third_party/move/move-bytecode-verifier/src/struct_defs.rs (L34-45)
```rust
        let graph = StructDefGraphBuilder::new(checker.module).build()?;

        // toposort is iterative while petgraph::algo::is_cyclic_directed is recursive. Prefer
        // the iterative solution here as this code may be dealing with untrusted data.
        match toposort(&graph, None) {
            Ok(_) => Ok(()),
            Err(cycle) => Err(verification_error(
                StatusCode::RECURSIVE_STRUCT_DEFINITION,
                IndexKind::StructDefinition,
                cycle.node_id().into_index() as TableIndex,
            )),
        }
```
