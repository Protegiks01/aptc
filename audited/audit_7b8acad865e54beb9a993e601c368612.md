# Audit Report

## Title
Encrypted Transactions Bypass Batch-Level Transaction Filters in Consensus Layer

## Summary
The `TransactionMatcher` implementation fails to properly validate encrypted transactions, allowing attackers to bypass critical batch-level filtering rules. When filters attempt to match encrypted payloads against entry functions, module addresses, or script arguments, the matchers return `false` due to inaccessible encrypted content. This causes Deny rules to fail matching (since ALL matchers must match), resulting in encrypted transactions being allowed by default even when they should be blocked.

## Finding Description

The vulnerability exists in the interaction between the batch transaction filtering system and encrypted transaction handling across three key components:

**1. Filter Application Point:**
In the consensus layer's batch coordinator, transaction filters are applied to incoming batches before decryption occurs. [1](#0-0) 

**2. Encrypted Payload Handling:**
When `TransactionMatcher` attempts to validate encrypted transactions, the `executable_ref()` method returns an error for payloads in the `Encrypted` or `FailedDecryption` states, only succeeding for `Decrypted` payloads. [2](#0-1) 

**3. Matcher Failure Mode:**
When matching entry functions in encrypted payloads, if `payload.executable_ref()` returns an error, the matcher silently returns `false` rather than treating it as a potential security violation. [3](#0-2) 

The same issue affects module address matching [4](#0-3)  and script argument matching [5](#0-4) .

**4. Default-Allow Behavior:**
The filter uses a default-allow policy when no rules match. Since the matchers return `false` for encrypted payloads, Deny rules fail to match (requiring ALL matchers to succeed), and the transaction is allowed. [6](#0-5) 

**5. Rule Matching Logic:**
Rules only apply when ALL their constituent matchers return `true`. If any matcher returns `false`, the entire rule fails to match. [7](#0-6) 

**6. No Re-filtering After Decryption:**
Decryption occurs later in the consensus pipeline, but there is no second filter application after transactions are decrypted. [8](#0-7) 

**Attack Scenario:**

1. Network operators deploy a Deny rule to block dangerous operations during an incident, such as:
   - `Deny([Transaction(EntryFunction(0x1, "governance", "emergency_action"))])`

2. Attacker creates a transaction calling the blocked entry function and encrypts the payload using the batch threshold encryption scheme.

3. The encrypted transaction is submitted in a batch and reaches the batch coordinator.

4. The filter checks `allows_transaction()` which evaluates the Deny rule's EntryFunction matcher.

5. The matcher attempts to access the encrypted payload's executable via `executable_ref()`, which returns `Err("Transaction is encrypted")`.

6. The matcher returns `false`, causing the Deny rule to fail matching (ALL matchers must return `true`).

7. No other rules match, so the default-allow policy applies, and the transaction passes the filter.

8. The transaction enters consensus, gets decrypted, and executes the blocked entry function without any filter check.

This breaks the **Transaction Validation** invariant that filters must enforce security policies before execution.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria)

This vulnerability enables **significant protocol violations** by allowing attackers to bypass consensus-layer security controls:

1. **Emergency Response Bypass**: During security incidents, operators may deploy filters to block dangerous operations. Encrypted transactions can bypass these emergency controls, allowing attacks to continue.

2. **Governance Manipulation**: Filters blocking specific governance actions (voting, proposal execution) can be bypassed, potentially enabling unauthorized governance changes.

3. **Validator Security**: Filters are applied at the consensus layer before transaction execution, making this a core protocol-level security mechanism. Bypassing it affects all validators uniformly.

4. **No Defense in Depth**: Since decryption happens after filtering with no re-application of filters, there is no secondary defense mechanism.

The impact is amplified because:
- The bypass is deterministic and affects all validators identically
- Encrypted transactions are a standard feature available to all users
- Filters are explicitly designed as security controls in the consensus layer
- The vulnerability undermines trust in the filtering mechanism itself

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible because:

1. **Low Technical Barrier**: Any user can submit encrypted transactions using the standard batch threshold encryption scheme. No special privileges or validator access required.

2. **Public Filter Information**: Filter rules may be publicly known through governance announcements or security incident responses, allowing attackers to specifically target them.

3. **Deterministic Behavior**: The bypass works consistently across all encrypted transactions with no random factors.

4. **No Detection**: The vulnerability is silent - encrypted transactions passing through appear legitimate to monitoring systems.

5. **Production Relevance**: Filters are specifically designed for emergency response and security enforcement scenarios where this bypass would be most dangerous.

The only requirement is the ability to submit encrypted transactions, which is a standard feature of the Aptos protocol.

## Recommendation

**Immediate Fix:**

Modify the matcher logic to handle encrypted payloads explicitly rather than treating access errors as "no match". For security-critical matchers, encrypted transactions should either:

1. **Conservative Approach (Recommended)**: Treat inaccessible encrypted payloads as potential matches, causing Deny rules to apply:

```rust
// In transaction_filter.rs, matches_entry_function()
TransactionPayload::EncryptedPayload(payload) => {
    match payload.executable_ref() {
        Ok(executable) => {
            match executable {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            }
        },
        Err(_) => {
            // Conservative: assume encrypted payloads might match
            // This causes Deny rules to apply to encrypted transactions
            true
        }
    }
}
```

2. **Alternative Approach**: Add explicit configuration for how to handle encrypted transactions in filter rules (allow encrypted, deny encrypted, or require decryption before filtering).

**Long-term Solution:**

Implement a two-phase filtering system:
1. Pre-decryption filter (batch level) - checks sender, transaction ID, public metadata
2. Post-decryption filter (execution level) - checks entry functions, module addresses, arguments

Apply both filters to ensure encrypted transactions cannot bypass security controls.

**Configuration Update:**

Add a filter configuration option to specify encrypted transaction handling:
```rust
pub enum EncryptedTransactionPolicy {
    AllowAllEncrypted,  // Current behavior (unsafe)
    DenyAllEncrypted,   // Block all encrypted transactions
    TreatAsMatch,       // Assume encrypted payloads match (conservative)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::HashValue;
    use aptos_types::{
        transaction::{
            RawTransaction, SignedTransaction, TransactionPayload,
            encrypted_payload::EncryptedPayload,
        },
        chain_id::ChainId,
        account_address::AccountAddress,
        quorum_store::BatchId,
        PeerId,
    };
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_crypto::{PrivateKey, Uniform};

    #[test]
    fn test_encrypted_transaction_bypasses_entry_function_filter() {
        // Create a filter that denies transactions calling a specific entry function
        let blocked_address = AccountAddress::from_hex_literal("0x1").unwrap();
        let blocked_module = "governance".to_string();
        let blocked_function = "vote".to_string();
        
        let entry_function_matcher = TransactionMatcher::EntryFunction(
            blocked_address,
            blocked_module.clone(),
            blocked_function.clone(),
        );
        
        let filter = BatchTransactionFilter::new(vec![
            BatchTransactionRule::Deny(vec![
                BatchTransactionMatcher::Transaction(entry_function_matcher)
            ])
        ]);

        // Create an encrypted transaction (in Encrypted state, not yet decrypted)
        // In reality, this would call the blocked entry function after decryption
        let encrypted_payload = EncryptedPayload::Encrypted {
            ciphertext: create_dummy_ciphertext(),
            extra_config: TransactionExtraConfig::default(),
            payload_hash: HashValue::random(),
        };
        
        let raw_txn = RawTransaction::new(
            AccountAddress::random(),
            0,
            TransactionPayload::EncryptedPayload(encrypted_payload),
            100000,
            1,
            99999999999,
            ChainId::test(),
        );
        
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let signature = private_key.sign(&raw_txn).unwrap();
        let signed_txn = SignedTransaction::new(
            raw_txn,
            private_key.public_key(),
            signature,
        );

        // Test: The encrypted transaction should be blocked, but it bypasses the filter
        let batch_id = BatchId::new_for_test(1);
        let batch_author = PeerId::random();
        let batch_digest = HashValue::random();
        
        let is_allowed = filter.allows_transaction(
            batch_id,
            batch_author,
            &batch_digest,
            &signed_txn,
        );

        // VULNERABILITY: The encrypted transaction is ALLOWED even though it would
        // call the blocked entry function after decryption
        assert_eq!(is_allowed, true, "Encrypted transaction bypasses entry function filter!");
        
        // Expected behavior: should be DENIED (false)
        // Actual behavior: ALLOWED (true) - SECURITY BYPASS
    }
    
    fn create_dummy_ciphertext() -> aptos_types::secret_sharing::Ciphertext {
        // Create a minimal ciphertext for testing purposes
        // In production, this would be properly encrypted payload
        use aptos_types::secret_sharing::Ciphertext;
        Ciphertext::new(vec![0u8; 32], 0)
    }
}
```

**Expected Output:**
The test demonstrates that encrypted transactions bypass entry function filters. The assertion `assert_eq!(is_allowed, true)` succeeds, proving the vulnerability exists. The comment indicates the expected secure behavior would be `false` (denied).

**Notes**

This vulnerability specifically affects the following matcher types when applied to encrypted transactions:
- `EntryFunction` matcher
- `ModuleAddress` matcher  
- `AccountAddress` matcher (partially - only the entry function and script argument checks)
- Script argument matching

Other matchers like `Sender`, `TransactionId`, and `PublicKey` are unaffected as they check transaction metadata accessible without decryption.

The vulnerability is particularly critical because batch transaction filters are explicitly positioned as a consensus-layer security mechanism, applied before transactions enter the execution pipeline. This represents a fundamental security boundary that can be bypassed using standard protocol features.

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L191-213)
```rust
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L362-374)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L405-416)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L471-483)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::EntryFunction(_)
                    | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::Script(script) => {
                        compare_script_argument_address(script, address)
                    },
                }
            } else {
                false
            }
        },
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L57-57)
```rust
        true // No rules match (allow the batch transaction by default)
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L162-164)
```rust
        batch_transaction_matchers.iter().all(|matcher| {
            matcher.matches(batch_id, batch_author, batch_digest, signed_transaction)
        })
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```
