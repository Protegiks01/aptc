# Audit Report

## Title
Block Epilogue Failure Silently Skips Fee Distribution While Keeping Block

## Summary
The `process_block_epilogue()` function in `aptos_vm.rs` contains overly permissive error handling that returns a success status even when the block epilogue execution fails. This causes transaction fee distribution to validators to be silently skipped while the block remains committed, resulting in permanent fee loss for validators. [1](#0-0) 

## Finding Description
When the block epilogue transaction executes, it calls the Move function `block::block_epilogue`, which in turn invokes `stake::record_fee` to distribute accumulated transaction fees to validators based on their proposer indices. [2](#0-1) 

The `record_fee` function attempts to update fee accumulators in the `PendingTransactionFee` resource by looking up each validator index in the `pending_fee_by_validator` map: [3](#0-2) 

The critical issue occurs at the `borrow_mut` call, which uses `BigOrderedMap::borrow_mut`. This function aborts with `EKEY_NOT_FOUND` if the validator index doesn't exist in the map: [4](#0-3) 

When any Move abort occurs during block epilogue execution (including missing validator indices, missing resources, or any other failure), the error is caught and handled by returning a **success status with empty output**. This means:
1. The block is marked as `Keep(Success)` and committed to the chain
2. No state changes are applied (empty VMOutput)
3. **Fee distribution is completely skipped**
4. Only an error log is produced with no on-chain record

The validator indices in the `pending_fee_by_validator` map are populated only with active validators during epoch transitions: [5](#0-4) 

**Failure Scenarios:**
1. **Validator index mismatch**: If a proposer_index from transaction auxiliary info doesn't exist in the current active validator set map
2. **Missing PendingTransactionFee resource**: If the resource hasn't been initialized (unlikely on mainnet but possible on testnets)
3. **Vector length mismatch**: If fee distribution vectors have inconsistent lengths (bug in `gen_block_epilogue`)
4. **Any other Move abort**: Any abort in the epilogue call chain results in silent fee loss

The fee distribution data is calculated in `gen_block_epilogue`: [6](#0-5) 

## Impact Explanation
This vulnerability causes **permanent loss of transaction fees** for validators when block epilogue execution fails. According to the Aptos bug bounty program, this qualifies as **Medium Severity** under "Limited funds loss or manipulation" and "State inconsistencies requiring intervention."

**Specific Impacts:**
1. **Financial Loss**: Validators lose all transaction fees from blocks where epilogue fails
2. **No Recovery Mechanism**: Lost fees cannot be recovered as there's no on-chain record of the failure
3. **Consensus Risk**: If different validators have inconsistent state (e.g., different validator sets), some nodes might succeed while others fail, potentially causing state divergence
4. **Broken Invariant**: Violates "Staking Security: Validator rewards and penalties must be calculated correctly"

The impact is limited to fee loss rather than consensus safety violations, but the permanent nature of the loss and lack of detection/recovery mechanisms justify Medium severity.

## Likelihood Explanation
The likelihood is **Low to Medium** based on several factors:

**Factors Increasing Likelihood:**
- The error handling is overly broad, catching ALL epilogue failures
- No validation exists to ensure validator indices in fee distribution match the current active set
- Epoch transitions could create timing windows where validator sets are inconsistent
- Any bug in fee calculation or state management triggers this path

**Factors Decreasing Likelihood:**
- `PendingTransactionFee` is initialized during genesis on mainnet
- Validator indices are typically consistent within an epoch
- The system is generally designed to maintain validator set consistency

**Realistic Scenarios:**
1. Race conditions during epoch transitions
2. Bugs in proposer_index assignment in transaction auxiliary info
3. State corruption or inconsistencies across nodes
4. Feature flag changes affecting fee distribution logic

The error has likely occurred in production given the permissive error handling, though without monitoring, failures would go undetected.

## Recommendation
The error handling should be made more strict and specific:

```rust
let output = match session
    .execute_function_bypass_visibility(/* ... */)
    .map(|_return_vals| ())
    .or_else(|e| expect_only_successful_execution(e, BLOCK_EPILOGUE.as_str(), log_context))
{
    Ok(_) => get_system_transaction_output(
        session,
        module_storage,
        &self.storage_gas_params(log_context)?.change_set_configs,
    )?,
    Err(e) => {
        // DO NOT return success for epilogue failures
        // This causes permanent fee loss with no recovery
        alert!(
            "CRITICAL: Block epilogue failed: {e:?}. Fees will not be distributed. \
             This may indicate validator set inconsistency or state corruption."
        );
        
        // Return error status to signal the failure
        // This forces block rejection or retry rather than silent fee loss
        return Err(e);
    },
};
```

Additionally, add validation before fee distribution:
1. Verify all validator indices in fee distribution exist in the active validator set
2. Add metrics/alerts for epilogue failures
3. Consider implementing a fee recovery mechanism for failed distributions
4. Add explicit feature flag checks before attempting fee distribution

In `record_fee`, add defensive checks:
```move
// Validate validator index exists before attempting borrow_mut
if (!pending_fee.pending_fee_by_validator.contains(&validator_index)) {
    // Log error, skip this validator, or abort depending on desired behavior
    continue; // or abort with specific error code
}
```

## Proof of Concept

```rust
#[test]
fn test_block_epilogue_failure_skips_fees() {
    // Setup: Create a block with transactions that generate fees
    let mut executor = FakeExecutor::from_head_genesis();
    
    // Create validator set
    let validator = validator_addresses::get(0);
    let proposer_idx = 0u64;
    
    // Execute block with user transactions
    let txn = create_user_transaction_with_fees();
    executor.execute_block(vec![txn]).unwrap();
    
    // Create block epilogue with INVALID validator index
    // This simulates the scenario where proposer_index doesn't exist in map
    let invalid_proposer_idx = 999u64; // Non-existent validator
    let fee_distribution = FeeDistribution::new(
        vec![(invalid_proposer_idx, 1000000)].into_iter().collect()
    );
    
    let epilogue = Transaction::BlockEpilogue(BlockEpiloguePayload::V1 {
        block_id: HashValue::random(),
        fee_distribution,
        block_end_info: BlockEndInfo::default(),
    });
    
    // Execute block epilogue
    let output = executor.execute_transaction(epilogue);
    
    // VULNERABILITY: Epilogue returns SUCCESS even though record_fee failed
    assert_eq!(output.status(), TransactionStatus::Keep(ExecutionStatus::Success));
    
    // VULNERABILITY: Output is empty - no state changes, fees not distributed
    assert!(output.write_set().is_empty());
    
    // Verify validator DID NOT receive fees (permanent loss)
    let validator_fees = executor.read_stake_pool_fees(validator);
    assert_eq!(validator_fees, 0); // Fees were lost!
}
```

## Notes
This vulnerability highlights a broader issue with error handling in system transactions. The permissive fallback to success status prioritizes liveness over correctness, which can lead to silent data loss. While this approach prevents chain halts, it violates the critical invariant that validators must receive their earned fees. A better approach would be to fail fast with proper alerting and recovery mechanisms rather than silently losing funds.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2611-2617)
```rust
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L249-255)
```text
    fun block_epilogue(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) {
        stake::record_fee(vm, fee_distribution_validator_indices, fee_amounts_octa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L616-635)
```text
    public(friend) fun record_fee(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) acquires PendingTransactionFee {
        // Operational constraint: can only be invoked by the VM.
        system_addresses::assert_vm(vm);

        assert!(fee_distribution_validator_indices.length() == fee_amounts_octa.length());

        let num_validators_to_distribute = fee_distribution_validator_indices.length();
        let pending_fee = borrow_global_mut<PendingTransactionFee>(@aptos_framework);
        let i = 0;
        while (i < num_validators_to_distribute) {
            let validator_index = fee_distribution_validator_indices[i];
            let fee_octa = fee_amounts_octa[i];
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
            i = i + 1;
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1454-1458)
```text
        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            assert!(pending_fee_by_validator.is_empty(), error::internal(ETRANSACTION_FEE_NOT_FULLY_DISTRIBUTED));
            validator_set.active_validators.for_each_ref(|v| pending_fee_by_validator.add(v.config.validator_index, aggregator_v2::create_unbounded_aggregator<u64>()));
        };
```

**File:** aptos-move/framework/aptos-framework/sources/datastructures/big_ordered_map.move (L597-600)
```text
    public fun borrow_mut<K: drop + copy + store, V: store>(self: &mut BigOrderedMap<K, V>, key: &K): &mut V {
        let iter = self.internal_find(key);
        assert!(!iter.iter_is_end(self), error::invalid_argument(EKEY_NOT_FOUND));
        iter.iter_borrow_mut(self)
```

**File:** aptos-move/block-executor/src/executor.rs (L2042-2078)
```rust
        for (i, output) in outputs.enumerate().take(epilogue_txn_idx as usize) {
            // TODO(grao): Also include other transactions that is "Keep" if we are confident
            // that we successfully charge enough gas amount as it appears in the FeeStatement
            // for every corner cases.
            if !output.is_materialized_and_success() {
                continue;
            }
            let output_after_guard = output.after_materialization()?;
            let fee_statement = output_after_guard.fee_statement();

            let txn = signature_verified_block.get_txn(i as TxnIndex);
            if let Some(user_txn) = txn.try_as_signed_user_txn() {
                let auxiliary_info = signature_verified_block.get_auxiliary_info(i as TxnIndex);
                if let Some(proposer_index) = auxiliary_info.proposer_index() {
                    let gas_price = user_txn.gas_unit_price();
                    let total_gas_unit = fee_statement.gas_used();
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
                        }
                    }
                }
            }
        }
```
