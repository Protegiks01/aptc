# Audit Report

## Title
Absence of Emergency Fast-Track Governance Mechanism Creates Extended Vulnerability Window for Critical Cryptographic Vulnerabilities

## Summary
Aptos governance lacks emergency procedures to rapidly rotate validator keys or upgrade cryptographic implementations in production (mainnet). All governance proposals, including critical security updates, must go through the standard 7-day voting period with no bypass mechanism, creating an extended exploitation window if cryptographic vulnerabilities are discovered.

## Finding Description

The Aptos governance system requires all proposals to complete a mandatory voting period before execution. On mainnet, this is configured to 7 days (604,800 seconds). [1](#0-0) 

The governance configuration is initialized during genesis and stored in the `GovernanceConfig` struct: [2](#0-1) 

Individual validators can rotate their consensus keys using `rotate_consensus_key`, which validates a proof-of-possession and takes effect at the next epoch: [3](#0-2) 

However, there is **no mechanism** to:
1. Force coordinated mass key rotation across all validators
2. Fast-track governance proposals in emergency situations on mainnet
3. Bypass the 7-day voting period for critical security updates

The `set_fast_resolve` function exists but only works in testnet environments with mint capability: [4](#0-3) 

Similarly, `get_signer_testnet_only` explicitly checks for mint capability, which does not exist on mainnet: [5](#0-4) 

For cryptographic implementation upgrades via feature flags, the `change_feature_flags_for_next_epoch` function requires the framework signer (obtained only through governance): [6](#0-5) 

**Attack Scenario:**
If a critical cryptographic vulnerability is discovered (e.g., BLS12-381 signature forgery, proof-of-possession bypass):

1. Security researchers or attackers discover the vulnerability
2. Aptos Foundation creates governance proposal for emergency patch
3. Proposal enters 7-day voting period (minimum on mainnet)
4. During this window, sophisticated attackers who learned of the vulnerability can:
   - Forge validator signatures
   - Impersonate validators
   - Create equivocations
   - Violate consensus safety
5. Even after governance passes (day 7), validators must individually rotate keys
6. No coordination ensures all validators upgrade before exploitation

## Impact Explanation

This represents a **HIGH severity** issue under the Aptos bug bounty categories because it could lead to:

- **Consensus Safety Violations**: If BLS signature verification is compromised, attackers could forge quorum certificates and cause chain splits (CRITICAL impact)
- **Validator Impersonation**: Attackers could sign blocks as legitimate validators (CRITICAL impact)
- **Loss of Network Integrity**: During the 7+ day exposure window, the network operates with known vulnerable cryptography (HIGH impact)

The extended time window between vulnerability disclosure and deployment of fixes creates significant risk, especially for zero-day vulnerabilities where attackers may already have exploits prepared.

## Likelihood Explanation

While discovering a fundamental cryptographic vulnerability in BLS12-381 or other primitives is relatively unlikely (these are well-studied cryptosystems), the likelihood increases due to:

1. **Complexity of Cryptographic Systems**: Proof-of-possession validation, pairing operations, and multi-signature schemes have complex implementations
2. **Implementation Bugs**: Even if the mathematics is sound, implementation vulnerabilities in Rust crypto libraries can occur
3. **Side-Channel Attacks**: Timing attacks or other side-channels discovered in constant-time implementations (as referenced in the original file `is_zkcrypto_constant_time.rs`)
4. **Future Cryptanalysis**: Advances in cryptanalysis or quantum computing could weaken current assumptions

The **7-day mandatory exposure window** significantly amplifies the impact when vulnerabilities do occur.

## Recommendation

Implement a multi-tier emergency governance mechanism:

**1. Add Emergency Proposal Type**

Create an emergency proposal variant that:
- Requires supermajority (e.g., 80% of voting power) instead of simple majority
- Has reduced voting duration (e.g., 24-48 hours)
- Restricted to critical security updates only
- Includes additional validation to prevent abuse

**2. Implement Coordinated Key Rotation**

Add governance capability to trigger coordinated validator key rotation:
- Governance proposal specifies target epoch for rotation
- Validators must submit new keys before target epoch
- Automatic exclusion from validator set if keys not rotated by deadline
- Emergency reconfiguration if threshold of validators complete rotation

**3. Feature Flag Emergency Disable**

Allow immediate disabling (not enabling) of vulnerable cryptographic features:
- Create "emergency disable" capability separate from normal feature flags
- Requires multiple validator signatures (e.g., 2/3 threshold)
- Can only disable, not enable features
- Automatically triggers governance proposal for permanent resolution

**4. Cryptographic Agility**

Implement version negotiation for cryptographic primitives:
- Support multiple signature schemes simultaneously
- Allow gradual migration to new schemes
- Maintain backward compatibility during transition period

The implementation would require modifications to:
- `aptos_governance.move`: Add `EmergencyProposal` type with shorter duration
- `stake.move`: Add `coordinated_rotate_consensus_key` with governance enforcement
- `features.move`: Add emergency disable capability with multi-sig requirement

## Proof of Concept

This is a **design limitation** rather than an exploitable code bug. A PoC cannot demonstrate exploitation of non-existent emergency procedures. However, the absence can be verified by:

1. Examining governance code - no fast-track mechanism exists: [7](#0-6) 

2. Verifying testnet-only bypass restrictions: [5](#0-4) 

3. Confirming 7-day mainnet voting requirement in genesis configuration

The vulnerability manifests as an **operational security gap** rather than exploitable code, representing a process failure in incident response capabilities.

---

## Notes

While this finding represents a legitimate security concern about Aptos's ability to respond to cryptographic emergencies, it differs from traditional code vulnerabilities. It is a **design limitation** in the governance system that creates extended exposure windows during security incidents. The severity assessment assumes that cryptographic vulnerabilities, while rare, have catastrophic impact when they occur, and the 7-day minimum response time is inadequate for critical security events.

The referenced file `is_zkcrypto_constant_time.rs` is an example testing framework for constant-time cryptographic operations, indicating the Aptos team's awareness of implementation-level security concerns. However, no corresponding emergency response mechanism exists at the governance layer to handle discovered vulnerabilities rapidly.

### Citations

**File:** aptos-move/vm-genesis/src/lib.rs (L886-905)
```rust
fn initialize_on_chain_governance(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl AptosModuleStorage,
    traversal_context: &mut TraversalContext,
    genesis_config: &GenesisConfiguration,
) {
    exec_function(
        session,
        module_storage,
        traversal_context,
        GOVERNANCE_MODULE_NAME,
        "initialize",
        vec![],
        serialize_values(&vec![
            MoveValue::Signer(CORE_CODE_ADDRESS),
            MoveValue::U128(genesis_config.min_voting_threshold),
            MoveValue::U64(genesis_config.required_proposer_stake),
            MoveValue::U64(genesis_config.voting_duration_secs),
        ]),
    );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L87-91)
```text
    struct GovernanceConfig has key {
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_duration_secs: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L370-435)
```text
    public entry fun create_proposal(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
    ) acquires GovernanceConfig, GovernanceEvents {
        create_proposal_v2(proposer, stake_pool, execution_hash, metadata_location, metadata_hash, false);
    }

    /// Create a single-step or multi-step proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    public entry fun create_proposal_v2(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ) acquires GovernanceConfig, GovernanceEvents {
        create_proposal_v2_impl(
            proposer,
            stake_pool,
            execution_hash,
            metadata_location,
            metadata_hash,
            is_multi_step_proposal
        );
    }

    /// Create a single-step or multi-step proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    /// Return proposal_id when a proposal is successfully created.
    public fun create_proposal_v2_impl(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ): u64 acquires GovernanceConfig, GovernanceEvents {
        check_governance_permission(proposer);
        let proposer_address = signer::address_of(proposer);
        assert!(
            stake::get_delegated_voter(stake_pool) == proposer_address,
            error::invalid_argument(ENOT_DELEGATED_VOTER)
        );

        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );

        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.
        let current_time = timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
        assert!(
            stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );

```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L720-727)
```text
    /// Only called in testnet where the core resources account exists and has been granted power to mint Aptos coins.
    public fun get_signer_testnet_only(
        core_resources: &signer, signer_address: address): signer acquires GovernanceResponsbility {
        system_addresses::assert_core_resource(core_resources);
        // Core resources account only has mint capability in tests/testnets.
        assert!(aptos_coin::has_mint_capability(core_resources), error::unauthenticated(EUNAUTHORIZED));
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L909-932)
```text
    /// Rotate the consensus key of the validator, it'll take effect in next epoch.
    public entry fun rotate_consensus_key(
        operator: &signer,
        pool_address: address,
        new_consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);

        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));

        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_consensus_pubkey = validator_info.consensus_pubkey;
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
        validator_info.consensus_pubkey = new_consensus_pubkey;
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L134-153)
```rust
    /// Change the time for a network to resolve governance proposal
    pub async fn set_fast_resolve(&self, resolution_time: u64) -> Result<()> {
        let fast_resolve_script = aptos_temppath::TempPath::new();
        fast_resolve_script.create_as_file()?;
        let mut fas_script_path = fast_resolve_script.path().to_path_buf();
        fas_script_path.set_extension("move");

        std::fs::write(fas_script_path.as_path(), format!(r#"
        script {{
            use aptos_framework::aptos_governance;

            fun main(core_resources: &signer) {{
                let core_signer = aptos_governance::get_signer_testnet_only(core_resources, @0000000000000000000000000000000000000000000000000000000000000001);

                let framework_signer = &core_signer;

                aptos_governance::update_governance_config(framework_signer, 0, 0, {});
            }}
        }}
        "#, resolution_time).as_bytes())?;
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L804-828)
```text
    /// Enable and disable features for the next epoch.
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```
