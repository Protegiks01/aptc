# Audit Report

## Title
Resource Exhaustion via Unauthenticated RequestShare Messages from Malicious Validators

## Summary
The `RequestShare` message verification only validates epoch matching but performs no sender authorization checks. While non-validators are blocked at the network layer by mutual authentication, any validator can send `RequestShare` messages to any other validator for arbitrary rounds, forcing expensive cryptographic share generation operations and causing resource exhaustion.

## Finding Description

The vulnerability exists in the randomness generation protocol's message verification logic. When a validator receives a `RequestShare` message, the `verify()` function only checks epoch validity: [1](#0-0) 

The `RequestShare` variant returns `Ok(())` without any validation beyond the epoch check, unlike other message types that perform cryptographic verification or sender validation.

When a `RequestShare` message passes verification, it's processed by the RandManager: [2](#0-1) 

If no cached share exists for the requested metadata, the validator generates a new share using expensive cryptographic operations (`WVUF::create_share`): [3](#0-2) 

The only application-level validation occurs in `get_self_share`, which checks that the requested round doesn't exceed `highest_known_round`: [4](#0-3) 

**Attack Path:**
1. Malicious validator M observes that honest validator V has `highest_known_round = 10,000`
2. M sends `RequestShare` messages for rounds 1 through 10,000 to V
3. For each round where V lacks a cached share (e.g., after restart), V performs expensive `WVUF::create_share` operations
4. M can repeat this attack against all validators simultaneously
5. While shares are cached after generation (preventing duplicate work for the same epoch/round), the initial generation cost is substantial

**Network Layer Protection (Insufficient):**
The validator network enforces mutual authentication, blocking non-validators: [5](#0-4) 

However, this only prevents external attackers. Within the validator set, any validator can request shares from any other validator without authorization checks.

## Impact Explanation

This vulnerability enables **validator node slowdowns**, qualifying as **High severity** per the Aptos bug bounty program (up to $50,000).

**Severity Justification:**
- **Resource Exhaustion**: Forces validators to perform up to `highest_known_round` cryptographic operations (potentially 10,000+ WVUF share creations)
- **Validator Performance Degradation**: Slows down consensus participation during the attack
- **Coordinated Attack Potential**: A malicious validator can target all honest validators simultaneously
- **Byzantine Fault Scenario**: Exploitable by any compromised validator within the Byzantine fault tolerance threshold

**Limitations:**
- Requires being a validator (not exploitable by external attackers)
- Each (epoch, round) pair only generates one share due to caching
- Limited to current epoch and rounds â‰¤ `highest_known_round`
- Does not directly violate consensus safety or cause fund loss

The impact is amplified when validators restart without cached shares, or when `highest_known_round` is large.

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**
- Any validator can become malicious (compromised keys, insider threat, Byzantine behavior)
- Attack is straightforward - simply send `RequestShare` for many rounds
- No rate limiting or deduplication on the receiving side
- Channel buffer limits are modest (10 messages per sender): [6](#0-5) 

- Validators without cached shares (post-restart) are most vulnerable

**Factors Decreasing Likelihood:**
- Requires validator access (not arbitrary network participants)
- Caching prevents repeated exploitation of the same rounds
- Attack duration is limited by share cache lifetime

**Realistic Scenario:**
A validator with 1/3 of the stake becomes compromised or acts maliciously. It sends bulk `RequestShare` messages to all other validators during a high-activity epoch, causing temporary performance degradation across the network.

## Recommendation

Add sender authorization validation in the `RequestShare` verification path. The verification should check:

1. **Sender is a validator**: Validate against `epoch_state.verifier`
2. **Rate limiting**: Track RequestShare frequency per sender
3. **Round reasonableness**: Only allow requests for recent rounds (e.g., within last 100 rounds of `highest_known_round`)

**Proposed Fix:**

```rust
// In consensus/src/rand/rand_gen/network_messages.rs
impl<S: TShare, D: TAugmentedData> RandMessage<S, D> {
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(request) => {
                // Validate sender is in validator set
                ensure!(
                    epoch_state.verifier.get_voting_power(&sender).is_some(),
                    "[RequestShare] Sender not in validator set"
                );
                // Additional rate limiting could be added here
                Ok(())
            },
            RandMessage::Share(share) => share.verify(rand_config),
            // ... rest unchanged
        }
    }
}
```

Additionally, implement per-sender rate limiting in `RandManager` to track RequestShare frequency.

## Proof of Concept

**Rust Test Scenario:**

```rust
#[tokio::test]
async fn test_requestshare_resource_exhaustion() {
    // Setup: Create 4 validators (V0, V1, V2, V3)
    // V0 is the attacker, V1-V3 are victims
    let validators = setup_test_validators(4).await;
    let attacker = validators[0].clone();
    let victim = validators[1].clone();
    
    // Victim has highest_known_round = 1000 but no cached shares
    victim.rand_store.lock().update_highest_known_round(1000);
    
    // Attacker sends RequestShare for rounds 1-1000
    let start_time = Instant::now();
    for round in 1..=1000 {
        let metadata = RandMetadata {
            epoch: victim.epoch(),
            round,
        };
        let request = RequestShare::new(metadata);
        
        // Send via network (passes verification due to missing authorization check)
        attacker.send_request_share(victim.author(), request).await;
    }
    
    // Measure victim's CPU utilization and response time
    // Expected: Significant slowdown due to 1000 WVUF::create_share operations
    let duration = start_time.elapsed();
    assert!(duration > Duration::from_secs(10)); // Demonstrates slowdown
    
    // Verify shares were generated (proving resource consumption)
    for round in 1..=1000 {
        assert!(victim.rand_store.lock().has_share_for_round(round));
    }
}
```

**Exploitation Steps:**
1. Compromise or control a validator node
2. Identify `highest_known_round` for target validators (observable via consensus messages)
3. Send bulk `RequestShare` messages for rounds 1 to `highest_known_round`
4. Observe target validators' performance degradation
5. Optionally repeat periodically or coordinate with other malicious validators

## Notes

**Key Clarification:** The question asks if "any network participant (even non-validators)" can exploit this. The answer is:
- **Non-validators:** NO - blocked by network-layer mutual authentication
- **Validators:** YES - no application-layer authorization checks exist

While network-layer protection prevents external exploitation, the lack of application-layer access control allows any malicious validator to exhaust resources of other validators, which violates the **Resource Limits** invariant (#9: "All operations must respect gas, storage, and computational limits").

This vulnerability is realistic under the Byzantine fault tolerance model, where up to 1/3 of validators may behave maliciously.

### Citations

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-60)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
            RandMessage::FastShare(share) => {
                share.share.verify(fast_rand_config.as_ref().ok_or_else(|| {
                    anyhow::anyhow!("[RandMessage] rand config for fast path not found")
                })?)
            },
            _ => bail!("[RandMessage] unexpected message type"),
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L397-413)
```rust
                        RandMessage::RequestShare(request) => {
                            let result = self.rand_store.lock().get_self_share(request.rand_metadata());
                            match result {
                                Ok(maybe_share) => {
                                    let share = maybe_share.unwrap_or_else(|| {
                                        // reproduce previous share if not found
                                        let share = S::generate(&self.config, request.rand_metadata().clone());
                                        self.rand_store.lock().add_share(share.clone(), PathType::Slow).expect("Add self share should succeed");
                                        share
                                    });
                                    self.process_response(protocol, response_sender, RandMessage::Share(share));
                                },
                                Err(e) => {
                                    warn!("[RandManager] Failed to get share: {}", e);
                                }
                            }
                        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L84-95)
```rust
    fn generate(rand_config: &RandConfig, rand_metadata: RandMetadata) -> RandShare<Self>
    where
        Self: Sized,
    {
        let share = Share {
            share: WVUF::create_share(
                &rand_config.keys.ask,
                bcs::to_bytes(&rand_metadata).unwrap().as_slice(),
            ),
        };
        RandShare::new(rand_config.author(), rand_metadata, share)
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L323-338)
```rust
    pub fn get_self_share(
        &mut self,
        metadata: &RandMetadata,
    ) -> anyhow::Result<Option<RandShare<S>>> {
        ensure!(
            metadata.round <= self.highest_known_round,
            "Request share from future round {}, highest known round {}",
            metadata.round,
            self.highest_known_round
        );
        Ok(self
            .rand_map
            .get(&metadata.round)
            .and_then(|item| item.get_self_share())
            .filter(|share| share.metadata() == metadata))
    }
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** config/src/config/consensus_config.rs (L242-242)
```rust
            internal_per_key_channel_size: 10,
```
