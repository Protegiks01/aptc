# Audit Report

## Title
Network Topology Disclosure via Unauthenticated Metrics Endpoint Enables Coordinated Attack Planning

## Summary
The Aptos inspection service exposes an unauthenticated `/metrics` endpoint that publishes the `aptos_network_peer_connected` metric, which explicitly reveals validator-to-validator connection topology through `peer_id` and `remote_peer_id` labels. Attackers who can scrape metrics from multiple validators (either through misconfiguration or compromised monitoring infrastructure) can reconstruct the complete validator network graph, identify critical connection points, and detect network partitions in real-time to plan coordinated attacks.

## Finding Description

The vulnerability exists in the metrics exposure system across multiple components:

**1. Network Topology Metrics Exposure**

The `APTOS_NETWORK_PEER_CONNECTED` metric explicitly tracks which validators are connected to which other validators: [1](#0-0) 

This metric is updated whenever validators connect or disconnect: [2](#0-1) 

**2. Unauthenticated Metrics Endpoint**

The inspection service exposes all Prometheus metrics via an unauthenticated HTTP endpoint: [3](#0-2) [4](#0-3) 

Unlike other inspection endpoints (e.g., `/configuration`, `/peer_information`) which have access control flags, the `/metrics` endpoint has NO authentication or authorization checks: [5](#0-4) 

**3. Default Configuration and Exposure Risk**

While the default Helm configuration sets `enableMetricsPort: false`, preventing public exposure: [6](#0-5) 

The NetworkPolicy still allows access from monitoring systems: [7](#0-6) 

**Attack Scenario:**

1. **Misconfiguration Path**: Validator operator sets `enableMetricsPort: true` in Helm values, exposing metrics via LoadBalancer
2. **Monitoring Compromise Path**: Attacker compromises monitoring infrastructure (Prometheus/Grafana) that has legitimate access to port 9101
3. **Metric Scraping**: Attacker scrapes `/metrics` endpoint from multiple validators
4. **Topology Reconstruction**: By analyzing `aptos_network_peer_connected{peer_id="A", remote_peer_id="B"}` metrics across validators, attacker builds complete connection graph
5. **Attack Planning**: Attacker identifies:
   - Highly connected validators (network hubs)
   - Validators with few connections (isolation targets)
   - Network partition boundaries
   - Real-time connection/disconnection events

**Information Leaked:**
- Complete validator-to-validator connection topology
- Connection directionality (inbound/outbound via `APTOS_CONNECTIONS` metric)
- Network partition state (missing connections indicate splits)
- Connection stability (by monitoring metric changes over time)

## Impact Explanation

**Severity: Medium** ($10,000 per Aptos Bug Bounty)

This qualifies as a **Medium severity information leak** because:

1. **Reconnaissance Value**: While not directly exploiting consensus, it provides critical intelligence for planning sophisticated attacks:
   - Identifying which validators to target for maximum network impact
   - Detecting optimal timing for attacks during network instability
   - Understanding validator clustering patterns for eclipse attacks

2. **Coordination Enabler**: Attackers can synchronize distributed attacks by monitoring when specific validators lose/gain connections

3. **Defense Evasion**: Real-time topology knowledge allows attackers to predict how the network will react to their actions

4. **Indirect Security Impact**: Does not directly cause fund loss or consensus failure, but significantly reduces the attacker's cost and increases success probability for subsequent attacks

The issue does not meet **High severity** criteria because it requires additional attack steps after the reconnaissance phase, and the default configuration mitigates (but does not eliminate) the risk.

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
1. **Misconfiguration Risk**: Validator operators may enable metrics port for debugging without understanding security implications
2. **Monitoring Infrastructure**: Production deployments commonly use centralized monitoring, creating a single point of compromise
3. **No Authentication by Design**: The metrics endpoint is intentionally unauthenticated, following standard Prometheus conventions
4. **Persistent Exposure**: Once misconfigured, the vulnerability remains active until configuration is changed

**Factors Decreasing Likelihood:**
1. **Default Configuration**: `enableMetricsPort: false` by default prevents immediate public exposure
2. **Network Policy**: Kubernetes NetworkPolicy limits access to specific namespaces/pods
3. **Operational Awareness**: Many operators understand not to expose monitoring ports publicly

**Realistic Attack Paths:**
- Testnet/devnet validators often have less strict security, providing initial reconnaissance
- Cloud provider metadata services or SSRF vulnerabilities could expose internal monitoring
- Insider threat from monitoring team or compromised monitoring credentials
- Social engineering targeting validators to enable metrics for "debugging"

## Recommendation

Implement authentication and access control for the metrics endpoint:

**1. Add Authentication to Inspection Service:**

```rust
// In config/src/config/inspection_service_config.rs
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    // NEW: Add metrics access control
    pub expose_metrics: bool,
    pub metrics_auth_token: Option<String>,
}
```

**2. Add Authorization Check to Metrics Handler:**

```rust
// In crates/aptos-inspection-service/src/server/metrics.rs
pub fn handle_metrics_request(node_config: &NodeConfig, auth_header: Option<&str>) -> (StatusCode, Body, String) {
    // Check if metrics endpoint is enabled
    if !node_config.inspection_service.expose_metrics {
        return (
            StatusCode::FORBIDDEN,
            Body::from("Metrics endpoint is disabled"),
            CONTENT_TYPE_TEXT.into(),
        );
    }
    
    // Verify authentication token if configured
    if let Some(expected_token) = &node_config.inspection_service.metrics_auth_token {
        match auth_header {
            Some(header) if header.starts_with("Bearer ") => {
                let provided_token = &header[7..];
                if provided_token != expected_token {
                    return (
                        StatusCode::UNAUTHORIZED,
                        Body::from("Invalid authentication token"),
                        CONTENT_TYPE_TEXT.into(),
                    );
                }
            }
            _ => {
                return (
                    StatusCode::UNAUTHORIZED,
                    Body::from("Authentication required"),
                    CONTENT_TYPE_TEXT.into(),
                );
            }
        }
    }
    
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

**3. Filter Sensitive Metrics:**

Alternatively or additionally, filter the `aptos_network_peer_connected` metric to only expose aggregate connection counts without revealing specific peer relationships.

**4. Documentation Update:**

Add security warnings in Helm charts and documentation about the risks of exposing metrics endpoints publicly.

## Proof of Concept

**Scenario**: Attacker scrapes metrics from three validators to reconstruct topology

**Step 1: Enable Metrics Port (Simulating Misconfiguration)**
```bash
# In Helm values.yaml
service:
  validator:
    enableMetricsPort: true
```

**Step 2: Scrape Metrics from Multiple Validators**
```bash
# Scrape validator A
curl http://validator-a.example.com:9101/metrics | grep aptos_network_peer_connected

# Output example:
# aptos_network_peer_connected{role_type="validator",network_id="Validator",peer_id="abc123",remote_peer_id="def456"} 1
# aptos_network_peer_connected{role_type="validator",network_id="Validator",peer_id="abc123",remote_peer_id="ghi789"} 1

# Scrape validator B
curl http://validator-b.example.com:9101/metrics | grep aptos_network_peer_connected

# Output example:
# aptos_network_peer_connected{role_type="validator",network_id="Validator",peer_id="def456",remote_peer_id="abc123"} 1
# aptos_network_peer_connected{role_type="validator",network_id="Validator",peer_id="def456",remote_peer_id="jkl012"} 1

# Continue for all accessible validators...
```

**Step 3: Topology Reconstruction**
```python
# Python script to build network graph
import requests
import re
from collections import defaultdict

def scrape_validator_connections(validators):
    topology = defaultdict(set)
    
    for validator_url in validators:
        try:
            response = requests.get(f"{validator_url}/metrics", timeout=5)
            for line in response.text.split('\n'):
                if 'aptos_network_peer_connected' in line and not line.startswith('#'):
                    match = re.search(r'peer_id="([^"]+)".*remote_peer_id="([^"]+)".*} 1', line)
                    if match:
                        local_peer, remote_peer = match.groups()
                        topology[local_peer].add(remote_peer)
        except Exception as e:
            print(f"Failed to scrape {validator_url}: {e}")
    
    return topology

# Usage
validators = [
    "http://validator-a.example.com:9101",
    "http://validator-b.example.com:9101",
    # ... add more validator endpoints
]

network_map = scrape_validator_connections(validators)

# Analyze topology
print("Network Topology:")
for validator, connections in network_map.items():
    print(f"{validator} -> {connections}")
    
# Identify highly connected validators (potential targets)
connection_counts = {v: len(c) for v, c in network_map.items()}
hub_validators = sorted(connection_counts.items(), key=lambda x: x[1], reverse=True)[:5]
print(f"\nHighly Connected Validators (Attack Targets): {hub_validators}")

# Detect isolated validators
isolated = [v for v, c in network_map.items() if len(c) < 3]
print(f"\nIsolated Validators: {isolated}")
```

**Expected Output:**
```
Network Topology:
abc123 -> {'def456', 'ghi789'}
def456 -> {'abc123', 'jkl012'}
ghi789 -> {'abc123', 'mno345'}
...

Highly Connected Validators (Attack Targets): [('abc123', 15), ('def456', 12), ...]

Isolated Validators: ['xyz999', 'uvw888']
```

This demonstrates how an attacker can systematically map the entire validator network topology and identify strategic attack targets.

## Notes

**Additional Context:**

1. **Comparison with Other Endpoints**: The `/peer_information` endpoint also leaks topology but can be disabled via `expose_peer_information: false` flag. The `/metrics` endpoint lacks any such protection mechanism.

2. **Standard Prometheus Practice**: Unauthenticated metrics endpoints are common in Prometheus ecosystem, but blockchain validators require higher security standards due to the value at risk.

3. **Defense in Depth**: Even with proper default configuration, the lack of authentication represents a missing security layer. Network-level protections (NetworkPolicy, firewalls) can fail due to misconfiguration or cloud provider vulnerabilities.

4. **Mainnet vs Testnet**: While mainnet validators may be more carefully configured, testnet reconnaissance provides valuable intelligence for planning mainnet attacks.

5. **Related Metrics**: Beyond `aptos_network_peer_connected`, other metrics like `aptos_connections` (with direction labels), RPC latencies, and message counts also leak operational intelligence, though less directly than explicit peer relationships.

### Citations

**File:** network/framework/src/counters.rs (L86-106)
```rust
pub static APTOS_NETWORK_PEER_CONNECTED: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_network_peer_connected",
        "Indicates if we are connected to a particular peer",
        &["role_type", "network_id", "peer_id", "remote_peer_id"]
    )
    .unwrap()
});

pub fn peer_connected(network_context: &NetworkContext, remote_peer_id: &PeerId, v: i64) {
    if network_context.network_id().is_validator_network() {
        APTOS_NETWORK_PEER_CONNECTED
            .with_label_values(&[
                network_context.role().as_str(),
                network_context.network_id().as_str(),
                network_context.peer_id().short_str().as_str(),
                remote_peer_id.short_str().as_str(),
            ])
            .set(v)
    }
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1010-1026)
```rust
        match notif {
            peer_manager::ConnectionNotification::NewPeer(metadata, _network_id) => {
                let peer_id = metadata.remote_peer_id;
                counters::peer_connected(&self.network_context, &peer_id, 1);
                self.connected.insert(peer_id, metadata);

                // Cancel possible queued dial to this peer.
                self.dial_states.remove(&peer_id);
                self.dial_queue.remove(&peer_id);
            },
            peer_manager::ConnectionNotification::LostPeer(metadata, _network_id) => {
                let peer_id = metadata.remote_peer_id;
                if let Some(stored_metadata) = self.connected.get(&peer_id) {
                    // Remove node from connected peers list.

                    counters::peer_connected(&self.network_context, &peer_id, 0);

```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L142-146)
```rust
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L72-76)
```rust
/// Handles a new metrics request (with text encoding)
pub fn handle_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-26)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };
```

**File:** terraform/helm/aptos-node/values.yaml (L156-157)
```yaml
    # -- Enable the metrics port on the validator
    enableMetricsPort: false
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L38-46)
```yaml
  # Monitoring metrics port
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: monitoring
    ports:
    - protocol: TCP
      port: 9101
```
