# Audit Report

## Title
Premature Abort of JWK Consensus Tasks Due to Cloneable Guard Wrapper

## Summary
The `QuorumCertProcessGuard` incorrectly implements `Clone`, allowing the abort handle to be cloned and dropped prematurely. When `maybe_start_consensus()` checks if consensus is already running, it clones the `ConsensusState` containing the guard, and upon dropping this clone, the underlying async task is aborted even though consensus should still be in progress. This causes JWK consensus to silently fail, preventing critical security updates to JWT keys from being committed to the blockchain.

## Finding Description

The vulnerability exists in the JWK consensus system's guard wrapper design: [1](#0-0) 

The `QuorumCertProcessGuard` struct incorrectly derives `Clone`. This guard wraps an `AbortHandle` and implements `Drop` to abort the async task: [2](#0-1) 

The guard is stored within `ConsensusState::InProgress`: [3](#0-2) 

The bug is triggered in `maybe_start_consensus()`: [4](#0-3) 

When checking if consensus is already started (line 183), the code calls `.cloned()` on the HashMap value. This clones the entire `ConsensusState::InProgress`, including the `QuorumCertProcessGuard`. After the match expression completes, the cloned state goes out of scope and is dropped. The `Drop` implementation of the cloned guard then calls `abort()` on the cloned `AbortHandle`, which aborts the running async task created by `update_certifier.start_produce()`: [5](#0-4) 

According to Rust's `futures` library semantics, when an `AbortHandle` is cloned, all clones share the same abort signal. Calling `abort()` on any clone aborts the task. This means the consensus process is terminated even though the original guard remains in the HashMap and the function returns early believing consensus is still running.

**Attack Scenario:**
1. JWK observer detects a key change and calls `process_new_observation()`: [6](#0-5) 

2. First call to `maybe_start_consensus()` starts the quorum certificate building process: [7](#0-6) 

3. Observer polls again after 10 seconds (configured polling interval): [8](#0-7) 

4. Second call to `maybe_start_consensus()` with same key clones the state, drops the clone, aborting the task.

5. The quorum-certified update never completes, and `process_quorum_certified_update()` is never invoked: [9](#0-8) 

## Impact Explanation

This is a **High Severity** vulnerability under the Aptos bug bounty program ("Significant protocol violations"):

1. **Critical Security Function Failure**: JWK (JSON Web Key) consensus is responsible for updating JWT verification keys used in authentication. When this fails, the blockchain cannot update its trusted key set.

2. **Silent Failure**: The bug causes consensus to silently abort without error logging. Validators believe consensus is running but it has actually stopped.

3. **Authentication Impact**: If external identity providers rotate their JWT signing keys, the blockchain cannot update, potentially breaking authentication for users and applications.

4. **No Recovery Mechanism**: Once aborted, there's no automatic retry. The consensus remains stuck until manual intervention or epoch change.

5. **Affects All Validators**: Every validator running the per-key JWK consensus mode is affected identically, making this a network-wide issue.

## Likelihood Explanation

**Likelihood: Very High**

This bug triggers naturally during normal operation without any attacker involvement:

1. **Periodic Polling**: The JWK observer thread polls identity provider endpoints every 10 seconds by design.

2. **Consensus Latency**: Building a quorum certificate requires communication with 2f+1 validators over the network, which typically takes several seconds.

3. **Guaranteed Trigger**: If consensus takes longer than the 10-second polling interval (very common), the bug triggers on the second observation.

4. **Every Key Affected**: Each (issuer, kid) pair that needs updating will hit this bug independently.

5. **Production Frequency**: In production, JWK updates occur whenever identity providers rotate keys (typically monthly or weekly for security).

The bug will manifest in every deployment using per-key JWK consensus mode with any realistic network conditions.

## Recommendation

Remove the `Clone` derive from `QuorumCertProcessGuard` to prevent accidental cloning:

```rust
// In crates/aptos-jwk-consensus/src/types.rs, line 79:
#[derive(Debug)]  // Remove Clone
pub struct QuorumCertProcessGuard {
    pub handle: AbortHandle,
}
```

Then refactor `maybe_start_consensus()` to avoid cloning the state:

```rust
// In crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs, line 179:
fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
    let key = (update.issuer.clone(), update.kid.clone());
    
    // Check without cloning
    let consensus_already_started = match self.states_by_key.get(&key) {
        Some(ConsensusState::InProgress { my_proposal, .. })
        | Some(ConsensusState::Finished { my_proposal, .. }) => {
            my_proposal.observed.to_upsert == update.to_upsert
        },
        _ => false,
    };

    if consensus_already_started {
        return Ok(());
    }
    
    // ... rest of function remains the same
}
```

This matches the pattern used in `DropGuard` from the reliable-broadcast crate: [10](#0-9) 

Note that `DropGuard` correctly does NOT derive `Clone`, preventing this class of bug.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::{sleep, Duration};
    use futures::future::pending;
    
    #[tokio::test]
    async fn test_guard_premature_abort_bug() {
        // Create an abort handle pair
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        
        // Spawn a long-running task
        let task_handle = tokio::spawn(Abortable::new(
            async {
                sleep(Duration::from_secs(100)).await;
                "completed"
            },
            abort_registration,
        ));
        
        // Wrap in QuorumCertProcessGuard
        let guard = QuorumCertProcessGuard::new(abort_handle);
        
        // Store in a state structure
        let mut state = ConsensusState::InProgress {
            my_proposal: ObservedKeyLevelUpdate {
                author: AccountAddress::ZERO,
                observed: KeyLevelUpdate {
                    issuer: vec![],
                    base_version: 0,
                    kid: vec![],
                    to_upsert: None,
                },
                signature: Signature::dummy_signature(),
            },
            abort_handle_wrapper: guard,
        };
        
        // Simulate the bug: clone the state (as done in line 183)
        let cloned_state = state.clone();
        
        // Drop the clone immediately (as happens after the match)
        drop(cloned_state);
        
        // Give time for abort to propagate
        sleep(Duration::from_millis(10)).await;
        
        // Verify the task was aborted (bug!)
        let result = task_handle.await;
        assert!(result.is_ok()); // Task completed (was aborted)
        assert!(result.unwrap().is_err()); // But with Aborted error
        
        // The original guard still exists, but the task is dead!
        // This proves the bug.
    }
}
```

**Notes**

The comparison with `DropGuard` in the reliable-broadcast crate is instructive - that implementation correctly avoids the `Clone` trait, preventing this exact bug pattern. The JWK consensus code should follow the same pattern. This vulnerability affects the security-critical function of updating JWT verification keys, making it a high-priority fix despite requiring no attacker interaction.

### Citations

**File:** crates/aptos-jwk-consensus/src/types.rs (L79-82)
```rust
#[derive(Clone, Debug)]
pub struct QuorumCertProcessGuard {
    pub handle: AbortHandle,
}
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L96-101)
```rust
impl Drop for QuorumCertProcessGuard {
    fn drop(&mut self) {
        let QuorumCertProcessGuard { handle } = self;
        handle.abort();
    }
}
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L103-109)
```rust
#[derive(Debug, Clone)]
pub enum ConsensusState<T: Debug + Clone + Eq + PartialEq> {
    NotStarted,
    InProgress {
        my_proposal: T,
        abort_handle_wrapper: QuorumCertProcessGuard,
    },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L109-114)
```rust
    pub fn process_new_observation(&mut self, issuer: Issuer, jwks: Vec<JWK>) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L180-194)
```rust
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };

        if consensus_already_started {
            return Ok(());
        }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L207-228)
```rust
        let abort_handle = self
            .update_certifier
            .start_produce(
                self.epoch_state.clone(),
                update_translated,
                self.qc_update_tx.clone(),
            )
            .context("maybe_start_consensus failed at update_certifier.start_produce")?;

        self.states_by_key.insert(
            (update.issuer.clone(), update.kid.clone()),
            ConsensusState::InProgress {
                my_proposal: ObservedKeyLevelUpdate {
                    author: self.my_addr,
                    observed: update,
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard {
                    handle: abort_handle,
                },
            },
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L311-320)
```rust
    /// Triggered once the `update_certifier` produced a certified key-level update.
    pub fn process_quorum_certified_update(
        &mut self,
        issuer_level_repr: QuorumCertifiedUpdate,
    ) -> Result<()> {
        let key_level_update =
            KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)
                .context("process_quorum_certified_update failed with repr err")?;
        let issuer = &key_level_update.issuer;
        let issuer_str = String::from_utf8(issuer.clone()).ok();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L399-400)
```rust
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L80-82)
```rust
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        Ok(abort_handle)
```

**File:** crates/reliable-broadcast/src/lib.rs (L222-236)
```rust
pub struct DropGuard {
    abort_handle: AbortHandle,
}

impl DropGuard {
    pub fn new(abort_handle: AbortHandle) -> Self {
        Self { abort_handle }
    }
}

impl Drop for DropGuard {
    fn drop(&mut self) {
        self.abort_handle.abort();
    }
}
```
