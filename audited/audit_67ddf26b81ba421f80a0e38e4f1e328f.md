# Audit Report

## Title
Out-of-Bounds Vector Drain Causing Panic in Transaction Restore Process

## Summary
The `save_before_replay_version()` function contains two sequential drain operations on transaction vectors that can trigger a panic when `global_first_version > target_version`. The second drain operation incorrectly calculates the removal range using the original chunk's `first_version` without accounting for elements already removed by the first drain, leading to an out-of-bounds access that crashes the restore process.

## Finding Description

The vulnerability exists in the sequential drain operations within the chunk processing logic: [1](#0-0) 

The issue manifests through the following sequence:

**First Drain Block** removes transactions exceeding `target_version`: [2](#0-1) 

This reduces vector length to `(target_version - first_version + 1)` elements.

**Second Drain Block** removes transactions before `global_first_version`: [3](#0-2) 

The critical flaw is that `num_to_remove` is calculated as `(global_first_version - first_version)`, where `first_version` is still the **original** chunk's first version from: [4](#0-3) 

When `global_first_version > target_version`, the second drain attempts to remove more elements than remain after the first drain, causing Rust's `Vec::drain()` to panic with "range end exceeds vector length."

**Attack Scenario:**
A restore coordinator can trigger this by passing `first_version` parameter independently of chunk contents: [5](#0-4) 

Where `db_next_version` comes from: [6](#0-5) 

There is no validation preventing `db_next_version > target_version`, allowing the misconfiguration.

**Concrete Example:**
- Backup chunk: `first_version=100`, `last_version=2000`, `txns.len()=1901`
- User parameters: `target_version=500`, `global_first_version=1500`

First drain: `num_to_keep = 500-100+1 = 401`, resulting in `txns.len()=401`
Second drain: `num_to_remove = 1500-100 = 1400`, but `txns.len()=401`
**Panic**: Attempting `txns.drain(..1400)` with length 401

This breaks the **Resource Limits** and **State Consistency** invariants by crashing the restore process before completion.

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria:

1. **Validator node crashes**: Restore operations are critical for validator onboarding and recovery. A panic during restore renders the node inoperable.

2. **Network liveness impact**: If multiple validators encounter this during synchronized restore operations (e.g., after network upgrade requiring state recovery), it could significantly delay validator set recovery.

3. **Database inconsistency**: The panic leaves the database in an intermediate state, potentially requiring manual intervention or full restore restart.

4. **Denial of Service**: Malicious or accidental misconfiguration of restore parameters can repeatedly crash restoration attempts.

While not directly a consensus safety violation, this represents a "Significant protocol violation" by disrupting critical infrastructure operations and validator availability, meeting the High severity threshold.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can be triggered through:

1. **User error**: Operators mistakenly setting `--target-version` below the DB's current version during incremental restores
2. **Configuration bugs**: Automated restore scripts with incorrect parameter ordering
3. **Resume scenarios**: Multi-phase restores where phase boundaries are miscalculated

Evidence of realistic triggering: [7](#0-6) 

The code logs both values but performs no validation that `target_version >= db_next_version`, making the misconfiguration straightforward to introduce.

The lack of defensive checks combined with complex multi-phase restore logic increases the probability of occurrence in production environments.

## Recommendation

**Fix: Validate parameter relationships and use updated version bounds**

1. **Add validation** before processing chunks:

```rust
// In save_before_replay_version(), after line 458
ensure!(
    target_version >= global_first_version,
    "target_version ({}) must be >= global_first_version ({})",
    target_version,
    global_first_version
);
```

2. **Update first_version after first drain** to reflect actual vector contents:

```rust
// After line 482, before the second drain block
if target_version < last_version {
    let num_to_keep = (target_version - first_version + 1) as usize;
    txns.drain(num_to_keep..);
    persisted_aux_info.drain(num_to_keep..);
    txn_infos.drain(num_to_keep..);
    event_vecs.drain(num_to_keep..);
    write_sets.drain(num_to_keep..);
    last_version = target_version;
    // ADD THIS LINE:
    // No need to update first_version since elements removed from end
}

// Update second drain to account for shortened vectors
if global_first_version > first_version {
    // Ensure we don't exceed current vector length
    let num_to_remove = min(
        (global_first_version - first_version) as usize,
        txns.len()
    );
    txns.drain(..num_to_remove);
    persisted_aux_info.drain(..num_to_remove);
    txn_infos.drain(..num_to_remove);
    event_vecs.drain(..num_to_remove);
    write_sets.drain(..num_to_remove);
    first_version = global_first_version;
}
```

3. **Add validation in RestoreCoordinator**: [8](#0-7) 

Add after this:
```rust
ensure!(
    target_version >= db_next_version,
    "target_version ({}) must be >= current DB version ({})",
    target_version,
    db_next_version
);
```

## Proof of Concept

```rust
// To reproduce the panic, create a test in 
// storage/backup/backup-cli/src/backup_types/transaction/restore.rs

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[should_panic(expected = "range end index")]
    fn test_drain_panic_scenario() {
        // Simulate the vulnerable drain sequence
        let mut txns = vec![0u8; 1901]; // Represents versions 100-2000
        let mut other_vecs = vec![vec![0u8; 10]; 1901];
        
        let first_version = 100u64;
        let target_version = 500u64;
        let global_first_version = 1500u64;
        let last_version = 2000u64;
        
        // First drain - mimics line 477-478
        if target_version < last_version {
            let num_to_keep = (target_version - first_version + 1) as usize;
            txns.drain(num_to_keep..);
            other_vecs.drain(num_to_keep..);
        }
        
        assert_eq!(txns.len(), 401); // After first drain
        
        // Second drain - mimics line 489-490
        // This PANICS because num_to_remove (1400) > txns.len() (401)
        if global_first_version > first_version {
            let num_to_remove = (global_first_version - first_version) as usize;
            txns.drain(..num_to_remove); // PANIC HERE
            other_vecs.drain(..num_to_remove);
        }
    }
}
```

To trigger in production:
1. Set up a DB with transactions through version 1000
2. Create backup chunks covering versions 0-2000
3. Run restore with `--target-version 500`
4. Observe panic in `save_before_replay_version()` when processing chunks

**Notes**

The vulnerability is not caused by integer overflow in the arithmetic operations themselves (both `Version` type and `usize` are 64-bit on modern systems), but rather by incorrect logic that fails to account for vector length changes between sequential operations. The security question's mention of "integer overflow" was on the right track but the actual vulnerability is the out-of-bounds drain range access that occurs when `global_first_version > target_version`, which is a reachable state through legitimate (though misconfigured) restore parameters.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L464-465)
```rust
                    let mut first_version = chunk.manifest.first_version;
                    let mut last_version = chunk.manifest.last_version;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L474-495)
```rust
                    // remove the txns that exceeds the target_version to be restored
                    if target_version < last_version {
                        let num_to_keep = (target_version - first_version + 1) as usize;
                        txns.drain(num_to_keep..);
                        persisted_aux_info.drain(num_to_keep..);
                        txn_infos.drain(num_to_keep..);
                        event_vecs.drain(num_to_keep..);
                        write_sets.drain(num_to_keep..);
                        last_version = target_version;
                    }

                    // remove the txns that are before the global_first_version
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
                    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L128-132)
```rust
        let target_version = std::cmp::min(self.global_opt.target_version, max_txn_ver);
        info!(
            "User specified target version: {}, max transaction version: {}, Target version is set to {}",
            self.global_opt.target_version, max_txn_ver, target_version
        );
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L152-155)
```rust
        let mut db_next_version = self
            .global_opt
            .run_mode
            .get_next_expected_transaction_version()?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L289-298)
```rust
            TransactionRestoreBatchController::new(
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
                None,
            )
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L311-314)
```rust
            info!(
                "Starting restore DB from version {} to target version {}",
                db_next_version, target_version,
            );
```
