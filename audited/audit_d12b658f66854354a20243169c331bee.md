# Audit Report

## Title
OnDiskStorage Creates World-Readable Files Exposing Validator Consensus Private Keys

## Summary
The `OnDiskStorage` implementation in `secure/storage/src/on_disk.rs` creates files with default permissions (world-readable 0644 on Unix systems) when storing validator consensus private keys. Despite documentation stating it should not be used in production, `OnDiskStorage` is permitted by the mainnet configuration sanitizer and appears in production deployment configurations. An attacker with local filesystem read access can steal the BLS12-381 consensus private key, enabling validator impersonation and consensus safety violations.

## Finding Description

The security question points to the benchmark file at [1](#0-0) , which is out of scope as a test file. However, this reveals a critical vulnerability in the underlying production code.

The `OnDiskStorage` struct stores validator consensus private keys in plaintext files without setting restrictive file permissions. When `OnDiskStorage` is instantiated, it creates files using standard `File::create()` calls: [2](#0-1) [3](#0-2) 

These files contain the validator's consensus private key, which is explicitly stored during initialization: [4](#0-3) 

The codebase provides secure file creation utilities that set mode 0600 (owner read/write only): [5](#0-4) 

However, `OnDiskStorage` does not use these utilities, leaving files with default permissions (typically 0644 on Unix = world-readable).

**Production Usage Evidence:**

Despite documentation warnings, `OnDiskStorage` is used in production configurations: [6](#0-5) [7](#0-6) 

The configuration sanitizer only forbids `InMemoryStorage` for mainnet validators, but permits `OnDiskStorage`: [8](#0-7) 

**Attack Path:**
1. Validator operator configures `on_disk_storage` backend (as shown in deployment configs)
2. `OnDiskStorage` creates `secure-data.json` with default permissions (0644)
3. Local attacker with filesystem read access reads the file
4. Attacker extracts the BLS12-381 consensus private key
5. Attacker can now sign votes as the compromised validator, potentially causing double-signing or safety violations

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violations**: The stolen consensus key allows an attacker to sign votes as the compromised validator, potentially causing equivocation (double-voting) which breaks BFT consensus safety guarantees under the < 1/3 Byzantine fault tolerance threshold.

2. **Validator Impersonation**: The attacker can participate in consensus rounds as the legitimate validator, signing blocks and votes that appear authentic.

3. **Loss of Validator Stake**: If the attacker causes the validator to equivocate, the validator may face slashing penalties or ejection from the active set.

This directly violates the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" and the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure."

Per Aptos bug bounty criteria, consensus/safety violations are Critical Severity (up to $1,000,000).

## Likelihood Explanation

**High Likelihood** due to:

1. **Production Deployment**: Configuration files in `terraform/helm` and `docker/compose` directories show `on_disk_storage` being used, not just documented as an option.

2. **No Protection Barrier**: The configuration sanitizer explicitly allows `OnDiskStorage` on mainnet, only forbidding `InMemoryStorage`.

3. **Default Permissions**: Unix systems create files with 0644 permissions by default when using `File::create()`, making them readable by any local user.

4. **Common Attack Scenario**: Shared hosting environments, compromised container escapes, or malicious co-tenants can trivially read world-readable files.

5. **Documentation vs. Implementation Gap**: While the README states OnDiskStorage "should not be used in production", the code permits it and provides no runtime warnings.

## Recommendation

**Immediate Fix:**

Modify `OnDiskStorage::new_with_time_service` and `write` methods to set restrictive file permissions:

```rust
#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
    if !file_path.exists() {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);  // Owner read/write only
        opts.write(true).create(true)
            .open(&file_path)
            .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
    }
    // ... rest of the code
}

fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    let mut file = opts.write(true).create(true).open(self.temp_path.path())?;
    file.write_all(&contents)?;
    fs::rename(&self.temp_path, &self.file_path)?;
    Ok(())
}
```

**Additional Measures:**

1. **Add Mainnet Validation**: Update the sanitizer to forbid `OnDiskStorage` on mainnet: [8](#0-7) 

2. **Runtime Warning**: Emit a warning log when `OnDiskStorage` is initialized, especially for validator nodes.

3. **Documentation**: Strengthen warnings in deployment documentation about the security implications.

## Proof of Concept

```rust
#[cfg(test)]
mod test_file_permissions {
    use super::*;
    use aptos_temppath::TempPath;
    use std::fs;
    
    #[test]
    #[cfg(unix)]
    fn test_ondisk_storage_insecure_permissions() {
        use std::os::unix::fs::PermissionsExt;
        
        // Create OnDiskStorage
        let temp = TempPath::new();
        let path = temp.path().join("test_storage.json");
        let storage = OnDiskStorage::new(path.clone());
        
        // Write data to trigger file creation
        let mut storage_mut = storage;
        storage_mut.set("test_key", "sensitive_data".to_string()).unwrap();
        
        // Check file permissions
        let metadata = fs::metadata(&path).unwrap();
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // Extract Unix permission bits (last 9 bits)
        let perms = mode & 0o777;
        
        // VULNERABILITY: File is world-readable (0644 or similar)
        // Should be 0600 (owner read/write only)
        println!("File permissions: {:o}", perms);
        assert_ne!(perms & 0o044, 0, "File is world/group readable - VULNERABILITY!");
        
        // Demonstrate that any user can read the file
        let contents = fs::read_to_string(&path).unwrap();
        assert!(contents.contains("sensitive_data"));
        println!("Sensitive data readable by any local user: {}", contents);
    }
}
```

This PoC demonstrates that files created by `OnDiskStorage` have world-readable permissions, allowing any local user to extract validator private keys stored in these files.

### Citations

**File:** consensus/safety-rules/benches/safety_rules.rs (L73-86)
```rust
fn on_disk(n: u64) {
    let signer = ValidatorSigner::from_int(0);
    let file_path = NamedTempFile::new().unwrap().into_temp_path().to_path_buf();
    let waypoint = test_utils::validator_signers_to_waypoint(&[&signer]);
    let storage = PersistentSafetyStorage::initialize(
        Storage::from(OnDiskStorage::new(file_path)),
        signer.author(),
        signer.private_key().clone(),
        waypoint,
        true,
    );
    let safety_rules_manager = SafetyRulesManager::new_local(storage);
    lsr(safety_rules_manager.client(), signer, n);
}
```

**File:** secure/storage/src/on_disk.rs (L34-38)
```rust
    fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
        if !file_path.exists() {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
```

**File:** secure/storage/src/on_disk.rs (L64-69)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-68)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L10-17)
```yaml
consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** docker/compose/aptos-node/validator.yaml (L7-14)
```yaml
consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```
