# Audit Report

## Title
Unvalidated `known_version_at_stream_start` in Subscription Requests Allows State Synchronization Bypass

## Summary
The storage service server accepts subscription requests with client-provided `known_version_at_stream_start` values without validation, allowing malicious or buggy clients to skip critical transactions and achieve inconsistent state. This violates the State Consistency invariant and can lead to nodes having divergent ledger states.

## Finding Description

The subscription mechanism in Aptos state-sync allows clients to subscribe to new transactions starting from a claimed "known version". However, the server never validates that the client's claimed `known_version_at_stream_start` matches reality.

**Vulnerability Flow:**

1. Client sends a subscription request containing `SubscriptionStreamMetadata` with an arbitrary `known_version_at_stream_start` value. [1](#0-0) 

2. Server accepts this request and creates a new `SubscriptionStreamRequests` by directly extracting the unvalidated value: [2](#0-1) 

3. The server stores the client-provided version as `highest_known_version` without any validation against actual ledger state: [3](#0-2) 

4. When serving data, the server calculates `start_version = known_version + 1` using the unvalidated value: [4](#0-3) 

5. The server then sends transactions starting from this manipulated version: [5](#0-4) 

**Attack Example:**
- Client has actually synced to version 1000
- Client sends subscription with `known_version_at_stream_start = 2000`
- Server accepts this claim without validation
- Server sends transactions starting from version 2001
- Client permanently misses transactions 1001-2000
- Client now has incomplete state, breaking State Consistency invariant

The only existing validation checks if subsequent requests in the same stream match the initial metadata, but never validates the initial claim itself: [6](#0-5) 

## Impact Explanation

This is a **Critical** severity vulnerability under the Aptos bug bounty program because it enables:

1. **State Consistency Violations** (Invariant #4): Nodes can have divergent ledger states containing different transaction histories, violating the fundamental requirement that all nodes must maintain identical state.

2. **Consensus/Safety Violations** (Invariant #1, #2): If validator nodes are affected, they will have inconsistent state roots, potentially causing consensus failures or network partitions when validators disagree on state transitions.

3. **Non-recoverable Network Partition**: Desynchronized nodes may be unable to participate in consensus or validate blocks, requiring manual intervention or hard fork to recover.

The vulnerability affects the core state synchronization mechanism that ensures all Aptos nodes maintain consistent replicas of the blockchain state.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

1. **No authentication required**: Any network peer can send subscription requests
2. **Simple exploitation**: Attacker only needs to craft a single request with manipulated metadata
3. **No special privileges needed**: Does not require validator access or cryptographic capabilities
4. **Multiple attack vectors**:
   - Buggy client implementations accidentally providing wrong versions
   - Man-in-the-middle attackers modifying legitimate subscription requests
   - Malicious actors targeting critical infrastructure nodes
   - Adversarial validators deliberately desyncing themselves

The vulnerability is present in the core state-sync code path used by all full nodes and validators for staying synchronized.

## Recommendation

Implement server-side validation of `known_version_at_stream_start` when creating new subscription streams:

```rust
// In state-sync/storage-service/server/src/handler.rs
pub fn handle_subscription_request(
    &self,
    storage_service_config: StorageServiceConfig,
    peer_network_id: PeerNetworkId,
    request: StorageServiceRequest,
    response_sender: ResponseSender,
) {
    // Create a new subscription request and get the stream ID
    let subscription_request =
        SubscriptionRequest::new(request.clone(), response_sender, self.time_service.clone());
    
    // VALIDATION: Verify the claimed known_version is reasonable
    let known_version = subscription_request.highest_known_version_at_stream_start();
    let storage_summary = self.cached_storage_server_summary.load();
    if let Some(synced_info) = &storage_summary.data_summary.synced_ledger_info {
        let highest_synced_version = synced_info.ledger_info().version();
        
        // Reject claims that exceed our highest synced version
        if known_version > highest_synced_version {
            let error = Error::InvalidRequest(format!(
                "Claimed known_version {} exceeds server's highest synced version {}",
                known_version, highest_synced_version
            ));
            self.handle_subscription_request_failure(
                peer_network_id,
                request,
                error,
                subscription_request,
            );
            return;
        }
    }
    
    // Continue with existing logic...
}
```

Additional recommendations:
1. Add rate limiting per peer for subscription stream creation attempts
2. Log suspicious version claims for monitoring
3. Consider requiring peers to provide proof of their claimed version (e.g., state proof at that version)

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_unvalidated_known_version_attack() {
    use aptos_storage_service_types::requests::*;
    
    // Setup: Server has synced to version 1000
    let highest_synced_version = 1000u64;
    let storage_service = /* initialize storage service */;
    
    // Attack: Client claims to know version 2000 (800 versions ahead)
    let malicious_known_version = 2000u64;
    let subscription_metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: malicious_known_version,
        known_epoch_at_stream_start: 1,
        subscription_stream_id: 12345,
    };
    
    // Create subscription request with manipulated metadata
    let request = StorageServiceRequest::new(
        DataRequest::SubscribeTransactionOutputsWithProof(
            SubscribeTransactionOutputsWithProofRequest {
                subscription_stream_metadata: subscription_metadata,
                subscription_stream_index: 0,
            }
        ),
        false,
    );
    
    // Server accepts the malicious request without validation
    // and will later serve data starting from version 2001
    // causing the client to miss transactions 1001-2000
    
    // Verify: Server stored the manipulated version
    let subscriptions = storage_service.get_active_subscriptions();
    let peer_subscription = subscriptions.get(&peer_network_id).unwrap();
    assert_eq!(
        peer_subscription.highest_known_version,
        malicious_known_version,
        "Server accepted manipulated known_version without validation"
    );
    
    // Result: Client will skip 1000 critical transactions (versions 1001-2000)
    // leading to state inconsistency
}
```

**Notes**

This vulnerability is particularly dangerous because:
- It's in the core state synchronization path used by all nodes
- Silent failures make detection difficult until state divergence is noticed
- The affected node may continue operating with incorrect state, propagating errors
- Legitimate clients with buggy implementations could trigger this accidentally
- The server's trust in client-provided version claims violates basic input validation principles [7](#0-6)

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L417-422)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct SubscriptionStreamMetadata {
    pub known_version_at_stream_start: u64, // The highest known transaction version at stream start
    pub known_epoch_at_stream_start: u64,   // The highest known epoch at stream start
    pub subscription_stream_id: u64,        // The unique id of the subscription stream
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L68-141)
```rust
    fn get_storage_request_for_missing_data(
        &self,
        config: StorageServiceConfig,
        known_version: u64,
        target_ledger_info: &LedgerInfoWithSignatures,
    ) -> aptos_storage_service_types::Result<StorageServiceRequest, Error> {
        // Calculate the number of versions to fetch
        let target_version = target_ledger_info.ledger_info().version();
        let mut num_versions_to_fetch =
            target_version.checked_sub(known_version).ok_or_else(|| {
                Error::UnexpectedErrorEncountered(
                    "Number of versions to fetch has overflown!".into(),
                )
            })?;

        // Bound the number of versions to fetch by the maximum chunk size
        num_versions_to_fetch = min(
            num_versions_to_fetch,
            self.max_chunk_size_for_request(config),
        );

        // Calculate the start and end versions
        let start_version = known_version.checked_add(1).ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Start version has overflown!".into())
        })?;
        let end_version = known_version
            .checked_add(num_versions_to_fetch)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("End version has overflown!".into())
            })?;

        // Create the storage request
        let data_request = match &self.request.data_request {
            DataRequest::SubscribeTransactionOutputsWithProof(_) => {
                DataRequest::GetTransactionOutputsWithProof(TransactionOutputsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                })
            },
            DataRequest::SubscribeTransactionsWithProof(request) => {
                DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                    include_events: request.include_events,
                })
            },
            DataRequest::SubscribeTransactionsOrOutputsWithProof(request) => {
                DataRequest::GetTransactionsOrOutputsWithProof(
                    TransactionsOrOutputsWithProofRequest {
                        proof_version: target_version,
                        start_version,
                        end_version,
                        include_events: request.include_events,
                        max_num_output_reductions: request.max_num_output_reductions,
                    },
                )
            },
            DataRequest::SubscribeTransactionDataWithProof(request) => {
                DataRequest::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
                    transaction_data_request_type: request.transaction_data_request_type,
                    proof_version: target_version,
                    start_version,
                    end_version,
                    max_response_bytes: request.max_response_bytes,
                })
            },
            request => unreachable!("Unexpected subscription request: {:?}", request),
        };
        let storage_request =
            StorageServiceRequest::new(data_request, self.request.use_compression);
        Ok(storage_request)
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L314-335)
```rust
    pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Self {
        // Extract the relevant information from the request
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

        // Create a new set of pending subscription requests using the first request
        let mut pending_subscription_requests = BTreeMap::new();
        pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        Self {
            highest_known_version,
            highest_known_epoch,
            next_index_to_serve: 0,
            pending_subscription_requests,
            subscription_stream_metadata,
            last_stream_update_time: time_service.now(),
            time_service,
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L346-356)
```rust
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L307-349)
```rust
        match subscription_stream_entry {
            Entry::Occupied(mut occupied_entry) => {
                // If the stream has a different ID than the request, replace the stream.
                // Otherwise, add the request to the existing stream.
                let existing_stream_id = occupied_entry.get().subscription_stream_id();
                if existing_stream_id != request_stream_id {
                    // Create a new subscription stream for the peer
                    let subscription_stream = SubscriptionStreamRequests::new(
                        subscription_request,
                        self.time_service.clone(),
                    );
                    occupied_entry.replace_entry(subscription_stream);

                    // Update the subscription metrics
                    update_created_stream_metrics(&peer_network_id);
                } else {
                    // Add the request to the existing stream
                    if let Err((error, subscription_request)) = occupied_entry
                        .get_mut()
                        .add_subscription_request(storage_service_config, subscription_request)
                    {
                        // Handle the subscription failure
                        self.handle_subscription_request_failure(
                            peer_network_id,
                            request,
                            error,
                            subscription_request,
                        );
                    }
                }
            },
            Entry::Vacant(vacant_entry) => {
                // Create a new subscription stream for the peer
                let subscription_stream = SubscriptionStreamRequests::new(
                    subscription_request,
                    self.time_service.clone(),
                );
                vacant_entry.insert(subscription_stream);

                // Update the subscription metrics
                update_created_stream_metrics(&peer_network_id);
            },
        }
```
