# Audit Report

## Title
Missing Target Version Coverage Validation in Transaction Backup Selection Leading to Silent Partial State Restoration

## Summary
The `select_transaction_backups` method fails to validate that available transaction backups actually cover the entire range up to the requested `target_version`. This allows backup restoration and replay verification operations to silently complete with an incomplete state, potentially causing state inconsistencies and consensus divergence between nodes.

## Finding Description

The vulnerability exists in the transaction backup selection logic and affects multiple coordinators including replay-verify and restore operations.

**Root Cause:**

In `select_transaction_backups`, the method validates that transaction backups are continuous from version 0 onwards but does NOT verify that they extend all the way to the requested `target_version`. [1](#0-0) 

The method iterates through all available backups, validates continuity, and breaks when it encounters a backup starting after the target version. However, it never checks if `next_ver - 1 >= target_version` before returning, allowing incomplete coverage to pass silently.

**Missing Post-Restore Validation:**

The replay-verify coordinator calls `select_transaction_backups` and processes the returned backups without verifying that the target version was actually reached: [2](#0-1) 

After the restore completes, there is no validation that `end_version` was actually restored. The function only checks for execution errors but not version coverage.

**Dead Validation Code:**

A method `get_actual_target_version` exists in the restore coordinator that could detect and warn about this issue, but it is marked as dead code and never called: [3](#0-2) 

This method explicitly handles the case where backups don't reach the target version and logs a warning, but since it's never invoked, this protection is not active.

**Exploitation Scenario:**

1. Operator requests replay-verify from version 0 to version 1000
2. Backup storage only contains transaction backups covering [0, 500]
3. `select_transaction_backups(0, 1000)` validates continuity of [0, 500] and returns successfully
4. Transaction restore processes versions [0, 500] and completes
5. Replay-verify reports success without any error or warning
6. The database is left at version 500, not version 1000 as expected
7. Operator believes state is verified up to version 1000 and proceeds with operations

This breaks the **State Consistency** invariant because:
- The system silently accepts incomplete transaction coverage
- Different nodes could restore to different versions from different incomplete backups
- The restored state doesn't match the requested target state
- Backup validation becomes ineffective

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violations**: The system violates the fundamental guarantee that backup restoration reaches the requested target version, breaking state consistency assumptions.

2. **State Inconsistencies Requiring Intervention**: If multiple validators restore from different incomplete backup sets, they could end up at different versions, requiring manual intervention to synchronize.

3. **Potential Consensus Impact**: While not directly a consensus break, if validators operate with states at different versions due to this issue, it could lead to divergence in state roots and block validation failures.

4. **Backup Validation Bypass**: The replay-verify functionality is intended to validate backup integrity. This bug allows incomplete/corrupted backups to pass validation, defeating the security purpose of the tool.

The impact could escalate to **Critical Severity** if:
- Multiple validators simultaneously restore from incomplete backups during network recovery
- The resulting state divergence causes a non-recoverable network partition
- Validators produce different state roots for the same block due to being at different versions

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to manifest in several realistic scenarios:

1. **Incomplete Backup Storage**: Backup storage systems may fail to retain all transaction backups due to storage limits, retention policies, or corruption. Operators would unknowingly restore incomplete states.

2. **Disaster Recovery**: During network recovery operations, operators rushing to restore validator nodes might not notice the silent partial restoration, leading to state divergence.

3. **Malicious Backup Provider**: An attacker controlling backup storage could intentionally provide incomplete backup metadata to cause validators to restore to different versions.

4. **Storage Migration**: When migrating backups between storage systems, incomplete transfers would not be detected by the validation logic.

The vulnerability is easy to trigger (no complex setup required) and has no existing safeguards, making it a realistic threat to production systems.

## Recommendation

**Immediate Fix:**

Add validation in `select_transaction_backups` to ensure the selected backups cover the entire range up to `target_version`:

```rust
pub fn select_transaction_backups(
    &self,
    start_version: Version,
    target_version: Version,
) -> Result<Vec<TransactionBackupMeta>> {
    let mut next_ver = 0;
    let mut res = Vec::new();
    for backup in self.transaction_backups.iter().sorted() {
        if backup.first_version > target_version {
            break;
        }
        ensure!(
            backup.first_version == next_ver,
            "Transaction backup ranges not continuous, expecting version {}, got {}.",
            next_ver,
            backup.first_version,
        );

        if backup.last_version >= start_version {
            res.push(backup.clone());
        }

        next_ver = backup.last_version + 1;
    }
    
    // NEW VALIDATION: Ensure backups cover up to target_version
    ensure!(
        next_ver > target_version,
        "Transaction backups incomplete: only cover up to version {}, but target is {}",
        next_ver.saturating_sub(1),
        target_version
    );

    Ok(res)
}
```

**Additional Safeguards:**

1. **Activate the Dead Code**: Remove `#[allow(dead_code)]` from `get_actual_target_version` and use it in the restore flow to log warnings when backups don't reach the target.

2. **Post-Restore Validation**: Add explicit validation in `replay_verify.rs` and `restore.rs` coordinators to verify the final database version matches the target version after restore completes.

3. **Metrics and Monitoring**: Emit metrics tracking the actual restored version vs. target version to detect partial restorations in production.

## Proof of Concept

The following steps demonstrate the vulnerability:

**Setup:**
1. Create a backup storage with transaction backups only covering versions [0, 500]
2. Request replay-verify to target version 1000

**Reproduction Steps:**

```rust
// Create incomplete transaction backup metadata
let incomplete_backups = vec![
    TransactionBackupMeta {
        first_version: 0,
        last_version: 250,
        manifest: FileHandle::new("backup_0_250.manifest"),
    },
    TransactionBackupMeta {
        first_version: 251,
        last_version: 500,
        manifest: FileHandle::new("backup_251_500.manifest"),
    },
    // No backups beyond version 500
];

// Call select_transaction_backups with target_version = 1000
let metadata_view = MetadataView::new(
    incomplete_backups.into_iter().map(Metadata::TransactionBackup).collect(),
    vec![]
);

// This should fail but actually succeeds
let selected = metadata_view.select_transaction_backups(0, 1000)?;
// selected contains backups [0, 500] only
// No error is raised despite missing coverage to version 1000

// Run replay-verify coordinator
let coordinator = ReplayVerifyCoordinator::new(
    storage,
    metadata_cache_opt,
    trusted_waypoints_opt,
    concurrent_downloads,
    replay_concurrency_level,
    restore_handler,
    0,        // start_version
    1000,     // end_version (target)
    validate_modules,
    verify_execution_mode,
)?;

// This completes successfully but only restores to version 500
coordinator.run().await?;
// No error is raised despite not reaching version 1000

// Verify the database is at version 500, not 1000
let actual_version = restore_handler.get_latest_version()?;
assert_eq!(actual_version, Some(500)); // Should be 1000!
```

**Expected Behavior:** The system should return an error indicating that backups only cover up to version 500 and cannot reach the target version 1000.

**Actual Behavior:** The system silently completes restoration to version 500 and reports success, leaving the operator unaware that the target version was not reached.

---

**Notes:**

This vulnerability demonstrates a critical gap in backup validation that could lead to state inconsistencies in production environments. The issue is compounded by the existence of validation code (`get_actual_target_version`) that was never activated, suggesting this was a known concern that was not properly addressed. Immediate remediation is recommended before this affects production validator operations.

### Citations

**File:** storage/backup/backup-cli/src/metadata/view.rs (L132-160)
```rust
    pub fn select_transaction_backups(
        &self,
        start_version: Version,
        target_version: Version,
    ) -> Result<Vec<TransactionBackupMeta>> {
        // This can be more flexible, but for now we assume and check backups are continuous in
        // range (which is always true when we backup from a single backup coordinator)
        let mut next_ver = 0;
        let mut res = Vec::new();
        for backup in self.transaction_backups.iter().sorted() {
            if backup.first_version > target_version {
                break;
            }
            ensure!(
                backup.first_version == next_ver,
                "Transaction backup ranges not continuous, expecting version {}, got {}.",
                next_ver,
                backup.first_version,
            );

            if backup.last_version >= start_version {
                res.push(backup.clone());
            }

            next_ver = backup.last_version + 1;
        }

        Ok(res)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L159-211)
```rust
        let transactions = metadata_view.select_transaction_backups(
            // transaction info at the snapshot must be restored otherwise the db will be confused
            // about the latest version after snapshot is restored.
            next_txn_version.saturating_sub(1),
            self.end_version,
        )?;
        let global_opt = GlobalRestoreOptions {
            target_version: self.end_version,
            trusted_waypoints: Arc::new(self.trusted_waypoints_opt.verify()?),
            run_mode,
            concurrent_downloads: self.concurrent_downloads,
            replay_concurrency_level: 0, // won't replay, doesn't matter
        };

        if !skip_snapshot {
            if let Some(backup) = state_snapshot {
                StateSnapshotRestoreController::new(
                    StateSnapshotRestoreOpt {
                        manifest_handle: backup.manifest,
                        version: backup.version,
                        validate_modules: self.validate_modules,
                        restore_mode: Default::default(),
                    },
                    global_opt.clone(),
                    Arc::clone(&self.storage),
                    None, /* epoch_history */
                )
                .run()
                .await?;
            }
        }

        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            transactions
                .into_iter()
                .map(|t| t.manifest)
                .collect::<Vec<_>>(),
            save_start_version,
            Some((next_txn_version, false)), /* replay_from_version */
            None,                            /* epoch_history */
            self.verify_execution_mode.clone(),
            None,
        )
        .run()
        .await?;

        if self.verify_execution_mode.seen_error() {
            Err(ReplayError::TxnMismatch)
        } else {
            Ok(())
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L388-406)
```rust
    #[allow(dead_code)]
    fn get_actual_target_version(
        &self,
        transaction_backups: &[TransactionBackupMeta],
    ) -> Result<Version> {
        if let Some(b) = transaction_backups.last() {
            if b.last_version > self.target_version() {
                Ok(self.target_version())
            } else {
                warn!(
                    "Can't find transaction backup containing the target version, \
                    will restore as much as possible"
                );
                Ok(b.last_version)
            }
        } else {
            bail!("No transaction backup found.")
        }
    }
```
