# Audit Report

## Title
Epoch Transition Panic: DirectMempoolQuorumStore Crashes on InQuorumStore PayloadFilter

## Summary
During epoch transitions from QuorumStore-enabled mode to DirectMempool mode, validator nodes crash due to an `unreachable!()` panic when receiving `PayloadFilter::InQuorumStore` filters derived from pending blocks that contain QuorumStore-type payloads from the previous epoch.

## Finding Description

The vulnerability exists in the `handle_block_request()` function which processes payload requests. [1](#0-0) 

When `DirectMempoolQuorumStore` receives a request with `PayloadFilter::InQuorumStore`, it executes `unreachable!()` which causes a panic. This defensive programming assumption is violated during epoch transitions.

**Attack Path:**

1. **Epoch N**: QuorumStore is enabled (`quorum_store_enabled = true`), validators propose blocks with QuorumStore-type payloads (`Payload::InQuorumStore`, `Payload::OptQuorumStore`, etc.)

2. **Epoch Transition**: On-chain governance or configuration changes disable QuorumStore. [2](#0-1) 

3. **Epoch N+1 Start**: Validators initialize `DirectMempoolQuorumStore` instead of `QuorumStore`. [3](#0-2) 

4. **Proposal Generation**: When generating new proposals, the consensus layer collects pending blocks from commit root to parent. [4](#0-3) 

5. **Filter Construction**: The `PayloadFilter::from()` implementation checks if any payload is direct mode using `is_direct()`. [5](#0-4) 

6. **InQuorumStore Filter Created**: Since pending blocks contain only QuorumStore payloads (no DirectMempool payloads), `direct_mode` is false, creating `PayloadFilter::InQuorumStore`. [6](#0-5) 

7. **Panic**: The filter is sent to `DirectMempoolQuorumStore`, which hits the `unreachable!()` macro and crashes the validator node. [7](#0-6) 

## Impact Explanation

**High Severity** - This vulnerability causes validator node crashes and network liveness failures:

- **Validator Node Crashes**: Any validator attempting to propose during the transition epoch will panic and crash
- **Network Liveness Impact**: If multiple validators crash simultaneously, the network may lose liveness until nodes are manually restarted
- **Consensus Disruption**: Block production stops on affected nodes, potentially delaying transaction finalization
- **Automated Recovery Required**: Nodes must be restarted, but will continue crashing until all pending QuorumStore blocks are committed

This meets the **High Severity** criteria per Aptos bug bounty: "Validator node slowdowns, API crashes, Significant protocol violations."

## Likelihood Explanation

**High Likelihood** during epoch transitions:

- Aptos supports runtime configuration changes for QuorumStore enablement [8](#0-7) 
- Test infrastructure explicitly tests toggling between QuorumStore modes, indicating this is an expected operational scenario
- Any governance proposal to disable QuorumStore after it has been enabled will trigger this vulnerability
- No attacker action required - this is a natural consequence of legitimate configuration changes

## Recommendation

Replace the `unreachable!()` panic with proper handling that treats `InQuorumStore` filters as empty during DirectMempool mode:

```rust
async fn handle_block_request(
    &self,
    max_txns: u64,
    max_bytes: u64,
    return_non_full: bool,
    payload_filter: PayloadFilter,
    callback: oneshot::Sender<Result<GetPayloadResponse>>,
) {
    let get_batch_start_time = Instant::now();
    let exclude_txns = match payload_filter {
        PayloadFilter::DirectMempool(exclude_txns) => exclude_txns,
        PayloadFilter::InQuorumStore(_) => {
            // During epoch transitions from QuorumStore to DirectMempool mode,
            // we may receive InQuorumStore filters from pending blocks.
            // Treat these as empty since DirectMempool doesn't use batch proofs.
            warn!("Received InQuorumStore filter in DirectMempool mode, treating as empty");
            Vec::new()
        },
        PayloadFilter::Empty => Vec::new(),
    };
    // ... rest of function
}
```

## Proof of Concept

```rust
#[tokio::test]
#[should_panic(expected = "Unknown payload_filter")]
async fn test_epoch_transition_panic() {
    use aptos_consensus_types::{
        common::PayloadFilter,
        proof_of_store::BatchInfo,
        request_response::{GetPayloadCommand, GetPayloadRequest},
        utils::PayloadTxnsSize,
    };
    use futures::channel::{mpsc, oneshot};
    use std::collections::HashSet;

    let (quorum_store_to_mempool_sender, _quorum_store_to_mempool_receiver) =
        mpsc::channel(1_024);
    let (mut consensus_to_quorum_store_sender, consensus_to_quorum_store_receiver) =
        mpsc::channel(1_024);
    
    let quorum_store = DirectMempoolQuorumStore::new(
        consensus_to_quorum_store_receiver,
        quorum_store_to_mempool_sender,
        10_000,
    );
    let _join_handle = tokio::spawn(quorum_store.start());

    let (consensus_callback, _consensus_callback_rcv) = oneshot::channel();
    
    // Simulate epoch transition: DirectMempool receives InQuorumStore filter
    consensus_to_quorum_store_sender
        .try_send(GetPayloadCommand::GetPayloadRequest(GetPayloadRequest {
            max_txns: PayloadTxnsSize::new(100, 1000),
            max_txns_after_filtering: 100,
            soft_max_txns_after_filtering: 100,
            max_inline_txns: PayloadTxnsSize::new(50, 500),
            return_non_full: true,
            filter: PayloadFilter::InQuorumStore(HashSet::new()), // This causes panic
            callback: consensus_callback,
            block_timestamp: aptos_infallible::duration_since_epoch(),
            maybe_optqs_payload_pull_params: None,
        }))
        .unwrap();

    // Wait for panic
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
}
```

## Notes

This vulnerability demonstrates a classic epoch transition edge case where defensive programming assumptions (`unreachable!()`) become invalid during legitimate operational scenarios. The issue is particularly severe because:

1. It affects all validators simultaneously during epoch transitions
2. Recovery requires manual intervention (node restarts)
3. The condition persists until all pending QuorumStore blocks are committed
4. No validation exists to prevent the wrong filter type from being sent to the wrong quorum store implementation

The root cause is the architectural assumption that `DirectMempoolQuorumStore` will never receive non-DirectMempool payloads, which is violated when configuration changes occur mid-chain with pending blocks from the previous mode.

### Citations

**File:** consensus/src/quorum_store/direct_mempool_quorum_store.rs (L98-104)
```rust
        let exclude_txns = match payload_filter {
            PayloadFilter::DirectMempool(exclude_txns) => exclude_txns,
            PayloadFilter::InQuorumStore(_) => {
                unreachable!("Unknown payload_filter: {}", payload_filter)
            },
            PayloadFilter::Empty => Vec::new(),
        };
```

**File:** consensus/src/epoch_manager.rs (L716-777)
```rust
    async fn init_payload_provider(
        &mut self,
        epoch_state: &EpochState,
        network_sender: NetworkSender,
        consensus_config: &OnChainConsensusConfig,
        consensus_key: Arc<PrivateKey>,
    ) -> (
        Arc<dyn TPayloadManager>,
        QuorumStoreClient,
        QuorumStoreBuilder,
    ) {
        // Start QuorumStore
        let (consensus_to_quorum_store_tx, consensus_to_quorum_store_rx) =
            mpsc::channel(self.config.intra_consensus_channel_buffer_size);

        let quorum_store_config = if consensus_config.is_dag_enabled() {
            self.dag_config.quorum_store.clone()
        } else {
            self.config.quorum_store.clone()
        };

        let mut quorum_store_builder = if self.quorum_store_enabled {
            info!("Building QuorumStore");
            QuorumStoreBuilder::QuorumStore(InnerBuilder::new(
                self.epoch(),
                self.author,
                epoch_state.verifier.len() as u64,
                quorum_store_config,
                self.quorum_store_txn_filter_config.clone(),
                consensus_to_quorum_store_rx,
                self.quorum_store_to_mempool_sender.clone(),
                self.config.mempool_txn_pull_timeout_ms,
                self.storage.aptos_db().clone(),
                network_sender,
                epoch_state.verifier.clone(),
                self.proof_cache.clone(),
                self.quorum_store_storage.clone(),
                !consensus_config.is_dag_enabled(),
                consensus_key,
            ))
        } else {
            info!("Building DirectMempool");
            QuorumStoreBuilder::DirectMempool(DirectMempoolInnerBuilder::new(
                consensus_to_quorum_store_rx,
                self.quorum_store_to_mempool_sender.clone(),
                self.config.mempool_txn_pull_timeout_ms,
            ))
        };

        let (payload_manager, quorum_store_msg_tx) =
            quorum_store_builder.init_payload_manager(self.consensus_publisher.clone());
        self.quorum_store_msg_tx = quorum_store_msg_tx;
        self.payload_manager = payload_manager.clone();

        let payload_client = QuorumStoreClient::new(
            consensus_to_quorum_store_tx,
            self.config.quorum_store_pull_timeout_ms,
            self.config.wait_for_full_blocks_above_recent_fill_threshold,
            self.config.wait_for_full_blocks_above_pending_blocks,
        );
        (payload_manager, payload_client, quorum_store_builder)
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L585-589)
```rust
        let exclude_payload: Vec<_> = pending_blocks
            .iter()
            .flat_map(|block| block.payload())
            .collect();
        let payload_filter = PayloadFilter::from(&exclude_payload);
```

**File:** consensus/consensus-types/src/common.rs (L485-487)
```rust
    pub fn is_direct(&self) -> bool {
        matches!(self, Payload::DirectMempool(_))
    }
```

**File:** consensus/consensus-types/src/common.rs (L772-788)
```rust
        let direct_mode = exclude_payloads.iter().any(|payload| payload.is_direct());

        if direct_mode {
            let mut exclude_txns = Vec::new();
            for payload in exclude_payloads {
                if let Payload::DirectMempool(txns) = payload {
                    for txn in txns {
                        exclude_txns.push(TransactionSummary {
                            sender: txn.sender(),
                            replay_protector: txn.replay_protector(),
                            hash: txn.committed_hash(),
                        });
                    }
                }
            }
            PayloadFilter::DirectMempool(exclude_txns)
        } else {
```
