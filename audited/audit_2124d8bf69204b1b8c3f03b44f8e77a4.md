# Audit Report

## Title
SyncInfo Verification Bypass via None highest_ordered_cert Field Allowing Unverified Certificate Usage in Consensus

## Summary
The `highest_ordered_cert()` getter method in `SyncInfo` creates a critical verification bypass where a fallback conversion from `QuorumCert` to `WrappedLedgerInfo` is used without cryptographic verification, allowing malicious peers to inject semantically incorrect ordered certificates into the consensus protocol.

## Finding Description

The `SyncInfo` structure contains a verification bypass in how it handles the optional `highest_ordered_cert` field. The vulnerability exists in the interaction between two methods: [1](#0-0) [2](#0-1) 

**The Verification Bypass:**

When `highest_ordered_cert` field is `None`, the `verify()` method skips verifying the ordered certificate entirely using `.as_ref()` which returns `None`. However, the `highest_ordered_cert()` getter returns a fallback value by converting the `highest_quorum_cert` into a `WrappedLedgerInfo`. This fallback certificate is **never cryptographically verified as an ordered certificate**, yet it is used throughout consensus operations.

**Attack Path:**

1. A malicious peer crafts a `SyncInfo` message with `highest_ordered_cert` field set to `None` (achievable via manual message crafting or exploiting backward compatibility with older protocol versions)

2. The victim node receives this SyncInfo and calls `verify()`:
   - Line 187-188: Verifies `highest_quorum_cert` ✓ (passes)
   - Line 190-192: Checks `highest_ordered_cert.as_ref()` → None, skips verification ✗ (bypassed)

3. Validation checks at lines 141, 154, 162, 168 use the `highest_ordered_cert()` **getter**, which returns the unverified fallback conversion

4. The system proceeds to use this unverified certificate in `add_certs()`: [3](#0-2) 

5. The unverified certificate is inserted into the block tree and sent for execution: [4](#0-3) 

**Semantic Inconsistency:**

The conversion produces semantically different results than a legitimate ordered certificate: [5](#0-4) 

When order votes are enabled, legitimate ordered certificates should have `is_ordered_only() == true` (placeholder execution state): [6](#0-5) 

However, the fallback conversion from QC may contain real execution state from the QC's commit_info, violating the semantic expectation that ordered certificates use placeholder values. This can cause:

1. **Validation Bypass**: Check at line 153-154 becomes tautological, comparing `QC.certified_round >= QC.commit_round` (always true)
2. **State Inconsistency**: Different nodes may have different views of the highest ordered block
3. **Execution Mismatch**: Execution client receives incorrect state information [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** ($10,000 tier) under the Aptos Bug Bounty program:

- **State inconsistencies requiring intervention**: Different nodes using the fallback vs actual ordered certs will have inconsistent views of consensus state
- **Protocol violation**: Bypasses the requirement that all certificates must be cryptographically verified before use
- **Limited consensus disruption**: While not causing immediate funds loss or network partition, it allows manipulation of consensus state tracking

The impact is constrained because:
- The underlying QC data is verified, limiting the attacker's ability to inject completely arbitrary data
- Requires specific conditions (None field) that may not occur in normal operation with current protocol versions
- Does not directly cause funds theft or complete consensus break

However, it represents a clear violation of the security invariant that "all consensus certificates must be verified before use in protocol operations."

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can be triggered when:
1. A malicious peer sends a crafted `SyncInfo` with `highest_ordered_cert = None`
2. Backward compatibility scenarios where old protocol versions omit the field
3. Deserialization of malformed network messages

Current codebase shows all constructors set the field to `Some()`, but network deserialization allows `None`: [8](#0-7) 

The field is marked as `Option<WrappedLedgerInfo>`, indicating the protocol explicitly allows `None` values. An attacker with network access can craft such messages.

## Recommendation

**Fix 1: Require verification of the fallback**

Modify the `verify()` method to verify the fallback conversion when the field is None:

```rust
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    // ... existing checks ...
    
    self.highest_quorum_cert
        .verify(validator)
        .and_then(|_| {
            if let Some(cert) = &self.highest_ordered_cert {
                cert.verify(validator)
            } else {
                // Verify the fallback conversion
                self.highest_quorum_cert
                    .into_wrapped_ledger_info()
                    .verify(validator)
            }
            .context("Fail to verify ordered certificate")
        })
        // ... rest of verification ...
}
```

**Fix 2: Eliminate the fallback (preferred)**

Remove the fallback entirely and require the field to always be present:

```rust
pub fn highest_ordered_cert(&self) -> &WrappedLedgerInfo {
    self.highest_ordered_cert
        .as_ref()
        .expect("highest_ordered_cert must be set")
}
```

And change the field type to non-optional:
```rust
highest_ordered_cert: WrappedLedgerInfo,
```

**Fix 3: Make validation checks consistent**

Ensure all code paths use either the field or the getter consistently, not mixing `.as_ref()` and the getter method.

## Proof of Concept

```rust
// PoC: Demonstrating the verification bypass
use aptos_consensus_types::{
    sync_info::SyncInfo,
    quorum_cert::QuorumCert,
    wrapped_ledger_info::WrappedLedgerInfo,
};

// Test showing that verification succeeds with None field
// but the getter returns unverified data
#[test]
fn test_sync_info_verification_bypass() {
    // Create a valid QC
    let qc = QuorumCert::dummy();
    let commit_cert = WrappedLedgerInfo::dummy();
    
    // Manually construct SyncInfo with highest_ordered_cert = None
    // (In practice, this comes from deserializing a crafted network message)
    let sync_info_json = r#"{
        "highest_quorum_cert": ...,
        "highest_ordered_cert": null,
        "highest_commit_cert": ...,
        "highest_2chain_timeout_cert": null
    }"#;
    
    let sync_info: SyncInfo = serde_json::from_str(sync_info_json).unwrap();
    let verifier = ValidatorVerifier::new_for_test(...);
    
    // Verification passes (skips ordered cert since it's None)
    assert!(sync_info.verify(&verifier).is_ok());
    
    // But the getter returns a value (the unverified fallback)
    let ordered_cert = sync_info.highest_ordered_cert();
    
    // This cert was NEVER verified, yet it will be used in consensus operations
    // The commit_info may have different semantic meaning than expected
    assert_ne!(ordered_cert.commit_info(), &BlockInfo::empty());
}
```

## Notes

The vulnerability is subtle because the fallback uses data from the verified `highest_quorum_cert`, making it appear safe. However, the semantic conversion from `QuorumCert` to `WrappedLedgerInfo` changes the meaning of the certificate (from certified block to ordered block), and this converted certificate should itself be verified as a valid ordered certificate. The current implementation skips this verification step entirely when the field is `None`, creating a bypass that allows unverified certificates into consensus operations.

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L14-25)
```rust
#[derive(Deserialize, Serialize, Clone, Eq, PartialEq)]
/// This struct describes basic synchronization metadata.
pub struct SyncInfo {
    /// Highest quorum certificate known to the peer.
    highest_quorum_cert: QuorumCert,
    /// Highest ordered cert known to the peer.
    highest_ordered_cert: Option<WrappedLedgerInfo>,
    /// Highest commit cert (ordered cert with execution result) known to the peer.
    highest_commit_cert: WrappedLedgerInfo,
    /// Optional highest timeout certificate if available.
    highest_2chain_timeout_cert: Option<TwoChainTimeoutCertificate>,
}
```

**File:** consensus/consensus-types/src/sync_info.rs (L98-104)
```rust
    pub fn highest_ordered_cert(&self) -> WrappedLedgerInfo {
        if let Some(cert) = &self.highest_ordered_cert {
            cert.clone()
        } else {
            self.highest_quorum_cert.into_wrapped_ledger_info()
        }
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L152-156)
```rust
        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );
```

**File:** consensus/consensus-types/src/sync_info.rs (L187-194)
```rust
        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
```

**File:** consensus/src/block_storage/sync_manager.rs (L150-152)
```rust
        if self.order_vote_enabled {
            self.insert_ordered_cert(&sync_info.highest_ordered_cert())
                .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L206-227)
```rust
    pub async fn insert_ordered_cert(
        &self,
        ordered_cert: &WrappedLedgerInfo,
    ) -> anyhow::Result<()> {
        if self.ordered_root().round() < ordered_cert.ledger_info().ledger_info().round() {
            if let Some(ordered_block) = self.get_block(ordered_cert.commit_info().id()) {
                if !ordered_block.block().is_nil_block() {
                    observe_block(
                        ordered_block.block().timestamp_usecs(),
                        BlockStage::OC_ADDED,
                    );
                }
                SUCCESSFUL_EXECUTED_WITH_ORDER_VOTE_QC.inc();
                self.send_for_execution(ordered_cert.clone()).await?;
            } else {
                bail!("Ordered block not found in block store when inserting ordered cert");
            }
        } else {
            LATE_EXECUTION_WITH_ORDER_VOTE_QC.inc();
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L165-167)
```rust
    pub fn into_wrapped_ledger_info(&self) -> WrappedLedgerInfo {
        WrappedLedgerInfo::new(self.vote_data.clone(), self.ledger_info().clone())
    }
```

**File:** types/src/block_info.rs (L209-214)
```rust
    pub fn is_ordered_only(&self) -> bool {
        *self != BlockInfo::empty()
            && self.next_epoch_state.is_none()
            && self.executed_state_id == *ACCUMULATOR_PLACEHOLDER_HASH
            && self.version == 0
    }
```
