# Audit Report

## Title
Database Corruption Risk in Replay-Verify Tool Due to Non-Read-Only Database Access

## Summary
The `replay_verify.rs` tool opens the database in non-read-only mode and performs write operations during replay verification, creating a risk of database corruption if an operator accidentally points the tool at a live production database directory instead of a separate restore directory.

## Finding Description

The replay verification tool opens the database in write mode and performs multiple write operations during its execution: [1](#0-0) 

The tool explicitly sets `readonly` to `false`, allowing database modifications. During execution, the `ReplayVerifyCoordinator` uses `RestoreRunMode::Restore`: [2](#0-1) 

This triggers multiple database write operations through the `TransactionRestoreBatchController`: [3](#0-2) [4](#0-3) [5](#0-4) 

**Importantly**, the codebase provides an alternative read-only verification mode (`RestoreRunMode::Verify`) that is used by the `VerifyCoordinator`: [6](#0-5) 

This demonstrates that verification operations CAN be performed without database writes, but the replay-verify tool chooses not to use this mode.

**Attack Scenario:**
If an operator accidentally specifies a live/production database directory via `--target-db-dir` (e.g., due to misconfiguration, script error, or copy-paste mistake), the replay operations would write to the live database, potentially causing:
- State inconsistencies if replay fails partway through
- Data corruption if replay data conflicts with live data
- Database integrity violations requiring manual intervention

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program criteria: "State inconsistencies requiring intervention."

While RocksDB file locking prevents concurrent access when a node is running, the risk materializes when:
1. The node is stopped for maintenance
2. An operator runs replay-verify against the wrong directory
3. Database corruption occurs that requires manual recovery

The impact is limited because it requires operator access and error, but the consequences can be severe for node operations.

## Likelihood Explanation

**Likelihood: Medium-Low**

This issue is likely to occur because:
- The tool name "replay-verify" suggests read-only verification
- No explicit warnings prevent pointing at live databases
- CLI parameter is generic (`--target-db-dir`) without safety checks
- Operators may reuse database paths from other commands

However, likelihood is reduced by:
- RocksDB file locking when node is running
- Typical operator procedures separate backup/restore from production
- Most operators would use fresh directories for restore operations

## Recommendation

**Immediate Fix:**
Add a `--readonly` flag to the replay-verify tool and implement true read-only verification mode:

```rust
// In replay_verify.rs
pub struct Opt {
    // ... existing fields ...
    #[clap(long, default_value = "true")]
    readonly: bool,
}

impl Opt {
    pub async fn run(self) -> Result<()> {
        if self.readonly {
            // Use RestoreRunMode::Verify (read-only)
            let global_opt = GlobalRestoreOptions {
                run_mode: Arc::new(RestoreRunMode::Verify),
                // ... other options ...
            };
            // Run verification without database writes
        } else {
            // Existing restore behavior
            let restore_handler = Arc::new(AptosDB::open_kv_only(
                StorageDirPaths::from_path(self.db_dir),
                false,  // Allow writes only when explicitly requested
                // ... rest of configuration ...
            )?).get_restore_handler();
        }
    }
}
```

**Additional Safeguards:**
1. Add validation to detect if target directory contains an active database
2. Require explicit `--allow-writes` flag for non-readonly mode
3. Display prominent warning before any write operations
4. Check for RocksDB LOCK file and warn if present

## Proof of Concept

```bash
# Setup: Create a "production" database directory with test data
mkdir -p /tmp/prod_db
# ... initialize with test blockchain data ...

# Vulnerability: Operator accidentally uses production DB path
# Expected: Read-only verification
# Actual: Writes to production database
aptos-db-tool replay-verify \
    --target-db-dir /tmp/prod_db \
    --backup-dir /tmp/backup_data \
    --start-version 0 \
    --end-version 1000

# Result: Production database is modified during "verification"
# Can be verified by checking database modification timestamps
# and comparing state before/after replay-verify execution
```

**Demonstration Steps:**
1. Create a database with known state
2. Run replay-verify against it
3. Observe database writes occur (via filesystem monitoring or DB metrics)
4. Verify that database state has changed
5. Show that using `VerifyCoordinator` instead would not modify the database

## Notes

This finding represents a **design flaw creating operational risk** rather than a direct exploit-path vulnerability. While it doesn't meet the strict criteria of "exploitable by unprivileged attacker," it poses genuine risk to node operators and can cause state inconsistencies requiring manual intervention, fitting the Medium severity category. The existence of `RestoreRunMode::Verify` demonstrates that read-only verification is technically feasible and should be the default for a tool named "replay-verify."

### Citations

**File:** storage/db-tool/src/replay_verify.rs (L64-73)
```rust
        let restore_handler = Arc::new(AptosDB::open_kv_only(
            StorageDirPaths::from_path(self.db_dir),
            false,                       /* read_only */
            NO_OP_STORAGE_PRUNER_CONFIG, /* pruner config */
            self.rocksdb_opt.into(),
            false, /* indexer */
            BUFFERED_STATE_TARGET_ITEMS,
            DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
            None,
        )?)
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L117-119)
```rust
        let run_mode = Arc::new(RestoreRunMode::Restore {
            restore_handler: self.restore_handler,
        });
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L508-516)
```rust
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L593-600)
```rust
                        handler.save_transactions_and_replay_kv(
                            base_version,
                            &txns,
                            &persisted_aux_info,
                            &txn_infos,
                            &events,
                            write_sets,
                        )?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L715-715)
```rust
                        let v = chunk_replayer.commit()?;
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L101-101)
```rust
            run_mode: Arc::new(RestoreRunMode::Verify),
```
