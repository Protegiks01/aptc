# Audit Report

## Title
MultiEd25519 API Validation Logic Breaks k-of-n Threshold Signatures

## Summary
The API type validation for `MultiEd25519Signature` incorrectly enforces n-of-n signing by requiring all public keys to have corresponding signatures, fundamentally breaking the k-of-n threshold signature design. While the threshold value itself is correctly preserved during type conversion, the validation logic contradicts the documented "k-of-n signing" capability.

## Finding Description

The `MultiEd25519Signature` API type is documented as supporting "k-of-n signing for a transaction" [1](#0-0) , but the validation implementation contains a critical logic error.

The problematic validation check requires exact equality between the number of public keys and signatures: [2](#0-1) 

This check contradicts the fundamental design of threshold signatures. In a k-of-n multisig scheme (e.g., 3-of-5), there should be n public keys but only k signatures (where k ≥ threshold). The validation should verify `signatures.len() >= threshold` and `signatures.len() <= public_keys.len()`, not enforce equality.

**Evidence of the Bug:**

1. The `From` conversion correctly creates API responses with k-of-n signatures: [3](#0-2) 

This conversion outputs all n public keys but only k signatures (those that actually signed), along with the bitmap indicating which keys signed.

2. An ignored test demonstrates a valid 3-of-11 multisig that would fail the validation: [4](#0-3) 

The test output shows 11 public keys but only 3 signatures with threshold=3: [5](#0-4) 

3. The validation is called during transaction submission: [6](#0-5) 

**Regarding the Original Security Question:**

The threshold value IS correctly preserved in the conversion with no off-by-one errors: [7](#0-6) 

The conversion directly copies the threshold value without modification. The security issue is not in the conversion or an off-by-one error, but in the validation logic that misinterprets what threshold signatures mean.

## Impact Explanation

**HIGH Severity** - This qualifies as a "Significant protocol violation" under the Aptos bug bounty high severity category.

**Specific Impacts:**
- **Feature Breakage**: Users cannot submit valid k-of-n MultiEd25519 transactions via the JSON API
- **Fault Tolerance Loss**: Forces n-of-n signatures, eliminating the redundancy that threshold signatures provide
- **Account Lockout Risk**: Users who configure k-of-n multisig expecting fault tolerance may lose account access if one key is compromised/lost
- **API Inconsistency**: The API can OUTPUT k-of-n signatures (via the From conversion) but cannot INPUT them (due to validation), creating a fundamental asymmetry

This breaks the cryptographic correctness invariant and contradicts the documented API behavior.

## Likelihood Explanation

**High Likelihood:**
- Any user attempting to use k-of-n MultiEd25519 signatures via JSON API will encounter this issue
- The feature is documented and expected to work, so users will try to use it
- The ignored test indicates this is likely a known issue that hasn't been fixed
- No special privileges or complex attack is needed - normal usage triggers the bug

## Recommendation

Remove the incorrect validation check and replace with proper threshold-based validation:

```rust
// Remove this check:
} else if self.public_keys.len() != self.signatures.len() {
    bail!("MultiEd25519 signature does not have the same number of signatures as public keys")

// Replace with:
} else if self.signatures.len() > self.public_keys.len() {
    bail!("MultiEd25519 signature has more signatures than public keys")
```

The existing check at line 1345 already validates that `signatures.len() >= threshold`, which is sufficient. The validation should allow any number of signatures between `threshold` and `public_keys.len()` inclusive.

Additionally, validate the bitmap consistency - ensure the number of set bits in the bitmap matches the number of signatures, as done in the crypto layer: [8](#0-7) 

## Proof of Concept

The ignored test already serves as a PoC. To demonstrate the bug:

1. Remove the `#[ignore]` attribute from the test at line 800
2. Run: `cargo test test_multi_ed25519_signed_transaction`
3. The test will fail at the validation step because 11 ≠ 3

The test creates a valid 3-of-11 multisig and attempts to submit it via the JSON API, but the validation rejects it despite the signature being cryptographically valid.

## Notes

- The threshold value conversion itself is **correct** - there are no off-by-one errors in line 2204
- The bug is in the **validation logic** (line 1341), not the conversion
- The ignored test status suggests this may be a **known issue** that hasn't been prioritized for fixing
- This vulnerability affects only the **JSON API submission path** - BCS-encoded transactions bypass this validation
- The underlying crypto layer correctly implements k-of-n multisig; the bug is limited to the API validation layer

### Citations

**File:** api/types/src/transaction.rs (L1215-1225)
```rust
impl VerifyInput for TransactionSignature {
    fn verify(&self) -> anyhow::Result<()> {
        match self {
            TransactionSignature::Ed25519Signature(inner) => inner.verify(),
            TransactionSignature::MultiEd25519Signature(inner) => inner.verify(),
            TransactionSignature::MultiAgentSignature(inner) => inner.verify(),
            TransactionSignature::FeePayerSignature(inner) => inner.verify(),
            TransactionSignature::SingleSender(inner) => inner.verify(),
            TransactionSignature::NoAccountSignature(inner) => inner.verify(),
        }
    }
```

**File:** api/types/src/transaction.rs (L1311-1313)
```rust
/// A Ed25519 multi-sig signature
///
/// This allows k-of-n signing for a transaction
```

**File:** api/types/src/transaction.rs (L1341-1344)
```rust
        } else if self.public_keys.len() != self.signatures.len() {
            bail!(
                "MultiEd25519 signature does not have the same number of signatures as public keys"
            )
```

**File:** api/types/src/transaction.rs (L2181-2208)
```rust
impl
    From<(
        &MultiEd25519PublicKey,
        &multi_ed25519::MultiEd25519Signature,
    )> for MultiEd25519Signature
{
    fn from(
        (pk, sig): (
            &MultiEd25519PublicKey,
            &multi_ed25519::MultiEd25519Signature,
        ),
    ) -> Self {
        Self {
            public_keys: pk
                .public_keys()
                .iter()
                .map(|k| k.to_bytes().to_vec().into())
                .collect(),
            signatures: sig
                .signatures()
                .iter()
                .map(|s| s.to_bytes().to_vec().into())
                .collect(),
            threshold: *pk.threshold(),
            bitmap: sig.bitmap().to_vec().into(),
        }
    }
}
```

**File:** api/src/tests/transactions_test.rs (L800-802)
```rust
#[ignore]
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_multi_ed25519_signed_transaction() {
```

**File:** api/src/tests/transactions_test.rs (L845-870)
```rust
    assert_json(
        resp["signature"].clone(),
        json!({
          "type": "multi_ed25519_signature",
          "public_keys": [
            "0x9e4208caddd825f71957c9b12dbfbd13a23fb0ea23eb398fd7e1f418b51f8fbc",
            "0x4708a77bb9285ce3745ffdd48c51980326b625488209803228ff623f3768c64e",
            "0x852b13cd7a89b0c223d74504705e84c745d32261244ed233ef0285637a1dece0",
            "0x77e7fe2a510e4f14e15071fc420469ee287b64f2c8f8c0221b946a3fd9cbfef3",
            "0xd0c66cfef88b999f027347726bd54eda4675ae312af9146bfdc9e9fa702cc90a",
            "0xd316059933e0dd6415f00ce350962c8e94b46373b7fb5fb49687f3d6b9e3cb30",
            "0xf20e973e6dfeda74ca8e15f1a7aed9c87d67bd12e071fd3de4240368422712c9",
            "0xead82d6e9e3f3baeaa557bd7a431a1c6fe9f35a82c10fed123f362615ee7c2cd",
            "0x5c048c8c456ff9dd2810343bbd630fb45bf064317efae22c65a1535cf392c5d5",
            "0x861546d0818178f2b5f37af0fa712fe8ce3cceeda894b553ee274f3fbcb4b32f",
            "0xfe047a766a47719591348a4601afb3f38b0c77fa3f820e0298c064e7cde6763f"
          ],
          "signatures": [
                "0xcf9e7a0284434c568cefecd995d2f1c950b041513e815f9bdd8a42cb641c9b6dfcc692b767ace76f4171ef4fa032d3b4687e9944ffbb6b2ebe7033758e55a002",
                "0x840caf50f80da4ca2d4146458da3d93a0fd8e46796d231e36fa426614a10e372a25c2a4843367f6a632fa2459fd6bd8f0a4b35febad4fbdb780fcfba36d81f0b",
                "0xe1523537cc3d2be86df0c65a03cc1168c4d10e9436d8f69bce0e229f8e91c1714a0440e57d9813eedb495a39790fb9090b688173634bfbefe55e194384c45b05"

          ],
          "threshold": 3,
          "bitmap": "0xe0000000"
        }),
```

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L527-543)
```rust
        let num_ones_in_bitmap = bitmap_count_ones(self.bitmap);
        if num_ones_in_bitmap < public_key.threshold as u32 {
            return Err(anyhow!(
                "{}",
                CryptoMaterialError::BitVecError(
                    "Not enough signatures to meet the threshold".to_string()
                )
            ));
        }
        if num_ones_in_bitmap != self.signatures.len() as u32 {
            return Err(anyhow!(
                "{}",
                CryptoMaterialError::BitVecError(
                    "Bitmap ones and signatures count are not equal".to_string()
                )
            ));
        }
```
