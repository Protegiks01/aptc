# Audit Report

## Title
Consensus Bypass via Unverified LedgerInfo During Transaction Restore

## Summary
The transaction restore process in `restore.rs` fails to verify `LedgerInfoWithSignatures` when `epoch_history` is `None`, allowing an attacker with control over backup storage to inject arbitrary transactions with forged consensus proofs that bypass validator signature verification entirely.

## Finding Description

The vulnerability exists in the `LoadedChunk::load` function where `TransactionListWithProof` objects are constructed and verified during database restore operations. [1](#0-0) 

The critical flaw occurs at the conditional check: when `epoch_history` is `None`, the `LedgerInfoWithSignatures` loaded from backup storage is never cryptographically verified. This `epoch_history` parameter is explicitly set to `None` in two scenarios:

1. **Oneoff transaction restore mode:** [2](#0-1) 

2. **Bootstrap restore with `--skip-epoch-endings` flag:** [3](#0-2) 

The subsequent verification only checks Merkle proof consistency, not the authenticity of the LedgerInfo itself: [4](#0-3) 

The `TransactionListWithProof::verify` method only validates that transaction hashes match their corresponding `TransactionInfo` objects and that Merkle proofs are internally consistent: [5](#0-4) 

Critically, this verification does NOT check that the `LedgerInfo` was signed by validator quorum. The `EpochHistory::verify_ledger_info` method is responsible for signature verification: [6](#0-5) 

When this verification is skipped, an attacker controlling backup storage can:
1. Craft malicious transactions (token minting, unauthorized transfers)
2. Compute their transaction hashes
3. Create matching `TransactionInfo` objects
4. Generate a FORGED `LedgerInfoWithSignatures` with invalid/missing validator signatures
5. Construct valid Merkle proofs connecting everything

The forged data passes all checks and gets persisted to the database: [7](#0-6) 

**Invariant Violated:** Consensus Safety - The fundamental blockchain invariant that all state transitions must be validated by validator quorum is completely bypassed.

## Impact Explanation

This vulnerability achieves **Critical Severity** under the Aptos bug bounty program criteria:

- **Consensus/Safety Violation**: Complete bypass of AptosBFT consensus mechanism. Transactions are persisted without any validator signature verification, violating the core security guarantee of the blockchain.

- **Loss of Funds**: An attacker can inject transactions that mint tokens, transfer assets, or manipulate staking rewards. If the compromised restored node is used operationally (e.g., as an exchange's validator node or archive node), it could lead to direct financial loss.

- **State Inconsistency Requiring Intervention**: The restored node's state will diverge from the canonical chain, potentially requiring manual intervention or re-synchronization to detect and remediate.

The attack completely subverts the trust model by accepting arbitrary state changes as valid without validator consensus.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Prerequisites:**
- Control over backup storage (compromised S3 bucket, malicious storage provider, or man-in-the-middle attack during backup retrieval)
- Knowledge of the target node's restore operation

**Realistic Attack Scenarios:**

1. **Compromised Cloud Storage**: If backup storage credentials are leaked or the storage provider is compromised, attackers can replace legitimate backup files with malicious ones.

2. **Supply Chain Attack**: A malicious storage provider or compromised backup service could inject forged data.

3. **Oneoff Restore Operations**: The documented `db-tool restore oneoff transaction` command explicitly sets `epoch_history` to `None`, making this mode inherently vulnerable.

4. **Skip Epoch Endings Flag**: The existence of the `--skip-epoch-endings` flag suggests it's used in operational scenarios (possibly for performance or debugging), creating an attack surface.

The likelihood is elevated because:
- The vulnerable code path is production code, not debug-only
- Backup storage compromise is a realistic threat model
- The oneoff restore mode is a documented feature

## Recommendation

**Immediate Fix:** Remove the ability to restore transactions without epoch history verification. The `epoch_history` parameter should be mandatory for all restore operations.

**Code Changes Required:**

1. In `storage/db-tool/src/restore.rs`, make epoch history loading mandatory before transaction restore:

```rust
// Load epoch history BEFORE transaction restore
let epoch_history = Arc::new(
    EpochHistoryRestoreController::new(
        epoch_handles,
        global.clone(),
        storage.clone(),
    )
    .run()
    .await?
);

TransactionRestoreController::new(
    opt,
    global.try_into()?,
    storage.init_storage().await?,
    Some(epoch_history), // MANDATORY
    VerifyExecutionMode::NoVerify,
)
```

2. In `storage/backup/backup-cli/src/backup_types/transaction/restore.rs`, enforce epoch history requirement:

```rust
pub async fn load(
    manifest: TransactionChunk,
    storage: &Arc<dyn BackupStorage>,
    epoch_history: &Arc<EpochHistory>, // No longer Option
) -> Result<Self> {
    // ... load transactions ...
    
    let (range_proof, ledger_info) = storage
        .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
            &manifest.proof,
        )
        .await?;
    
    // MANDATORY verification
    epoch_history.verify_ledger_info(&ledger_info)?;
    
    // ... continue with TransactionListWithProof verification ...
}
```

3. Remove the `--skip-epoch-endings` flag or make it fail-safe by refusing to restore transactions without epoch verification.

**Defense in Depth:**
- Add integrity checks on backup storage (checksums, signatures)
- Implement backup file authentication before restoration
- Log all restore operations for audit trails
- Add warnings when restoring from untrusted sources

## Proof of Concept

```rust
// PoC: Restore malicious transaction without signature verification
// File: storage/backup/backup-cli/tests/forge_transaction_restore.rs

#[tokio::test]
async fn test_forged_transaction_bypass() {
    // Setup: Create malicious backup data
    let malicious_txn = create_forged_transaction();
    let malicious_txn_info = create_matching_txn_info(&malicious_txn);
    let forged_ledger_info = create_forged_ledger_info_with_signatures(); // No valid sigs
    let valid_merkle_proof = create_consistent_merkle_proof(
        &malicious_txn_info,
        &forged_ledger_info,
    );
    
    // Write malicious backup files
    let storage = create_test_storage();
    write_backup_chunk(storage, &malicious_txn, &malicious_txn_info);
    write_backup_proof(storage, &valid_merkle_proof, &forged_ledger_info);
    
    // Execute vulnerable restore with epoch_history = None
    let restore_controller = TransactionRestoreController::new(
        opt,
        global_opt,
        storage,
        None, // VULNERABILITY: No epoch history verification
        VerifyExecutionMode::NoVerify,
    );
    
    // Attack succeeds: Forged transaction is persisted without signature verification
    restore_controller.run().await.expect("Should succeed");
    
    // Verify malicious transaction was saved to database
    let db = open_db();
    let saved_txn = db.get_transaction(version).unwrap();
    assert_eq!(saved_txn, malicious_txn); // Attack successful!
}

fn create_forged_ledger_info_with_signatures() -> LedgerInfoWithSignatures {
    let ledger_info = LedgerInfo::new(...); // Arbitrary state root
    let empty_signatures = AggregateSignature::empty(); // NO VALID SIGNATURES
    LedgerInfoWithSignatures::new(ledger_info, empty_signatures)
}
```

**Verification Steps:**
1. Set up test backup storage with forged transaction data
2. Run `cargo test --package backup-cli test_forged_transaction_bypass`
3. Observe that forged transactions are accepted without signature verification
4. Confirm database contains malicious state changes

**Notes**

The vulnerability represents a fundamental architectural flaw where the restore process trusts backup storage without cryptographic verification. The `TransactionListWithProof` verification is insufficient as a security boundary because it only validates internal consistency (hashes and Merkle proofs), not authenticity (validator signatures).

The issue is particularly severe because:
- It affects documented operational procedures (oneoff restore mode)
- The `--skip-epoch-endings` flag suggests performance/operational trade-offs that prioritize speed over security
- Backup storage is often considered a trusted component, making compromise scenarios more realistic

The fix must enforce mandatory epoch history verification for all transaction restore operations, eliminating the possibility of restoring unverified state.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L157-167)
```rust
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-517)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
```

**File:** storage/db-tool/src/restore.rs (L102-107)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** types/src/transaction/mod.rs (L2318-2336)
```rust
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-310)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
```
