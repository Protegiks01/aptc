# Audit Report

## Title
Integer Overflow in Rosetta API Gas Fee Calculation Causes Incorrect Fee Estimates

## Summary
The Aptos Rosetta API performs unchecked u64 multiplication when calculating suggested gas fees, which can overflow when users provide extremely large `max_gas_amount` values. This results in incorrect fee estimates being returned to clients, though the underlying VM validation prevents actual fund loss.

## Finding Description

The vulnerability exists in two locations where unchecked u64 multiplication occurs:

**Location 1: Server-side fee calculation** [1](#0-0) 

In the `Amount::suggested_gas_fee` function, the multiplication `gas_unit_price * max_gas_amount` is performed without overflow checking.

**Location 2: Client-side validation** [2](#0-1) 

The test client performs the same unchecked multiplication for validation.

**Attack Path:**

1. Attacker calls Rosetta `/construction/preprocess` endpoint with malicious gas parameters:
   - `max_gas_amount`: 1.844×10^18 (u64::MAX / 10)
   - `gas_price`: 1000 (moderate value)

2. The only validation performed is: [3](#0-2) 

This only checks `max_gas_amount >= 1`, not upper bounds.

3. When `/construction/metadata` is called, the `simulate_transaction` function builds a transaction with DEFAULT max_gas_amount for simulation: [4](#0-3) 

The simulation succeeds because it uses the safe default value (2,000,000), not the user's malicious value.

4. After simulation, the fee is calculated using the **user's original unvalidated max_gas_amount**: [5](#0-4) 

5. The overflow occurs: 1.844×10^18 × 1000 = 1.844×10^21, which exceeds u64::MAX (≈1.844×10^19), wrapping to an incorrect small value.

**Why VM protection doesn't prevent the overflow:**

While the VM enforces strict bounds: [6](#0-5) 

These checks occur during actual transaction execution, NOT during Rosetta API fee estimation. The Rosetta API returns the overflowed suggested_fee before VM validation occurs.

## Impact Explanation

**Severity: Medium** (borderline Low)

While the overflow produces incorrect API responses, actual fund loss is prevented by downstream VM validation: [7](#0-6) 

**Impact limitations:**
- Transactions constructed with invalid gas parameters are rejected by the VM
- The Move prologue performs checked arithmetic: [8](#0-7) 

Move's default overflow checking prevents incorrect fee charges.

**Actual harm:**
- API returns incorrect fee estimates, confusing clients
- Client-side assertion failures in the test utility
- Potential DoS through malformed API responses
- No direct fund loss or consensus violation

This is primarily a **defensive programming failure** rather than a critical security vulnerability.

## Likelihood Explanation

**High likelihood of occurrence** - Any user can trigger this by calling the public Rosetta API with malicious parameters. The API lacks input validation against VM bounds before performing arithmetic operations.

**Low likelihood of actual harm** - The VM's multi-layered validation (gas bound checks, Move overflow checks) prevents any security impact beyond incorrect API responses.

## Recommendation

Add bounds validation in `construction_preprocess` before accepting gas parameters:

```rust
// In construction_preprocess, after line 1450:
if let Some(max_gas) = request.metadata.as_ref().and_then(|inner| inner.max_gas_amount) {
    // Validate against VM maximum (retrieve from gas schedule in production)
    const MAX_GAS_BOUND: u64 = 100_000_000; // Conservative bound
    if max_gas.0 > MAX_GAS_BOUND {
        return Err(ApiError::InvalidInput(Some(
            format!("max_gas_amount {} exceeds maximum bound {}", max_gas.0, MAX_GAS_BOUND)
        )));
    }
}

if let Some(gas_price) = request.metadata.as_ref().and_then(|inner| inner.gas_price) {
    const MAX_GAS_PRICE: u64 = 10_000_000_000;
    if gas_price.0 > MAX_GAS_PRICE {
        return Err(ApiError::InvalidInput(Some(
            format!("gas_price {} exceeds maximum bound {}", gas_price.0, MAX_GAS_PRICE)
        )));
    }
}
```

Additionally, use checked arithmetic in `Amount::suggested_gas_fee`:

```rust
pub fn suggested_gas_fee(gas_unit_price: u64, max_gas_amount: u64) -> ApiResult<Amount> {
    gas_unit_price.checked_mul(max_gas_amount)
        .map(|value| Amount {
            value: value.to_string(),
            currency: native_coin(),
        })
        .ok_or_else(|| ApiError::InvalidInput(Some(
            "Gas fee calculation would overflow u64".to_string()
        )))
}
```

## Proof of Concept

```rust
#[test]
fn test_gas_overflow_in_rosetta_api() {
    // Demonstrate overflow with realistic values
    let max_gas_amount: u64 = u64::MAX / 10; // 1.844e18
    let gas_price: u64 = 1000;
    
    // This multiplication overflows
    let result = max_gas_amount.wrapping_mul(gas_price);
    
    // Result wraps to incorrect small value
    assert!(result < max_gas_amount); // Overflow occurred
    println!("Overflowed result: {} (should be {})", result, max_gas_amount as u128 * gas_price as u128);
    
    // However, VM validation would catch this:
    // MAX_GAS_AMOUNT is 2,000,000 in production
    // So max_gas_amount = u64::MAX / 10 exceeds the bound
    // and would be rejected during transaction simulation/execution
}
```

## Notes

While this is a real implementation bug violating defensive programming principles, **the actual security impact is minimal** due to multi-layered validation in the VM and Move framework. The Rosetta API returns incorrect data, but cannot cause fund loss or consensus violations. This is more of a **code quality issue** than a critical vulnerability.

The VM bounds are specifically designed to prevent `max_gas_amount * gas_price` from overflowing u64: [9](#0-8) 

Given the extremely high bar for valid vulnerabilities and the requirement for "clear security harm demonstrated (funds, consensus, availability)", this issue **does not meet Critical, High, or Medium severity thresholds** as defined in the Aptos bug bounty program.

### Citations

**File:** crates/aptos-rosetta/src/types/objects.rs (L120-125)
```rust
    pub fn suggested_gas_fee(gas_unit_price: u64, max_gas_amount: u64) -> Amount {
        Amount {
            value: (gas_unit_price * max_gas_amount).to_string(),
            currency: native_coin(),
        }
    }
```

**File:** crates/aptos-rosetta/src/client.rs (L681-684)
```rust
        assert!(
            metadata.metadata.max_gas_amount.0 * metadata.metadata.gas_price_per_unit.0
                >= expected_fee
        );
```

**File:** crates/aptos-rosetta/src/construction.rs (L424-432)
```rust
        let max_gas_amount = if let Some(max_gas_amount) = options.max_gas_amount.as_ref() {
            max_gas_amount.0
        } else {
            // If estimating, we want to give headroom to ensure the transaction succeeds
            adjust_gas_headroom(simulated_txn.info.gas_used(), user_txn.max_gas_amount())
        };

        // Multiply the gas price times the max gas amount to use
        let suggested_fee = Amount::suggested_gas_fee(simulated_gas_unit_price, max_gas_amount);
```

**File:** crates/aptos-rosetta/src/construction.rs (L1441-1451)
```rust
    if let Some(max_gas) = request
        .metadata
        .as_ref()
        .and_then(|inner| inner.max_gas_amount)
    {
        if max_gas.0 < 1 {
            return Err(ApiError::InvalidInput(Some(
                "Cannot have a max gas amount less than 1".to_string(),
            )));
        }
    }
```

**File:** sdk/src/transaction_builder.rs (L36-45)
```rust
        Self {
            payload,
            chain_id,
            expiration_timestamp_secs,
            // TODO(Gas): double check this
            max_gas_amount: MAX_GAS_AMOUNT,
            gas_unit_price: std::cmp::max(GAS_UNIT_PRICE, 1),
            sender: None,
            sequence_number: None,
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L50-71)
```rust
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
        // computational time of any given transaction at roughly 20 seconds. We want this number and
        // `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
        [
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L126-138)
```rust
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L188-188)
```text
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
```
