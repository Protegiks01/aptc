# Audit Report

## Title
Missing Execution Pool Window Size Validation in Consensus Observer

## Summary
The `ExecutionPoolWindow::verify_window_contents()` function is not implemented and always returns `Ok()`, failing to validate that the execution pool window size matches the expected configuration. While this validation is called during message processing, the feature is currently incomplete and messages are dropped after validation, limiting immediate exploitability.

## Finding Description

The consensus observer system includes an `OrderedBlockWithWindow` message type that contains an execution pool window with block IDs representing parent blocks needed for execution. When processing these messages, the system calls `verify_window_contents()` to validate the window size against the configured `execution_pool_window_size`. [1](#0-0) 

However, this validation function is not implemented - it contains only a TODO comment and always returns `Ok()`, accepting any window size without validation.

The validation is called during message processing: [2](#0-1) 

The expected behavior can be inferred from `get_ordered_block_window()` which builds windows with specific size constraints: [3](#0-2) 

**Critical Limitation**: After validation passes, the message is currently dropped rather than processed: [4](#0-3) 

This TODO indicates the feature is incomplete. Without actual processing logic, a malicious window cannot cause harm in the current codebase.

## Impact Explanation

**Current Impact: Minimal** - The feature is incomplete and messages are dropped after validation. No actual exploitation path exists.

**Potential Future Impact (if completed without fixing): Medium** - If the TODO at line 895 is implemented without fixing the validation, a malicious consensus publisher could send:
- Windows with incorrect sizes causing execution failures
- Missing parent blocks leading to state inconsistencies  
- Excessive window sizes causing resource exhaustion

This would affect consensus observer nodes but not validators directly, qualifying as Medium severity under "State inconsistencies requiring intervention."

## Likelihood Explanation

**Current Likelihood: Not Applicable** - No exploitation is possible with the current incomplete implementation.

**Future Likelihood (if deployed unfixed): Low to Medium** - Would require:
1. Feature completion without fixing validation
2. Malicious or compromised consensus publisher
3. Observers with execution pool enabled

The presence of TODO comments suggests developers are aware the feature is incomplete, reducing the likelihood of deploying without proper validation.

## Recommendation

Before completing the feature (removing TODO at line 895), implement `verify_window_contents()`: [5](#0-4) 

The function should validate:
1. Number of block_ids matches expected window size based on block rounds
2. Block_ids are in chronological order
3. Window size is reasonable (< expected_window_size)

## Proof of Concept

This demonstrates the missing validation but cannot show exploitation due to incomplete feature:

```rust
#[test]
fn test_window_validation_missing() {
    // Create window with wrong size
    let wrong_window = ExecutionPoolWindow::new(vec![HashValue::random(); 1000]);
    
    // Validation should fail but currently always passes
    let expected_size = 5;
    assert!(wrong_window.verify_window_contents(expected_size).is_ok()); // âœ“ Passes incorrectly
}
```

**Notes:**
- This is an **incomplete feature** with missing validation, not a currently exploitable vulnerability
- The validation gap exists but cannot be exploited in current codebase due to line 895 TODO
- Should be fixed before feature deployment but does not represent immediate security risk

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L329-333)
```rust
    /// Verifies the execution pool window contents and returns an error if the data is invalid
    pub fn verify_window_contents(&self, _expected_window_size: u64) -> Result<(), Error> {
        Ok(()) // TODO: Implement this method!
    }
}
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L849-867)
```rust
        // Verify the execution pool window contents
        let execution_pool_window = ordered_block_with_window.execution_pool_window();
        if let Err(error) = execution_pool_window.verify_window_contents(execution_pool_window_size)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify execution pool window contents! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L895-895)
```rust
        // TODO: process the ordered block with window message (instead of just dropping it!)
```

**File:** consensus/src/block_storage/block_tree.rs (L264-305)
```rust
    pub fn get_ordered_block_window(
        &self,
        block: &Block,
        window_size: Option<u64>,
    ) -> anyhow::Result<OrderedBlockWindow> {
        // Block round should never be less than the commit root round
        ensure!(
            block.round() >= self.commit_root().round(),
            "Block round {} is less than the commit root round {}, cannot get_ordered_block_window",
            block.round(),
            self.commit_root().round()
        );

        // window_size is None only if execution pool is turned off
        let Some(window_size) = window_size else {
            return Ok(OrderedBlockWindow::empty());
        };
        let round = block.round();
        let window_start_round = calculate_window_start_round(round, window_size);
        let window_size = round - window_start_round + 1;
        ensure!(window_size > 0, "window_size must be greater than 0");

        let mut window = vec![];
        let mut current_block = block.clone();

        // Add each block to the window until you reach the start round
        while !current_block.is_genesis_block()
            && current_block.quorum_cert().certified_block().round() >= window_start_round
        {
            if let Some(current_pipelined_block) = self.get_block(&current_block.parent_id()) {
                current_block = current_pipelined_block.block().clone();
                window.push(current_pipelined_block);
            } else {
                bail!("Parent block not found for block {}", current_block.id());
            }
        }

        // The window order is lower round -> higher round
        window.reverse();
        ensure!(window.len() < window_size as usize);
        Ok(OrderedBlockWindow::new(window))
    }
```
