# Audit Report

## Title
Batch Retrieval Task Panic Due to V2 Batch Format Mismatch

## Summary
The batch retrieval RPC handler in `spawn_quorum_store()` unconditionally forces conversion of stored batches from `Batch<BatchInfoExt>` to `Batch<BatchInfo>` using `.expect()`, causing a panic when V2 batches are requested. This crashes the batch retrieval task and prevents the validator from serving batch requests to peers.

## Finding Description

The vulnerability exists in the batch retrieval task spawned by `spawn_quorum_store()`. [1](#0-0) 

The code retrieves a batch from local storage as `PersistedValue<BatchInfoExt>`, converts it to `Batch<BatchInfoExt>`, then attempts to force-convert it to `Batch<BatchInfo>` with `.expect("Batch retrieval requests must be for V1 batch")`.

However, the `BatchInfoExt` enum supports both V1 and V2 variants: [2](#0-1) 

The conversion from `Batch<BatchInfoExt>` to `Batch<BatchInfo>` is fallible and fails for V2 batches: [3](#0-2) 

When `enable_batch_v2` configuration flag is enabled, validators create V2 batches: [4](#0-3) 

The default configuration has `enable_batch_v2: false`, but it can be enabled: [5](#0-4) 

**Attack Path:**
1. Validator A enables `enable_batch_v2: true` in their configuration
2. Validator A creates and persists V2 batches locally with `BatchInfoExt::V2` format
3. Validator B requests a batch from Validator A via batch retrieval RPC
4. Validator A's batch retrieval task retrieves the V2 batch: [6](#0-5) 
5. The V2 batch is loaded from database: [7](#0-6) 
6. The forced conversion at line 414 fails because the batch is V2, not V1
7. The `.expect()` panics, crashing the batch retrieval task
8. Validator A can no longer serve batch requests to any validator

The code already has infrastructure for V2 batch responses in `BatchResponse::BatchV2`: [8](#0-7) 

## Impact Explanation

**High Severity** - This meets the "Validator node slowdowns" and "API crashes" criteria from the Aptos bug bounty program.

**Impact:**
- The batch retrieval task crashes and stops processing requests
- Other validators cannot retrieve batches from the affected node
- Proposals referencing batches from this validator will fail
- Multiple validators with `enable_batch_v2=true` could cause widespread consensus disruption
- The spawned task does not automatically restart: [9](#0-8) 

**Affected Components:**
- Batch retrieval availability
- Consensus proposal formation
- Network-wide batch distribution

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is likely to occur because:
- Configuration change is trivial (single boolean flag)
- No special privileges required beyond validator operator access
- The V2 batch format exists and is intended for future use
- Operators might enable the flag during testing or upgrades
- No validation prevents mixed V1/V2 deployments across validators
- The expect() message incorrectly assumes all batches are V1

## Recommendation

Replace the forced conversion with proper V2 batch handling:

```rust
let response = if let Ok(value) = batch_store.get_batch_from_local(&rpc_request.req.digest()) {
    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
    if batch.batch_info().is_v2() {
        BatchResponse::BatchV2(batch)
    } else {
        let batch_v1: Batch<BatchInfo> = batch
            .try_into()
            .expect("V1 batch conversion should succeed");
        BatchResponse::Batch(batch_v1)
    }
} else {
    // ... NotFound handling
};
```

Alternatively, always use `BatchResponse::BatchV2` which accepts `Batch<BatchInfoExt>` and is compatible with both V1 and V2 formats.

## Proof of Concept

```rust
// Integration test demonstrating the panic
#[tokio::test]
async fn test_batch_retrieval_v2_panic() {
    // Setup validator with enable_batch_v2 = true
    let mut config = QuorumStoreConfig::default();
    config.enable_batch_v2 = true;
    
    // Create and persist a V2 batch
    let batch_id = BatchId::new_for_test(1);
    let txns = vec![test_transaction()];
    let batch = Batch::new_v2(
        batch_id,
        txns,
        epoch,
        expiration,
        author,
        gas_bucket_start,
        BatchKind::Normal,
    );
    
    // Store the V2 batch
    batch_store.persist(vec![batch.into()]);
    
    // Simulate batch retrieval request from another validator
    let digest = batch.digest();
    
    // This will panic with "Batch retrieval requests must be for V1 batch"
    let result = batch_store.get_batch_from_local(&digest);
    let batch: Batch<BatchInfoExt> = result.unwrap().try_into().unwrap();
    
    // This expect() will panic:
    let _: Batch<BatchInfo> = batch
        .try_into()
        .expect("Batch retrieval requests must be for V1 batch");
    
    // Test fails here due to panic
}
```

**Notes**

This vulnerability demonstrates a version compatibility issue in the batch retrieval protocol. The code was written assuming all batches would be V1 format, but the V2 format capability exists and can be enabled via configuration. The presence of `BatchResponse::BatchV2` variant suggests the response protocol was designed to handle V2 batches, but the request handler was not updated accordingly. This creates a dangerous mismatch where enabling a supported configuration flag causes validator unavailability.

### Citations

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-415)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L192-203)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
pub enum BatchInfoExt {
    V1 {
        info: BatchInfo,
    },
    V2 {
        info: BatchInfo,
        extra: ExtraBatchInfo,
    },
}
```

**File:** consensus/src/quorum_store/types.rs (L336-353)
```rust
impl TryFrom<Batch<BatchInfoExt>> for Batch<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(batch: Batch<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(batch.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let Batch {
            batch_info,
            payload,
        } = batch;
        Ok(Self {
            batch_info: batch_info.unpack_info(),
            payload,
        })
    }
}
```

**File:** consensus/src/quorum_store/types.rs (L416-421)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum BatchResponse {
    Batch(Batch<BatchInfo>),
    NotFound(LedgerInfoWithSignatures),
    BatchV2(Batch<BatchInfoExt>),
}
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-211)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
        } else {
            Batch::new_v1(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
            )
        }
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** consensus/src/quorum_store/batch_store.rs (L552-559)
```rust
        if is_v2 {
            match self.db.get_batch_v2(digest) {
                Ok(Some(value)) => Ok(value),
                Ok(None) | Err(_) => {
                    warn!("Could not get batch from db");
                    Err(ExecutorError::CouldNotGetData)
                },
            }
```

**File:** consensus/src/quorum_store/batch_store.rs (L571-585)
```rust
    pub(crate) fn get_batch_from_local(
        &self,
        digest: &HashValue,
    ) -> ExecutorResult<PersistedValue<BatchInfoExt>> {
        if let Some(value) = self.db_cache.get(digest) {
            if value.payload_storage_mode() == StorageMode::PersistedOnly {
                self.get_batch_from_db(digest, value.batch_info().is_v2())
            } else {
                // Available in memory.
                Ok(value.clone())
            }
        } else {
            Err(ExecutorError::CouldNotGetData)
        }
    }
```

**File:** crates/aptos-logger/src/macros.rs (L5-14)
```rust
#[cfg(not(feature = "tokio-console"))]
#[macro_export]
macro_rules! spawn_named {
      ($name:expr, $func:expr) => { tokio::spawn($func); };
      ($name:expr, $handler:expr, $func:expr) => { $handler.spawn($func); };
      ($name:expr, $async:ident = async; $clojure:block) => { tokio::spawn( async $clojure); };
      ($name:expr, $handler:expr, $async:ident = async; $clojure:block) => { $handler.spawn( async $clojure); };
      ($name:expr, $async:ident = async ; $move:ident = move; $clojure:block) => { tokio::spawn( async move $clojure); };
      ($name:expr, $handler:expr, $async:ident = async ; $move:ident = move; $clojure:block) => { $handler.spawn( async move $clojure); };
  }
```
