# Audit Report

## Title
Memory Exhaustion via Unbounded String Deserialization in Keyless ZKP Signatures Before Size Validation

## Summary
The `ZeroKnowledgeSig` structure contains unbounded `Option<String>` fields (`extra_field` and `override_aud_val`) that are fully deserialized during BCS deserialization before any size validation occurs. This allows attackers to submit transactions with multi-megabyte strings that consume memory during deserialization, then fail validation without incurring gas costs, enabling a resource exhaustion attack on validator nodes.

## Finding Description

The keyless authentication system's `ZeroKnowledgeSig` structure has two string fields that lack size constraints during BCS deserialization: [1](#0-0) 

These strings are deserialized in the API layer without size limits: [2](#0-1) 

The API's content length limit is 8 MB, allowing large payloads: [3](#0-2) 

Size validation only occurs later during VM keyless validation when computing the public inputs hash: [4](#0-3) 

The transaction size check (64 KB limit) happens even later during prologue execution: [5](#0-4) 

**Attack Flow:**
1. Attacker crafts transaction with `ZeroKnowledgeSig` containing `extra_field` with 7 MB of data
2. Transaction submitted to API endpoint (under 8 MB HTTP limit)
3. BCS deserialization allocates 7 MB in memory for the string
4. Transaction sent to mempool and VM validator
5. Keyless validation fails when `pad_and_hash_string` checks size (7,000,000 > 350 bytes)
6. Transaction rejected with `INVALID_SIGNATURE` error
7. **No gas charged** because validation failed before execution

The validator flow shows keyless validation occurs before transaction size checks: [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability breaks the **Resource Limits invariant**: "All operations must respect gas, storage, and computational limits." Memory is allocated for oversized data structures before gas metering begins, and rejected transactions consume node resources without cost to the attacker.

**Impact Assessment (Medium Severity):**
- **Validator Node Slowdowns**: Sustained attack could degrade validator performance through memory pressure
- **No Gas Cost**: Attacker pays zero gas for rejected transactions
- **Limited but Real Impact**: Each transaction can waste up to ~8 MB of memory during the validation window
- **Amplification**: At 100 concurrent validations, 800 MB memory consumed; at 1000 concurrent, 8 GB consumed

This qualifies as **Medium Severity** per the bug bounty program as it enables validator node resource exhaustion without requiring insider access or consensus manipulation.

## Likelihood Explanation

**High Likelihood** - Attack requirements are minimal:
- Any user can submit transactions via public API
- No special privileges required
- Attack is repeatable and deterministic
- Trivial to automate with standard HTTP clients
- Validation time (~1-10ms) creates window for concurrent memory usage
- No rate limiting specifically prevents oversized keyless signatures

The expected configuration constants show the intended limits are orders of magnitude smaller than what can be deserialized: [8](#0-7) 

## Recommendation

**Immediate Fix:** Enforce size limits during BCS deserialization before allocating memory for strings. Add a custom deserializer for `ZeroKnowledgeSig` that validates string lengths:

```rust
impl<'de> Deserialize<'de> for ZeroKnowledgeSig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Use a temporary struct with validation
        #[derive(Deserialize)]
        struct TempZeroKnowledgeSig {
            proof: ZKP,
            exp_horizon_secs: u64,
            extra_field: Option<String>,
            override_aud_val: Option<String>,
            training_wheels_signature: Option<EphemeralSignature>,
        }
        
        let temp = TempZeroKnowledgeSig::deserialize(deserializer)?;
        
        // Validate sizes during deserialization
        if let Some(ref field) = temp.extra_field {
            if field.len() > MAX_EXTRA_FIELD_BYTES as usize {
                return Err(serde::de::Error::custom(
                    format!("extra_field exceeds {} bytes", MAX_EXTRA_FIELD_BYTES)
                ));
            }
        }
        if let Some(ref val) = temp.override_aud_val {
            if val.len() > MAX_AUD_VAL_BYTES {
                return Err(serde::de::Error::custom(
                    format!("override_aud_val exceeds {} bytes", MAX_AUD_VAL_BYTES)
                ));
            }
        }
        
        Ok(ZeroKnowledgeSig {
            proof: temp.proof,
            exp_horizon_secs: temp.exp_horizon_secs,
            extra_field: temp.extra_field,
            override_aud_val: temp.override_aud_val,
            training_wheels_signature: temp.training_wheels_signature,
        })
    }
}
```

**Alternative Fix:** Validate transaction size in API layer before BCS deserialization.

## Proof of Concept

```rust
#[test]
fn test_oversized_keyless_signature_memory_exhaustion() {
    use aptos_types::transaction::SignedTransaction;
    use aptos_types::keyless::{ZeroKnowledgeSig, ZKP, Groth16Proof};
    
    // Create a ZeroKnowledgeSig with 7 MB extra_field
    let oversized_string = "A".repeat(7 * 1024 * 1024);
    let zk_sig = ZeroKnowledgeSig {
        proof: ZKP::Groth16(Groth16Proof::dummy_proof()),
        exp_horizon_secs: 1000,
        extra_field: Some(oversized_string),  // 7 MB string
        override_aud_val: None,
        training_wheels_signature: None,
    };
    
    // Serialize to BCS
    let serialized = bcs::to_bytes(&zk_sig).unwrap();
    println!("Serialized size: {} bytes", serialized.len());
    assert!(serialized.len() > 7_000_000);
    
    // Deserialize - this allocates 7 MB in memory
    let start = std::time::Instant::now();
    let deserialized: ZeroKnowledgeSig = bcs::from_bytes(&serialized).unwrap();
    println!("Deserialization took: {:?}", start.elapsed());
    
    // Verify the string was deserialized
    assert_eq!(deserialized.extra_field.unwrap().len(), 7 * 1024 * 1024);
    
    // Later validation would fail when trying to hash this string
    // but memory has already been allocated
    
    println!("Attack successful: 7 MB allocated before validation");
}
```

**Notes:**
- The fix should be implemented in `types/src/keyless/groth16_sig.rs`
- Consider also adding early transaction size validation in the API layer
- Rate limiting on failed keyless validations could provide defense-in-depth
- The BCS `from_bytes_with_limit` only limits recursion depth, not individual field sizes

### Citations

**File:** types/src/keyless/groth16_sig.rs (L34-50)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Hash, Serialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct ZeroKnowledgeSig {
    pub proof: ZKP,
    /// The expiration horizon that the circuit should enforce on the expiration date committed in
    /// the nonce. This must be <= `Configuration::max_expiration_horizon_secs`.
    pub exp_horizon_secs: u64,
    /// An optional extra field (e.g., `"<name>":"<val>"`) that will be matched publicly in the JWT
    pub extra_field: Option<String>,
    /// Will be set to the override `aud` value that the circuit should match, instead of the `aud`
    /// in the IDC. This will allow users to recover keyless accounts bound to an application that
    /// is no longer online.
    pub override_aud_val: Option<String>,
    /// A signature on the proof and the statement (via the training wheels SK) to mitigate against
    /// flaws in our circuit.
    pub training_wheels_signature: Option<EphemeralSignature>,
}
```

**File:** api/src/transactions.rs (L1223-1232)
```rust
                let signed_transaction: SignedTransaction =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
                        .map_err(|err| {
                            SubmitTransactionError::bad_request_with_code(
                                err,
                                AptosErrorCode::InvalidInput,
                                ledger_info,
                            )
                        })?;
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L97-103)
```rust
    if len > max_bytes {
        bail!(
            "Byte array length of {} is NOT <= max length of {} bytes.",
            bytes.len(),
            max_bytes
        );
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1802-1810)
```rust
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1939-1949)
```rust
        self.run_prologue_with_payload(
            session,
            module_storage,
            &serialized_signers,
            executable,
            extra_config,
            transaction_data,
            log_context,
            is_approved_gov_script,
            traversal_context,
        )?;
```

**File:** types/src/keyless/circuit_constants.rs (L20-20)
```rust
pub(crate) const MAX_EXTRA_FIELD_BYTES: u16 = 350;
```
