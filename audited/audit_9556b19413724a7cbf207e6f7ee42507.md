# Audit Report

## Title
TOCTOU Race in Configuration Check Leading to Protocol Violation During Epoch Transitions

## Summary
A Time-of-Check to Time-of-Use (TOCTOU) race condition exists in `aptos_governance::reconfigure()` where the decision to start DKG is based on stale configuration data. When validator transaction or randomness configs transition from disabled to enabled, the system checks the old configuration but applies the new configuration, resulting in an epoch that has randomness enabled in its configuration but lacks the necessary DKG session to make it functional.

## Finding Description

The vulnerability exists in the reconfiguration flow when on-chain configurations are updated. The function `validator_txn_enabled()` reads from the currently active `ConsensusConfig` resource stored at `@aptos_framework` [1](#0-0) , while buffered configuration changes are applied later during `on_new_epoch()` [2](#0-1) .

In `aptos_governance::reconfigure()`, the code performs a conditional check to determine whether to start DKG [3](#0-2) . If the check returns false (because the old config has validator transactions or randomness disabled), it calls `finish()` without starting DKG. However, `finish()` then applies the buffered configuration by calling `consensus_config::on_new_epoch()` and `randomness_config::on_new_epoch()` [4](#0-3) , which may enable validator transactions and randomness.

**Attack Scenario:**
1. Current epoch: `validator_txn_enabled = false` (or `randomness = false`)
2. Governance proposes and buffers new config: `validator_txn_enabled = true`, `randomness = true` using the documented pattern [5](#0-4) 
3. `reconfigure()` is called following this standard pattern
4. Check at line 687 reads old config → condition evaluates to `false`
5. `finish()` is called without DKG
6. `consensus_config::on_new_epoch()` and `randomness_config::on_new_epoch()` apply buffered configs → new values become active [6](#0-5) 
7. New epoch starts with `validator_txn_enabled = true`, `randomness = true`
8. Consensus layer attempts to initialize randomness but fails because `DKGState.last_completed` is `None`, returning `NoRandomnessReason::DKGCompletedSessionResourceMissing` [7](#0-6) 
9. The error is logged and `rand_config` is set to `None` [8](#0-7) 
10. Blocks are created without randomness seeds, and smart contracts calling randomness APIs abort when attempting to borrow the `None` seed [9](#0-8) 

This breaks the protocol invariant that configuration accurately reflects system behavior.

## Impact Explanation

This qualifies as **High Severity** under the "Significant protocol violations" category. The on-chain configuration explicitly indicates that validator transactions and randomness are enabled, but the protocol operates in a degraded state without functional randomness for an entire epoch.

While all validators remain in consistent state (preventing consensus safety issues) and the system auto-recovers at the next epoch transition when `reconfigure()` properly starts DKG [10](#0-9) , the protocol violation is significant because:

- Randomness is a critical security feature for the blockchain
- Smart contracts and applications expecting randomness will abort at runtime, causing transaction failures and gas loss
- The configuration misrepresents the actual system state
- Affects all validators and users network-wide for an entire epoch
- Users lose gas fees for transactions that call randomness APIs and fail

## Likelihood Explanation

This issue has **high likelihood** of occurrence because:

1. It can happen during routine governance operations without malicious intent
2. The standard configuration update pattern documented in the code triggers this race, as shown in example release scripts [11](#0-10) 
3. No validation prevents buffered configs from differing significantly from active configs
4. Governance participants following documented procedures will inadvertently trigger this

The issue requires no special privileges beyond normal governance access and can occur accidentally whenever configuration transitions enable validator transactions or randomness.

## Recommendation

The fix should ensure that the DKG decision is based on the **buffered** configuration that will be active in the new epoch, not the current active configuration. One approach:

```move
public entry fun reconfigure(aptos_framework: &signer) {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // Check if buffered configs (not current active configs) will enable randomness
    let will_enable_vtxn = config_buffer::does_exist<ConsensusConfig>() && 
                           validator_txn_will_be_enabled();
    let will_enable_rand = config_buffer::does_exist<RandomnessConfig>() && 
                           randomness_will_be_enabled();
    
    if (will_enable_vtxn && will_enable_rand) {
        reconfiguration_with_dkg::try_start();
    } else {
        reconfiguration_with_dkg::finish(aptos_framework);
    }
}
```

Alternatively, apply configs before checking:
```move
public entry fun reconfigure(aptos_framework: &signer) {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // Apply buffered configs first
    consensus_config::on_new_epoch(aptos_framework);
    randomness_config::on_new_epoch(aptos_framework);
    
    // Then check the now-active configs
    if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
        reconfiguration_with_dkg::try_start();
    } else {
        reconfiguration_with_dkg::finish_without_config_apply(aptos_framework);
    }
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::toctou_test {
    use aptos_framework::aptos_governance;
    use aptos_framework::consensus_config;
    use aptos_framework::randomness_config;
    use aptos_framework::reconfiguration;
    use aptos_framework::stake;
    use std::features;
    use aptos_std::fixed_point64;
    
    #[test(aptos_framework = @0x1)]
    fun test_toctou_race(aptos_framework: signer) {
        // Initialize with randomness disabled
        consensus_config::initialize(&aptos_framework, initial_consensus_config_v1());
        randomness_config::initialize(&aptos_framework, randomness_config::new_off());
        
        // Verify randomness is currently disabled
        assert!(!randomness_config::enabled(), 1);
        
        // Buffer new configs that enable randomness
        consensus_config::set_for_next_epoch(&aptos_framework, consensus_config_with_vtxn());
        randomness_config::set_for_next_epoch(&aptos_framework, randomness_config_enabled());
        
        // Call reconfigure - this triggers the TOCTOU race
        aptos_governance::reconfigure(&aptos_framework);
        
        // After reconfigure, config says randomness is enabled
        assert!(randomness_config::enabled(), 2);
        
        // But DKG was never started, so randomness will not work
        // Smart contracts calling randomness APIs will abort
    }
}
```

## Notes

The severity assessment is based on the significant impact to users and the protocol:
- Network-wide impact affecting all validators and users
- Smart contract failures causing gas loss
- Configuration misrepresenting actual system state for an entire epoch
- Auto-recovery at next epoch prevents permanent damage

While this falls between High and Medium severity in the framework, the significance of randomness as a security feature and the network-wide user impact justify the High severity classification.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L46-56)
```text
    /// This can be called by on-chain governance to update on-chain consensus configs for the next epoch.
    /// Example usage:
    /// ```
    /// aptos_framework::consensus_config::set_for_next_epoch(&framework_signer, some_config_bytes);
    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);
    /// ```
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L59-69)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<ConsensusConfig>();
            if (exists<ConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-74)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L59-69)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires RandomnessConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<RandomnessConfig>()) {
            let new_config = config_buffer::extract_v2<RandomnessConfig>();
            if (exists<RandomnessConfig>(@aptos_framework)) {
                *borrow_global_mut<RandomnessConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            }
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L1040-1042)
```rust
        let dkg_session = dkg_state
            .last_completed
            .ok_or_else(|| NoRandomnessReason::DKGCompletedSessionResourceMissing)?;
```

**File:** consensus/src/epoch_manager.rs (L1243-1260)
```rust
        let (rand_config, fast_rand_config) = match rand_configs {
            Ok((rand_config, fast_rand_config)) => (Some(rand_config), fast_rand_config),
            Err(reason) => {
                if onchain_randomness_config.randomness_enabled() {
                    if epoch_state.epoch > 2 {
                        error!(
                            "Failed to get randomness config for new epoch [{}]: {:?}",
                            epoch_state.epoch, reason
                        );
                    } else {
                        warn!(
                            "Failed to get randomness config for new epoch [{}]: {:?}",
                            epoch_state.epoch, reason
                        );
                    }
                }
                (None, None)
            },
```

**File:** aptos-move/framework/aptos-framework/sources/randomness.move (L76-87)
```text
    fun next_32_bytes(): vector<u8> acquires PerBlockRandomness {
        assert!(is_unbiasable(), E_API_USE_IS_BIASIBLE);

        let input = DST;
        let randomness = borrow_global<PerBlockRandomness>(@aptos_framework);
        let seed = *option::borrow(&randomness.seed);

        vector::append(&mut input, seed);
        vector::append(&mut input, transaction_context::get_transaction_hash());
        vector::append(&mut input, fetch_and_increment_txn_counter());
        hash::sha3_256(input)
    }
```

**File:** aptos-move/aptos-release-builder/data/example-release-with-randomness-framework/output/1-consensus-config.move (L51-52)
```text
        consensus_config::set_for_next_epoch(framework_signer, consensus_blob);
        aptos_governance::reconfigure(framework_signer);
```
