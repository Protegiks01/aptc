# Audit Report

## Title
Missing Validation in Nested Protobuf Filter Conversion Allows Invalid EntryFunctionFilter Creation

## Summary
The `From<protobuf>` conversion for `UserTransactionPayloadFilter` does not validate nested `EntryFunctionFilter` construction, allowing malformed protobuf data to create filters with all fields set to `None`. This violates the explicit invariant that "at least one of address, module, or function must be set" and causes the invalid filter to match all entry functions instead of being rejected. [1](#0-0) 

## Finding Description
The protobuf-to-Rust conversion chain uses infallible `From` trait implementations that never validate the semantic correctness of filter data. When a client sends a protobuf `UserTransactionPayloadFilter` containing an `EntryFunctionFilter` where all three fields (`address`, `module_name`, `function`) are `None`, the conversion succeeds without error:

**Conversion Chain:**
1. `BooleanTransactionFilter::new_from_proto()` converts from protobuf without calling validation [2](#0-1) 

2. `TryFrom<ApiFilter>` uses `.into()` for `UserTransactionFilter` conversion (infallible) [3](#0-2) 

3. `From<UserTransactionFilter>` chains to nested `UserTransactionPayloadFilter` via `.into()` [4](#0-3) 

4. `From<UserTransactionPayloadFilter>` chains to `EntryFunctionFilter` via `.into()` [1](#0-0) 

5. `From<EntryFunctionFilter>` creates the filter with all fields as `None` [5](#0-4) 

The validation logic exists but is never called: [6](#0-5) 

The filter is then used directly in production services without validation: [7](#0-6) 

When the invalid filter is used in `matches()`, it returns `true` for all entry functions because all `Option` fields default to matching everything: [8](#0-7) [9](#0-8) 

## Impact Explanation
**Medium Severity** - This vulnerability causes:

1. **Resource Exhaustion**: Invalid filters match all transactions instead of being rejected, causing the indexer to process and stream excessive data. This can overload the service and degrade availability for legitimate clients.

2. **Invariant Violation**: The code explicitly requires "at least one of address, name or function must be set" but this constraint is never enforced during protobuf conversion.

3. **Logic Bypass**: Applications expecting validation will receive unexpected behavior when invalid filters are silently accepted and match everything.

While this does not directly affect consensus, Move VM execution, or fund security, it impacts the availability and correct operation of the indexer-grpc service, which is critical infrastructure for monitoring and querying blockchain state. Per Aptos bug bounty criteria, this qualifies as Medium severity due to state inconsistencies and potential service degradation.

## Likelihood Explanation
**High Likelihood** - The vulnerability is trivially exploitable:
- Any unauthenticated client can send malformed protobuf messages
- No special permissions or insider access required
- The attack path is deterministic and requires only a single malformed gRPC request
- Multiple production services (historical, live, and localnet data services) are affected

The only protection is the filter size limit, which doesn't prevent semantically invalid filters.

## Recommendation
Add explicit validation after protobuf conversion. Modify `parse_transaction_filter` to validate the constructed filter:

```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    let filter = BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))?;
    
    // Validate the filter after construction
    filter.is_valid()
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))?;
    
    Ok(filter)
}
```

Alternatively, add validation directly in `new_from_proto` before returning the filter.

## Proof of Concept
```rust
use aptos_protos::indexer::v1::{
    BooleanTransactionFilter, ApiFilter, UserTransactionFilter, 
    UserTransactionPayloadFilter, EntryFunctionFilter,
    boolean_transaction_filter, api_filter
};
use aptos_transaction_filter::BooleanTransactionFilter as RustFilter;
use aptos_transaction_filter::traits::Filterable;

#[test]
fn test_invalid_entry_function_filter_bypass() {
    // Create malformed protobuf with all None fields in EntryFunctionFilter
    let proto_filter = BooleanTransactionFilter {
        filter: Some(boolean_transaction_filter::Filter::ApiFilter(ApiFilter {
            filter: Some(api_filter::Filter::UserTransactionFilter(UserTransactionFilter {
                sender: None,
                payload_filter: Some(UserTransactionPayloadFilter {
                    entry_function_filter: Some(EntryFunctionFilter {
                        address: None,
                        module_name: None,
                        function: None,
                    }),
                }),
            })),
        })),
    };
    
    // This succeeds without validation
    let rust_filter = RustFilter::new_from_proto(proto_filter, None).unwrap();
    
    // But calling is_valid() reveals the filter is invalid
    let validation_result = rust_filter.is_valid();
    assert!(validation_result.is_err());
    assert!(validation_result.unwrap_err().to_string().contains("At least one"));
    
    // The filter was created in an invalid state, violating the invariant
}
```

**Notes**

This vulnerability is specific to the indexer-grpc transaction filtering system and does not affect core consensus, Move VM, or on-chain execution. However, it represents a real security issue in the indexer infrastructure that could be exploited for denial-of-service attacks against the query service. The fix requires adding a single validation call after filter construction to enforce the explicitly documented invariants.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-61)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L155-169)
```rust
impl From<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L183-188)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.address.is_none() && self.module.is_none() && self.function.is_none() {
            return Err(anyhow!("At least one of address, name or function must be set").into());
        };
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L191-211)
```rust
    fn matches(&self, module_id: &EntryFunctionId) -> bool {
        if !self.function.matches(&module_id.name) {
            return false;
        }

        if self.address.is_some() || self.function.is_some() {
            if let Some(module) = &module_id.module.as_ref() {
                if !(self
                    .get_standardized_address()
                    .matches(&standardize_address(&module.address))
                    && self.module.matches(&module.name))
                {
                    return false;
                }
            } else {
                return false;
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L238-246)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionPayloadFilter>
    for UserTransactionPayloadFilter
{
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionPayloadFilter) -> Self {
        Self {
            function: proto_filter.entry_function_filter.map(|f| f.into()),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L380-401)
```rust
impl TryFrom<aptos_protos::indexer::v1::ApiFilter> for APIFilter {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::ApiFilter) -> Result<Self> {
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in ApiFilter."))?
            {
                aptos_protos::indexer::v1::api_filter::Filter::TransactionRootFilter(
                    transaction_root_filter,
                ) => Into::<TransactionRootFilter>::into(transaction_root_filter).into(),
                aptos_protos::indexer::v1::api_filter::Filter::UserTransactionFilter(
                    user_transaction_filter,
                ) => Into::<UserTransactionFilter>::into(user_transaction_filter).into(),
                aptos_protos::indexer::v1::api_filter::Filter::EventFilter(event_filter) => {
                    Into::<EventFilter>::into(event_filter).into()
                },
            },
        )
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L83-100)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["historical_data_service_invalid_filter"])
                                .inc();
                            continue;
                        },
                    }
                } else {
                    None
                };
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/traits.rs (L108-121)
```rust
impl Filterable<String> for Option<String> {
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        Ok(())
    }

    #[inline]
    fn matches(&self, item: &String) -> bool {
        match self {
            Some(filter) => filter == item,
            None => true,
        }
    }
}
```
