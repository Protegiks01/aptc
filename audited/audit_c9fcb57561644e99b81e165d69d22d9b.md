# Audit Report

## Title
MaybeMutual Authentication Mode Lacks Anti-Replay Protection for Known Peers, Enabling DoS via Handshake Replay Attacks

## Summary
`HandshakeAuthMode::MaybeMutual` mode fails to enforce anti-replay timestamp validation even when authenticating known/trusted peers from the trusted_peers set. This allows network-level attackers to capture legitimate Noise IK handshake messages and replay them repeatedly, forcing victim nodes (VFNs and fullnodes) to perform expensive Diffie-Hellman cryptographic operations without any rate limiting, enabling Denial-of-Service attacks against critical infrastructure nodes.

## Finding Description

The Aptos network layer uses two authentication modes for Noise protocol handshakes: `Mutual` and `MaybeMutual`. [1](#0-0) 

Validator networks are enforced to use `Mutual` mode with anti-replay protection enabled. [2](#0-1) 

However, VFN and public fullnode networks default to `MaybeMutual` mode. [3](#0-2) 

The critical vulnerability lies in how `MaybeMutual` mode handles known peers. When a peer connects and IS found in the trusted_peers set, the server correctly authenticates the peer's public key. [4](#0-3) 

However, the anti-replay timestamp check that follows is ONLY executed when `anti_replay_timestamps()` returns `Some`, which only happens for `Mutual` mode. [5](#0-4) 

This means the anti-replay check is completely skipped for `MaybeMutual` mode. [6](#0-5) 

The anti-replay protection was explicitly designed to prevent attackers from replaying handshake messages to force expensive Diffie-Hellman operations. [7](#0-6) 

**Attack Flow:**

1. VFN runs with `MaybeMutual` authentication mode and has validators in its trusted_peers set (configured via seeds)
2. Attacker captures a legitimate Noise IK handshake initialization message from a validator connecting to the VFN
3. Attacker replays this captured message thousands of times to the VFN's listening port
4. For each replay, the VFN performs the full handshake processing at lines 325-364, including calling `parse_client_init_message()` which performs TWO expensive Diffie-Hellman operations [8](#0-7) 
5. The VFN authenticates the peer successfully since it's in trusted_peers [9](#0-8) 
6. The anti-replay check is skipped because `MaybeMutual` mode returns `None` from `anti_replay_timestamps()`
7. VFN continues to respond, performing additional crypto operations
8. Unlimited replays exhaust VFN CPU resources, causing node slowdown or unavailability

The expensive Diffie-Hellman operations are explicitly documented in the crypto module. [10](#0-9) 

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability enables Denial-of-Service attacks against Validator Full Nodes (VFNs) and public fullnodes, categorized as "Validator node slowdowns" in the bug bounty program. VFNs are critical infrastructure that:

1. Serve state sync requests for validators
2. Handle RPC traffic to reduce validator load
3. Provide redundancy for validator operations
4. Act as trusted upstream peers for public fullnodes

By exploiting this vulnerability, an attacker can:
- Exhaust VFN CPU resources through forced cryptographic operations
- Degrade VFN performance, impacting service quality for dependent nodes
- Potentially render VFNs completely unavailable if replay rate is sufficiently high
- Impact the broader network's ability to serve state sync and RPC requests

This is NOT a simple "network-level DoS" (which is out of scope). Instead, it exploits a missing protocol-level security check that was explicitly designed to prevent this exact attack vector. The vulnerability affects the network's operational availability without requiring any validator credentials or insider access.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Attacker only needs to:
   - Observe network traffic between validator and VFN (passive capture)
   - Replay captured handshake message (no cryptographic breaking required)
   - No authentication or privileged access needed

2. **Broad Attack Surface**: 
   - All VFNs running with default configuration are vulnerable
   - All public fullnodes with trusted peers are vulnerable
   - VFN network configuration is publicly documented

3. **High Impact vs. Low Cost**:
   - Single captured message can be replayed unlimited times
   - Each replay forces expensive crypto operations on victim
   - Attacker cost: minimal (just network bandwidth)
   - Victim cost: significant (CPU-intensive DH operations)

4. **No Detection**: 
   - Replayed messages appear as legitimate connection attempts
   - No logs indicate replay attack vs. normal connection pattern
   - Current implementation has no replay detection mechanism in MaybeMutual mode

## Recommendation

**Immediate Fix**: Enable anti-replay timestamp protection for ALL authenticated connections, not just those in `Mutual` mode.

**Code Fix** in `network/framework/src/noise/handshake.rs`:

Modify the `HandshakeAuthMode` enum to always include anti-replay protection when trusted peers exist:

```rust
pub enum HandshakeAuthMode {
    Mutual {
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
        peers_and_metadata: Arc<PeersAndMetadata>,
    },
    MaybeMutual {
        // Add anti-replay protection for known peers
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
        peers_and_metadata: Arc<PeersAndMetadata>,
    },
}

impl HandshakeAuthMode {
    pub fn maybe_mutual(peers_and_metadata: Arc<PeersAndMetadata>) -> Self {
        HandshakeAuthMode::MaybeMutual {
            anti_replay_timestamps: RwLock::new(AntiReplayTimestamps::default()),
            peers_and_metadata,
        }
    }
    
    fn anti_replay_timestamps(&self) -> Option<&RwLock<AntiReplayTimestamps>> {
        match &self {
            HandshakeAuthMode::Mutual { anti_replay_timestamps, .. } 
            | HandshakeAuthMode::MaybeMutual { anti_replay_timestamps, .. } => {
                Some(anti_replay_timestamps)
            }
        }
    }
}
```

**Alternative Fix**: Conditionally check anti-replay for known peers in `upgrade_inbound()`:

```rust
// After authenticating a known peer in MaybeMutual mode, check timestamp
if peer_was_in_trusted_set && payload.len() == AntiReplayTimestamps::TIMESTAMP_SIZE {
    // Extract and verify timestamp even in MaybeMutual mode
    let client_timestamp = u64::from_le_bytes(payload[..8]);
    // Perform replay check
}
```

**Memory Management Note**: The concern about "unbounded space" for timestamps [11](#0-10)  can be addressed by implementing timestamp garbage collection based on peer activity or a maximum cache size, rather than completely omitting replay protection.

## Proof of Concept

```rust
#[test]
fn test_maybe_mutual_replay_attack() {
    use aptos_memsocket::MemorySocket;
    use futures::executor::block_on;
    
    // Setup VFN with MaybeMutual mode
    let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Vfn]);
    let (vfn_private_key, vfn_public_key) = create_key_pair();
    let vfn_network_context = NetworkContext::new(
        RoleType::FullNode,
        NetworkId::Vfn,
        PeerId::random(),
    );
    
    // Setup validator with keys that VFN trusts
    let (validator_private_key, validator_public_key) = create_key_pair();
    let validator_peer_id = PeerId::random();
    
    // Add validator to VFN's trusted peers
    let trusted_peer = Peer::new(
        vec![],
        [validator_public_key].into_iter().collect(),
        PeerRole::Validator,
    );
    peers_and_metadata.insert_peer_metadata(
        NetworkId::Vfn,
        validator_peer_id,
        trusted_peer,
    );
    
    let vfn = NoiseUpgrader::new(
        vfn_network_context,
        vfn_private_key,
        HandshakeAuthMode::maybe_mutual(peers_and_metadata),
    );
    
    let validator = NoiseUpgrader::new(
        NetworkContext::new(RoleType::Validator, NetworkId::Vfn, validator_peer_id),
        validator_private_key,
        HandshakeAuthMode::maybe_mutual(peers_and_metadata.clone()),
    );
    
    // Capture legitimate handshake message
    let (client_socket, server_socket) = MemorySocket::new_pair();
    let captured_message = capture_first_handshake_message(
        &validator,
        vfn_public_key,
        validator_peer_id,
    );
    
    // Replay attack: Send same message 1000 times
    for i in 0..1000 {
        let (_, replay_socket) = MemorySocket::new_pair();
        
        // Send captured message
        replay_socket.write_all(&captured_message).await.unwrap();
        
        // VFN processes it - SHOULD reject but doesn't
        let result = vfn.upgrade_inbound(replay_socket).await;
        
        // Demonstrate that replay succeeds when it should fail
        assert!(result.is_ok(), 
            "Replay #{} should be rejected but was accepted", i);
    }
}
```

**Notes:**
- The vulnerability affects VFNs and public fullnodes, not validators directly (validators use `Mutual` mode which has anti-replay protection)
- While comment at lines 86-91 acknowledges memory concerns, this doesn't justify omitting critical security protection for known peers
- The "downgrade" referenced in the security question manifests as degraded security posture: authenticated connections lack replay protection that `Mutual` mode provides

### Citations

**File:** network/framework/src/noise/handshake.rs (L30-39)
```rust
/// In a mutually authenticated network, a client message is accompanied with a timestamp.
/// This is in order to prevent replay attacks, where the attacker does not know the client's static key,
/// but can still replay a handshake message in order to force a peer into performing a few Diffie-Hellman key exchange operations.
///
/// Thus, to prevent replay attacks a responder will always check if the timestamp is strictly increasing,
/// effectively considering it as a stateful counter.
///
/// If the client timestamp has been seen before, or is not strictly increasing,
/// we can abort the handshake early and avoid heavy Diffie-Hellman computations.
/// If the client timestamp is valid, we store it.
```

**File:** network/framework/src/noise/handshake.rs (L76-99)
```rust
/// Noise handshake authentication mode.
pub enum HandshakeAuthMode {
    /// In `Mutual` mode, both sides will authenticate each other with their
    /// `trusted_peers` set. We also include replay attack mitigation in this mode.
    ///
    /// For example, in the Aptos validator network, validator peers will only
    /// allow connections from other validator peers. They will use this mode to
    /// check that inbound connections authenticate to a network public key
    /// actually contained in the current validator set.
    Mutual {
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
        peers_and_metadata: Arc<PeersAndMetadata>,
    },
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
}
```

**File:** network/framework/src/noise/handshake.rs (L123-131)
```rust
    fn anti_replay_timestamps(&self) -> Option<&RwLock<AntiReplayTimestamps>> {
        match &self {
            HandshakeAuthMode::Mutual {
                anti_replay_timestamps,
                ..
            } => Some(anti_replay_timestamps),
            HandshakeAuthMode::MaybeMutual(_) => None,
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L359-364)
```rust
        // parse it
        let (prologue, client_init_message) = client_message.split_at(Self::PROLOGUE_SIZE);
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;
```

**File:** network/framework/src/noise/handshake.rs (L384-390)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
```

**File:** network/framework/src/noise/handshake.rs (L429-454)
```rust
        // if on a mutually authenticated network,
        // the payload should contain a u64 client timestamp
        if let Some(anti_replay_timestamps) = self.auth_mode.anti_replay_timestamps() {
            // check that the payload received as the client timestamp (in seconds)
            if payload.len() != AntiReplayTimestamps::TIMESTAMP_SIZE {
                return Err(NoiseHandshakeError::MissingAntiReplayTimestamp(
                    remote_peer_short,
                ));
            }

            let mut client_timestamp = [0u8; AntiReplayTimestamps::TIMESTAMP_SIZE];
            client_timestamp.copy_from_slice(&payload);
            let client_timestamp = u64::from_le_bytes(client_timestamp);

            // check the timestamp is not a replay
            let mut anti_replay_timestamps = anti_replay_timestamps.write();
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }

            // store the timestamp
            anti_replay_timestamps.store_timestamp(remote_public_key, client_timestamp);
        }
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** crates/aptos-crypto/src/noise.rs (L448-470)
```rust
        // <- es
        let dh_output = self.private_key.diffie_hellman(&re);
        let k = mix_key(&mut ck, &dh_output)?;

        // <- s
        let mut encrypted_remote_static = [0u8; x25519::PUBLIC_KEY_SIZE + AES_GCM_TAGLEN];
        cursor
            .read_exact(&mut encrypted_remote_static)
            .map_err(|_| NoiseError::MsgTooShort)?;

        let aead = aes_key(&k[..]);
        let mut in_out = encrypted_remote_static.to_vec();
        let nonce = aead::Nonce::assume_unique_for_key([0u8; AES_NONCE_SIZE]);
        let rs: &[u8] = aead
            .open_in_place(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Decrypt)?;

        let rs = x25519::PublicKey::try_from(rs).map_err(|_| NoiseError::WrongPublicKeyReceived)?;
        mix_hash(&mut h, &encrypted_remote_static);

        // <- ss
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```
