# Audit Report

## Title
Unverified Decryption Key Shares Enable Consensus-Breaking Threshold Manipulation

## Summary
Malicious validators can submit invalid decryption key shares that are aggregated without verification, corrupting the reconstructed decryption key and causing non-deterministic transaction decryption across validators, breaking consensus safety.

## Finding Description

The Aptos batch encryption system has a critical vulnerability where decryption key shares are reconstructed via Shamir secret sharing **without cryptographic verification**, allowing malicious validators to inject invalid shares that corrupt the final decryption key.

**Attack Flow:**

1. **Share Collection Without Verification**: When validators submit decryption key shares, they are added to the aggregator without calling the provided `verify()` method. [1](#0-0) 

The `add_share()` method accepts shares and immediately triggers aggregation without any verification step.

2. **Aggregation Without Verification**: The `aggregate()` function directly reconstructs the key from unverified shares. [2](#0-1) 

Despite a `verify()` method existing at lines 75-82, it is never called during the aggregation process.

3. **Blind Shamir Reconstruction**: The underlying reconstruction performs pure mathematical interpolation without cryptographic checks. [3](#0-2) 

The reconstruction only checks the number of shares (line 313), not their validity. It blindly computes Lagrange coefficients and performs weighted sum.

4. **Usage Without Post-Reconstruction Verification**: The corrupted key is used directly to decrypt transactions. [4](#0-3) 

The reconstructed key (line 119) is used immediately for decryption (line 126) with no verification against the master public key.

**Cryptographic Verification Exists But Is Unused:**

The system provides BLS-based verification for both individual shares and reconstructed keys: [5](#0-4) [6](#0-5) 

However, neither verification is called in the actual consensus usage path.

**Invariant Violation:**

This breaks the **Deterministic Execution** invariant: Different honest validators receiving different subsets of shares (some containing malicious invalid shares, some not) will reconstruct different decryption keys, decrypt the same encrypted transactions to different plaintexts, execute different transactions, and produce **different state roots for the same block**.

## Impact Explanation

**Critical Severity** - Consensus Safety Violation:

- **Consensus Split**: Validators using different share subsets (e.g., validators 1-6 vs validators 2-7) will reconstruct mathematically different decryption keys when malicious shares are included
- **Non-Deterministic Decryption**: Encrypted transactions decrypt to different plaintexts on different validators
- **State Root Divergence**: Different executions produce different state roots, causing validators to disagree on the committed state
- **Network Partition**: The chain splits into multiple forks as validators cannot reach consensus
- **Requires Hard Fork**: Recovery requires manual intervention and chain rollback

Per Aptos bug bounty: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)" are **Critical** severity ($1,000,000 maximum).

## Likelihood Explanation

**HIGH Likelihood:**

- **Single Malicious Validator**: Only requires ONE malicious validator with non-zero weight to inject invalid shares
- **No Detection**: Invalid shares are silently accepted and mixed with valid shares
- **Guaranteed Corruption**: Any invalid share mathematically corrupts the Shamir reconstruction output
- **Every Block**: Attack can be executed on every block containing encrypted transactions
- **No Validation Barrier**: Zero cryptographic checks prevent the attack

The code contains TODO comments suggesting this area is incomplete: [7](#0-6) 

## Recommendation

**Immediate Fix**: Add verification before reconstruction and after reconstruction.

```rust
// In types/src/secret_sharing.rs, SecretShare::aggregate()
pub fn aggregate<'a>(
    dec_shares: impl Iterator<Item = &'a SecretShare>,
    config: &SecretShareConfig,
) -> anyhow::Result<DecryptionKey> {
    let threshold = config.threshold();
    
    // VERIFY ALL SHARES BEFORE RECONSTRUCTION
    let shares: Vec<SecretKeyShare> = dec_shares
        .map(|dec_share| {
            // Verify each share
            dec_share.verify(config)?;
            Ok(dec_share.share.clone())
        })
        .take(threshold as usize)
        .collect::<anyhow::Result<Vec<_>>>()?;
    
    let decryption_key = <FPTXWeighted as BatchThresholdEncryption>::reconstruct_decryption_key(
        &shares,
        &config.config,
    )?;
    
    // VERIFY RECONSTRUCTED KEY AGAINST MASTER PUBLIC KEY
    config.encryption_key()
        .verify_decryption_key(&config.digest, &decryption_key)?;
    
    Ok(decryption_key)
}
```

**Defense in Depth**: Also verify in `SecretShareStore::add_share()`:

```rust
// In consensus/src/rand/secret_sharing/secret_share_store.rs
pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
    let weight = self.secret_share_config.get_peer_weight(share.author());
    let metadata = share.metadata();
    ensure!(metadata.epoch == self.epoch, "Share from different epoch");
    ensure!(
        metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
        "Share from future round"
    );
    
    // VERIFY SHARE BEFORE ACCEPTING
    share.verify(&self.secret_share_config)?;
    
    let item = self
        .secret_share_map
        .entry(metadata.round)
        .or_insert_with(|| SecretShareItem::new(self.self_author));
    item.add_share(share, weight)?;
    item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
    Ok(item.has_decision())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_threshold_manipulation {
    use super::*;
    use aptos_batch_encryption::shared::key_derivation::*;
    use aptos_crypto::arkworks::shamir::ShamirThresholdConfig;
    use ark_ff::UniformRand;
    use ark_std::rand::thread_rng;

    #[test]
    fn test_invalid_share_corrupts_reconstruction() {
        let mut rng = thread_rng();
        let n = 8;
        let t = 6;
        let tc = ShamirThresholdConfig::new(t, n);
        let msk = Fr::rand(&mut rng);
        let (mpk, vks, msk_shares) = gen_msk_shares(msk, &mut rng, &tc);
        let digest = Digest::new_for_testing(&mut rng);

        // Honest validators derive valid shares
        let mut dk_shares = vec![];
        for (i, msk_share) in msk_shares.into_iter().enumerate() {
            let mut dk_share = msk_share.derive_decryption_key_share(&digest).unwrap();
            
            // Malicious validator 3 submits INVALID share
            if i == 3 {
                // Corrupt the signature by using wrong value
                dk_share.1.signature_share_eval = G1Affine::rand(&mut rng);
            }
            
            dk_shares.push(dk_share);
        }

        // Verification would catch the invalid share
        for (i, dk_share) in dk_shares.iter().enumerate() {
            let verify_result = vks[i].verify_decryption_key_share(&digest, dk_share);
            if i == 3 {
                assert!(verify_result.is_err(), "Invalid share should fail verification");
            } else {
                assert!(verify_result.is_ok(), "Valid share should pass verification");
            }
        }

        // But reconstruction ACCEPTS invalid shares without verification
        let shares_with_invalid: Vec<BIBEDecryptionKeyShare> = 
            dk_shares[0..6].to_vec(); // includes invalid share at index 3
        
        let corrupted_key = BIBEDecryptionKey::reconstruct(&tc, &shares_with_invalid)
            .expect("Reconstruction succeeds even with invalid share");

        // The corrupted key FAILS verification against master public key
        assert!(
            mpk.verify_decryption_key(&digest, &corrupted_key).is_err(),
            "Reconstructed key from invalid shares should fail verification"
        );

        // Different validators using different subsets get DIFFERENT keys
        let shares_subset_a: Vec<BIBEDecryptionKeyShare> = 
            vec![dk_shares[0], dk_shares[1], dk_shares[2], 
                 dk_shares[3], dk_shares[4], dk_shares[5]].into_iter()
                 .cloned().collect();
        
        let shares_subset_b: Vec<BIBEDecryptionKeyShare> = 
            vec![dk_shares[1], dk_shares[2], dk_shares[4], 
                 dk_shares[5], dk_shares[6], dk_shares[7]].into_iter()
                 .cloned().collect();

        let key_a = BIBEDecryptionKey::reconstruct(&tc, &shares_subset_a).unwrap();
        let key_b = BIBEDecryptionKey::reconstruct(&tc, &shares_subset_b).unwrap();

        // CONSENSUS BREAK: Different validators get different decryption keys!
        assert_ne!(
            key_a.signature_g1, 
            key_b.signature_g1,
            "Different share subsets produce different keys - CONSENSUS VIOLATION"
        );
    }
}
```

## Notes

This vulnerability exists because verification and reconstruction are **separate, optional operations** with no enforcement mechanism. The codebase provides all necessary cryptographic verification functions (BLS signature checks via pairings), but the actual consensus integration fails to invoke them at any point in the critical path from share collection to key usage. A single malicious validator can deterministically break consensus safety for any block containing encrypted transactions.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```

**File:** types/src/secret_sharing.rs (L78-78)
```rust
        // TODO(ibalajiarun): Check index out of bounds
```

**File:** types/src/secret_sharing.rs (L84-99)
```rust
    pub fn aggregate<'a>(
        dec_shares: impl Iterator<Item = &'a SecretShare>,
        config: &SecretShareConfig,
    ) -> anyhow::Result<DecryptionKey> {
        let threshold = config.threshold();
        let shares: Vec<SecretKeyShare> = dec_shares
            .map(|dec_share| dec_share.share.clone())
            .take(threshold as usize)
            .collect();
        let decryption_key =
            <FPTXWeighted as BatchThresholdEncryption>::reconstruct_decryption_key(
                &shares,
                &config.config,
            )?;
        Ok(decryption_key)
    }
```

**File:** crates/aptos-crypto/src/arkworks/shamir.rs (L309-330)
```rust
    fn reconstruct(
        sc: &ShamirThresholdConfig<T::Scalar>,
        shares: &[ShamirShare<Self::ShareValue>],
    ) -> Result<Self> {
        if shares.len() < sc.t {
            Err(anyhow!(
                "Incorrect number of shares provided, received {} but expected at least {}",
                shares.len(),
                sc.t
            ))
        } else {
            let (roots_of_unity_indices, bases): (Vec<usize>, Vec<Self::ShareValue>) = shares
                [..sc.t]
                .iter()
                .map(|(p, g_y)| (p.get_id(), g_y))
                .collect();

            let lagrange_coeffs = sc.lagrange_for_subset(&roots_of_unity_indices);

            Ok(T::weighted_sum(&bases, &lagrange_coeffs))
        }
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L115-131)
```rust
        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");

        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L136-150)
```rust
    pub fn verify_decryption_key_share(
        &self,
        digest: &Digest,
        decryption_key_share: &BIBEDecryptionKeyShare,
    ) -> Result<()> {
        verify_bls(
            self.vk_g2,
            digest,
            self.mpk_g2,
            decryption_key_share.1.signature_share_eval,
        )
        .map_err(|_| BatchEncryptionError::DecryptionKeyShareVerifyError)?;

        Ok(())
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L153-164)
```rust
impl BIBEMasterPublicKey {
    pub fn verify_decryption_key(
        &self,
        digest: &Digest,
        decryption_key: &BIBEDecryptionKey,
    ) -> Result<()> {
        verify_bls(self.0, digest, self.0, decryption_key.signature_g1)
            .map_err(|_| BatchEncryptionError::DecryptionKeyVerifyError)?;

        Ok(())
    }
}
```
