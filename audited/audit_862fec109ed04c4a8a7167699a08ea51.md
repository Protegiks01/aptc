# Audit Report

## Title
Peer Score Race Condition Allows Malicious Peers to Serve Invalid Proofs Before Penalty Application

## Summary
The `ignore_low_score_peers` feature contains a timing vulnerability where peer scores are incremented immediately upon response receipt but only decremented after proof verification. This allows malicious peers below the ignore threshold (25.0) to temporarily boost their score above the threshold, serve invalid data that gets processed by the node, and then fall back below the threshold. The attack can be repeated indefinitely, causing resource exhaustion and sync delays.

## Finding Description

The Aptos Data Client implements a peer scoring system to ignore low-quality peers. When `ignore_low_score_peers` is enabled (default: `true`), peers with scores at or below `IGNORE_PEER_THRESHOLD` (25.0) are excluded from serving data requests. [1](#0-0) [2](#0-1) [3](#0-2) 

The vulnerability exists in the timing of score updates:

**1. Score is Updated on Response Receipt (BEFORE Verification):** [4](#0-3) 

The code explicitly states this is intentional but acknowledges the trade-off in the comments.

**2. Ignored Peers are Excluded from Data Serving:** [5](#0-4) [6](#0-5) 

**3. Proof Verification Happens Later in Consumer:** [7](#0-6) 

**4. Only Then is Peer Penalized:** [8](#0-7) [9](#0-8) [10](#0-9) 

**Attack Execution Path:**

1. Malicious peer maintains score = 24.0 (below 25.0 threshold, ignored)
2. Peer sends 2 valid responses: score increases to 26.0 (now serviceable)
3. Peer is included in global data summary calculation [11](#0-10) 

4. Peer sends response with invalid proof:
   - Score immediately increases: 26.0 + 1.0 = 27.0
   - Node processes the response, attempts verification
   - Proof verification fails, stream resets
   - Score penalized: 27.0 × 0.8 = 21.6 (back below threshold) [12](#0-11) [13](#0-12) 

5. Attack repeats: peer sends valid responses to boost score again

This breaks the **Resource Limits** invariant (invariant #9) and causes **validator node slowdowns** due to repeated proof verification attempts and stream resets.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty criteria)

This qualifies as "Validator node slowdowns" and "Significant protocol violations":

1. **Resource Exhaustion**: Each invalid proof forces expensive cryptographic verification operations before failure detection
2. **Sync Delays**: Repeated stream resets prevent the node from making forward progress on state synchronization
3. **Bandwidth Waste**: Node continuously requests and processes malicious data
4. **Amplification Effect**: Multiple malicious peers can coordinate this attack simultaneously

The attack affects all node types (validators, VFNs, PFNs) attempting to synchronize state, potentially degrading network-wide sync performance if executed at scale.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Only requires network connectivity; no validator privileges needed
- **Attack Complexity**: LOW - simple to execute with basic understanding of peer scoring
- **Detection Difficulty**: MEDIUM - appears as normal peer behavior (mix of valid/invalid responses)
- **Cost**: Minimal - attacker only needs to send valid responses periodically
- **Repeatability**: Infinite - attack cycle can repeat indefinitely
- **Scale**: Can be executed by multiple peers simultaneously for amplified impact

The attack is practical because:
- Sending valid responses is trivial (just proxy legitimate data)
- The score threshold (25.0) is easily reachable with 2 valid responses from 24.0
- The penalty (×0.8) doesn't prevent score recovery

## Recommendation

**Fix: Update Score Only After Proof Verification**

Defer the success score update until after the consumer validates the response:

1. Remove immediate `update_score_success()` call from `send_request_to_peer()`
2. Add a `notify_successful_response()` method to `ResponseCallback` trait
3. Have consumers call this after successful proof verification
4. Maintain current `notify_bad_response()` for failures

**Alternative Fix: Implement Stricter Penalty Thresholds**

If maintaining current architecture:
- Increase `IGNORE_PEER_THRESHOLD` to 30.0
- Decrease `MALICIOUS_MULTIPLIER` to 0.5 (more aggressive penalty)
- Require more consecutive valid responses to exit ignore state
- Track proof failure count separately and ban on repeated failures

**Code Fix (Recommended Approach):**

```rust
// In client.rs, remove line 817:
// self.peer_states.update_score_success(peer);

// In interface.rs, add to ResponseCallback trait:
fn notify_successful_response(&self);

// In consumer (state-sync-driver), after successful verification:
response_context.response_callback.notify_successful_response();
```

This ensures peers only receive score increases for cryptographically valid data.

## Proof of Concept

```rust
// Conceptual PoC demonstrating the attack cycle
// This would be implemented as an integration test in state-sync/aptos-data-client/src/tests/

#[tokio::test]
async fn test_score_manipulation_attack() {
    // Setup: Create data client with ignore_low_score_peers enabled
    let config = AptosDataClientConfig {
        ignore_low_score_peers: true,
        ..Default::default()
    };
    let (client, _poller) = create_test_client(config);
    
    // Create malicious peer with low score
    let malicious_peer = create_test_peer();
    manually_set_peer_score(&client, malicious_peer, 24.0);
    
    // Assert peer is ignored initially
    assert!(is_peer_ignored(&client, malicious_peer));
    
    // Attack Step 1: Send 2 valid responses to boost score
    for _ in 0..2 {
        send_valid_response(&client, malicious_peer).await;
    }
    
    // Assert peer is no longer ignored (score = 26.0)
    assert!(!is_peer_ignored(&client, malicious_peer));
    assert_eq!(get_peer_score(&client, malicious_peer), 26.0);
    
    // Attack Step 2: Send response with invalid proof
    let invalid_response = create_response_with_invalid_proof();
    client.send_request_to_peer(malicious_peer, request, timeout).await.unwrap();
    
    // Score increases immediately (before proof check)
    assert_eq!(get_peer_score(&client, malicious_peer), 27.0);
    
    // Simulate proof verification failure
    response_context.response_callback.notify_bad_response(
        ResponseError::ProofVerificationError
    );
    
    // Score decreases after penalty, but peer already served malicious data
    assert_eq!(get_peer_score(&client, malicious_peer), 21.6);
    
    // Peer back below threshold - attack can repeat
    assert!(is_peer_ignored(&client, malicious_peer));
}
```

## Notes

The vulnerability stems from an architectural decision to separate response receipt from proof verification for performance reasons. While the comments in the code acknowledge this trade-off, the security implications enable a concrete denial-of-service attack vector against state synchronization. The fix requires either architectural changes to delay score updates until full validation, or significantly more aggressive penalties that prevent score recovery after malicious behavior.

### Citations

**File:** config/src/config/state_sync_config.rs (L421-421)
```rust
    pub ignore_low_score_peers: bool,
```

**File:** config/src/config/state_sync_config.rs (L466-466)
```rust
            ignore_low_score_peers: true,
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L43-43)
```rust
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L142-149)
```rust
    /// Returns the storage summary iff the peer is not below the ignore threshold
    pub fn get_storage_summary_if_not_ignored(&self) -> Option<&StorageServerSummary> {
        if self.is_ignored() {
            None
        } else {
            self.storage_summary.as_ref()
        }
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L163-165)
```rust
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L168-174)
```rust
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L339-350)
```rust
    pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();
```

**File:** state-sync/aptos-data-client/src/client.rs (L811-817)
```rust
                // For now, record all responses that at least pass the data
                // client layer successfully. An alternative might also have the
                // consumer notify both success and failure via the callback.
                // On the one hand, scoring dynamics are simpler when each request
                // is successful or failed but not both; on the other hand, this
                // feels simpler for the consumer.
                self.peer_states.update_score_success(peer);
```

**File:** state-sync/aptos-data-client/src/client.rs (L1241-1245)
```rust
    fn notify_bad_response(&self, error: ResponseError) {
        let error_type = ErrorType::from(error);
        self.data_client
            .notify_bad_response(self.id, self.peer, &self.request, error_type);
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1294-1312)
```rust
                match transaction_outputs_with_proof.verify(
                    ledger_info_to_sync.ledger_info(),
                    Some(expected_start_version),
                ) {
                    Ok(()) => {
                        self.state_value_syncer
                            .set_transaction_output_to_sync(transaction_outputs_with_proof);
                    },
                    Err(error) => {
                        self.reset_active_stream(Some(NotificationAndFeedback::new(
                            notification_id,
                            NotificationFeedback::PayloadProofFailed,
                        )))
                        .await?;
                        return Err(Error::VerificationError(format!(
                            "Transaction outputs with proof is invalid! Error: {:?}",
                            error
                        )));
                    },
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L260-260)
```rust
        self.notify_bad_response(response_context, response_error);
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1389-1389)
```rust
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
```
