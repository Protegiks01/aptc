# Audit Report

## Title
Race Condition in Scheduler V1 Validation Index Management Causing Stale Transaction Validation

## Summary
A race condition exists in the BlockSTM V1 scheduler where concurrent commits of transactions with side effects can cause validation indices to be decreased out of order. This allows transactions to commit with stale validation results, potentially breaking deterministic execution across validators and causing consensus splits.

## Finding Description

The V1 scheduler's `wake_dependencies_and_decrease_validation_idx` function is called during transaction commit when side effects occur (module publishing or delayed field re-execution). This function decreases the validation index to trigger re-validation of dependent transactions. However, when multiple transactions with side effects commit sequentially, the validation index decrease can fail for later transactions, causing them to skip re-validation. [1](#0-0) 

The `decrease_validation_idx` function uses atomic `fetch_update` to modify the validation index: [2](#0-1) 

**The critical issue:** When transaction N has side effects at commit and calls `decrease_validation_idx(N+1)`, it may fail because a previous transaction M (where M < N) already decreased the validation index to a value less than or equal to N+1. When this happens:

1. The validation index is not updated
2. Transaction N+1's `max_triggered_wave` is never updated  
3. Transaction N+1 is NOT marked for re-validation despite transaction N's side effects

**Attack Scenario:**

1. Transaction 3 commits with side effects (e.g., module publishing), calls `wake_dependencies_and_decrease_validation_idx(3)` → `decrease_validation_idx(4)`, validation_idx becomes (4, wave=1)
2. Validation threads start validating transactions 4, 5, 6, 7... with wave 1
3. Transaction 5 commits and is marked as committed
4. During `prepare_and_queue_commit_ready_txn(5)`, delayed field validation fails, requiring re-execution
5. Transaction 5 is re-executed with new outputs written to versioned cache
6. `wake_dependencies_and_decrease_validation_idx(5)` is called → `decrease_validation_idx(6)`
7. **BUG:** Since validation_idx is (4, 1) and 4 < 6, the decrease fails with no effect
8. Transaction 6 was already validated with wave 1 using transaction 5's OLD outputs
9. Transaction 6's `max_triggered_wave` remains 0 (never updated)
10. Transaction 6 commits using stale validation based on transaction 5's old outputs [3](#0-2) 

The code comment incorrectly assumes all callers hold validation status locks: [4](#0-3) 

However, `wake_dependencies_and_decrease_validation_idx` does NOT hold such a lock, violating this assumption.

## Impact Explanation

This vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

When transaction 6 commits with stale validation:
- It validated against transaction 5's OLD outputs
- Its execution is based on those old outputs  
- Other validators that execute sequentially see transaction 5's NEW outputs
- Transaction 6 may produce different state transitions across validators
- This leads to **state divergence** and potential chain splits

**Severity: Critical** - This is a consensus safety violation. Different validators can produce different state roots for the same block, requiring manual intervention or a hard fork to resolve. According to Aptos bug bounty criteria, consensus/safety violations are Critical severity (up to $1,000,000).

## Likelihood Explanation

**Likelihood: Medium-High**

Required conditions:
1. Two or more transactions with commit-time side effects in the same block
2. Sequential commits of these transactions  
3. Intermediate transaction validation occurring between the commits

These conditions are realistic:
- Delayed field validation failures can occur naturally due to complex aggregator dependencies
- Module publishing transactions are common during upgrades
- Parallel validation runs concurrently with commits, making the timing window exploitable
- The ArmedLock ensures sequential commits, which is exactly the problematic pattern

An attacker could deliberately trigger this by:
1. Submitting transactions with complex aggregator operations that fail delayed field validation
2. Publishing Move modules in the same block
3. Relying on natural parallel execution to create the race window

## Recommendation

The validation status lock must be held when calling `decrease_validation_idx` from `wake_dependencies_and_decrease_validation_idx` to prevent the race condition. This ensures atomicity between checking the validation index and updating the transaction's `max_triggered_wave`.

**Fix:**

```rust
pub fn wake_dependencies_and_decrease_validation_idx(
    &self,
    txn_idx: TxnIndex,
) -> Result<(), PanicError> {
    // Acquire validation status lock for txn_idx to match other callers
    let _validation_status = self.txn_status[txn_idx as usize].1.

### Citations

**File:** aptos-move/block-executor/src/scheduler.rs (L598-610)
```rust
    pub fn wake_dependencies_and_decrease_validation_idx(
        &self,
        txn_idx: TxnIndex,
    ) -> Result<(), PanicError> {
        // We have exclusivity on this transaction.
        self.wake_dependencies_after_execution(txn_idx)?;

        // We skipped decreasing validation index when invalidating, as we were
        // executing it immediately, and are doing so now (unconditionally).
        self.decrease_validation_idx(txn_idx + 1);

        Ok(())
    }
```

**File:** aptos-move/block-executor/src/scheduler.rs (L812-845)
```rust
    fn decrease_validation_idx(&self, target_idx: TxnIndex) -> Option<Wave> {
        // We only call with txn_idx + 1, so it can equal num_txns, but not be strictly larger.
        assert!(target_idx <= self.num_txns);
        if target_idx == self.num_txns {
            return None;
        }

        if let Ok(prev_val_idx) =
            self.validation_idx
                .fetch_update(Ordering::SeqCst, Ordering::Acquire, |val_idx| {
                    let (txn_idx, wave) = Self::unpack_validation_idx(val_idx);
                    if txn_idx > target_idx {
                        let mut validation_status = self.txn_status[target_idx as usize].1.write();
                        // Update the minimum wave all the suffix txn needs to pass.
                        // We set it to max for safety (to avoid overwriting with lower values
                        // by a slower thread), but currently this isn't strictly required
                        // as all callers of decrease_validation_idx hold a write lock on the
                        // previous transaction's validation status.
                        validation_status.max_triggered_wave =
                            max(validation_status.max_triggered_wave, wave + 1);

                        Some(Self::pack_into_validation_index(target_idx, wave + 1))
                    } else {
                        None
                    }
                })
        {
            let (_, wave) = Self::unpack_validation_idx(prev_val_idx);
            // Note that 'wave' is the previous wave value, and we must update it to 'wave + 1'.
            Some(wave + 1)
        } else {
            None
        }
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L1055-1057)
```rust
        if side_effect_at_commit {
            scheduler.wake_dependencies_and_decrease_validation_idx(txn_idx)?;
        }
```
