# Audit Report

## Title
Strict Inequality in Epoch Filters Creates Boundary Blind Spots Leading to Consensus Divergence Risk

## Summary
The `BlockEpochLessThan` and `BlockEpochGreaterThan` filters use strict inequality operators (`<` and `>`) without providing inclusive alternatives (`≤` and `≥`). When administrators configure complementary filters to create continuous coverage, boundary values can fall into filtering gaps, creating blind spots. During emergency incident response, misconfiguration at boundaries can cause validators to disagree on proposal acceptance, leading to consensus liveness degradation.

## Finding Description

The block transaction filter system in [1](#0-0)  defines epoch filtering functions that use strict inequality. The matching logic at [2](#0-1)  implements this with `block_epoch > *target_epoch` and `block_epoch < *target_epoch`.

When administrators attempt to create complementary coverage using both filters, boundary epochs create gaps. For example:
- `Deny if BlockEpochLessThan: 100` matches epochs 0-99
- `Deny if BlockEpochGreaterThan: 100` matches epochs 101+  
- **Epoch 100 matches neither rule and gets allowed by default**

This becomes critical during consensus proposal validation at [3](#0-2)  where proposals containing denied transactions are rejected. If validators configure epoch filters differently due to boundary confusion:

1. Validator A configures: `Deny BlockEpochLessThan: 101` (intending to deny ≤100)
2. Validator B configures: `Deny BlockEpochLessThan: 100` and `Deny BlockEpochGreaterThan: 100` (intending to deny ≠100)
3. A proposal arrives with transactions at epoch 100
4. Validator A denies and rejects the proposal (100 < 101 matches)
5. Validator B allows and votes for the proposal (100 not < 100, 100 not > 100)
6. Consensus fails to reach agreement, proposal rejected

The filtering happens during block preparation at [4](#0-3)  where denied transactions are filtered before execution. Inconsistent filtering across validators breaks the deterministic execution invariant.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention." The impact includes:

1. **Consensus Liveness Degradation**: Validators disagree on proposal acceptance, causing proposals to fail and reducing block production rate
2. **Security Bypass During Incident Response**: If filters are deployed to block vulnerable transactions at specific epochs, boundary errors allow malicious transactions through
3. **Operational Disruption**: Requires manual intervention to identify and correct filter misconfigurations across validator set

This breaks the **Deterministic Execution** invariant (all validators must agree on block composition) when validators configure boundary values differently.

## Likelihood Explanation

**Likelihood: Medium**

This occurs when:
1. Emergency security filters are deployed rapidly under time pressure
2. Multiple validators configure filters independently without centralized coordination  
3. Administrators misunderstand strict inequality semantics
4. No validation or warnings exist about boundary gaps

The scenario is realistic during incident response when blocking specific epoch ranges is critical. The lack of inclusive operators (`≤`/`≥`) and boundary warnings increases misconfiguration probability. Tests at [5](#0-4)  document the behavior but provide no warnings about complementary rule pitfalls.

## Recommendation

1. **Add inclusive inequality operators** to `BlockMatcher` enum:
```rust
pub enum BlockMatcher {
    // ... existing variants ...
    BlockEpochLessThanOrEqual(u64),
    BlockEpochGreaterThanOrEqual(u64),
    BlockTimeStampLessThanOrEqual(u64),
    BlockTimeStampGreaterThanOrEqual(u64),
}
```

2. **Add configuration validation** to detect boundary gaps and warn administrators:
```rust
impl BlockTransactionFilter {
    pub fn validate_epoch_coverage(&self) -> Vec<String> {
        let mut warnings = Vec::new();
        // Detect gaps between LessThan and GreaterThan rules
        // Warn about potential blind spots
        warnings
    }
}
```

3. **Document boundary semantics** in configuration guides with explicit examples of gap scenarios

## Proof of Concept

```rust
#[test]
fn test_epoch_boundary_blind_spot() {
    // Simulate two validators with different boundary interpretations
    
    // Validator A: Wants to deny epochs <= 100, uses LessThan 101
    let filter_a = BlockTransactionFilter::empty()
        .add_block_epoch_less_than_filter(false, 101);
    
    // Validator B: Wants to deny all epochs except 100, uses complementary rules
    let filter_b = BlockTransactionFilter::empty()
        .add_block_epoch_less_than_filter(false, 100)
        .add_block_epoch_greater_than_filter(false, 100);
    
    let (block_id, block_author, _, block_timestamp) = get_random_block_info();
    let transactions = create_entry_function_transactions(false);
    
    // At epoch 100:
    let epoch_100_allowed_by_a = filter_a.allows_transaction(
        block_id, block_author, 100, block_timestamp, &transactions[0]
    );
    let epoch_100_allowed_by_b = filter_b.allows_transaction(
        block_id, block_author, 100, block_timestamp, &transactions[0]
    );
    
    // Validator A denies (100 < 101), Validator B allows (100 not < 100, 100 not > 100)
    assert!(!epoch_100_allowed_by_a); // Validator A denies
    assert!(epoch_100_allowed_by_b);  // Validator B allows - DIVERGENCE!
    
    // This divergence causes consensus disagreement on proposal acceptance
    println!("Consensus divergence detected at boundary epoch 100");
}
```

## Notes

The vulnerability is exacerbated by the configuration format shown at [6](#0-5)  which uses YAML and allows arbitrary epoch values without validation. The consensus integration at [7](#0-6)  shows that filter disagreements directly impact proposal acceptance, making this a consensus-critical issue.

### Citations

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L166-169)
```rust
    pub fn add_block_epoch_less_than_filter(self, allow: bool, epoch: u64) -> Self {
        let block_matcher = BlockTransactionMatcher::Block(BlockMatcher::BlockEpochLessThan(epoch));
        self.add_multiple_matchers_filter(allow, vec![block_matcher])
    }
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L311-318)
```rust
fn matches_epoch_greater_than(block_epoch: u64, target_epoch: &u64) -> bool {
    block_epoch > *target_epoch
}

/// Returns true iff the block epoch is less than the target epoch
fn matches_epoch_less_than(block_epoch: u64, target_epoch: &u64) -> bool {
    block_epoch < *target_epoch
}
```

**File:** consensus/src/round_manager.rs (L1202-1210)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** crates/aptos-transaction-filters/src/tests/block_transaction_filter.rs (L186-246)
```rust
fn test_block_epoch_greater_than_filter() {
    for use_new_txn_payload_format in [false, true] {
        // Create a filter that only allows transactions with a block epoch greater than a specific value
        let filter = BlockTransactionFilter::empty()
            .add_block_epoch_greater_than_filter(true, 1000)
            .add_all_filter(false);

        // Create a block ID, author, and timestamp
        let (block_id, block_author, _, block_timestamp) = utils::get_random_block_info();

        // Verify that the filter only allows transactions with a block epoch greater than 1000
        let transactions = utils::create_entry_function_transactions(use_new_txn_payload_format);
        for block_epoch in [0, 999, 1000] {
            verify_all_transactions_rejected(
                filter.clone(),
                block_id,
                Some(block_author),
                block_epoch,
                block_timestamp,
                transactions.clone(),
            );
        }
        for block_epoch in [1001, 1002] {
            verify_all_transactions_allowed(
                filter.clone(),
                block_id,
                Some(block_author),
                block_epoch,
                block_timestamp,
                transactions.clone(),
            );
        }

        // Create a filter that denies transactions with a block epoch greater than a specific value
        let filter = BlockTransactionFilter::empty()
            .add_block_epoch_greater_than_filter(false, 1000)
            .add_all_filter(true);

        // Verify that the filter only allows transactions with a block epoch less than or equal to 1000
        for block_epoch in [0, 999, 1000] {
            verify_all_transactions_allowed(
                filter.clone(),
                block_id,
                Some(block_author),
                block_epoch,
                block_timestamp,
                transactions.clone(),
            );
        }
        for block_epoch in [1001, 2000] {
            verify_all_transactions_rejected(
                filter.clone(),
                block_id,
                Some(block_author),
                block_epoch,
                block_timestamp,
                transactions.clone(),
            );
        }
    }
}
```

**File:** crates/aptos-transaction-filters/src/tests/block_transaction_filter_config.rs (L115-169)
```rust
#[test]
fn test_block_transaction_filter_config_multiple_matchers() {
    for use_new_txn_payload_format in [false, true] {
        // Create a block ID, author, epoch, and timestamp
        let (block_id, block_author, block_epoch, block_timestamp) = utils::get_random_block_info();

        // Create a malicious block author (where blocks are not allowed)
        let malicious_block_author = AccountAddress::random();

        // Create a filter that denies transactions based on multiple criteria
        let transactions = utils::create_entry_function_transactions(use_new_txn_payload_format);
        let block_transaction_filter_string = format!(
            r#"
            block_transaction_rules:
                - Deny:
                    - Transaction:
                        Sender: "{}"
                    - Transaction:
                        ModuleAddress: "0000000000000000000000000000000000000000000000000000000000000000"
                    - Block:
                        BlockId: "{}"
                - Deny:
                    - Transaction:
                        Sender: "{}"
                    - Transaction:
                        EntryFunction:
                            - "0000000000000000000000000000000000000000000000000000000000000001"
                            - entry
                            - check
                    - Block:
                        BlockId: "{}"
                - Deny:
                    - Transaction:
                        Sender: "{}"
                    - Block:
                        BlockId: "0000000000000000000000000000000000000000000000000000000000000000"
                - Deny:
                    - Block:
                        Author: "{}"
                - Deny:
                    - Block:
                        BlockEpochLessThan: {}
                - Allow:
                    - Transaction:
                        All
          "#,
            transactions[0].sender().to_standard_string(),
            block_id.to_hex(),
            transactions[1].sender().to_standard_string(),
            block_id.to_hex(),
            transactions[2].sender().to_standard_string(),
            malicious_block_author,
            block_epoch,
        );
        let block_transaction_filter =
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L30-70)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal. Note: all
        // transactions in a direct mempool payload are inline transactions.
        let (inline_transactions, _, _) = get_transactions_from_block(block)?;
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for DirectMempoolPayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```
