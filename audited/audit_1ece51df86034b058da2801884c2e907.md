# Audit Report

## Title
Permanent Shard Execution Freeze Due to Missing Timeout on Cross-Shard Dependency Resolution

## Summary
The `execute_transactions_with_dependencies()` function in the sharded block executor lacks timeout protection on critical blocking operations. The main thread blocks indefinitely waiting for a callback from the executor thread, while the executor thread can itself block indefinitely waiting for cross-shard state values. This creates a vulnerability where edge cases in cross-shard message delivery or execution errors can cause permanent shard freezes without recovery.

## Finding Description
The vulnerability exists in the cross-shard execution coordination mechanism: [1](#0-0) [2](#0-1) 

The main thread blocks indefinitely on `block_on(callback_receiver).unwrap()` without any timeout. The callback is sent by an executor thread that must complete block execution and send cross-shard stop messages: [3](#0-2) 

During execution, transactions with cross-shard dependencies block waiting for remote state values through a condition variable with no timeout: [4](#0-3) [5](#0-4) 

The cross-shard commit receiver waits indefinitely for messages: [6](#0-5) [7](#0-6) 

Additionally, transaction abort handling is unimplemented, which could trigger panics: [8](#0-7) 

**Attack Scenarios:**
While direct attacker control is limited, several edge cases can trigger permanent freezes:
1. Bugs in cross-shard message delivery causing missing `RemoteTxnWriteMsg` 
2. Race conditions during shard coordination
3. Network issues in distributed remote execution mode
4. Transaction aborts triggering unimplemented handlers

## Impact Explanation
**High Severity** per Aptos bug bounty criteria - "Validator node slowdowns."

The vulnerability causes permanent shard execution freeze, which directly impacts:
- **Consensus Liveness**: Frozen shards cannot process new blocks, stalling the chain
- **Validator Availability**: Affected validator nodes become unresponsive  
- **No Recovery**: No timeout or watchdog mechanism exists; requires node restart
- **Cascading Failures**: If multiple shards freeze, entire validator fails

This violates the **Deterministic Execution** and **State Consistency** invariants, as different validators may experience hangs at different times, leading to consensus disruption.

## Likelihood Explanation
**Medium-to-Low Likelihood** but **High Impact**:

- Requires specific edge cases to trigger (message delivery failures, race conditions)
- Cross-shard dependencies are system-computed (not directly attacker-controlled)
- More likely to manifest as:
  - Bugs in production under heavy load
  - Network issues in distributed deployments  
  - Race conditions during concurrent shard execution
- Less likely in local multi-threaded mode with reliable channels
- The unimplemented `on_execution_aborted` increases risk during error conditions

The lack of defensive timeout protection means ANY bug or edge case in the complex cross-shard coordination logic becomes a potential freeze scenario.

## Recommendation
Implement timeout protection at multiple levels:

1. **Add timeout to block_on call** in `execute_transactions_with_dependencies()`:
```rust
use tokio::time::{timeout, Duration};
const EXECUTION_TIMEOUT: Duration = Duration::from_secs(300); // 5 minutes

match timeout(EXECUTION_TIMEOUT, callback_receiver).await {
    Ok(Ok(result)) => result,
    Ok(Err(_)) => return Err(VMStatus::Error { /* channel closed */ }),
    Err(_) => return Err(VMStatus::Error { /* timeout */ }),
}
```

2. **Add timeout to RemoteStateValue::get_value()**:
```rust
use std::time::Duration;

pub fn get_value_with_timeout(&self, timeout: Duration) -> Result<Option<StateValue>, TimeoutError> {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    let (mut status, timeout_result) = cvar.wait_timeout_while(
        status,
        timeout,
        |s| matches!(s, RemoteValueStatus::Waiting)
    ).unwrap();
    
    if timeout_result.timed_out() {
        return Err(TimeoutError);
    }
    // ... return value
}
```

3. **Implement on_execution_aborted** to gracefully handle transaction aborts instead of panicking

4. **Add watchdog monitoring** at the shard service level to detect and recover from hangs

## Proof of Concept
The vulnerability is difficult to reproduce deterministically without access to internal Aptos infrastructure. A theoretical PoC would require:

```rust
// Theoretical test scenario (requires Aptos test infrastructure)
#[test]
fn test_shard_freeze_on_missing_cross_shard_message() {
    // 1. Set up sharded executor with 2 shards
    // 2. Create transactions with cross-shard dependencies from Shard 0 to Shard 1
    // 3. Inject a fault that prevents RemoteTxnWriteMsg from Shard 0 reaching Shard 1
    //    (e.g., drop message in LocalCrossShardClient::send_cross_shard_msg)
    // 4. Start execution on both shards
    // 5. Observe: Shard 1 hangs indefinitely in RemoteStateValue::get_value()
    // 6. Observe: Main thread hangs indefinitely in block_on(callback_receiver)
    // Expected: Timeout after reasonable duration, return error
    // Actual: Permanent hang requiring external intervention
}
```

**Notes**
This vulnerability represents a critical gap in defensive programming for a consensus-critical system. While the primary attack surface requires triggering edge cases rather than direct malicious input, the lack of timeout protection means that ANY bug, race condition, or network issue in the complex cross-shard coordination can cause catastrophic permanent freezes. The unimplemented transaction abort handler further increases the risk surface. The high impact on consensus liveness combined with the absence of recovery mechanisms qualifies this as a High severity issue per the bug bounty program criteria for "Validator node slowdowns" and "Significant protocol violations."

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L113-113)
```rust
        let (callback, callback_receiver) = oneshot::channel();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L142-179)
```rust
            s.spawn(move |_| {
                let txn_provider =
                    DefaultTxnProvider::new_without_info(signature_verified_transactions);
                let ret = AptosVMBlockExecutorWrapper::execute_block_on_thread_pool(
                    executor_thread_pool,
                    &txn_provider,
                    aggr_overridden_state_view.as_ref(),
                    // Since we execute blocks in parallel, we cannot share module caches, so each
                    // thread has its own caches.
                    &AptosModuleCacheManager::new(),
                    config,
                    TransactionSliceMetadata::unknown(),
                    cross_shard_commit_sender,
                )
                .map(BlockOutput::into_transaction_outputs_forced);
                if let Some(shard_id) = shard_id {
                    trace!(
                        "executed sub block for shard {} and round {}",
                        shard_id,
                        round
                    );
                    // Send a self message to stop the cross-shard commit receiver.
                    cross_shard_client_clone.send_cross_shard_msg(
                        shard_id,
                        round,
                        CrossShardMsg::StopMsg,
                    );
                } else {
                    trace!("executed block for global shard and round {}", round);
                    // Send a self message to stop the cross-shard commit receiver.
                    cross_shard_client_clone.send_global_msg(CrossShardMsg::StopMsg);
                }
                callback.send(ret).unwrap();
                executor_thread_pool_clone.spawn(move || {
                    // Explicit async drop
                    drop(txn_provider);
                });
            });
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L182-182)
```rust
        block_on(callback_receiver).unwrap()
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L77-82)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L335-337)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        self.message_rxs[current_round].recv().unwrap()
    }
```
