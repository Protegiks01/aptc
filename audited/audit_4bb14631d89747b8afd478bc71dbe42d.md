# Audit Report

## Title
Lack of Access Control in Indexer Processor Status Updates Enables Processor Impersonation and Denial of Service

## Summary
The Aptos indexer lacks authentication and authorization mechanisms in the processor status update system, allowing any process with database access to impersonate critical system processors by crafting malicious processor names. This enables denial-of-service attacks against off-chain indexing infrastructure and manipulation of health monitoring systems.

## Finding Description

The indexer system uses a shared PostgreSQL database where multiple processors track their progress via the `processor_status` table. Each processor is identified solely by a string name (max 50 characters) configured through the `PROCESSOR_NAME` environment variable or configuration file. [1](#0-0) 

The processor name is passed directly to the database update function without any validation or authentication: [2](#0-1) 

Multiple processor instances share the same database connection string, as confirmed in the processor management code: [3](#0-2) 

The processor configuration comes from environment variables with no authentication: [4](#0-3) 

Health monitoring systems directly query the processor_status table based solely on processor name: [5](#0-4) 

**Attack Scenario:**
1. Attacker gains access to the PostgreSQL database (through compromised credentials, network access, or starting a malicious indexer instance)
2. Attacker sets `PROCESSOR_NAME="token_v2_processor"` (or any critical processor)
3. Attacker's indexer repeatedly updates that processor's `last_success_version` to 0 or a very low value
4. Legitimate processor's progress is overwritten, causing it to reprocess millions of transactions or appear stuck
5. Health checks fail, triggering automated restarts and operational alerts
6. Indexer API becomes unavailable or degraded

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for the following reasons:

- **API crashes/degradation**: The indexer API relies on processor health, and manipulated status can cause service disruptions
- **Validator node slowdowns**: While not directly affecting consensus, the indexer is critical infrastructure that validators may depend on for monitoring and operations
- **Significant protocol violations**: Breaks the operational security model of the indexer infrastructure

The impact is limited to off-chain components and does not affect consensus, on-chain state, or funds. However, it can cause operational disruptions requiring manual intervention.

## Likelihood Explanation

**Likelihood: Medium to High** in environments where:
- Multiple teams/services share database access
- Compromised credentials provide database access
- Insider threats exist
- Insufficient network segmentation

**Prerequisites for exploitation:**
- PostgreSQL database credentials (or ability to start an indexer process with database access)
- Knowledge of target processor names
- Basic understanding of environment variable configuration

The attack is trivial to execute once prerequisites are met - simply changing an environment variable and starting an indexer process.

## Recommendation

Implement defense-in-depth through multiple mechanisms:

**1. Process-Level Authentication (Recommended)**
Add a unique secret token per processor instance that must be validated before status updates:

```rust
pub struct ProcessorStatusV2 {
    pub processor: String,
    pub last_success_version: i64,
    pub instance_token: String, // New field: secret token per instance
}

pub fn update_last_processed_version(
    &self, 
    processor_name: &str, 
    version: u64,
    instance_token: &str
) -> Result<()> {
    // Validate token matches processor's registered token
    let registered_token = get_processor_token(processor_name)?;
    if instance_token != registered_token {
        return Err(anyhow!("Invalid processor authentication token"));
    }
    // Proceed with update...
}
```

**2. Database-Level Access Controls**
- Create separate database users per processor with restricted permissions
- Use PostgreSQL row-level security policies to enforce processor isolation
- Implement triggers to prevent unauthorized updates

**3. Process Instance IDs**
Generate unique instance IDs on processor startup and validate that updates come from the current active instance:

```rust
pub struct ProcessorStatusV2 {
    pub processor: String,
    pub last_success_version: i64,
    pub instance_id: String, // UUID generated on startup
    pub instance_started_at: Timestamp,
}
```

**4. Audit Logging**
Add comprehensive audit trails for all processor_status updates to detect anomalous behavior.

## Proof of Concept

```bash
# Terminal 1: Start legitimate token_v2_processor
export PROCESSOR_NAME="token_v2_processor"
export INDEXER_DATABASE_URL="postgresql://user:pass@localhost/indexer"
./aptos-indexer

# Terminal 2: Start malicious impersonator
export PROCESSOR_NAME="token_v2_processor"  # Same name!
export INDEXER_DATABASE_URL="postgresql://user:pass@localhost/indexer"

# Create malicious indexer that repeatedly sets status to 0
cat > malicious_indexer.rs << 'EOF'
use aptos_indexer::database::new_db_pool;
use aptos_indexer::indexer::tailer::Tailer;

#[tokio::main]
async fn main() {
    let pool = new_db_pool("postgresql://user:pass@localhost/indexer").unwrap();
    let tailer = Tailer::new(/*...*/);
    
    // Repeatedly overwrite the legitimate processor's status
    loop {
        tailer.update_last_processed_version("token_v2_processor", 0).unwrap();
        tokio::time::sleep(Duration::from_secs(1)).await;
    }
}
EOF

# The legitimate processor will continuously fight with the malicious one,
# causing status thrashing, reprocessing, and health check failures
```

To verify the vulnerability:
1. Check `processor_status` table shows inconsistent/low versions for token_v2_processor
2. Health checker at line 94-126 of health_checker.rs will fail or show erratic behavior
3. Monitor logs show repeated reprocessing of old transactions
4. Indexer API may timeout or return stale data

## Notes

This vulnerability exists because the indexer design assumes a trusted environment where all processes with database access are cooperative. However, in production deployments with multiple teams, shared infrastructure, or compromised credentials, this assumption breaks down. The lack of any authentication layer makes exploitation trivial once database access is obtained.

### Citations

**File:** crates/indexer/src/models/processor_status.rs (L10-13)
```rust
pub struct ProcessorStatusV2 {
    pub processor: String,
    pub last_success_version: i64,
}
```

**File:** crates/indexer/src/indexer/tailer.rs (L170-191)
```rust
    pub fn update_last_processed_version(&self, processor_name: &str, version: u64) -> Result<()> {
        let mut conn = self.connection_pool.get()?;

        let status = ProcessorStatusV2 {
            processor: processor_name.to_owned(),
            last_success_version: version as i64,
        };
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
        Ok(())
    }
```

**File:** crates/aptos/src/node/local_testnet/processors.rs (L103-123)
```rust
    /// This function returns many new ProcessorManagers, one for each processor.
    pub fn many_new(
        args: &RunLocalnet,
        prerequisite_health_checkers: HashSet<HealthChecker>,
        data_service_url: Url,
        postgres_connection_string: String,
    ) -> Result<Vec<Self>> {
        if args.processor_args.processors.is_empty() {
            bail!("Must specify at least one processor to run");
        }
        let mut managers = Vec::new();
        for processor_name in &args.processor_args.processors {
            managers.push(Self::new(
                processor_name,
                prerequisite_health_checkers.clone(),
                data_service_url.clone(),
                postgres_connection_string.clone(),
            )?);
        }
        Ok(managers)
    }
```

**File:** config/src/config/indexer_config.rs (L147-155)
```rust
        // Verify and set the processor
        indexer_config.processor = env_var_or_default(
            PROCESSOR_NAME,
            indexer_config
                .processor
                .clone()
                .or_else(|| Some("default_processor".to_string())),
            None,
        );
```

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L94-126)
```rust
            HealthChecker::Processor(connection_string, processor_name) => {
                let mut connection = AsyncPgConnection::establish(connection_string)
                    .await
                    .context("Failed to connect to postgres to check processor status")?;
                let result = processor_status::table
                    .select((processor_status::last_success_version,))
                    .filter(processor_status::processor.eq(processor_name))
                    .first::<(i64,)>(&mut connection)
                    .await
                    .optional()
                    .context("Failed to look up processor status")?;
                match result {
                    Some(result) => {
                        // This is last_success_version.
                        if result.0 > 0 {
                            info!(
                                "Processor {} started processing successfully (currently at version {})",
                                processor_name, result.0
                            );
                            Ok(())
                        } else {
                            Err(anyhow!(
                                "Processor {} found in DB but last_success_version is zero",
                                processor_name
                            ))
                        }
                    },
                    None => Err(anyhow!(
                        "Processor {} has not processed any transactions",
                        processor_name
                    )),
                }
            },
```
