# Audit Report

## Title
Stack Overflow DoS via Deeply Nested Transaction Filters in Indexer-gRPC

## Summary
The `BooleanTransactionFilter::and()` function allows creation of arbitrarily nested filter structures without depth limits. While the filter size is bounded by a 10KB protobuf encoding limit, an attacker can craft a deeply nested filter (500-1000 levels) that fits within this limit but causes stack overflow during recursive operations, resulting in denial of service of the indexer-gRPC service.

## Finding Description

The `and()` function creates nested filter structures by wrapping the previous filter inside a new `LogicalAnd` variant: [1](#0-0) 

When chained repeatedly (e.g., `filter1.and(filter2).and(filter3)...`), this creates deeply nested structures where each level adds minimal bytes to the serialized size. The system validates filters using only a size check: [2](#0-1) 

The default maximum filter size is 10KB: [3](#0-2) 

However, there is **no depth limit** enforcement. The `matches()` and `validate_state()` operations recursively traverse the entire filter tree: [4](#0-3) 

Critically, the filter's `matches()` method is invoked for **every transaction** during stream processing: [5](#0-4) 

**Attack Path:**

1. Attacker crafts a protobuf filter with deep nesting: `And([And([And([...And([leaf])])])])` with ~500-1000 levels
2. Each nested level adds only ~10-20 bytes, keeping total size under 10KB
3. Filter is sent via gRPC `GetTransactionsRequest.transaction_filter`: [6](#0-5) 

4. Filter passes size validation but has extreme nesting depth
5. During transaction processing, `filter.matches(txn)` recursively traverses all levels
6. With sufficient depth, this exhausts the stack and panics the `spawn_blocking` task
7. Repeated attacks cause continuous service disruption

## Impact Explanation

This vulnerability enables **Denial of Service** of the indexer-gRPC service, which runs embedded within fullnode and validator processes. According to Aptos bug bounty criteria, this qualifies as:

- **High Severity**: "API crashes" - The indexer-gRPC API crashes when processing deeply nested filters
- **Medium Severity**: Service unavailability requiring manual intervention to restart

The impact is bounded to the indexer infrastructure and does not affect core consensus, but can disrupt:
- Transaction indexing for dApps and explorers
- Fullnode operations if indexer-gRPC is enabled
- Validator operations if validators run indexer-gRPC (less common but possible)

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" by allowing unbounded recursion depth.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - requires only crafting a nested protobuf message
- **Attacker Requirements**: None - any unauthenticated gRPC client can send filters
- **Detection**: Difficult - appears as legitimate filter until stack overflow occurs
- **Frequency**: Can be triggered repeatedly with minimal cost

The vulnerability is trivially exploitable by any client connecting to an indexer-gRPC endpoint.

## Recommendation

Implement a maximum recursion depth limit for transaction filters. Add depth tracking during filter construction and validation:

```rust
const MAX_FILTER_DEPTH: usize = 100;

impl BooleanTransactionFilter {
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        
        let filter = Self::from_proto_internal(proto_filter, 0)?;
        Ok(filter)
    }
    
    fn from_proto_internal(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        current_depth: usize,
    ) -> Result<Self> {
        ensure!(
            current_depth <= MAX_FILTER_DEPTH,
            format!("Filter nesting too deep. Max depth: {}, Current: {}", MAX_FILTER_DEPTH, current_depth)
        );
        
        // Continue with existing logic, passing current_depth + 1 to recursive calls
        // ...
    }
}
```

Additionally, implement depth checking in the recursive `Filterable` trait methods to provide defense in depth.

## Proof of Concept

```rust
#[cfg(test)]
mod stack_overflow_poc {
    use super::*;
    use aptos_transaction_filter::{BooleanTransactionFilter, filters::TransactionRootFilterBuilder};
    
    #[test]
    #[should_panic(expected = "stack overflow")]
    fn test_deeply_nested_filter_stack_overflow() {
        // Create a base filter
        let mut filter = BooleanTransactionFilter::from(
            TransactionRootFilterBuilder::default()
                .success(true)
                .build()
                .unwrap()
        );
        
        // Nest it 1000 times
        for _ in 0..1000 {
            filter = filter.and(TransactionRootFilterBuilder::default()
                .success(true)
                .build()
                .unwrap());
        }
        
        // Convert to protobuf - this should be under 10KB
        let proto = filter.into_proto();
        assert!(proto.encoded_len() < 10_000, "Filter exceeds size limit");
        
        // Try to validate - this will cause stack overflow
        let reconstructed = BooleanTransactionFilter::new_from_proto(proto, Some(10_000)).unwrap();
        
        // Create a dummy transaction
        let txn = create_test_transaction();
        
        // This matches() call will overflow the stack
        reconstructed.matches(&txn);
    }
}
```

**Notes:**

While the security question framed this as "unbounded memory growth," the actual vulnerability is **stack overflow from unbounded recursion depth**, not heap memory exhaustion. The 10KB size limit bounds total memory allocation, but does not prevent deeply nested structures that exhaust stack space during recursive traversal. This is a valid Medium-to-High severity DoS vulnerability affecting the indexer-gRPC infrastructure.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L98-106)
```rust
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L157-161)
```rust
    pub fn and<Other: Into<BooleanTransactionFilter>>(self, other: Other) -> Self {
        BooleanTransactionFilter::And(LogicalAnd {
            and: vec![self, other.into()],
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L287-297)
```rust
impl Filterable<Transaction> for LogicalAnd {
    fn validate_state(&self) -> Result<(), FilterError> {
        for filter in &self.and {
            filter.is_valid()?;
        }
        Ok(())
    }

    fn matches(&self, item: &Transaction) -> bool {
        self.and.iter().all(|filter| filter.matches(item))
    }
```

**File:** config/src/config/indexer_grpc_config.rs (L21-21)
```rust
const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-179)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L64-71)
```rust
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```
