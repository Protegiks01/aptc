# Audit Report

## Title
Spec Function Index Desynchronization in Schema Blocks Causes Wrong Body Assignments

## Summary
The `spec_fun_index` counter in `ModuleBuilder` becomes desynchronized from the `spec_funs` vector when spec functions are declared within schema blocks, causing spec function bodies to be assigned to incorrect declarations.

## Finding Description

The vulnerability arises from a mismatch in how spec functions are processed between the declaration and definition analysis phases in the Move model builder.

**Declaration Phase (decl_ana):**
All spec blocks, including schemas, have their members processed. [1](#0-0) 

When a spec function is encountered in ANY spec block (including schemas), it is added to the `spec_funs` vector: [2](#0-1) 

**Definition Phase (def_ana):**
Schema spec blocks are explicitly skipped during the main spec block iteration: [3](#0-2) 

Schemas are processed separately via `def_ana_schema`, which rejects spec functions with an error but does NOT call `def_ana_spec_fun`: [4](#0-3) 

Non-schema spec blocks call `def_ana_spec_fun`, which uses `spec_fun_index` to access and update entries: [5](#0-4) 

**The Synchronization Break:**
The `spec_fun_index` field is defined to track the current position during definition analysis: [6](#0-5) 

However, it is only incremented when `def_ana_spec_fun` is called (line 2517), which never happens for spec functions in schemas. This causes:
1. Spec functions in schemas are added to `spec_funs` but never processed with `def_ana_spec_fun`
2. Subsequent non-schema spec functions access wrong indices in the `spec_funs` vector
3. Bodies of spec functions get assigned to incorrect declarations

**Attack Scenario:**
```move
module 0x1::Example {
    spec schema S {
        fun helper1(): bool { true }  // Index 0 in spec_funs, rejected in def_ana
    }
    
    spec module {
        fun helper2(): bool { false }  // Index 1 in spec_funs, processed at index 0
    }
}
```

Result: `helper2`'s body is incorrectly assigned to `helper1`'s declaration, and `helper2` never receives its body.

## Impact Explanation

This is a **Medium severity** issue affecting the Move Prover's formal verification system:

1. **Incorrect Verification Results**: Spec functions with swapped bodies cause the prover to verify incorrect properties, potentially allowing vulnerable smart contracts to pass verification
2. **False Security Guarantees**: Developers relying on formal verification may have a false sense of security if proofs pass but check the wrong specifications
3. **Undetected Contract Vulnerabilities**: Critical security properties may go unverified if the spec function handling the verification has the wrong body

While this doesn't directly affect runtime consensus or funds transfer, it undermines the security guarantees of formally verified Move contracts deployed on Aptos, which could indirectly lead to exploitable vulnerabilities in production contracts.

## Likelihood Explanation

**Likelihood: Medium**

The parser accepts spec functions in schema blocks without restriction, as seen in the parsing logic: [7](#0-6) 

While an error is eventually reported during definition analysis, the index desynchronization has already occurred, affecting subsequent spec function processing. Developers unfamiliar with schema restrictions might inadvertently include spec functions in schemas during specification development.

## Recommendation

Add validation during declaration analysis to reject spec functions in schemas before they are added to `spec_funs`:

```rust
fn decl_ana_spec_block(&mut self, block: &EA::SpecBlock) {
    // Check if this is a schema block
    let is_schema = matches!(
        block.value.target.value, 
        EA::SpecBlockTarget_::Schema(..)
    );
    
    for member in &block.value.members {
        // Reject spec functions in schemas during declaration
        if is_schema && matches!(
            member.value,
            EA::SpecBlockMember_::Function { .. }
        ) {
            let loc = self.parent.env.to_loc(&member.loc);
            self.parent.error(&loc, "spec functions not allowed in schema blocks");
            continue; // Skip adding to spec_funs
        }
        self.decl_ana_spec_block_member(member)
    }
    
    if let EA::SpecBlockTarget_::Schema(name, type_params) = &block.value.target.value {
        self.decl_ana_schema(block, name, type_params.iter().map(|(n, a)| (n, a)));
    }
}
```

This prevents the desynchronization by ensuring spec functions in schemas are never added to `spec_funs`, maintaining the invariant that `spec_fun_index` always corresponds to the correct entry.

## Proof of Concept

Create a Move module `test_spec_sync.move`:

```move
module 0x1::TestSpecSync {
    spec schema TestSchema {
        // This will be added to spec_funs at index 0 during decl_ana
        // but skipped during def_ana
        fun schema_helper(): bool { true }
    }
    
    spec module {
        // This will be added to spec_funs at index 1 during decl_ana
        // but processed at index 0 during def_ana (WRONG!)
        fun module_helper(): bool { false }
    }
}
```

Compile with the Move Prover enabled. The result will be:
1. Error reported: "item not allowed in schema" for `schema_helper`
2. `schema_helper` declaration receives the body `{ false }` from `module_helper`
3. `module_helper` declaration never receives its body
4. If the prover continues processing, it will verify the wrong specification

This demonstrates the index desynchronization vulnerability where `spec_fun_index` gets out of sync with the `spec_funs` vector, causing wrong spec function body assignments.

### Citations

**File:** third_party/move/move-model/src/builder/module_builder.rs (L80-83)
```rust
    pub spec_funs: Vec<SpecFunDecl>,
    /// During the definition analysis, the index into `spec_funs` we are currently
    /// handling
    pub spec_fun_index: usize,
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L736-744)
```rust
    fn decl_ana_spec_block(&mut self, block: &EA::SpecBlock) {
        for member in &block.value.members {
            self.decl_ana_spec_block_member(member)
        }
        // If this is a schema spec block, process its declaration.
        if let EA::SpecBlockTarget_::Schema(name, type_params) = &block.value.target.value {
            self.decl_ana_schema(block, name, type_params.iter().map(|(n, a)| (n, a)));
        }
    }
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L773-824)
```rust
    fn decl_ana_spec_fun(
        &mut self,
        loc: &Loc,
        uninterpreted: bool,
        name: &PA::FunctionName,
        signature: &EA::FunctionSignature,
    ) {
        let name = self.symbol_pool().make(&name.0.value);
        let (type_params, params, result_type) = self.decl_ana_signature(signature, false);
        // Eliminate references in parameters and result type for spec functions
        // `derive_spec_fun` does the same when generating spec functions from general move functions
        let params = params
            .into_iter()
            .map(|Parameter(sym, ty, loc)| Parameter(sym, ty.skip_reference().clone(), loc))
            .collect_vec();
        let result_type = result_type.skip_reference().clone();

        // Add the function to the symbol table.
        let fun_id = SpecFunId::new(self.spec_funs.len());
        self.parent.define_spec_or_builtin_fun(
            self.qualified_by_module(name),
            SpecOrBuiltinFunEntry {
                loc: loc.clone(),
                oper: Operation::SpecFunction(self.module_id, fun_id, None),
                type_params: type_params.clone(),
                type_param_constraints: BTreeMap::default(),
                params: params.clone(),
                result_type: result_type.clone(),
                visibility: EntryVisibility::Spec,
            },
        );

        // Add a prototype of the SpecFunDecl to the module build. This
        // will for now have an empty body which we fill in during a 2nd pass.
        let fun_decl = SpecFunDecl {
            loc: loc.clone(),
            name,
            type_params,
            params,
            context_params: None,
            result_type,
            used_memory: BTreeSet::new(),
            uninterpreted,
            is_move_fun: false,
            is_native: false,
            body: None,
            callees: Default::default(),
            is_recursive: Default::default(),
            insts_using_generic_type_reflection: Default::default(),
            spec: RefCell::new(Default::default()),
        };
        self.spec_funs.push(fun_decl);
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L1117-1121)
```rust
        // Analyze all module level spec blocks (except schemas)
        for spec in &module_def.specs {
            if matches!(spec.value.target.value, EA::SpecBlockTarget_::Schema(..)) {
                continue;
            }
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L2489-2517)
```rust
                let entry = &self.spec_funs[self.spec_fun_index];
                let type_params = entry.type_params.clone();
                let params = entry.params.clone();
                let result_type = entry.result_type.clone();
                let mut et = ExpTranslator::new(self);
                let loc = et.to_loc(&body.loc);
                et.define_type_params(&loc, &type_params, false);
                et.enter_scope();
                for Parameter(n, ty, loc) in params {
                    et.define_local(&loc, n, ty, None, None);
                }
                let translated =
                    et.translate_seq(&loc, seq, &result_type, &ErrorMessageContext::Return);
                // Run type inference finalization so post processing has all available type information,
                // but do not report errors yet because receiver functions can add more type bindings.
                // TODO: refactor `finalize_types` to run it only once.
                et.finalize_types(false);
                let translated = et.post_process_body(translated.into_exp());
                // Run finalization again, this time with reporting errors.
                et.finalize_types(true);
                self.spec_funs[self.spec_fun_index].body = Some(translated);
            },
            EA::FunctionBody_::Native => {
                if !uninterpreted {
                    self.spec_funs[self.spec_fun_index].is_native = true
                }
            },
        }
        self.spec_fun_index += 1;
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L2763-2765)
```rust
                _ => {
                    self.parent.error(&member_loc, "item not allowed in schema");
                },
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs (L4008-4035)
```rust
fn parse_spec_block_member(context: &mut Context) -> Result<SpecBlockMember, Box<Diagnostic>> {
    context.tokens.match_doc_comments();
    match context.tokens.peek() {
        Tok::Invariant => parse_invariant(context),
        Tok::Let => parse_spec_let(context),
        Tok::Fun | Tok::Native => parse_spec_function(context),
        Tok::Identifier => match context.tokens.content() {
            "assert" | "assume" | "decreases" | "aborts_if" | "aborts_with" | "succeeds_if"
            | "modifies" | "emits" | "ensures" | "requires" => parse_condition(context),
            "axiom" => parse_axiom(context),
            "include" => parse_spec_include(context),
            "apply" => parse_spec_apply(context),
            "pragma" => parse_spec_pragma(context),
            "global" | "local" => parse_spec_variable(context),
            "update" => parse_spec_update(context),
            _ => {
                // local is optional but supported to be able to declare variables which are
                // named like the weak keywords above
                parse_spec_variable(context)
            },
        },
        _ => Err(unexpected_token_error(
            context.tokens,
            "one of `assert`, `assume`, `decreases`, `aborts_if`, `aborts_with`, `succeeds_if`, \
             `modifies`, `emits`, `ensures`, `requires`, `include`, `apply`, `pragma`, `global`, \
             or a name",
        )),
    }
```
