# Audit Report

## Title
Storage Service Error Classification Bypass Allows Unpunished Peer Misbehavior via Out-of-Bounds State Value Requests

## Summary
The storage service's request validation only checks if the requested version is available but does not validate the `start_index` and `end_index` parameters in `GetStateValuesWithProof` requests. Malicious peers can send requests with out-of-bounds indices that pass validation but cause storage errors during processing. These errors are classified as `StorageErrorEncountered` instead of `InvalidRequest`, bypassing the peer reputation system that tracks and penalizes misbehaving peers. This allows indefinite attacks without the peer being ignored.

## Finding Description

The storage service implements a peer reputation system to protect nodes from misbehaving peers. The `RequestModerator` tracks invalid requests per peer and temporarily ignores peers that exceed a threshold on public networks. [1](#0-0) 

However, the invalid request counter is **only** incremented during the validation phase when `can_service` returns false. The validation for `GetStateValuesWithProof` requests only checks if the version is within the available states range: [2](#0-1) 

The validation does **not** check whether `start_index` and `end_index` are within bounds for the given version. When processing proceeds, if the `start_index` exceeds the total number of state values at that version, the Jellyfish Merkle iterator detects this and returns an empty iterator: [3](#0-2) 

The empty iterator causes `get_state_value_chunk_proof` to be called with an empty `state_key_values` vector, which fails the assertion: [4](#0-3) 

This `AptosDbError` is automatically converted to `Error::StorageErrorEncountered`: [5](#0-4) 

Since this error occurs **after** validation passes, the moderator's invalid request counter is never incremented. The peer can repeat this attack indefinitely without being penalized or ignored.

**Attack Steps:**
1. Malicious peer queries storage server summary to get valid version range
2. Peer sends `GetStateValuesWithProof` request with:
   - `version`: valid version within states range (e.g., 1000)
   - `start_index`: very large number (e.g., `u64::MAX - 100`)
   - `end_index`: `u64::MAX - 100` or higher
3. Request passes validation (only version is checked)
4. Processing creates empty iterator (start_index exceeds leaf count)
5. Storage error occurs when proof creation receives empty values
6. Error is classified as `StorageErrorEncountered`, not `InvalidRequest`
7. Peer's invalid request count is NOT incremented
8. Peer repeats attack without consequences

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program:

- **"Validator node slowdowns"**: Repeated malicious requests cause storage errors, excessive logging, and unnecessary database operations, degrading node performance
- **"Significant protocol violations"**: The peer reputation system is a critical defense mechanism. Bypassing it undermines the protocol's ability to protect nodes from malicious peers

The attack enables:
- **Denial of Service**: Continuous storage error generation and log spam
- **Resource Exhaustion**: Unnecessary database queries and iterator creation
- **Reputation System Bypass**: Complete circumvention of the invalid request tracking designed to protect public network nodes
- **Persistent Attack Vector**: Since PFN peers are never penalized, attacks can continue indefinitely without the attacker being blocked

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

- **Low Attack Complexity**: Requires only crafting a single malformed network request with out-of-bounds indices
- **No Special Privileges Required**: Any peer on the public network can execute this attack
- **Easy Discovery**: The lack of index validation is easily discoverable through code review or fuzzing
- **High Attacker Motivation**: DoS attacks against blockchain nodes are common, and bypassing reputation systems provides persistent attack capability
- **Production Impact**: All Aptos nodes running the storage service are affected

The attack is practical, repeatable, and requires minimal resources from the attacker.

## Recommendation

Implement index validation in the `can_service` method for `GetStateValuesWithProof` requests. Before allowing the request to proceed, verify that the indices are within the valid range for the given version.

**Option 1: Validate indices in `can_service`**

Add a method to check index bounds in `StorageServerSummary`:

```rust
fn can_service_state_values_indices(&self, version: u64, start_index: u64, end_index: u64) -> bool {
    // First check if we have the version
    if !self.states.map(|range| range.contains(version)).unwrap_or(false) {
        return false;
    }
    
    // Validate indices are in proper order
    if end_index < start_index {
        return false;
    }
    
    // Optionally: Add an upper bound check based on expected state size
    // This would require tracking or estimating the number of states per version
    
    true
}
```

Update the `can_service` match arm for `GetStateValuesWithProof`:

```rust
GetStateValuesWithProof(request) => {
    self.can_service_state_values_indices(request.version, request.start_index, request.end_index) &&
    self.can_create_proof(request.version)
}
```

**Option 2: Early validation with inclusive_range_len**

Move the `inclusive_range_len` check from processing into validation by adding it to the moderator's request validation or the `can_service` logic. Additionally, the validation should verify that the `start_index` is reasonable (not excessively large).

**Option 3: Increment invalid request count for processing errors**

Track errors that occur during processing (not just validation) and increment the invalid request counter for errors that indicate peer misbehavior. However, this is more complex as it requires distinguishing between peer misbehavior and legitimate storage issues.

**Recommended Approach**: Implement Option 1 as it provides defense-in-depth and catches malicious requests before they consume resources.

## Proof of Concept

```rust
#[cfg(test)]
mod test_index_bypass {
    use super::*;
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::{DataRequest, StateValuesWithProofRequest};
    use aptos_types::{PeerId, network_id::NetworkId};
    
    #[test]
    fn test_out_of_bounds_indices_bypass_reputation() {
        // Setup storage service with moderator
        let config = StorageServiceConfig::default();
        let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        
        // Create a request with valid version but invalid indices
        let request = StorageServiceRequest::new(
            DataRequest::GetStateValuesWithProof(StateValuesWithProofRequest {
                version: 1000,  // Valid version within states range
                start_index: u64::MAX - 100,  // Out of bounds
                end_index: u64::MAX - 100,
            }),
            false,
        );
        
        // Initial invalid request count should be 0
        let unhealthy_states = request_moderator.get_unhealthy_peer_states();
        assert_eq!(
            unhealthy_states.get(&peer_network_id).map(|s| s.invalid_request_count).unwrap_or(0),
            0
        );
        
        // Send the malicious request
        let response = handler.process_request(&peer_network_id, request.clone(), false);
        
        // Verify it returns a storage error
        assert!(matches!(
            response,
            Err(StorageServiceError::InternalError(_))
        ));
        
        // VULNERABILITY: Invalid request count is still 0
        // The peer is NOT penalized despite sending a malicious request
        let invalid_count = unhealthy_states
            .get(&peer_network_id)
            .map(|s| s.invalid_request_count)
            .unwrap_or(0);
        assert_eq!(invalid_count, 0);  // This demonstrates the bypass
        
        // Peer can repeat the attack indefinitely without being ignored
        for _ in 0..100 {
            let _ = handler.process_request(&peer_network_id, request.clone(), false);
        }
        
        // Peer is still not ignored
        let peer_state = unhealthy_states.get(&peer_network_id);
        assert!(peer_state.is_none() || !peer_state.unwrap().is_ignored());
    }
}
```

## Notes

This vulnerability demonstrates a critical gap between validation and enforcement in the peer reputation system. While the system correctly identifies and penalizes peers that send obviously invalid requests (wrong version ranges), it fails to catch sophisticated attacks that exploit incomplete parameter validation. The fix requires strengthening the `can_service` validation to check all request parameters, not just high-level availability constraints.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L160-178)
```rust
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);
```

**File:** state-sync/storage-service/types/src/responses.rs (L727-742)
```rust
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
```

**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L212-220)
```rust
        if start_idx >= current_node.leaf_count() {
            return Ok(Self {
                reader,
                version,
                parent_stack,
                done: true,
                phantom_value: PhantomData,
            });
        }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1123-1127)
```rust
        ensure!(
            !state_key_values.is_empty(),
            "State chunk starting at {}",
            first_index,
        );
```

**File:** state-sync/storage-service/server/src/error.rs (L43-46)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
```
