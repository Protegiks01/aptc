# Audit Report

## Title
Unbounded Event Type String Conversion in Indexer Enables Database Bloat Attack

## Summary
The indexer's `Event::from_event()` function converts Move event type tags to strings without any length limits or truncation before storing them in the database's `Text` column. While on-chain protections limit identifier lengths (255 bytes) and type complexity (128/256 type nodes), an attacker can still craft events with types that produce strings several kilobytes long, causing indexer database bloat and potential service degradation.

## Finding Description

The vulnerability exists in the event processing pipeline where blockchain events are indexed for off-chain querying.

**The Attack Path:**

1. **Event Type Conversion**: When the indexer processes blockchain events, it converts the Move type tag to a string representation [1](#0-0) 

2. **No Truncation Applied**: Unlike other similar fields (e.g., `coin_type` which uses `truncate_str` with a 5000-character limit [2](#0-1) ), the event `type_` field has no truncation

3. **Unbounded Database Column**: The database schema defines the `type_` column as `Text` (unbounded) [3](#0-2) 

4. **Recursive String Formatting**: The `Display` implementation for `MoveType` recursively formats nested generic types [4](#0-3)  and delegates to `MoveStructTag::Display` which formats type parameters recursively [5](#0-4) 

**Attack Scenario:**

An attacker can publish a Move module with maximum-length identifiers (255 bytes each, within the production limit [6](#0-5) ) and create structs with deeply nested generic types (within the `MAX_RECURSIVE_TYPES_ALLOWED` limit of 8 [7](#0-6) ).

While the production verifier limits type complexity to 128 or 256 type nodes [8](#0-7) , the string representation can still reach several kilobytes per event. By emitting many such events across multiple transactions, an attacker can cause significant database bloat.

**Gap in Protections:**

Gas metering charges based on the BCS-serialized size of the type tag [9](#0-8) , but the string representation used by the indexer can be proportionally larger due to formatting overhead (addresses as hex strings, separators, etc.).

## Impact Explanation

This vulnerability represents a **Medium Severity** issue under the Aptos bug bounty program:

- **State inconsistencies requiring intervention**: The indexer database will experience uncontrolled growth, requiring manual cleanup or increased storage capacity
- **API service degradation**: As the primary off-chain data source, indexer performance degradation affects all downstream APIs and services that depend on blockchain data
- **Resource exhaustion**: While not causing validator node issues, the indexer is critical infrastructure for ecosystem applications

The attack does not:
- Affect on-chain consensus or validator nodes directly
- Cause fund loss or theft
- Break consensus safety guarantees

However, it creates a practical DoS vector against off-chain infrastructure that is essential for the blockchain's usability.

## Likelihood Explanation

**High Likelihood** - The attack requires only:
1. Publishing a Move module with long identifiers (standard module publishing process)
2. Emitting events from the module (no special privileges required)
3. Paying transaction gas fees (moderate cost, proportional to event count)

The feature flag `LIMIT_MAX_IDENTIFIER_LENGTH` is enabled in production [10](#0-9) , limiting identifiers to 255 bytes rather than the legacy 65535-byte limit, but this still allows for significant string length multiplication through nesting.

## Recommendation

Implement consistent truncation for event type strings similar to other indexer fields:

```rust
// In crates/indexer/src/models/events.rs
pub const EVENT_TYPE_MAX_LENGTH: usize = 5000;

impl Event {
    pub fn from_event(
        event: &APIEvent,
        transaction_version: i64,
        transaction_block_height: i64,
        event_index: i64,
    ) -> Self {
        Event {
            account_address: standardize_address(&event.guid.account_address.to_string()),
            creation_number: event.guid.creation_number.0 as i64,
            sequence_number: event.sequence_number.0 as i64,
            transaction_version,
            transaction_block_height,
            type_: truncate_str(&event.typ.to_string(), EVENT_TYPE_MAX_LENGTH),  // Add truncation
            data: event.data.clone(),
            event_index: Some(event_index),
        }
    }
}
```

Additionally, consider adding a database migration to change the column type from `Text` to `VARCHAR(5000)` to enforce the limit at the database level.

## Proof of Concept

```move
module attacker::dos_event {
    use std::event;
    
    struct LongName_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<T1, T2, T3> has copy, drop, store {}
    
    struct NestedType<T1, T2, T3> has copy, drop, store {}
    
    struct AttackEvent has copy, drop, store {
        data: NestedType<
            LongName_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<u64, u128, u256>,
            LongName_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<u64, u128, u256>,
            LongName_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<u64, u128, u256>
        >
    }
    
    public entry fun emit_attack_events() {
        let i = 0;
        while (i < 100) {
            event::emit(AttackEvent { 
                data: NestedType {} 
            });
            i = i + 1;
        };
    }
}
```

When executed, this module emits 100 events per transaction, each with a type string exceeding 1KB. An attacker submitting multiple such transactions can cause significant indexer database bloat. The indexer will attempt to store each type string without truncation, leading to performance degradation over time.

**Notes:**
- The actual identifier length in the PoC is limited to 255 bytes to comply with production limits
- Multiple transactions can amplify the effect
- The indexer will continue to process these events without rejecting them or truncating the type strings

### Citations

**File:** crates/indexer/src/models/events.rs (L55-55)
```rust
            type_: event.typ.to_string(),
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L174-174)
```rust
        truncate_str(&self.coin_type, COIN_TYPE_HASH_LENGTH)
```

**File:** crates/indexer/src/schema.rs (L517-517)
```rust
        type_ -> Text,
```

**File:** api/types/src/move_types.rs (L586-593)
```rust
        write!(f, "{}::{}::{}", self.address, self.module, self.name)?;
        if let Some(first_ty) = self.generic_type_params.first() {
            write!(f, "<")?;
            write!(f, "{}", first_ty)?;
            for ty in self.generic_type_params.iter().skip(1) {
                write!(f, ", {}", ty)?;
            }
            write!(f, ">")?;
```

**File:** api/types/src/move_types.rs (L688-688)
```rust
pub const MAX_RECURSIVE_TYPES_ALLOWED: u8 = 8;
```

**File:** api/types/src/move_types.rs (L777-778)
```rust
            MoveType::Vector { items } => write!(f, "vector<{}>", items),
            MoveType::Struct(s) => write!(f, "{}", s),
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L67-67)
```rust
pub const IDENTIFIER_SIZE_MAX: u64 = 255;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-165)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
```

**File:** types/src/contract_event.rs (L269-269)
```rust
        let size = bcs::serialized_size(&self.type_tag)? + self.event_data.len();
```

**File:** types/src/on_chain_config/aptos_features.rs (L479-479)
```rust
            IDENTIFIER_SIZE_MAX
```
