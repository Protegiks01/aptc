# Audit Report

## Title
Hardcoded Testnet Seed Peer Public Keys Create Extended Exposure Window for Bootstrap Attacks

## Summary
The 4 testnet seed peer public keys are hardcoded as compile-time constants in the codebase, requiring source code modification, recompilation, and coordinated deployment to rotate. This architectural limitation creates an extended window (potentially weeks to months) during which a compromised seed peer key remains trusted by newly bootstrapping nodes, enabling man-in-the-middle and eclipse attacks against the testnet network.

## Finding Description

The testnet seed peers are defined as hardcoded constants in the config optimizer: [1](#0-0) 

These seed peers are automatically injected into public fullnode configurations when no user-provided seeds are specified: [2](#0-1) 

When a fullnode connects to a seed peer, it performs Noise IK handshake authentication using the public key embedded in the network address. The client authenticates the server by including the expected public key in the handshake prologue: [3](#0-2) 

If an attacker compromises one of the 4 seed peer private keys, they can impersonate that seed peer because they possess the corresponding private key. The authentication will succeed since the attacker can complete the Noise IK handshake correctly.

**Attack Sequence:**
1. Attacker compromises a seed peer's private key (through server breach, leaked credentials, etc.)
2. Discovery happens, Aptos team becomes aware of the compromise
3. To rotate the key, developers must:
   - Modify the hardcoded constant in source code
   - Commit, review, and merge the change
   - Release a new node version
   - Wait for node operators to upgrade (weeks to months)
4. During this extended window, the attacker can:
   - Set up a server with the compromised private key at a different location
   - Impersonate the legitimate seed peer to new nodes bootstrapping
   - Feed malicious peer lists through discovery mechanisms
   - Eclipse attack: isolate bootstrapping nodes by surrounding them with attacker-controlled peers
   - Prevent nodes from discovering legitimate network participants

The code shows that while users CAN override seeds in their local config, the optimizer only applies defaults when seeds are not explicitly configured: [4](#0-3) 

Most users rely on defaults and won't know to override seeds manually in response to a compromise.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program for multiple reasons:

1. **Network Availability Impact**: Newly bootstrapping fullnodes (including VFNs) can be eclipsed and isolated from the honest network, affecting network availability and partition resilience.

2. **Significant Protocol Violation**: Nodes connecting to attacker-controlled peers violates the network's trust assumptions and can lead to nodes receiving incorrect chain state, invalid transactions, or being prevented from syncing to the correct chain tip.

3. **Extended Exposure Window**: The requirement for code changes, release cycles, and coordinated upgrades creates a multi-week to multi-month window where the compromised key remains trusted, significantly amplifying the attack surface.

4. **Affects Network Bootstrap**: While not directly affecting consensus safety (since seed peers are not validators), compromising the bootstrap process can prevent new nodes and recovering nodes from joining the network correctly.

The impact maps to "Significant protocol violations" and could contribute to "Validator node slowdowns" if VFNs are affected, both of which are High Severity categories.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Key Compromise Prerequisite**: While the exploit requires initial key compromise, seed peer infrastructure represents a realistic attack target (servers exposed to the internet, operational security challenges, supply chain risks).

2. **Long-Lived Keys**: The hardcoded nature means these keys are long-lived and unchanging, increasing the window for potential compromise.

3. **Limited Key Set**: Only 4 testnet seed peers exist, so compromising even one represents a 25% impact on bootstrap infrastructure.

4. **Testnet Environment**: Testnet infrastructure may have weaker security controls than mainnet, making key compromise more likely.

5. **No Early Warning System**: No mechanism exists to quickly warn users that a seed peer key has been compromised, so users continue trusting it until they manually upgrade.

## Recommendation

Implement a runtime seed peer rotation mechanism that doesn't require code changes:

**Solution 1: On-Chain Seed Registry (Preferred)**
Create a Move module that maintains an on-chain registry of trusted seed peers for each network (testnet, mainnet). Allow authorized entities to update this registry, and have nodes query it at startup or periodically refresh.

**Solution 2: DNS-Based Bootstrap**
Use DNS TXT records or DNSSEC-signed records to publish current seed peer information, allowing rapid rotation without code changes.

**Solution 3: Configuration File Discovery**
Implement a well-known HTTPS endpoint (e.g., `https://config.aptoslabs.com/testnet/seeds.yaml`) that nodes can query for current seed peers. Use certificate pinning or signed configurations to prevent MITM.

**Solution 4: Multi-Layered Bootstrap**
Combine hardcoded seeds with dynamic discovery methods as fallback: [5](#0-4) 

Modify the config optimizer to automatically enable File or Rest discovery methods for testnet/mainnet in addition to static seeds, providing redundancy.

**Immediate Mitigation:**
Until architectural changes are implemented, document and prominently communicate to node operators:
- How to override default seeds in their config files
- Monitoring channels for seed peer security announcements
- Best practices for verifying seed peer authenticity

## Proof of Concept

**Demonstrating the Issue:**

1. **Verify hardcoded seeds cannot be changed at runtime:**

```rust
// In config/src/config/config_optimizer.rs
// Attempt to modify TESTNET_SEED_PEERS at runtime will fail:
// const TESTNET_SEED_PEERS cannot be mutated

// The only way to change these values is to:
// 1. Edit the source file
// 2. Recompile: cargo build --release
// 3. Deploy new binary to all nodes
// 4. Wait for adoption
```

2. **Verify seeds are automatically applied:**

```rust
// Test showing automatic seed application
#[test]
fn test_hardcoded_seeds_applied_without_override() {
    let mut node_config = NodeConfig {
        storage: setup_storage_config_with_temp_dir().0,
        full_node_networks: vec![NetworkConfig {
            network_id: NetworkId::Public,
            seeds: HashMap::new(),  // Empty - no user override
            ..Default::default()
        }],
        ..Default::default()
    };
    
    // Optimize with empty local config (no user seeds)
    let modified = optimize_public_network_config(
        &mut node_config,
        &serde_yaml::from_str("{}").unwrap(),
        NodeType::PublicFullnode,
        Some(ChainId::testnet()),
    ).unwrap();
    
    assert!(modified);
    // Hardcoded seeds are now in the config
    assert_eq!(node_config.full_node_networks[0].seeds.len(), 4);
}
```

3. **Simulate compromise scenario:**

```bash
# If seed0.testnet.aptoslabs.com key is compromised:
# 1. Attacker sets up impersonation server with compromised private key
# 2. New nodes starting with default config connect to attacker
# 3. Attacker passes authentication (has valid private key)
# 4. Attacker feeds malicious peer list to bootstrapping nodes
# 5. Nodes become eclipsed

# To fix, requires:
# - Modify TESTNET_SEED_PEERS constant
# - Release new aptos-node version
# - Node operators must upgrade (weeks/months)
# - During this time, compromised key remains in old versions
```

**Notes:**

This vulnerability represents an architectural security limitation rather than a code logic bug. The code functions as designed, but the design itself creates a security risk by coupling seed peer key rotation to the software release cycle. This violates the security principle of separation between operational key management and code deployment, creating an unnecessarily long exposure window for key compromise scenarios. While users can manually override seeds, this requires awareness and action, making it an insufficient mitigation for the broader network.

### Citations

**File:** config/src/config/config_optimizer.rs (L40-61)
```rust
const TESTNET_SEED_PEERS: [(&str, &str, &str); 4] = [
    (
        "31e55012a7d439dcd16fee0509cd5855c1fbdc62057ba7fac3f7c88f5453dd8e",
        "0x87bb19b02580b7e2a91a8e9342ec77ffd8f3ad967f54e77b22aaf558c5c11755",
        "/dns/seed0.testnet.aptoslabs.com/tcp/6182/noise-ik/0x87bb19b02580b7e2a91a8e9342ec77ffd8f3ad967f54e77b22aaf558c5c11755/handshake/0",
    ),
    (
        "116176e2af223a8b7f8db80dc52f7a423b4d7f8c0553a1747e92ef58849aff4f",
        "0xc2f24389f31c9c18d2ceb69d153ad9299e0ea7bbd66f457e0a28ef41c77c2b64",
        "/dns/seed1.testnet.aptoslabs.com/tcp/6182/noise-ik/0xc2f24389f31c9c18d2ceb69d153ad9299e0ea7bbd66f457e0a28ef41c77c2b64/handshake/0",
    ),
    (
        "12000330d7cd8a748f46c25e6ce5d236a27e13d0b510d4516ac84ecc5fddd002",
        "0x171c661e5b785283978a74eafc52a906e68c73ae78119737b92f93507c753933",
        "/dns/seed2.testnet.aptoslabs.com/tcp/6182/noise-ik/0x171c661e5b785283978a74eafc52a906e68c73ae78119737b92f93507c753933/handshake/0",
    ),
    (
        "03c04549114877c55f45649aba48ac0a4ff086ab7bdce3b8cc8d3d9947bc0d99",
        "0xafc38bf177bd825326a1c314748612137d2b35dae6472932806806a32c23174a",
        "/dns/seed3.testnet.aptoslabs.com/tcp/6182/noise-ik/0xafc38bf177bd825326a1c314748612137d2b35dae6472932806806a32c23174a/handshake/0",
    ),
];
```

**File:** config/src/config/config_optimizer.rs (L203-214)
```rust
            if local_network_config_yaml["seeds"].is_null() {
                if let Some(chain_id) = chain_id {
                    if chain_id.is_testnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(TESTNET_SEED_PEERS.into())?;
                        modified_config = true;
                    } else if chain_id.is_mainnet() {
                        fullnode_network_config.seeds =
                            create_seed_peers(MAINNET_SEED_PEERS.into())?;
                        modified_config = true;
                    }
                }
```

**File:** network/framework/src/noise/handshake.rs (L197-218)
```rust
        // craft prologue = self_peer_id | expected_public_key
        client_message[..PeerId::LENGTH].copy_from_slice(self.network_context.peer_id().as_ref());
        client_message[PeerId::LENGTH..Self::PROLOGUE_SIZE]
            .copy_from_slice(remote_public_key.as_slice());

        let (prologue_msg, client_noise_msg) = client_message.split_at_mut(Self::PROLOGUE_SIZE);

        // craft 8-byte payload as current timestamp (in milliseconds)
        let payload = time_provider();

        // craft first handshake message  (-> e, es, s, ss)
        let mut rng = rand::rngs::OsRng;
        let initiator_state = self
            .noise_config
            .initiate_connection(
                &mut rng,
                prologue_msg,
                remote_public_key,
                Some(&payload),
                client_noise_msg,
            )
            .map_err(NoiseHandshakeError::BuildClientHandshakeMessageFailed)?;
```

**File:** config/src/config/network_config.rs (L345-350)
```rust
pub enum DiscoveryMethod {
    Onchain,
    File(FileDiscovery),
    Rest(RestDiscovery),
    None,
}
```
