# Audit Report

## Title
Fullnode Network Identity Persistence Vulnerability - PeerId Evasion of Network-Level Tracking

## Summary
The `aptos_node_identity::init()` function accepts any PeerId without validating it against persistent storage or previous state, allowing fullnodes to evade network-level ban/tracking mechanisms by changing their PeerId across restarts. However, this does **not** enable validators to evade consensus-level slashing.

## Finding Description

The `aptos_node_identity::init()` function provides no mechanism to ensure PeerId consistency across node restarts. [1](#0-0) 

For fullnodes with auto-generated identities, the network identity key is persisted to `{storage_dir}/ephemeral_identity_key` and the PeerId is derived from this key. [2](#0-1) 

Network-level tracking systems for misbehaving peers store state in memory using `DashMap<PeerNetworkId, UnhealthyPeerState>`, which is not persisted to disk. [3](#0-2) 

When a peer exceeds the invalid request threshold, it is temporarily ignored. [4](#0-3) 

**Attack Path for Fullnodes:**
1. Malicious fullnode sends invalid requests to storage service
2. After 5 invalid requests, peer is ignored by `RequestModerator`
3. Attacker deletes/replaces `ephemeral_identity_key` file
4. Restarts node with new auto-generated PeerId
5. Ban state is lost (only existed in memory)
6. Attacker continues sending invalid requests with new identity

**Important Limitation - This Does NOT Apply to Validators:**

For validators, the PeerId is their account address from the on-chain validator set, not derived from the network identity key. [5](#0-4) 

The system checks that validators' local network public keys match their on-chain configuration. [6](#0-5) 

**Validators cannot evade slashing** because:
- Slashing is on-chain based on account address and consensus key signatures (BLS12-381)
- Validator PeerId is their immutable account address
- Consensus signatures are verified against `ValidatorConsensusInfo` containing account address and consensus public key
- Network identity is separate from consensus identity [7](#0-6) 

## Impact Explanation

**Severity: Medium (up to $10,000)**

This vulnerability does **not** meet High or Critical severity criteria because:
- It does NOT enable evasion of consensus-level slashing (which only applies to validators)
- It does NOT directly cause validator slowdowns, API crashes, or protocol violations
- It does NOT affect funds, consensus safety, or liveness

It qualifies as Medium severity because:
- It allows evasion of network-level DoS protections for fullnodes
- Could enable sustained resource exhaustion attacks on state sync services
- Requires manual intervention to mitigate (identifying and blocking at infrastructure level)

However, note that network-level DoS attacks are listed as "out of scope per bug bounty rules," which may exclude this finding entirely.

## Likelihood Explanation

**Likelihood: Medium-High for Fullnodes, Not Applicable for Validators**

For fullnodes:
- Trivially exploitable (delete one file, restart node)
- No special privileges required
- Automated scripts could cycle through identities

For validators:
- **Cannot exploit** - PeerId is account address, not changeable without losing stake
- Slashing mechanisms are unaffected by network identity changes

## Recommendation

**1. Add PeerId Persistence Validation:**

Modify `aptos_node_identity::init()` to validate that the provided PeerId matches any previously stored value:

```rust
pub fn init(peer_id: Option<PeerId>) -> Result<()> {
    // Load previously stored PeerId if it exists
    let stored_peer_id = load_stored_peer_id()?;
    
    // Validate consistency
    if let (Some(stored), Some(provided)) = (stored_peer_id, peer_id) {
        ensure!(
            stored == provided,
            "PeerId mismatch: stored={}, provided={}. \
             Identity changes require explicit configuration update.",
            stored, provided
        );
    }
    
    let identity = AptosNodeIdentity {
        chain_id: OnceCell::new(),
        peer_id,
        peer_id_str: peer_id.map(|id| id.to_string()),
    };
    
    APTOS_NODE_IDENTITY
        .set(Arc::new(identity))
        .map_err(|_| format_err!("APTOS_NODE_IDENTITY was already set"))?;
    
    // Persist the PeerId for future validation
    if let Some(pid) = peer_id {
        store_peer_id(pid)?;
    }
    
    Ok(())
}
```

**2. Persist Ban/Tracking State:**

Store `UnhealthyPeerState` to disk so ban state survives restarts. Track by both PeerId and network endpoint characteristics (IP ranges, connection patterns).

**3. Rate Limiting at Network Layer:**

Implement additional rate limiting based on connection source (IP/ASN) rather than just PeerId.

## Proof of Concept

```rust
// Rust test demonstrating PeerId evasion
#[tokio::test]
async fn test_peer_id_evasion_of_network_bans() {
    use aptos_config::config::NodeConfig;
    use std::fs;
    
    // Step 1: Create fullnode with auto-generated identity
    let mut config = NodeConfig::default();
    let storage_dir = tempfile::tempdir().unwrap();
    config.storage.dir = storage_dir.path().to_path_buf();
    
    // Initialize and get first PeerId
    let peer_id_1 = config.get_peer_id().unwrap();
    aptos_node_identity::init(Some(peer_id_1)).unwrap();
    
    // Step 2: Simulate getting banned (5 invalid requests)
    // In real code, this would be tracked in RequestModerator's DashMap
    
    // Step 3: Delete identity key file to force regeneration
    let identity_file = storage_dir.path().join("ephemeral_identity_key");
    fs::remove_file(&identity_file).unwrap();
    
    // Step 4: Restart node (reinitialize with new identity)
    let peer_id_2 = config.get_peer_id().unwrap();
    
    // Step 5: Verify PeerIds are different (ban evasion succeeded)
    assert_ne!(peer_id_1, peer_id_2, 
        "Successfully evaded network ban by changing PeerId");
    
    // Note: In production, the ban state in RequestModerator would be
    // keyed by peer_id_1, so peer_id_2 would not be banned
}
```

## Notes

**Critical Clarification:** This vulnerability **does not enable validators to evade slashing** as suggested by the security question. Slashing is an on-chain mechanism tied to validator account addresses and consensus key signatures, completely independent of network PeerId. 

The finding applies only to fullnode network-level tracking evasion, which may fall under "network-level DoS attacks" that are explicitly out of scope per bug bounty rules. The lack of PeerId validation in `init()` is a code quality issue but does not enable the specific attack vector (slashing evasion) described in the security question.

### Citations

**File:** crates/aptos-node-identity/src/lib.rs (L22-32)
```rust
pub fn init(peer_id: Option<PeerId>) -> Result<()> {
    let identity = AptosNodeIdentity {
        chain_id: OnceCell::new(),
        peer_id,
        peer_id_str: peer_id.map(|id| id.to_string()),
    };

    APTOS_NODE_IDENTITY
        .set(Arc::new(identity))
        .map_err(|_| format_err!("APTOS_NODE_IDENTITY was already set"))
}
```

**File:** config/src/config/config_optimizer.rs (L226-231)
```rust
                let path = node_config.storage.dir().join(IDENTITY_KEY_FILE);
                if let Some(loaded_identity) = Identity::load_identity(&path)? {
                    fullnode_network_config.identity = loaded_identity;
                } else {
                    Identity::save_private_key(&path, &config_key.private_key())?;
                }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L111-111)
```rust
    unhealthy_peer_states: Arc<DashMap<PeerNetworkId, UnhealthyPeerState>>,
```

**File:** network/discovery/src/validator_set.rs (L44-66)
```rust
    fn find_key_mismatches(&self, onchain_keys: Option<&HashSet<x25519::PublicKey>>) {
        let mismatch = onchain_keys.map_or(0, |pubkeys| {
            if !pubkeys.contains(&self.expected_pubkey) {
                error!(
                    NetworkSchema::new(&self.network_context),
                    "Onchain pubkey {:?} differs from local pubkey {}",
                    pubkeys,
                    self.expected_pubkey
                );
                1
            } else {
                0
            }
        });

        NETWORK_KEY_MISMATCH
            .with_label_values(&[
                self.network_context.role().as_str(),
                self.network_context.network_id().as_str(),
                self.network_context.peer_id().short_str().as_str(),
            ])
            .set(mismatch);
    }
```

**File:** network/discovery/src/validator_set.rs (L118-118)
```rust
            let peer_id = *info.account_address();
```

**File:** types/src/validator_verifier.rs (L72-76)
```rust
pub struct ValidatorConsensusInfo {
    pub address: AccountAddress,
    pub public_key: PublicKey,
    pub voting_power: u64,
}
```
