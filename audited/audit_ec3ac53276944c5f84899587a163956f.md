# Audit Report

## Title
Network Trust Boundary Violation: Untrusted Peers Can Subscribe to Consensus Observer Without Validation

## Summary
The consensus observer publisher accepts subscription requests from any peer on any NetworkId without validating the source network's trust level. This allows untrusted peers on the Public network to subscribe to VFN publishers and receive real-time consensus updates with the same privileges as trusted VFN or Validator network peers.

## Finding Description

The consensus observer system is designed to allow nodes to observe consensus progress without participating in consensus. However, the implementation fails to enforce trust boundaries based on NetworkId when processing subscription requests.

**The Vulnerability Chain:**

1. **VFNs Operate on Multiple Networks**

Validator Full Nodes are explicitly configured to operate on both NetworkId::Vfn (semi-trusted, for validator connections) and NetworkId::Public (untrusted, for public fullnode connections). [1](#0-0) 

The network trust hierarchy is defined with clear ordering: Validator < Vfn < Public. [2](#0-1) 

2. **Network Registration Without Differentiation**

When consensus observer is enabled, the protocols are registered on ALL networks where the node operates. The registration loop iterates through all network configurations and registers consensus observer protocols on each network without filtering based on NetworkId trust level. [3](#0-2) 

3. **No Trust Validation in Subscription Handling**

The `process_network_message` method accepts Subscribe requests from ANY peer without validating the source NetworkId. All peers are treated with equal trust regardless of whether they connect via NetworkId::Validator, NetworkId::Vfn, or NetworkId::Public. The method directly calls `add_active_subscriber` without any NetworkId validation. [4](#0-3) 

4. **Configuration Shows Trust Hierarchy**

The configuration explicitly defines a trust hierarchy where public fullnodes should NOT participate in consensus observer by default (`ENABLE_ON_PUBLIC_FULLNODES = false`), while VFNs have it enabled (`ENABLE_ON_VALIDATOR_FULLNODES = true`). This indicates the feature is intended for trusted networks only. [5](#0-4) 

However, this trust hierarchy is not enforced when the publisher receives subscription requests - it accepts subscriptions from peers on any network.

**Attack Scenario:**

1. Attacker connects to a VFN on its Public network endpoint
2. Attacker sends a `ConsensusObserverRequest::Subscribe` RPC request  
3. VFN's publisher accepts the subscription without checking that the peer is from NetworkId::Public (untrusted)
4. Attacker receives real-time streams of OrderedBlock, CommitDecision, BlockPayload, and other consensus messages
5. Attacker gains the same level of access as trusted VFN peers, violating trust boundaries

## Impact Explanation

**High Severity** - This qualifies as a significant protocol violation with the following impacts:

1. **Trust Boundary Violation**: The fundamental security principle of network segmentation is violated. NetworkId::Public peers gain the same privileges as NetworkId::Vfn or NetworkId::Validator peers, directly contradicting the intended trust model where public fullnodes should not participate in consensus observer.

2. **Information Disclosure**: Attackers gain early access to consensus decisions before they're finalized on-chain. This pre-finalization visibility into OrderedBlock and CommitDecision messages could enable:
   - MEV-style attacks through timing advantages
   - Front-running based on pre-finalization block contents  
   - Market manipulation through early consensus visibility

3. **Resource Exhaustion Vector**: Multiple untrusted peers can subscribe simultaneously without any limits. There is no max_subscribers configuration, no rate limiting in the subscription handling, and no validation preventing mass subscriptions from the public network. This consumes VFN resources including bandwidth, CPU for message serialization, and memory for maintaining active subscriptions.

4. **Protocol Design Compromise**: The intended trust model (validators → VFNs → public nodes) is undermined by allowing direct subscriptions from untrusted sources, bypassing the hierarchical information flow design.

While this doesn't cause direct fund loss or consensus safety violations (which would be Critical severity), it represents a significant breach of the protocol's security architecture and trust model, justifying High severity classification.

## Likelihood Explanation

**High Likelihood** of exploitation:

1. **Easy to Execute**: The attack requires only standard network connectivity to a VFN's public endpoint and sending a single RPC request using the standard ConsensusObserverRequest::Subscribe message format.

2. **No Authentication Required**: Public network connections don't require special credentials or validator-level access. Any peer can connect to the public network endpoint.

3. **Default Configuration Vulnerable**: VFNs have consensus observer publisher enabled by default, making all VFNs immediately vulnerable without configuration changes. [6](#0-5) 

4. **No Rate Limiting**: The codebase search confirms there is no rate limiting or maximum subscriber count enforced in the subscription handling logic.

5. **Discoverable**: VFN endpoints are publicly known and discoverable. The consensus observer protocol is standardized across all VFNs, making the attack surface consistent and predictable.

## Recommendation

Implement NetworkId-based access control in the subscription handling logic:

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    let (peer_network_id, message, response_sender) = network_message.into_parts();
    
    // Validate that subscription requests come from trusted networks only
    let network_id = peer_network_id.network_id();
    if !network_id.is_validator_network() && !network_id.is_vfn_network() {
        warn!(LogSchema::new(LogEntry::ConsensusPublisher)
            .event(LogEvent::Subscription)
            .message(&format!(
                "Rejected subscription request from untrusted network! Peer: {:?}",
                peer_network_id
            )));
        // Send rejection response instead of SubscribeAck
        return;
    }
    
    // Existing subscription handling logic...
    match message {
        ConsensusObserverRequest::Subscribe => {
            self.add_active_subscriber(peer_network_id);
            // ... rest of logic
        }
        // ...
    }
}
```

Additionally, consider:
- Implementing maximum subscriber limits per NetworkId
- Adding rate limiting for subscription requests
- Monitoring and alerting on subscription patterns from untrusted networks

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a VFN node with default configuration (publisher enabled)
2. Connecting a peer to the VFN's Public network endpoint
3. Sending a ConsensusObserverRequest::Subscribe RPC from the public network peer
4. Observing that the subscription is accepted (SubscribeAck received)
5. Confirming receipt of OrderedBlock and CommitDecision messages

The code structure itself proves the vulnerability - no PoC execution is required to verify that `process_network_message` lacks NetworkId validation checks before accepting subscriptions.

## Notes

This vulnerability represents a design flaw where the intended trust boundaries (evidenced by `ENABLE_ON_PUBLIC_FULLNODES = false`) are not enforced at the protocol implementation level. The observer side correctly prioritizes peers by network distance, but the publisher side accepts all subscription requests indiscriminately, creating an asymmetric trust model that can be exploited by untrusted peers.

### Citations

**File:** config/src/config/test_data/validator_full_node.yaml (L15-40)
```yaml
# For validator fullnode we setup two network ids, the private "vfn" identity will allow it to connect to the validator node,
# and the public identity will allow it to connects to other fullnodes onchain.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6180"
      discovery_method: "onchain"
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id: "public"
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 1
      network_id:
          private: "vfn"
      seeds:
        00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237:
          addresses:
          - "/ip4/127.0.0.1/tcp/6181/noise-ik/f0274c2774519281a8332d0bb9d8101bd58bc7bb154b38039bc9096ce04e1237/handshake/0"
          role: "Validator"
```

**File:** config/src/network_id.rs (L287-289)
```rust
        assert!(NetworkId::Validator < NetworkId::Vfn);
        assert!(NetworkId::Vfn < NetworkId::Public);
        assert!(NetworkId::Validator < NetworkId::Public);
```

**File:** aptos-node/src/network.rs (L275-358)
```rust
    for network_config in network_configs.into_iter() {
        // Create a network runtime for the config
        let runtime = create_network_runtime(&network_config);

        // Entering gives us a runtime to instantiate all the pieces of the builder
        let _enter = runtime.enter();

        // Create a new network builder
        let mut network_builder = NetworkBuilder::create(
            chain_id,
            node_config.base.role,
            &network_config,
            TimeService::real(),
            Some(event_subscription_service),
            peers_and_metadata.clone(),
        );

        // Register consensus (both client and server) with the network
        let network_id = network_config.network_id;
        if network_id.is_validator_network() {
            // A validator node must have only a single consensus network handle
            if consensus_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    consensus_network_configuration(node_config),
                    true,
                );
                consensus_network_handle = Some(network_handle);
            }

            if dkg_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    dkg_network_configuration(node_config),
                    true,
                );
                dkg_network_handle = Some(network_handle);
            }

            if jwk_consensus_network_handle.is_some() {
                panic!("There can be at most one validator network!");
            } else {
                let network_handle = register_client_and_service_with_network(
                    &mut network_builder,
                    network_id,
                    &network_config,
                    jwk_consensus_network_configuration(node_config),
                    true,
                );
                jwk_consensus_network_handle = Some(network_handle);
            }
        }

        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L168-208)
```rust
    fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
        // Unpack the network message
        let (peer_network_id, message, response_sender) = network_message.into_parts();

        // Update the RPC request counter
        metrics::increment_counter(
            &metrics::PUBLISHER_RECEIVED_REQUESTS,
            message.get_label(),
            &peer_network_id,
        );

        // Handle the message
        match message {
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
            ConsensusObserverRequest::Unsubscribe => {
                // Remove the peer from the set of active subscribers
                self.remove_active_subscriber(&peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Peer unsubscribed from consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple unsubscription ACK
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
            },
        }
    }
```

**File:** config/src/config/consensus_observer_config.rs (L12-14)
```rust
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
