# Audit Report

## Title
Genesis File Tampering via Time-of-Check-Time-of-Use (TOCTOU) Vulnerability in Local Repository Mode

## Summary
The genesis generation process using local repository mode lacks integrity verification, allowing an attacker with filesystem access to tamper with critical genesis files (validator configurations, framework bytecode, initial balances) between their creation and use, resulting in a compromised blockchain genesis state.

## Finding Description

The `Client` abstraction in the genesis system supports two storage backends: GitHub and local filesystem. When using local mode (`Client::Local`), files are written and read without any cryptographic integrity verification. [1](#0-0) 

The `get()` method for local storage simply reads files from disk using standard filesystem operations with no hash verification, signature checking, or tamper detection. [2](#0-1) 

Similarly, the `put()` method writes files directly to disk with no signing or integrity protection.

The critical framework bytecode is also loaded without verification: [3](#0-2) 

The `ReleaseBundle::read()` function performs only BCS deserialization with no integrity checks: [4](#0-3) 

**Attack Scenario:**

1. Administrator runs `SetupGit` with `--local-repository-dir /path/to/genesis`
2. Administrator runs `SetValidatorConfiguration` to configure validators, writing owner.yaml and operator.yaml files
3. **ATTACK WINDOW**: Between file creation and genesis generation, attacker with filesystem access modifies:
   - `framework.mrb` - Injects malicious Move bytecode into the framework
   - `layout.yaml` - Modifies chain parameters (min_stake, epoch_duration, etc.)
   - `validator/owner.yaml` - Changes validator account addresses or public keys
   - `balances.yaml` - Alters initial token distribution
4. Administrator runs `GenerateGenesis`, which reads the tampered files
5. The malicious genesis blob is generated and distributed to all validators [5](#0-4) 

The genesis generation process consumes these files without any verification that they haven't been tampered with since creation. [6](#0-5) 

The framework bytecode is directly loaded into the genesis state without signature verification.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables complete compromise of the blockchain from genesis:

1. **Consensus Safety Violation**: Attacker can inject malicious validator configurations with controlled keys, enabling consensus manipulation from block 1
2. **Loss of Funds**: Modified initial balances can allocate all tokens to attacker-controlled addresses
3. **Move VM Compromise**: Malicious framework bytecode gives attacker complete control over all system operations including:
   - Token minting capabilities
   - Validator set management
   - Governance mechanisms
   - Access control to system addresses
4. **State Consistency Breakdown**: Different nodes receiving different genesis blobs will have incompatible state roots, causing immediate chain split
5. **Non-Recoverable**: Once validators start with different genesis states, the network cannot recover without a complete reset and hardfork

This breaks multiple critical invariants:
- **Invariant 1 (Deterministic Execution)**: Validators won't produce identical state roots if genesis differs
- **Invariant 2 (Consensus Safety)**: Compromised genesis enables immediate consensus attacks
- **Invariant 4 (State Consistency)**: Genesis tampering causes permanent state divergence
- **Invariant 8 (Access Control)**: Malicious framework can bypass all access controls

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

Required conditions:
- Genesis setup using `--local-repository-dir` mode (common for private/testnet deployments)
- Attacker has filesystem read/write access to the genesis directory
- Time window between file creation and genesis generation (hours to days typically)

While the attacker needs filesystem access, this is achievable through:
- Compromised administrator workstation
- Insider threat (malicious employee with access)
- Supply chain attack on the genesis setup machine
- Misconfigured file permissions

The attack requires no specialized knowledge beyond file modification and is trivial to execute once filesystem access is obtained. The time window is typically substantial as genesis setup is a multi-step process spanning hours or days.

## Recommendation

Implement cryptographic integrity verification for genesis files:

1. **Sign all genesis files**: When writing files via `Client::put()`, generate a cryptographic signature using a trusted key:
   ```rust
   pub fn put<T: Serialize + ?Sized>(&self, name: &Path, input: &T) -> CliTypedResult<()> {
       let yaml_content = to_yaml(input)?;
       let content_hash = HashValue::sha3_256_of(yaml_content.as_bytes());
       
       // Sign the hash with a trusted genesis setup key
       let signature = self.signing_key.sign(&content_hash);
       
       // Write both content and signature
       // ... existing write logic ...
       
       // Write signature to .sig file
       let sig_path = name.with_extension("yaml.sig");
       write_signature(sig_path, signature)?;
   }
   ```

2. **Verify signatures when reading**: In `Client::get()`, verify the signature before deserializing:
   ```rust
   pub fn get<T: DeserializeOwned + Debug>(&self, path: &Path) -> CliTypedResult<T> {
       // Read content
       let contents = read_file(path)?;
       
       // Read signature
       let sig_path = path.with_extension("yaml.sig");
       let signature = read_signature(sig_path)?;
       
       // Verify signature matches content
       let content_hash = HashValue::sha3_256_of(contents.as_bytes());
       self.verification_key.verify(&content_hash, &signature)?;
       
       // Only deserialize if verification passes
       from_yaml(&contents)
   }
   ```

3. **Hash chain for framework bytecode**: For `framework.mrb`, include the hash in the layout file and verify:
   ```rust
   pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
       let bytes = read_framework_file()?;
       let computed_hash = HashValue::sha3_256_of(&bytes);
       
       // Read expected hash from layout
       let layout: Layout = self.get(Path::new(LAYOUT_FILE))?;
       let expected_hash = layout.framework_hash.ok_or(Error::MissingFrameworkHash)?;
       
       if computed_hash != expected_hash {
           return Err(CliError::FrameworkHashMismatch);
       }
       
       Ok(bcs::from_bytes::<ReleaseBundle>(&bytes)?)
   }
   ```

4. **Add genesis setup public key to CLI**: Require operators to specify a trusted public key for verification:
   ```bash
   aptos genesis generate-genesis \
       --local-repository-dir ./genesis \
       --genesis-public-key-file ./trusted_key.pub
   ```

## Proof of Concept

```rust
// PoC demonstrating the TOCTOU vulnerability
use std::fs;
use std::path::PathBuf;

#[test]
fn test_genesis_file_tampering() {
    // Step 1: Legitimate genesis setup
    let genesis_dir = PathBuf::from("/tmp/test_genesis");
    fs::create_dir_all(&genesis_dir).unwrap();
    
    // Administrator creates validator configuration
    let owner_config = r#"
    owner_account_address: "0x1234"
    owner_account_public_key: "0xabcd..."
    stake_amount: 1000000
    "#;
    
    let owner_file = genesis_dir.join("validator1/owner.yaml");
    fs::create_dir_all(owner_file.parent().unwrap()).unwrap();
    fs::write(&owner_file, owner_config).unwrap();
    
    // Step 2: ATTACKER modifies the file before genesis generation
    let malicious_config = r#"
    owner_account_address: "0xATTACKER"
    owner_account_public_key: "0xMALICIOUS..."
    stake_amount: 999999999999
    "#;
    
    // Attacker overwrites with no detection
    fs::write(&owner_file, malicious_config).unwrap();
    
    // Step 3: Genesis generation reads tampered file
    let client = Client::local(genesis_dir.clone());
    let read_config: OwnerConfiguration = client.get(&PathBuf::from("validator1/owner.yaml")).unwrap();
    
    // VULNERABILITY: No detection that file was modified
    assert_eq!(read_config.owner_account_address.unwrap(), "0xATTACKER");
    assert_eq!(read_config.stake_amount.unwrap(), 999999999999);
    
    // The malicious genesis would now be generated with attacker's configuration
}

#[test]
fn test_framework_tampering() {
    let genesis_dir = PathBuf::from("/tmp/test_genesis_fw");
    fs::create_dir_all(&genesis_dir).unwrap();
    
    // Step 1: Legitimate framework placed
    let legitimate_framework = create_legitimate_framework();
    let framework_path = genesis_dir.join("framework.mrb");
    fs::write(&framework_path, &legitimate_framework).unwrap();
    
    // Step 2: ATTACKER replaces with malicious framework bytecode
    let malicious_framework = create_malicious_framework_with_backdoor();
    fs::write(&framework_path, &malicious_framework).unwrap();
    
    // Step 3: Genesis reads tampered framework
    let client = Client::local(genesis_dir.clone());
    let framework = client.get_framework().unwrap();
    
    // VULNERABILITY: Malicious bytecode loaded without verification
    // The attacker's backdoored framework is now part of genesis
    assert!(framework.packages.len() > 0);
}
```

**Notes:**

This vulnerability exists specifically in the local repository mode. The GitHub mode has similar issues (no signature verification on GitHub content), but the threat model is slightly different as GitHub provides some audit trail and access controls. However, neither mode implements proper cryptographic integrity protection, which is critical for a security-sensitive operation like genesis generation that determines the entire chain's initial state.

The vulnerability is particularly severe because genesis is a one-time, irreversible operation. Once validators start with a compromised genesis, the entire blockchain is permanently compromised from block 0, with no recovery path except complete chain restart.

### Citations

**File:** crates/aptos/src/genesis/git.rs (L159-184)
```rust
    pub fn get<T: DeserializeOwned + Debug>(&self, path: &Path) -> CliTypedResult<T> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(path);

                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }

                eprintln!("Reading {}", path.display());
                let mut file = std::fs::File::open(path.as_path())
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;

                let mut contents = String::new();
                file.read_to_string(&mut contents)
                    .map_err(|e| CliError::IO(path.display().to_string(), e))?;
                from_yaml(&contents)
            },
            Client::Github(client) => {
                from_base64_encoded_yaml(&client.get_file(&path.display().to_string())?)
            },
        }
    }
```

**File:** crates/aptos/src/genesis/git.rs (L187-213)
```rust
    pub fn put<T: Serialize + ?Sized>(&self, name: &Path, input: &T) -> CliTypedResult<()> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(name);

                // Create repository path and any sub-directories
                if let Some(dir) = path.parent() {
                    self.create_dir(dir)?;
                } else {
                    return Err(CliError::UnexpectedError(format!(
                        "Path should always have a parent {}",
                        path.display()
                    )));
                }
                write_to_file(
                    path.as_path(),
                    &path.display().to_string(),
                    to_yaml(input)?.as_bytes(),
                )?;
            },
            Client::Github(client) => {
                client.put(&name.display().to_string(), &to_base64_encoded_yaml(input)?)?;
            },
        }

        Ok(())
    }
```

**File:** crates/aptos/src/genesis/git.rs (L230-247)
```rust
    pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(FRAMEWORK_NAME);
                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }
                Ok(ReleaseBundle::read(path)?)
            },
            Client::Github(client) => {
                let bytes = base64::decode(client.get_file(FRAMEWORK_NAME)?)?;
                Ok(bcs::from_bytes::<ReleaseBundle>(&bytes)?)
            },
        }
    }
```

**File:** aptos-move/framework/src/release_bundle.rs (L45-49)
```rust
    pub fn read(file: PathBuf) -> anyhow::Result<ReleaseBundle> {
        let content =
            std::fs::read(&file).with_context(|| format!("while reading `{}`", file.display()))?;
        Ok(bcs::from_bytes::<ReleaseBundle>(&content)?)
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L270-282)
```rust
pub fn fetch_genesis_info(git_options: GitOptions) -> CliTypedResult<GenesisInfo> {
    let client = git_options.get_client()?;
    let layout: Layout = client.get(Path::new(LAYOUT_FILE))?;

    if layout.root_key.is_none() {
        return Err(CliError::UnexpectedError(
            "Layout field root_key was not set.  Please provide a hex encoded Ed25519PublicKey."
                .to_string(),
        ));
    }

    let validators = get_validator_configs(&client, &layout, false).map_err(parse_error)?;
    let framework = client.get_framework()?;
```

**File:** aptos-move/vm-genesis/src/lib.rs (L147-149)
```rust
    for (module_bytes, module) in framework.code_and_compiled_modules() {
        state_view.add_module(&module.self_id(), module_bytes);
    }
```
