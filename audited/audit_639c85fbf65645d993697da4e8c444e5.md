# Audit Report

## Title
Consensus Observer Duplicate Detection Race Condition Allows Malicious Block Injection

## Summary
The `existing_pending_block()` function in the consensus observer only checks the first block's epoch and round without verifying the block hash. This allows an attacker to race malicious blocks ahead of legitimate ones, causing the observer to reject valid blocks and potentially stall consensus progression.

## Finding Description
The vulnerability exists in the duplicate detection logic for pending blocks in the consensus observer system. [1](#0-0) 

The `existing_pending_block()` function only checks if a block with matching `(epoch, round)` exists for the **first block** in an ordered block chain, without verifying that it's actually the same block (same hash). An `OrderedBlock` can contain multiple pipelined blocks: [2](#0-1) 

The attack unfolds as follows:

1. **Attacker sends malicious OrderedBlock A first:**
   - First block: `(epoch=10, round=100, hash=HashMalicious)`
   - Subsequent blocks with malicious/invalid content
   - May have invalid ordered_proof or crafted transactions
   - Gets stored in `blocks_without_payloads` with key `(10, 100)`

2. **Legitimate peer sends honest OrderedBlock B:**
   - First block: `(epoch=10, round=100, hash=HashHonest)` where `HashHonest â‰  HashMalicious`
   - Valid subsequent blocks and valid ordered_proof
   - The duplicate check finds `(10, 100)` already exists
   - Block is **dropped without further validation**: [3](#0-2) 

3. **System attempts to process malicious block:**
   - When payloads arrive, attempts to verify OrderedBlock A
   - Proof verification fails (if invalid): [4](#0-3) 

4. **Result:** Both blocks rejected - observer cannot progress at round 100

The critical flaw is that `existing_pending_block()` performs a premature duplicate check based solely on position `(epoch, round)` rather than content (hash). While `insert_pending_block()` also stores blocks by hash, this secondary check is never reached because the block is dropped earlier: [5](#0-4) 

The ordered block structure verification confirms blocks must chain correctly, but this doesn't prevent different valid chains at the same starting round: [6](#0-5) 

## Impact Explanation
**Severity: Medium** (per Aptos bug bounty: "State inconsistencies requiring intervention")

This vulnerability enables a **Denial of Service attack** on consensus observers:

1. **Observer Stalling:** Malicious peers can prevent observers from processing legitimate blocks by racing to send invalid blocks first, causing observers to drop honest blocks and stall at specific rounds.

2. **Network-Wide Impact:** If multiple observers are affected simultaneously, the network's observation layer could become unreliable, impacting systems that depend on consensus observers for block data.

3. **Recovery Requires Intervention:** Observers must wait for subscription health checks to timeout or manually clear state to recover, during which they cannot track consensus progress. [7](#0-6) 

4. **No Automatic Recovery:** Unlike validator nodes which have multiple safeguards, consensus observers have limited recovery mechanisms once stuck with a bad pending block.

While this doesn't directly compromise consensus safety (validators are unaffected), it impacts the availability and reliability of the observer infrastructure, which is used for monitoring, indexing, and other critical ecosystem services.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is easily exploitable:

1. **Low Barrier to Entry:** Any network peer can send ordered block messages without special privileges
2. **Simple Attack Vector:** Attacker just needs to send blocks faster than legitimate peers
3. **Network Race Condition:** Natural network latency variations make racing feasible
4. **No Authentication:** The duplicate check happens before cryptographic proof verification
5. **Persistent Effect:** Once a malicious block is cached, it blocks legitimate blocks until manual intervention

The attack requires no insider access, no sophisticated cryptography, and minimal resources - just the ability to send network messages quickly.

## Recommendation
Modify `existing_pending_block()` to check the **hash of the first block** in addition to epoch and round:

```rust
/// Returns true iff the store contains an entry for the given ordered block
pub fn existing_pending_block(&self, ordered_block: &OrderedBlock) -> bool {
    // Get the epoch, round, and hash of the first block
    let first_block = ordered_block.first_block();
    let first_block_epoch_round = (first_block.epoch(), first_block.round());
    let first_block_hash = first_block.id();

    // Check if a block with the same epoch, round, AND hash exists
    if let Some(existing_block) = self.blocks_without_payloads.get(&first_block_epoch_round) {
        // Verify the hash matches to ensure it's truly the same block
        existing_block.ordered_block().first_block().id() == first_block_hash
    } else {
        false
    }
}
```

This ensures that only **identical** blocks (same hash) are treated as duplicates, while different blocks at the same round are processed independently. This maintains the intended duplicate detection while preventing the race condition exploit.

Alternatively, use the hash-based lookup directly:
```rust
pub fn existing_pending_block(&self, ordered_block: &OrderedBlock) -> bool {
    let first_block_hash = ordered_block.first_block().id();
    self.blocks_without_payloads_by_hash.contains_key(&first_block_hash)
}
```

## Proof of Concept

```rust
#[test]
fn test_duplicate_detection_race_condition_vulnerability() {
    use aptos_consensus_types::{block::Block, block_data::BlockData, block_info::BlockInfo};
    use aptos_crypto::HashValue;
    
    // Create a pending block store
    let consensus_observer_config = ConsensusObserverConfig::default();
    let mut store = PendingBlockStore::new(consensus_observer_config);
    
    let epoch = 10;
    let round = 100;
    
    // Create first ordered block (malicious) with specific hash
    let malicious_hash = HashValue::random();
    let malicious_block_info = BlockInfo::new(
        epoch, round, malicious_hash, HashValue::random(), round, 0, None
    );
    let malicious_block_data = BlockData::new_for_testing(
        epoch, round, 0, QuorumCert::dummy(), BlockType::Genesis
    );
    let malicious_block = Block::new_for_testing(malicious_hash, malicious_block_data, None);
    let malicious_pipelined = Arc::new(PipelinedBlock::new_ordered(
        malicious_block, OrderedBlockWindow::empty()
    ));
    let malicious_proof = LedgerInfoWithSignatures::new(
        LedgerInfo::new(malicious_block_info, HashValue::random()),
        AggregateSignature::empty()
    );
    let malicious_ordered_block = OrderedBlock::new(
        vec![malicious_pipelined], malicious_proof
    );
    
    // Create second ordered block (honest) with DIFFERENT hash but same epoch/round
    let honest_hash = HashValue::random(); // Different hash!
    assert_ne!(honest_hash, malicious_hash);
    
    let honest_block_info = BlockInfo::new(
        epoch, round, honest_hash, HashValue::random(), round, 0, None
    );
    let honest_block_data = BlockData::new_for_testing(
        epoch, round, 0, QuorumCert::dummy(), BlockType::Genesis
    );
    let honest_block = Block::new_for_testing(honest_hash, honest_block_data, None);
    let honest_pipelined = Arc::new(PipelinedBlock::new_ordered(
        honest_block, OrderedBlockWindow::empty()
    ));
    let honest_proof = LedgerInfoWithSignatures::new(
        LedgerInfo::new(honest_block_info, HashValue::random()),
        AggregateSignature::empty()
    );
    let honest_ordered_block = OrderedBlock::new(
        vec![honest_pipelined], honest_proof
    );
    
    // Insert malicious block first
    let malicious_pending = PendingBlockWithMetadata::new_with_arc(
        PeerNetworkId::random(),
        Instant::now(),
        ObservedOrderedBlock::new(malicious_ordered_block.clone())
    );
    store.insert_pending_block(malicious_pending);
    
    // VULNERABILITY: Check if honest block is considered "existing"
    // It returns TRUE even though the blocks have different hashes!
    let is_duplicate = store.existing_pending_block(&honest_ordered_block);
    
    // This assertion demonstrates the vulnerability:
    // The honest block is incorrectly flagged as duplicate
    assert!(is_duplicate, "Vulnerability: Different blocks at same round treated as duplicates!");
    
    // Verify they are actually different blocks
    assert_ne!(
        malicious_ordered_block.first_block().id(),
        honest_ordered_block.first_block().id(),
        "Blocks have different hashes but are treated as duplicates"
    );
}
```

This test demonstrates that two completely different blocks (different hashes) at the same `(epoch, round)` are incorrectly treated as duplicates, allowing the attack described above.

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L90-99)
```rust
    /// Returns true iff the store contains an entry for the given ordered block
    pub fn existing_pending_block(&self, ordered_block: &OrderedBlock) -> bool {
        // Get the epoch and round of the first block
        let first_block = ordered_block.first_block();
        let first_block_epoch_round = (first_block.epoch(), first_block.round());

        // Check if the block is already in the store by epoch and round
        self.blocks_without_payloads
            .contains_key(&first_block_epoch_round)
    }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L111-150)
```rust
    /// Inserts a pending block (without payloads) into the store
    pub fn insert_pending_block(&mut self, pending_block: Arc<PendingBlockWithMetadata>) {
        // Get the first block in the ordered blocks
        let first_block = pending_block.ordered_block().first_block();

        // Insert the block into the store using the epoch round of the first block
        let first_block_epoch_round = (first_block.epoch(), first_block.round());
        match self.blocks_without_payloads.entry(first_block_epoch_round) {
            Entry::Occupied(_) => {
                // The block is already in the store
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "A pending block was already found for the given epoch and round: {:?}",
                        first_block_epoch_round
                    ))
                );
            },
            Entry::Vacant(entry) => {
                // Insert the block into the store
                entry.insert(pending_block.clone());
            },
        }

        // Insert the block into the hash store using the hash of the first block
        let first_block_hash = first_block.id();
        match self.blocks_without_payloads_by_hash.entry(first_block_hash) {
            Entry::Occupied(_) => {
                // The block is already in the hash store
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "A pending block was already found for the given block hash: {:?}",
                        first_block_hash
                    ))
                );
            },
            Entry::Vacant(entry) => {
                // Insert the block into the hash store
                entry.insert(pending_block);
            },
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L179-192)
```rust
/// OrderedBlock message contains the ordered blocks and the proof of the ordering
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}

impl OrderedBlock {
    pub fn new(blocks: Vec<Arc<PipelinedBlock>>, ordered_proof: LedgerInfoWithSignatures) -> Self {
        Self {
            blocks,
            ordered_proof,
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L225-266)
```rust
    /// Verifies the ordered blocks and returns an error if the data is invalid.
    /// Note: this does not check the ordered proof.
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L216-234)
```rust
    /// Clears the pending block state (this is useful for changing
    /// subscriptions, where we want to wipe all state and restart).
    async fn clear_pending_block_state(&self) {
        // Clear the observer block data
        let root = self.observer_block_data.lock().clear_block_data();

        // Reset the execution pipeline for the root
        if let Err(error) = self.execution_client.reset(&root).await {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to reset the execution pipeline for the root! Error: {:?}",
                    error
                ))
            );
        }

        // Increment the cleared block state counter
        metrics::increment_counter_without_labels(&metrics::OBSERVER_CLEARED_BLOCK_STATE);
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L681-691)
```rust
        let block_pending = self
            .observer_block_data
            .lock()
            .existing_pending_block(&ordered_block);

        // If the block is out of date or already pending, ignore it
        if block_out_of_date || block_pending {
            // Update the metrics for the dropped ordered block
            update_metrics_for_dropped_ordered_block_message(peer_network_id, &ordered_block);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L730-742)
```rust
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
```
