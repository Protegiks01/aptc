# Audit Report

## Title
Critical System Error Masking in Block Execution Leading to Potential Consensus Divergence

## Summary
The `execute_global_txns()` function and broader block executor do not properly distinguish between benign transaction failures and critical system errors. Specifically, `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` status codes—which indicate code bugs in the executor—are handled identically to normal validation failures, being discarded without proper differentiation. This error masking creates a risk of non-deterministic execution outcomes if the underlying conditions triggering these critical errors vary across validator nodes.

## Finding Description

The vulnerability exists in how VMStatus errors propagate through the execution pipeline from `execute_global_txns()` to final transaction status determination. [1](#0-0) 

When global transactions execute, any VMStatus errors are returned directly. These errors flow through the block executor where critical system errors are converted: [2](#0-1) 

The critical issue is in how these errors are classified. The `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` status code is documented as indicating a code bug: [3](#0-2) 

However, during error handling in `keep_or_discard()`, this critical error type (InvariantViolation) is treated identically to validation errors—both are discarded: [4](#0-3) 

During sequential execution fallback with BCS mode, individual transactions causing serialization errors are discarded and execution continues: [5](#0-4) 

When the entire block execution fails due to critical errors, if `discard_failed_blocks` is enabled (though disabled by default), all transactions are discarded with the same status code: [6](#0-5) 

The default configuration shows this setting is disabled in production: [7](#0-6) 

## Impact Explanation

This constitutes a **High Severity** vulnerability (potentially escalating to **Critical**) based on these impact scenarios:

**Deterministic Execution Invariant Violation**: The most critical Aptos invariant states "All validators must produce identical state roots for identical blocks". If the conditions triggering `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` vary across validators (due to race conditions in parallel execution, resource availability differences, or timing-dependent edge cases in delayed field handling), different validators will produce different outcomes:

- Validators hitting the error will discard affected transactions
- Validators not hitting the error will commit the same transactions
- This causes state divergence and consensus failure

**Error Masking**: Even in deterministic scenarios, treating critical system errors (code bugs) identically to benign validation failures masks the severity from operators. Logs and metrics cannot distinguish between:
- "User submitted invalid transaction" (expected, normal)
- "Block executor encountered code invariant error" (critical bug requiring immediate investigation)

**Protocol Degradation**: During sequential fallback, transactions causing these errors are silently discarded and execution continues, potentially allowing blocks to commit in a degraded state that should have failed entirely.

## Likelihood Explanation

**Medium-to-High Likelihood** for several reasons:

1. **Parallel Execution Non-Determinism**: BlockSTM parallel execution inherently has timing-dependent behavior. While designed for deterministic outcomes, subtle race conditions in delayed field handling or resource group serialization could manifest differently across nodes with varying CPU speeds, memory availability, or load patterns.

2. **Resource-Dependent Triggers**: The errors can be triggered by resource exhaustion or memory limits, which vary across validator hardware configurations.

3. **Complex State Dependencies**: Delayed fields and resource groups involve complex state materialization logic with multiple fallback paths, increasing the surface area for non-deterministic behavior.

4. **Historical Precedent**: The code comments explicitly mention fallback mechanisms were added because of such issues, and the multiple layers of error handling suggest these scenarios occur in practice.

## Recommendation

Implement strict differentiation between critical system errors and benign transaction failures:

```rust
// In VMStatus keep_or_discard() method
VMStatus::Error {
    status_code: code,
    message,
    ..
} => {
    match code.status_type() {
        StatusType::InvariantViolation => {
            // Critical: Check if this is a code bug vs. normal invariant violation
            if code == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR ||
               code == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                // These should NEVER be kept - they indicate executor bugs
                // Propagate as fatal error rather than discarding
                panic!("CRITICAL: Block executor invariant violation - code bug detected: {:?}", code);
            }
            Err(code) // Other invariant violations are discarded
        },
        // ... rest of the logic
    }
}

// In executor.rs sequential fallback
if serialization_error {
    // CRITICAL: This is a code bug, not a bad transaction
    // Fail the entire block rather than silently discarding
    alert!("CRITICAL: Serialization failed during BCS fallback - executor bug");
    return Err(SequentialBlockExecutionError::ErrorToReturn(
        BlockExecutionError::FatalBlockExecutorError(
            code_invariant_error("Serialization failed in BCS fallback - this should never happen")
        )
    ));
}
```

Additionally, add consensus-critical assertions to ensure all validators reach identical outcomes even during error conditions.

## Proof of Concept

```rust
// Conceptual PoC demonstrating the vulnerability
// This would require integration test infrastructure

#[test]
fn test_non_deterministic_delayed_field_error() {
    // Setup: Create a block with transactions that stress delayed field handling
    let transactions = vec![
        create_transaction_with_complex_delayed_fields(),
        create_transaction_with_resource_group_edge_case(),
    ];
    
    // Execute on "fast" validator with high resources
    let fast_validator_config = BlockExecutorConfig {
        local: BlockExecutorLocalConfig {
            concurrency_level: 32,
            allow_fallback: true,
            discard_failed_blocks: false,
            // ... other config
        },
        // ...
    };
    let result1 = execute_block(&transactions, fast_validator_config);
    
    // Execute on "slow" validator with constrained resources
    // that might hit resource limits during parallel execution
    let slow_validator_config = BlockExecutorConfig {
        local: BlockExecutorLocalConfig {
            concurrency_level: 2, // Lower concurrency
            allow_fallback: true,
            discard_failed_blocks: false,
            // ... other config
        },
        // ...
    };
    let result2 = execute_block(&transactions, slow_validator_config);
    
    // Vulnerability: Results may differ if timing-dependent error occurs
    // Fast validator: Succeeds with parallel execution
    // Slow validator: Hits DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
    //                  during fallback, discards transactions
    assert_eq!(result1.state_root(), result2.state_root()); // MAY FAIL
}
```

## Notes

The vulnerability's exploitability depends on whether an attacker can craft transactions that reliably trigger `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` under specific validator conditions. While the exact trigger is complex, the error handling flaw is demonstrable: critical code bugs are masked as normal transaction failures, violating the principle that all validators must fail identically or succeed identically for consensus safety.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/global_executor.rs (L44-69)
```rust
    pub fn execute_global_txns(
        &self,
        transactions: Vec<TransactionWithDependencies<AnalyzedTransaction>>,
        state_view: &S,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>, VMStatus> {
        trace!("executing the last round in global executor",);
        if transactions.is_empty() {
            return Ok(vec![]);
        }
        ShardedExecutorService::execute_transactions_with_dependencies(
            None,
            self.executor_thread_pool.clone(),
            transactions,
            self.global_cross_shard_client.clone(),
            None,
            GLOBAL_ROUND_ID,
            state_view,
            BlockExecutorConfig {
                local: BlockExecutorLocalConfig::default_with_concurrency_level(
                    self.concurrency_level,
                ),
                onchain: onchain_config,
            },
        )
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L577-585)
```rust
            Err(BlockExecutionError::FatalBlockExecutorError(PanicError::CodeInvariantError(
                err_msg,
            ))) => Err(VMStatus::Error {
                status_code: StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                sub_status: None,
                message: Some(err_msg),
            }),
            Err(BlockExecutionError::FatalVMError(err)) => Err(err),
        }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L287-316)
```rust
            VMStatus::Error {
                status_code: code,
                message,
                ..
            } => {
                match code.status_type() {
                    // Any unknown error should be discarded
                    StatusType::Unknown => Err(code),
                    // Any error that is a validation status (i.e. an error arising from the prologue)
                    // causes the transaction to not be included.
                    StatusType::Validation => Err(code),
                    // If the VM encountered an invalid internal state, we should discard the transaction.
                    StatusType::InvariantViolation => Err(code),
                    // A transaction that publishes code that cannot be verified will be charged.
                    StatusType::Verification => Ok(KeptVMStatus::MiscellaneousError),
                    // If we are able to decode the`SignedTransaction`, but failed to decode
                    // `SingedTransaction.raw_transaction.payload` (i.e., the transaction script),
                    // there should be a charge made to that user's account for the gas fees related
                    // to decoding, running the prologue etc.
                    StatusType::Deserialization => Ok(KeptVMStatus::MiscellaneousError),
                    // Any error encountered during the execution of the transaction will charge gas.
                    StatusType::Execution => Ok(KeptVMStatus::ExecutionFailure {
                        location: AbortLocation::Script,
                        function: 0,
                        code_offset: 0,
                        message,
                    }),
                }
            },
        }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L855-871)
```rust
    // code invariant error while handling delayed materialization, should never happen,
    // always indicates a code bug. Delayed materialization includes handling of
    // Resource Groups and Delayed Fields. Unlike regular CODE_INVARIANT_ERROR, this
    // is a signal to BlockSTM, which it might do something about (i.e. fallback to
    // sequential execution).
    // Note: This status is created both from third_party (move) and block executor
    // (aptos-move in the adapter). In the later case, it can now also represent more
    // general invariant violations beyond delayed fields, due to the convenience of
    // handling such issues with asserts (e.g. by falling back to sequential execution).
    // TODO: can be audited and broken down into specific types, once implementation
    // is also not duplicated.
    DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR = 2023,
    // Speculative error means that there was an issue because of speculative
    // reads provided to the transaction, and the transaction needs to
    // be re-executed.
    // Should never be committed on chain
    SPECULATIVE_EXECUTION_ABORT_ERROR = 2024,
```

**File:** aptos-move/block-executor/src/executor.rs (L2399-2408)
```rust
                        if serialization_error {
                            // The corresponding error / alert must already be triggered, the goal in sequential
                            // fallback is to just skip any transactions that would cause such serialization errors.
                            alert!("Discarding transaction because serialization failed in bcs fallback");
                            ret.push(E::Output::discard_output(
                                StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                            ));
                            idx += 1;
                            continue;
                        }
```

**File:** aptos-move/block-executor/src/executor.rs (L2648-2660)
```rust
        if self.config.local.discard_failed_blocks {
            // We cannot execute block, discard everything (including block metadata and validator transactions)
            // (TODO: maybe we should add fallback here to first try BlockMetadataTransaction alone)
            let error_code = match sequential_error {
                BlockExecutionError::FatalBlockExecutorError(_) => {
                    StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                },
                BlockExecutionError::FatalVMError(_) => {
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                },
            };
            let ret = (0..signature_verified_block.num_txns())
                .map(|_| E::Output::discard_output(error_code))
```

**File:** config/src/config/execution_config.rs (L78-96)
```rust
impl Default for ExecutionConfig {
    fn default() -> ExecutionConfig {
        ExecutionConfig {
            genesis: None,
            genesis_file_location: PathBuf::new(),
            // use min of (num of cores/2, DEFAULT_CONCURRENCY_LEVEL) as default concurrency level
            concurrency_level: 0,
            num_proof_reading_threads: 32,
            paranoid_type_verification: true,
            paranoid_hot_potato_verification: true,
            discard_failed_blocks: false,
            processed_transactions_detailed_counters: false,
            genesis_waypoint: None,
            blockstm_v2_enabled: false,
            layout_caches_enabled: true,
            // TODO: consider setting to be true by default.
            async_runtime_checks: false,
        }
    }
```
