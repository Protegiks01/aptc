# Audit Report

## Title
Epoch History Bypass Allows Unverified Ledger Info Injection During Database Restore

## Summary
The backup restore functionality conditionally skips cryptographic verification of ledger info signatures when the `--skip-epoch-endings` flag is used. This allows an attacker controlling the backup source to inject malicious, unverified ledger infos into the validator database, compromising the consensus trust anchor and potentially causing chain splits or state corruption.

## Finding Description

The vulnerability exists in two critical restore paths where ledger info signature verification is conditionally skipped:

**State Snapshot Restore Path:**
When `skip_epoch_endings` is true, the `epoch_history` parameter becomes `None` [1](#0-0) , which is then passed to the state snapshot restore controller [2](#0-1) .

In the state snapshot restore implementation, ledger info signature verification only occurs when epoch_history exists [3](#0-2) .

**Transaction Restore Path:**
The same vulnerability exists in transaction restore, where signature verification is skipped when epoch_history is None [4](#0-3) .

**What Gets Bypassed:**
The `verify_ledger_info` method performs critical security checks [5](#0-4) :
- Verifies BLS signatures against the epoch's validator set
- Validates waypoints against trusted checkpoints  
- Ensures genesis epoch consistency

**Attack Path:**
1. Attacker controls or compromises the backup storage source
2. Attacker creates malicious backup with forged ledger infos (invalid/missing signatures)
3. Victim runs restore with the `--skip-epoch-endings` flag [6](#0-5) 
4. Unverified ledger infos are saved to the database [7](#0-6) 
5. The malicious ledger info becomes the "latest ledger info" trust anchor [8](#0-7) 
6. Validator starts using corrupted state as consensus root

## Impact Explanation

**CRITICAL SEVERITY** - This vulnerability meets multiple critical impact categories:

**Consensus/Safety Violations:** The validator's consensus root is derived from the latest ledger info. With an unverified ledger info containing arbitrary epoch state, validator sets, or voting power, different validators could have divergent views of the blockchain state, causing chain splits.

**State Corruption:** The attacker can specify arbitrary state roots, transaction accumulator hashes, and epoch information in the ledger info without cryptographic proof. This breaks the fundamental invariant that "State transitions must be atomic and verifiable via Merkle proofs."

**Non-recoverable Network Partition:** If multiple validators restore from compromised backups, they may form a partitioned network with incompatible state that cannot reconcile without a hard fork.

This directly violates the critical invariant: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" and "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure."

## Likelihood Explanation

**Medium-to-High Likelihood:**

**Attacker Requirements:**
- Control or compromise backup storage (e.g., cloud storage buckets, backup servers)
- MITM capability on backup retrieval channel
- Social engineering to convince operators to use `--skip-epoch-endings`

**Victim Requirements:**
- Operator runs restore with `--skip-epoch-endings` flag
- The flag is marked only as "used for debugging" with no security warnings
- Operators may use this flag for legitimate performance/debugging reasons without understanding security implications

**Realistic Scenarios:**
- Compromised backup infrastructure
- Insider threat with backup access
- Operators following incomplete documentation
- Emergency recovery situations where operators rush and skip validations

## Recommendation

**Immediate Fix:**
Remove the `--skip-epoch-endings` flag entirely, or if debugging is essential, add strict safeguards:

```rust
#[clap(long, help = "DANGEROUS: Skip epoch validation. Creates UNVERIFIED database. \
                      NEVER use in production. Only for testing/debugging.")]
pub skip_epoch_endings: bool,
```

Add runtime checks to prevent production use:

```rust
if skip_epoch_endings {
    warn!("SECURITY WARNING: Skipping epoch validation creates unverified database!");
    warn!("This database MUST NOT be used for validator operations!");
    if !confirm_dangerous_operation() {
        bail!("Epoch validation skip aborted for safety");
    }
}
```

**Proper Fix:**
Always verify ledger info signatures regardless of flags:

```rust
// In state_snapshot/restore.rs and transaction/restore.rs
// Remove conditional check - ALWAYS verify
epoch_history
    .as_ref()
    .ok_or_else(|| anyhow!("Epoch history required for ledger info verification"))?
    .verify_ledger_info(&li)?;
```

Mark restored databases with a flag indicating they require re-validation before validator use.

## Proof of Concept

**Setup:**
1. Create malicious backup with forged ledger info (invalid signatures/wrong validator set)
2. Run restore with bypassed validation

**Test Code:**
```rust
// Create malicious ledger info with arbitrary state
let malicious_li = LedgerInfoWithSignatures::new(
    LedgerInfo::new(
        BlockInfo::new(
            /* arbitrary epoch */ 100,
            /* arbitrary round */ 1000, 
            /* arbitrary hash */ HashValue::random(),
            /* arbitrary tx accumulator */ HashValue::random(),
            /* version */ 1000000,
            /* timestamp */ 0,
            None, // No epoch state
        ),
        HashValue::zero(),
    ),
    AggregateSignature::empty(), // NO VALID SIGNATURES
);

// Create backup manifest with malicious ledger info
// Save to storage

// Restore with skip_epoch_endings=true
// Result: Unverified ledger info is saved to DB

// Verify vulnerability:
let restored_li = db.get_latest_ledger_info();
assert!(restored_li.signatures().is_empty()); // No valid signatures!
assert_eq!(restored_li.ledger_info().epoch(), 100); // Arbitrary epoch accepted
```

**Expected Result:** Database contains unverified ledger info that would be used as consensus trust anchor when validator starts.

**Notes**

This vulnerability is particularly dangerous because:

1. The flag appears innocuous ("used for debugging") but has critical security implications
2. There are no warnings or access controls on the flag
3. The compromised database appears valid and will start normally
4. Detection requires manual inspection of ledger info signatures
5. Multiple validators could be compromised simultaneously during coordinated backup restoration
6. The attack surface includes all backup storage infrastructure

The vulnerability affects both state snapshot and transaction restore paths, making it pervasive across the entire backup/restore subsystem.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L247-259)
```rust
                StateSnapshotRestoreController::new(
                    StateSnapshotRestoreOpt {
                        manifest_handle: kv_snapshot.manifest,
                        version: kv_snapshot.version,
                        validate_modules: false,
                        restore_mode: StateSnapshotRestoreMode::KvOnly,
                    },
                    self.global_opt.clone(),
                    Arc::clone(&self.storage),
                    epoch_history.clone(),
                )
                .run()
                .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L60-74)
```rust
/// Updates the latest ledger info iff a ledger info with a higher epoch is found
pub(crate) fn update_latest_ledger_info(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    if let Some(li) = ledger_metadata_db.get_latest_ledger_info_option() {
        if li.ledger_info().epoch() > ledger_infos.last().unwrap().ledger_info().epoch() {
            // No need to update latest ledger info.
            return Ok(());
        }
    }
    ledger_metadata_db.set_latest_ledger_info(ledger_infos.last().unwrap().clone());

    Ok(())
}
```
