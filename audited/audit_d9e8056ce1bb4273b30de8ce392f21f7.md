# Audit Report

## Title
Anti-Replay Protection Missing on Validator-to-VFN Connections Enables Handshake Replay DoS Attack

## Summary
Anti-replay timestamp validation is only enabled in `HandshakeAuthMode::Mutual` but not in `HandshakeAuthMode::MaybeMutual` mode. Since VFN (Validator Full Node) networks default to `mutual_authentication: false`, they use `MaybeMutual` mode, allowing attackers to replay captured Noise handshake messages and force validators to repeatedly perform expensive Diffie-Hellman key exchange operations, causing denial-of-service through resource exhaustion.

## Finding Description

The Noise handshake implementation includes an anti-replay protection mechanism using timestamps to prevent replay attacks. [1](#0-0) 

However, this protection is only activated when `HandshakeAuthMode::Mutual` is used. The `anti_replay_timestamps()` method returns `None` for `MaybeMutual` mode: [2](#0-1) 

VFN networks, which handle connections between validators and their associated full nodes, default to `mutual_authentication: false`: [3](#0-2) 

This configuration translates to `HandshakeAuthMode::MaybeMutual` in the network builder: [4](#0-3) 

During inbound connection handling, timestamp validation only occurs when `anti_replay_timestamps()` returns `Some(...)`: [5](#0-4) 

**Attack Flow:**
1. Attacker eavesdrops on network traffic and captures a valid Noise IK handshake initiation message from a legitimate VFN connecting to a validator
2. The captured message contains the client's peer_id, expected server public key, Noise handshake data (ephemeral key, encrypted static key), and timestamp
3. Attacker replays this exact message to the validator's VFN network endpoint multiple times
4. Each replay passes initial validation and forces the validator to perform expensive Diffie-Hellman key exchanges during `parse_client_init_message()`
5. Without anti-replay timestamp checking, there is no mechanism to detect or reject these replayed handshakes

The client always sends timestamps regardless of authentication mode: [6](#0-5) 

## Impact Explanation

This vulnerability enables a **High severity** DoS attack against validators according to Aptos bug bounty criteria: "Validator node slowdowns."

An attacker can force validators to waste computational resources on cryptographic operations without possessing any private keys. The Diffie-Hellman key exchanges performed during Noise handshake parsing are intentionally expensive operations. By replaying captured handshakes repeatedly, an attacker can:

- Exhaust validator CPU resources processing replayed handshakes
- Degrade validator performance, potentially impacting consensus participation
- Create targeted attacks against specific validators by replaying their VFN handshakes

This is particularly concerning because VFN networks are a standard component of validator deployments, and the default configuration is vulnerable.

## Likelihood Explanation

**Likelihood: High**

- VFN networks are a standard part of validator infrastructure
- The vulnerable configuration (`mutual_authentication: false`) is the default for VFN networks
- Attack requires only passive network eavesdropping (capturing one valid handshake)
- No private keys or authentication credentials needed
- Attack is repeatable indefinitely with a single captured handshake
- Validators cannot easily distinguish replay attacks from legitimate connection attempts in MaybeMutual mode

The code comments acknowledge this attack vector exists: [7](#0-6) 

## Recommendation

Enable anti-replay timestamp validation for all authentication modes, or at minimum, require `mutual_authentication: true` for VFN networks in production deployments.

**Option 1: Enable anti-replay for MaybeMutual mode**
Extend `AntiReplayTimestamps` to use a size-limited LRU cache with periodic garbage collection to prevent unbounded memory growth while still providing replay protection:

```rust
// In HandshakeAuthMode::MaybeMutual
MaybeMutual {
    anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
    peers_and_metadata: Arc<PeersAndMetadata>,
}
```

**Option 2: Enforce mutual authentication for VFN networks**
Update the network configuration validator to require `mutual_authentication: true` for VFN networks, similar to the validator network requirement: [8](#0-7) 

**Option 3: Add connection-level rate limiting**
Implement per-source-IP rate limiting on handshake attempts to mitigate replay attack volume.

## Proof of Concept

The existing test demonstrates that replay protection works in Mutual mode but not in MaybeMutual mode: [9](#0-8) 

To demonstrate the vulnerability, modify the test to use `MaybeMutual` mode:

```rust
#[test]
fn test_timestamp_replay_maybemutual_vulnerable() {
    // Build peers with MaybeMutual mode (mutual_authentication=false)
    let ((client, _), (server, server_public_key)) = build_peers(false, None);
    let server_peer_id = server.network_context.peer_id();

    // Perform first handshake with timestamp=1
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_session, server_session) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            bad_timestamp(1),
        ),
        server.upgrade_inbound(listener_socket),
    ));
    
    // First handshake succeeds
    client_session.unwrap();
    server_session.unwrap();

    // Replay with same timestamp=1 - should fail but succeeds in MaybeMutual
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_session, server_session) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            bad_timestamp(1),
        ),
        server.upgrade_inbound(listener_socket),
    ));

    // This demonstrates the vulnerability - replay succeeds when it shouldn't
    client_session.unwrap();  // Succeeds instead of failing
    server_session.unwrap();  // Succeeds instead of failing
}
```

## Notes

The vulnerability exists because anti-replay protection was intentionally disabled for `MaybeMutual` mode to avoid unbounded memory growth from storing timestamps for untrusted peers. However, this design choice creates a security vulnerability that enables DoS attacks against validators on their VFN networks. The trade-off between memory management and replay protection should be resolved through rate limiting, LRU caches, or requiring mutual authentication for VFN networks.

### Citations

**File:** network/framework/src/noise/handshake.rs (L30-39)
```rust
/// In a mutually authenticated network, a client message is accompanied with a timestamp.
/// This is in order to prevent replay attacks, where the attacker does not know the client's static key,
/// but can still replay a handshake message in order to force a peer into performing a few Diffie-Hellman key exchange operations.
///
/// Thus, to prevent replay attacks a responder will always check if the timestamp is strictly increasing,
/// effectively considering it as a stateful counter.
///
/// If the client timestamp has been seen before, or is not strictly increasing,
/// we can abort the handshake early and avoid heavy Diffie-Hellman computations.
/// If the client timestamp is valid, we store it.
```

**File:** network/framework/src/noise/handshake.rs (L86-92)
```rust
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
        anti_replay_timestamps: RwLock<AntiReplayTimestamps>,
```

**File:** network/framework/src/noise/handshake.rs (L123-131)
```rust
    fn anti_replay_timestamps(&self) -> Option<&RwLock<AntiReplayTimestamps>> {
        match &self {
            HandshakeAuthMode::Mutual {
                anti_replay_timestamps,
                ..
            } => Some(anti_replay_timestamps),
            HandshakeAuthMode::MaybeMutual(_) => None,
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L429-454)
```rust
        // if on a mutually authenticated network,
        // the payload should contain a u64 client timestamp
        if let Some(anti_replay_timestamps) = self.auth_mode.anti_replay_timestamps() {
            // check that the payload received as the client timestamp (in seconds)
            if payload.len() != AntiReplayTimestamps::TIMESTAMP_SIZE {
                return Err(NoiseHandshakeError::MissingAntiReplayTimestamp(
                    remote_peer_short,
                ));
            }

            let mut client_timestamp = [0u8; AntiReplayTimestamps::TIMESTAMP_SIZE];
            client_timestamp.copy_from_slice(&payload);
            let client_timestamp = u64::from_le_bytes(client_timestamp);

            // check the timestamp is not a replay
            let mut anti_replay_timestamps = anti_replay_timestamps.write();
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }

            // store the timestamp
            anti_replay_timestamps.store_timestamp(remote_public_key, client_timestamp);
        }
```

**File:** network/framework/src/noise/handshake.rs (L629-694)
```rust
    #[test]
    fn test_timestamp_replay() {
        // 1. generate peers
        let ((client, _), (server, server_public_key)) = build_peers(true, None);
        let server_peer_id = server.network_context.peer_id();

        // 2. perform the handshake with some timestamp, it should work
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        let (client_session, server_session) = block_on(join(
            client.upgrade_outbound(
                dialer_socket,
                server_peer_id,
                server_public_key,
                bad_timestamp(1),
            ),
            server.upgrade_inbound(listener_socket),
        ));

        client_session.unwrap();
        server_session.unwrap();

        // 3. perform the handshake again with timestamp in the past, it should fail
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        let (client_session, server_session) = block_on(join(
            client.upgrade_outbound(
                dialer_socket,
                server_peer_id,
                server_public_key,
                bad_timestamp(0),
            ),
            server.upgrade_inbound(listener_socket),
        ));

        client_session.unwrap_err();
        server_session.unwrap_err();

        // 4. perform the handshake again with the same timestamp, it should fail
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        let (client_session, server_session) = block_on(join(
            client.upgrade_outbound(
                dialer_socket,
                server_peer_id,
                server_public_key,
                bad_timestamp(1),
            ),
            server.upgrade_inbound(listener_socket),
        ));

        client_session.unwrap_err();
        server_session.unwrap_err();

        // 5. perform the handshake again with a valid timestamp in the future, it should work
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        let (client_session, server_session) = block_on(join(
            client.upgrade_outbound(
                dialer_socket,
                server_peer_id,
                server_public_key,
                bad_timestamp(2),
            ),
            server.upgrade_inbound(listener_socket),
        ));

        client_session.unwrap();
        server_session.unwrap();
    }
```

**File:** config/src/config/network_config.rs (L135-143)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
            network_id,
```

**File:** network/framework/src/peer_manager/builder.rs (L253-262)
```rust
        let (key, auth_mode) = match transport_context.authentication_mode {
            AuthenticationMode::MaybeMutual(key) => (
                key,
                HandshakeAuthMode::maybe_mutual(transport_context.peers_and_metadata),
            ),
            AuthenticationMode::Mutual(key) => (
                key,
                HandshakeAuthMode::mutual(transport_context.peers_and_metadata),
            ),
        };
```

**File:** network/framework/src/transport/mod.rs (L346-354)
```rust
    // noise handshake
    let (mut socket, peer_role) = ctxt
        .noise
        .upgrade_outbound(
            socket,
            remote_peer_id,
            remote_pubkey,
            AntiReplayTimestamps::now,
        )
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```
