# Audit Report

## Title
Resource Exhaustion via Unvalidated Block ID in Admin Service Consensus Block Dump Endpoint

## Summary
The `handle_dump_block_request()` function in the admin service lacks input validation to check whether a provided `block_id` exists in the database before scanning. This allows authenticated attackers to trigger expensive full database scans by providing arbitrary non-existent block IDs, potentially causing validator node slowdowns through resource exhaustion.

## Finding Description

The vulnerability exists in the admin service's block dump endpoint at `/debug/consensus/block`. When a client provides a `block_id` parameter, the code does not validate whether this block exists before performing database operations. [1](#0-0) 

The `handle_dump_block_request()` function accepts an optional `block_id` parameter from the query string and passes it directly to `dump_blocks()` without any existence validation. [2](#0-1) 

The `dump_blocks()` function performs the following expensive operations regardless of whether `block_id` exists:

1. Loads ALL blocks from the consensus database via `consensus_db.consensus_db().get_data()` 
2. Loads ALL quorum certificates from the database
3. Loads ALL batches from the quorum store database via `get_all_batches()`
4. Iterates through all results in-memory to find matches [3](#0-2) 

The `get_data()` method calls `get_all::<BlockSchema>()` which performs a full table scan: [4](#0-3) 

This iterates through the entire BlockSchema column family. With a default configuration of `max_pruned_blocks_in_mem = 100`, the database typically contains around 100 blocks: [5](#0-4) 

**Attack Scenario:**

1. Attacker obtains access to the admin service (on testnet/devnet without authentication, or with valid passcode)
2. Attacker sends multiple concurrent requests: `/debug/consensus/block?block_id=<random_hash>`
3. Each request with a non-existent `block_id`:
   - Scans all ~100 blocks from ConsensusDB
   - Scans all ~100 QCs from ConsensusDB  
   - Scans all batches from QuorumStoreDB
   - Performs in-memory iteration and filtering
   - Returns "block not found"
4. Concurrent requests cause sustained high database I/O, CPU, and memory usage

**Broken Invariant:** Resource Limits - "All operations must respect gas, storage, and computational limits"

The efficient implementation already exists in the `ConsensusDB` interface: [6](#0-5) 

The `get()` method provides O(1) direct lookup by `HashValue` (block ID), but is not utilized when a specific `block_id` is provided.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** (up to $10,000) per the Aptos bug bounty program, falling under resource exhaustion attacks. While the admin service has authentication requirements, the vulnerability can cause validator node performance degradation through:

- Repeated full database scans (I/O load)
- Memory allocation for all blocks/QCs/batches  
- CPU cycles for iteration and filtering
- Amplification through concurrent requests

On testnet/devnet deployments where the admin service may run without authentication, the attack surface is broader. The admin service configuration shows: [7](#0-6) 

By default, the admin service is enabled on non-mainnet chains, making testnet/devnet validators vulnerable to unauthenticated resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Access to the admin service endpoint (authenticated or on testnet/devnet)
- Ability to send HTTP requests with arbitrary parameters
- Knowledge of the endpoint path

The authentication mechanism uses SHA256 passcode verification: [8](#0-7) 

On mainnet, authentication is enforced if the service is enabled: [9](#0-8) 

However, on testnet/devnet, the service may run without authentication, increasing exploitability.

## Recommendation

Implement input validation to check block existence before performing expensive database scans. When a specific `block_id` is provided, use the O(1) direct lookup method instead of O(n) full table scan:

```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();
    let all_batches = quorum_store_db.get_all_batches()?;

    // Optimized: Use direct lookup when block_id is specified
    if let Some(block_id) = block_id {
        match consensus_db.consensus_db().get::<BlockSchema>(&block_id)? {
            Some(block) => {
                body.push_str(&format!("Block ({:?}): \n\n", block.id()));
                match extract_txns_from_block(&block, &all_batches) {
                    Ok(txns) => body.push_str(&format!("{txns:?}")),
                    Err(e) => body.push_str(&format!("Not available: {e:?}")),
                };
                body.push_str("\n\n");
            },
            None => {
                body.push_str(&format!("Done, block ({block_id:?}) is not found."));
            }
        }
    } else {
        // Only scan all blocks when no specific block_id is requested
        let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;
        for block in blocks {
            let id = block.id();
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => body.push_str(&format!("{txns:?}")),
                Err(e) => body.push_str(&format!("Not available: {e:?}")),
            };
            body.push_str("\n\n");
        }
        if body.is_empty() {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
}
```

Similar optimization should be applied to `dump_blocks_bcs()` function.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::HashValue;
    use std::time::Instant;

    #[tokio::test]
    async fn test_expensive_nonexistent_block_lookup() {
        // Setup: Create ConsensusDB with 100 blocks (typical pruned window size)
        let tmpdir = tempfile::tempdir().unwrap();
        let consensus_db = ConsensusDB::new(tmpdir.path());
        
        // Insert 100 test blocks
        let mut blocks = vec![];
        for i in 0..100 {
            let block = create_test_block(i);
            blocks.push(block);
        }
        consensus_db.save_blocks_and_quorum_certificates(blocks, vec![]).unwrap();
        
        // Attack: Query with non-existent block ID
        let nonexistent_id = HashValue::random();
        
        // Measure time for inefficient implementation (full scan)
        let start = Instant::now();
        let result = dump_blocks(&consensus_db, &quorum_store_db, Some(nonexistent_id)).unwrap();
        let scan_duration = start.elapsed();
        
        // Verify it performs full scan despite block not existing
        assert!(result.contains("is not found"));
        assert!(scan_duration.as_millis() > 10); // Significant time for full scan
        
        // Multiple concurrent requests amplify the effect
        let mut handles = vec![];
        for _ in 0..10 {
            let db = consensus_db.clone();
            let qs_db = quorum_store_db.clone();
            let handle = tokio::spawn(async move {
                dump_blocks(&db, &qs_db, Some(HashValue::random())).unwrap()
            });
            handles.push(handle);
        }
        
        // All requests perform expensive scans
        for handle in handles {
            handle.await.unwrap();
        }
    }
}
```

**Notes:**

The vulnerability is confirmed in the current implementation. The admin service endpoint lacks input validation and performs expensive full database scans even when querying for specific non-existent blocks. While access is restricted through authentication on mainnet, testnet/devnet deployments may be vulnerable to unauthenticated resource exhaustion attacks. The fix is straightforward: use the existing O(1) direct lookup method when a specific `block_id` is provided, reserving full scans only for requests without a `block_id` parameter.

### Citations

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L74-111)
```rust
pub async fn handle_dump_block_request(
    req: Request<Body>,
    consensus_db: Arc<dyn PersistentLivenessStorage>,
    quorum_store_db: Arc<dyn QuorumStoreStorage>,
) -> hyper::Result<Response<Body>> {
    let query = req.uri().query().unwrap_or("");
    let query_pairs: HashMap<_, _> = url::form_urlencoded::parse(query.as_bytes()).collect();

    let block_id: Option<HashValue> = match query_pairs.get("block_id") {
        Some(val) => match val.parse() {
            Ok(val) => Some(val),
            Err(err) => return Ok(reply_with_status(StatusCode::BAD_REQUEST, err.to_string())),
        },
        None => None,
    };

    // TODO(grao): I'm lazy, only support this through query parameters, let me know if this need
    // to be done through header.
    let bcs: bool = match query_pairs.get("bcs") {
        Some(val) => match val.parse() {
            Ok(val) => val,
            Err(err) => return Ok(reply_with_status(StatusCode::BAD_REQUEST, err.to_string())),
        },
        None => false,
    };

    if let Some(block_id) = block_id {
        info!("Dumping block ({block_id:?}).");
    } else {
        info!("Dumping all blocks.");
    }

    match spawn_blocking(move || {
        if bcs {
            dump_blocks_bcs(consensus_db.as_ref(), quorum_store_db.as_ref(), block_id)
                .map(Into::<Body>::into)
        } else {
            dump_blocks(consensus_db.as_ref(), quorum_store_db.as_ref(), block_id).map(Into::into)
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-214)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }

    if body.is_empty() {
        if let Some(block_id) = block_id {
            body.push_str(&format!("Done, block ({block_id:?}) is not found."));
        } else {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
```

**File:** consensus/src/consensusdb/mod.rs (L80-106)
```rust
    pub fn get_data(
        &self,
    ) -> Result<(
        Option<Vec<u8>>,
        Option<Vec<u8>>,
        Vec<Block>,
        Vec<QuorumCert>,
    )> {
        let last_vote = self.get_last_vote()?;
        let highest_2chain_timeout_certificate = self.get_highest_2chain_timeout_certificate()?;
        let consensus_blocks = self
            .get_all::<BlockSchema>()?
            .into_iter()
            .map(|(_, block)| block)
            .collect();
        let consensus_qcs = self
            .get_all::<QCSchema>()?
            .into_iter()
            .map(|(_, qc)| qc)
            .collect();
        Ok((
            last_vote,
            highest_2chain_timeout_certificate,
            consensus_blocks,
            consensus_qcs,
        ))
    }
```

**File:** consensus/src/consensusdb/mod.rs (L201-205)
```rust
    pub fn get_all<S: Schema>(&self) -> Result<Vec<(S::Key, S::Value)>, DbError> {
        let mut iter = self.db.iter::<S>()?;
        iter.seek_to_first();
        Ok(iter.collect::<Result<Vec<(S::Key, S::Value)>, AptosDbError>>()?)
    }
```

**File:** consensus/src/consensusdb/mod.rs (L207-209)
```rust
    pub fn get<S: Schema>(&self, key: &S::Key) -> Result<Option<S::Value>, DbError> {
        Ok(self.db.get::<S>(key)?)
    }
```

**File:** config/src/config/consensus_config.rs (L232-232)
```rust
            max_pruned_blocks_in_mem: 100,
```

**File:** config/src/config/admin_service_config.rs (L59-81)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
```

**File:** config/src/config/admin_service_config.rs (L84-106)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```
