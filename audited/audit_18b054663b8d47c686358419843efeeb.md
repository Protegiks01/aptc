# Audit Report

## Title
Proposal Equivocation via Missing Round Tracking in SafetyRules

## Summary
The `SafetyRules::sign_proposal()` function fails to track or prevent signing multiple distinct proposals for the same consensus round. A compromised validator can bypass `ProposalGenerator` and sign multiple conflicting `BlockData` structures for the same round, enabling equivocation attacks that break consensus liveness and potentially split the validator set.

## Finding Description

The vulnerability exists in the consensus proposal signing flow. When a validator creates a proposal, the flow is: [1](#0-0) 

The `proposal` (BlockData) gets signed by SafetyRules: [2](#0-1) 

**Critical Issue:** The `guarded_sign_proposal()` function checks that `block_data.round() > safety_data.last_voted_round` but **never updates or persists `last_voted_round`**. This means SafetyRules will sign multiple different proposals for the same round, as long as that round is greater than the last round that was **voted on** (not proposed).

The legitimate `ProposalGenerator` has protection via `last_round_generated`: [3](#0-2) 

However, `new_proposal_from_block_data()` and `new_proposal_from_block_data_and_signature()` are **public functions** that can be called directly, bypassing this protection: [4](#0-3) 

**Attack Scenario:**
1. Compromised validator bypasses `ProposalGenerator` and constructs `BlockData` X for round R
2. Calls `safety_rules.sign_proposal(X)` → succeeds (R > last_voted_round)
3. Constructs different `BlockData` Y for round R with different payload/QC/timestamp
4. Calls `safety_rules.sign_proposal(Y)` → **also succeeds** (last_voted_round was not updated)
5. Creates two signed blocks and selectively broadcasts them to different validators
6. Different validators receive different proposals, causing consensus split

The equivocation detection in `UnequivocalProposerElection` only triggers **after** blocks are received: [5](#0-4) 

This check happens in `process_proposal()`, which occurs **after** the malicious blocks are already broadcast: [6](#0-5) 

## Impact Explanation

This vulnerability breaks **Consensus Safety Invariant #2**: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

SafetyRules is designed as the trusted enforcement layer (often running in secure enclaves/HSMs) to prevent equivocation even when the validator node is compromised. The failure to track proposal signatures means:

- A single compromised validator can create network splits
- Different validators accept different proposals, fragmenting consensus
- Blocks may receive insufficient votes (< 2f+1), causing liveness failures  
- Repeated equivocation enables persistent denial-of-service
- Violates fundamental BFT safety guarantees

**Severity: Critical** - This is a consensus safety violation that enables equivocation attacks with a single compromised validator.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Compromised validator with code execution capability
- Ability to call SafetyRules and Block creation functions directly
- Bypassing ProposalGenerator's rate limiting

While this requires validator-level compromise, SafetyRules is specifically designed as defense-in-depth for this scenario. The vulnerability represents a fundamental design flaw where the "secure" component fails its primary purpose. Validator compromises have occurred in other chains, making this a realistic threat.

## Recommendation

SafetyRules must track and persist proposals that have been signed to prevent equivocation:

```rust
// In SafetyData struct, add:
pub last_signed_proposal: Option<(Round, HashValue)>

// In guarded_sign_proposal():
fn guarded_sign_proposal(
    &mut self,
    block_data: &BlockData,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    self.verify_author(block_data.author())?;

    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(block_data.epoch(), &safety_data)?;

    if block_data.round() <= safety_data.last_voted_round {
        return Err(Error::InvalidProposal(format!(
            "Proposed round {} is not higher than last voted round {}",
            block_data.round(),
            safety_data.last_voted_round
        )));
    }

    // NEW: Check if already signed a proposal for this round
    if let Some((signed_round, signed_hash)) = safety_data.last_signed_proposal {
        if signed_round == block_data.round() {
            let current_hash = block_data.hash();
            if signed_hash != current_hash {
                return Err(Error::ProposalEquivocation(
                    block_data.round(),
                    signed_hash,
                    current_hash,
                ));
            }
            // Allow re-signing the same proposal (idempotency)
        }
    }

    self.verify_qc(block_data.quorum_cert())?;
    self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;

    let signature = self.sign(block_data)?;
    
    // NEW: Persist the signed proposal
    safety_data.last_signed_proposal = Some((block_data.round(), block_data.hash()));
    self.persistent_storage.set_safety_data(safety_data)?;

    Ok(signature)
}
```

Additionally, make `new_proposal_from_block_data()` and `new_proposal_from_block_data_and_signature()` `pub(crate)` instead of `pub` to restrict direct access.

## Proof of Concept

```rust
// Simulated attack demonstrating multiple signatures for same round
use aptos_consensus_types::{block_data::BlockData, common::Payload};
use aptos_crypto::HashValue;

#[test]
fn test_proposal_equivocation_vulnerability() {
    // Setup: validator at round 5 with last_voted_round = 4
    let mut safety_rules = setup_safety_rules_at_round(4);
    let round = 5;
    let quorum_cert = create_valid_qc_for_round(4);
    
    // Create first proposal for round 5
    let block_data_a = BlockData::new_proposal(
        Payload::empty(true, false),
        validator_author(),
        vec![],
        round,
        timestamp_now(),
        quorum_cert.clone(),
    );
    
    // Sign first proposal - should succeed
    let signature_a = safety_rules.sign_proposal(&block_data_a).unwrap();
    
    // Create DIFFERENT proposal for SAME round 5
    let block_data_b = BlockData::new_proposal(
        Payload::empty(true, false), // different payload
        validator_author(),
        vec![(3, Author::random())], // different failed_authors
        round,
        timestamp_now() + 1000, // different timestamp
        quorum_cert,
    );
    
    // Sign second proposal - SHOULD FAIL but currently SUCCEEDS
    let signature_b = safety_rules.sign_proposal(&block_data_b);
    
    // Vulnerability: Both signatures succeed for different blocks at same round
    assert!(signature_b.is_ok(), "VULNERABILITY: SafetyRules signed two different proposals for round {}", round);
    
    // Attacker can now broadcast block_data_a to validators 1-10
    // and block_data_b to validators 11-20, causing consensus split
}
```

**Notes:**

The vulnerability exists in the core SafetyRules design. While ProposalGenerator provides protection in the normal flow, SafetyRules—as the ultimate security enforcement layer—must independently prevent proposal equivocation. The current implementation assumes honest validator code, violating defense-in-depth principles for Byzantine Fault Tolerance.

### Citations

**File:** consensus/src/round_manager.rs (L668-692)
```rust
    async fn generate_proposal(
        epoch_state: Arc<EpochState>,
        new_round_event: NewRoundEvent,
        sync_info: SyncInfo,
        proposal_generator: Arc<ProposalGenerator>,
        safety_rules: Arc<Mutex<MetricsSafetyRules>>,
        proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    ) -> anyhow::Result<ProposalMsg> {
        let proposal = proposal_generator
            .generate_proposal(new_round_event.round, proposer_election)
            .await?;
        let signature = safety_rules.lock().sign_proposal(&proposal)?;
        let signed_proposal =
            Block::new_proposal_from_block_data_and_signature(proposal, signature);
        observe_block(signed_proposal.timestamp_usecs(), BlockStage::SIGNED);
        info!(
            Self::new_log_with_round_epoch(
                LogEvent::Propose,
                new_round_event.round,
                epoch_state.epoch
            ),
            "{}", signed_proposal
        );
        Ok(ProposalMsg::new(signed_proposal, sync_info))
    }
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L565-572)
```rust
        {
            let mut last_round_generated = self.last_round_generated.lock();
            if *last_round_generated < round {
                *last_round_generated = round;
            } else {
                bail!("Already proposed in the round {}", round);
            }
        }
```

**File:** consensus/consensus-types/src/block.rs (L389-408)
```rust
    pub fn new_proposal_from_block_data(
        block_data: BlockData,
        validator_signer: &ValidatorSigner,
    ) -> anyhow::Result<Self> {
        let signature = validator_signer.sign(&block_data)?;
        Ok(Self::new_proposal_from_block_data_and_signature(
            block_data, signature,
        ))
    }

    pub fn new_proposal_from_block_data_and_signature(
        block_data: BlockData,
        signature: bls12381::Signature,
    ) -> Self {
        Block {
            id: block_data.hash(),
            block_data,
            signature: Some(signature),
        }
    }
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-87)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
    }
```
