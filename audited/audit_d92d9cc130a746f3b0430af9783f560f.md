# Audit Report

## Title
Supply Chain Attack via Profile Injection in Move Package Dependency Resolution

## Summary
The `maybe_download_package()` function uses profile-based address resolution without validating the trust boundary of profile configuration sources. An attacker can inject malicious profile configurations into Git repositories, causing developers to download and build against attacker-controlled Move packages instead of legitimate dependencies.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Package Dependency Resolution**: [1](#0-0) 

2. **Profile-Based Address Loading**: [2](#0-1) 

3. **Workspace Configuration Search**: [3](#0-2) 

The attack flow works as follows:

When resolving custom Move package dependencies, the system parses the `address` field from Move.toml [4](#0-3)  and passes it to `load_account_arg()`. This function first attempts to parse the string as a hex address, but if that fails, it loads a CLI profile with that name using `ConfigSearchMode::CurrentDirAndParents`.

The configuration search checks the current directory first before searching parent directories. This means an attacker can:

1. Create a malicious Git repository containing:
   - `.aptos/config.yaml` with a crafted profile pointing to an attacker-controlled address
   - `Move.toml` referencing the profile name (e.g., "malicious") instead of a hex address

2. When a victim clones and builds this project:
   - The system loads the attacker's `.aptos/config.yaml` from the project directory
   - Resolves the profile name to the attacker's address
   - Downloads Move packages from the attacker's blockchain address instead of the intended legitimate address

3. The attacker serves malicious Move modules that can:
   - Steal funds when deployed on-chain
   - Create backdoors in smart contracts
   - Compromise the security of dependent projects

While `.aptos/config.yaml` is added to `.gitignore` by default [5](#0-4) , an attacker can force-add it to their repository using `git add -f`, making it available to victims who clone the repository.

## Impact Explanation

This vulnerability enables **supply chain attacks** on the Move development ecosystem. The impact is **High Severity** because:

1. **Developer Tooling Compromise**: Affects all developers building Move packages from untrusted sources
2. **Silent Attack**: No warnings or validation when profiles are loaded from project directories
3. **Malicious Code Injection**: Attackers can inject arbitrary Move code into victim builds
4. **Potential Fund Loss**: If malicious packages are deployed on-chain, they can steal user funds
5. **Trust Boundary Violation**: The system trusts local configurations without distinguishing between user-controlled and project-controlled sources

While this doesn't directly compromise the blockchain consensus or validator nodes, it breaks the security of the development workflow and can lead to widespread deployment of compromised smart contracts.

## Likelihood Explanation

The likelihood is **High** because:

1. **Low Attack Complexity**: Attacker only needs to create a malicious Git repository
2. **Common Workflow**: Developers frequently clone and build projects from GitHub/GitLab
3. **No Security Warnings**: Users receive no indication that non-standard address resolution is occurring
4. **Subtle Exploitation**: Profile names can appear legitimate (e.g., "aptos-framework" instead of "0x1")
5. **No Validation**: System doesn't validate that dependency addresses are hex addresses vs. profile names

The attack requires no special privileges and exploits normal development practices.

## Recommendation

Implement the following security controls:

1. **Restrict Profile Resolution**: Only load profiles from trusted global locations (user home directory), never from project directories:

```rust
pub fn load_account_arg(str: &str) -> Result<AccountAddress, CliError> {
    if let Ok(account_address) = AccountAddress::from_str(str) {
        Ok(account_address)
    } else {
        // Only allow profile lookup from global config, never workspace
        return Err(CliError::CommandArgumentError(
            format!("Invalid account address '{}'. Dependency addresses must be hex addresses, not profile names.", str)
        ));
    }
}
```

2. **Validate Dependency Addresses**: In the manifest parser, validate that dependency addresses are valid hex addresses [4](#0-3) 

3. **Add Security Warnings**: If profile-based resolution must be supported, add prominent warnings when profiles are loaded from non-global locations

4. **Dependency Lock Files**: Implement dependency lock files with cryptographic hashes to detect malicious substitutions

## Proof of Concept

**Step 1**: Create malicious repository structure:

```bash
mkdir malicious-project
cd malicious-project

# Create malicious profile configuration
mkdir -p .aptos
cat > .aptos/config.yaml << 'EOF'
---
profiles:
  fake-framework:
    account: "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef"
EOF

# Force add to git (bypasses gitignore)
git init
git add -f .aptos/config.yaml

# Create Move.toml with dependency using profile name
cat > Move.toml << 'EOF'
[package]
name = "VictimProject"
version = "1.0.0"

[dependencies]
AptosFramework = { aptos = "https://fullnode.mainnet.aptoslabs.com/v1", address = "fake-framework", package_name = "AptosFramework" }
EOF

mkdir sources
touch sources/dummy.move
git add Move.toml sources/
git commit -m "Initial commit"
```

**Step 2**: Victim clones and builds:

```bash
cd /tmp
git clone <malicious-repo-url>
cd malicious-project
aptos move compile
```

**Expected Result**: The build system will:
1. Load `.aptos/config.yaml` from the project directory
2. Resolve "fake-framework" to `0xdeadbeef...`
3. Query the blockchain at that address for "AptosFramework" package
4. Download and incorporate attacker-controlled code instead of the legitimate framework at `0x1`

This demonstrates a complete supply chain attack where legitimate-looking Move projects can inject malicious dependencies.

## Notes

This vulnerability represents a **trust boundary violation** in the Aptos CLI tooling. The system fails to distinguish between:
- **Trusted sources**: User-configured global profiles in `~/.aptos/`
- **Untrusted sources**: Project-local profiles in workspace `.aptos/` directories

The fix requires treating all project-local configurations as untrusted and requiring explicit hex addresses for all on-chain dependencies.

### Citations

**File:** crates/aptos/src/move_tool/package_hooks.rs (L38-54)
```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info
        .download_to
        .join(CompiledPackageLayout::BuildInfo.path())
        .exists()
    {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        )
        .await?;
        let package = registry.get_package(info.package_name).await?;
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
```

**File:** crates/aptos/src/common/types.rs (L93-97)
```rust
pub const APTOS_FOLDER_GIT_IGNORE: &str = indoc! {"
    *
    testnet/
    config.yaml
"};
```

**File:** crates/aptos/src/common/types.rs (L1369-1388)
```rust
pub fn load_account_arg(str: &str) -> Result<AccountAddress, CliError> {
    if let Ok(account_address) = AccountAddress::from_str(str) {
        Ok(account_address)
    } else if let Some(Some(account_address)) =
        CliConfig::load_profile(Some(str), ConfigSearchMode::CurrentDirAndParents)?
            .map(|p| p.account)
    {
        Ok(account_address)
    } else if let Some(Some(private_key)) =
        CliConfig::load_profile(Some(str), ConfigSearchMode::CurrentDirAndParents)?
            .map(|p| p.private_key)
    {
        let public_key = private_key.public_key();
        Ok(account_address_from_public_key(&public_key))
    } else {
        Err(CliError::CommandArgumentError(
            "'--account' or '--profile' after using aptos init must be provided".to_string(),
        ))
    }
}
```

**File:** crates/aptos/src/config/mod.rs (L393-411)
```rust
fn find_workspace_config(
    starting_path: PathBuf,
    mode: ConfigSearchMode,
) -> CliTypedResult<PathBuf> {
    match mode {
        ConfigSearchMode::CurrentDir => Ok(starting_path.join(CONFIG_FOLDER)),
        ConfigSearchMode::CurrentDirAndParents => {
            let mut current_path = starting_path.clone();
            loop {
                current_path.push(CONFIG_FOLDER);
                if current_path.is_dir() {
                    break Ok(current_path);
                } else if !(current_path.pop() && current_path.pop()) {
                    // If we aren't able to find the folder, we'll create a new one right here
                    break Ok(starting_path.join(CONFIG_FOLDER));
                }
            }
        },
    }
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L394-400)
```rust
                    let address = match table.remove("address") {
                        None => bail!("Address not supplied for 'node' dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Node address not a string"))?,
                        ),
                    };
```
