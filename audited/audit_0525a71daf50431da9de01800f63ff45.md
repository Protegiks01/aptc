# Audit Report

## Title
Persistent Authentication Failure in Telemetry Sender Due to Incomplete Retry Logic After Server Key Rotation

## Summary
The telemetry sender's authentication retry mechanism has a critical flaw: when the initial authentication fails (e.g., due to a stale cached server public key), the retry logic that clears the cached key is never executed, causing all subsequent authentication attempts to fail indefinitely until the validator process is restarted.

## Finding Description

The `TelemetrySender` in the Aptos telemetry subsystem maintains a cached server public key that is used for Noise protocol handshakes during authentication. The issue lies in the incomplete retry logic in the authentication flow. [1](#0-0) 

The server public key is cached indefinitely until `reset_token()` is called: [2](#0-1) 

The retry logic in `send_authenticated_request()` is designed to call `reset_token()` when receiving a 401 Unauthorized response: [3](#0-2) 

However, this retry logic has a critical flaw. At line 104, if `get_auth_token()` fails (which happens when `authenticate()` fails due to using a stale cached key), the function returns immediately via the `?` operator. The retry logic at lines 115-121 is **never reached** because it only executes after a successful token retrieval and request execution.

**Attack Scenario:**
1. Telemetry server rotates its public key at time T
2. Validator has the old server public key cached and a valid JWT token
3. At time T+N (when JWT expires or is cleared), validator attempts to send telemetry
4. `authenticate()` is called, which uses the cached stale server public key [4](#0-3) 
5. The Noise handshake fails, server rejects the authentication request
6. Error propagates through `get_auth_token()` back to `send_authenticated_request()`
7. Line 104's `?` operator causes immediate return - retry logic at line 115 never executes
8. `reset_token()` is never called, stale key remains cached
9. All future authentication attempts use the same stale key and fail
10. Validator cannot send any telemetry data until process restart

## Impact Explanation

**Severity Assessment: Does NOT meet security vulnerability criteria**

While this bug exists and causes persistent authentication failures, the impact is limited to the telemetry subsystem only:

- **No Consensus Impact**: Telemetry is completely separate from consensus, block production, and validator operation
- **No Validator Operation Impact**: Validators continue to operate normally, produce blocks, and earn rewards
- **No State Impact**: No effect on blockchain state or data integrity  
- **Observability Loss Only**: Validators lose ability to send logs, metrics, and monitoring data

The telemetry service error handling shows all failures are logged but don't affect node operation: [5](#0-4) 

According to the Aptos bug bounty severity criteria:
- **Critical/High/Medium**: Require impact on funds, consensus, availability, or state - NOT APPLICABLE
- **Low**: "Non-critical implementation bugs" - This qualifies as an operational reliability issue, not a security vulnerability

This does **not** meet the threshold for a reportable security vulnerability under the bug bounty program.

## Likelihood Explanation

While the bug is easily triggered (server key rotation is a normal operational event), the impact is limited to telemetry availability, which is not a security-critical function. The likelihood of exploitation for security impact is zero, as there is no exploitable security consequence.

## Recommendation

Despite not qualifying as a security vulnerability, the bug should still be fixed for operational reliability:

```rust
pub async fn send_authenticated_request(
    &self,
    request_builder: RequestBuilder,
) -> Result<Response, anyhow::Error> {
    // Try getting token first
    let token_result = self.get_auth_token().await;
    
    // If token acquisition failed, clear cache and retry once
    let token = match token_result {
        Ok(t) => t,
        Err(_) => {
            self.reset_token();
            self.get_auth_token().await?
        }
    };

    let request = request_builder
        .try_clone()
        .expect("Could not clone request_builder")
        .bearer_auth(token)
        .build()?;

    let mut response = self.client.execute(request).await?;

    // Retry on 401 response
    if response.status() == StatusCode::UNAUTHORIZED {
        self.reset_token();
        let token = self.get_auth_token().await?;
        let request = request_builder.bearer_auth(token).build()?;
        response = self.client.execute(request).await?;
    }
    Ok(response)
}
```

## Proof of Concept

N/A - While the bug exists and can be demonstrated, it does not constitute a security vulnerability per the bug bounty criteria. This is an operational reliability issue in the telemetry subsystem.

---

**Note**: This issue exists as described but **fails the validation checklist** requirement: "Impact meets Critical, High, or Medium severity criteria per bounty program." The impact is limited to telemetry observability with no effect on blockchain security, consensus, validator operation, or funds. This is a non-critical operational bug, not a security vulnerability.

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L100-123)
```rust
    pub async fn send_authenticated_request(
        &self,
        request_builder: RequestBuilder,
    ) -> Result<Response, anyhow::Error> {
        let token = self.get_auth_token().await?;

        let request = request_builder
            .try_clone()
            .expect("Could not clone request_builder")
            .bearer_auth(token)
            .build()?;

        let mut response = self.client.execute(request).await?;

        // do 1 retry if the first attempt failed
        if response.status() == StatusCode::UNAUTHORIZED {
            // looks like request failed due to auth error. Let's get a new a fresh token. If this fails again we'll just return the error.
            self.reset_token();
            let token = self.get_auth_token().await?;
            let request = request_builder.bearer_auth(token).build()?;
            response = self.client.execute(request).await?;
        }
        Ok(response)
    }
```

**File:** crates/aptos-telemetry/src/sender.rs (L270-280)
```rust
    async fn server_public_key(&self) -> Result<x25519::PublicKey> {
        let server_public_key = { *self.auth_context.server_public_key.lock() };
        match server_public_key {
            Some(key) => Ok(key),
            None => {
                let public_key = self.get_public_key_from_server().await?;
                *self.auth_context.server_public_key.lock() = Some(public_key);
                Ok(public_key)
            },
        }
    }
```

**File:** crates/aptos-telemetry/src/sender.rs (L282-285)
```rust
    fn reset_token(&self) {
        *self.auth_context.token.write() = None;
        *self.auth_context.server_public_key.lock() = None;
    }
```

**File:** crates/aptos-telemetry/src/sender.rs (L287-353)
```rust
    pub async fn authenticate(&self) -> Result<String, anyhow::Error> {
        let noise_config = match &self.auth_context.noise_config {
            Some(config) => config,
            None => return Err(anyhow!("Cannot send telemetry without private key")),
        };
        let server_public_key = self.server_public_key().await?;

        // buffer to first noise handshake message
        let mut client_noise_msg = vec![0; noise::handshake_init_msg_len(0)];

        // build the prologue (chain_id | peer_id | server_public_key)
        const CHAIN_ID_LENGTH: usize = 1;
        const ID_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH;
        const PROLOGUE_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH + x25519::PUBLIC_KEY_SIZE;
        let mut prologue = [0; PROLOGUE_SIZE];
        prologue[..CHAIN_ID_LENGTH].copy_from_slice(&[self.chain_id.id()]);
        prologue[CHAIN_ID_LENGTH..ID_SIZE].copy_from_slice(self.peer_id.as_ref());
        prologue[ID_SIZE..PROLOGUE_SIZE].copy_from_slice(server_public_key.as_slice());

        let mut rng = rand::rngs::OsRng;

        // craft first handshake message  (-> e, es, s, ss)
        let initiator_state = noise_config
            .initiate_connection(
                &mut rng,
                &prologue,
                server_public_key,
                None,
                &mut client_noise_msg,
            )
            .unwrap();

        let auth_request = AuthRequest {
            chain_id: self.chain_id,
            peer_id: self.peer_id,
            role_type: self.role_type,
            server_public_key,
            handshake_msg: client_noise_msg,
            run_uuid: self.uuid,
        };

        let response = self
            .client
            .post(self.build_path("auth")?)
            .json::<AuthRequest>(&auth_request)
            .send()
            .await?;

        let resp = match error_for_status_with_body(response).await {
            Ok(response) => Ok(response.json::<AuthResponse>().await?),
            Err(err) => {
                debug!(
                    "[telemetry-client] Error sending authentication request: {}",
                    err,
                );
                Err(anyhow!("error {}", err))
            },
        }?;

        let (response_payload, _) = noise_config
            .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
            .unwrap();

        let jwt = String::from_utf8(response_payload)?;

        Ok(jwt)
    }
```

**File:** crates/aptos-telemetry/src/service.rs (L259-271)
```rust
fn try_spawn_metrics_sender(telemetry_sender: TelemetrySender) {
    if enable_prometheus_push_metrics() {
        tokio::spawn(async move {
            // Periodically send ALL prometheus metrics (This replaces the previous core and network metrics implementation)
            let mut interval =
                time::interval(Duration::from_secs(PROMETHEUS_PUSH_METRICS_FREQ_SECS));
            loop {
                interval.tick().await;
                telemetry_sender.try_push_prometheus_metrics().await;
            }
        });
    }
}
```
