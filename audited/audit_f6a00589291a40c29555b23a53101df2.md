# Audit Report

## Title
Rosetta API Balance Reconciliation Failure Due to Missing Balance Exemptions for Automatic Staking Rewards

## Summary
The Aptos Rosetta API implementation fails to declare balance exemptions for automatic staking rewards distribution, violating the Rosetta specification's reconciliation model. Account balances change at epoch boundaries without corresponding operations, breaking the fundamental invariant that `Balance = Sum(Operations)`.

## Finding Description

The Rosetta specification requires that all balance changes either have corresponding operations OR be declared via the `balance_exemptions` field. [1](#0-0) 

Currently, the Rosetta implementation returns an empty `balance_exemptions` array: [2](#0-1) 

However, automatic balance changes occur in the staking system. At each epoch boundary, the `on_new_epoch` function automatically distributes rewards to validator stake pools: [3](#0-2) 

The `update_stake_pool` function calls `distribute_rewards` which mints new AptosCoin directly into stake pools: [4](#0-3) 

The minting occurs here: [5](#0-4) 

These rewards emit `DistributeRewardsEvent` events: [6](#0-5) 

However, the Rosetta implementation does NOT parse these events into operations. The `parse_stake_pool_resource_changes` function explicitly states that balance changes are not supported: [7](#0-6) 

The Rosetta implementation only parses `0x1::staking_contract::Distribute` events, NOT the `0x1::stake::DistributeRewards` events that are emitted during automatic reward distribution: [8](#0-7) 

Meanwhile, balance queries correctly return the increased balances including rewards: [9](#0-8) 

This creates a reconciliation gap where:
1. Account balances increase due to automatic reward distribution
2. No operations are created to explain this increase
3. No balance exemptions are declared
4. Rosetta clients cannot reconcile balances

## Impact Explanation

This issue violates the Rosetta API specification but does not directly compromise blockchain security, consensus, or funds. It affects **API correctness** rather than core protocol security.

**Impact on Integrators:**
- Exchanges and custodians using Rosetta for balance reconciliation will detect mismatches
- Automated reconciliation systems will fail
- May require manual intervention or alternative balance tracking methods
- Could lead to operational issues (suspended deposits/withdrawals pending investigation)

**No Direct Security Impact:**
- Does not allow theft or loss of funds
- Does not affect consensus or validator operations
- Does not compromise state integrity
- Does not enable unauthorized access

This qualifies as **Low Severity** per the bug bounty criteria: "Non-critical implementation bugs" that affect API functionality rather than core security.

## Likelihood Explanation

**Certainty: Very High**
- Occurs automatically at every epoch boundary
- Affects all active validators and delegation pool participants
- Any Rosetta integrator tracking staking accounts will encounter this

**Frequency:**
- Epochs occur regularly (typically every 2 hours)
- Affects every validator receiving rewards
- Impacts all delegation pool delegators

## Recommendation

1. **Populate balance_exemptions field** to declare that staking rewards cause balance changes without operations:

```rust
// In crates/aptos-rosetta/src/network.rs, line 119
balance_exemptions: vec![BalanceExemption {
    // Define exemption for automatic staking rewards
    // per Rosetta spec requirements
}],
```

2. **Implement parsing of DistributeRewardsEvent** to create corresponding operations:

Add to `crates/aptos-rosetta/src/types/objects.rs`:
```rust
static DISTRIBUTE_REWARDS_EVENT_TAG: Lazy<TypeTag> =
    Lazy::new(|| parse_type_tag("0x1::stake::DistributeRewards").unwrap());
```

Modify `parse_stake_pool_resource_changes` to parse these events and create `StakingReward` operations.

3. **Update BalanceExemption struct** with proper fields per Rosetta specification.

## Proof of Concept

**Reproduction Steps:**

1. Start a validator node and join the validator set
2. Wait for an epoch transition
3. Query `/account/balance` before and after epoch - balance increases
4. Query `/block/transaction` for the epoch transition block
5. Sum all operations for the account - total does not match balance
6. Check `/network/options` - `balance_exemptions` is empty
7. Reconciliation fails: `actual_balance != sum(operations)`

**Expected Rosetta Behavior:**
- Either operations should be created for reward distribution
- OR balance_exemptions should declare this scenario

**Actual Behavior:**
- No operations created
- No balance exemptions declared
- Reconciliation invariant violated

## Notes

While this is a legitimate API specification violation that affects Rosetta integrators, it does **not** constitute a security vulnerability in the traditional sense. It does not enable:
- Theft or unauthorized access to funds
- Consensus manipulation
- State corruption
- Protocol violations affecting blockchain operation

This is an **API correctness issue** that impacts operational reconciliation for exchanges and custodians, but does not compromise the underlying blockchain security or integrity.

### Citations

**File:** crates/aptos-rosetta/src/types/objects.rs (L75-76)
```rust
static DISTRIBUTE_STAKING_REWARDS_TAG: Lazy<TypeTag> =
    Lazy::new(|| parse_type_tag("0x1::staking_contract::Distribute").unwrap());
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L100-102)
```rust
    /// A list of balance exemptions.  These should be as minimal as possible, otherwise it becomes
    /// more complicated for users
    pub balance_exemptions: Vec<BalanceExemption>,
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L1561-1574)
```rust
fn parse_stake_pool_resource_changes(
    _server_context: &RosettaContext,
    _version: u64,
    _pool_address: AccountAddress,
    _data: &[u8],
    _events: &[ContractEvent],
    _operation_index: u64,
) -> ApiResult<Vec<Operation>> {
    let operations = Vec::new();

    // We at this point only care about balance changes from the stake pool
    // TODO: Balance changes are not supported for staking at this time
    /*    if let Some(owner_address) = server_context.pool_address_to_owner.get(&pool_address) {
            if let Ok(stakepool) = bcs::from_bytes::<StakePool>(data) {
```

**File:** crates/aptos-rosetta/src/network.rs (L119-119)
```rust
        balance_exemptions: vec![],
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1344-1361)
```text
    public(friend) fun on_new_epoch(
    ) acquires AptosCoinCapabilities, PendingTransactionFee, StakePool, TransactionFeeConfig, ValidatorConfig, ValidatorPerformance, ValidatorSet {
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let config = staking_config::get();
        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);

        // Process pending stake and distribute transaction fees and rewards for each currently active validator.
        vector::for_each_ref(&validator_set.active_validators, |validator| {
            let validator: &ValidatorInfo = validator;
            update_stake_pool(validator_perf, validator.addr, &config);
        });

        // Process pending stake and distribute transaction fees and rewards for each currently pending_inactive validator
        // (requested to leave but not removed yet).
        vector::for_each_ref(&validator_set.pending_inactive, |validator| {
            let validator: &ValidatorInfo = validator;
            update_stake_pool(validator_perf, validator.addr, &config);
        });
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1693-1705)
```text
        let rewards_active = distribute_rewards(
            &mut stake_pool.active,
            num_successful_proposals,
            num_total_proposals,
            rewards_rate,
            rewards_rate_denominator
        );
        let rewards_pending_inactive = distribute_rewards(
            &mut stake_pool.pending_inactive,
            num_successful_proposals,
            num_total_proposals,
            rewards_rate,
            rewards_rate_denominator
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1738-1748)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(DistributeRewards { pool_address, rewards_amount });
        } else {
            event::emit_event(
                &mut stake_pool.distribute_rewards_events,
                DistributeRewardsEvent {
                    pool_address,
                    rewards_amount,
                },
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1806-1810)
```text
        if (rewards_amount > 0) {
            let mint_cap = &borrow_global<AptosCoinCapabilities>(@aptos_framework).mint_cap;
            let rewards = coin::mint(rewards_amount, mint_cap);
            coin::merge(stake, rewards);
        };
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L338-340)
```rust
        let total_active_stake = staking_contract_amounts_response[0];
        let accumulated_rewards = staking_contract_amounts_response[1];
        let commission_amount = staking_contract_amounts_response[2];
```
