# Audit Report

## Title
Indexer-GRPC Permanent Data Gap Due to Version Check After Dump Operation

## Summary
The `buffer_and_maybe_dump_transactions_to_file()` function in the indexer-grpc file store operator performs version checking after buffering transactions and after dump operations. When an upstream data gap occurs (missing transaction version), and a successful dump happens immediately before encountering the gap, the indexer enters an unrecoverable crash loop, creating permanent gaps in indexed blockchain data.

## Finding Description

The vulnerability exists in the order of operations within the file store operator's transaction buffering logic. The critical flaw occurs when:

1. A transaction passes the version check and is added to the buffer [1](#0-0) 

2. The internal version counter is incremented immediately after buffering [2](#0-1) 

3. If buffer threshold is reached, transactions are dumped to the file store via channel [3](#0-2) 

4. The dump operation clears the buffer and sends transactions asynchronously [4](#0-3) 

5. When the next transaction from cache has a version gap (e.g., version 102 when expecting 101), the version check fails and the process panics [5](#0-4) 

The caller uses `.unwrap()` on the result, causing immediate process termination when version mismatch is detected. Upon restart, the recovery mechanism reads the last uploaded version from file store metadata [6](#0-5)  and attempts to resume from the gap position. However, if the upstream cache still contains the same gap, the indexer requests the missing version, receives transactions starting from the next available version (skipping the gap), and crashes again in an infinite loop.

The cache's `get_transactions` method returns transactions by skipping to the requested position in the VecDeque [7](#0-6) . If a gap exists in the upstream fullnode data and gets propagated into the cache, this gap becomes permanent in the indexed data.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria under "API crashes" because:

1. **Indexer Service Unavailability**: The indexer-grpc service enters an unrecoverable crash loop, making the indexer API completely unavailable for serving blockchain data queries.

2. **Data Integrity Compromise**: Permanent gaps are created in indexed blockchain data, breaking the fundamental expectation that indexers provide complete historical transaction data.

3. **Manual Intervention Required**: Recovery requires manual database manipulation or re-indexing from scratch, which is operationally expensive and causes extended downtime.

4. **Cascading Failures**: Dependent services relying on complete indexed data (analytics, block explorers, dApps) will experience failures or incorrect behavior.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability has realistic triggering conditions:

1. **Upstream Data Issues**: Fullnodes can experience bugs, network partitions, or state sync issues that create gaps in transaction delivery [8](#0-7) 

2. **No Attacker Required**: The bug triggers from operational issues rather than malicious exploitation, making it more likely to occur naturally in production environments.

3. **Timing Window**: The vulnerability only manifests when a dump operation occurs exactly before encountering a gap in the cache, which depends on buffer size thresholds and transaction timing.

4. **Observable in Production**: Any indexer deployment connected to fullnodes experiencing data delivery issues will trigger this condition.

## Recommendation

Implement defensive gap detection and handling:

**Fix 1: Pre-validate transaction continuity before dumping**
```rust
pub async fn buffer_and_maybe_dump_transactions_to_file(
    &mut self,
    transaction: Transaction,
    tx: Sender<(Vec<Transaction>, BatchMetadata, bool)>,
) -> Result<()> {
    // Move version check to the top, before any state modification
    ensure!(
        self.version == transaction.version,
        "Gap is found when buffering transaction, expected: {}, actual: {}",
        self.version,
        transaction.version,
    );
    
    let end_batch = (transaction.version + 1) % self.num_txns_per_folder == 0;
    let size_bytes = transaction.encoded_len();
    
    self.buffer.push(transaction);
    self.buffer_size_in_bytes += size_bytes;
    self.version += 1;
    
    if self.buffer_size_in_bytes >= self.max_size_per_file || end_batch {
        self.dump_transactions_to_file(end_batch, tx).await?;
    }

    Ok(())
}
```

**Fix 2: Graceful error handling in caller**
Replace `.unwrap()` with proper error handling and alerting:
```rust
for transaction in transactions {
    if let Err(e) = file_store_operator
        .buffer_and_maybe_dump_transactions_to_file(transaction, tx.clone())
        .await 
    {
        error!("Version gap detected: {}, entering recovery mode", e);
        // Implement gap recovery logic: skip gap, alert operators, etc.
        break;
    }
}
```

**Fix 3: Implement gap recovery mechanism**
Add a recovery mode that can skip gaps and alert operators rather than crashing indefinitely.

## Proof of Concept

**Reproduction Steps:**

1. Deploy indexer-grpc connected to a fullnode
2. Simulate upstream data gap by manipulating fullnode response to skip version N
3. Ensure buffer contains transactions up to version N-1
4. Set buffer size to trigger dump exactly at version N-1
5. Observe:
   - Transaction N-1 is buffered and dumped successfully
   - File store metadata updated to version N
   - Transaction N+1 arrives (skipping N)
   - Indexer crashes with "Gap is found when buffering transaction, expected: N, actual: N+1"
6. Restart indexer
7. Observe infinite crash loop as indexer repeatedly requests version N, receives N+1, and crashes

**Test case outline:**
```rust
#[tokio::test]
async fn test_gap_after_dump_creates_permanent_gap() {
    // Setup file store operator with version 100
    // Create buffer with transactions 95-99
    // Process transaction 100 (triggers dump)
    // Attempt to process transaction 102 (skip 101)
    // Assert: panic occurs
    // Simulate restart: recover() returns version 101
    // Attempt to process transaction 102 again
    // Assert: panic occurs again (infinite loop demonstrated)
}
```

## Notes

This vulnerability is specific to the indexer-grpc auxiliary service and does not affect core blockchain consensus, validation, or execution. However, it represents a significant reliability issue for blockchain data availability through indexer APIs. The bug is triggered by upstream data quality issues rather than direct exploitation, but the impact on service availability justifies High severity classification under the "API crashes" category.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_operator.rs (L50-58)
```rust
        ensure!(
            self.version == transaction.version,
            "Gap is found when buffering transaction, expected: {}, actual: {}",
            self.version,
            transaction.version,
        );
        self.buffer.push(transaction);
        self.buffer_size_in_bytes += size_bytes;
        self.version += 1;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_operator.rs (L59-61)
```rust
        if self.buffer_size_in_bytes >= self.max_size_per_file || end_batch {
            self.dump_transactions_to_file(end_batch, tx).await?;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_operator.rs (L66-88)
```rust
    async fn dump_transactions_to_file(
        &mut self,
        end_batch: bool,
        tx: Sender<(Vec<Transaction>, BatchMetadata, bool)>,
    ) -> Result<()> {
        let transactions = std::mem::take(&mut self.buffer);
        let first_version = transactions.first().unwrap().version;
        self.buffer_batch_metadata.files.push(FileMetadata {
            first_version,
            last_version: first_version + transactions.len() as u64,
            size_bytes: self.buffer_size_in_bytes,
        });
        self.buffer_size_in_bytes = 0;

        tx.send((transactions, self.buffer_batch_metadata.clone(), end_batch))
            .await
            .map_err(anyhow::Error::msg)?;

        if end_batch {
            self.buffer_batch_metadata = BatchMetadata::default();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L87-117)
```rust
    async fn recover(&self) -> Result<(u64, BatchMetadata)> {
        let _timer = TIMER.with_label_values(&["recover"]).start_timer();

        let mut version = self
            .reader
            .get_latest_version()
            .await
            .expect("Latest version must exist.");
        info!("Starting recovering process, current version in storage: {version}.");
        let mut num_folders_checked = 0;
        let mut buffered_batch_metadata_to_recover = BatchMetadata::default();
        while let Some(batch_metadata) = self.reader.get_batch_metadata(version).await {
            let batch_last_version = batch_metadata.files.last().unwrap().last_version;
            version = batch_last_version;
            if version % NUM_TXNS_PER_FOLDER != 0 {
                buffered_batch_metadata_to_recover = batch_metadata;
                break;
            }
            num_folders_checked += 1;
            if num_folders_checked >= MAX_NUM_FOLDERS_TO_CHECK_FOR_RECOVERY {
                panic!(
                    "File store metadata is way behind batch metadata, data might be corrupted."
                );
            }
        }

        self.update_file_store_metadata(version).await?;

        info!("Finished recovering process, recovered at version: {version}.");

        Ok((version, buffered_batch_metadata_to_recover))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L166-171)
```rust
                    for transaction in transactions {
                        file_store_operator
                            .buffer_and_maybe_dump_transactions_to_file(transaction, tx.clone())
                            .await
                            .unwrap();
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L92-143)
```rust
    fn get_transactions(
        &self,
        start_version: u64,
        max_size_bytes: usize,
        update_file_store_version: bool,
    ) -> Vec<Transaction> {
        if !update_file_store_version {
            trace!(
            "Requesting version {start_version} from cache, update_file_store_version = {update_file_store_version}.",
        );
            trace!(
                "Current data range in cache: [{}, {}).",
                self.start_version,
                self.start_version + self.transactions.len() as u64
            );
        }
        if start_version < self.start_version {
            return vec![];
        }

        let mut transactions = vec![];
        let mut size_bytes = 0;
        for transaction in self
            .transactions
            .iter()
            .skip((start_version - self.start_version) as usize)
        {
            size_bytes += transaction.encoded_len();
            transactions.push(transaction.clone());
            if size_bytes > max_size_bytes {
                // Note: We choose to not pop the last transaction here, so the size could be
                // slightly larger than the `max_size_bytes`. This is fine.
                break;
            }
        }
        if update_file_store_version {
            if !transactions.is_empty() {
                let old_version = self
                    .file_store_version
                    .fetch_add(transactions.len() as u64, Ordering::SeqCst);
                let new_version = old_version + transactions.len() as u64;
                FILE_STORE_VERSION_IN_CACHE.set(new_version as i64);
                info!("Updated file_store_version in cache to {new_version}.");
            }
        } else {
            trace!(
                "Returned {} transactions from Cache, total {size_bytes} bytes.",
                transactions.len()
            );
        }
        transactions
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L207-230)
```rust
            let request = GetTransactionsFromNodeRequest {
                starting_version: Some(cache.start_version + cache.transactions.len() as u64),
                transactions_count: Some(100000),
            };
            drop(cache);

            debug!(
                "Requesting transactions from fullnodes, starting_version: {}.",
                request.starting_version.unwrap()
            );
            let (address, mut fullnode_client) =
                self.metadata_manager.get_fullnode_for_request(&request);
            trace!("Fullnode ({address}) is picked for request.");
            let response = fullnode_client.get_transactions_from_node(request).await;
            if response.is_err() {
                warn!(
                    "Error when getting transactions from fullnode ({address}): {}",
                    response.err().unwrap()
                );
                tokio::time::sleep(Duration::from_millis(100)).await;
                continue;
            } else {
                trace!("Got success response from fullnode.");
            }
```
