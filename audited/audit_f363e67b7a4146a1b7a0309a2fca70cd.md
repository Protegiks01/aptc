# Audit Report

## Title
Critical Validator Panic via Unsupported Transaction Shuffler Types in OnChainExecutionConfig Deployment

## Summary
The `generate_execution_config_upgrade_proposal` function and the Move framework's `execution_config::set_for_next_epoch` function lack validation of `TransactionShufflerType` values. This allows governance proposals to deploy execution configs with deprecated shuffler types (`SenderAwareV2` or `DeprecatedFairness`) that trigger `unreachable!()` panics in all validators when the next epoch starts, causing complete network unavailability requiring a hard fork to recover.

## Finding Description

The Aptos blockchain allows on-chain governance to update execution configuration parameters via the `execution_config::set_for_next_epoch` Move function. However, there are **no validation checks** to prevent dangerous transaction shuffler types from being deployed.

### Validation Gap in Rust Code

In the release builder, the `generate_execution_config_upgrade_proposal` function only validates that the BCS-serialized config is less than 65536 bytes: [1](#0-0) 

The function performs no validation of the `TransactionShufflerType` field within the config.

### Validation Gap in Move Framework

The Move framework's `set_for_next_epoch` function only checks that:
1. The caller is the aptos_framework signer
2. The config bytes are not empty [2](#0-1) 

No validation of the actual config content is performed.

### The Dangerous Code Path

The `TransactionShufflerType` enum includes deprecated variants that are explicitly marked as unsupported: [3](#0-2) 

When validators start a new epoch, the `create_transaction_shuffler` function is called with the shuffler type from the on-chain config. This function contains `unreachable!()` calls for deprecated types: [4](#0-3) 

### The Trigger Point

During epoch initialization, all validators call `start_epoch`, which creates the transaction shuffler: [5](#0-4) 

### Attack Path

1. An attacker (or mistaken operator) creates a governance proposal containing:
   ```rust
   OnChainExecutionConfig::V7(ExecutionConfigV7 {
       transaction_shuffler_type: TransactionShufflerType::SenderAwareV2(32),
       // ... other fields ...
   })
   ```
   OR
   ```rust
   transaction_shuffler_type: TransactionShufflerType::DeprecatedFairness
   ```

2. The proposal passes governance voting and is executed via `aptos_governance::resolve`

3. The config is stored on-chain via `execution_config::set_for_next_epoch` with no validation

4. At the next epoch boundary (triggered by `reconfiguration_with_dkg::finish`), the config becomes active

5. All validators simultaneously call `start_epoch` â†’ `create_transaction_shuffler`

6. All validators hit `unreachable!()` at line 79 or 82 and panic

7. The entire network becomes unavailable with all validators crashed

## Impact Explanation

This vulnerability falls under **Critical Severity** per the Aptos Bug Bounty program:
- **"Total loss of liveness/network availability"** - All validators crash simultaneously when the malicious config activates
- **"Non-recoverable network partition (requires hardfork)"** - Recovery requires either:
  - A coordinated hard fork to revert the config change
  - Manual intervention to patch all validator binaries to handle the panic gracefully

The impact is catastrophic because:
1. **Affects all validators simultaneously** - No partial degradation, instant total failure
2. **Automatic trigger** - Happens at epoch boundary without additional input
3. **No recovery mechanism** - The panic prevents validators from starting, blocking any on-chain governance fix
4. **Breaks deterministic execution invariant** - While all validators crash identically, this violates the liveness requirement

## Likelihood Explanation

**Likelihood: Medium-to-High**

**Factors increasing likelihood:**
- Governance proposals are the standard mechanism for config updates
- The deprecated shuffler types exist in the codebase and are valid enum variants
- No validation prevents their use
- Could occur accidentally during config migration or testing
- An attacker with governance proposal access could intentionally trigger this

**Factors decreasing likelihood:**
- Requires governance approval (but governance participants are not considered adversarial in the trust model)
- Default configs use safe values
- Most operators would likely test proposals, though the panic only triggers at epoch start

**Realistic scenarios:**
1. **Accidental misconfiguration** - Developer copies old config with `SenderAwareV2` during upgrade
2. **Malicious governance participant** - Insider submits malicious proposal
3. **Supply chain attack** - Compromised release tooling generates bad configs

## Recommendation

Implement validation in multiple layers:

### 1. Add Validation in Move Framework

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Validate the config can be deserialized and contains valid parameters
    assert!(is_valid_execution_config(&config), error::invalid_argument(EINVALID_CONFIG));
    
    config_buffer::upsert(ExecutionConfig { config });
}

// Add validation function
native fun is_valid_execution_config(config: &vector<u8>): bool;
```

### 2. Implement Native Validation Function

In Rust, add a native function to validate the config:

```rust
// In aptos-move/framework/aptos-framework/src/natives/execution_config.rs
pub fn native_is_valid_execution_config(
    _context: &mut NativeContext,
    _ty_args: Vec<Type>,
    mut args: VecDeque<Value>,
) -> PartialVMResult<NativeResult> {
    let config_bytes = pop_arg!(args, Vec<u8>);
    
    match bcs::from_bytes::<OnChainExecutionConfig>(&config_bytes) {
        Ok(config) => {
            // Validate shuffler type is supported
            match config.transaction_shuffler_type() {
                TransactionShufflerType::SenderAwareV2(_) |
                TransactionShufflerType::DeprecatedFairness => {
                    return Ok(NativeResult::ok(0.into(), smallvec![Value::bool(false)]));
                },
                _ => {}
            }
            Ok(NativeResult::ok(0.into(), smallvec![Value::bool(true)]))
        },
        Err(_) => Ok(NativeResult::ok(0.into(), smallvec![Value::bool(false)])),
    }
}
```

### 3. Add Validation in Release Builder

```rust
pub fn generate_execution_config_upgrade_proposal(
    execution_config: &OnChainExecutionConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    // Validate the config before generating proposal
    match execution_config.transaction_shuffler_type() {
        TransactionShufflerType::SenderAwareV2(_) |
        TransactionShufflerType::DeprecatedFairness => {
            bail!("Unsupported transaction shuffler type: {:?}. Use NoShuffling or UseCaseAware instead.", 
                  execution_config.transaction_shuffler_type());
        },
        _ => {}
    }
    
    // ... rest of the function
}
```

### 4. Make Deprecated Variants Non-Constructible

Consider removing the deprecated variants from the public API or marking them as `#[doc(hidden)]` to prevent accidental use.

## Proof of Concept

### Move Script PoC (Triggers the Vulnerability)

```move
script {
    use aptos_framework::execution_config;
    use aptos_framework::aptos_governance;
    
    fun malicious_execution_config(framework_signer: &signer) {
        // This config contains SenderAwareV2, which will cause validators to panic
        // The actual bytes would be BCS-encoded OnChainExecutionConfig::V7 with SenderAwareV2
        let malicious_config: vector<u8> = x"0700000003000000020000000000000001000000...<rest of BCS bytes>";
        
        execution_config::set_for_next_epoch(framework_signer, malicious_config);
        aptos_governance::reconfigure(framework_signer);
    }
}
```

### Rust Unit Test PoC (Demonstrates the Panic)

```rust
#[test]
#[should_panic(expected = "SenderAware shuffler is no longer supported")]
fn test_unsupported_shuffler_causes_panic() {
    use aptos_types::on_chain_config::{OnChainExecutionConfig, ExecutionConfigV7, TransactionShufflerType};
    use crate::transaction_shuffler::create_transaction_shuffler;
    
    let bad_config = OnChainExecutionConfig::V7(ExecutionConfigV7 {
        transaction_shuffler_type: TransactionShufflerType::SenderAwareV2(32),
        block_gas_limit_type: BlockGasLimitType::NoLimit,
        enable_per_block_gas_limit: false,
        transaction_deduper_type: TransactionDeduperType::NoDedup,
        gas_price_to_burn: 0,
        persisted_auxiliary_info_version: 0,
    });
    
    // This will panic with "unreachable!" when validators start the epoch
    let _shuffler = create_transaction_shuffler(bad_config.transaction_shuffler_type());
}
```

**Notes:**
- This vulnerability affects the core consensus layer and would cause **total network unavailability**
- The issue exists because deprecated enum variants were left in the codebase with `unreachable!()` guards instead of being properly handled or removed
- A defense-in-depth approach with validation at multiple layers (Move, native, and Rust tooling) is essential to prevent this class of issues

### Citations

**File:** aptos-move/aptos-release-builder/src/components/execution_config.rs (L11-51)
```rust
pub fn generate_execution_config_upgrade_proposal(
    execution_config: &OnChainExecutionConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    emitln!(writer, "// Execution config upgrade proposal\n");
    let config_comment = format!("// config: {:#?}", execution_config).replace('\n', "\n// ");
    emitln!(writer, "{}\n", config_comment);

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::execution_config"],
        |writer| {
            let execution_config_blob = bcs::to_bytes(execution_config).unwrap();
            assert!(execution_config_blob.len() < 65536);

            emit!(writer, "let execution_blob: vector<u8> = ");
            generate_blob_as_hex_string(writer, &execution_config_blob);
            emitln!(writer, ";\n");

            emitln!(
                writer,
                "execution_config::set_for_next_epoch({}, execution_blob);",
                signer_arg
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("execution-config".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L48-52)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        config_buffer::upsert(ExecutionConfig { config });
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L228-240)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum TransactionShufflerType {
    NoShuffling,
    DeprecatedSenderAwareV1(u32),
    SenderAwareV2(u32),
    DeprecatedFairness,
    UseCaseAware {
        sender_spread_factor: usize,
        platform_use_case_spread_factor: usize,
        user_use_case_spread_factor: usize,
    },
}
```

**File:** consensus/src/transaction_shuffler/mod.rs (L64-101)
```rust
pub fn create_transaction_shuffler(
    shuffler_type: TransactionShufflerType,
) -> Arc<dyn TransactionShuffler> {
    use TransactionShufflerType::*;

    match shuffler_type {
        NoShuffling => {
            info!("Using no-op transaction shuffling");
            Arc::new(NoOpShuffler {})
        },
        DeprecatedSenderAwareV1(_) => {
            info!("Using no-op sender aware shuffling v1");
            Arc::new(NoOpShuffler {})
        },
        SenderAwareV2(_) => {
            unreachable!("SenderAware shuffler is no longer supported.")
        },
        DeprecatedFairness => {
            unreachable!("DeprecatedFairness shuffler is no longer supported.")
        },
        UseCaseAware {
            sender_spread_factor,
            platform_use_case_spread_factor,
            user_use_case_spread_factor,
        } => {
            let config = use_case_aware::Config {
                sender_spread_factor,
                platform_use_case_spread_factor,
                user_use_case_spread_factor,
            };
            info!(
                config = ?config,
                "Using use case aware transaction shuffling."
            );
            Arc::new(use_case_aware::UseCaseAwareShuffler { config })
        },
    }
}
```

**File:** consensus/src/pipeline/execution_client.rs (L560-561)
```rust
        let transaction_shuffler =
            create_transaction_shuffler(onchain_execution_config.transaction_shuffler_type());
```
