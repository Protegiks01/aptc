# Audit Report

## Title
Fail-Open Security Check Bypass When chain_id Extraction Fails in ExecutionConfig Sanitization

## Summary
The `ExecutionConfig::sanitize()` method fails open when `chain_id` is `None`, completely bypassing critical mainnet security checks for `paranoid_type_verification` and `paranoid_hot_potato_verification`. Since the chain ID extraction from genesis can fail for multiple realistic reasons (corrupted/missing genesis file, malformed genesis), a mainnet node could inadvertently run without essential Move VM runtime type safety checks, creating a consensus divergence risk.

## Finding Description

The vulnerability exists in the configuration sanitization flow where mainnet-specific security requirements are only enforced when the chain ID can be successfully extracted from the genesis transaction.

**The Fail-Open Pattern:** [1](#0-0) 

The sanitization logic only validates paranoid verification settings inside an `if let Some(chain_id) = chain_id` block. When `chain_id` is `None`, the function returns `Ok(())` without any validation, allowing a mainnet node to run with `paranoid_type_verification = false` and `paranoid_hot_potato_verification = false`.

**How chain_id Becomes None:** [2](#0-1) 

The `extract_node_type_and_chain_id()` function catches errors from `get_chain_id()` and continues with `None`, merely printing a warning. The `get_chain_id()` function can fail due to: [3](#0-2) 

- Missing genesis transaction
- Wrong transaction type
- Chain ID not present in genesis write set
- Deserialization errors

**Security Impact:**

When `paranoid_type_verification` is disabled, the Move VM runs without critical runtime type checks: [4](#0-3) 

These paranoid checks are designed to catch VM implementation bugs and enforce type safety invariants during bytecode execution: [5](#0-4) 

**Attack Scenarios:**

1. **Malicious Operator**: An attacker with filesystem access corrupts or deletes the genesis file on a mainnet validator
2. **Accidental Misconfiguration**: A node operator uses an incorrect genesis file path or damaged genesis blob
3. **Genesis File Corruption**: Filesystem errors corrupt the genesis file during node operation

In all cases, the node starts successfully but runs without essential type safety checks, potentially executing Move bytecode differently than properly configured nodes.

## Impact Explanation

This vulnerability has **HIGH severity** per Aptos bug bounty criteria:

1. **Consensus Divergence Risk**: If some validators have correctly configured nodes with paranoid checks enabled while others have misconfigured nodes with checks disabled, they may produce different execution results for the same transactions. This violates the **Deterministic Execution** invariant.

2. **Significant Protocol Violation**: The paranoid type checks use the `EPARANOID_FAILURE` error code to catch VM invariant violations. Without these checks, VM bugs that would normally be caught could go undetected, leading to state corruption.

3. **Mainnet Security Guarantee Bypass**: The configuration explicitly requires these checks for mainnet nodes. The fail-open behavior subverts this security requirement.

This meets the "Significant protocol violations" criteria for HIGH severity ($50,000 tier).

## Likelihood Explanation

**MEDIUM to HIGH likelihood:**

1. **Realistic Scenarios**: Genesis file corruption, incorrect file paths, or using wrong genesis files are common operational errors, especially during node setup or migration.

2. **Silent Failure**: The system only prints a warning to stdout and continues - there's no hard failure or obvious indication that security checks are disabled.

3. **Wide Attack Surface**: Any entity with filesystem access (compromised operators, malicious insiders, or automated attacks exploiting other vulnerabilities) could trigger this condition.

4. **Long-lived Impact**: Once a node starts with this misconfiguration, it continues running indefinitely without the security checks until restart with proper configuration.

## Recommendation

**Fix 1: Fail Closed When chain_id Cannot Be Determined**

Modify `extract_node_type_and_chain_id()` to return an error when chain ID extraction fails, forcing node startup to fail rather than continue with reduced security:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    let chain_id = get_chain_id(node_config)?; // Propagate error instead of suppressing
    Ok((node_type, chain_id))
}
```

**Fix 2: Always Enforce Mainnet Checks (Defense in Depth)**

Add an additional check in `ExecutionConfig::sanitize()` that enforces paranoid verification regardless of chain_id when certain indicators suggest mainnet operation:

```rust
fn sanitize(
    node_config: &NodeConfig,
    _node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = Self::get_sanitizer_name();
    let execution_config = &node_config.execution;

    // If chain_id cannot be determined, enforce conservative defaults
    if chain_id.is_none() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Cannot sanitize execution config: chain ID could not be determined from genesis transaction!".into(),
        ));
    }

    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() {
            // existing checks...
        }
    }

    Ok(())
}
```

**Fix 3: Validate Genesis File Integrity Earlier**

Add explicit genesis file validation in `ExecutionConfig::load_from_path()` to detect corruption before node startup: [6](#0-5) 

## Proof of Concept

```rust
#[test]
fn test_sanitize_mainnet_bypass_with_none_chain_id() {
    // Create a mainnet-like node config with paranoid checks DISABLED
    let node_config = NodeConfig {
        execution: ExecutionConfig {
            paranoid_hot_potato_verification: false,  // INSECURE!
            paranoid_type_verification: false,         // INSECURE!
            ..Default::default()
        },
        ..Default::default()
    };

    // Sanitize with chain_id = None (simulating genesis extraction failure)
    // This should FAIL but actually PASSES due to fail-open bug
    let result = ExecutionConfig::sanitize(
        &node_config, 
        NodeType::Validator, 
        None  // Chain ID extraction failed!
    );

    // BUG: This passes when it should fail!
    assert!(result.is_ok(), "VULNERABILITY: Mainnet security checks bypassed!");

    // For comparison, with proper chain_id, it correctly fails:
    let result_with_mainnet = ExecutionConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet())
    );
    assert!(result_with_mainnet.is_err(), "Correctly fails with mainnet chain_id");
}

#[test]
fn test_genesis_extraction_failure_propagation() {
    // Simulate a node config with missing/corrupted genesis
    let mut node_config = NodeConfig::default();
    node_config.execution.genesis_file_location = PathBuf::from("/nonexistent/genesis.blob");
    node_config.execution.paranoid_type_verification = false;
    node_config.execution.paranoid_hot_potato_verification = false;

    // Attempt to extract chain_id (will fail due to missing file)
    let (node_type, chain_id) = extract_node_type_and_chain_id(&node_config);
    
    // BUG: chain_id is None, security checks will be bypassed
    assert!(chain_id.is_none(), "Chain ID extraction failed as expected");
    
    // Sanitize should fail closed, but instead passes:
    let result = NodeConfig::sanitize(&node_config, node_type, chain_id);
    assert!(result.is_ok(), "VULNERABILITY: Sanitization passes with None chain_id!");
}
```

## Notes

This vulnerability also affects other config sanitizers with the same pattern: [7](#0-6) [8](#0-7) 

The fail-open pattern is systemic across the configuration sanitization framework. A comprehensive fix should address all sanitizers to fail closed when chain_id is indeterminate.

### Citations

**File:** config/src/config/execution_config.rs (L100-140)
```rust
    pub fn load_from_path(&mut self, root_dir: &RootPath) -> Result<(), Error> {
        if !self.genesis_file_location.as_os_str().is_empty() {
            // Ensure the genesis file exists
            let genesis_path = root_dir.full_path(&self.genesis_file_location);
            if !genesis_path.exists() {
                return Err(Error::Unexpected(format!(
                    "The genesis file could not be found! Ensure the given path is correct: {:?}",
                    genesis_path.display()
                )));
            }

            // Open the genesis file and read the bytes
            let mut file = File::open(&genesis_path).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to open the genesis file: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
            let mut buffer = vec![];
            file.read_to_end(&mut buffer).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to read the genesis file into a buffer: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;

            // Deserialize the genesis file and store it
            let genesis = bcs::from_bytes(&buffer).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to BCS deserialize the genesis file: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
            self.genesis = Some(genesis);
        }

        Ok(())
    }
```

**File:** config/src/config/execution_config.rs (L157-187)
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;

        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/node_config_loader.rs (L112-124)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
}
```

**File:** config/src/config/node_config_loader.rs (L158-198)
```rust
fn get_chain_id(node_config: &NodeConfig) -> Result<ChainId, Error> {
    // TODO: can we make this less hacky?

    // Load the genesis transaction from disk
    let genesis_txn = get_genesis_txn(node_config).ok_or_else(|| {
        Error::InvariantViolation("The genesis transaction was not found!".to_string())
    })?;

    // Extract the chain ID from the genesis transaction
    match genesis_txn {
        Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set)) => {
            let chain_id_state_key = StateKey::on_chain_config::<ChainId>()?;

            // Get the write op from the write set
            let write_set_mut = change_set.clone().write_set().clone().into_mut();
            let write_op = write_set_mut.get(&chain_id_state_key).ok_or_else(|| {
                Error::InvariantViolation(
                    "The genesis transaction does not contain the write op for the chain id!"
                        .into(),
                )
            })?;

            // Extract the chain ID from the write op
            let write_op_bytes = write_op.bytes().ok_or_else(|| Error::InvariantViolation(
                "The genesis transaction does not contain the correct write op for the chain ID!".into(),
            ))?;
            let chain_id = ChainId::deserialize_into_config(write_op_bytes).map_err(|error| {
                Error::InvariantViolation(format!(
                    "Failed to deserialize the chain ID: {:?}",
                    error
                ))
            })?;

            Ok(chain_id)
        },
        _ => Err(Error::InvariantViolation(format!(
            "The genesis transaction has the incorrect type: {:?}!",
            genesis_txn
        ))),
    }
}
```

**File:** aptos-node/src/utils.rs (L53-56)
```rust
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L19-37)
```rust
pub(crate) trait RuntimeTypeCheck {
    /// Paranoid type checks to perform before instruction execution.
    fn pre_execution_type_stack_transition(
        frame: &Frame,
        operand_stack: &mut Stack,
        instruction: &Instruction,
        ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()>;

    /// Paranoid type checks to perform after instruction execution.
    fn post_execution_type_stack_transition(
        frame: &Frame,
        operand_stack: &mut Stack,
        instruction: &Instruction,
        ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()>;

    /// For any other checks are performed externally
    fn should_perform_checks(for_fun: &Function) -> bool;
```

**File:** config/src/config/config_sanitizer.rs (L74-109)
```rust
fn sanitize_failpoints_config(
    node_config: &NodeConfig,
    _node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints = &node_config.failpoints;

    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }

    // Ensure that the failpoints config is populated appropriately
    if let Some(failpoints) = failpoints {
        if failpoints_enabled && failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are enabled, but the failpoints config is empty?".into(),
            ));
        } else if !failpoints_enabled && !failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are disabled, but the failpoints config is not empty!".into(),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/api_config.rs (L178-185)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```
