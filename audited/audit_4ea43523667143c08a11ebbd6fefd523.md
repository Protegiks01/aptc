# Audit Report

## Title
Consensus Split Vulnerability During Validator Set Changes Due to Epoch-Agnostic JWK Update Verification

## Summary
During validator set changes, the JWK consensus system lacks epoch-awareness in both message routing and quorum certificate verification, causing validators in different epochs to accept or reject the same JWK update transaction differently, leading to potential consensus splits and chain forks.

## Finding Description

The vulnerability stems from a fundamental architectural flaw where `QuorumCertifiedUpdate` structures lack epoch information, combined with silent message dropping during epoch transitions. This breaks the critical invariant: **"All validators must produce identical state roots for identical blocks."**

**Critical Design Flaws:**

1. **No Epoch Filtering at Network Layer**: [1](#0-0) 
   The `NetworkTask::start()` function forwards all RPC requests without epoch validation, blindly queuing messages regardless of epoch compatibility.

2. **Silent Message Dropping**: [2](#0-1) 
   The `process_rpc_request()` function silently discards messages with mismatched epochs without sending error responses, causing reliable broadcast protocols to timeout waiting for responses that will never arrive.

3. **Epoch-Agnostic Quorum Certificates**: [3](#0-2) 
   The `QuorumCertifiedUpdate` structure contains no epoch field, only a `ProviderJWKs` update and an `AggregateSignature` multi-sig.

4. **Validator-Ordering-Dependent Bitmask**: [4](#0-3) [5](#0-4) 
   The `AggregateSignature` uses a `BitVec` bitmask to identify signers by their index position in the validator set. The `get_signers_addresses()` method maps bitmask indices to validators using the provided ordering.

5. **Current-Epoch-Only Verification**: [6](#0-5) 
   The `process_jwk_update_inner()` function always loads the **current** `ValidatorSet` and verifies signatures against it, with no mechanism to verify against the epoch when signatures were created.

**Attack Scenario:**

1. **Epoch N Setup**: Validators have ordering `[Alice@0, Bob@1, Charlie@2, Dave@3, Eve@4]`

2. **JWK Consensus in Progress**: A reliable broadcast creates a `QuorumCertifiedUpdate` with:
   - Signatures from Alice, Bob, Charlie
   - Bitmask: `11100` (bits 0, 1, 2 set)
   - Multi-sig aggregated from their BLS signatures

3. **Epoch Transition to N+1**: Validator set changes to `[Alice@0, Frank@1, George@2, Henry@3, Ivan@4]` (Bob, Charlie, Dave, Eve removed; Frank, George, Henry, Ivan added)

4. **Validator Split During Transition**:
   - Validators Alice, Frank, George transition to epoch N+1
   - Validators Dave, Eve still in epoch N
   - JWK consensus messages with epoch N arrive at Alice/Frank/George
   - Messages are silently dropped (epoch mismatch check fails)
   - No RPC responses sent back
   - Reliable broadcast cannot complete quorum

5. **Transaction Verification Divergence**: If the `QuorumCertifiedUpdate` reaches the validator transaction pool:
   - **Validators in Epoch N** (Dave, Eve):
     - Load epoch N validator set `[Alice, Bob, Charlie, Dave, Eve]`
     - Bitmask `11100` maps to Alice@0, Bob@1, Charlie@2
     - Aggregate their public keys and verify signature ✓ **ACCEPTS**
   
   - **Validators in Epoch N+1** (Alice, Frank, George):
     - Load epoch N+1 validator set `[Alice, Frank, George, Henry, Ivan]`
     - Bitmask `11100` maps to Alice@0, Frank@1, George@2
     - Aggregate public keys of Alice, Frank, George (wrong signers!)
     - Signature verification fails because signature is from Alice, Bob, Charlie ✗ **REJECTS**

6. **Consensus Split**: When a block containing this `ValidatorTransaction::ObservedJWKUpdate` is proposed:
   - Validators verifying against epoch N accept the block
   - Validators verifying against epoch N+1 reject the block
   - **Chain fork occurs**

**Invariant Violations:**

1. **Deterministic Execution Broken**: Same transaction produces different results on different validators
2. **Consensus Safety Broken**: Validators cannot agree on valid blocks due to divergent JWK update acceptance
3. **State Consistency Broken**: Different validators have different views of the JWK state

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability falls under **"Consensus/Safety violations"** and **"Non-recoverable network partition (requires hardfork)"**:

1. **Chain Split**: Different validators accept/reject the same block containing JWK updates, causing the network to fork into incompatible chains.

2. **Irrecoverable Without Hardfork**: Once validators diverge on which JWK updates are valid, they have different state roots. Validators cannot sync because they fundamentally disagree on transaction validity based on which epoch's validator set they're using for verification.

3. **Authentication System Compromise**: JWK (JSON Web Key) consensus manages the cryptographic keys used for keyless account authentication. State divergence here means different validators recognize different sets of valid authentication keys, breaking the authentication system.

4. **No Byzantine Fault Required**: This vulnerability triggers through normal protocol operation during validator set changes, not requiring any Byzantine actors.

## Likelihood Explanation

**Likelihood: HIGH** 

This vulnerability will trigger whenever:
1. A validator set change occurs (validators joining/leaving)
2. JWK consensus is active and creates quorum certificates
3. The epoch transition timing coincides with JWK update propagation

Validator set changes are regular occurrences in Aptos through:
- Governance proposals adding/removing validators
- Validators voluntarily leaving the set
- Stake-based validator rotation

JWK consensus runs continuously to monitor OIDC provider key rotations, making race conditions with epoch transitions inevitable over time.

## Recommendation

**Required Fixes:**

1. **Add Epoch to QuorumCertifiedUpdate**:
```rust
pub struct QuorumCertifiedUpdate {
    pub epoch: u64,  // ADD THIS FIELD
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

2. **Epoch-Aware Verification** in `aptos-move/aptos-vm/src/validator_txns/jwk.rs`:
```rust
fn process_jwk_update_inner(
    &self,
    resolver: &impl AptosMoveResolver,
    current_epoch: u64,  // Pass current epoch
    update: jwks::QuorumCertifiedUpdate,
) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
    // Reject if QC is from old epoch
    if update.epoch < current_epoch {
        return Err(Expected(ObsoleteEpoch));
    }
    
    // Load validator set from the QC's epoch
    let validator_set = ValidatorSet::fetch_config_for_epoch(resolver, update.epoch)
        .ok_or(Expected(MissingResourceValidatorSet))?;
    
    // Verify against THAT epoch's validator set
    let verifier = ValidatorVerifier::from(&validator_set);
    // ... rest of verification
}
```

3. **Network-Layer Epoch Filtering** in `crates/aptos-jwk-consensus/src/network.rs`:
```rust
pub async fn start(mut self, current_epoch: Arc<AtomicU64>) {
    while let Some(message) = self.all_events.next().await {
        match message {
            Event::RpcRequest(peer_id, msg, protocol, response_sender) => {
                // Check epoch BEFORE forwarding
                if msg.epoch() != current_epoch.load(Ordering::Relaxed) {
                    // Send error response instead of silent drop
                    let error = Err(anyhow!("Epoch mismatch"));
                    let _ = response_sender.send(error);
                    continue;
                }
                // ... forward to manager
            }
        }
    }
}
```

4. **Clear VTxn Pool on Epoch Transition**: Ensure validator transaction pool is cleared of epoch-N transactions when transitioning to epoch N+1.

## Proof of Concept

```rust
#[tokio::test]
async fn test_jwk_consensus_split_on_validator_set_change() {
    // Setup: Create epoch N with validators [A, B, C, D, E]
    let epoch_n_validators = vec![
        validator_address("Alice"),
        validator_address("Bob"),
        validator_address("Charlie"),
        validator_address("Dave"),
        validator_address("Eve"),
    ];
    let epoch_n_state = create_epoch_state(100, epoch_n_validators);
    
    // Create a JWK update and sign with Alice, Bob, Charlie (indices 0,1,2)
    let jwk_update = create_jwk_update("https://issuer.com");
    let mut partial_sigs = PartialSignatures::empty();
    for validator in &["Alice", "Bob", "Charlie"] {
        let sig = sign_update(&jwk_update, validator);
        partial_sigs.add_signature(validator_address(validator), sig);
    }
    
    let verifier_n = ValidatorVerifier::from(&epoch_n_state);
    let multi_sig = verifier_n.aggregate_signatures(partial_sigs.signatures_iter()).unwrap();
    let qc = QuorumCertifiedUpdate {
        update: jwk_update.clone(),
        multi_sig: multi_sig.clone(),
    };
    
    // Verify in epoch N: Should succeed
    let result_n = verifier_n.verify_multi_signatures(&jwk_update, &multi_sig);
    assert!(result_n.is_ok(), "Verification should succeed in epoch N");
    
    // Transition to epoch N+1 with different validator set [Alice, Frank, George, Henry, Ivan]
    let epoch_n1_validators = vec![
        validator_address("Alice"),   // Same at index 0
        validator_address("Frank"),   // NEW at index 1
        validator_address("George"),  // NEW at index 2
        validator_address("Henry"),   // NEW at index 3
        validator_address("Ivan"),    // NEW at index 4
    ];
    let epoch_n1_state = create_epoch_state(101, epoch_n1_validators);
    let verifier_n1 = ValidatorVerifier::from(&epoch_n1_state);
    
    // Get signers in epoch N+1 context - bitmask 11100 now maps to [Alice, Frank, George]
    let signers_n1 = multi_sig.get_signers_addresses(
        &verifier_n1.get_ordered_account_addresses()
    );
    assert_eq!(signers_n1, vec![
        validator_address("Alice"),
        validator_address("Frank"),   // WRONG! Should be Bob
        validator_address("George"),  // WRONG! Should be Charlie
    ]);
    
    // Verify in epoch N+1: Should FAIL (signature is from Alice,Bob,Charlie not Alice,Frank,George)
    let result_n1 = verifier_n1.verify_multi_signatures(&jwk_update, &multi_sig);
    assert!(result_n1.is_err(), "Verification should FAIL in epoch N+1 due to validator set change");
    
    // This demonstrates the consensus split:
    // - Validators in epoch N accept the transaction
    // - Validators in epoch N+1 reject the same transaction
    // - Chain fork occurs
}
```

## Notes

The vulnerability requires validator set **reordering or membership changes** between epochs. If the validator set remains identical (only configuration changes), the bitmask indices remain valid. However, any addition, removal, or reordering of validators triggers the vulnerability.

The issue is exacerbated by the lack of error handling when messages are dropped during epoch transitions, causing reliable broadcast protocols to timeout silently rather than failing fast and retrying with the correct epoch.

### Citations

**File:** crates/aptos-jwk-consensus/src/network.rs (L188-210)
```rust
    pub async fn start(mut self) {
        while let Some(message) = self.all_events.next().await {
            match message {
                Event::RpcRequest(peer_id, msg, protocol, response_sender) => {
                    let req = IncomingRpcRequest {
                        msg,
                        sender: peer_id,
                        response_sender: Box::new(RealRpcResponseSender {
                            inner: Some(response_sender),
                            protocol,
                        }),
                    };

                    if let Err(e) = self.rpc_tx.push(peer_id, (peer_id, req)) {
                        warn!(error = ?e, "aptos channel closed");
                    };
                },
                _ => {
                    // Ignore
                },
            }
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L94-105)
```rust
    fn process_rpc_request(
        &mut self,
        peer_id: Author,
        rpc_request: IncomingRpcRequest,
    ) -> Result<()> {
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
    }
```

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** types/src/aggregate_signature.rs (L16-19)
```rust
pub struct AggregateSignature {
    validator_bitmask: BitVec,
    sig: Option<bls12381::Signature>,
}
```

**File:** types/src/aggregate_signature.rs (L43-58)
```rust
    pub fn get_signers_addresses(
        &self,
        validator_addresses: &[AccountAddress],
    ) -> Vec<AccountAddress> {
        validator_addresses
            .iter()
            .enumerate()
            .filter_map(|(index, addr)| {
                if self.validator_bitmask.is_set(index as u16) {
                    Some(*addr)
                } else {
                    None
                }
            })
            .collect()
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-142)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```
