# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Causes JWK Consensus Liveness Failure

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization via `.to_string()`, which can produce different payload bytes across validators when processing JWKs containing numeric fields. This prevents JWK consensus from reaching quorum, causing a liveness failure for JWK updates.

## Finding Description

The vulnerability exists in the conversion of JSON Web Keys to `UnsupportedJWK` structures. When validators observe JWKs from external OIDC providers, unsupported key types are stored as raw JSON bytes. [1](#0-0) 

The critical line uses `json_value.to_string()` to serialize the JSON, but this is not canonical. The TODO comment explicitly acknowledges this issue. The payload bytes are then hashed to create an ID. [2](#0-1) 

**Attack Flow:**

1. An OIDC provider publishes JWKs with numeric fields (e.g., timestamps, version numbers as floats)
2. Validators independently fetch these JWKs [3](#0-2) 

3. Each validator parses the JSON and converts unsupported types via `JWK::from(serde_json::Value)` [4](#0-3) 

4. Different platforms/Rust versions may serialize floating-point numbers with different precision (e.g., `1.234567890123456` vs `1.2345678901234567`)

5. Validators generate different `UnsupportedJWK.payload` bytes, resulting in different hash IDs

6. During consensus aggregation, validators compare their observations [5](#0-4) 

7. The check `self.local_view == peer_view` fails because `ProviderJWKs` contain different `UnsupportedJWK` payloads

8. No quorum can be reached, preventing `QuorumCertifiedUpdate` creation

9. JWK updates for that provider cannot be committed to chain

This breaks the **Deterministic Execution** invariant (Invariant #1) at the JWK consensus layer, though not at the core blockchain consensus layer.

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity under "State inconsistencies requiring intervention":
- JWK updates become permanently blocked for affected OIDC providers
- Keyless authentication relying on those providers cannot function with updated keys
- Requires manual intervention (validator upgrades, provider configuration changes, or governance action)
- Does NOT affect core blockchain consensus or state
- Does NOT risk funds directly
- System fails safely (refuses to commit) rather than creating inconsistent state

The impact is limited to the JWK consensus subsystem, not core blockchain operations.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Current State (Low):**
- Standard JWK formats (RSA, EC, OKP) use only string fields, which serialize deterministically
- Most validators run similar software stacks
- Within the same serde_json version, number serialization is typically consistent

**Future Risk (Medium):**
- New cryptographic key types (e.g., post-quantum) may introduce numeric parameters
- Validators may run on heterogeneous platforms (x86 vs ARM, different OS)
- Long-lived networks with gradual validator software upgrades
- Federated keyless authentication allows external OIDC providers with arbitrary JWK formats

The codebase already includes test scenarios for validators receiving different JWK payloads: [6](#0-5) 

## Recommendation

Replace non-canonical `.to_string()` with RFC 8785 canonical JSON serialization:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization (RFC 8785)
        let payload = canonicalize_json(&json_value)
            .expect("JSON canonicalization failed")
            .into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}

// Implement RFC 8785 canonical JSON
fn canonicalize_json(value: &serde_json::Value) -> Result<String> {
    // Sort object keys lexicographically
    // Remove insignificant whitespace
    // Use minimal numeric representation
    // Escape unicode consistently
    // ...
}
```

Alternatively, use a well-tested canonical JSON library like `serde_jcs` or implement deterministic serialization that:
1. Sorts all object keys lexicographically
2. Uses minimal numeric representation (no trailing zeros, scientific notation for large values)
3. Removes all unnecessary whitespace
4. Handles unicode escaping consistently

The workspace-level `serde_json` configuration already uses `arbitrary_precision` and `preserve_order`: [7](#0-6) 

However, this is insufficient for true canonical serialization.

## Proof of Concept

```rust
#[test]
fn test_floating_point_non_determinism() {
    use serde_json::Value;
    use types::jwks::unsupported::UnsupportedJWK;
    
    // Simulate JWK with floating-point field
    let json_str1 = r#"{"kty":"experimental","version":1.23456789012345678901234567890}"#;
    let json_str2 = r#"{"kty":"experimental","version":1.234567890123456789}"#;
    
    let value1: Value = serde_json::from_str(json_str1).unwrap();
    let value2: Value = serde_json::from_str(json_str2).unwrap();
    
    let jwk1 = UnsupportedJWK::from(value1);
    let jwk2 = UnsupportedJWK::from(value2);
    
    // These should be semantically equivalent but may have different payloads
    // due to floating-point precision handling
    println!("JWK1 payload: {}", String::from_utf8_lossy(&jwk1.payload));
    println!("JWK2 payload: {}", String::from_utf8_lossy(&jwk2.payload));
    println!("JWK1 ID: {}", hex::encode(&jwk1.id));
    println!("JWK2 ID: {}", hex::encode(&jwk2.id));
    
    // This may fail if serialization differs
    assert_eq!(jwk1.id, jwk2.id, "Same semantic value should produce same ID");
}
```

To demonstrate actual platform differences, validators would need to be deployed on different architectures and the JWK observation compared. The existing `MindChangingServer` and `EquivocatingServer` test infrastructure could be extended to inject platform-specific serialization differences.

---

**Notes:**
- The TODO comment on line 53 confirms developers are aware this needs canonical serialization
- Current JWK formats (RSA) are unaffected as they use only string fields
- The vulnerability becomes exploitable when future unsupported JWK types use numeric fields
- This is a liveness issue, not a safety violation - the system fails safely by refusing to commit inconsistent data

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** testsuite/smoke-test/src/jwks/dummy_provider/request_handler.rs (L80-119)
```rust
/// This server first replies with `initial_thoughts`.
/// After enough audience receives it for at least once, it switches its reply to `second_thoughts`.
///
/// This behavior simulates the situation where a provider performs a 2nd key rotation right after the 1st.
pub struct MindChangingServer {
    initial_thoughts: Vec<u8>,
    second_thoughts: Vec<u8>,
    change_mind_threshold: usize,
    requesters_observed: Mutex<HashSet<AccountAddress>>,
}

impl MindChangingServer {
    pub fn new(
        initial_thoughts: Vec<u8>,
        second_thoughts: Vec<u8>,
        change_mind_threshold: usize,
    ) -> Self {
        Self {
            initial_thoughts,
            second_thoughts,
            change_mind_threshold,
            requesters_observed: Mutex::new(HashSet::new()),
        }
    }
}

impl RequestHandler for MindChangingServer {
    fn handle(&self, request: Request<Body>) -> Vec<u8> {
        let mut requesters_observed = self.requesters_observed.lock();
        let origin = origin_from_cookie(&request);
        if requesters_observed.contains(&origin)
            || requesters_observed.len() >= self.change_mind_threshold
        {
            self.second_thoughts.clone()
        } else {
            requesters_observed.insert(origin);
            self.initial_thoughts.clone()
        }
    }
}
```

**File:** Cargo.toml (L789-792)
```text
serde_json = { version = "1.0.81", features = [
    "preserve_order",
    "arbitrary_precision",
] } # Note: arbitrary_precision is required to parse u256 in JSON
```
