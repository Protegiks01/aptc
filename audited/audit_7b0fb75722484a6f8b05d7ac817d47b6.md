# Audit Report

## Title
Missing Validation of TimeoutCertificate HQC Round Against Local One-Chain Round in Voting Safety Rules

## Summary
The `safe_to_vote()` function in the 2-chain consensus safety rules does not validate that a TimeoutCertificate's `hqc_round` is at least as high as the validator's local `one_chain_round`, creating an asymmetry with `safe_to_timeout()` which enforces this check. This allows validators to vote on proposals referencing outdated TimeoutCertificates, potentially enabling consensus inconsistencies.

## Finding Description

The 2-chain consensus protocol uses two critical safety functions in `consensus/safety-rules/src/safety_rules_2chain.rs`: [1](#0-0) 

The `safe_to_timeout()` function validates that `timeout.hqc_round() >= safety_data.one_chain_round` before allowing a validator to sign a timeout. This ensures validators do not timeout with QCs older than what they've already observed. [2](#0-1) 

However, `safe_to_vote()` has **no corresponding validation** that the TC's `hqc_round` is `>= safety_data.one_chain_round`. It only checks that `block.qc.round >= tc.hqc_round` without considering the validator's local state.

The `one_chain_round` field tracks the highest QC round a validator has observed: [3](#0-2) [4](#0-3) 

**Attack Scenario:**

1. An honest validator V has observed QCs up to round 10, so `safety_data.one_chain_round = 10`
2. Due to network partition, validators A, B, C (forming 2f+1 quorum) only have QCs up to round 5
3. They legitimately timeout in round 11, creating a TC with `hqc_round = 5`
4. A Byzantine proposer sends V a proposal for round 12 with:
   - The TC for round 11 (`hqc_round = 5`)
   - A QC for round 6-9 (older than V's `one_chain_round = 10`)
5. V's `safe_to_vote()` check: `round(12) == tc_round(11) + 1 && qc_round(6-9) >= hqc_round(5)` â†’ **Passes**
6. V votes on a proposal with an outdated QC, regressing from round 10 to 6-9

This breaks the invariant that validators should vote based on the most recent state they've observed, potentially creating chain inconsistencies.

## Impact Explanation

**Severity: High**

This vulnerability enables:
- **Consensus Safety Risk**: Validators can vote on proposals that regress to older chain states, potentially causing validators to vote on conflicting forks
- **Protocol Violation**: Breaks the consistency principle that validators should not accept proposals with QCs older than their observed state
- **State Regression**: Allows chain progress to "go backwards" in terms of certified rounds

While the TC itself is cryptographically valid (has 2f+1 signatures), the semantic validation is missing. The asymmetry with `safe_to_timeout()` indicates this is unintended behavior rather than design choice.

Per Aptos bug bounty criteria, this qualifies as **High Severity** due to "Significant protocol violations" in the consensus layer.

## Likelihood Explanation

**Likelihood: Medium to High**

This can occur through:
1. **Network Asynchrony** (no malice required): Network partitions naturally cause validators to have different views of the latest QCs. When 2f+1 validators create a legitimate TC with outdated HQCs, Byzantine proposers can exploit this.
2. **Byzantine Proposer Exploitation**: A single malicious proposer can craft proposals exploiting legitimately outdated TCs to cause honest validators to vote on regressed states.

The attack does NOT require:
- Validator collusion beyond f Byzantine (the TC can be legitimately created by honest validators under network partition)
- Control of 2f+1 validators
- Cryptographic breaks

The asymmetry with `safe_to_timeout()` strongly suggests this is a bug rather than intentional design.

## Recommendation

Add validation in `safe_to_vote()` consistent with `safe_to_timeout()` by passing `safety_data` and checking the TC's `hqc_round` against `one_chain_round`:

```rust
fn safe_to_vote(
    &self,
    block: &Block,
    maybe_tc: Option<&TwoChainTimeoutCertificate>,
    safety_data: &SafetyData,  // ADD THIS PARAMETER
) -> Result<(), Error> {
    let round = block.round();
    let qc_round = block.quorum_cert().certified_block().round();
    let tc_round = maybe_tc.map_or(0, |tc| tc.round());
    let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
    
    // ADD THIS CHECK when using TC path
    if let Some(tc) = maybe_tc {
        if hqc_round < safety_data.one_chain_round {
            return Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round));
        }
    }
    
    if round == next_round(qc_round)?
        || (round == next_round(tc_round)? && qc_round >= hqc_round)
    {
        Ok(())
    } else {
        Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
    }
}
```

Update the caller at: [5](#0-4) 

to pass `&safety_data` to the function.

## Proof of Concept

Add this test to `consensus/safety-rules/src/tests/suite.rs`:

```rust
#[test]
fn test_2chain_vote_rejects_outdated_tc_hqc() {
    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Build chain: genesis -> b1(r1) -> b2(r2) -> ... -> b10(r10)
    let mut prev_qc = genesis_qc.clone();
    for round in 1..=10 {
        let proposal = test_utils::make_proposal_with_qc(round, prev_qc, &signer);
        let vote = safety_rules.construct_and_sign_vote_two_chain(&proposal, None).unwrap();
        prev_qc = test_utils::make_qc_from_vote(&vote, &signer);
    }
    
    // Validator has one_chain_round = 10
    assert_eq!(safety_rules.consensus_state().unwrap().one_chain_round(), 10);
    
    // Create TC with outdated hqc_round = 5
    let outdated_qc = /* QC for round 5 */;
    let tc = test_utils::make_timeout_cert(11, &outdated_qc, &signer);
    
    // Proposal for round 12 with QC for round 6
    let qc_round_6 = /* QC for round 6 */;
    let proposal = test_utils::make_proposal_with_qc(12, qc_round_6, &signer);
    
    // This should FAIL but currently PASSES
    let result = safety_rules.construct_and_sign_vote_two_chain(&proposal, Some(tc));
    assert!(result.is_err(), "Should reject vote on proposal with TC.hqc_round < one_chain_round");
}
```

This test demonstrates that the current implementation accepts votes on proposals with TCs referencing outdated HQCs, which violates the consistency principle enforced by `safe_to_timeout()`.

## Notes

The root cause is the asymmetric validation between `safe_to_timeout()` (which checks `qc_round >= one_chain_round`) and `safe_to_vote()` (which does not check `hqc_round >= one_chain_round`). Both functions serve similar safety purposes and should enforce consistent constraints. The TC verification at [6](#0-5)  only validates cryptographic properties, not semantic consistency with local validator state.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L81-81)
```rust
        self.safe_to_vote(proposed_block, timeout_cert)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L180-188)
```rust
    fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            tc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```
