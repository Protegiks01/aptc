# Audit Report

## Title
Trust Model Bypass: Untrusted Peers Can Forge ValidatorFullNode Role on VFN Networks to Bypass Connection Limits

## Summary
Validators running on the VFN (Validator Full Node) network in MaybeMutual authentication mode incorrectly assign `PeerRole::ValidatorFullNode` to untrusted peers through network context inference. This allows malicious actors to bypass the `inbound_connection_limit` entirely, enabling resource exhaustion attacks against validator infrastructure.

## Finding Description

The vulnerability exists in the role determination logic during the Noise handshake for inbound connections. The security assumption in the connection limit enforcement code states that any peer with a role other than `PeerRole::Unknown` is trusted and authenticated. [1](#0-0) 

However, this assumption is **violated** in MaybeMutual authentication mode on VFN networks. The Noise handshake's role inference logic automatically assigns `PeerRole::ValidatorFullNode` to any peer connecting to a validator on the VFN network, **regardless of whether that peer is in the trusted peers set**: [2](#0-1) 

The critical flaw occurs at line 410 where untrusted peers are assigned `ValidatorFullNode` role purely based on network topology inference, without cryptographic authentication against the trusted peers set.

By default, validators on VFN networks use MaybeMutual mode (not Mutual mode): [3](#0-2) 

Since `is_validator_network()` only returns true for `NetworkId::Validator`, the VFN network (`NetworkId::Vfn`) defaults to `mutual_authentication = false`, enabling MaybeMutual mode: [4](#0-3) 

**Attack Flow:**
1. Attacker generates valid Noise IK keypair (no special keys required)
2. Attacker connects to validator on VFN network
3. Noise handshake completes successfully
4. Since attacker is not in trusted peers set, code reaches role inference logic
5. Server is a validator (`network_context.role().is_validator()` = true)
6. Network is VFN (`network_id.is_vfn_network()` = true)
7. Attacker is assigned `PeerRole::ValidatorFullNode` without authentication
8. Connection metadata is created with this forged role: [5](#0-4) 

9. In `handle_new_connection_event`, the connection limit check at line 355 evaluates to false because `conn.metadata.role == PeerRole::ValidatorFullNode` (not Unknown): [6](#0-5) 

10. Connection is accepted, bypassing all limits
11. Attacker repeats steps 1-10 to exhaust validator resources

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Total Loss of Liveness/Network Availability**: An attacker can open unlimited inbound connections to validators on the VFN network, exhausting file descriptors, memory, and CPU resources. This directly impacts validator availability and consensus participation.

2. **Consensus Safety Violation**: By DoSing validators that bridge the validator network and VFN network, an attacker can partition the network, potentially preventing validators from reaching consensus quorum or causing network splits.

3. **Non-recoverable Network Partition**: If enough validators on VFN networks are simultaneously exhausted, the network could enter a state requiring manual intervention or hardfork to recover.

The vulnerability breaks the **Resource Limits** and **Consensus Safety** invariants. Validators must be protected from resource exhaustion to maintain liveness and consensus participation.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: None beyond basic network access. No validator keys, stake, or insider access required.
- **Complexity**: Low. The attack requires only:
  - Generating standard x25519 keypairs
  - Connecting to publicly advertised validator VFN endpoints
  - Repeating connections until resources exhausted
- **Detection Difficulty**: Moderate. Connections appear legitimate with valid Noise handshakes and non-Unknown peer roles.
- **Deployment**: VFN networks are widely deployed in production by default for validator-to-VFN communication.

## Recommendation

The role inference logic must not assign privileged roles to untrusted peers. Fix the logic in `upgrade_inbound` to return `PeerRole::Unknown` for all peers not in the trusted set when using MaybeMutual mode:

```rust
HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
    let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
    let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
    match trusted_peer {
        Some(peer) => {
            Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
        },
        None => {
            // Verify peer ID matches public key to prevent spoofing
            let derived_remote_peer_id =
                aptos_types::account_address::from_identity_public_key(
                    remote_public_key,
                );
            if derived_remote_peer_id != remote_peer_id {
                Err(NoiseHandshakeError::ClientPeerIdMismatch(
                    remote_peer_short,
                    remote_peer_id,
                    derived_remote_peer_id,
                ))
            } else {
                // FIXED: Always return Unknown for untrusted peers
                // Do NOT infer roles based on network context
                Ok(PeerRole::Unknown)
            }
        },
    }
}
```

**Alternative**: Use Mutual authentication mode for VFN networks to reject all untrusted peers at the handshake level, or implement separate connection limits per role that apply to all roles including inferred ones.

## Proof of Concept

```rust
// PoC: Demonstrate untrusted peer bypassing connection limits on VFN network

#[tokio::test]
async fn test_vfn_role_forgery_bypass() {
    use aptos_config::config::{NetworkId, PeerRole, RoleType};
    use aptos_config::network_id::NetworkContext;
    use aptos_crypto::x25519;
    use aptos_types::PeerId;
    
    // Setup: Validator on VFN network with MaybeMutual auth
    let validator_peer_id = PeerId::random();
    let validator_network_context = NetworkContext::new(
        RoleType::Validator,
        NetworkId::Vfn,
        validator_peer_id,
    );
    
    // Validator has trusted peers set (empty for this test)
    let peers_and_metadata = Arc::new(PeersAndMetadata::new(&[NetworkId::Vfn]));
    
    // Attacker generates random keypair (untrusted)
    let mut rng = rand::rngs::OsRng;
    let attacker_private_key = x25519::PrivateKey::generate(&mut rng);
    let attacker_public_key = attacker_private_key.public_key();
    let attacker_peer_id = aptos_types::account_address::from_identity_public_key(
        attacker_public_key
    );
    
    // Setup validator's Noise upgrader with MaybeMutual mode
    let validator_upgrader = NoiseUpgrader::new(
        validator_network_context,
        x25519::PrivateKey::generate(&mut rng),
        HandshakeAuthMode::maybe_mutual(peers_and_metadata.clone()),
    );
    
    // Setup attacker's Noise upgrader
    let attacker_network_context = NetworkContext::new(
        RoleType::FullNode,
        NetworkId::Vfn,
        attacker_peer_id,
    );
    let attacker_upgrader = NoiseUpgrader::new(
        attacker_network_context,
        attacker_private_key,
        HandshakeAuthMode::maybe_mutual(peers_and_metadata),
    );
    
    // Perform handshake
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    
    let (attacker_result, validator_result) = tokio::join!(
        attacker_upgrader.upgrade_outbound(
            dialer_socket,
            validator_peer_id,
            validator_upgrader.noise_config.public_key(),
            AntiReplayTimestamps::now,
        ),
        validator_upgrader.upgrade_inbound(listener_socket),
    );
    
    // Verify attacker successfully connected
    assert!(attacker_result.is_ok());
    let (_, _, peer_role) = validator_result.unwrap();
    
    // VULNERABILITY: Untrusted attacker is assigned ValidatorFullNode role!
    assert_eq!(peer_role, PeerRole::ValidatorFullNode);
    
    // This peer_role will bypass the connection limit check at line 355
    // because it's not PeerRole::Unknown
    
    println!("EXPLOIT SUCCESS: Untrusted peer assigned ValidatorFullNode role");
    println!("Connection limit bypass enabled for attacker");
}
```

## Notes

This vulnerability specifically affects the VFN network deployment which is critical for validator infrastructure. The code comment at line 353-354 in `peer_manager/mod.rs` incorrectly assumes that the Noise handshake only assigns non-Unknown roles to authenticated peers, but the MaybeMutual mode's role inference violates this assumption for network topology-based assignments.

### Citations

**File:** network/framework/src/peer_manager/mod.rs (L353-354)
```rust
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
```

**File:** network/framework/src/peer_manager/mod.rs (L355-389)
```rust
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```

**File:** network/framework/src/noise/handshake.rs (L406-422)
```rust
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
```

**File:** config/src/config/network_config.rs (L136-136)
```rust
        let mutual_authentication = network_id.is_validator_network();
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/transport/mod.rs (L320-331)
```rust
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
```
