# Audit Report

## Title
Missing Transaction Signature Validation During Database Restore Operations

## Summary
The Aptos database restore mechanism does not validate transaction signatures when replaying transactions from backup files. Both the normal restore path and KV-only replay mode use `VerifyExecutionMode::NoVerify`, which bypasses signature verification entirely. This creates a gap in defense-in-depth where corrupted or maliciously modified backup data could be restored without detecting invalid signatures.

## Finding Description

During database restore operations, transactions are loaded from backup files and saved to the database through multiple code paths, none of which validate transaction signatures:

**Path 1: Transactions saved before replay version** [1](#0-0) 

These transactions are saved directly using `restore_handler.save_transactions()` without any signature validation.

**Path 2: KV-only replay mode** [2](#0-1) 

Transactions are saved using `save_transactions_and_replay_kv()` which applies write sets but never validates signatures.

**Path 3: Restore coordinator uses NoVerify mode** [3](#0-2) 

Phase 1 restore explicitly uses `VerifyExecutionMode::NoVerify`. [4](#0-3) 

Phase 2 restore also uses `VerifyExecutionMode::NoVerify`.

**What gets validated vs. what doesn't:**
The restore process DOES validate:
- Transaction accumulator Merkle proofs [5](#0-4) 

- Ledger info signatures (from validators) [6](#0-5) 

But it does NOT validate individual transaction signatures.

**Why signatures aren't checked:**
When `VerifyExecutionMode::NoVerify` is used, the execution verification is skipped: [7](#0-6) 

The signature verification would normally happen during transaction conversion: [8](#0-7) 

And during VM execution, invalid signatures are caught: [9](#0-8) 

But since `NoVerify` mode skips execution, these checks never run.

**Broken Invariant:**
This violates the invariant: "Transaction Validation: All transactions in the ledger must have valid signatures." While normal operation enforces this during transaction submission, the restore path does not re-verify it, creating a defense-in-depth gap.

## Impact Explanation

**Severity Assessment: Medium**

This issue does NOT meet Critical or High severity because:

1. **Cryptographic Protection**: To exploit this, an attacker would need to either:
   - Compromise backup storage AND forge BLS multi-signatures from validators (cryptographically infeasible per trust model)
   - Exploit a separate vulnerability that allows invalid signatures during normal operation
   - Cause physical data corruption in backup files

2. **Limited Attack Surface**: The vulnerability cannot be exploited by:
   - Regular transaction senders
   - Malicious peers
   - Move module deployers
   - Anyone without access to backup infrastructure

However, it qualifies as **Medium severity** because:

1. **Defense-in-depth violation**: If backup storage is compromised or data corruption occurs, invalid transactions would be accepted without detection
2. **State inconsistency risk**: Nodes restored from corrupted backups could have invalid transactions in their ledger, requiring manual intervention
3. **Trust model assumption**: The system assumes backups are trustworthy, but doesn't verify this assumption during restore

## Likelihood Explanation

**Likelihood: Low to Medium**

While the attack path requires either cryptographic forgery or backup compromise (both difficult), the risk of data corruption in backup storage is non-negligible:

1. **Storage failures**: Backup systems can experience bit rot, hardware failures, or software bugs
2. **Supply chain attacks**: Compromised backup infrastructure could inject invalid data
3. **Operator errors**: Backup restoration from incorrect or corrupted sources

The likelihood increases if:
- Backups are stored on untrusted infrastructure
- Multiple backup sources are used without verification
- Automated restore processes run without operator oversight

## Recommendation

**Fix: Always validate transaction signatures during restore**

Modify the restore coordinator to use `VerifyExecutionMode::Verify` instead of `NoVerify`:

```rust
// In storage/backup/backup-cli/src/coordinators/restore.rs

// Phase 1 restore - change line 296:
TransactionRestoreBatchController::new(
    transaction_restore_opt,
    Arc::clone(&self.storage),
    txn_manifests,
    Some(db_next_version),
    Some((kv_replay_version, true)),
    epoch_history.clone(),
    VerifyExecutionMode::verify_all(), // Changed from NoVerify
    None,
)

// Phase 2 restore - change line 367:
TransactionRestoreBatchController::new(
    self.global_opt,
    self.storage,
    txn_manifests,
    first_version,
    replay_version,
    epoch_history,
    VerifyExecutionMode::verify_all(), // Changed from NoVerify
    None,
)
```

**Alternative: Add explicit signature validation in save path**

Add signature verification before saving transactions:

```rust
// In storage/aptosdb/src/backup/restore_utils.rs
// Add validation before line 206:

pub(crate) fn save_transactions_impl(
    // ... existing parameters
) -> Result<()> {
    // Validate all transaction signatures before saving
    for txn in txns.iter() {
        if let Transaction::UserTransaction(user_txn) = txn {
            user_txn.verify_signature()
                .map_err(|_| anyhow!("Invalid transaction signature during restore"))?;
        }
    }
    
    // ... rest of existing implementation
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a simple PoC because it requires:
1. Access to backup file creation/modification
2. Either cryptographic forgery (infeasible) or simulation of data corruption

**Conceptual demonstration:**

```rust
// This would be a test showing the vulnerability exists
#[test]
fn test_restore_accepts_invalid_signatures() {
    // 1. Create a valid transaction
    let valid_txn = create_signed_transaction(/* valid params */);
    
    // 2. Corrupt the signature
    let mut corrupted_txn = valid_txn.clone();
    corrupted_txn.authenticator_mut().corrupt_signature();
    
    // 3. Create backup with corrupted transaction
    // (This requires manipulating backup files and Merkle proofs)
    let backup = create_backup_with_transaction(corrupted_txn);
    
    // 4. Restore from backup
    let restore_result = restore_from_backup(backup, VerifyExecutionMode::NoVerify);
    
    // 5. Verify corrupted transaction was accepted
    assert!(restore_result.is_ok()); // Bug: should fail but doesn't
    
    // 6. Verify transaction is in database with invalid signature
    let restored_txn = db.get_transaction(version);
    assert!(!restored_txn.verify_signature().is_ok()); // Invalid signature accepted
}
```

**Note**: A full working PoC would require extensive setup including backup file manipulation and is not practical without access to internal test infrastructure. The vulnerability is demonstrated through code analysis showing the missing validation path.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L156-167)
```rust
        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-517)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L591-600)
```rust
                    tokio::task::spawn_blocking(move || {
                        // we directly save transaction and kvs to DB without involving chunk executor
                        handler.save_transactions_and_replay_kv(
                            base_version,
                            &txns,
                            &persisted_aux_info,
                            &txn_infos,
                            &events,
                            write_sets,
                        )?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L289-300)
```rust
            TransactionRestoreBatchController::new(
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L360-371)
```rust
            TransactionRestoreBatchController::new(
                self.global_opt,
                self.storage,
                txn_manifests,
                first_version,
                replay_version,
                epoch_history,
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L561-575)
```rust
            // Try to run the transactions with the VM
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-139)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2881-2885)
```rust
        if let SignatureVerifiedTransaction::Invalid(_) = txn {
            let vm_status = VMStatus::error(StatusCode::INVALID_SIGNATURE, None);
            let discarded_output = discarded_output(vm_status.status_code());
            return Ok((vm_status, discarded_output));
        }
```
