# Audit Report

## Title
Missing Economic Penalty Integration for Proposal Equivocation in Consensus Layer

## Summary
When a validator attempts to propose multiple different blocks for the same round, the equivocation is detected and logged, but there is no integration with the on-chain slashing or penalty mechanisms. Byzantine validators face no economic consequences for attempting equivocation beyond having their duplicate proposal rejected.

## Finding Description

The `UnequivocalProposerElection::is_valid_proposal()` function detects when a proposer submits multiple different blocks for the same round: [1](#0-0) 

When equivocation is detected, the function:
1. Logs a security event (`SecurityEvent::InvalidConsensusProposal`)
2. Returns `false` to reject the duplicate proposal

However, this detection is **not integrated** with any slashing or penalty mechanism. The `RoundManager` simply rejects the proposal: [2](#0-1) 

**Critical Gap**: The validator performance tracking system in `stake.move` tracks `failed_proposals` for validators who fail to propose at all, but does NOT track or penalize equivocation attempts: [3](#0-2) 

The `failed_proposer_indices` parameter only contains validators who failed to propose in their designated rounds (computed by `compute_failed_authors`), not validators who attempted equivocation: [4](#0-3) 

While the staking framework has placeholder code for future slashing support, it is not implemented: [5](#0-4) 

**Attack Scenario**: A Byzantine validator can:
1. Propose block A for round N
2. Immediately propose block B (different content) for round N
3. Equivocation is detected and logged
4. Block B is rejected
5. Validator continues participating with full stake and rewards
6. No on-chain record of the Byzantine behavior
7. Can repeat this behavior with no cumulative penalty

## Impact Explanation

**Medium Severity** - While this does not cause immediate consensus safety violations (equivocating proposals are rejected), it represents a significant weakness in the economic security model:

- **State Inconsistency**: The consensus layer detects Byzantine behavior but the staking layer has no record of it, creating a disconnect between protocol enforcement and economic accountability
- **Limited Protocol Violation**: Byzantine validators can attempt to manipulate consensus without economic consequences, undermining the incentive structure designed to maintain network security
- **Requires Intervention**: If validators repeatedly attempt equivocation, governance would need to manually remove them via `remove_validators()` since there's no automatic penalty mechanism

This falls under the Medium severity category: "State inconsistencies requiring intervention" and "Significant protocol violations" where the Byzantine behavior detection exists but the enforcement mechanism is incomplete.

## Likelihood Explanation

**High Likelihood**: 
- Any validator can attempt this attack
- The attack is simple to execute (send two proposals for the same round)
- No sophisticated coordination required
- Only deterrent is potential manual intervention by governance
- Byzantine validators have economic incentive to test consensus boundaries without penalty

## Recommendation

Integrate equivocation detection with the validator performance tracking system:

1. **Immediate**: Modify `is_valid_proposal()` to emit an on-chain event or signal when equivocation is detected, allowing off-chain monitoring and manual intervention.

2. **Long-term**: Implement automatic slashing for equivocation:
   - Add `equivocation_count` to `IndividualValidatorPerformance`
   - Record equivocation attempts in `update_performance_statistics()`
   - Apply graduated penalties: reduce rewards → reduce stake → validator ejection
   - Complete the slashing infrastructure indicated by placeholder code

**Proposed Code Enhancement**:
```rust
// In unequivocal_proposer_election.rs
if already_proposed.1 != block.id() {
    error!(
        SecurityEvent::InvalidConsensusProposal,
        "Multiple proposals from {} for round {}: {} and {}",
        author,
        block.round(),
        already_proposed.1,
        block.id()
    );
    // NEW: Signal equivocation for on-chain recording
    self.record_equivocation_attempt(author, block.round());
    false
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_equivocation_no_penalty {
    use super::*;
    
    #[test]
    fn test_equivocation_has_no_economic_consequence() {
        // Setup: Create a validator and proposer election
        let proposer = create_test_validator();
        let election = UnequivocalProposerElection::new(/*...*/);
        
        // Validator proposes block A for round 1
        let block_a = create_test_block(round: 1, proposer);
        assert!(election.is_valid_proposal(&block_a)); // Accepted
        
        // Validator attempts equivocation: proposes block B for round 1
        let block_b = create_different_block(round: 1, proposer);
        assert!(!election.is_valid_proposal(&block_b)); // Rejected
        
        // VULNERABILITY: Check validator performance - no record of equivocation
        let (successful, failed) = get_current_epoch_proposal_counts(validator_index);
        // Equivocation attempt is not counted as failed proposal
        // Validator receives full rewards for successful proposals
        
        // Validator can continue proposing in next rounds without penalty
        let block_c = create_test_block(round: 2, proposer);
        assert!(election.is_valid_proposal(&block_c)); // Still accepted!
    }
}
```

**Notes**:
- The equivocation detection works correctly at the protocol level (safety maintained)
- The missing integration means no on-chain accountability for Byzantine behavior
- This creates a gap between consensus-layer security and economic-layer incentives
- The delegation pool code explicitly has placeholders for slashing (`ESLASHED_INACTIVE_STAKE_ON_PAST_OLC`) indicating this is a known limitation
- Manual intervention via governance remains the only recourse for repeated equivocation attempts

### Citations

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L70-78)
```rust
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1282-1332)
```text
    public(friend) fun update_performance_statistics(
        proposer_index: Option<u64>,
        failed_proposer_indices: vector<u64>
    ) acquires ValidatorPerformance {
        // Validator set cannot change until the end of the epoch, so the validator index in arguments should
        // match with those of the validators in ValidatorPerformance resource.
        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);
        let validator_len = vector::length(&validator_perf.validators);

        spec {
            update ghost_valid_perf = validator_perf;
            update ghost_proposer_idx = proposer_index;
        };
        // proposer_index is an option because it can be missing (for NilBlocks)
        if (option::is_some(&proposer_index)) {
            let cur_proposer_index = option::extract(&mut proposer_index);
            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,
            // this ensures that this function doesn't abort if there are out of bounds errors.
            if (cur_proposer_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
                spec {
                    assume validator.successful_proposals + 1 <= MAX_U64;
                };
                validator.successful_proposals = validator.successful_proposals + 1;
            };
        };

        let f = 0;
        let f_len = vector::length(&failed_proposer_indices);
        while ({
            spec {
                invariant len(validator_perf.validators) == validator_len;
                invariant (option::is_some(ghost_proposer_idx) && option::borrow(
                    ghost_proposer_idx
                ) < validator_len) ==>
                    (validator_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals ==
                        ghost_valid_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals + 1);
            };
            f < f_len
        }) {
            let validator_index = *vector::borrow(&failed_proposer_indices, f);
            if (validator_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
                spec {
                    assume validator.failed_proposals + 1 <= MAX_U64;
                };
                validator.failed_proposals = validator.failed_proposals + 1;
            };
            f = f + 1;
        };
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L884-902)
```rust
    pub fn compute_failed_authors(
        &self,
        round: Round,
        previous_round: Round,
        include_cur_round: bool,
        proposer_election: Arc<dyn ProposerElection>,
    ) -> Vec<(Round, Author)> {
        let end_round = round + u64::from(include_cur_round);
        let mut failed_authors = Vec::new();
        let start = std::cmp::max(
            previous_round + 1,
            end_round.saturating_sub(self.max_failed_authors_to_store as u64),
        );
        for i in start..end_round {
            failed_authors.push((i, proposer_election.get_valid_proposer(i)));
        }

        failed_authors
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L2023-2043)
```text
        // unsynced are rewards and slashes routed exclusively to/out the stake pool

        // operator `active` rewards not persisted yet to the active shares pool
        let pool_active = total_coins(&pool.active_shares);
        let commission_active = if (active > pool_active) {
            math64::mul_div(active - pool_active, pool.operator_commission_percentage, MAX_FEE)
        } else {
            // handle any slashing applied to `active` stake
            0
        };
        // operator `pending_inactive` rewards not persisted yet to the pending_inactive shares pool
        let pool_pending_inactive = total_coins(pending_inactive_shares_pool(pool));
        let commission_pending_inactive = if (pending_inactive > pool_pending_inactive) {
            math64::mul_div(
                pending_inactive - pool_pending_inactive,
                pool.operator_commission_percentage,
                MAX_FEE
            )
        } else {
            // handle any slashing applied to `pending_inactive` stake
            0
```
