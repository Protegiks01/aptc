# Audit Report

## Title
Validator Node Crash via Mixed V1/V2 Batch Variant Attack in Batch Coordinator

## Summary
A malicious validator can crash other validators by sending a `BatchMsg` containing mixed V1 and V2 `BatchInfoExt` variants. The `BatchCoordinator::persist_and_send_digests` function only checks the first batch's variant to determine processing path, causing a panic when subsequent batches have different variants. [1](#0-0) 

## Finding Description
The vulnerability exists in the batch processing logic where variant consistency is assumed but not enforced. The attack path:

1. **No Variant Validation**: The `BatchMsg::verify` method validates author, epoch, and individual batch integrity, but does NOT check that all batches have the same `BatchInfoExt` variant (V1 or V2). [2](#0-1) 

2. **Incorrect Variant Assumption**: In `persist_and_send_digests`, the code checks only the first batch's variant to determine the processing path for ALL batches: [3](#0-2) 

3. **Panic on Variant Mismatch**: If the first batch is V1, the code takes the else branch and attempts to convert all signed batch infos to V1 using `.expect()`: [4](#0-3) 

4. **Guaranteed Failure**: The `TryFrom` implementation explicitly fails on V2 variants: [5](#0-4) 

**Attack Scenario**: A malicious validator crafts a `BatchMsg<BatchInfoExt>` where the first batch is V1 and subsequent batches are V2. The message passes all network validation and reaches the batch coordinator. When processing, the node panics with "Batch must be V1 batch", crashing the validator.

## Impact Explanation
**Severity: High**

This vulnerability allows a single malicious validator to crash other validators, meeting the **High Severity** criteria per Aptos bug bounty:
- "Validator node slowdowns" - directly causes node crashes
- "API crashes" - consensus API crashes due to panic
- "Significant protocol violations" - breaks liveness guarantees

**Impact**:
- **Consensus Disruption**: Crashed validators cannot participate in consensus
- **Liveness Attack**: If enough validators are crashed, the network could lose liveness
- **DoS on Validators**: Malicious validator can repeatedly crash honest validators
- **Byzantine Fault Amplification**: One malicious validator (< 1/3) can disrupt multiple honest validators

This violates the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". While this doesn't directly cause safety violations, it compromises liveness which is equally critical for consensus protocols.

## Likelihood Explanation
**Likelihood: Medium-High**

**Attack Requirements**:
- Attacker must be a validator in the current epoch (passes `epoch_authors.contains_key` check)
- Can send arbitrary batch messages through the network layer
- No additional cryptographic or computational barriers

**Attack Complexity**: Low
- Simple to construct: Create one V1 batch and one V2 batch with valid payloads
- No timing dependencies or race conditions
- Deterministic outcome (guaranteed panic)
- Can be repeated indefinitely

**Realistic Scenario**: In Aptos's Byzantine fault tolerance model, the system is designed to handle up to 1/3 malicious validators. A validator with malicious intent (compromised node, malicious operator) could trivially exploit this to disrupt consensus.

## Recommendation

Add variant consistency validation in `BatchMsg::verify`:

```rust
pub fn verify(
    &self,
    peer_id: PeerId,
    max_num_batches: usize,
    verifier: &ValidatorVerifier,
) -> anyhow::Result<()> {
    ensure!(!self.batches.is_empty(), "Empty message");
    ensure!(
        self.batches.len() <= max_num_batches,
        "Too many batches: {} > {}",
        self.batches.len(),
        max_num_batches
    );
    
    // NEW: Validate variant consistency for BatchInfoExt
    if !self.batches.is_empty() {
        let first_is_v2 = self.batches[0].batch_info().is_v2();
        for batch in self.batches.iter().skip(1) {
            ensure!(
                batch.batch_info().is_v2() == first_is_v2,
                "Mixed V1/V2 batch variants in message. First: {}, Current: {}",
                first_is_v2,
                batch.batch_info().is_v2()
            );
        }
    }
    
    let epoch_authors = verifier.address_to_validator_index();
    for batch in self.batches.iter() {
        // ... existing validation ...
    }
    Ok(())
}
``` [2](#0-1) 

## Proof of Concept

```rust
// PoC: Malicious validator sends mixed batch message
use aptos_consensus_types::proof_of_store::{BatchInfo, BatchInfoExt, BatchKind};
use aptos_types::transaction::SignedTransaction;
use consensus::quorum_store::types::{Batch, BatchMsg, BatchPayload};

// Attacker (validator) creates mixed batches
fn create_malicious_batch_message(
    validator_id: PeerId,
    epoch: u64,
) -> BatchMsg<BatchInfoExt> {
    let txns = vec![/* valid transactions */];
    
    // Create V1 batch (first in list)
    let batch_v1 = Batch::new_v1(
        BatchId::new_for_test(1),
        txns.clone(),
        epoch,
        expiration_time,
        validator_id,
        gas_bucket_start,
    );
    
    // Create V2 batch (subsequent batches)
    let batch_v2 = Batch::new_v2(
        BatchId::new_for_test(2),
        txns.clone(),
        epoch,
        expiration_time,
        validator_id,
        gas_bucket_start,
        BatchKind::Normal, // V2-specific field
    );
    
    // Mix them in one message
    BatchMsg::new(vec![batch_v1, batch_v2])
}

// This message will:
// 1. Pass BatchMsg::verify() (no variant check)
// 2. Reach BatchCoordinator::persist_and_send_digests
// 3. Check first batch: is_v2() == false
// 4. Take V1 processing path
// 5. Panic when trying to convert V2 batch: "Batch must be V1 batch"
```

**Expected Outcome**: Target validator node panics and crashes when processing the mixed batch message, requiring manual restart.

**Validation Steps**:
1. Deploy malicious validator node
2. Wait for epoch where both V1 and V2 batch support exists
3. Send `BatchMsg` with [V1_batch, V2_batch] to target validator
4. Target validator crashes with panic in `batch_coordinator.rs:124`
5. Repeat attack to continuously disrupt network

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-125)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
                }
            } else {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    assert!(!signed_batch_infos
                        .first()
                        .expect("must not be empty")
                        .is_v2());
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    let signed_batch_infos = signed_batch_infos
                        .into_iter()
                        .map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
                        .collect();
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L524-527)
```rust
        ensure!(
            matches!(signed_batch_info.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
```
