# Audit Report

## Title
Critical Unauthenticated Network Communication in Remote Executor Service Enables Consensus Safety Violations

## Summary
The security question contains a **false premise**: `aptos_secure_net` does NOT detect message tampering or replay attacks. However, this investigation reveals a **CRITICAL vulnerability** - the remote executor service uses completely unauthenticated, unencrypted network communication to transmit execution-critical data between coordinator and executor shards, enabling an attacker with MITM access to violate consensus safety by tampering with execution commands and results.

## Finding Description

The `aptos_secure_net` module is a basic TCP/gRPC transport layer with **zero security features** - no authentication, no encryption, no message signing, and no replay protection. [1](#0-0) 

The error enum only contains basic network errors (NetworkError, RemoteStreamClosed, DataTooLarge, etc.) with no variants for security events. When converted to executor service errors, all `aptos_secure_net::Error` variants are indiscriminately converted to generic `InternalError` strings. [2](#0-1) 

This unauthenticated channel is used in the **critical execution path** to transmit:
- `ExecuteBlockCommand` containing transactions to execute
- `RemoteExecutionResult` containing transaction outputs  
- State key-value pairs via `RemoteKVRequest/Response` [3](#0-2) 

The remote executor is integrated into production consensus execution and is used when remote addresses are configured. [4](#0-3) 

The system is designed for distributed deployment across multiple machines, accepting arbitrary network addresses. [5](#0-4) 

**Attack Scenario:**

An attacker with network MITM access between coordinator and executor shards can:

1. **Intercept ExecuteBlockCommand messages** - These contain transactions, concurrency config, and onchain parameters sent as BCS-serialized payloads over plain gRPC
2. **Modify transaction data** - Change transaction content, ordering, or block configuration before forwarding to shards
3. **Tamper with RemoteExecutionResult** - Modify TransactionOutput data including state writes, events, gas amounts, and execution status
4. **Inject fake responses** - Impersonate executor shards and return fabricated execution results to the coordinator

Since different validators may have their network traffic tampered with differently, they will execute different state transitions for the same block, **violating consensus safety**.

## Impact Explanation

**CRITICAL Severity** - This vulnerability breaks the fundamental **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

When validators use the remote executor service across networks susceptible to MITM attacks:
- **Consensus Safety Violation**: Different validators compute different state roots for the same block, causing chain splits that cannot be resolved without human intervention
- **State Corruption**: Modified execution results lead to incorrect state transitions being committed to storage
- **Fund Theft**: An attacker can modify transaction outputs to redirect funds, mint tokens, or bypass payment checks
- **Non-Recoverable Network Partition**: Validators with tampered execution will permanently diverge from honest validators, requiring a hard fork

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** if the remote executor service is deployed in production across multiple machines on networks without additional security controls:

1. **Deployment Model**: The code explicitly supports distributed deployment with a standalone binary accepting arbitrary network addresses [6](#0-5) 

2. **No Security Layer**: Unlike the main validator network which uses Noise protocol with x25519 authentication and AES-GCM encryption, the remote executor uses plain gRPC with no security

3. **Attack Complexity**: MITM attacks are well-understood and feasible on enterprise networks, cloud environments, or compromised network infrastructure

4. **Silent Failure**: Network errors are converted to generic `InternalError` strings, making tampering indistinguishable from legitimate network issues

## Recommendation

**Immediate Actions:**

1. **Implement Authentication & Encryption**: Migrate the remote executor service from `aptos_secure_net` to the existing Noise-based secure transport used by the validator network. The codebase already has this infrastructure available. [7](#0-6) 

2. **Add Message Authentication Codes**: If immediate migration is not feasible, add HMAC signing to all messages using shared secrets between coordinator and shards, with sequence numbers to prevent replay attacks.

3. **Document Security Assumptions**: If remote executor is only intended for localhost deployment, document this clearly and add runtime validation to reject non-localhost addresses.

4. **Enhance Error Handling**: Even with security layers, preserve security event context when converting errors. Create specific error variants for authentication failures, signature verification failures, and replay detection.

**Recommended Code Structure:**

The remote executor should use the existing `AptosNetTransport` with Noise protocol authentication instead of plain gRPC. This requires:
- x25519 keypairs for coordinator and each shard
- Mutual authentication mode to verify peer identities
- Encrypted channels for all message transmission

## Proof of Concept

**Conceptual PoC demonstrating the vulnerability:**

```rust
// Attacker Setup: MITM proxy between coordinator and executor shard
// 1. Intercept ExecuteBlockCommand from coordinator
let intercepted_msg = grpc_proxy.intercept_message();
let mut command: RemoteExecutionRequest = bcs::from_bytes(&intercepted_msg).unwrap();

// 2. Tamper with execution command
if let RemoteExecutionRequest::ExecuteBlock(ref mut exec_cmd) = command {
    // Modify transaction data, e.g., change recipient addresses
    // or alter onchain config to disable security checks
    exec_cmd.onchain_config.disable_invariant_violation_check = true;
}

// 3. Forward tampered message to executor shard
grpc_proxy.forward_to_shard(bcs::to_bytes(&command).unwrap());

// 4. Intercept execution result
let result_msg = grpc_proxy.intercept_response();
let mut result: RemoteExecutionResult = bcs::from_bytes(&result_msg).unwrap();

// 5. Tamper with outputs - modify state writes, events, or gas
if let Ok(ref mut outputs) = result.inner {
    for output_batch in outputs.iter_mut() {
        for output in output_batch.iter_mut() {
            // Change state writes to transfer funds to attacker
            // Modify gas to undercharge or overcharge
            // Alter events to hide malicious activity
        }
    }
}

// 6. Return tampered result to coordinator
grpc_proxy.forward_to_coordinator(bcs::to_bytes(&result).unwrap());
```

**Result**: The coordinator commits a state root based on tampered execution, while other validators using different network paths commit different state roots, **violating consensus safety**.

## Notes

1. **False Premise Clarification**: The original security question assumes `aptos_secure_net` detects tampering/replay attacks - this is incorrect. The module is a plain transport layer with no security features whatsoever.

2. **Actual Vulnerability**: The lack of any security layer (authentication, encryption, signing) on a communication channel used for consensus-critical execution data.

3. **Scope Limitation**: This vulnerability only applies when the remote executor service is deployed across multiple machines on networks susceptible to MITM attacks. Localhost-only deployments are not vulnerable, but the code does not restrict to localhost.

4. **Comparison to Safety Rules**: Notably, the consensus safety-rules component also uses `aptos_secure_net` for remote communication, indicating this may be a systemic issue beyond just the executor service. [8](#0-7)

### Citations

**File:** secure/net/src/lib.rs (L133-147)
```rust
#[derive(Debug, Error)]
pub enum Error {
    #[error("Already called shutdown")]
    AlreadyShutdown,
    #[error("Found data that is too large to decode: {0}")]
    DataTooLarge(usize),
    #[error("Internal network error:")]
    NetworkError(#[from] std::io::Error),
    #[error("No active stream")]
    NoActiveStream,
    #[error("Overflow error: {0}")]
    OverflowError(String),
    #[error("Remote stream cleanly closed")]
    RemoteStreamClosed,
}
```

**File:** execution/executor-service/src/error.rs (L22-26)
```rust
impl From<aptos_secure_net::Error> for Error {
    fn from(error: aptos_secure_net::Error) -> Self {
        Self::InternalError(error.to_string())
    }
}
```

**File:** execution/executor-service/src/lib.rs (L44-65)
```rust
pub enum RemoteExecutionRequest {
    ExecuteBlock(ExecuteBlockCommand),
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}

impl ExecuteBlockCommand {
    pub fn into(
        self,
    ) -> (
        SubBlocksForShard<AnalyzedTransaction>,
        usize,
        BlockExecutorConfigFromOnchain,
    ) {
        (self.sub_blocks, self.concurrency_level, self.onchain_config)
    }
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-275)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
```

**File:** execution/executor-service/src/main.rs (L9-25)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}
```

**File:** execution/executor-service/src/process_executor_service.rs (L11-50)
```rust
/// An implementation of the remote executor service that runs in a standalone process.
pub struct ProcessExecutorService {
    executor_service: ExecutorService,
}

impl ProcessExecutorService {
    pub fn new(
        shard_id: ShardId,
        num_shards: usize,
        num_threads: usize,
        coordinator_address: SocketAddr,
        remote_shard_addresses: Vec<SocketAddr>,
    ) -> Self {
        let self_address = remote_shard_addresses[shard_id];
        info!(
            "Starting process remote executor service on {}; coordinator address: {}, other shard addresses: {:?}; num threads: {}",
            self_address, coordinator_address, remote_shard_addresses, num_threads
        );
        aptos_node_resource_metrics::register_node_metrics_collector(None);
        let _mp = MetricsPusher::start_for_local_run(
            &("remote-executor-service-".to_owned() + &shard_id.to_string()),
        );

        AptosVM::set_concurrency_level_once(num_threads);
        let mut executor_service = ExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            self_address,
            coordinator_address,
            remote_shard_addresses,
        );
        executor_service.start();
        Self { executor_service }
    }

    pub fn shutdown(&mut self) {
        self.executor_service.shutdown()
    }
}
```

**File:** network/framework/src/noise/handshake.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! The handshake module implements the handshake part of the protocol.
//! This module also implements additional anti-DoS mitigation,
//! by including a timestamp in each handshake initialization message.
//! Refer to the module's documentation for more information.
//! A successful handshake returns a [`NoiseStream`] which is defined in the
//! [stream] module.
//!
//! [stream]: crate::noise::stream

use crate::{
    application::storage::PeersAndMetadata,
    logging::NetworkSchema,
    noise::{error::NoiseHandshakeError, stream::NoiseStream},
};
use aptos_config::{
    config::{Peer, PeerRole},
    network_id::{NetworkContext, NetworkId},
};
use aptos_crypto::{noise, x25519};
use aptos_infallible::{duration_since_epoch, RwLock};
use aptos_logger::{error, trace};
use aptos_short_hex_str::{AsShortHexStr, ShortHexStr};
use aptos_types::PeerId;
use futures::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
use std::{collections::HashMap, convert::TryFrom as _, fmt::Debug, sync::Arc};

/// In a mutually authenticated network, a client message is accompanied with a timestamp.
/// This is in order to prevent replay attacks, where the attacker does not know the client's static key,
/// but can still replay a handshake message in order to force a peer into performing a few Diffie-Hellman key exchange operations.
///
/// Thus, to prevent replay attacks a responder will always check if the timestamp is strictly increasing,
/// effectively considering it as a stateful counter.
///
/// If the client timestamp has been seen before, or is not strictly increasing,
/// we can abort the handshake early and avoid heavy Diffie-Hellman computations.
/// If the client timestamp is valid, we store it.
#[derive(Default)]
pub struct AntiReplayTimestamps(HashMap<x25519::PublicKey, u64>);

impl AntiReplayTimestamps {
    /// The timestamp is sent as a payload, so that it is encrypted.
    /// Note that a millisecond value is a 16-byte value in rust,
    /// but as we use it to store a duration since UNIX_EPOCH we will never use more than 8 bytes.
    pub const TIMESTAMP_SIZE: usize = 8;

    /// obtain the current timestamp
    pub fn now() -> [u8; Self::TIMESTAMP_SIZE] {
```

**File:** consensus/safety-rules/src/remote_service.rs (L10-28)
```rust
use aptos_secure_net::{NetworkClient, NetworkServer};
use std::net::SocketAddr;

pub trait RemoteService {
    fn client(&self) -> SerializerClient {
        let network_client = NetworkClient::new(
            "safety-rules".to_string(),
            self.server_address(),
            self.network_timeout_ms(),
        );
        let service = Box::new(RemoteClient::new(network_client));
        SerializerClient::new_client(service)
    }

    fn server_address(&self) -> SocketAddr;

    /// Network Timeout in milliseconds.
    fn network_timeout_ms(&self) -> u64;
}
```
