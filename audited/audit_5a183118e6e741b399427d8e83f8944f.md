# Audit Report

## Title
Missing Epoch Validation for Timeout Certificates in Safety Rules Voting Path

## Summary
The `SafetyRules` voting validation lacks explicit epoch consistency checks for timeout certificates, allowing semantically incorrect cross-epoch round comparisons. While cryptographic signature verification may prevent some exploitation scenarios, the absence of defense-in-depth validation creates a protocol violation inconsistent with other parts of the codebase.

## Finding Description

The `safe_to_vote()` function in the 2-chain consensus safety rules performs round-based voting validation using timeout certificates without verifying that the timeout certificate's epoch matches the proposed block's epoch. [1](#0-0) 

The function extracts `tc_round` and `hqc_round` from the timeout certificate and compares them with the block's round number, but rounds are epoch-relative values that reset to 0 at each epoch boundary: [2](#0-1) 

The timeout certificate verification in `verify_tc()` only validates cryptographic signatures without checking epoch consistency: [3](#0-2) 

This is inconsistent with `SyncInfo::verify()`, which explicitly validates epoch consistency between timeout certificates and quorum certificates: [4](#0-3) 

**Attack Scenario:**
A malicious validator could attempt to use a valid timeout certificate from epoch M when proposing a block in epoch N. Since rounds reset per epoch, the round values would be semantically incomparable (epoch M round 5 vs epoch N round 6), but the safety check would compare them as if they were in the same epoch context.

## Impact Explanation

This vulnerability represents a **High Severity** protocol violation according to Aptos bug bounty criteria. While cryptographic signature verification provides a layer of protection, the lack of explicit epoch validation:

1. **Violates Consensus Safety Invariants**: The 2-chain voting rule assumes timeout certificates and blocks are from the same epoch. Cross-epoch round comparisons are semantically meaningless and could lead to incorrect voting decisions.

2. **Creates Defense-in-Depth Failures**: The code relies solely on signature verification to prevent cross-epoch timeout certificate misuse, rather than implementing explicit validation as a primary check.

3. **Introduces Protocol Inconsistency**: The explicit epoch check in `SyncInfo::verify()` demonstrates that Aptos developers recognize the importance of epoch consistency for timeout certificates, yet this check is missing in the critical voting path.

4. **Enables Potential Safety Breaks**: If signature verification were to pass for a cross-epoch timeout certificate (e.g., with identical validator sets across epochs), the safety logic would incorrectly allow voting on blocks that violate the 2-chain safety rule.

## Likelihood Explanation

**Moderate Likelihood**. The vulnerability requires:

1. **Malicious Validator Access**: An attacker must be a validator to propose blocks with timeout certificates
2. **Epoch Transition Context**: Exploitation requires crossing epoch boundaries  
3. **Signature Verification Bypass Scenario**: Most cross-epoch timeout certificates would fail signature verification if the validator set changes significantly

However, the likelihood increases in scenarios where:
- Validator sets remain stable across epochs
- Epoch transitions occur frequently
- The protocol relies on implicit rather than explicit validation

The existence of explicit epoch validation in `SyncInfo` but not in `SafetyRules` suggests this was an oversight rather than an intentional design decision.

## Recommendation

Add explicit epoch validation in the `verify_tc()` function before signature verification:

```rust
fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
    let epoch_state = self.epoch_state()?;
    let safety_data = self.persistent_storage.safety_data()?;
    
    // Add explicit epoch check
    if tc.epoch() != safety_data.epoch {
        return Err(Error::IncorrectEpoch(tc.epoch(), safety_data.epoch));
    }
    
    if !self.skip_sig_verify {
        tc.verify(&epoch_state.verifier)
            .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
    }
    Ok(())
}
```

Alternatively, add the check in `guarded_construct_and_sign_vote_two_chain()` before calling `verify_tc()`:

```rust
if let Some(tc) = timeout_cert {
    let safety_data = self.persistent_storage.safety_data()?;
    if tc.epoch() != safety_data.epoch {
        return Err(Error::IncorrectEpoch(tc.epoch(), safety_data.epoch));
    }
    self.verify_tc(tc)?;
}
```

## Proof of Concept

```rust
#[test]
fn test_cross_epoch_timeout_certificate_rejection() {
    use crate::test_utils;
    use aptos_consensus_types::timeout_2chain::TwoChainTimeout;
    
    let (mut safety_rules, signer) = /* initialize safety_rules */;
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    
    // Initialize to epoch 1
    safety_rules.initialize(&proof).unwrap();
    
    // Create a valid timeout certificate for epoch 1, round 5
    let tc_epoch_1 = test_utils::make_timeout_cert(5, &genesis_qc, &signer);
    assert_eq!(tc_epoch_1.epoch(), 1);
    
    // Transition to epoch 2 (simulated)
    // Create a block proposal for epoch 2, round 6
    let block_epoch_2_round_6 = /* create block with epoch 2, round 6 */;
    
    // Attempt to vote with epoch 1 timeout certificate on epoch 2 block
    // Currently: This might pass safety checks (vulnerability)
    // Expected: Should reject with Error::IncorrectEpoch(1, 2)
    let result = safety_rules.construct_and_sign_vote_two_chain(
        &block_epoch_2_round_6, 
        Some(&tc_epoch_1)
    );
    
    // The vulnerability: no epoch validation occurs
    // Expected behavior: should return Err(Error::IncorrectEpoch(1, 2))
}
```

## Notes

The test suite currently only validates timeout certificates from the same epoch, as evidenced by the hardcoded epoch value in `make_timeout_cert()`: [5](#0-4) 

No existing tests validate the behavior when timeout certificates from different epochs are used, indicating this edge case was not considered during development. The explicit epoch validation in `SyncInfo::verify()` strongly suggests this is a genuine oversight in the `SafetyRules` implementation that should be corrected for defense-in-depth and protocol correctness.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L180-188)
```rust
    fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            tc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L296-303)
```rust
                self.persistent_storage.set_safety_data(SafetyData::new(
                    epoch_state.epoch,
                    0,
                    0,
                    0,
                    None,
                    0,
                ))?;
```

**File:** consensus/consensus-types/src/sync_info.rs (L148-150)
```rust
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }
```

**File:** consensus/safety-rules/src/test_utils.rs (L207-219)
```rust
pub fn make_timeout_cert(
    round: Round,
    hqc: &QuorumCert,
    signer: &ValidatorSigner,
) -> TwoChainTimeoutCertificate {
    let timeout = TwoChainTimeout::new(1, round, hqc.clone());
    let mut tc_partial = TwoChainTimeoutWithPartialSignatures::new(timeout.clone());
    let signature = timeout.sign(signer).unwrap();
    tc_partial.add(signer.author(), timeout, signature);
    tc_partial
        .aggregate_signatures(&generate_validator_verifier(std::slice::from_ref(signer)))
        .unwrap()
}
```
