# Audit Report

## Title
State Merkle DB Crash-Recovery Inconsistency Leading to Orphaned Shard Nodes

## Summary
In `truncate_state_merkle_db()`, committing top-level progress before shard truncation can create a crash-recovery window where the database reports a progress version that has no corresponding state root, leaving orphaned shard nodes that violate state consistency invariants. [1](#0-0) 

## Finding Description

The `truncate_state_merkle_db()` function performs iterative truncation of the Jellyfish Merkle Tree by:

1. Finding `version_before` as the closest root version at or before `current_version - 1`
2. Deleting top-level nodes ≥ `current_version` and setting top-level progress to `current_version - 1` (line 174)
3. Deleting shard nodes ≥ `version_before + 1` and setting shard progress to `version_before` (line 176) [2](#0-1) 

**Critical Issue**: When `version_before < current_version - 1` (which occurs when roots are sparse), the top-level progress is set to `current_version - 1` despite no root existing at that version.

The `delete_nodes_and_stale_indices_at_or_after_version()` helper sets progress to `version.checked_sub(1)`: [3](#0-2) 

**Crash Scenario**: If the node crashes between line 174 and 176:
- Top-level progress = `current_version - 1` (no root exists at this version)
- Shards still contain nodes up to `current_version`

**Recovery Behavior**: On restart, the recovery mechanism reads top-level progress and truncates shards to match: [4](#0-3) 

**Result After Recovery**:
- Top-level progress = `current_version - 1` (but no root exists)
- Shards truncated to `current_version - 1` (keeping nodes from `version_before + 1` to `current_version - 1`)
- These shard nodes are **orphaned** (not reachable from any root)

This violates the invariant: "Progress version should have a corresponding valid state root."

## Impact Explanation

**Severity**: Medium (State inconsistencies requiring intervention)

While this doesn't directly cause consensus divergence or fund loss, it creates:

1. **Invalid Progress State**: The database reports being at a version with no valid state root
2. **Orphaned Storage**: Shard nodes exist without parent roots, wasting space and potentially interfering with pruning
3. **Query Failures**: Attempts to access state at the "progress version" will fail
4. **Potential Recovery Loops**: Automated recovery systems expecting valid roots at progress versions may fail

However, impact is limited because:
- Affects only a single node (local database state)
- Does not affect network consensus
- Occurs only during crash-recovery of truncation operations
- No direct path to fund loss or consensus safety violations

## Likelihood Explanation

**Likelihood**: Low to Medium

This requires:
1. A node performing state truncation (startup recovery or manual maintenance via `db_debugger`)
2. Sparse root distribution (common when not every version commits state)
3. Crash occurring in the narrow window between lines 174-176
4. `version_before < current_version - 1` (depends on root distribution)

The window is small (two sequential operations), but truncation happens during:
- Every database startup if progress mismatches exist
- Manual database maintenance operations

In production environments with frequent restarts or maintenance, this could occur occasionally.

## Recommendation

**Fix**: Commit both top-levels and shards atomically, or set top-level progress to `version_before` (the actual target) instead of `current_version - 1`.

**Option 1** - Correct Progress Value:
```rust
// In truncate_state_merkle_db(), modify the top_levels_batch to use version_before
delete_nodes_and_stale_indices_at_or_after_version(
    state_merkle_db.metadata_db(),
    current_version,
    None,
    &mut top_levels_batch,
)?;

// Manually override progress to version_before instead of current_version - 1
let mut final_batch = SchemaBatch::new();
StateMerkleDb::put_progress(Some(version_before), None, &mut final_batch)?;
// Merge batches before commit
```

**Option 2** - Atomic Commit:
Defer progress updates until after both top-levels and shards are truncated, then write progress atomically.

## Proof of Concept

```rust
// Reproduction test (add to storage/aptosdb/src/utils/truncation_helper.rs tests)
#[test]
fn test_truncation_crash_recovery_inconsistency() {
    use crate::AptosDB;
    use aptos_temppath::TempPath;
    
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Commit state at versions 95, 97, 100, 102 (sparse roots)
    // ... (setup code to create sparse roots)
    
    // Simulate truncate_state_merkle_db crash after line 174
    let state_merkle_db = db.state_merkle_db();
    
    // Manually execute line 174 (top level commit)
    let mut top_levels_batch = SchemaBatch::new();
    delete_nodes_and_stale_indices_at_or_after_version(
        state_merkle_db.metadata_db(),
        100, // current_version
        None,
        &mut top_levels_batch,
    ).unwrap();
    state_merkle_db.commit_top_levels(99, top_levels_batch).unwrap();
    
    // Simulate crash - don't execute line 176
    drop(db);
    
    // Reopen database - recovery mechanism runs
    let db = AptosDB::new_for_test(&tmp_dir);
    let state_merkle_db = db.state_merkle_db();
    
    // Check: progress = 99 but no root exists at version 99
    let progress = get_state_merkle_commit_progress(state_merkle_db).unwrap().unwrap();
    assert_eq!(progress, 99);
    
    // Verify no root at version 99
    assert!(!root_exists_at_version(state_merkle_db, 99).unwrap());
    
    // Shards contain orphaned nodes from 98-99
    // ... (verification code)
}
```

**Notes**

This issue represents a **database consistency bug** rather than a directly exploitable attack vector. It cannot be triggered by an unprivileged attacker and does not directly compromise consensus safety or fund security. However, it does violate state consistency invariants and could require manual intervention to resolve, justifying Medium severity under "State inconsistencies requiring intervention."

The root cause is the non-atomic commit of top-level progress versus shard truncation combined with progress being set to `current_version - 1` when the actual truncation target is `version_before`.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L144-180)
```rust
pub(crate) fn truncate_state_merkle_db(
    state_merkle_db: &StateMerkleDb,
    target_version: Version,
) -> Result<()> {
    let status = StatusLine::new(Progress::new("Truncating State Merkle DB.", target_version));

    loop {
        let current_version = get_current_version_in_state_merkle_db(state_merkle_db)?
            .expect("Current version of state merkle db must exist.");
        status.set_current_version(current_version);
        assert_ge!(current_version, target_version);
        if current_version == target_version {
            break;
        }

        let version_before = find_closest_node_version_at_or_before(
            state_merkle_db.metadata_db(),
            current_version - 1,
        )?
        .expect("Must exist.");

        let mut top_levels_batch = SchemaBatch::new();

        delete_nodes_and_stale_indices_at_or_after_version(
            state_merkle_db.metadata_db(),
            current_version,
            None, // shard_id
            &mut top_levels_batch,
        )?;

        state_merkle_db.commit_top_levels(version_before, top_levels_batch)?;

        truncate_state_merkle_db_shards(state_merkle_db, version_before)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L603-622)
```rust
fn delete_nodes_and_stale_indices_at_or_after_version(
    db: &DB,
    version: Version,
    shard_id: Option<usize>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexSchema>(db, version, batch)?;
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexCrossEpochSchema>(
        db, version, batch,
    )?;

    let mut iter = db.iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek(&NodeKey::new_empty_path(version))?;
    for item in iter {
        let (key, _) = item?;
        batch.delete::<JellyfishMerkleNodeSchema>(&key)?;
    }

    StateMerkleDb::put_progress(version.checked_sub(1), shard_id, batch)
}
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L668-677)
```rust
        if !readonly {
            if let Some(overall_state_merkle_commit_progress) =
                get_state_merkle_commit_progress(&state_merkle_db)?
            {
                truncate_state_merkle_db_shards(
                    &state_merkle_db,
                    overall_state_merkle_commit_progress,
                )?;
            }
        }
```
