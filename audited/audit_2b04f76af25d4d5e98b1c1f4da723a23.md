# Audit Report

## Title
Stall Counter Underflow Causes Permanent Transaction Liveness Failure

## Summary
The `remove_stall()` function in `scheduler_status.rs` uses `fetch_sub` to decrement the stall counter before checking if the counter was zero. If a logic bug causes `remove_stall` to be called more times than `add_stall`, the u32 counter wraps to u32::MAX (4,294,967,295), causing the transaction to appear maximally stalled and never be scheduled for execution, resulting in a permanent liveness failure.

## Finding Description

The vulnerability exists in the `remove_stall()` function's check-after-modify pattern: [1](#0-0) 

The critical issue is that `fetch_sub(1, Ordering::SeqCst)` atomically decrements the counter at line 419 BEFORE the zero-check at line 421. If `num_stalls` is 0 when this function is called:

1. Line 419 executes: `0 - 1` wraps to `4,294,967,295` (u32::MAX) using wrapping arithmetic
2. `prev_num_stalls` is set to 0 (the value before subtraction)
3. Line 421 detects the error and returns `code_invariant_error`
4. **Critical**: The counter remains at u32::MAX permanently

The `is_stalled()` function checks if the counter is greater than zero: [2](#0-1) 

With `num_stalls = u32::MAX`, this will always return `true`, causing the transaction to be treated as maximally stalled.

**Impact on Scheduling**: When a transaction is moved to `PendingScheduling` state, it is only added to the execution queue if NOT stalled: [3](#0-2) 

With the wrapped counter, the transaction will never be scheduled for execution, causing a permanent liveness failure.

**Attack Propagation**: The stall mechanism propagates through the dependency graph. If a transaction appears stalled, the `propagate()` function will propagate `add_stall` to all its dependencies: [4](#0-3) 

This can cause cascading liveness failures across multiple transactions.

**Triggering Condition**: While the code includes error handling, any logic bug in the complex stall tracking system could trigger this. The stall tracking involves:
- Multiple concurrent workers calling `add_stall` and `remove_stall`
- `AbortedDependencies` that persist across incarnations and are never cleared
- Dependency tracking across transaction aborts and re-executions [5](#0-4) 

The test suite explicitly checks for this error condition, indicating developers are aware of the risk: [6](#0-5) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: If this affects any transaction in a block, that block cannot complete execution, causing all validators processing that block to hang.

2. **Significant Protocol Violation**: This breaks the liveness invariantâ€”the guarantee that valid transactions will eventually be executed and committed.

3. **Cascading Failures**: Due to stall propagation through the dependency graph, a single affected transaction can cause multiple dependent transactions to also become permanently stalled.

4. **Deterministic Impact**: Once triggered, the effect is permanent for that block execution. The wrapped counter cannot naturally return to a valid state since removing ~4 billion stalls is infeasible.

5. **Network-Wide Impact**: If the same logic bug is hit deterministically by all validators processing the same block, the entire network could stall on that block.

## Likelihood Explanation

**Medium-High Likelihood** given:

1. **Complex Stall Tracking**: The stall mechanism involves intricate concurrent operations across multiple workers, transaction incarnations, and dependency relationships.

2. **Never-Cleared Dependencies**: `AbortedDependencies` persist for the lifetime of the scheduler and accumulate dependencies across incarnations, increasing the potential for tracking errors. [7](#0-6) 

3. **Known Risk**: The existence of explicit test cases checking for this error condition suggests the developers recognize this as a realistic failure mode.

4. **No Automatic Recovery**: Once triggered, there is no mechanism to detect and fix the corrupted counter state. The error is returned, but the damage persists.

## Recommendation

**Fix 1: Check-Before-Modify Pattern**

Modify `remove_stall()` to check the counter before decrementing:

```rust
pub(crate) fn remove_stall(&self, txn_idx: TxnIndex) -> Result<bool, PanicError> {
    let status = &self.statuses[txn_idx as usize];
    
    // Check BEFORE modifying
    let current_stalls = status.num_stalls.load(Ordering::SeqCst);
    if current_stalls == 0 {
        return Err(code_invariant_error(
            "remove_stall called when num_stalls == 0",
        ));
    }
    
    let prev_num_stalls = status.num_stalls.fetch_sub(1, Ordering::SeqCst);
    
    // Re-check for race conditions
    if prev_num_stalls == 0 {
        // Restore counter if underflow occurred
        status.num_stalls.fetch_add(1, Ordering::SeqCst);
        return Err(code_invariant_error(
            "remove_stall race condition detected",
        ));
    }
    
    // Rest of function...
}
```

**Fix 2: Saturating Arithmetic**

Use saturating subtraction to prevent wrapping:

```rust
// Replace fetch_sub with compare-and-swap loop using saturating arithmetic
loop {
    let current = status.num_stalls.load(Ordering::SeqCst);
    if current == 0 {
        return Err(code_invariant_error("remove_stall called when num_stalls == 0"));
    }
    if status.num_stalls.compare_exchange(
        current,
        current - 1,
        Ordering::SeqCst,
        Ordering::SeqCst,
    ).is_ok() {
        break;
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_remove_stall_underflow_causes_permanent_stall() {
    use crate::scheduler_status::{ExecutionStatuses, ExecutionStatus, StatusWithIncarnation, SchedulingStatus};
    use crate::scheduler_v2::ExecutionQueueManager;
    use std::sync::atomic::Ordering;

    // Create a scheduler with one transaction
    let statuses = ExecutionStatuses::new_for_test(
        ExecutionQueueManager::new_for_test(1),
        vec![ExecutionStatus::new_for_test(
            StatusWithIncarnation::new_for_test(SchedulingStatus::PendingScheduling, 1),
            0,  // num_stalls = 0
        )],
    );
    
    let status = statuses.get_status(0);
    
    // Verify initial state: not stalled
    assert_eq!(status.num_stalls.load(Ordering::Relaxed), 0);
    assert!(!status.is_stalled());
    
    // Call remove_stall when num_stalls is 0 (simulating a logic bug)
    let result = statuses.remove_stall(0);
    
    // Function returns error as expected
    assert!(result.is_err());
    
    // VULNERABILITY: Counter has wrapped to u32::MAX
    assert_eq!(status.num_stalls.load(Ordering::Relaxed), u32::MAX);
    
    // Transaction now appears maximally stalled
    assert!(status.is_stalled());
    
    // Transaction will never be scheduled
    // Attempting to add it to schedule will fail due to is_stalled() check
    statuses.get_execution_queue_manager().add_to_schedule(false, 0);
    
    // Queue remains empty - transaction is permanently stuck
    assert!(statuses.get_execution_queue_manager().pop_next().is_none());
    
    // Even calling remove_stall u32::MAX times won't fix it in reasonable time
    // This transaction is permanently stalled, causing liveness failure
}
```

## Notes

This vulnerability represents a defense-in-depth weakness where an incorrect error handling pattern (check-after-modify) converts a potentially recoverable logic error into a permanent liveness failure. While triggering requires a pre-existing bug in stall tracking logic, the consequences are severe and deterministic. The complex concurrent nature of the BlockSTMv2 scheduler, combined with dependencies that persist across incarnations without clearing, creates a realistic risk surface for such tracking errors to occur.

### Citations

**File:** aptos-move/block-executor/src/scheduler_status.rs (L417-425)
```rust
    pub(crate) fn remove_stall(&self, txn_idx: TxnIndex) -> Result<bool, PanicError> {
        let status = &self.statuses[txn_idx as usize];
        let prev_num_stalls = status.num_stalls.fetch_sub(1, Ordering::SeqCst);

        if prev_num_stalls == 0 {
            return Err(code_invariant_error(
                "remove_stall called when num_stalls == 0",
            ));
        }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L885-890)
```rust
        if add_to_schedule && !status.is_stalled() {
            // Need to schedule the transaction for re-execution. If stalled, then
            // scheduling is deferred to the remove_stall.
            self.execution_queue_manager
                .add_to_schedule(new_incarnation == 1, txn_idx);
        }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L959-961)
```rust
    pub(crate) fn is_stalled(&self) -> bool {
        self.num_stalls.load(Ordering::Relaxed) > 0
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L502-507)
```rust
    /// For each transaction `i`, `aborted_dependencies[i]` stores a list of transactions
    /// `j > i` that were previously aborted by `i` (due to `i`'s writes).
    /// This information is used to propagate stalls: if `i` is stalled or aborted,
    /// a stall signal is propagated to these dependent transactions `j`.
    /// Each [AbortedDependencies] instance is protected by a `Mutex`.
    aborted_dependencies: Vec<CachePadded<Mutex<AbortedDependencies>>>,
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L551-553)
```rust
            aborted_dependencies: (0..num_txns)
                .map(|_| CachePadded::new(Mutex::new(AbortedDependencies::new())))
                .collect(),
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1224-1234)
```rust
            if self
                .txn_statuses
                .shortcut_executed_and_not_stalled(task_idx)
            {
                // Still makes sense to propagate remove_stall.
                aborted_deps_guard
                    .remove_stall(&self.txn_statuses, &mut stall_propagation_queue)?;
            } else {
                // Not executed or stalled - still makes sense to propagate add_stall.
                aborted_deps_guard.add_stall(&self.txn_statuses, &mut stall_propagation_queue)?;
            }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1504-1505)
```rust
        // Removing stall should fail because num_stalls = 0.
        assert_err!(deps.remove_stall(&statuses, &mut stall_propagation_queue));
```
