# Audit Report

## Title
Time-of-Check-Time-of-Use (TOCTOU) Vulnerability in Move Package Compilation Allows Package Tampering After Validation

## Summary
A TOCTOU race condition exists between source digest computation and bytecode compilation in the Move package build pipeline. The digest is computed in one lock-protected section, the lock is released, then bytecode compilation occurs in a separate lock-protected section. An attacker with local filesystem access can modify source files in the window between these operations, causing malicious bytecode to be deployed with an incorrect source digest.

## Finding Description
The Move package compilation process validates package integrity by computing a SHA256 digest of all source files and the manifest. However, this validation is separated from the actual compilation by distinct lock acquisitions, creating a TOCTOU vulnerability.

**Vulnerable Flow:**

1. **Digest Computation Phase** (first lock section): [1](#0-0) [2](#0-1) [3](#0-2) 

The digest is computed by reading all `.move` files and `Move.toml`, then stored in the resolution package.

2. **Lock Release** - The lock is released after resolution completes, before returning to `compile_package`.

3. **TOCTOU Window** - Files can be modified here without any protection.

4. **Compilation Phase** (second lock section): [4](#0-3) 

The compiler reads source files again to generate bytecode, potentially reading modified files.

5. **Metadata Extraction** - The pre-computed digest is included in package metadata: [5](#0-4) 

**Attack Scenario:**
An attacker with local filesystem access (e.g., malware, compromised build environment) monitors for the lock release after digest computation, immediately modifies source files to inject malicious code, then allows compilation to proceed. The resulting package contains:
- `source_digest`: Hash of original, benign source files
- Bytecode: Compiled from modified, malicious source files

When published on-chain, package verification using `stored_package.rs` will compare against the incorrect digest.

## Impact Explanation
This is a **High Severity** vulnerability under the "Significant protocol violations" category. It breaks the fundamental package integrity guarantee that the `source_digest` field accurately represents the compiled bytecode. This enables:

1. **Supply Chain Attacks**: Malicious code deployment with clean source digest metadata
2. **Trust Violation**: Package verification mechanisms become ineffective
3. **Stealth Malicious Deployments**: Attackers can deploy backdoored contracts that pass source verification

The vulnerability undermines the entire package verification system designed to ensure code authenticity and prevent tampering.

## Likelihood Explanation
**Likelihood: Medium to High in targeted scenarios**

The attack requires:
- Local filesystem access to the package directory during compilation
- Precise timing to exploit the TOCTOU window (typically milliseconds)
- Ability to detect lock release (achievable via filesystem monitoring tools like inotify)

While this requires local access, it's realistic in:
1. **Compromised developer machines** (malware, trojans)
2. **Shared build servers** with multiple users
3. **CI/CD pipeline compromises** where build artifacts are manipulated
4. **Container escape scenarios** in multi-tenant build environments

Supply chain attacks targeting blockchain deployments are increasingly common, making this a practical threat vector.

## Recommendation
**Fix: Atomic digest computation and compilation within a single lock section**

The resolution graph creation and compilation should occur within the same lock-protected section to prevent file modifications between validation and compilation:

Modify `third_party/move/tools/move-package/src/lib.rs`:

```rust
pub fn compile_package<W: Write>(self, path: &Path, writer: &mut W) -> Result<CompiledPackage> {
    let config = self.compiler_config.clone();
    let mutx = PackageLock::lock();  // Acquire lock BEFORE resolution
    let resolved_graph = self.resolution_graph_for_package(path, writer)?;
    let ret = BuildPlan::create(resolved_graph)?.compile(&config, writer);
    mutx.unlock();
    ret
}
```

Remove the separate lock in `resolution_graph_for_package` since the outer lock now protects both operations.

**Alternative: Content-based verification**
Add a post-compilation verification step that re-computes the source digest and compares it to the stored digest, failing the build if they don't match.

## Proof of Concept

```rust
// Exploit script (pseudocode demonstrating the attack)
use notify::{Watcher, RecursiveMode, watcher};
use std::sync::mpsc::channel;
use std::time::Duration;

fn exploit_toctou() {
    // Monitor for lock file release
    let (tx, rx) = channel();
    let mut watcher = watcher(tx, Duration::from_millis(10)).unwrap();
    watcher.watch("/tmp/move_pkg_lock_*", RecursiveMode::NonRecursive).unwrap();
    
    // Wait for first lock release (after digest computation)
    loop {
        match rx.recv_timeout(Duration::from_millis(100)) {
            Ok(notify::DebouncedEvent::Remove(path)) => {
                // Lock released! Inject malicious code
                let target = "package/sources/module.move";
                let malicious_code = "public entry fun backdoor() { /* exploit */ }";
                std::fs::write(target, malicious_code).unwrap();
                break;
            }
            _ => continue,
        }
    }
    // Compilation will now read modified files with old digest
}
```

**Test scenario:**
1. Create a Move package with benign source code
2. Start compilation in one thread
3. In another thread, detect lock release and modify source files
4. Observe that the compiled package has mismatched digest and bytecode
5. Publish the package - source digest verification will incorrectly pass

**Notes**
- The vulnerability exists because `PackageLock` is acquired twice in separate critical sections rather than protecting the entire validate-then-compile operation atomically
- The `layout.rs` file itself only defines directory structure and doesn't perform validation; the actual vulnerability is in the compilation pipeline that uses these layouts
- This is exploitable in supply chain attack scenarios where build environments are compromised
- The impact extends beyond individual packages to the entire package verification ecosystem on Aptos

### Citations

**File:** third_party/move/tools/move-package/src/lib.rs (L145-151)
```rust
    pub fn compile_package<W: Write>(self, path: &Path, writer: &mut W) -> Result<CompiledPackage> {
        let config = self.compiler_config.clone(); // Need clone because of mut self
        let resolved_graph = self.resolution_graph_for_package(path, writer)?;
        let mutx = PackageLock::lock();
        let ret = BuildPlan::create(resolved_graph)?.compile(&config, writer);
        mutx.unlock();
        ret
```

**File:** third_party/move/tools/move-package/src/lib.rs (L203-222)
```rust
    pub fn resolution_graph_for_package<W: Write>(
        mut self,
        path: &Path,
        writer: &mut W,
    ) -> Result<ResolvedGraph> {
        if self.test_mode {
            self.dev_mode = true;
        }
        let path = SourcePackageLayout::try_find_root(path)?;
        let toml_manifest =
            self.parse_toml_manifest(path.join(SourcePackageLayout::Manifest.path()))?;
        let mutx = PackageLock::lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        let resolution_graph = ResolutionGraph::new(manifest, path, self, writer)?;
        let ret = resolution_graph.resolve();
        mutx.unlock();
        ret
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L306-307)
```rust
        let source_digest =
            ResolvingPackage::get_package_digest_for_config(&package_path, &self.build_options)?;
```

**File:** third_party/move/tools/move-package/src/resolution/digest.rs (L11-51)
```rust
pub fn compute_digest(paths: &[PathBuf]) -> Result<PackageDigest> {
    let mut hashed_files = Vec::new();
    let mut hash = |path: &Path| {
        let contents = std::fs::read(path)?;
        hashed_files.push(format!("{:X}", Sha256::digest(&contents)));
        Ok(())
    };
    let mut maybe_hash_file = |path: &Path| -> Result<()> {
        match path.extension() {
            Some(x) if MOVE_EXTENSION == x => hash(path),
            _ if path.ends_with(SourcePackageLayout::Manifest.path()) => hash(path),
            _ => Ok(()),
        }
    };

    for path in paths {
        if path.is_file() {
            maybe_hash_file(path)?;
        } else {
            for entry in walkdir::WalkDir::new(path)
                .follow_links(true)
                .into_iter()
                .filter_map(|e| e.ok())
            {
                if entry.file_type().is_file() {
                    maybe_hash_file(entry.path())?
                }
            }
        }
    }

    // Sort the hashed files to ensure that the order of files is always stable
    hashed_files.sort();

    let mut hasher = Sha256::new();
    for file_hash in hashed_files.into_iter() {
        hasher.update(file_hash.as_bytes());
    }

    Ok(PackageDigest::from(format!("{:X}", hasher.finalize())))
}
```

**File:** aptos-move/framework/src/built_package.rs (L516-522)
```rust
    pub fn extract_metadata(&self) -> anyhow::Result<PackageMetadata> {
        let source_digest = self
            .package
            .compiled_package_info
            .source_digest
            .map(|s| s.to_string())
            .unwrap_or_default();
```
