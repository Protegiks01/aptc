# Audit Report

## Title
Event V2 Translation Uses Wrong State Version Causing Event Index Corruption and Type Confusion

## Summary
The EventV2TranslationEngine uses the latest committed state instead of the state at the event's transaction version when translating V2 events to V1 format. This causes events to be indexed with incorrect event keys when resources are deleted or modified between event emission and indexer processing, leading to event index corruption, missing events in queries, and potential type confusion.

## Finding Description

The internal indexer translates V2 events to V1 format for backward compatibility. When translating, it needs to look up on-chain resources (like `CoinStore`) to extract the correct event handle keys. However, the translation engine uses `latest_state_checkpoint_view()` which returns the current latest state, not the state at the version when the event was emitted. [1](#0-0) 

The indexer processes transactions asynchronously after they are committed to the main database: [2](#0-1) 

When the indexer processes events from version V, but the latest state is at version L (where L > V), the translator queries resources at version L instead of V. This breaks the following invariant:

**Broken Invariant**: State Consistency - Event metadata (event keys) must be derived from the state at the time of event emission, not from future state.

**Attack Scenario:**

1. Alice creates account and CoinStore at version 100 (event handles created with GUIDs)
2. Alice receives APT deposit at version 200, emitting `CoinDeposit` V2 event
3. Alice closes CoinStore at version 500 (withdraws all coins, deletes resource)
4. Indexer processes batch including version 200 when latest version is 600
5. Translator looks up CoinStore at version 600 (latest) - NOT FOUND
6. Falls back to deterministic creation number: `EventKey::new(2, Alice_address)` [3](#0-2) 

Result: The deposit event at version 200 is indexed with key `(2, Alice)` instead of the actual key from Alice's CoinStore. When queried by the correct event key, the event won't be found. When queried by the fallback key, events from different accounts/resources may be grouped together.

This violates type safety because:
- Events with different event keys (and potentially different types) can be incorrectly grouped
- The `get_translated_v1_event_by_version_and_index()` function returns events indexed under wrong keys
- Callers expecting specific event types may receive events of different types that happen to share the fallback key [4](#0-3) 

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Event Index Corruption**: Events are permanently indexed under incorrect event keys in the `EventByKeySchema` and `EventByVersionSchema` schemas
2. **Missing Events**: API queries by correct event keys will fail to find events indexed under wrong keys
3. **Type Confusion**: Different event types can be grouped under the same fallback key, breaking type safety assumptions
4. **API Deserialization Failures**: If events with mismatched type tags and data are returned, `view_value` deserialization will fail [5](#0-4) 

This does not affect consensus or execution (indexer is read-only), but corrupts the event index which is critical for API functionality and dApp event monitoring.

## Likelihood Explanation

**High Likelihood**: This bug will occur whenever:
1. The indexer lags behind the main database (common during initial sync or heavy load)
2. Resources containing event handles are deleted or recreated between event emission and indexer processing
3. The lag window can be significant (batch size up to 10,000 transactions)

The condition is frequently met in production environments where:
- Users close accounts/CoinStores after transferring funds
- Token resources are burned
- The indexer catches up after node restart or fast sync

## Recommendation

The EventV2TranslationEngine should use `state_view_at_version()` to get state at the specific transaction version being processed, not the latest state:

```rust
// In EventV2TranslationEngine, add version parameter to methods
pub fn get_state_value_bytes_for_resource(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,  // Add this parameter
) -> Result<Option<Bytes>> {
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))?;  // Use specific version
    // ... rest of implementation
}
```

The DBIndexer should pass the transaction version to the translation engine: [6](#0-5) 

Modify line 451 to pass the version parameter through the translation chain.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_event_translation_wrong_state_version() {
    // Setup: Create account with CoinStore
    let (mut executor, genesis_key) = create_executor();
    let account = create_account(&mut executor, &genesis_key);
    
    // Version 100: Mint coins to account (CoinStore created)
    let mint_txn = mint_coins(&account, 1000);
    let version_100 = executor.execute_and_commit(mint_txn);
    
    // Version 200: Receive deposit (emits CoinDeposit V2 event)
    let deposit_txn = deposit_to_account(&account, 500);
    let version_200 = executor.execute_and_commit(deposit_txn);
    let actual_event_key = get_deposit_event_key(&executor, &account, version_200);
    
    // Version 500: Close account (deletes CoinStore)
    let withdraw_all = withdraw_all_and_close(&account);
    executor.execute_and_commit(withdraw_all);
    
    // Simulate indexer processing version 200 with latest state at 500
    let indexer = DBIndexer::new(internal_db, executor.db_reader());
    
    // Bug: Translator uses state at version 500 (CoinStore deleted)
    // Falls back to deterministic key instead of actual_event_key
    let translated_event = indexer
        .translate_event_v2_to_v1(&deposit_event_v2)
        .unwrap()
        .unwrap();
    
    let indexed_key = translated_event.key();
    let expected_fallback_key = EventKey::new(2, account.address());
    
    // Assertion: Event indexed with wrong key
    assert_eq!(indexed_key, &expected_fallback_key);  // Passes - BUG!
    assert_ne!(indexed_key, &actual_event_key);  // Keys don't match - CORRUPTION!
    
    // Query by actual key fails to find the event
    let events = indexer.get_events_by_event_key(&actual_event_key, 0, Order::Ascending, 10, version_200)?;
    assert!(events.is_empty());  // Event not found - DATA LOSS!
}
```

The test demonstrates that events are indexed under incorrect keys when resources are deleted after event emission but before indexer processing, confirming the state inconsistency vulnerability.

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L244-273)
```rust
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L167-198)
```rust
    pub async fn run(&mut self, node_config: &NodeConfig) -> Result<()> {
        let mut start_version = self.get_start_version(node_config).await?;
        let mut target_version = self.db_indexer.main_db_reader.ensure_synced_version()?;
        let mut step_timer = std::time::Instant::now();

        loop {
            if target_version <= start_version {
                match self.update_receiver.changed().await {
                    Ok(_) => {
                        (step_timer, target_version) = *self.update_receiver.borrow();
                    },
                    Err(e) => {
                        panic!("Failed to get update from update_receiver: {}", e);
                    },
                }
            }
            let next_version = self.db_indexer.process(start_version, target_version)?;
            INDEXER_DB_LATENCY.set(step_timer.elapsed().as_millis() as i64);
            log_grpc_step(
                SERVICE_TYPE,
                IndexerGrpcStep::InternalIndexerDBProcessed,
                Some(start_version as i64),
                Some(next_version as i64),
                None,
                None,
                Some(step_timer.elapsed().as_secs_f64()),
                None,
                Some((next_version - start_version) as i64),
                None,
            );
            start_version = next_version;
        }
```

**File:** storage/indexer/src/db_indexer.rs (L294-302)
```rust
    pub fn get_translated_v1_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEventV1> {
        self.db
            .get::<TranslatedV1EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```

**File:** storage/indexer/src/db_indexer.rs (L448-483)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
```

**File:** api/types/src/convert.rs (L612-624)
```rust
    pub fn try_into_versioned_events(
        &self,
        events: &[EventWithVersion],
    ) -> Result<Vec<VersionedEvent>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.event.type_tag(), event.event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```
