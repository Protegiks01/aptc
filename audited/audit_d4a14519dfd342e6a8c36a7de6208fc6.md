# Audit Report

## Title
Event Storage Spam Attack via Zero Storage Fees in DiskSpacePricing V2

## Summary
The DiskSpacePricing V2 model eliminates storage fees for events (returning 0 from `legacy_storage_fee_per_event`), relying solely on IO gas charges to prevent spam. However, at ~$1 per GB, the economic cost to attackers is insufficient to prevent large-scale event spam attacks that impose disproportionate storage, bandwidth, and indexing burdens on validators and infrastructure nodes. [1](#0-0) 

## Finding Description
In the transition from DiskSpacePricing V1 to V2 (enabled when `gas_feature_version >= 13` and `REFUNDABLE_BYTES` feature is active), events became "free" from a storage fee perspective. The `legacy_storage_fee_per_event()` function explicitly returns `0.into()` for V2: [2](#0-1) 

While events still incur IO gas charges, the cost structure creates an exploitable economic asymmetry:

**Attacker Cost Calculation:**
- IO gas charge: 89 internal gas units per byte [3](#0-2) 

- Maximum event data per transaction: 10MB (enforced by `ChangeSetConfigs`) [4](#0-3) 

- Cost for 10MB events: 10,485,760 bytes Ã— 89 internal gas = 933,232,640 internal gas
- Converting to external gas: 933,232,640 / 1,000,000 = 933.23 external gas units [5](#0-4) 

- At 100 octas/gas: 93,323 octas = 0.00093323 APT per 10MB [6](#0-5) 

- **Cost per TB: ~97.8 APT (~$978 at $10/APT)**

**Attack Vector:**
1. Attacker deploys a Move module that emits maximum-size events
2. Repeatedly calls this module to spam events at ~$1/GB cost
3. Validators must store events (default retention: 150M versions) and sync them across the network
4. Archive nodes and indexers that don't prune face permanent storage growth

**Infrastructure Impact:**
The event processing is charged only through IO gas, with no storage fee applied in V2: [7](#0-6) 

Events are stored by validators and must be synced across the network, but pruning is configurable and many nodes (archive nodes, indexers) retain events indefinitely: [8](#0-7) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **Validator node slowdowns**: For $10,000, an attacker can spam ~10TB of event data, causing:
   - Storage exhaustion (even temporary retention burdens validators)
   - Bandwidth saturation (all validators must sync event data)
   - Indexing overhead (API nodes process and store events)
   - Query degradation (bloated event stores slow down lookups)

2. **Significant protocol violations**: The economic model fails to adequately protect network resources. The cost asymmetry enables attacks where the attacker's one-time cost (~$1/GB) is dwarfed by the aggregate infrastructure burden across all validators and service providers.

3. **Resource Limits Invariant Violation**: While gas limits are technically enforced, the economic model violates the principle that "all operations must respect storage and computational limits" by allowing cheap storage spam that exceeds validators' operational budgets.

## Likelihood Explanation
**Likelihood: High**

- **Low attacker cost**: $1,000 generates 1TB of event spam, $100,000 generates 100TB
- **No special privileges required**: Any user can deploy a contract and emit events
- **Simple exploitation**: Standard Move contract with event emission, no complex exploit chain needed
- **Sustained attack feasible**: Attacker can continuously spam events as long as funds last
- **Multiple attack motivations**: Competitor attacks, ransom demands, ideological disruption, or simply testing infrastructure limits

The attack is particularly attractive because:
1. Event data multiplies across all validators (bandwidth cost amplification)
2. Archive nodes/indexers may never prune (permanent storage growth)
3. Default pruning retention (150M versions) means spam persists for extended periods
4. No circuit breakers or additional rate limits exist beyond per-account mempool limits

## Recommendation

**Immediate Mitigation:**
1. Reintroduce storage fees for events in V2, even if set to a lower rate than V1
2. Implement stricter per-transaction event size limits (reduce from 10MB)
3. Add per-block or per-epoch aggregate event size limits

**Comprehensive Fix:**
```rust
// In space_pricing.rs, modify legacy_storage_fee_per_event for V2:
pub fn legacy_storage_fee_per_event(
    &self,
    params: &TransactionGasParameters,
    event: &ContractEvent,
) -> Fee {
    match self {
        Self::V1 => {
            NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
        },
        Self::V2 => {
            // Apply reduced but non-zero storage fee for events
            // to prevent economic spam attacks
            NumBytes::new(event.size() as u64) * params.storage_fee_per_event_byte_v2
        }
    }
}
```

Add new gas parameter `storage_fee_per_event_byte_v2` set to a value that makes TB-scale spam economically infeasible (e.g., 10x current IO gas rate).

**Alternative Approaches:**
- Implement dynamic pricing that increases with event volume
- Add per-epoch aggregate event size caps enforced at consensus level
- Implement account-based event rate limiting beyond mempool constraints

## Proof of Concept

```move
// spam_events.move
module attacker::event_spam {
    use std::vector;
    use aptos_framework::event;
    
    struct SpamEvent has drop, store {
        data: vector<u8>
    }
    
    // Emit maximum size events to spam validator storage
    public entry fun spam_max_events(account: &signer) {
        let i = 0;
        // Create events totaling close to 10MB limit
        while (i < 100) {
            let large_data = vector::empty<u8>();
            let j = 0;
            // Each event ~100KB, total ~10MB
            while (j < 100000) {
                vector::push_back(&mut large_data, 0xFF);
                j = j + 1;
            };
            
            event::emit(SpamEvent {
                data: large_data
            });
            i = i + 1;
        };
    }
}
```

**Exploitation Steps:**
1. Deploy the above module
2. Execute `spam_max_events()` repeatedly (limited only by account funds)
3. Each transaction costs ~0.00093323 APT (~$0.01) but generates 10MB of event data
4. 100 transactions ($1) = 1GB of validator event storage
5. Monitor validator metrics for increased storage utilization, sync times, and API latency

**Verification:**
```bash
# Monitor validator event storage growth
du -sh /var/aptos/data/events/

# Check state sync bandwidth consumption
nethogs -d 5

# Query API event endpoints to observe degradation
curl -X GET "https://fullnode.mainnet.aptoslabs.com/v1/accounts/{address}/events/{event_handle}/{field_name}"
```

## Notes

The vulnerability stems from the V2 pricing model's assumption that events are "ephemeral" and can be aggressively pruned. However, in practice:

1. **Pruning varies by node type**: Archive nodes, indexers, and API services often retain events indefinitely for historical queries
2. **Default retention is long**: 150M versions before pruning kicks in
3. **Economic model mismatch**: IO gas alone (~89 internal gas/byte) is insufficient to prevent spam attacks that cost validators far more in aggregate

While the design may be intentional to reduce costs for legitimate event usage, it creates an exploitable attack surface where the economic cost to attackers is asymmetrically lower than the operational burden imposed on network infrastructure.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L36-43)
```rust
impl DiskSpacePricing {
    pub fn new(gas_feature_version: u64, features: &Features) -> Self {
        if gas_feature_version >= 13 && features.is_refundable_bytes_enabled() {
            Self::V2
        } else {
            Self::V1
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L58-69)
```rust
    pub fn legacy_storage_fee_per_event(
        &self,
        params: &TransactionGasParameters,
        event: &ContractEvent,
    ) -> Fee {
        match self {
            Self::V1 => {
                NumBytes::new(event.size() as u64) * params.legacy_storage_fee_per_event_byte
            },
            Self::V2 => 0.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L22-22)
```rust
const GAS_SCALING_FACTOR: u64 = 1_000_000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L133-136)
```rust
            storage_io_per_event_byte_write: InternalGasPerByte,
            { RELEASE_V1_11.. => "storage_io_per_event_byte_write" },
            89,
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** config/global-constants/src/lib.rs (L26-26)
```rust
pub const GAS_UNIT_PRICE: u64 = 100;
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L195-202)
```rust
        // Events (no event fee in v2)
        let event_fee = change_set.events_iter().fold(Fee::new(0), |acc, event| {
            acc + pricing.legacy_storage_fee_per_event(params, event)
        });
        let event_discount = pricing.legacy_storage_discount_for_events(params, event_fee);
        let event_net_fee = event_fee
            .checked_sub(event_discount)
            .expect("event discount should always be less than or equal to total amount");
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L296-301)
```rust
    pub fn io_gas_per_event(
        &self,
        event: &ContractEvent,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_EVENT_BYTE_WRITE * NumBytes::new(event.size() as u64)
    }
```
