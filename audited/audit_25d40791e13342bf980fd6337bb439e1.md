# Audit Report

## Title
DKG Transcript Verification Panic Enables Validator DoS During Epoch Transitions

## Summary
The DKG (Distributed Key Generation) transcript verification code uses `.expect()` for error handling in critical cryptographic operations, converting recoverable errors into node-crashing panics. A malicious validator can craft a PVSS transcript with oversized ciphertext chunk vectors that trigger index-out-of-bounds panics or MSM failures during verification, causing honest validator nodes to crash and potentially preventing successful DKG completion required for epoch transitions.

## Finding Description

The vulnerability exists in the PVSS transcript verification path where cryptographic operations use `.expect()` instead of propagating errors gracefully.

**Primary Vulnerability Location:** [1](#0-0) 

The `msm_eval()` function uses `.expect()` to handle MSM failures, converting any error into a panic.

**Critical Verification Path:** [2](#0-1) 

During transcript verification, the code iterates over ciphertext chunks and accesses `pp.powers_of_radix[j]` without validating that `j < pp.powers_of_radix.len()`. If a malicious transcript contains ciphertexts with more chunks than expected (i.e., `Cs_flat[i].len() > num_chunks_per_scalar`), this causes an index-out-of-bounds panic.

Additionally, MSM operations use `.expect()`: [3](#0-2) 

**Validation Gap:** [4](#0-3) 

The verification checks validate outer vector dimensions (number of players) but do NOT validate that each ciphertext has the correct number of chunks matching `num_chunks_per_scalar(ell)`.

**Attack Vector:**

When validators process DKG transcripts from peers: [5](#0-4) 

A malicious validator can broadcast a transcript that passes deserialization but contains malformed chunk arrays. When honest validators call `verify_transcript()`: [6](#0-5) 

The verification code panics, crashing the validator process. This is a **Byzantine fault amplification attack** where one malicious validator (< 1/3 Byzantine threshold) can crash multiple honest validators, preventing the DKG session from reaching the required voting power threshold.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability enables:

1. **Validator Node Crashes**: Each honest validator attempting to verify the malicious transcript will panic and crash
2. **DKG Session Failure**: If enough validators crash, the DKG cannot complete, blocking epoch transitions
3. **Network Liveness Impact**: Failed epoch transitions prevent validator set updates, stake changes, and governance execution
4. **Consensus Disruption**: The network may be unable to progress to new epochs without manual intervention

The impact qualifies as "Validator node slowdowns" and "Significant protocol violations" under High Severity criteria. While not causing direct fund loss, it can halt network progression and require coordinated recovery.

## Likelihood Explanation

**Likelihood: High**

- **Low Complexity**: Crafting an oversized chunk vector requires minimal effort
- **No Special Privileges Required**: Any validator (within Byzantine threshold) can execute this attack
- **Guaranteed Trigger**: The panic is deterministic when chunk lengths exceed bounds
- **Multiple Attack Windows**: Occurs during every epoch transition when DKG runs
- **Detection Difficulty**: The malicious transcript passes deserialization and initial checks

The attack is trivial to execute and reliably disrupts the DKG process.

## Recommendation

**Immediate Fix**: Replace all `.expect()` calls with proper error propagation in DKG verification paths.

**For `univariate_kzg.rs`:**
```rust
fn msm_eval(input: Self::MsmInput) -> Result<Self::MsmOutput, anyhow::Error> {
    E::G1::msm(input.bases(), input.scalars())
        .map_err(|e| anyhow::anyhow!("MSM failed in univariate KZG: {:?}", e))
}
```

**For `weighted_transcript.rs` verification:**

Add chunk length validation before accessing arrays:
```rust
let expected_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
for i in 0..Cs_flat.len() {
    if Cs_flat[i].len() != expected_chunks {
        bail!("Invalid chunk count at index {}: expected {}, got {}", 
              i, expected_chunks, Cs_flat[i].len());
    }
    for j in 0..Cs_flat[i].len() {
        // ... rest of loop
    }
}
```

Replace `.expect()` with `?` operator:
```rust
let weighted_Cs = E::G1::msm(&E::G1::normalize_batch(&base_vec), &exp_vec)?;
let weighted_Vs = E::G2::msm(&E::G2::normalize_batch(&Vs_flat[..sc.get_total_weight()]), 
                             &powers_of_beta[..sc.get_total_weight()])?;
```

**Update function signatures** to return `Result<(), anyhow::Error>` and propagate errors to the DKG manager where they can be logged and handled gracefully.

## Proof of Concept

```rust
#[cfg(test)]
mod dkg_panic_test {
    use super::*;
    use aptos_crypto::bls12381::bls12381_keys::PrivateKey;
    use aptos_dkg::pvss::chunky::weighted_transcript::Transcript;
    use ark_serialize::CanonicalSerialize;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_oversized_chunks_cause_panic() {
        // Setup: Create normal DKG public parameters
        let pp = create_test_public_params();
        let sc = create_test_sharing_config();
        
        // Craft malicious transcript with oversized chunk vectors
        let mut malicious_transcript = create_valid_transcript(&pp, &sc);
        
        // Inject oversized chunks (more than num_chunks_per_scalar)
        let excess_chunks = 10;
        let expected_chunks = num_chunks_per_scalar::<Fr>(pp.ell) as usize;
        for i in 0..malicious_transcript.subtrs.Cs.len() {
            for j in 0..malicious_transcript.subtrs.Cs[i].len() {
                // Add extra chunks beyond the expected count
                malicious_transcript.subtrs.Cs[i][j]
                    .extend(vec![random_g1_point(); excess_chunks]);
            }
        }
        
        // Serialize the malicious transcript
        let mut bytes = Vec::new();
        malicious_transcript.serialize_compressed(&mut bytes).unwrap();
        
        // Victim validator attempts verification - this will panic!
        let transcript: Transcript<Bls12_381> = bcs::from_bytes(&bytes).unwrap();
        transcript.verify(&sc, &pp, &signing_keys, &encryption_keys, &session_id)
            .expect("Should panic before reaching this point");
    }
}
```

## Notes

This vulnerability demonstrates a **critical error handling antipattern** in consensus-critical code. The use of `.expect()` in cryptographic verification paths violates defensive programming principles and enables Byzantine fault amplification. Proper error propagation would allow validators to reject malicious transcripts gracefully without crashing, maintaining network liveness even under Byzantine attack.

The fix requires systematic replacement of panic-based error handling with Result propagation throughout the DKG verification stack, ensuring that malformed inputs are rejected with logged errors rather than process termination.

### Citations

**File:** crates/aptos-dkg/src/pcs/univariate_kzg.rs (L65-67)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput {
        E::G1::msm(input.bases(), input.scalars()).expect("MSM failed in univariate KZG")
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L133-153)
```rust
        if eks.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} encryption keys, but got {}",
                sc.get_total_num_players(),
                eks.len()
            );
        }
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L255-265)
```rust
        for i in 0..Cs_flat.len() {
            for j in 0..Cs_flat[i].len() {
                let base = Cs_flat[i][j];
                let exp = pp.powers_of_radix[j] * powers_of_beta[i];
                base_vec.push(base);
                exp_vec.push(exp);
            }
        }

        let weighted_Cs = E::G1::msm(&E::G1::normalize_batch(&base_vec), &exp_vec)
            .expect("Failed to compute MSM of Cs in chunky");
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L267-271)
```rust
        let weighted_Vs = E::G2::msm(
            &E::G2::normalize_batch(&Vs_flat[..sc.get_total_weight()]), // Don't use the last entry of `Vs_flat`
            &powers_of_beta[..sc.get_total_weight()],
        )
        .expect("Failed to compute MSM of Vs in chunky");
```

**File:** dkg/src/transcript_aggregation/mod.rs (L88-101)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
        let mut trx_aggregator = self.trx_aggregator.lock();
        if trx_aggregator.contributors.contains(&metadata.author) {
            return Ok(None);
        }

        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-112)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```
