# Audit Report

## Title
Memory Exhaustion via Unbounded EpochEndingLedgerInfos Vector in State Sync

## Summary
A malicious peer can send `EpochEndingLedgerInfos` responses containing an arbitrarily large vector of `LedgerInfoWithSignatures`, causing memory exhaustion on victim nodes. The vulnerability exists because size limits enforced when creating responses are not validated when receiving responses from untrusted peers.

## Finding Description

The vulnerability exists in the state sync data streaming service's handling of epoch ending ledger info responses. While the storage service enforces limits when creating responses (`max_epoch_chunk_size`: 200, `max_network_chunk_bytes`: 10 MiB), these limits are **not validated** when a node receives responses from peers. [1](#0-0) 

The `DataPayload::EpochEndingLedgerInfos` variant contains an unbounded `Vec<LedgerInfoWithSignatures>`.

**Attack Flow:**

1. **Response Creation Without Validation**: When the data client receives a response, it converts the `StorageServiceResponse` to `EpochChangeProof` without any size validation: [2](#0-1) 

2. **BCS Deserialization**: The response is deserialized using BCS, which will deserialize vectors of any size: [3](#0-2) 

3. **No Size Validation in Stream Engine**: The stream engine only checks if the vector is empty, but does not validate its size: [4](#0-3) 

4. **Direct Pass-Through**: The data notification is created without size validation: [5](#0-4) 

5. **Bootstrapper Processing**: The bootstrapper processes all ledger infos without size limits: [6](#0-5) 

**Why Storage Service Limits Don't Protect:**

The storage service implements size limits only when **creating** responses: [7](#0-6) 

However, a malicious peer can bypass these limits by directly crafting network messages.

**Memory Amplification:**

While the network layer limits serialized messages to 64 MiB: [8](#0-7) 

The deserialized `LedgerInfoWithSignatures` structures consume significantly more memory than their serialized form. A malicious peer can pack thousands of compact serialized ledger infos into a 64 MiB message, which when deserialized, expands to hundreds of MiB or GiB in heap memory.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **Validator node slowdowns**: Processing millions of ledger infos causes CPU exhaustion during verification loops
- **Memory exhaustion**: Large vectors consume excessive heap memory, potentially crashing nodes
- **Repeated attacks**: Attacker can send multiple malicious responses, causing sustained DoS
- **Network-wide impact**: Multiple nodes can be targeted simultaneously

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: High**

- **No authentication required**: Any peer can send malicious responses
- **No special privileges needed**: Attack works from any network position
- **Easy to execute**: Attacker only needs to craft a single malicious response
- **Difficult to detect**: Legitimate epoch ending responses can also be large
- **No existing mitigations**: No size validation in the entire receive path

## Recommendation

Implement size validation when receiving `EpochEndingLedgerInfos` responses. Add validation at multiple layers:

**1. In the TryFrom conversion (responses.rs):**
```rust
impl TryFrom<StorageServiceResponse> for EpochChangeProof {
    type Error = crate::responses::Error;

    fn try_from(response: StorageServiceResponse) -> crate::Result<Self, Self::Error> {
        let data_response = response.get_data_response()?;
        match data_response {
            DataResponse::EpochEndingLedgerInfos(inner) => {
                // Add size validation
                const MAX_EPOCH_ENDING_LEDGER_INFOS: usize = 200; // From MAX_EPOCH_CHUNK_SIZE
                if inner.ledger_info_with_sigs.len() > MAX_EPOCH_ENDING_LEDGER_INFOS {
                    return Err(Error::UnexpectedResponseError(format!(
                        "Epoch ending ledger infos response exceeds maximum size. Got: {}, Max: {}",
                        inner.ledger_info_with_sigs.len(),
                        MAX_EPOCH_ENDING_LEDGER_INFOS
                    )));
                }
                Ok(inner)
            },
            _ => Err(Error::UnexpectedResponseError(format!(
                "expected epoch_ending_ledger_infos, found {}",
                data_response.get_label()
            ))),
        }
    }
}
```

**2. In the stream engine transformation (stream_engine.rs):**
```rust
// In transform_client_response_into_notification
let last_received_epoch = match &client_response_payload {
    ResponsePayload::EpochEndingLedgerInfos(ledger_infos) => {
        // Verify that we received at least one ledger info
        if ledger_infos.is_empty() {
            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                "Received an empty epoch ending ledger info response! Request: {:?}",
                client_request
            )));
        }
        
        // Add maximum size validation
        if ledger_infos.len() > MAX_EPOCH_CHUNK_SIZE as usize {
            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                "Epoch ending ledger info response too large! Got: {}, Max: {}",
                ledger_infos.len(),
                MAX_EPOCH_CHUNK_SIZE
            )));
        }
        
        // Return the last epoch
        ledger_infos
            .last()
            .map(|ledger_info| ledger_info.ledger_info().epoch())
            .unwrap_or(request.start_epoch)
    },
    _ => invalid_response_type!(client_response_payload),
};
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability (add to state-sync/data-streaming-service/src/tests/)
#[tokio::test]
async fn test_oversized_epoch_ending_ledger_infos() {
    use crate::data_notification::{DataPayload, DataNotification};
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    // Create a malicious response with excessive ledger infos
    let mut malicious_ledger_infos = Vec::new();
    for _ in 0..10000 {  // 10,000 items (far exceeding the limit of 200)
        malicious_ledger_infos.push(create_test_ledger_info_with_sigs());
    }
    
    // Attempt to create a data payload
    let data_payload = DataPayload::EpochEndingLedgerInfos(malicious_ledger_infos.clone());
    
    // This should be rejected but currently is not
    assert!(malicious_ledger_infos.len() > 200, 
            "Test payload should exceed MAX_EPOCH_CHUNK_SIZE");
    
    // Demonstrate memory consumption
    let serialized = bcs::to_bytes(&data_payload).unwrap();
    let deserialized_size = std::mem::size_of_val(&data_payload);
    
    println!("Serialized size: {} bytes", serialized.len());
    println!("Estimated deserialized size: {} bytes", deserialized_size);
    
    // In a real attack, this would consume excessive memory and CPU
    // during verification in the bootstrapper
}
```

**Notes:**
- The PoC demonstrates that no validation prevents oversized vectors
- In production, an attacker would craft a network message with thousands of ledger infos
- Each ledger info requires signature verification, causing CPU exhaustion
- Multiple concurrent attacks could crash validator nodes

### Citations

**File:** state-sync/data-streaming-service/src/data_notification.rs (L46-46)
```rust
    EpochEndingLedgerInfos(Vec<LedgerInfoWithSignatures>),
```

**File:** state-sync/storage-service/types/src/responses.rs (L105-106)
```rust
                let data_response = bcs::from_bytes::<DataResponse>(&raw_data)
                    .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
```

**File:** state-sync/storage-service/types/src/responses.rs (L341-353)
```rust
impl TryFrom<StorageServiceResponse> for EpochChangeProof {
    type Error = crate::responses::Error;

    fn try_from(response: StorageServiceResponse) -> crate::Result<Self, Self::Error> {
        let data_response = response.get_data_response()?;
        match data_response {
            DataResponse::EpochEndingLedgerInfos(inner) => Ok(inner),
            _ => Err(Error::UnexpectedResponseError(format!(
                "expected epoch_ending_ledger_infos, found {}",
                data_response.get_label()
            ))),
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1605-1612)
```rust
                    ResponsePayload::EpochEndingLedgerInfos(ledger_infos) => {
                        // Verify that we received at least one ledger info
                        if ledger_infos.is_empty() {
                            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                                "Received an empty epoch ending ledger info response! Request: {:?}",
                                client_request
                            )));
                        }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2200-2201)
```rust
        ResponsePayload::EpochEndingLedgerInfos(ledger_infos) => {
            DataPayload::EpochEndingLedgerInfos(ledger_infos)
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1081-1106)
```rust
        if epoch_ending_ledger_infos.is_empty() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(
                "The epoch ending payload was empty!".into(),
            ));
        }

        // Verify the epoch change proofs, update our latest epoch state and
        // verify our waypoint.
        for epoch_ending_ledger_info in epoch_ending_ledger_infos {
            if let Err(error) = self.verified_epoch_states.update_verified_epoch_states(
                &epoch_ending_ledger_info,
                &self.driver_configuration.waypoint,
            ) {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
        }
```

**File:** state-sync/storage-service/server/src/storage.rs (L219-220)
```rust
        let max_num_ledger_infos = self.config.max_epoch_chunk_size;
        let num_ledger_infos_to_fetch = min(expected_num_ledger_infos, max_num_ledger_infos);
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
