# Audit Report

## Title
Integer Overflow in Gas Validation Causes Validator Panic and Network Halt

## Summary
The gas validation logic performs unchecked u64 multiplication of governance-controlled parameters (`gas_unit_price * max_gas_amount`), which can cause validator nodes to panic and halt the network if governance misconfigures gas parameters such that their product exceeds `u64::MAX`.

## Finding Description
The `check_gas` function validates transaction gas parameters during the "Check Size and Gas" phase of transaction processing. When checking if a transaction has sufficient gas for account creation, the code performs raw u64 multiplication without overflow protection: [1](#0-0) 

The multiplication `gas_unit_price * max_gas_amount` can overflow if governance sets parameters where:
- `maximum_number_of_gas_units * max_price_per_gas_unit > u64::MAX`

While transaction values are validated against these limits: [2](#0-1) [3](#0-2) 

There is no validation ensuring the governance parameters themselves maintain the safety invariant. The code comment explicitly acknowledges this requirement: [4](#0-3) 

However, when governance updates gas parameters, no validation enforces this constraint. The governance update logic has explicit TODOs noting missing consistency checks: [5](#0-4) 

Since Aptos builds with `overflow-checks = true` in release mode: [6](#0-5) 

Any overflow causes a panic rather than wrapping. When validators process transactions that trigger this code path (account creation scenarios where `should_create_account_resource()` returns true), they will panic and crash.

**Attack Scenario:**
1. Governance proposes and passes a gas schedule update where `maximum_number_of_gas_units = 10,000,000,000` and `max_price_per_gas_unit = 10,000,000,000` (product = 10^20 > u64::MAX ≈ 1.8 × 10^19)
2. A user submits a transaction to a non-existent account with sponsor paying gas
3. During `check_gas` validation at line 233, the multiplication overflows
4. All validators processing this transaction panic simultaneously
5. Network halts due to consensus failure

## Impact Explanation
**Critical Severity** - This vulnerability causes total loss of network availability, meeting the critical severity criteria:

1. **Consensus Safety Violation**: Breaks the invariant that "All validators must produce identical state roots for identical blocks" - validators crash instead of processing blocks
2. **Network Availability**: Total loss of liveness as all validators crash when encountering affected transactions
3. **Non-recoverable without intervention**: Requires emergency governance action or hard fork to fix gas parameters
4. **Deterministic Execution Violation**: Node crashes are non-deterministic failures that prevent block processing

The vulnerability affects the core transaction validation path called for every user transaction. [7](#0-6) 

## Likelihood Explanation
**Medium Likelihood** - While exploitation requires governance misconfiguration rather than direct attacker action, several factors increase the risk:

1. **No Defensive Validation**: The code lacks parameter validation despite explicit TODOs acknowledging the need
2. **Governance Complexity**: Gas parameter updates are complex governance decisions where mistakes are possible
3. **Developer Awareness**: The comment indicates developers know this invariant should be maintained but haven't implemented enforcement
4. **Cascading Failure**: Once bad parameters are set, ANY transaction meeting the conditions triggers crashes across ALL validators simultaneously

Current production values are safe (2M × 10B = 2 × 10^16 < u64::MAX), but future governance updates could inadvertently violate the constraint without validation preventing it.

## Recommendation
Implement validation in the gas schedule governance update logic to enforce the overflow safety invariant:

```move
// In aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate gas parameter consistency to prevent overflow
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

// Helper function to validate gas schedule parameters
fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Extract critical parameters
    let max_gas_units = extract_param(schedule, b"txn.maximum_number_of_gas_units");
    let max_gas_price = extract_param(schedule, b"txn.max_price_per_gas_unit");
    
    // Ensure multiplication won't overflow u64
    // Check: max_gas_units * max_gas_price < u64::MAX
    assert!(
        (max_gas_units as u128) * (max_gas_price as u128) <= MAX_U64,
        error::invalid_argument(EINVALID_GAS_SCHEDULE)
    );
}
```

Additionally, add defensive checked arithmetic in the Rust code:

```rust
// In aptos-move/aptos-vm/src/gas.rs, replace line 233:
let actual = gas_unit_price
    .checked_mul(max_gas_amount)
    .ok_or_else(|| {
        VMStatus::error(
            StatusCode::ARITHMETIC_ERROR,
            Some("Gas calculation overflow".to_string()),
        )
    })?;
```

## Proof of Concept

**Step 1: Governance Proposal to Set Unsafe Parameters**
```move
script {
    use aptos_framework::gas_schedule;
    use aptos_framework::aptos_governance;
    
    fun set_unsafe_gas_params(framework: &signer) {
        // Create gas schedule with parameters that overflow when multiplied
        // maximum_number_of_gas_units: 10,000,000,000 (10B)
        // max_price_per_gas_unit: 10,000,000,000 (10B)  
        // Product: 10^20 > u64::MAX (≈1.8 × 10^19)
        
        let unsafe_gas_schedule_blob = create_unsafe_schedule();
        gas_schedule::set_for_next_epoch(framework, unsafe_gas_schedule_blob);
        aptos_governance::reconfigure(framework);
    }
}
```

**Step 2: Transaction Triggering the Overflow**
```rust
// Rust test in aptos-move/aptos-vm/src/gas.rs
#[test]
#[should_panic(expected = "overflow")]
fn test_gas_overflow_panic() {
    // Set up VM with unsafe gas parameters
    let gas_params = AptosGasParameters {
        txn: TransactionGasParameters {
            maximum_number_of_gas_units: 10_000_000_000.into(),
            max_price_per_gas_unit: 10_000_000_000.into(),
            // ... other params
        },
        // ... other params  
    };
    
    // Create transaction metadata with max values
    let txn_metadata = TransactionMetadata {
        max_gas_amount: 10_000_000_000.into(),
        gas_unit_price: 10_000_000_000.into(),
        sender: account_address_from_hex("0x1"),
        // ... other fields
    };
    
    // This will panic due to overflow in line 233
    check_gas(
        &gas_params,
        gas_feature_version,
        &resolver,
        &module_storage,
        &txn_metadata,
        &features,
        false,
        &log_context,
    );
}
```

**Expected Result**: Validator panics with arithmetic overflow error, causing network disruption when multiple validators process the same transaction.

## Notes
This vulnerability demonstrates a critical gap in defensive programming where governance-controlled parameters lack validation to prevent catastrophic failure modes. While current parameters are safe, the missing validation violates the defense-in-depth principle and creates a high-impact failure path that could be triggered by governance misconfiguration rather than malicious intent.

### Citations

**File:** aptos-move/aptos-vm/src/gas.rs (L126-139)
```rust
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L195-208)
```rust
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L213-233)
```rust
    let gas_unit_price: u64 = txn_metadata.gas_unit_price().into();
    if crate::aptos_vm::should_create_account_resource(
        txn_metadata,
        features,
        resolver,
        module_storage,
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
    {
        let max_gas_amount: u64 = txn_metadata.max_gas_amount().into();
        let pricing = DiskSpacePricing::new(gas_feature_version, features);
        let storage_fee_per_account_create: u64 = pricing
            .hack_estimated_fee_for_account_creation(txn_gas_params)
            .into();

        let expected = gas_unit_price * 10
            + if features.is_new_account_default_to_fa_store() {
                1
            } else {
                2
            } * storage_fee_per_account_create;
        let actual = gas_unit_price * max_gas_amount;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L50-58)
```rust
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
        // computational time of any given transaction at roughly 20 seconds. We want this number and
        // `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
        [
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2793-2814)
```rust
    fn run_prologue_with_payload(
        &self,
        session: &mut SessionExt<impl AptosMoveResolver>,
        module_storage: &impl ModuleStorage,
        serialized_signers: &SerializedSigners,
        executable: TransactionExecutableRef,
        extra_config: TransactionExtraConfig,
        txn_data: &TransactionMetadata,
        log_context: &AdapterLogSchema,
        is_approved_gov_script: bool,
        traversal_context: &mut TraversalContext,
    ) -> Result<(), VMStatus> {
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```
