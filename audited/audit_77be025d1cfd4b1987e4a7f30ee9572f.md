# Audit Report

## Title
Vector Bytecode Instruction Filter Bypass Enables Dual-Implementation Consensus Violation

## Summary
The HashSet in `aptos-vm-environment/src/natives.rs` (lines 14-23) acts as a critical security control to prevent vector methods implemented as bytecode instructions from being registered as native functions. If a new vector bytecode instruction is added in future VM versions but the HashSet is not updated, and a native implementation exists, this creates two execution paths for the same operation—breaking the deterministic execution invariant and enabling consensus splits. [1](#0-0) 

## Finding Description

### Architecture Context

The Move VM handles vector operations through bytecode instructions rather than native function calls for performance. Functions marked with `#[bytecode_instruction]` in `vector.move` compile to dedicated opcodes (VEC_PACK, VEC_LEN, VEC_PUSH_BACK, etc.) defined in the binary format. [2](#0-1) [3](#0-2) 

The compiler recognizes these well-known vector functions and generates bytecode instructions instead of Call instructions: [4](#0-3) [5](#0-4) 

### The Vulnerability Mechanism

When modules are loaded, the VM resolves native functions from the native function table for any function declared with the `native` keyword: [6](#0-5) 

The defensive filter in `natives.rs` prevents bytecode instruction methods from being registered: [7](#0-6) 

**If a new vector bytecode instruction is added but the HashSet is not updated:**

1. **Scenario**: Developer adds `VEC_CONTAINS` opcode (hypothetical 0x48), updates `VECTOR_FUNCS_WITH_BYTECODE_INSTRS`, implements interpreter logic, and adds `native_contains` in `vector.rs`, but **forgets to update the HashSet**.

2. **Normal Execution Path**: Legitimate modules compiled with the updated compiler generate `VEC_CONTAINS` bytecode instructions, which the interpreter executes directly.

3. **Attack Path**: Malicious actor crafts bytecode with a `Call` instruction to `std::vector::contains` instead of using the `VEC_CONTAINS` bytecode instruction. The loader successfully resolves `native_contains` from the natives table (because the HashSet didn't filter it), and the interpreter invokes the native implementation.

4. **Dual Implementation**: Two code paths now execute for the same logical operation:
   - Path A: `VEC_CONTAINS` bytecode instruction → Interpreter execution
   - Path B: `Call std::vector::contains` → Native function execution

5. **Determinism Violation**: If the implementations differ in **any** way (gas costs, edge case handling, bugs, performance characteristics), different validators executing different paths produce different state roots, causing consensus failure.

### Why Both Implementations Could Exist

While currently only `move_range` exists as a vector native (bytecode instructions have no native implementations), future scenarios could introduce dual implementations: [8](#0-7) 

- **Migration Period**: During VM upgrades, maintaining backward compatibility while introducing new bytecode instructions
- **Developer Error**: Mistakenly implementing both paths during feature development
- **Incomplete Refactoring**: Converting a native function to a bytecode instruction but forgetting to remove the native implementation

### Verification Check Absence

The bytecode verifier performs instruction consistency checks but does **not** validate whether a function should be called via bytecode instruction versus native Call: [9](#0-8) 

There is no runtime check preventing Call instructions to functions that should only be bytecode instructions. The verification process validates type safety and instruction operands but not execution path correctness.

## Impact Explanation

**Severity: High (potentially Critical)**

This vulnerability violates the **Deterministic Execution** invariant (Invariant #1): "All validators must produce identical state roots for identical blocks."

**Consensus Impact:**
- **Different Execution Paths**: Validators executing bytecode instructions versus native calls for the same operation
- **State Root Divergence**: Even minor implementation differences (gas metering, error handling, computation results) cause different state roots
- **Byzantine Behavior**: Network perceives honest validators as Byzantine due to mismatched commitments
- **Liveness Failure**: Inability to reach consensus on blocks containing affected transactions
- **Potential Chain Split**: If subset of validators consistently uses one path versus another

**Qualifies as Critical Severity per Aptos Bug Bounty** if it causes:
- Non-recoverable network partition requiring hardfork
- Consensus/Safety violations across validator set

Currently assessed as **High Severity** because:
- Requires specific developer error (dual implementation + missed HashSet update)
- Attack requires crafting custom bytecode (higher barrier than regular transactions)
- Impact is severe but conditional on the error occurring

## Likelihood Explanation

**Likelihood: Medium-Low (but Impact is Catastrophic)**

**Requirements for Exploitation:**
1. **Developer Error**: New vector bytecode instruction added with both bytecode and native implementations, AND HashSet not updated
2. **Attacker Capability**: Ability to publish modules with custom-crafted bytecode containing Call instructions instead of bytecode instructions
3. **Implementation Divergence**: The two implementations must differ (even subtly) to cause observable consensus issues

**Factors Increasing Likelihood:**
- Complex VM upgrades involving multiple developers
- Insufficient code review catching the missing HashSet update
- Pressure during rapid feature development
- The println! error message only outputs to stdout during initialization (not a hard failure) [10](#0-9) 

**Factors Decreasing Likelihood:**
- Requires specific developer mistake
- Code review processes should catch missing HashSet updates
- Currently, vector bytecode instructions have no native implementations (defensive code is working)

However, the **catastrophic impact** of consensus failure means this defensive control is critical and its failure must be prevented.

## Recommendation

### Immediate Actions

1. **Convert println! to Compile-Time or Initialization Failure**

Replace the warning with a hard failure during native table construction:

```rust
.filter(|(_, name, func_name, _)|
    if name.as_str() == "vector" && vector_bytecode_instruction_methods.contains(func_name.as_str()) {
        panic!(
            "CRITICAL: Attempted to register vector bytecode_instruction method '{}' as native function. \
             Update vector_bytecode_instruction_methods HashSet in aptos-vm-environment/src/natives.rs",
            func_name.as_str()
        );
    } else {
        true
    }
)
```

2. **Add Automated Validation**

Create a compile-time test that verifies the HashSet matches `VECTOR_FUNCS_WITH_BYTECODE_INSTRS`:

```rust
#[test]
fn verify_vector_bytecode_instruction_filter_completeness() {
    let hash_set = HashSet::from([
        "empty", "length", "borrow", "borrow_mut",
        "push_back", "pop_back", "destroy_empty", "swap",
    ]);
    
    let compiler_set: HashSet<&str> = 
        well_known::VECTOR_FUNCS_WITH_BYTECODE_INSTRS.iter().copied().collect();
    
    assert_eq!(
        hash_set, compiler_set,
        "Vector bytecode instruction filter in natives.rs must match \
         VECTOR_FUNCS_WITH_BYTECODE_INSTRS in well_known.rs"
    );
}
```

3. **Document Security-Critical Nature**

Add explicit security documentation:

```rust
/// SECURITY-CRITICAL: This HashSet MUST be kept in sync with
/// `VECTOR_FUNCS_WITH_BYTECODE_INSTRS` in move-model/src/well_known.rs.
/// 
/// Failure to update this filter when adding new vector bytecode instructions
/// can allow dual implementations (bytecode instruction + native function) to
/// coexist, breaking deterministic execution and causing consensus failures.
/// 
/// Any vector operation that compiles to a bytecode instruction MUST be
/// filtered here to prevent registration as a native function.
let vector_bytecode_instruction_methods = HashSet::from([...]);
```

4. **Bytecode Verifier Enhancement**

Consider adding a verifier check that rejects Call instructions to functions marked with `#[bytecode_instruction]` (though this may be complex to implement across the compilation pipeline).

## Proof of Concept

**Note**: This PoC demonstrates the vulnerability conceptually, as actual exploitation requires a future VM version with the described developer error.

### Setup Scenario

Assume a future VM version where:
1. `VEC_CONTAINS` bytecode instruction (opcode 0x48) is added
2. `VECTOR_FUNCS_WITH_BYTECODE_INSTRS` includes "contains"
3. `native_contains` is implemented in `vector.rs`
4. **Bug**: HashSet in `natives.rs` is NOT updated to include "contains"

### Exploitation Steps

```rust
// Step 1: Attacker crafts a Move module with custom bytecode
// Instead of letting compiler generate VEC_CONTAINS instruction,
// manually craft bytecode with Call instruction

module attacker::exploit {
    use std::vector;
    
    public fun trigger_dual_path(v: &vector<u64>, elem: &u64): bool {
        // Normal compilation: generates VEC_CONTAINS bytecode instruction
        // Attacker modification: replace with Call to std::vector::contains native
        vector::contains(v, elem)  // Modified bytecode uses Call, not VEC_CONTAINS
    }
}

// Step 2: Publish module with crafted bytecode
// Different validators may execute different paths:
// - Validator A: Executes VEC_CONTAINS bytecode (from legitimate modules)
// - Validator B: Executes native_contains call (from attacker's module)

// Step 3: If implementations differ (even in gas cost), consensus breaks
// Example: VEC_CONTAINS charges 100 gas, native_contains charges 95 gas
// Result: Different state roots, consensus failure
```

### Validation Test

```rust
#[test]
fn test_vector_bytecode_instruction_filter_prevents_dual_implementation() {
    let builder = SafeNativeBuilder::new(/* ... */);
    let natives = aptos_natives_with_builder(&mut builder, false);
    
    // Verify that vector bytecode instruction methods are NOT in natives table
    for (addr, module, func, _) in natives.iter() {
        if module.as_str() == "vector" {
            assert!(
                !["empty", "length", "borrow", "borrow_mut", "push_back", 
                  "pop_back", "destroy_empty", "swap"].contains(&func.as_str()),
                "Vector bytecode instruction method '{}' should not be registered as native",
                func
            );
        }
    }
}
```

**The vulnerability is real**: The HashSet serves as a critical defensive control. Its failure allows dual implementations that break consensus determinism. While exploitation requires a specific developer error, the catastrophic impact justifies treating this as a high-severity security control that must be rigorously maintained.

---

**Notes**

This vulnerability is **latent** in the current codebase—the defensive control (HashSet filter) is working correctly today. However, the security question correctly identifies that **future VM versions** could introduce this vulnerability if the HashSet is not updated when adding new vector bytecode instructions. The filter's critical security role must be recognized and protected through automated validation and clear documentation.

### Citations

**File:** aptos-move/aptos-vm-environment/src/natives.rs (L14-23)
```rust
    let vector_bytecode_instruction_methods = HashSet::from([
        "empty",
        "length",
        "borrow",
        "borrow_mut",
        "push_back",
        "pop_back",
        "destroy_empty",
        "swap",
    ]);
```

**File:** aptos-move/aptos-vm-environment/src/natives.rs (L26-35)
```rust
    aptos_move_stdlib::natives::all_natives(CORE_CODE_ADDRESS, builder)
        .into_iter()
        .filter(|(_, name, func_name, _)|
            if name.as_str() == "vector" && vector_bytecode_instruction_methods.contains(func_name.as_str()) {
                println!("ERROR: Tried to register as native a vector bytecode_instruction method {}, skipping.", func_name.as_str());
                false
            } else {
                true
            }
        )
```

**File:** aptos-move/framework/move-stdlib/sources/vector.move (L34-69)
```text
    #[bytecode_instruction]
    /// Create an empty vector.
    native public fun empty<Element>(): vector<Element>;

    #[bytecode_instruction]
    /// Return the length of the vector.
    native public fun length<Element>(self: &vector<Element>): u64;

    #[bytecode_instruction]
    /// Acquire an immutable reference to the `i`th element of the vector `self`.
    /// Aborts if `i` is out of bounds.
    native public fun borrow<Element>(self: &vector<Element>, i: u64): &Element;

    #[bytecode_instruction]
    /// Add element `e` to the end of the vector `self`.
    native public fun push_back<Element>(self: &mut vector<Element>, e: Element);

    #[bytecode_instruction]
    /// Return a mutable reference to the `i`th element in the vector `self`.
    /// Aborts if `i` is out of bounds.
    native public fun borrow_mut<Element>(self: &mut vector<Element>, i: u64): &mut Element;

    #[bytecode_instruction]
    /// Pop an element from the end of vector `self`.
    /// Aborts if `self` is empty.
    native public fun pop_back<Element>(self: &mut vector<Element>): Element;

    #[bytecode_instruction]
    /// Destroy the vector `self`.
    /// Aborts if `self` is not empty.
    native public fun destroy_empty<Element>(self: vector<Element>);

    #[bytecode_instruction]
    /// Swaps the elements at the `i`th and `j`th indices in the vector `self`.
    /// Aborts if `i` or `j` is out of bounds.
    native public fun swap<Element>(self: &mut vector<Element>, i: u64, j: u64);
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L296-303)
```rust
    VEC_PACK                    = 0x40,
    VEC_LEN                     = 0x41,
    VEC_IMM_BORROW              = 0x42,
    VEC_MUT_BORROW              = 0x43,
    VEC_PUSH_BACK               = 0x44,
    VEC_POP_BACK                = 0x45,
    VEC_UNPACK                  = 0x46,
    VEC_SWAP                    = 0x47,
```

**File:** third_party/move/move-model/src/well_known.rs (L41-50)
```rust
pub const VECTOR_FUNCS_WITH_BYTECODE_INSTRS: &[&str] = &[
    "empty",
    "length",
    "borrow",
    "borrow_mut",
    "push_back",
    "pop_back",
    "destroy_empty",
    "swap",
];
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L1546-1573)
```rust
        if !well_known::VECTOR_FUNCS_WITH_BYTECODE_INSTRS.contains(&function_name.as_str()) {
            // early return if vector function does not have a bytecode instruction
            return None;
        }

        if let Some(inst) = inst_sign {
            match function_name.as_str() {
                // note: the following matched strings should all be present in `well_known::VECTOR_FUNCS_WITH_BYTECODE_INSTRS`
                "empty" => Some(FF::Bytecode::VecPack(inst, 0)),
                "length" => Some(FF::Bytecode::VecLen(inst)),
                "borrow" => Some(FF::Bytecode::VecImmBorrow(inst)),
                "borrow_mut" => Some(FF::Bytecode::VecMutBorrow(inst)),
                "push_back" => Some(FF::Bytecode::VecPushBack(inst)),
                "pop_back" => Some(FF::Bytecode::VecPopBack(inst)),
                "destroy_empty" => Some(FF::Bytecode::VecUnpack(inst, 0)),
                "swap" => Some(FF::Bytecode::VecSwap(inst)),
                _ => {
                    self.internal_error(
                        loc,
                        format!("unexpected vector function `{}`", function_name),
                    );
                    None
                },
            }
        } else {
            self.internal_error(loc, "expected type instantiation for vector operation");
            None
        }
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L647-656)
```rust
        let (native, is_native) = if def.is_native() {
            let native = natives.resolve(
                module_id.address(),
                module_id.name().as_str(),
                name.as_str(),
            );
            (native, true)
        } else {
            (None, false)
        };
```

**File:** aptos-move/framework/move-stdlib/src/natives/vector.rs (L101-107)
```rust
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [("move_range", native_move_range as RawSafeNative)];

    builder.make_named_natives(natives)
}
```

**File:** third_party/move/move-bytecode-verifier/src/instruction_consistency.rs (L137-142)
```rust
                VecPack(_, num) | VecUnpack(_, num) => {
                    if *num > u16::MAX as u64 {
                        return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                            .at_code_offset(self.current_function(), offset as CodeOffset)
                            .with_message("VecPack/VecUnpack argument out of range".to_string()));
                    }
```
