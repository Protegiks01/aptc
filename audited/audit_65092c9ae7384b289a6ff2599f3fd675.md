# Audit Report

## Title
State Consistency Violation via Request Queue Clearing Without Version Rollback

## Summary
The `clear_sent_data_requests_queue()` function clears pending data requests and aborts in-flight tasks without rolling back the stream engine's request version tracking. This causes transaction versions covered by aborted requests to be permanently skipped during stream reinitialization, leading to gaps in the node's transaction history and state inconsistency.

## Finding Description

The vulnerability occurs in the state synchronization data streaming service. When a continuous transaction stream encounters certain error conditions (e.g., subscription stream lag beyond recovery), the system calls `clear_sent_data_requests_queue()` to reset the request queue. [1](#0-0) 

However, this function only clears the queue and aborts tasks—it does **not** roll back the stream engine's internal version tracking state. The critical state variables `next_request_version_and_epoch` and `next_stream_version_and_epoch` in the `ContinuousTransactionStreamEngine` remain pointing to positions **after** the aborted requests. [2](#0-1) 

When batch requests are created, the stream engine updates `next_request_version_and_epoch` to point after the last request in the batch: [3](#0-2) 

This update happens via `update_request_tracking()` immediately after request creation: [4](#0-3) 

When the stream is cleared due to an error, the notification path is: [5](#0-4) 

The stream engine resets subscription state but does NOT roll back version tracking: [6](#0-5) 

Upon reinitialization, when a new subscription stream is started, it uses the current (non-rolled-back) version tracking: [7](#0-6) [8](#0-7) 

The new subscription requests then use this `known_version`, which excludes the aborted request ranges: [9](#0-8) [10](#0-9) 

**Attack Scenario:**
1. Node syncing at version 1000, creates batch requests: [1000-1099], [1100-1199], [1200-1299]
2. `next_request_version_and_epoch` updated to (1300, epoch_n)
3. Subscription stream lags beyond recovery threshold
4. `notify_new_data_request_error()` → `clear_sent_data_requests_queue()` → all pending requests cleared
5. `active_subscription_stream` reset to None, but `next_request_version_and_epoch` remains at (1300, epoch_n)
6. Stream reinitialized with `known_version = 1299` (from `next_request_version - 1`)
7. New requests ask for transactions AFTER version 1299
8. **Versions 1000-1299 permanently skipped—300 transactions missing from node's state**

This violates **State Consistency Invariant #4**: the node now has incomplete transaction history and cannot properly verify state transitions via Merkle proofs for the missing range.

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

This vulnerability directly causes:
- **Incomplete transaction history**: The node permanently loses transaction data for the skipped version range
- **State root verification failures**: Cannot construct valid Merkle proofs for missing transaction ranges
- **Potential consensus divergence**: Different nodes may skip different version ranges depending on when their streams fail, leading to different state views
- **Manual intervention required**: The node must be manually resynced from genesis or a snapshot to recover the missing data

Per the Aptos bug bounty criteria, this qualifies as Medium severity: "State inconsistencies requiring intervention."

While this doesn't immediately cause consensus failure or fund loss, it undermines the fundamental state consistency guarantee that all nodes maintain identical, complete transaction histories. In production, this could lead to validator nodes having different state roots for the same committed versions.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can trigger in two scenarios:

1. **Natural occurrence (High probability)**:
   - Subscription streams frequently lag during network congestion or high transaction throughput
   - The lag detection mechanism explicitly checks for streams "beyond recovery" [11](#0-10) 
   - When lag exceeds configured thresholds, the queue is automatically cleared

2. **Induced by network conditions (Medium probability)**:
   - An attacker could delay responses to specific nodes to trigger subscription lag
   - Multiple pending requests increase the version gap that gets skipped

The vulnerability is **deterministic**—once triggered, the version skip is guaranteed. Every time a stream clears its queue during active syncing with pending requests, transaction versions are lost.

## Recommendation

The stream engine must roll back `next_request_version_and_epoch` to match `next_stream_version_and_epoch` when clearing the request queue. This ensures that only successfully processed data advances the request pointer.

**Recommended fix for `clear_sent_data_requests_queue()`:**

Add a callback to the stream engine to reset request tracking:

```rust
/// Clears the sent data requests queue and drops all tasks
pub fn clear_sent_data_requests_queue(&mut self) {
    // Clear all pending data requests
    if let Some(sent_data_requests) = self.sent_data_requests.as_mut() {
        sent_data_requests.clear();
    }

    // Abort all spawned tasks
    self.abort_spawned_tasks();
    
    // Reset the stream engine's request tracking to match sent data
    self.stream_engine.reset_request_tracking_to_stream_position();
}
```

**Add to `ContinuousTransactionStreamEngine`:**

```rust
/// Resets next_request_version_and_epoch to match next_stream_version_and_epoch.
/// This should be called when clearing the request queue to prevent version skips.
pub fn reset_request_tracking_to_stream_position(&mut self) {
    self.next_request_version_and_epoch = self.next_stream_version_and_epoch;
}
```

This ensures that when the stream is reinitialized, it requests data starting from the last successfully sent version, not from the speculatively updated request version.

## Proof of Concept

```rust
#[tokio::test]
async fn test_version_skip_on_queue_clear() {
    use aptos_config::config::DataStreamingServiceConfig;
    use aptos_data_client::GlobalDataSummary;
    use aptos_time_service::MockTimeService;
    
    // Setup: Create a continuous transaction stream
    let config = DataStreamingServiceConfig::default();
    let mock_client = MockAptosDataClient::new();
    let (mut stream, _listener) = DataStream::new(
        config,
        1, // stream_id
        &StreamRequest::ContinuouslyStreamTransactions(...),
        // ... other params
    ).unwrap();
    
    // Initialize stream at version 1000
    stream.initialize_data_requests(GlobalDataSummary::default()).unwrap();
    
    // Verify initial state
    assert_eq!(stream.stream_engine.next_request_version_and_epoch.0, 1000);
    
    // Send batch of requests: [1000-1099], [1100-1199], [1200-1299]
    // This updates next_request_version to 1300
    stream.create_and_send_client_requests(&global_summary).unwrap();
    assert_eq!(stream.stream_engine.next_request_version_and_epoch.0, 1300);
    
    // Simulate subscription lag error triggering queue clear
    stream.notify_new_data_request_error(
        &client_request,
        aptos_data_client::error::Error::SubscriptionStreamIsLagging(...)
    ).unwrap();
    
    // BUG: next_request_version still at 1300, not rolled back to 1000
    assert_eq!(stream.stream_engine.next_request_version_and_epoch.0, 1300);
    assert_eq!(stream.stream_engine.next_stream_version_and_epoch.0, 1000);
    
    // Reinitialize stream
    stream.initialize_data_requests(GlobalDataSummary::default()).unwrap();
    
    // New requests start from version 1300, SKIPPING versions 1000-1299
    let new_requests = stream.stream_engine.create_data_client_requests(...).unwrap();
    match &new_requests[0] {
        DataClientRequest::SubscribeTransactionsWithProof(req) => {
            // known_version is 1299 (next_request_version - 1)
            // Subscription asks for transactions AFTER 1299
            assert_eq!(req.known_version, 1299);
            // VULNERABILITY: Versions 1000-1299 are permanently lost
        },
        _ => panic!("Wrong request type"),
    }
}
```

## Notes

This vulnerability affects all continuous streaming modes (transactions, transaction outputs, and transactions-or-outputs) when using either subscription-based or target-based streaming. The root cause is architectural: request tracking is updated optimistically before responses are confirmed, but there's no rollback mechanism when the request queue is cleared.

The issue is particularly severe because:
1. It can occur during normal operation without any malicious activity
2. The data loss is **permanent**—the node will never re-request the skipped versions
3. Different nodes may skip different ranges, leading to state divergence across the network
4. Detection requires comparing transaction histories between nodes, which may not happen until much later

### Citations

**File:** state-sync/data-streaming-service/src/data_stream.rs (L176-184)
```rust
    pub fn clear_sent_data_requests_queue(&mut self) {
        // Clear all pending data requests
        if let Some(sent_data_requests) = self.sent_data_requests.as_mut() {
            sent_data_requests.clear();
        }

        // Abort all spawned tasks
        self.abort_spawned_tasks();
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L605-619)
```rust
        // Check if the stream is beyond recovery (i.e., has failed).
        let current_stream_lag =
            highest_advertised_version.saturating_sub(highest_response_version);
        if let Some(mut subscription_stream_lag) = self.subscription_stream_lag.take() {
            // Check if the stream lag is beyond recovery
            if subscription_stream_lag
                .is_beyond_recovery(self.streaming_service_config, current_stream_lag)
            {
                return Err(
                    aptos_data_client::error::Error::SubscriptionStreamIsLagging(format!(
                        "The subscription stream is beyond recovery! Current lag: {:?}, last lag: {:?},",
                        current_stream_lag, subscription_stream_lag.version_lag
                    )),
                );
            }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L634-644)
```rust
    fn notify_new_data_request_error(
        &mut self,
        client_request: &DataClientRequest,
        error: aptos_data_client::error::Error,
    ) -> Result<(), Error> {
        // Notify the stream engine and clear the requests queue
        self.stream_engine
            .notify_new_data_request_error(client_request, error)?;
        self.clear_sent_data_requests_queue();

        Ok(())
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L415-417)
```rust
    // The next version and epoch that we're waiting to request from
    // the network. All versions before this have been requested.
    pub next_request_version_and_epoch: (Version, Epoch),
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L734-736)
```rust
        // Get the highest known version and epoch at stream start
        let (known_version, known_epoch) =
            active_subscription_stream.get_known_version_and_epoch_at_stream_start();
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L776-782)
```rust
                    SubscribeTransactionsWithProof(SubscribeTransactionsWithProofRequest {
                        known_version,
                        known_epoch,
                        include_events: request.include_events,
                        subscription_stream_id,
                        subscription_stream_index,
                    })
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L861-867)
```rust
    fn get_known_version_and_epoch(&mut self) -> Result<(u64, Epoch), Error> {
        let (next_request_version, known_epoch) = self.next_request_version_and_epoch;
        let known_version = next_request_version
            .checked_sub(1)
            .ok_or_else(|| Error::IntegerOverflow("Last version has overflown!".into()))?;

        Ok((known_version, known_epoch))
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L951-953)
```rust
        // Reset the active subscription stream and update the metrics
        self.active_subscription_stream = None;
        update_terminated_subscription_metrics(request_error.get_label());
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1017-1027)
```rust
        // Get the highest known version and epoch
        let (known_version, known_epoch) = self.get_known_version_and_epoch()?;

        // Create and save a new subscription stream
        let subscription_stream = SubscriptionStream::new(
            self.data_streaming_config,
            unique_id_generator,
            known_version,
            known_epoch,
        );
        self.active_subscription_stream = Some(subscription_stream);
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1103-1106)
```rust
        let next_request_version = request_end_version
            .checked_add(1)
            .ok_or_else(|| Error::IntegerOverflow("Next request version has overflown!".into()))?;
        self.next_request_version_and_epoch = (next_request_version, next_request_epoch);
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1111-1125)
```rust
    fn update_request_tracking(
        &mut self,
        client_requests: &[DataClientRequest],
        target_ledger_info: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        match &self.request {
            StreamRequest::ContinuouslyStreamTransactions(_) => {
                for client_request in client_requests {
                    match client_request {
                        DataClientRequest::TransactionsWithProof(request) => {
                            self.update_request_version_and_epoch(
                                request.end_version,
                                target_ledger_info,
                            )?;
                        },
```
