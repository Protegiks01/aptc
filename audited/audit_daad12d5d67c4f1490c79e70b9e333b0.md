# Audit Report

## Title
Silent Network Address Decoding Failure Allows Validators with Invalid BCS Encoding to Become Unreachable

## Summary
The `validator_network_addresses()` function properly returns a `Result<Vec<NetworkAddress>, bcs::Error>` when BCS decoding fails, but the critical network discovery code path silently replaces decoding errors with empty addresses using `.unwrap_or_default()`, allowing validators with invalid BCS-encoded network addresses to remain in the active validator set while being unreachable for network connectivity.

## Finding Description

The vulnerability exists across three layers of the codebase:

**Layer 1: Move Smart Contract (No Validation)**

The `update_network_and_fullnode_addresses()` function in the stake module accepts arbitrary bytes without validating they represent valid BCS-encoded `Vec<NetworkAddress>`: [1](#0-0) 

At line 969, the function directly stores `new_network_addresses` without any BCS validation, allowing invalid bytes to be written to the on-chain `ValidatorConfig` resource.

**Layer 2: Rust Deserialization (Returns Error)**

The `validator_network_addresses()` function correctly attempts BCS deserialization and returns an error on failure: [2](#0-1) 

**Layer 3: Network Discovery (Silent Failure)**

The critical failure occurs in `extract_validator_set_updates()` where BCS decoding errors are silently replaced with empty addresses: [3](#0-2) 

When `validator_network_addresses()` returns a `bcs::Error`, the code logs a warning and increments a metric (lines 130-138), but then calls `.unwrap_or_default()` at line 140, replacing the error with an empty `Vec<NetworkAddress>`. The validator is then added to the `PeerSet` with no addresses (line 147).

**Layer 4: Validator Set Joining (No Validation)**

When validators join the active set, only the consensus public key is validated, not the network addresses: [4](#0-3) 

Line 1083 validates `consensus_pubkey` is non-empty, but there is no validation of `network_addresses` or `fullnode_addresses` BCS encoding.

**Attack Scenario:**

1. A validator operator calls `update_network_and_fullnode_addresses()` with invalid BCS bytes (either maliciously or due to a bug in tooling)
2. The Move contract stores these invalid bytes in the `ValidatorConfig` resource
3. During epoch changes or network discovery updates, other validators read the `ValidatorSet` on-chain config
4. The `extract_validator_set_updates()` function attempts to decode the network addresses
5. BCS decoding fails, but instead of rejecting the validator, it silently replaces with empty addresses
6. The validator remains in the active validator set but becomes unreachable for P2P networking
7. This validator cannot participate in consensus message exchange despite having valid voting power

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the bug bounty criteria.

While consensus safety is not directly broken (the `ValidatorVerifier` only uses public keys and voting power, not network addresses): [5](#0-4) 

The validator becomes unreachable for network connectivity, creating an inconsistency between the validator's on-chain state (active with voting power) and their network reachability (unreachable due to no valid addresses).

If multiple validators are affected (whether through malicious action, buggy tooling, or coordinated attack), this could impact network liveness. AptosBFT requires 2f+1 voting power to reach consensus - if validators representing >1/3 voting power become unreachable due to invalid addresses, the network loses liveness.

However, this does **not** qualify as Critical severity because:
- It requires validator operator privileges to exploit
- It's self-inflicted (the operator harms their own validator)
- It's recoverable (the operator can update addresses again)
- Consensus safety guarantees remain intact

## Likelihood Explanation

**Medium Likelihood** due to:

1. **Accidental Occurrence**: More likely to occur accidentally through:
   - Bugs in CLI tooling generating address updates
   - Incorrect manual BCS encoding by operators
   - Programming errors in validator management scripts

2. **Malicious Exploitation**: Less likely because:
   - Requires validator operator credentials (privileged access)
   - Self-destructive (makes own validator unreachable)
   - No direct financial gain for the attacker
   - Easily detectable through network metrics

3. **Systemic Risk**: Could affect multiple validators if:
   - Common tooling bug affects many operators
   - Coordinated attack by multiple compromised operators
   - Copy-paste errors during mass validator updates

## Recommendation

Implement BCS validation at multiple defensive layers:

**Fix 1: Move Contract Validation (Strongest Defense)**
Add BCS validation in `update_network_and_fullnode_addresses()`:

```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
) acquires StakePool, ValidatorConfig {
    // ... existing checks ...
    
    // Validate BCS encoding by attempting to deserialize
    assert!(
        aptos_std::from_bcs::deserializable<vector<vector<u8>>>(&new_network_addresses),
        error::invalid_argument(EINVALID_NETWORK_ADDRESSES)
    );
    assert!(
        aptos_std::from_bcs::deserializable<vector<vector<u8>>>(&new_fullnode_addresses),
        error::invalid_argument(EINVALID_NETWORK_ADDRESSES)
    );
    
    // ... rest of function ...
}
```

**Fix 2: Validator Set Join Validation**
Add validation in `join_validator_set_inner()`:

```move
pub(friend) fun join_validator_set_inner(
    pool_address: address,
    stake_pool: &mut StakePool,
) acquires ValidatorConfig, ValidatorSet {
    // ... existing checks ...
    let validator_config = borrow_global<ValidatorConfig>(pool_address);
    assert!(!vector::is_empty(&validator_config.consensus_pubkey), error::invalid_argument(EINVALID_PUBLIC_KEY));
    
    // Add network address validation
    assert!(
        aptos_std::from_bcs::deserializable<vector<vector<u8>>>(&validator_config.network_addresses),
        error::invalid_argument(EINVALID_NETWORK_ADDRESSES)
    );
    // ... rest of function ...
}
```

**Fix 3: Rust-Side Error Propagation (Defense in Depth)**
Change the network discovery to reject validators with invalid addresses instead of using empty addresses:

```rust
let addrs = if is_validator {
    config.validator_network_addresses()
} else {
    config.fullnode_network_addresses()
}
.map_err(|err| {
    inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);
    error!(
        NetworkSchema::new(&network_context),
        "OnChainDiscovery: Failed to parse network address, SKIPPING peer: {}, err: {}",
        peer_id, err
    );
    err
})?; // Propagate error instead of unwrap_or_default

(peer_id, Peer::from_addrs(peer_role, addrs))
```

Then filter out failed entries in the caller.

## Proof of Concept

```move
// Test module to demonstrate the vulnerability
#[test_only]
module aptos_framework::validator_config_bcs_test {
    use aptos_framework::stake;
    use std::vector;
    
    #[test(validator_operator = @0x123, aptos_framework = @aptos_framework)]
    #[expected_failure] // This should fail but currently doesn't
    fun test_invalid_bcs_network_addresses(
        validator_operator: &signer,
        aptos_framework: &signer
    ) {
        // Setup validator stake pool
        // ... initialization code ...
        
        // Create invalid BCS bytes (not a valid Vec<NetworkAddress>)
        let invalid_bcs = vector::empty<u8>();
        vector::push_back(&mut invalid_bcs, 0xFF); // Invalid BCS prefix
        vector::push_back(&mut invalid_bcs, 0xFF);
        vector::push_back(&mut invalid_bcs, 0xFF);
        
        // This should fail but currently succeeds
        stake::update_network_and_fullnode_addresses(
            validator_operator,
            @0x123,
            invalid_bcs,
            vector::empty() // valid empty addresses for fullnode
        );
        
        // Validator can now join with invalid addresses
        stake::join_validator_set(validator_operator, @0x123);
        
        // The validator is in the active set but unreachable
        // Network discovery will replace invalid BCS with empty addresses
    }
}
```

## Notes

This vulnerability represents an inadequate error handling pattern where BCS deserialization errors are silently masked rather than properly validated or rejected. While the immediate security impact is limited to network availability rather than consensus safety, it violates the principle of fail-fast validation and could lead to subtle operational issues where validators appear active on-chain but are unreachable for P2P communication.

The root cause is the lack of BCS validation at the Move contract level when addresses are updated, combined with overly permissive error handling in the Rust network discovery layer. Both layers should be hardened to prevent invalid data from entering the system and to reject validators with malformed configuration rather than silently degrading their connectivity.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1082-1090)
```text
        let validator_config = borrow_global<ValidatorConfig>(pool_address);
        assert!(!vector::is_empty(&validator_config.consensus_pubkey), error::invalid_argument(EINVALID_PUBLIC_KEY));

        // Validate the current validator set size has not exceeded the limit.
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        vector::push_back(
            &mut validator_set.pending_active,
            generate_validator_info(pool_address, stake_pool, *validator_config)
        );
```

**File:** types/src/validator_config.rs (L64-66)
```rust
    pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.validator_network_addresses)
    }
```

**File:** network/discovery/src/validator_set.rs (L121-140)
```rust
            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();
```

**File:** types/src/validator_verifier.rs (L563-586)
```rust
impl From<&ValidatorSet> for ValidatorVerifier {
    fn from(validator_set: &ValidatorSet) -> Self {
        let sorted_validator_infos: BTreeMap<u64, ValidatorConsensusInfo> = validator_set
            .payload()
            .map(|info| {
                (
                    info.config().validator_index,
                    ValidatorConsensusInfo::new(
                        info.account_address,
                        info.consensus_public_key().clone(),
                        info.consensus_voting_power(),
                    ),
                )
            })
            .collect();
        let validator_infos: Vec<_> = sorted_validator_infos.values().cloned().collect();
        for info in validator_set.payload() {
            assert_eq!(
                validator_infos[info.config().validator_index as usize].address,
                info.account_address
            );
        }
        ValidatorVerifier::new(validator_infos)
    }
```
