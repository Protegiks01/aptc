# Audit Report

## Title
V2 Event Identifier Collision in API Responses Breaks Client Event Parsing

## Summary
When a transaction emits multiple V2 events, the REST API returns all V2 events with identical `guid` (0x0) and `sequence_number` (0) values, making them indistinguishable. This violates the documented contract that `guid` is a "globally unique identifier" and breaks client applications that rely on event identification. [1](#0-0) 

## Finding Description

The vulnerability occurs in the API layer's event conversion logic. When transactions are retrieved via REST API endpoints, both V1 and V2 events are converted to the same `Event` struct format: [2](#0-1) 

The conversion logic assigns dummy values to all V2 events: [3](#0-2) 

When a transaction emits multiple V2 events, they all receive:
- `guid.creation_number = 0`
- `guid.account_address = 0x0`  
- `sequence_number = 0`

This occurs during API response generation: [4](#0-3) 

The `Event` struct provides no `version` field to distinguish V1 from V2 events, and the `guid`/`sequence_number` combination—documented as globally unique—is identical for all V2 events in the same transaction.

Storage layer correctly preserves event distinctions using BCS encoding: [5](#0-4) 

However, when events are retrieved and converted for API responses, this distinction is lost for clients.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria ("State inconsistencies requiring intervention").

**Concrete impacts:**

1. **Event indexers fail**: Applications maintaining event databases using `(guid, sequence_number)` as primary keys will encounter duplicate key violations or overwrite events
2. **DApp state corruption**: Smart contract interfaces tracking events cannot distinguish between multiple V2 events (e.g., multiple NFT transfers in one transaction)
3. **Wallet history errors**: Transaction history displays will show incomplete or incorrect event lists
4. **Cross-contract call failures**: Applications processing event chains across multiple contracts cannot maintain correct ordering

These state inconsistencies can lead to limited funds loss or manipulation when DApps make incorrect decisions based on malformed event data (e.g., processing the same deposit event multiple times or missing withdrawal events).

## Likelihood Explanation

**High likelihood** of occurrence:

1. **V2 events are increasingly common**: The Aptos framework migrates to V2 events via feature flags [6](#0-5) 

2. **Multiple V2 events per transaction are valid**: Move modules can legitimately emit multiple V2 events [7](#0-6) 

3. **No warnings in API documentation**: Clients are not informed that V2 events have non-unique identifiers

4. **Translation only occurs in simulation context**, not regular queries: [8](#0-7) 

Regular transaction queries bypass translation, exposing the issue.

## Recommendation

**Solution 1: Add version discriminator to Event struct**

Add a `version` field to the `Event` struct:

```rust
pub struct Event {
    pub version: u8, // 1 for V1, 2 for V2
    pub guid: EventGuid,
    pub sequence_number: U64,
    pub typ: MoveType,
    pub data: serde_json::Value,
}
```

Update conversion to set version appropriately and use transaction-level index for V2 events instead of dummy values.

**Solution 2: Always translate V2 to V1 for API responses**

Apply the existing translation engine to all API queries (not just simulation): [9](#0-8) 

Extend translation coverage to handle all V2 event types or fail gracefully with clear error messages.

**Solution 3: Return separate V1/V2 event arrays**

Modify the transaction response to separate events by version, providing clarity to clients about which events have unique identifiers.

## Proof of Concept

```move
// Move module emitting multiple V2 events
module 0x1::multi_event_test {
    use std::signer;
    use aptos_framework::event;

    #[event]
    struct TransferEvent has drop, store {
        from: address,
        to: address,
        amount: u64,
    }

    public entry fun emit_multiple_events(account: &signer) {
        // Emit 3 V2 events in one transaction
        event::emit(TransferEvent { 
            from: @0x1, 
            to: @0x2, 
            amount: 100 
        });
        event::emit(TransferEvent { 
            from: @0x2, 
            to: @0x3, 
            amount: 200 
        });
        event::emit(TransferEvent { 
            from: @0x3, 
            to: @0x1, 
            amount: 300 
        });
    }
}
```

**Reproduction steps:**

1. Enable `MODULE_EVENT` feature flag
2. Deploy the above module
3. Execute `emit_multiple_events` transaction
4. Query transaction via REST API: `GET /transactions/by_version/{version}`
5. Observe all 3 `TransferEvent` entries have identical:
   - `guid.creation_number = "0"`
   - `guid.account_address = "0x0"`
   - `sequence_number = "0"`
6. Demonstrate client parser cannot distinguish events by their documented unique identifier

**Expected behavior**: Each event should have a unique identifier combination.

**Actual behavior**: All V2 events share identical guid/sequence_number, violating API documentation and breaking client event tracking.

## Notes

The storage layer correctly preserves event type information via BCS encoding. The vulnerability is isolated to the API serialization layer where the documented "globally unique identifier" contract is violated for V2 events. This represents a state consistency issue requiring intervention to prevent client application failures.

### Citations

**File:** api/types/src/transaction.rs (L48-52)
```rust
static DUMMY_GUID: Lazy<EventGuid> = Lazy::new(|| EventGuid {
    creation_number: U64::from(0u64),
    account_address: Address::from(AccountAddress::ZERO),
});
static DUMMY_SEQUENCE_NUMBER: Lazy<U64> = Lazy::new(|| U64::from(0));
```

**File:** api/types/src/transaction.rs (L865-875)
```rust
pub struct Event {
    // The globally unique identifier of this event stream.
    pub guid: EventGuid,
    // The sequence number of the event
    pub sequence_number: U64,
    #[serde(rename = "type")]
    #[oai(rename = "type")]
    pub typ: MoveType,
    /// The JSON representation of the event
    pub data: serde_json::Value,
}
```

**File:** api/types/src/transaction.rs (L877-894)
```rust
impl From<(&ContractEvent, serde_json::Value)> for Event {
    fn from((event, data): (&ContractEvent, serde_json::Value)) -> Self {
        match event {
            ContractEvent::V1(v1) => Self {
                guid: (*v1.key()).into(),
                sequence_number: v1.sequence_number().into(),
                typ: v1.type_tag().into(),
                data,
            },
            ContractEvent::V2(v2) => Self {
                guid: *DUMMY_GUID,
                sequence_number: *DUMMY_SEQUENCE_NUMBER,
                typ: v2.type_tag().into(),
                data,
            },
        }
    }
}
```

**File:** api/types/src/convert.rs (L601-610)
```rust
    pub fn try_into_events(&self, events: &[ContractEvent]) -> Result<Vec<Event>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.type_tag(), event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** storage/aptosdb/src/schema/event/mod.rs (L49-57)
```rust
impl ValueCodec<EventSchema> for ContractEvent {
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
}
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L242-256)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                CollectionUriMutate {
                    creator_addr: signer::address_of(creator),
                    collection_name: collection,
                    old_uri,
                    new_uri,
                }
            );
        } else {
            event::emit_event<CollectionUriMutateEvent>(
                &mut token_event_store.collection_uri_mutate_events,
                event,
            );
        };
```

**File:** aptos-move/move-examples/event/sources/event.move (L27-27)
```text
            event::emit(event);
```

**File:** api/src/transactions.rs (L1719-1722)
```rust
        let mut events = output.events().to_vec();
        let _ = self
            .context
            .translate_v2_to_v1_events_for_simulation(&mut events);
```

**File:** api/src/context.rs (L1038-1064)
```rust
    pub fn translate_v2_to_v1_events_for_simulation(
        &self,
        events: &mut [ContractEvent],
    ) -> Result<()> {
        let mut count_map: HashMap<EventKey, u64> = HashMap::new();
        for event in events.iter_mut() {
            if let ContractEvent::V2(v2) = event {
                let translated_event = self
                    .indexer_reader
                    .as_ref()
                    .ok_or(anyhow!("Internal indexer reader doesn't exist"))?
                    .translate_event_v2_to_v1(v2)?;
                if let Some(v1) = translated_event {
                    let count = count_map.get(v1.key()).unwrap_or(&0);
                    let v1_adjusted = ContractEventV1::new(
                        *v1.key(),
                        v1.sequence_number() + count,
                        v1.type_tag().clone(),
                        v1.event_data().to_vec(),
                    )?;
                    *event = ContractEvent::V1(v1_adjusted);
                    count_map.insert(*v1.key(), count + 1);
                }
            }
        }
        Ok(())
    }
```
