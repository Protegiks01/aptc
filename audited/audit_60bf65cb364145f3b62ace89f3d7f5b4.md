# Audit Report

## Title
Transaction Filter Bypass via Proof-With-Data Payload in QuorumStore

## Summary
The `check_denied_inline_transactions()` method in `QuorumStorePayloadManager` only validates transactions in the `inline_batches` field of hybrid payloads, allowing a malicious block proposer to bypass transaction filtering by placing denied transactions in the `proof_with_data` field instead.

## Finding Description

The Aptos consensus layer implements transaction filtering through `BlockTransactionFilterConfig` to deny specific transactions from being included in blocks. When validators receive a block proposal, they validate it using `check_denied_inline_transactions()` before voting. [1](#0-0) 

However, the implementation in `QuorumStorePayloadManager` has a critical flaw: [2](#0-1) 

The check calls `get_inline_transactions()` which ONLY extracts transactions from the `inline_batches` field: [3](#0-2) 

For `QuorumStoreInlineHybrid` and `QuorumStoreInlineHybridV2` payloads, this function returns transactions only from the first field, completely ignoring the `proof_with_data` field.

However, when transactions are actually retrieved for execution, BOTH sources are processed: [4](#0-3) 

The `QuorumStoreInlineHybrid` payload structure contains two transaction sources: [5](#0-4) 

**Attack Path:**
1. Malicious proposer creates a block with `QuorumStoreInlineHybrid` payload
2. Places allowed transactions in `inline_batches` field
3. Places denied transactions (e.g., from sanctioned addresses) in `proof_with_data` field
4. Validators run `check_denied_inline_transactions()` - check passes (only inline_batches validated)
5. Validators vote for the block
6. Block gets committed to consensus
7. During execution, denied transactions are filtered by `filter_block_transactions()`, but validators have already voted for a policy-violating block [6](#0-5) 

## Impact Explanation

This vulnerability breaks the **Transaction Validation** invariant and enables **Significant Protocol Violations** (High Severity per bug bounty criteria):

1. **Security Policy Bypass**: The transaction filter check is designed to prevent validators from voting on blocks containing denied transactions. This bypass allows malicious proposers to force validators to vote for policy-violating blocks.

2. **Resource Exhaustion**: Malicious proposers can include large numbers of denied transactions in `proof_with_data`, wasting validator CPU/network resources during transaction retrieval and filtering.

3. **Consensus Manipulation**: If validators have different filter configurations (possible in misconfigured networks), this could cause state divergence where different validators execute different transaction sets, breaking the **Deterministic Execution** invariant.

4. **Validator Reputation Damage**: Validators unknowingly vote for blocks containing transactions that violate network policies (e.g., sanctions compliance).

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly exploitable because:
- Requires only being selected as a block proposer (normal validator operation)
- No special cryptographic attacks needed
- Simple payload construction
- The code path is exercised in every block proposal with QuorumStore enabled
- Existing tests confirm the vulnerability is not detected [7](#0-6) 

The test creates payloads with `ProofWithData::empty()`, proving the non-inline transaction filtering path is not tested.

## Recommendation

Modify `check_denied_inline_transactions()` to validate ALL transactions in the payload, not just inline transactions:

```rust
fn check_denied_inline_transactions(
    &self,
    block: &Block,
    block_txn_filter_config: &BlockTransactionFilterConfig,
) -> anyhow::Result<()> {
    // If the filter is disabled, return early
    if !block_txn_filter_config.is_enabled() {
        return Ok(());
    }

    // Get ALL transactions from the payload, including both inline and proof-with-data
    let all_transactions = get_all_transactions(block);
    if all_transactions.is_empty() {
        return Ok(());
    }

    // Fetch the block metadata
    let block_id = block.id();
    let block_author = block.author();
    let block_epoch = block.epoch();
    let block_timestamp = block.timestamp_usecs();

    // Identify any denied transactions
    let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
    let denied_transactions = block_transaction_filter.get_denied_block_transactions(
        block_id,
        block_author,
        block_epoch,
        block_timestamp,
        all_transactions,
    );
    if !denied_transactions.is_empty() {
        return Err(anyhow::anyhow!(
            "Payload contains denied transactions: {:?}",
            denied_transactions
        ));
    }

    Ok(())
}
```

Add a helper function to extract all transactions from all payload sources synchronously (for validation without requiring async batch retrieval).

## Proof of Concept

Create a test in `consensus/src/round_manager_tests/txn_filter_proposal_test.rs`:

```rust
#[test]
fn test_no_vote_on_denied_proof_with_data_transactions() {
    // Create test transactions
    let denied_txn = create_test_transactions()[0].clone();
    let allowed_txns = create_test_transactions()[1..].to_vec();
    
    // Create filter denying the first transaction
    let block_txn_filter = BlockTransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![BlockTransactionMatcher::Transaction(
            TransactionMatcher::Sender(denied_txn.sender()),
        )])
        .add_all_filter(true);
    let block_txn_filter_config = BlockTransactionFilterConfig::new(true, block_txn_filter);
    
    let runtime = consensus_runtime();
    let mut playground = NetworkPlayground::new(runtime.handle().clone());
    let mut nodes = NodeSetup::create_nodes(
        &mut playground,
        runtime.handle().clone(),
        1,
        None,
        None,
        Some(block_txn_filter_config),
        None,
        None,
        None,
        true,
    );
    let node = &mut nodes[0];
    
    // Create malicious payload: allowed txns in inline_batches, denied txn in proof_with_data
    let inline_batch = (create_batch_info(allowed_txns.len()), allowed_txns);
    let proof_batch_info = create_batch_info(1);
    let proof_with_data = ProofWithData::new(vec![
        ProofOfStore::new(proof_batch_info, AggregateSignature::empty())
    ]);
    
    let malicious_payload = Payload::QuorumStoreInlineHybrid(
        vec![inline_batch], 
        proof_with_data, 
        None
    );
    
    let malicious_block = Block::new_proposal(
        malicious_payload,
        1,
        1,
        certificate_for_genesis(),
        &node.signer,
        Vec::new(),
    ).unwrap();
    
    // BUG: This should fail but currently passes
    timed_block_on(&runtime, async {
        let result = node.round_manager.process_proposal(malicious_block).await;
        // Currently this passes, but it SHOULD fail
        assert!(result.is_err(), "Validator should reject block with denied transactions in proof_with_data");
    });
}
```

This PoC demonstrates that the current implementation accepts blocks with denied transactions in `proof_with_data`, violating the intended security policy.

### Citations

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L126-163)
```rust
    async fn get_transactions_quorum_store_inline_hybrid(
        &self,
        block: &Block,
        inline_batches: &[(BatchInfo, Vec<SignedTransaction>)],
        proof_with_data: &ProofWithData,
        max_txns_to_execute: &Option<u64>,
        block_gas_limit_override: &Option<u64>,
    ) -> ExecutorResult<BlockTransactionPayload> {
        let all_transactions = {
            let mut all_txns = process_qs_payload(
                proof_with_data,
                self.batch_reader.clone(),
                block,
                &self.ordered_authors,
            )
            .await?;
            all_txns.append(
                &mut inline_batches
                    .iter()
                    // TODO: Can clone be avoided here?
                    .flat_map(|(_batch_info, txns)| txns.clone())
                    .collect(),
            );
            all_txns
        };
        let inline_batches = inline_batches
            .iter()
            .map(|(batch_info, _)| batch_info.clone())
            .collect();
        Ok(BlockTransactionPayload::new_quorum_store_inline_hybrid(
            all_transactions,
            proof_with_data.proofs.clone(),
            *max_txns_to_execute,
            *block_gas_limit_override,
            inline_batches,
            self.enable_payload_v2,
        ))
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L567-599)
```rust
/// Extracts and returns all inline transactions from the payload in the given block
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** consensus/consensus-types/src/common.rs (L213-217)
```rust
    QuorumStoreInlineHybrid(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        Option<u64>,
    ),
```

**File:** consensus/src/block_preparer.rs (L122-146)
```rust
/// Filters transactions in a block based on the filter configuration
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```

**File:** consensus/src/round_manager_tests/txn_filter_proposal_test.rs (L234-244)
```rust
fn create_payload(
    transactions: Vec<SignedTransaction>,
    use_quorum_store_payloads: bool,
) -> Payload {
    if use_quorum_store_payloads {
        let inline_batch = (create_batch_info(transactions.len()), transactions);
        Payload::QuorumStoreInlineHybrid(vec![inline_batch], ProofWithData::empty(), None)
    } else {
        Payload::DirectMempool(transactions)
    }
}
```
