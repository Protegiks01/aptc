# Audit Report

## Title
Incomplete Path Validation in BaseConfig::sanitize() Allows Path Traversal in Node Configuration

## Summary
The `BaseConfig::sanitize()` function only validates the `waypoint` field while completely ignoring validation of `data_dir` and `working_dir` path fields. This creates an inconsistency with `StorageConfig::sanitize()` which explicitly validates database paths, and allows potentially malicious path traversal sequences to pass validation and be used in critical filesystem operations. [1](#0-0) 

## Finding Description

The `BaseConfig` struct contains three critical fields: `data_dir`, `working_dir`, and `waypoint`. However, the `sanitize()` implementation only validates that `waypoint` is not `None`, completely skipping validation of the path fields. [2](#0-1) 

This is inconsistent with `StorageConfig::sanitize()`, which explicitly validates that override paths are absolute and not relative, preventing path traversal attacks: [3](#0-2) 

The unvalidated paths from `BaseConfig` are propagated throughout the system:

1. **Direct filesystem operations** - `working_dir` is used to create RocksDB checkpoints with `fs::create_dir_all`: [4](#0-3) [5](#0-4) 

2. **Storage path resolution** - `data_dir` is propagated to `StorageConfig` and used to resolve relative paths: [6](#0-5) [7](#0-6) 

3. **Secure storage paths** - Used in `OnDiskStorageConfig` for key material storage: [8](#0-7) 

**Attack Scenario:**
An attacker who can influence node configuration (through supply chain attacks on config templates, social engineering, or compromised deployment automation) could provide a malicious config:

```yaml
base:
  data_dir: "../../../../tmp/malicious"
  working_dir: "/etc/aptos-malicious"
  waypoint:
    from_config: "0:0000000000000000000000000000000000000000000000000000000000000000"
```

This config would pass `BaseConfig::sanitize()` validation because only the waypoint is checked, then trigger filesystem operations at the attacker-controlled paths.

## Impact Explanation

This vulnerability can cause **High Severity** impacts per Aptos bug bounty criteria:

1. **Validator Node Failures** (High): If paths point to invalid or protected locations, the node will fail to start or crash during checkpoint operations, causing "Validator node slowdowns" or complete unavailability.

2. **State Inconsistencies** (Medium): If database checkpoints are written to incorrect locations due to path traversal, it creates "State inconsistencies requiring intervention" when the node attempts to recover from these checkpoints.

3. **Filesystem Manipulation**: If the node runs with elevated privileges, malicious paths could:
   - Overwrite critical system files
   - Write sensitive database contents to world-readable locations  
   - Exhaust disk space on system partitions

4. **Defense-in-Depth Failure**: The sanitizer's purpose is to catch misconfigurations even from trusted operators. This incomplete validation defeats that protection.

## Likelihood Explanation

**Likelihood: Medium**

While direct exploitation requires configuration control (typically restricted to node operators), several realistic scenarios exist:

1. **Supply Chain Attacks**: Automated deployment tools or config templates sourced from compromised repositories
2. **Social Engineering**: Attackers distributing "optimized" or "updated" configs to node operators
3. **Insider Mistakes**: Trusted operators making errors that should be caught by validation
4. **Configuration Management Bugs**: Vulnerabilities in config generation or distribution systems

The inconsistency between `StorageConfig` (which validates paths) and `BaseConfig` (which doesn't) strongly suggests this is an oversight rather than intentional design, making exploitation through operator error more likely.

## Recommendation

Add comprehensive path validation to `BaseConfig::sanitize()` consistent with `StorageConfig::sanitize()`:

```rust
impl ConfigSanitizer for BaseConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let base_config = &node_config.base;

        // Verify the waypoint is not None
        if let WaypointConfig::None = base_config.waypoint {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "The waypoint config must be set in the base config!".into(),
            ));
        }

        // Validate data_dir path
        if !base_config.data_dir.is_absolute() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                format!(
                    "data_dir path {:?} must be an absolute path to prevent path traversal",
                    base_config.data_dir
                ),
            ));
        }

        // Validate working_dir path if set
        if let Some(working_dir) = &base_config.working_dir {
            if !working_dir.is_absolute() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!(
                        "working_dir path {:?} must be an absolute path to prevent path traversal",
                        working_dir
                    ),
                ));
            }
        }

        Ok(())
    }
}
```

Additionally, validate that paths don't contain suspicious sequences like `..` even if absolute, and ensure they're canonicalized.

## Proof of Concept

Create a malicious config file `malicious_config.yaml`:

```yaml
base:
  data_dir: "../../../../tmp/malicious_aptos_data"
  working_dir: "../../../../tmp/malicious_checkpoint"
  role: validator
  waypoint:
    from_config: "0:47e676b5fe38866e42bd45df44edcc016877cf29c13a55fb697bc0c2c3333e07"

execution:
  genesis_file_location: "./genesis.blob"

storage:
  dir: "db"
  
# ... other required config fields
```

Rust test demonstrating the vulnerability:

```rust
#[test]
fn test_path_traversal_not_caught_by_sanitizer() {
    use crate::config::{BaseConfig, NodeConfig, RoleType, WaypointConfig};
    use crate::config::config_sanitizer::ConfigSanitizer;
    use aptos_types::waypoint::Waypoint;
    use std::path::PathBuf;

    // Create a malicious config with path traversal
    let mut node_config = NodeConfig::default();
    node_config.base = BaseConfig {
        data_dir: PathBuf::from("../../../../tmp/malicious"),
        working_dir: Some(PathBuf::from("../../../../etc/malicious")),
        role: RoleType::Validator,
        waypoint: WaypointConfig::FromConfig(Waypoint::default()),
    };

    // This SHOULD fail but currently PASSES
    let result = BaseConfig::sanitize(
        &node_config,
        crate::config::node_config_loader::NodeType::Validator,
        None
    );

    // BUG: Sanitizer accepts malicious path traversal
    assert!(result.is_ok(), "Sanitizer should reject path traversal but accepts it");
    
    // Demonstrate that these paths are used in filesystem operations
    node_config.set_data_dir(node_config.base.data_dir.clone());
    let storage_dir = node_config.storage.dir();
    println!("Storage will be created at: {:?}", storage_dir);
    // This would create directories at the malicious path
}
```

**Notes:**

The vulnerability requires configuration control, which typically requires operational access to validator nodes. However, the **defense-in-depth principle** mandates that sanitizers should catch ALL path-related security issues, regardless of who provides the config. The inconsistency between `StorageConfig` (validates paths) and `BaseConfig` (doesn't validate paths) indicates this is an unintentional security gap rather than an intentional design decision.

### Citations

**File:** config/src/config/base_config.rs (L15-22)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct BaseConfig {
    pub data_dir: PathBuf,
    pub working_dir: Option<PathBuf>,
    pub role: RoleType,
    pub waypoint: WaypointConfig,
}
```

**File:** config/src/config/base_config.rs (L35-54)
```rust
impl ConfigSanitizer for BaseConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let base_config = &node_config.base;

        // Verify the waypoint is not None
        if let WaypointConfig::None = base_config.waypoint {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The waypoint config must be set in the base config!".into(),
            ));
        }

        Ok(())
    }
}
```

**File:** config/src/config/storage_config.rs (L459-465)
```rust
    pub fn dir(&self) -> PathBuf {
        if self.dir.is_relative() {
            self.data_dir.join(&self.dir)
        } else {
            self.dir.clone()
        }
    }
```

**File:** config/src/config/storage_config.rs (L738-747)
```rust
            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
            }
```

**File:** aptos-node/src/storage.rs (L142-147)
```rust
    node_config.set_data_dir(working_dir.as_ref().to_path_buf());
    let checkpoint_dir = node_config.storage.dir();
    assert!(source_dir != checkpoint_dir);

    // Create rocksdb checkpoint directory
    fs::create_dir_all(&checkpoint_dir).unwrap();
```

**File:** aptos-node/src/storage.rs (L183-185)
```rust
    if let Some(working_dir) = node_config.base.working_dir.clone() {
        create_rocksdb_checkpoint_and_change_working_dir(node_config, working_dir);
    }
```

**File:** config/src/config/node_config.rs (L128-135)
```rust
    pub fn set_data_dir(&mut self, data_dir: PathBuf) {
        // Set the base directory
        self.base.data_dir.clone_from(&data_dir);

        // Set the data directory for each sub-module
        self.consensus.set_data_dir(data_dir.clone());
        self.storage.set_data_dir(data_dir);
    }
```

**File:** config/src/config/secure_backend_config.rs (L140-146)
```rust
    pub fn path(&self) -> PathBuf {
        if self.path.is_relative() {
            self.data_dir.join(&self.path)
        } else {
            self.path.clone()
        }
    }
```
