# Audit Report

## Title
Critical State Inconsistency Between Vesting and Staking Contract Modules Causing Permanent Fund Freezing

## Summary
The vesting module exposes a public function `get_vesting_account_signer` that allows admins to obtain direct control of the vesting contract account. This enables admins to bypass vesting module functions and call `staking_contract::switch_operator` directly, which creates a permanent state inconsistency between the cached operator address in `VestingContract` and the actual operator key in the staking contract's `Store`. This inconsistency causes all subsequent vesting operations to fail with `ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR`, permanently freezing all vested tokens and accumulated rewards.

## Finding Description

The vulnerability stems from a state synchronization issue between two interconnected modules: `vesting.move` and `staking_contract.move`.

**Root Cause:**

The `VestingContract` struct caches staking-related information in its `StakingInfo` field: [1](#0-0) 

When a vesting contract is created, it establishes an underlying staking contract: [2](#0-1) 

The vesting module provides an emergency function that allows admins to obtain the vesting account signer: [3](#0-2) 

**The Critical Flaw:**

With this signer, an admin can call `staking_contract::switch_operator` directly: [4](#0-3) 

This function internally moves the `StakingContract` from the old operator key to the new operator key in the `Store.staking_contracts` SimpleMap: [5](#0-4) 

**However**, this bypass does NOT update the cached `vesting_contract.staking.operator` field. Now the vesting contract's cached operator no longer matches the actual key used to store the staking contract.

**Exploitation Impact:**

All vesting operations that interact with the staking contract will fail because they query using the stale operator address:

1. `total_accumulated_rewards` uses the cached operator: [6](#0-5) 

2. `staking_contract_amounts` looks up by operator key: [7](#0-6) 

3. When the operator doesn't match, the assertion fails with `ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR`.

4. All dependent functions fail:
   - `unlock_rewards` → calls `total_accumulated_rewards`
   - `vest` → calls `unlock_rewards`
   - `distribute` → depends on unlocked funds
   - `terminate_vesting_contract` → calls distribute
   - Internal `unlock_stake` and `withdraw_stake` helpers

The proper update path through `vesting::update_operator` correctly synchronizes both states: [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL** (per Aptos Bug Bounty Program - "Permanent freezing of funds (requires hardfork)")

This vulnerability causes:

1. **Permanent Fund Freezing**: All vested tokens and accumulated staking rewards become permanently inaccessible to shareholders. The vesting contract enters an irrecoverable state where no standard operations can be executed.

2. **Complete Denial of Service**: All core vesting functions (`vest`, `unlock_rewards`, `distribute`, `terminate_vesting_contract`) fail immediately with assertion errors.

3. **No Recovery Mechanism**: There is no function in the protocol to manually correct the cached operator address in `VestingContract`. Even the admin cannot recover the funds through normal means. The only recovery would require a hard fork.

4. **State Consistency Violation**: Breaks the fundamental invariant that "State transitions must be atomic and verifiable" - the system maintains inconsistent state across module boundaries.

The impact affects potentially millions of dollars in vesting contracts used for employee compensation, investor vesting schedules, and validator rewards.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

1. **Admin Access Required**: The vulnerability requires admin privileges, but vesting contract admins are not necessarily core protocol developers - they could be any organization managing token vesting (startups, VCs, foundations).

2. **Legitimate Use Case Exists**: The `get_vesting_account_signer` function is explicitly documented as being "for emergency use." An admin might legitimately believe they need to call staking contract functions directly during an operational emergency, unaware of the catastrophic consequences.

3. **No Warning or Protection**: There are no guardrails, warnings in documentation, or runtime checks to prevent this dangerous operation. The comment claims "this doesn't give the admin total power" but this is misleading - it actually provides enough power to brick the contract.

4. **Accidental Triggering**: This could easily happen accidentally during legitimate emergency operations where an admin is trying to quickly resolve an issue and bypasses the proper vesting module functions.

5. **Attack Surface**: Any vesting contract admin who is malicious, compromised, or simply makes an operational error can trigger this vulnerability.

## Recommendation

**Immediate Fix:**

1. **Make `get_vesting_account_signer` private or remove it entirely**. Replace with specific, safe emergency functions that maintain state consistency.

2. **Add a synchronization check function** that validates the cached operator matches the actual staking contract operator:

```move
fun assert_operator_synchronized(contract_address: address) acquires VestingContract {
    let vesting_contract = borrow_global<VestingContract>(contract_address);
    let actual_operator = staking_contract::get_actual_operator(
        contract_address, 
        vesting_contract.staking.pool_address
    );
    assert!(
        vesting_contract.staking.operator == actual_operator,
        error::invalid_state(EOPERATOR_DESYNCHRONIZED)
    );
}
```

3. **Add a recovery function** that allows resynchronization if desynchronization is detected:

```move
public entry fun resync_operator(
    admin: &signer,
    contract_address: address,
) acquires VestingContract {
    verify_admin(admin, borrow_global<VestingContract>(contract_address));
    let vesting_contract = borrow_global_mut<VestingContract>(contract_address);
    
    // Find the actual operator by iterating staking_contracts
    let actual_operator = staking_contract::find_operator_for_pool(
        contract_address,
        vesting_contract.staking.pool_address
    );
    
    vesting_contract.staking.operator = actual_operator;
    // Also sync commission percentage
    vesting_contract.staking.commission_percentage = 
        staking_contract::commission_percentage(contract_address, actual_operator);
}
```

4. **Add pre-condition checks** to all vesting functions that interact with staking_contract to verify synchronization before proceeding.

## Proof of Concept

```move
#[test(framework = @0x1, admin = @0x100, shareholder = @0x200)]
fun test_operator_desynchronization_dos(
    framework: &signer,
    admin: &signer,
    shareholder: &signer,
) acquires AdminStore, VestingContract {
    // Setup
    setup(framework, &vector[@0x100, @0x200]);
    let admin_address = signer::address_of(admin);
    let shareholder_address = signer::address_of(shareholder);
    
    // Create vesting contract with operator_A
    let operator_A = @0x300;
    let operator_B = @0x400;
    
    let contract_address = setup_vesting_contract(
        admin,
        &vector[shareholder_address],
        &vector[GRANT_AMOUNT],
        admin_address,
        10, // 10% commission
    );
    
    // Verify initial state works
    timestamp::fast_forward_seconds(VESTING_SCHEDULE_CLIFF + VESTING_PERIOD);
    vest(contract_address); // Should work
    
    // ATTACK: Admin gets signer and calls staking_contract::switch_operator directly
    let vesting_signer = get_vesting_account_signer(admin, contract_address);
    staking_contract::switch_operator(
        &vesting_signer,
        operator_A,
        operator_B,
        15 // new commission
    );
    
    // Now VestingContract.staking.operator still = operator_A
    // But StakingContract is stored under key operator_B
    
    // RESULT: All vesting operations fail
    vest(contract_address); // FAILS with ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR
    unlock_rewards(contract_address); // FAILS
    distribute(contract_address); // FAILS
    
    // Funds are permanently frozen - shareholders cannot access vested tokens
}
```

**Expected Behavior**: The test should demonstrate that after bypassing the vesting module and calling `staking_contract::switch_operator` directly, all subsequent vesting operations abort with `ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR` error, proving the funds are permanently inaccessible.

## Notes

This vulnerability highlights a critical design flaw in module interaction patterns where one module (vesting) caches state from another module (staking_contract) but provides mechanisms that allow that state to be modified out-of-band. The exposure of `get_vesting_account_signer` as a public function creates a dangerous escape hatch that bypasses the carefully designed state synchronization logic in functions like `update_operator` and `update_commission_percentage`.

The issue is particularly insidious because:
1. The function is documented as being for "emergency use"
2. The comment claims it "doesn't give the admin total power"
3. There are no warnings about the catastrophic consequences of bypassing vesting module functions
4. The error only manifests after the damage is done, with no recovery path

This represents a textbook example of violating the State Consistency invariant where "State transitions must be atomic and verifiable" - the transition of operator state is split across modules with no transactional guarantees.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L126-135)
```text
    struct StakingInfo has store {
        // Where the vesting's stake pool is located at. Included for convenience.
        pool_address: address,
        // The currently assigned operator.
        operator: address,
        // The currently assigned voter.
        voter: address,
        // Commission paid to the operator of the stake pool.
        commission_percentage: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L459-465)
```text
    public fun total_accumulated_rewards(vesting_contract_address: address): u64 acquires VestingContract {
        assert_active_vesting_contract(vesting_contract_address);

        let vesting_contract = borrow_global<VestingContract>(vesting_contract_address);
        let (total_active_stake, _, commission_amount) =
            staking_contract::staking_contract_amounts(vesting_contract_address, vesting_contract.staking.operator);
        total_active_stake - vesting_contract.remaining_grant - commission_amount
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L600-601)
```text
        let pool_address = staking_contract::create_staking_contract_with_coins(
            &contract_signer, operator, voter, grant, commission_percentage, contract_creation_seed);
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L892-904)
```text
    public entry fun update_operator(
        admin: &signer,
        contract_address: address,
        new_operator: address,
        commission_percentage: u64,
    ) acquires VestingContract {
        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);
        verify_admin(admin, vesting_contract);
        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);
        let old_operator = vesting_contract.staking.operator;
        staking_contract::switch_operator(contract_signer, old_operator, new_operator, commission_percentage);
        vesting_contract.staking.operator = new_operator;
        vesting_contract.staking.commission_percentage = commission_percentage;
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L1137-1144)
```text
    /// For emergency use in case the admin needs emergency control of vesting contract account.
    /// This doesn't give the admin total power as the admin would still need to follow the rules set by
    /// staking_contract and stake modules.
    public fun get_vesting_account_signer(admin: &signer, contract_address: address): signer acquires VestingContract {
        let vesting_contract = borrow_global<VestingContract>(contract_address);
        verify_admin(admin, vesting_contract);
        get_vesting_account_signer_internal(vesting_contract)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L325-332)
```text
    public fun staking_contract_amounts(
        staker: address, operator: address
    ): (u64, u64, u64) acquires Store {
        assert_staking_contract_exists(staker, operator);
        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;
        let staking_contract = simple_map::borrow(staking_contracts, &operator);
        get_staking_contract_amounts_internal(staking_contract)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L825-831)
```text
    /// Allows staker to switch operator without going through the lenghthy process to unstake.
    public entry fun switch_operator(
        staker: &signer,
        old_operator: address,
        new_operator: address,
        new_commission_percentage: u64
    ) acquires Store, BeneficiaryForOperator {
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L847-870)
```text
        let (_, staking_contract) = simple_map::remove(staking_contracts, &old_operator);
        // Force distribution of any already inactive stake.
        distribute_internal(
            staker_address,
            old_operator,
            &mut staking_contract,
            &mut store.distribute_events
        );

        // For simplicity, we request commission to be paid out first. This avoids having to ensure to staker doesn't
        // withdraw into the commission portion.
        request_commission_internal(
            old_operator,
            &mut staking_contract,
            &mut store.add_distribution_events,
            &mut store.request_commission_events
        );

        // Update the staking contract's commission rate and stake pool's operator.
        stake::set_operator_with_cap(&staking_contract.owner_cap, new_operator);
        staking_contract.commission_percentage = new_commission_percentage;

        let pool_address = staking_contract.pool_address;
        simple_map::add(staking_contracts, new_operator, staking_contract);
```
