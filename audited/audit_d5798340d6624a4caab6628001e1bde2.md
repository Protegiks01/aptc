# Audit Report

## Title
Indexer gRPC Gateway Exposes Internal Reflection API via Unvalidated Catch-All Route

## Summary
The indexer-grpc-gateway uses a catch-all route `/*path` without path validation, allowing external users to access the gRPC reflection API and potentially other internal endpoints on the backend data service. This exposes internal API structure and service definitions that should be restricted to internal use.

## Finding Description

The gateway configures an Axum router with a permissive catch-all route that accepts any HTTP method on any path: [1](#0-0) 

This route accepts ALL paths and ALL HTTP methods (GET, POST, PUT, DELETE, etc.) via the `any()` handler, then forwards them to the backend data service without any path filtering or access control validation.

The backend data service explicitly enables gRPC reflection for debugging purposes: [2](#0-1) 

The reflection service is added to the server alongside the main API endpoints: [3](#0-2) 

The `override_uri_with_upstream_url` function only validates that path traversal doesn't change the origin, but does not filter which paths are allowed: [4](#0-3) 

### Attack Path
1. Attacker sends gRPC reflection request to gateway at `/grpc.reflection.v1alpha.ServerReflection/ServerReflectionInfo`
2. Gateway middleware calls GrpcManager to get data service URL
3. Gateway forwards request to data service without path validation
4. Data service processes reflection request and returns complete API schema
5. Attacker receives service definitions, method signatures, and proto schemas

The attacker can now:
- Enumerate all available services and methods
- Understand exact message formats for crafting attacks
- Discover undocumented or internal-only endpoints
- Map the internal API structure for further exploitation

## Impact Explanation

This vulnerability is classified as **Low Severity** under the Aptos bug bounty criteria as it constitutes a "Minor information leak."

While the catch-all route is a security misconfiguration, the actual impact is limited:
- The gRPC reflection API only exposes service schemas, not sensitive data or secrets
- No direct path to consensus violations, fund loss, or network availability issues
- The indexer-grpc services are auxiliary infrastructure, not core blockchain components
- The exposed information could aid reconnaissance but doesn't directly enable exploitation

This does NOT meet High Severity criteria because it does not cause:
- Validator node slowdowns
- API crashes  
- Significant protocol violations affecting consensus or blockchain operation

## Likelihood Explanation

**Likelihood: High** - This vulnerability is trivially exploitable by any external user with network access to the gateway. No authentication, special permissions, or complex attack chains are required.

Any user can query the reflection API using standard gRPC tools (e.g., `grpcurl -plaintext gateway.example.com:8080 list`).

## Recommendation

Implement a path whitelist in the gateway to only forward requests to intended public endpoints:

```rust
pub(crate) async fn start(&self) -> anyhow::Result<()> {
    let app = Router::new()
        // Only allow specific gRPC paths
        .route("/aptos.indexer.v1.RawData/GetTransactions", 
               post(proxy).with_state(self.config.clone()))
        .route("/aptos.indexer.v1.DataService/GetTransactions",
               post(proxy).with_state(self.config.clone()))
        .route("/aptos.indexer.v1.DataService/Ping",
               post(proxy).with_state(self.config.clone()))
        // Reject all other paths
        .fallback(|| async { 
            (StatusCode::NOT_FOUND, "Endpoint not found")
        })
        .layer(from_fn_with_state(
            self.config.clone(),
            get_data_service_url,
        ));
    // ... rest of the code
}
```

Additionally, disable gRPC reflection in production data service deployments by removing the reflection service registration.

## Proof of Concept

Using `grpcurl` to query the reflection API through the gateway:

```bash
# List all services
grpcurl -plaintext gateway.example.com:8080 list

# Expected output (should NOT be accessible):
# aptos.indexer.v1.DataService
# aptos.indexer.v1.RawData
# grpc.reflection.v1alpha.ServerReflection

# Describe a service to get its methods
grpcurl -plaintext gateway.example.com:8080 describe aptos.indexer.v1.RawData

# Expected output (should NOT be accessible):
# Service definition with all methods and message types
```

## Notes

While this finding represents a security misconfiguration that violates the principle of least privilege, it must be emphasized that:

1. **Scope Limitation**: The indexer-grpc-gateway is an auxiliary indexing service, not a core blockchain component
2. **No Direct Blockchain Impact**: This vulnerability does not affect consensus, validator operations, transaction execution, or on-chain state
3. **Information Disclosure Only**: The reflection API exposes service schemas but not secrets, private keys, or sensitive blockchain data
4. **Severity Assessment**: Under strict interpretation of the Aptos bug bounty criteria focusing on consensus/funds/availability, this is Low Severity

The catch-all route pattern should still be remediated as a security best practice to minimize attack surface and prevent potential future issues if additional endpoints are added to the data service.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L44-49)
```rust
        let app = Router::new()
            .route("/*path", any(proxy).with_state(self.config.clone()))
            .layer(from_fn_with_state(
                self.config.clone(),
                get_data_service_url,
            ));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L65-90)
```rust
fn override_uri_with_upstream_url(
    original_uri: &Uri,
    upstream_url: &Url,
) -> Result<Uri, (StatusCode, String)> {
    let requested_path_and_query = original_uri.path_and_query().unwrap().to_string();

    let new_url = upstream_url
        .join(requested_path_and_query.as_str())
        .map_err(|_| {
            (
                StatusCode::BAD_REQUEST,
                format!("Requested URL is not supported: {}", original_uri),
            )
        })?;

    if new_url.origin() != upstream_url.origin() {
        return Err((
            StatusCode::BAD_REQUEST,
            format!("Requested URL is not supported: {}", original_uri),
        ));
    }

    let uri = Uri::try_from(new_url.as_str()).unwrap();

    Ok(uri)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L211-224)
```rust
        let reflection_service = tonic_reflection::server::Builder::configure()
            // Note: It is critical that the file descriptor set is registered for every
            // file that the top level API proto depends on recursively. If you don't,
            // compilation will still succeed but reflection will fail at runtime.
            //
            // TODO: Add a test for this / something in build.rs, this is a big footgun.
            .register_encoded_file_descriptor_set(INDEXER_V1_FILE_DESCRIPTOR_SET)
            .register_encoded_file_descriptor_set(TRANSACTION_V1_TESTING_FILE_DESCRIPTOR_SET)
            .register_encoded_file_descriptor_set(UTIL_TIMESTAMP_FILE_DESCRIPTOR_SET)
            .build_v1alpha()
            .map_err(|e| anyhow::anyhow!("Failed to build reflection service: {}", e))?
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Gzip);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L271-276)
```rust
        tasks.push(tokio::spawn(async move {
            server_builder
                .add_service(wrapper_service)
                .add_service(wrapper_service_raw)
                .add_service(reflection_service)
                .serve(listen_address)
```
