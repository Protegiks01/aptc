# Audit Report

## Title
Indexer Records Non-Token Object Transfers as NFT Activities Due to Missing Token Resource Validation

## Summary
The `TokenActivityV2::get_nft_v2_from_parsed_event()` function processes `0x1::object::TransferEvent` events for ANY object transfer without validating whether the object is actually an NFT token. This allows attackers to fabricate NFT transfer records in the indexer by creating and transferring regular (non-token) objects, corrupting the token activities database and misleading applications that rely on indexer data.

## Finding Description
The vulnerability exists in the NFT V2 event parsing logic. The indexer processes `0x1::object::TransferEvent` events, which are generic object transfer events emitted for ANY object transfer in the Aptos framework, not just tokens. [1](#0-0) 

When processing transactions, the indexer:

1. **Builds metadata map from WriteSetChanges** - Adds ALL objects with `ObjectCore` resource to `token_v2_metadata`, regardless of whether they have a `Token` resource: [2](#0-1) 

2. **Parses TransferEvent for all objects** - The event parsing treats `0x1::object::TransferEvent` as a valid V2 token event: [3](#0-2) 

3. **Records activity without token validation** - The critical flaw occurs here where metadata lookup succeeds for any object (not just tokens), and no validation checks if `metadata.token` exists: [4](#0-3) 

**Attack Flow:**
1. Attacker calls `object::create_object()` or `object::create_named_object()` to create a regular object without adding a `Token` resource
2. Attacker transfers the object using `object::transfer()`, which emits `0x1::object::TransferEvent`
3. Indexer processes the event in `get_nft_v2_from_parsed_event()`
4. Metadata lookup succeeds (object has `ObjectCore`)
5. Function creates `TokenActivityV2` record without checking if `metadata.token.is_some()`
6. Fake NFT transfer is recorded in `token_activities_v2` table

This breaks the **Data Integrity Invariant**: The indexer should accurately represent on-chain token activity, but instead records non-token object transfers as NFT activities.

## Impact Explanation
**Severity: Medium** - This qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty program.

**Direct Impact:**
- Corrupts the `token_activities_v2` indexer table with fake NFT transfer records
- Creates fabricated NFT trading history for non-existent tokens
- Misleads applications (marketplaces, explorers, analytics) that query the indexer API

**Potential Exploitation Scenarios:**
1. **Wash Trading Evasion**: Attacker creates fake transfer volume to evade wash trading detection
2. **Marketplace Manipulation**: Fake activity history could influence price discovery or rarity metrics
3. **Analytics Corruption**: NFT analytics platforms would report incorrect trading volumes and activity
4. **User Confusion**: Block explorers would show transfers for "tokens" that don't actually exist

**Mitigation Note:** While on-chain state remains correct and smart contracts are unaffected, many production applications rely heavily on indexer data for their UIs and business logic. Database cleanup and validation logic addition would be required to remediate.

## Likelihood Explanation
**Likelihood: High** - This vulnerability is trivially exploitable by any user:

- **Attacker Requirements**: None - any account can create and transfer objects
- **Complexity**: Low - requires only 2 transactions (create object, transfer object)
- **Detection**: Difficult - fake activities blend with legitimate token transfers in the database
- **Cost**: Minimal - only standard transaction fees

The vulnerability occurs deterministically whenever a non-token object is transferred, making exploitation straightforward and reliable.

## Recommendation
Add explicit validation to check if the object has a `Token` resource before recording it as an NFT activity:

```rust
pub fn get_nft_v2_from_parsed_event(
    event: &APIEvent,
    txn_version: i64,
    txn_timestamp: chrono::NaiveDateTime,
    event_index: i64,
    entry_function_id_str: &Option<String>,
    token_v2_metadata: &TokenV2AggregatedDataMapping,
) -> anyhow::Result<Option<Self>> {
    let event_type = event.typ.to_string();
    if let Some(token_event) =
        &V2TokenEvent::from_event(event_type.as_str(), &event.data, txn_version)?
    {
        let event_account_address =
            standardize_address(&event.guid.account_address.to_string());
        let token_data_id = match token_event {
            V2TokenEvent::MintEvent(inner) => inner.get_token_address(),
            V2TokenEvent::BurnEvent(inner) => inner.get_token_address(),
            V2TokenEvent::TransferEvent(inner) => inner.get_object_address(),
            _ => event_account_address.clone(),
        };

        if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
            // ADD THIS VALIDATION: Only process TransferEvents if the object is actually a token
            if matches!(token_event, V2TokenEvent::TransferEvent(_)) && metadata.token.is_none() {
                return Ok(None);
            }
            
            let object_core = &metadata.object.object_core;
            // ... rest of the function
        }
    }
    Ok(None)
}
```

Additionally, consider adding a database migration to clean existing fake records by cross-referencing with the `current_token_datas_v2` table to identify and remove activities for non-existent tokens.

## Proof of Concept

```move
module attacker::fake_nft_transfer {
    use std::signer;
    use aptos_framework::object;

    /// Creates a regular object and transfers it to fabricate an NFT transfer record
    public entry fun exploit_indexer(attacker: &signer, recipient: address) {
        // Step 1: Create a regular object (NOT a token)
        let constructor_ref = object::create_object(signer::address_of(attacker));
        
        // Get the object address
        let obj = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);
        let obj_addr = object::object_address(&obj);
        
        // Step 2: Transfer the object
        // This emits 0x1::object::TransferEvent which the indexer processes
        object::transfer(attacker, obj, recipient);
        
        // Result: The indexer now has a fake NFT transfer record in token_activities_v2
        // for an object that is NOT a token, corrupting the NFT activity database
    }
}
```

**Expected Behavior After Exploit:**
- Query `token_activities_v2` table for the object address
- Observe a transfer activity record exists
- Query `current_token_datas_v2` table for the same address
- Observe NO corresponding token data (because it's not a token)
- Indexer shows transfer of a non-existent NFT

## Notes
This vulnerability is specific to the indexer component and does not affect on-chain consensus, state integrity, or Move VM execution. However, it represents a significant data integrity violation that could impact dependent applications and services relying on accurate NFT transfer history from the indexer API.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/object.move (L548-571)
```text
    inline fun transfer_raw_inner(object: address, to: address) {
        let object_core = borrow_global_mut<ObjectCore>(object);
        if (object_core.owner != to) {
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Transfer {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            } else {
                event::emit_event(
                    &mut object_core.transfer_events,
                    TransferEvent {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            };
            object_core.owner = to;
        };
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1093-1115)
```rust
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    if let Some(object) =
                        ObjectWithMetadata::from_write_resource(wr, txn_version).unwrap()
                    {
                        token_v2_metadata_helper.insert(
                            standardize_address(&wr.address.to_string()),
                            TokenV2AggregatedData {
                                aptos_collection: None,
                                fixed_supply: None,
                                object,
                                unlimited_supply: None,
                                property_map: None,
                                transfer_event: None,
                                token: None,
                                fungible_asset_metadata: None,
                                fungible_asset_supply: None,
                                fungible_asset_store: None,
                            },
                        );
                    }
                }
            }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L529-531)
```rust
            "0x1::object::TransferEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::TransferEvent(inner)))
            },
```

**File:** crates/indexer/src/models/token_models/v2_token_activities.rs (L162-210)
```rust
            if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
                let object_core = &metadata.object.object_core;
                let token_activity_helper = match token_event {
                    V2TokenEvent::MintEvent(_) => TokenActivityHelperV2 {
                        from_address: Some(object_core.get_owner_address()),
                        to_address: None,
                        token_amount: BigDecimal::one(),
                        before_value: None,
                        after_value: None,
                    },
                    V2TokenEvent::TokenMutationEvent(inner) => TokenActivityHelperV2 {
                        from_address: Some(object_core.get_owner_address()),
                        to_address: None,
                        token_amount: BigDecimal::zero(),
                        before_value: Some(inner.old_value.clone()),
                        after_value: Some(inner.new_value.clone()),
                    },
                    V2TokenEvent::BurnEvent(_) => TokenActivityHelperV2 {
                        from_address: Some(object_core.get_owner_address()),
                        to_address: None,
                        token_amount: BigDecimal::one(),
                        before_value: None,
                        after_value: None,
                    },
                    V2TokenEvent::TransferEvent(inner) => TokenActivityHelperV2 {
                        from_address: Some(inner.get_from_address()),
                        to_address: Some(inner.get_to_address()),
                        token_amount: BigDecimal::one(),
                        before_value: None,
                        after_value: None,
                    },
                };
                return Ok(Some(Self {
                    transaction_version: txn_version,
                    event_index,
                    event_account_address,
                    token_data_id,
                    property_version_v1: BigDecimal::zero(),
                    type_: event_type.to_string(),
                    from_address: token_activity_helper.from_address,
                    to_address: token_activity_helper.to_address,
                    token_amount: token_activity_helper.token_amount,
                    before_value: token_activity_helper.before_value,
                    after_value: token_activity_helper.after_value,
                    entry_function_id_str: entry_function_id_str.clone(),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: Some(false),
                    transaction_timestamp: txn_timestamp,
                }));
```
