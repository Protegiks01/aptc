# Audit Report

## Title
Event V2 Translation Uses Latest State Instead of Event Emission State, Causing Non-Deterministic Event Indexing and Data Loss

## Summary
The event V2 to V1 translation system queries the latest blockchain state instead of the state at the transaction version where the event was emitted. This causes translation to fail if required resources are deleted after event emission but before indexing, resulting in events being stored but not indexed. This violates deterministic execution guarantees and causes data availability loss for clients querying events through standard APIs.

## Finding Description

The `TokenMutationEvent` type implements `MoveEventV1Type`, while the newer system uses `TokenMutation` implementing `MoveEventV2Type`. [1](#0-0) [2](#0-1) 

When the `MODULE_EVENT_MIGRATION` feature flag is enabled (which is enabled by default on mainnet), the Move framework emits V2 events instead of V1 events. [3](#0-2) 

The critical vulnerability occurs in the event translation process. The `EventV2TranslationEngine` uses `latest_state_checkpoint_view()` to query state when translating V2 events to V1 format: [4](#0-3) 

This is problematic because event indexing happens **asynchronously** in a background thread, separate from transaction execution. [5](#0-4) 

**Attack Scenario:**
1. Attacker creates and mutates a token at version V1, emitting a `TokenMutation` V2 event
2. Attacker burns the token at version V2, which deletes the Token resource via `move_from<Token>(addr)` [6](#0-5) 
3. The asynchronous indexer processes events after V2
4. `TokenMutationTranslator` attempts to translate the V1 mutation event by querying for the Token resource [7](#0-6) 
5. Because it uses latest state (after burn), the resource lookup fails with "Token resource not found"
6. Translation returns `Ok(None)` with a warning logged [8](#0-7) 
7. The event is stored in `EventSchema` but **NOT** indexed in `EventByKeySchema` or `EventByVersionSchema` [9](#0-8) 
8. Clients querying events through the event handle API cannot find these events because the API relies on `EventByKeySchema` for lookups [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under Aptos bug bounty criteria for the following reasons:

**State Inconsistencies Requiring Intervention:**
- Events exist in `EventSchema` but are missing from `EventByKeySchema` and `EventByVersionSchema`, creating database inconsistency
- This breaks the expected invariant that all V1 events (including translated ones) should be queryable by event key

**Non-Deterministic Behavior (Consensus Invariant Violation):**
- Different validator nodes may have different indexed events depending on when they process the transaction batch
- If Node A indexes before the token burn and Node B indexes after, they will have different queryable event sets
- This violates **Critical Invariant #1: Deterministic Execution** - not all validators produce identical queryable state for identical blocks

**Data Availability Loss:**
- Clients relying on `/accounts/{address}/events/{event_handle}/{field_name}` API cannot retrieve affected events
- Applications expecting to query all mutation events by handle will experience data loss
- This breaks backward compatibility during the V1→V2 migration

The issue does not constitute Critical severity because:
- Raw event data remains in storage (not permanently lost)
- Does not affect consensus on transaction validity or state roots
- Limited to indexing/query layer, not core blockchain state

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is highly likely to occur in production for several reasons:

1. **Feature is Enabled by Default:** The `MODULE_EVENT_MIGRATION` feature flag is enabled by default on mainnet, meaning all token mutations emit V2 events [11](#0-10) 

2. **Common User Pattern:** Mutating then burning tokens is a legitimate use case (e.g., updating metadata before burning, batch operations)

3. **Asynchronous Processing Window:** The indexer runs in a background thread with measurable latency, creating a time window where resources can be deleted between event emission and indexing

4. **No Attacker Privileges Required:** Any user can trigger this by normal token operations—no special permissions needed

5. **Affects Multiple Event Types:** Beyond TokenMutation, this also affects CollectionMutation and potentially other V2 event types that require resource lookups

6. **Already Partially Acknowledged:** The code has special handling for MINT/BURN events with ConcurrentSupply, indicating the developers are aware of similar issues but haven't addressed it for mutation events [12](#0-11) 

## Recommendation

**Root Cause:** The translation engine queries latest state instead of state at event emission time.

**Fix:** Modify `EventV2TranslationEngine` to accept and use the transaction version when translating events. The engine should use `state_view_at_version(Some(event_version))` instead of `latest_state_checkpoint_view()`.

**Code Changes Required:**

1. **Pass version to translation methods:**
```rust
// In storage/indexer/src/event_v2_translator.rs
pub trait EventV2Translator: Send + Sync {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        version: Version,  // Add version parameter
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1>;
}
```

2. **Update state query methods:**
```rust
// In storage/indexer/src/event_v2_translator.rs
pub fn get_state_value_bytes_for_object_group_resource(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,  // Add version parameter
) -> Result<Option<Bytes>> {
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))  // Use version-specific view
        .expect("Failed to get state view");
    // ... rest of implementation
}
```

3. **Update caller in db_indexer.rs:**
```rust
// In storage/indexer/src/db_indexer.rs, line ~450
if let Some(translated_v1_event) =
    self.translate_event_v2_to_v1(v2, version).map_err(|e| {
        // Pass the version being indexed
        // ...
```

This ensures translation always queries the state as it existed when the event was emitted, eliminating timing-dependent behavior.

## Proof of Concept

**Move Test to Reproduce:**

```move
#[test_only]
module test_addr::event_translation_poc {
    use std::string;
    use aptos_token_objects::token;
    use aptos_token_objects::collection;
    
    #[test(creator = @0xcafe)]
    fun test_mutation_before_burn_loses_event(creator: &signer) {
        // 1. Create a token collection and token
        let collection_name = string::utf8(b"Test Collection");
        collection::create_unlimited_collection(
            creator,
            string::utf8(b"description"),
            collection_name,
            option::none(),
            string::utf8(b"uri"),
        );
        
        let token_name = string::utf8(b"Test Token");
        let constructor_ref = token::create(
            creator,
            collection_name,
            string::utf8(b"description"),
            token_name,
            option::none(),
            string::utf8(b"uri"),
        );
        
        let mutator_ref = token::generate_mutator_ref(&constructor_ref);
        let burn_ref = token::generate_burn_ref(&constructor_ref);
        
        // 2. Mutate the token (emits TokenMutation V2 event)
        token::set_description(
            &mutator_ref, 
            string::utf8(b"Updated description")
        );
        
        // 3. Burn the token (deletes Token resource)
        token::burn(burn_ref);
        
        // At this point, if the indexer processes asynchronously:
        // - The mutation event was emitted at version V1
        // - The token was burned at version V2  
        // - If indexing happens after V2, translation will fail
        // - Event will be in EventSchema but not in EventByKeySchema
    }
}
```

**Expected Behavior:** All mutation events should be indexed and queryable regardless of when the token is burned.

**Actual Behavior:** If indexing is delayed past the burn transaction, the mutation event is stored but not indexed, making it inaccessible through event handle queries.

**Verification:** Check indexer logs for warnings like "Failed to translate event: TokenMutation... Error: Token resource not found" and verify the event appears in transaction queries but not in event handle queries.

## Notes

This vulnerability demonstrates a critical design flaw in the event migration strategy where translation assumes resource availability at any point in time, rather than at the specific version when the event was emitted. The issue extends beyond TokenMutationEvent to any V2 event type requiring resource lookups during translation (CollectionMutation, and potentially future event types).

The special-case handling for MINT/BURN events with ConcurrentSupply shows the developers recognized similar issues but didn't apply a comprehensive fix. The proper solution requires architectural changes to make translation version-aware throughout the entire indexing pipeline.

### Citations

**File:** types/src/account_config/events/token_mutation_event.rs (L52-52)
```rust
impl MoveEventV1Type for TokenMutationEvent {}
```

**File:** types/src/account_config/events/token_mutation.rs (L64-64)
```rust
impl MoveEventV2Type for TokenMutation {}
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L751-758)
```text
        let Token {
            collection,
            index: deprecated_index,
            description: _,
            name: _,
            uri: _,
            mutation_events,
        } = move_from<Token>(addr);
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L777-793)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(Mutation {
                token_address: mutator_ref.self,
                mutated_field_name: string::utf8(b"description"),
                old_value: token.description,
                new_value: description
            })
        } else {
            event::emit_event(
                &mut token.mutation_events,
                MutationEvent {
                    mutated_field_name: string::utf8(b"description"),
                    old_value: token.description,
                    new_value: description
                },
            );
        };
```

**File:** storage/indexer/src/event_v2_translator.rs (L221-224)
```rust
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
```

**File:** storage/indexer/src/event_v2_translator.rs (L440-456)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(
                token_mutation.token_address(),
                &struct_tag,
            )? {
            let token_resource: TokenResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *token_resource.mutation_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, token_resource.mutation_events().count())?;
            (key, sequence_number)
        } else {
            // If the token resource is not found, we skip the event translation to avoid panic
            // because the creation number cannot be decided. The token may have been burned.
            return Err(AptosDbError::from(anyhow::format_err!(
                "Token resource not found"
            )));
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L149-149)
```rust
                .event_v2_translation_ignores_below_version()
```

**File:** storage/indexer/src/db_indexer.rs (L448-484)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
```

**File:** storage/indexer/src/db_indexer.rs (L565-578)
```rust
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
```

**File:** storage/aptosdb/src/event_store/mod.rs (L120-121)
```rust
        let mut iter = self.event_db.iter::<EventByKeySchema>()?;
        iter.seek(&(*event_key, start_seq_num))?;
```

**File:** types/src/on_chain_config/aptos_features.rs (L468-468)
```rust

```
