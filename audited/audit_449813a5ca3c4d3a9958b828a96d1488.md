# Audit Report

## Title
CommitVote Signature Aggregation DoS via LedgerInfo Mismatch

## Summary

A malicious validator can cause expensive repeated BLS signature verification operations by sending CommitVotes with matching `commit_info` but different `consensus_data_hash` values. The vulnerability exists because `add_signature_if_matched()` only validates the `commit_info` portion of the LedgerInfo, not the complete LedgerInfo structure, allowing mismatched signatures to be added to the SignatureAggregator and trigger costly verification failures.

## Finding Description

The vulnerability occurs in the CommitVote processing pipeline where signatures are aggregated for commit decisions. A `LedgerInfo` structure consists of two components: `commit_info` (BlockInfo) and `consensus_data_hash` (HashValue). [1](#0-0) 

The critical flaw is in `add_signature_if_matched()` which only checks the `commit_info` portion, not the full `LedgerInfo`. For the Executed state, it validates `executed.commit_info == *target_commit_info` [2](#0-1)  and for the Signed state, it checks `signed.partial_commit_proof.data().commit_info() == target_commit_info` [3](#0-2) 

In contrast, during initialization via `create_signature_aggregator()`, the full LedgerInfo is correctly validated with `vote.ledger_info() == commit_ledger_info` [4](#0-3) 

**Attack Flow:**

1. A malicious validator constructs a CommitVote signed over a LedgerInfo with matching `commit_info` but different `consensus_data_hash`
2. When received, the vote undergoes verification via `optimistic_verify()` which, when optimistic signature verification is enabled and the validator is not in the pessimistic_verify_set, skips actual cryptographic validation [5](#0-4) 
3. The vote passes the partial `commit_info` check in `add_signature_if_matched()` and is added to the aggregator
4. When `try_advance_to_aggregated()` is called, it triggers `aggregate_and_verify()` [6](#0-5) 
5. The `aggregate_and_verify()` method attempts to verify all signatures against the aggregator's LedgerInfo [7](#0-6) 
6. Verification fails because the malicious signature was signed over a different `consensus_data_hash`
7. This triggers `filter_invalid_signatures()` which performs expensive individual BLS signature verification for ALL signatures in the aggregator using parallel iteration [8](#0-7) 
8. The malicious validator is added to `pessimistic_verify_set`, but the expensive computation has already occurred

**Computational Cost:**
Each malicious vote triggers O(N) individual BLS signature verifications where N is the number of validators in the aggregator. BLS pairing operations are cryptographically expensive operations taking milliseconds each.

## Impact Explanation

This vulnerability enables validator node slowdowns through CPU exhaustion, qualifying as **Medium Severity**. While the Aptos bug bounty lists "Validator Node Slowdowns" under High severity, this specific instance merits Medium severity due to:

1. **Built-in Mitigation**: After first detection, attackers are added to `pessimistic_verify_set`, preventing repeated attacks from the same validator
2. **Limited Scope**: Impact is contained to nodes processing the malicious votes; consensus safety is not compromised
3. **Temporary Impact**: The slowdown is temporary and does not cause total loss of liveness
4. **Rate Limited**: Network message rate limits reduce attack frequency

The vulnerability breaks the Resource Limits invariant by allowing unbounded computational work triggered by malicious but structurally valid messages. However, it does not break consensus safety or enable fund theft.

## Likelihood Explanation

**Likelihood: Medium**

The attack is moderately likely because:

1. **Low Technical Barrier**: Any active validator can execute this attack by constructing a CommitVote with altered `consensus_data_hash`
2. **Easy to Exploit**: Requires only modifying one field in the LedgerInfo structure
3. **Initial Success Guaranteed**: The attack succeeds at least once before pessimistic verification activates
4. **Limited Attack Surface**: Requires validator status, limiting the pool of potential attackers to active validators
5. **Network Constraints**: Message rate limits and network topology reduce attack frequency

## Recommendation

Modify `add_signature_if_matched()` to validate the complete `LedgerInfo` structure, not just the `commit_info` portion. The fix should compare the full `vote.ledger_info()` against the expected LedgerInfo in the aggregator:

For Executed state, compare against the full expected LedgerInfo constructed from `commit_info` and the appropriate `consensus_data_hash`. For Signed state, compare `vote.ledger_info()` against `signed.partial_commit_proof.data()` instead of just comparing `commit_info` portions.

This ensures that only signatures signed over the exact expected LedgerInfo are added to the SignatureAggregator, preventing the expensive fallback verification from being triggered by mismatched signatures.

## Proof of Concept

A proof of concept would involve:
1. Setting up a test validator with optimistic signature verification enabled
2. Creating a CommitVote with correct `commit_info` but modified `consensus_data_hash`
3. Sending this vote to a node and observing the expensive `filter_invalid_signatures()` execution
4. Verifying that individual BLS verifications are performed for all N signatures in the aggregator

The existing test at lines 607-758 in `consensus/src/pipeline/buffer_item.rs` demonstrates similar behavior with invalid signatures, confirming the expensive verification path is triggered. [9](#0-8) 

## Notes

This vulnerability represents a subtle interaction between optimistic signature verification (a performance optimization) and incomplete validation in the signature aggregation logic. The attack exploits the fact that `add_signature_if_matched()` performs a weaker check than `create_signature_aggregator()`, creating a validation gap that allows malicious votes to enter the aggregator and trigger expensive cryptographic operations upon verification failure.

### Citations

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L40-52)
```rust
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
) -> SignatureAggregator<LedgerInfo> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    for vote in unverified_votes.values() {
        let sig = vote.signature_with_status();
        if vote.ledger_info() == commit_ledger_info {
            sig_aggregator.add_signature(vote.author(), sig);
        }
    }
    sig_aggregator
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L294-348)
```rust
    pub fn try_advance_to_aggregated(self, validator: &ValidatorVerifier) -> Self {
        match self {
            Self::Signed(signed_item) => {
                if signed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();
                    if let Ok(commit_proof) = signed_item
                        .partial_commit_proof
                        .clone()
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: signed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Signed(signed_item)
            },
            Self::Executed(mut executed_item) => {
                if executed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();

                    if let Ok(commit_proof) = executed_item
                        .partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: executed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Executed(executed_item)
            },
            _ => self,
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-399)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
```

**File:** consensus/src/pipeline/buffer_item.rs (L401-405)
```rust
            Self::Signed(signed) => {
                if signed.partial_commit_proof.data().commit_info() == target_commit_info {
                    signed.partial_commit_proof.add_signature(author, signature);
                    return Ok(());
                }
```

**File:** consensus/src/pipeline/buffer_item.rs (L607-758)
```rust
    // This tests the case where some of the commit votes are not correct
    #[test]
    fn test_buffer_item_bad_path_1() {
        let (validator_signers, validator_verifier) = create_validators();
        let pipelined_block = create_pipelined_block();
        let block_info = pipelined_block.block_info();
        let ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
        let ordered_proof =
            LedgerInfoWithSignatures::new(ledger_info.clone(), AggregateSignature::empty());
        let mut commit_votes =
            create_valid_commit_votes(validator_signers.clone(), ledger_info.clone());

        // Corrupting commit_votes[3], commit_votes[5]
        commit_votes[3] = CommitVote::new_with_signature(
            validator_signers[3].author(),
            ledger_info.clone(),
            bls12381::Signature::dummy_signature(),
        );
        commit_votes[5] = CommitVote::new_with_signature(
            validator_signers[5].author(),
            ledger_info.clone(),
            bls12381::Signature::dummy_signature(),
        );

        let mut partial_signatures = BTreeMap::new();
        partial_signatures.insert(
            validator_signers[0].author(),
            commit_votes[0].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[1].author(),
            commit_votes[1].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[2].author(),
            commit_votes[2].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[4].author(),
            commit_votes[4].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[6].author(),
            commit_votes[6].signature().clone(),
        );
        let li_with_sig = validator_verifier
            .aggregate_signatures(partial_signatures.iter())
            .unwrap();
        let commit_proof = LedgerInfoWithSignatures::new(ledger_info.clone(), li_with_sig);

        let mut cached_commit_votes = HashMap::new();
        cached_commit_votes.insert(commit_votes[0].author(), commit_votes[0].clone());
        cached_commit_votes.insert(commit_votes[1].author(), commit_votes[1].clone());
        let mut ordered_item = BufferItem::new_ordered(
            vec![pipelined_block.clone()],
            ordered_proof.clone(),
            cached_commit_votes,
        );

        ordered_item
            .add_signature_if_matched(commit_votes[2].clone())
            .unwrap();
        ordered_item
            .add_signature_if_matched(commit_votes[3].clone())
            .unwrap();

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 0);
        let mut executed_item = ordered_item.advance_to_executed_or_aggregated(
            vec![pipelined_block.clone()],
            &validator_verifier,
            None,
            true,
        );

        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }

        executed_item
            .add_signature_if_matched(commit_votes[4].clone())
            .unwrap();

        let mut executed_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4, // Commit_votes[3] is not correct and will be removed from the partial_commit_proof
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }
        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);

        executed_item
            .add_signature_if_matched(commit_votes[5].clone())
            .unwrap();

        let mut executed_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4, // Commit_votes[5] is not correct and will be removed from the partial_commit_proof
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }
        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 2);

        executed_item
            .add_signature_if_matched(commit_votes[6].clone())
            .unwrap();
        let aggregated_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match aggregated_item {
            BufferItem::Aggregated(aggregated_item_inner) => {
                assert_eq!(aggregated_item_inner.executed_blocks, vec![pipelined_block]);
                assert_eq!(aggregated_item_inner.commit_proof, commit_proof);
            },
            _ => panic!("Expected aggregated item."),
        }
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```
