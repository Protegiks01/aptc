# Audit Report

## Title
Block Timestamp Manipulation Allows Bypassing Mempool Transaction Expiration Enforcement

## Summary
A malicious validator proposing a block can set the `block_timestamp_usecs` to an artificially old value (while still satisfying timestamp > parent constraints), causing mempool's `gc_by_expiration_time()` to fail to remove expired transactions. This allows expired transactions to persist in mempool and potentially be included in future blocks, violating transaction expiration invariants.

## Finding Description

The vulnerability exists in the block timestamp validation logic within the consensus layer. When a block is proposed, the timestamp must satisfy only two constraints: [1](#0-0) [2](#0-1) 

These checks ensure the timestamp is strictly increasing and not more than 5 minutes in the future, but there is **no lower bound check** to ensure the timestamp is reasonably close to the current time. A malicious proposer can exploit this by setting:

`block_timestamp = parent_block_timestamp + 1 microsecond`

If the parent block was committed hours ago, this new block would have a timestamp far in the past relative to the actual current time, yet it would pass all validation checks.

When blocks are inserted into the block store, there is a wait mechanism for future timestamps: [3](#0-2) 

However, this only waits if `block_time > current_timestamp`. For blocks with timestamps in the past, `checked_sub` returns `None` and no validation or waiting occurs - the block is immediately processed.

When such a block is committed, mempool receives a notification with the artificially old timestamp: [4](#0-3) [5](#0-4) 

The `gc_by_expiration_time()` function uses this timestamp to garbage collect transactions: [6](#0-5) 

The expiration check is performed against the transaction's client-specified `expiration_timestamp_secs()`: [7](#0-6) 

With an artificially old block timestamp, transactions that have actually expired (their `expiration_timestamp_secs < current_real_time`) will **not** be garbage collected because:

`expiration_timestamp_secs > old_block_timestamp`

These expired transactions will remain in mempool until either:
1. The next periodic system TTL garbage collection runs (separate mechanism)
2. A subsequent block with a newer timestamp is committed

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The specific impacts include:

1. **Transaction Expiration Bypass**: Transactions that should have expired based on their client-specified expiration time remain eligible for inclusion in blocks beyond their intended lifetime.

2. **Mempool Resource Exhaustion**: Expired transactions consume mempool capacity (memory, CPU cycles for validation/broadcasting) that should be available for valid transactions.

3. **Repeated Exploitation**: A malicious validator can repeatedly propose blocks with old timestamps to continuously prevent proper transaction expiration enforcement, especially if they control multiple validators or propose multiple times.

4. **Protocol Invariant Violation**: The system violates the guarantee that transactions will be automatically removed from mempool after their expiration time, which users rely on for transaction safety (e.g., preventing stale transactions from executing).

While not directly causing fund loss, this enables state inconsistencies that undermine mempool functionality and transaction lifecycle guarantees.

## Likelihood Explanation

**Likelihood: Medium-High**

Requirements for exploitation:
- Attacker must be a validator in the active set
- Attacker must be selected as proposer for at least one round (proposer selection rotates)
- Attack requires no collusion with other validators
- Attack is straightforward to execute once proposer role is obtained

In Aptos's BFT model, the system tolerates up to 1/3 Byzantine validators. Any validator in this Byzantine set could exploit this vulnerability during their proposer rounds. Given that:
- Proposer role rotates regularly among validators
- The attack requires only setting a single timestamp value
- No complex exploitation logic is needed

The likelihood is considered medium-high. The attack is not automatic but is trivially executable by any malicious validator during their proposer turns.

## Recommendation

Add a lower bound validation check for block timestamps to ensure they are within a reasonable range of the current time. The check should be added to the `verify_well_formed()` function:

```rust
// In consensus/consensus-types/src/block.rs, around line 530
if self.is_nil_block() || parent.has_reconfiguration() {
    ensure!(
        self.timestamp_usecs() == parent.timestamp_usecs(),
        "Nil/reconfig suffix block must have same timestamp as parent"
    );
} else {
    ensure!(
        self.timestamp_usecs() > parent.timestamp_usecs(),
        "Blocks must have strictly increasing timestamps"
    );

    let current_ts = duration_since_epoch();
    
    // Add this new check for lower bound
    const MIN_TIMEBOUND: u64 = 300_000_000; // 5 minutes
    ensure!(
        self.timestamp_usecs() >= (current_ts.as_micros() as u64).saturating_sub(MIN_TIMEBOUND),
        "Blocks must not have timestamps too far in the past"
    );

    // Existing upper bound check
    const TIMEBOUND: u64 = 300_000_000;
    ensure!(
        self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
        "Blocks must not be too far in the future"
    );
}
```

This ensures block timestamps fall within a [-5 minutes, +5 minutes] window relative to current time, preventing both artificially old and excessively future timestamps.

## Proof of Concept

The following demonstrates the vulnerability through a Rust-based test scenario:

```rust
// Integration test demonstrating the vulnerability
// Place in consensus/src/block_storage/block_store_test.rs

#[tokio::test]
async fn test_old_timestamp_bypasses_expiration_gc() {
    use aptos_types::transaction::SignedTransaction;
    use std::time::{Duration, SystemTime};
    
    // Setup: Create a parent block with timestamp from 1 hour ago
    let one_hour_ago = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .checked_sub(Duration::from_secs(3600))
        .unwrap();
    
    let parent_timestamp_usecs = one_hour_ago.as_micros() as u64;
    
    // Create parent block with old timestamp
    let parent_block = create_test_block_with_timestamp(parent_timestamp_usecs);
    
    // Attacker creates new block with timestamp barely above parent
    // (parent_timestamp + 1 microsecond)
    let malicious_timestamp_usecs = parent_timestamp_usecs + 1;
    let malicious_block = create_test_block_with_timestamp(malicious_timestamp_usecs);
    
    // Verify that malicious_block passes verify_well_formed()
    // It should pass because:
    // 1. timestamp > parent.timestamp ✓
    // 2. timestamp < current_time + 5_minutes ✓
    assert!(malicious_block.verify_well_formed().is_ok());
    
    // Create a transaction that expired 30 minutes ago
    let thirty_min_ago = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .checked_sub(Duration::from_secs(1800))
        .unwrap();
    
    let expired_txn_expiration = thirty_min_ago.as_secs();
    let expired_txn = create_test_transaction_with_expiration(expired_txn_expiration);
    
    // Add transaction to mempool
    let mut mempool = setup_test_mempool();
    mempool.add_transaction(expired_txn.clone());
    
    // Simulate block commit with old timestamp
    let block_timestamp = Duration::from_micros(malicious_timestamp_usecs);
    mempool.gc_by_expiration_time(block_timestamp);
    
    // VULNERABILITY: Transaction should be removed (expired 30 min ago)
    // but remains in mempool because:
    // expired_txn_expiration (30 min ago) > malicious_timestamp (1 hour ago)
    assert!(
        mempool.contains_transaction(&expired_txn.hash()),
        "Expired transaction incorrectly remains in mempool"
    );
    
    // The transaction would only be removed when:
    // - System TTL gc runs, OR
    // - A block with timestamp > expired_txn_expiration commits
}
```

This PoC demonstrates that by manipulating block timestamps to be artificially old (while still passing validation), expired transactions that should be removed from mempool persist incorrectly, allowing them to potentially be included in future blocks.

**Notes:**

The vulnerability relies on insufficient timestamp validation allowing blocks with unreasonably old timestamps to be accepted by consensus, which then propagates to mempool's garbage collection mechanism. The system's documented guarantee that "An honest validator will only vote on a block when its own clock >= timestamp T" is not enforced in code, allowing this attack vector to succeed.

### Citations

**File:** consensus/consensus-types/src/block.rs (L527-530)
```rust
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
            );
```

**File:** consensus/consensus-types/src/block.rs (L532-539)
```rust
            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
```

**File:** consensus/src/block_storage/block_store.rs (L499-511)
```rust
        // ensure local time past the block time
        let block_time = Duration::from_micros(pipelined_block.timestamp_usecs());
        let current_timestamp = self.time_service.get_current_timestamp();
        if let Some(t) = block_time.checked_sub(current_timestamp) {
            if t > Duration::from_secs(1) {
                warn!(
                    "Long wait time {}ms for block {}",
                    t.as_millis(),
                    pipelined_block
                );
            }
            self.time_service.wait_until(block_time).await;
        }
```

**File:** mempool/src/shared_mempool/coordinator.rs (L252-257)
```rust
    process_committed_transactions(
        mempool,
        use_case_history,
        msg.transactions,
        msg.block_timestamp_usecs,
    );
```

**File:** mempool/src/shared_mempool/tasks.rs (L740-742)
```rust
    if block_timestamp_usecs > 0 {
        pool.gc_by_expiration_time(block_timestamp);
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L119-121)
```rust
            expiration_time_index: TTLIndex::new(Box::new(|t: &MempoolTransaction| {
                Duration::from_secs(t.txn.expiration_timestamp_secs())
            })),
```

**File:** mempool/src/core_mempool/transaction_store.rs (L909-911)
```rust
    pub(crate) fn gc_by_expiration_time(&mut self, block_time: Duration) {
        self.gc(self.eager_expire_time(block_time), false);
    }
```
