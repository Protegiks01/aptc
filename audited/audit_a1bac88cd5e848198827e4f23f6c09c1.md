# Audit Report

## Title
Configuration Normalization Bypass Allows Proposal Generation to Exceed Receiver Block Size Limits

## Summary
Mismatched `max_sending_block_txns` and `max_sending_block_bytes` configuration parameters can cause the `PayloadTxnsSize` normalization logic to silently increase the effective byte limit beyond configured values, allowing proposers to generate blocks that exceed receiver validation limits and causing consensus liveness degradation.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Config Validation**: The `sanitize_send_recv_block_limits` function validates that configured sending limits are less than or equal to receiving limits. [1](#0-0) 

2. **Payload Size Normalization**: When `PayloadTxnsSize` is constructed, if `count > bytes`, the normalization logic sets `bytes = count` to maintain the invariant `count <= bytes`. [2](#0-1) 

3. **Proposal Generation**: The `ProposalGenerator` is initialized with the normalized `PayloadTxnsSize` constructed from config values. [3](#0-2) 

4. **Block Validation**: Receivers validate proposals against two independent limits for transaction count and byte size. [4](#0-3) 

**Attack Path:**

1. Operator configures: `max_sending_block_txns = 5001, max_sending_block_bytes = 1000`
2. Operator configures: `max_receiving_block_txns = 10000, max_receiving_block_bytes = 5000`
3. Config sanitization passes: `5001 <= 10000 ✓` and `1000 <= 5000 ✓`
4. At runtime, `PayloadTxnsSize::new(5001, 1000)` is called
5. Normalization detects `5001 > 1000` and adjusts to `PayloadTxnsSize(5001, 5001)`
6. Proposer generates blocks up to 5001 bytes (using normalized limit)
7. Receiver validates: `payload_size <= 5000` → **FAILS** (5001 > 5000)
8. Block proposals are rejected, causing consensus liveness issues

The root cause is that config sanitization validates the **raw configuration values** before normalization, but the **normalized values** are used for proposal generation. This creates a window where the effective sending limit can exceed the receiving limit.

## Impact Explanation

**Severity: Medium** (up to $10,000)

This vulnerability causes **state inconsistencies requiring intervention**:

- **Consensus Liveness Degradation**: Affected validators continuously propose blocks that other validators reject, leading to increased round timeouts and reduced throughput
- **Network Fragmentation Risk**: Misconfigured validators cannot successfully propose blocks, requiring manual intervention to identify and fix configuration issues
- **Operational Impact**: The issue manifests as proposal rejection errors that are difficult to diagnose since the configuration appears valid

While this doesn't lead to consensus safety violations or permanent network failure, it requires operator intervention to resolve and can significantly degrade network performance during the misconfiguration period.

## Likelihood Explanation

**Likelihood: Medium-to-High**

This vulnerability is likely to occur because:

1. **Configuration Complexity**: The relationship between transaction count and byte limits is non-obvious, making misconfigurations easy
2. **Silent Normalization**: The normalization logic only logs a warning, which may be missed in production environments
3. **Validation Gap**: The sanitization checks appear sufficient but don't catch the normalized value mismatch
4. **Legitimate Use Cases**: Operators might intentionally set low byte limits to restrict block sizes while allowing more transactions for small transaction scenarios

The issue is particularly likely when operators:
- Copy configurations across environments with different requirements
- Manually tune performance parameters without full understanding of normalization behavior
- Use automated configuration management that generates parameter combinations

## Recommendation

Add validation to ensure that after normalization, the effective sending limits still respect receiving limits:

```rust
fn sanitize_send_recv_block_limits(
    sanitizer_name: &str,
    config: &ConsensusConfig,
) -> Result<(), Error> {
    // Validate raw config values
    let send_recv_pairs = [
        (config.max_sending_block_txns, config.max_receiving_block_txns, "send < recv for txns"),
        (config.max_sending_block_bytes, config.max_receiving_block_bytes, "send < recv for bytes"),
    ];
    for (send, recv, label) in &send_recv_pairs {
        if *send > *recv {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.to_owned(),
                format!("Failed {}: {} > {}", label, *send, *recv),
            ));
        }
    }
    
    // NEW: Validate normalized values would also respect limits
    let normalized_sending = PayloadTxnsSize::new(
        config.max_sending_block_txns,
        config.max_sending_block_bytes
    );
    
    if normalized_sending.count() > config.max_receiving_block_txns {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!(
                "Normalized sending txn count {} exceeds receiving limit {}",
                normalized_sending.count(), config.max_receiving_block_txns
            ),
        ));
    }
    
    if normalized_sending.size_in_bytes() > config.max_receiving_block_bytes {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!(
                "Normalized sending bytes {} exceeds receiving limit {}",
                normalized_sending.size_in_bytes(), config.max_receiving_block_bytes
            ),
        ));
    }
    
    Ok(())
}
```

Additionally, enhance the warning in `PayloadTxnsSize::new` to include guidance:
```rust
warn!(
    "Invalid PayloadTxnsSize input - normalizing may violate downstream limits. \
     Count: {}, Bytes: {}, Err: {}. \
     Check that max_sending_block_txns <= max_sending_block_bytes in config.",
    count, bytes, err
);
```

## Proof of Concept

```rust
#[test]
fn test_normalized_sending_exceeds_receiving_limit() {
    // Simulate a misconfigured consensus config
    let config = ConsensusConfig {
        max_sending_block_txns: 5001,
        max_sending_block_bytes: 1000,
        max_receiving_block_txns: 10000,
        max_receiving_block_bytes: 5000,
        ..ConsensusConfig::default()
    };
    
    // Config sanitization would pass with current implementation
    assert!(ConsensusConfig::sanitize_send_recv_block_limits(
        "test",
        &config
    ).is_ok());
    
    // But normalization creates a problem
    let normalized_sending = PayloadTxnsSize::new(
        config.max_sending_block_txns,
        config.max_sending_block_bytes
    );
    
    // The normalized bytes limit exceeds the receiving limit!
    assert_eq!(normalized_sending.count(), 5001);
    assert_eq!(normalized_sending.size_in_bytes(), 5001); // Normalized from 1000
    assert!(normalized_sending.size_in_bytes() > config.max_receiving_block_bytes);
    
    // This would cause proposal rejections:
    // Proposer uses normalized_sending.size_in_bytes() = 5001
    // Receiver checks: payload_size <= max_receiving_block_bytes = 5000
    // Result: Block rejected, consensus liveness degraded
}
```

**Notes:**
- The vulnerability requires operator misconfiguration but the system should prevent invalid configurations
- The fix adds minimal overhead (one additional PayloadTxnsSize construction during config validation)
- This issue affects any validator that proposes blocks with the misconfigured settings
- The impact scales with the validator's proposal frequency in the rotation

### Citations

**File:** config/src/config/consensus_config.rs (L415-440)
```rust
    fn sanitize_send_recv_block_limits(
        sanitizer_name: &str,
        config: &ConsensusConfig,
    ) -> Result<(), Error> {
        let send_recv_pairs = [
            (
                config.max_sending_block_txns,
                config.max_receiving_block_txns,
                "send < recv for txns",
            ),
            (
                config.max_sending_block_bytes,
                config.max_receiving_block_bytes,
                "send < recv for bytes",
            ),
        ];
        for (send, recv, label) in &send_recv_pairs {
            if *send > *recv {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name.to_owned(),
                    format!("Failed {}: {} > {}", label, *send, *recv),
                ));
            }
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/utils.rs (L33-44)
```rust
    fn new_normalized(count: u64, bytes: u64) -> Self {
        let mut count = count;
        let mut bytes = bytes;
        if count > bytes {
            bytes = count;
        }
        if count == 0 || bytes == 0 {
            count = 0;
            bytes = 0;
        }
        Self { count, bytes }
    }
```

**File:** consensus/src/epoch_manager.rs (L919-928)
```rust
        let proposal_generator = ProposalGenerator::new(
            self.author,
            block_store.clone(),
            payload_client,
            self.time_service.clone(),
            Duration::from_millis(self.config.quorum_store_poll_time_ms),
            PayloadTxnsSize::new(
                self.config.max_sending_block_txns,
                self.config.max_sending_block_bytes,
            ),
```

**File:** consensus/src/round_manager.rs (L1180-1193)
```rust
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```
