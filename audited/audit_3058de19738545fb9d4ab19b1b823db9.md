# Audit Report

## Title
String Slicing Panic in standardize_address() Causes Indexer Node Crash via Multi-Byte UTF-8 Characters

## Summary
The `standardize_address()` function in the indexer-grpc transaction filter performs unsafe string slicing at byte indices without validating UTF-8 character boundaries. An attacker can crash indexer nodes by submitting transaction filters containing address strings that end with multi-byte UTF-8 characters (e.g., "0xÃ©"), causing a panic when the function attempts to slice through the middle of a multi-byte character.

## Finding Description
The vulnerability exists in the `standardize_address()` function [1](#0-0)  which processes address strings for the transaction filtering system.

The critical issue is at the string slicing operation [2](#0-1) . This code slices the string at byte index `len - 1` without checking if this index falls on a UTF-8 character boundary. When the string ends with a multi-byte UTF-8 character (any non-ASCII character like 'Ã©', 'ä¸­', 'ðŸ”¥'), the slice operation attempts to cut through the middle of that character, causing Rust to panic with "byte index X is not a char boundary".

**Attack Path:**
1. Attacker creates a `UserTransactionFilter` with sender = "0xÃ©" (or any address ending with multi-byte UTF-8 character)
2. Filter is submitted via gRPC to the indexer service (parsed via protobuf where strings are valid UTF-8 but not validated for hex format)
3. Filter passes validation [3](#0-2)  which only checks that at least one field is set, not the hex format
4. When the filter is applied to match transactions [4](#0-3) , it calls `get_standardized_sender()` which invokes `standardize_address()`
5. The `standardize_address()` function panics, crashing the indexer node thread or process

**Secondary Issue:**
Line 33 also has a potential integer underflow: `&ZEROS[..64 - trimmed.len()]` will panic if `trimmed.len() > 64` in debug mode or cause undefined behavior in release mode.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:
- **API crashes**: The indexer-grpc service will crash when processing the malicious filter
- **Significant protocol violations**: Indexer nodes are critical infrastructure for querying blockchain state

The impact includes:
- **Denial of Service**: Attackers can repeatedly crash indexer nodes by submitting malicious filters
- **Service Disruption**: Applications relying on indexer APIs will experience downtime
- **Resource Exhaustion**: Repeated crashes force node restarts, consuming system resources

While this doesn't directly affect consensus or validator nodes, indexer infrastructure is critical for dApp functionality and blockchain usability.

## Likelihood Explanation
**Likelihood: HIGH**

The attack is trivially exploitable:
- **No authentication required**: Any gRPC client can submit transaction filters
- **Simple payload**: A single character like "Ã©" is sufficient to trigger the crash
- **No special privileges needed**: The attacker doesn't need validator access or special permissions
- **Immediate effect**: The panic occurs synchronously during filter application
- **Repeatable**: The attack can be executed repeatedly to maintain denial of service

The only requirement is network access to the indexer-grpc service, which is typically publicly exposed for API access.

## Recommendation
Implement proper input validation and use character-aware string operations:

```rust
pub fn standardize_address(address: &str) -> String {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate that address contains only hex characters
    if !trimmed.chars().all(|c| c.is_ascii_hexdigit()) {
        // Return the address in long format without special handling
        let mut result = String::with_capacity(66);
        result.push_str("0x");
        if trimmed.len() >= 64 {
            result.push_str(trimmed);
        } else {
            result.push_str(&ZEROS[..64 - trimmed.len()]);
            result.push_str(trimmed);
        }
        return result;
    }
    
    // Check if the address is a special address
    if let Some(last_char) = trimmed.chars().last() {
        // Use character-aware operations instead of byte slicing
        let char_count = trimmed.chars().count();
        if char_count > 1 {
            let all_zeros_before_last = trimmed
                .chars()
                .take(char_count - 1)
                .all(|c| c == '0');
            
            if all_zeros_before_last 
                && last_char.is_ascii_hexdigit() 
                && last_char <= 'f' 
            {
                let mut result = String::with_capacity(3);
                result.push_str("0x");
                result.push(last_char);
                return result;
            }
        }
    }
    
    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    if trimmed.len() >= 64 {
        result.push_str(trimmed);
    } else {
        result.push_str(&ZEROS[..64 - trimmed.len()]);
        result.push_str(trimmed);
    }
    result
}
```

Additionally, add validation in `UserTransactionFilter::validate_state()` to reject non-hex addresses early.

## Proof of Concept

```rust
#[cfg(test)]
mod test_vulnerability {
    use super::*;

    #[test]
    #[should_panic(expected = "byte index")]
    fn test_multibyte_utf8_panic() {
        // This test demonstrates the panic when address ends with multi-byte UTF-8
        // The 'Ã©' character is 2 bytes (0xC3 0xA9), causing slice panic
        let malicious_address = "0xÃ©";
        standardize_address(malicious_address);
    }

    #[test]
    #[should_panic(expected = "byte index")]
    fn test_multibyte_utf8_panic_with_zeros() {
        // Even with leading zeros, the panic still occurs
        let malicious_address = "0x00000000000000000000000000000000000000000000000000000000000000Ã©";
        standardize_address(malicious_address);
    }

    #[test]
    #[should_panic(expected = "byte index")]
    fn test_multibyte_chinese_character() {
        // Chinese character is 3 bytes, also triggers panic
        let malicious_address = "0xä¸­";
        standardize_address(malicious_address);
    }
    
    #[test]
    #[should_panic]
    fn test_overflow_on_long_address() {
        // Address longer than 64 chars causes integer underflow
        let long_address = "0x11111111111111111111111111111111111111111111111111111111111111111";
        standardize_address(long_address);
    }
}
```

**To exploit against a running indexer:**
1. Create a gRPC client for the indexer service
2. Send a `GetTransactionsRequest` with `transaction_filter` containing:
   ```json
   {
     "filter": {
       "api_filter": {
         "user_transaction_filter": {
           "sender": "0xÃ©"
         }
       }
     }
   }
   ```
3. The indexer node will crash when attempting to apply the filter

## Notes
This vulnerability affects the indexer-grpc component specifically, not the core consensus or validator nodes. However, indexers are critical infrastructure for the Aptos ecosystem as they provide the primary API for querying blockchain state. The lack of input validation combined with unsafe string slicing creates a trivial denial-of-service attack vector that can be exploited without any special privileges or complex payloads.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L74-80)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.sender.is_none() && self.payload.is_none() {
            return Err(Error::msg("At least one of sender or payload must be set").into());
        };
        self.payload.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L83-115)
```rust
    fn matches(&self, txn: &Transaction) -> bool {
        let user_request = if let Some(TxnData::User(u)) = txn.txn_data.as_ref() {
            if let Some(user_request) = u.request.as_ref() {
                user_request
            } else {
                return false;
            }
        } else {
            return false;
        };

        if let Some(sender_filter) = self.get_standardized_sender() {
            if &standardize_address(&user_request.sender) != sender_filter {
                return false;
            }
        }

        if let Some(payload_filter) = &self.payload {
            // Get the entry_function_payload from both UserPayload and MultisigPayload
            let entry_function_payload = user_request
                .payload
                .as_ref()
                .and_then(get_entry_function_payload_from_transaction_payload);
            if let Some(payload) = entry_function_payload {
                // Here we have an actual EntryFunctionPayload
                if !payload_filter.matches(payload) {
                    return false;
                }
            }
        }

        true
    }
```
