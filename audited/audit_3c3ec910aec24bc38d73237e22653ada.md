# Audit Report

## Title
Division by Zero Crash in Block Partitioner Due to Missing Parameter Validation

## Summary
`PartitionState::new()` lacks validation for the `num_executor_shards` parameter, allowing zero as a value. This creates invalid state that immediately causes division-by-zero panics during initialization, crashing validator nodes attempting to partition blocks for execution.

## Finding Description

The `PartitionState::new()` function accepts `num_executor_shards` without validating that it must be greater than zero. [1](#0-0) 

When `num_executor_shards` is 0, the function creates invalid state by initializing an empty vector: [2](#0-1) 

Shortly after state creation, the `init()` function is called, which iterates through transactions and calls `get_anchor_shard_id()` with `num_executor_shards`: [3](#0-2) 

The `get_anchor_shard_id()` function performs a modulo operation with `num_shards`, causing division by zero when the value is 0: [4](#0-3) 

Additional crashes occur in the pre-partitioning phase. The `UniformPartitioner` performs division with `num_chunks` (which equals `num_shards`): [5](#0-4) 

The `ConnectedComponentPartitioner` performs subtraction that underflows when `num_executor_shards` is 0: [6](#0-5) 

The executor benchmark configuration demonstrates this is a realistic scenario, with a default value of 0: [7](#0-6) 

This breaks the **Resource Limits** and **Deterministic Execution** invariants - the partitioning process should handle all valid configurations gracefully, and a misconfigured validator should fail safely rather than crash.

## Impact Explanation

**Severity: High** - This qualifies as "API crashes" and "Validator node slowdowns" per the bug bounty criteria.

When triggered, this causes an immediate panic that crashes the validator node's block execution pipeline. While the node may restart, it will crash again on the next partitioning attempt if the configuration remains invalid. This constitutes a **validator availability issue**, though not total network unavailability since only misconfigured nodes are affected.

The impact is limited because:
- Only affects nodes with misconfigured `num_executor_shards=0`
- Does not affect consensus safety or state integrity
- Does not allow theft or manipulation of funds
- Is recoverable by fixing the configuration

## Likelihood Explanation

**Likelihood: Medium**

The likelihood is moderate because:
- The default value in benchmark/test code is 0, making accidental misconfiguration plausible
- No validation exists at any layer to catch this before runtime
- Operators following example configurations could inadvertently trigger this
- However, production deployments likely use non-zero shard counts

This is primarily an **operational/configuration vulnerability** rather than an attacker-exploitable bug, since external actors cannot force a validator to use invalid configuration values.

## Recommendation

Add parameter validation in `PartitionState::new()` to ensure `num_executor_shards > 0`:

```rust
pub fn new(
    thread_pool: Arc<ThreadPool>,
    dashmap_num_shards: usize,
    txns: Vec<AnalyzedTransaction>,
    num_executor_shards: ShardId,
    num_rounds_limit: usize,
    cross_shard_dep_avoid_threshold: f32,
    partition_last_round: bool,
) -> Self {
    assert!(num_executor_shards > 0, "num_executor_shards must be greater than 0");
    assert!(num_rounds_limit > 0, "num_rounds_limit must be greater than 0");
    assert!(dashmap_num_shards > 0, "dashmap_num_shards must be greater than 0");
    
    // ... rest of implementation
}
```

Additionally, validate at the configuration level before passing to the partitioner, and change the default value in benchmark configurations to a sensible non-zero value like 1 or 4.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_partition_with_zero_shards() {
    use rayon::ThreadPoolBuilder;
    use std::sync::Arc;
    
    let thread_pool = Arc::new(ThreadPoolBuilder::new().num_threads(4).build().unwrap());
    let txns = vec![/* empty or with test transactions */];
    
    // This will create invalid state
    let state = PartitionState::new(
        thread_pool,
        64,
        txns,
        0,  // Invalid: num_executor_shards = 0
        4,
        0.9,
        false,
    );
    
    // This will panic with division by zero
    PartitionerV2::init(&mut state);
}
```

**Notes**

This vulnerability demonstrates a **defensive programming failure** where invalid input is not rejected at the boundary. While not directly exploitable by external attackers (since they cannot control validator configuration), it represents a real operational risk for validators and could cause unexpected downtime during configuration changes or deployments. The issue is exacerbated by the default value of 0 in example/benchmark code, which could be copied into production configurations.

### Citations

**File:** execution/block-partitioner/src/v2/state.rs (L111-119)
```rust
    pub fn new(
        thread_pool: Arc<ThreadPool>,
        dashmap_num_shards: usize,
        txns: Vec<AnalyzedTransaction>,
        num_executor_shards: ShardId,
        num_rounds_limit: usize,
        cross_shard_dep_avoid_threshold: f32,
        partition_last_round: bool,
    ) -> Self {
```

**File:** execution/block-partitioner/src/v2/state.rs (L150-150)
```rust
            start_txn_idxs_by_shard: vec![0; num_executor_shards],
```

**File:** execution/block-partitioner/src/v2/init.rs (L46-49)
```rust
                                let anchor_shard_id = get_anchor_shard_id(
                                    storage_location,
                                    state.num_executor_shards,
                                );
```

**File:** execution/block-partitioner/src/lib.rs (L39-43)
```rust
fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> ShardId {
    let mut hasher = DefaultHasher::new();
    storage_location.hash(&mut hasher);
    (hasher.finish() % num_shards as u64) as usize
}
```

**File:** execution/block-partitioner/src/pre_partition/uniform_partitioner/mod.rs (L21-24)
```rust
    fn process(&self, num_txns: usize, num_shards: usize) -> Vec<Vec<PrePartitionedTxnIdx>> {
        let num_chunks = num_shards;
        let num_big_chunks = num_txns % num_chunks;
        let small_chunk_size = num_txns / num_chunks;
```

**File:** execution/block-partitioner/src/pre_partition/connected_component/mod.rs (L150-150)
```rust
                let end: PrePartitionedTxnIdx = if shard_id == state.num_executor_shards - 1 {
```

**File:** execution/executor-benchmark/src/main.rs (L205-206)
```rust
    #[clap(long, default_value = "0")]
    num_executor_shards: usize,
```
