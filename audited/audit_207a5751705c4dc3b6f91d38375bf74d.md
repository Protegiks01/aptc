# Audit Report

## Title
Missing Length Validation in batch_open() Leads to Incorrect Blinding Factor Computation in Zeromorph PCS

## Summary
The `batch_open()` function in the Zeromorph polynomial commitment scheme implementation fails to validate that the `polys` and `rs` vectors have matching lengths. When `rs.len() < polys.len()`, the function computes an incorrect combined blinding factor, breaking the zero-knowledge property of the commitment scheme.

## Finding Description

The `batch_open()` function combines multiple polynomial commitments into a single opening proof using random linear combination. [1](#0-0) 

The function accepts a vector of polynomials and an optional vector of blinding factors (randomness values). [2](#0-1) 

The critical vulnerability occurs in how blinding factors are combined:

1. The function generates `gammas` with length equal to `polys.len()` for combining polynomials
2. All polynomials are combined using the full `gammas` vector [3](#0-2) 
3. However, blinding factors are combined using `rs.iter().zip(gammas.iter())` [4](#0-3) 

The `zip` operation stops at the shorter iterator. If `rs.len() < polys.len()`, only the first `rs.len()` blinding factors are included in the combined randomness `s`, while ALL polynomials were included in `combined_poly`.

This breaks the algebraic relationship required by the KZG hiding commitment scheme. The commitment homomorphism requires: [5](#0-4) 

For a batch opening to maintain zero-knowledge, the combined blinding factor must be `s = Σ(γⁱ * rᵢ)` for ALL i from 0 to n-1, where n = `polys.len()`. Missing terms result in incomplete hiding.

## Impact Explanation

**Current Impact: None - Function is Unused**

Despite the vulnerability existing in the code, extensive searches reveal that `batch_open()` is never called in the current Aptos codebase. The function exists only as:
- A trait method definition [6](#0-5) 
- An implementation in Zeromorph [7](#0-6) 

No actual usage exists in DKG protocols, benchmarks, or any other component.

**Potential Impact if Used:**
If this function were integrated into the DKG protocol for batching polynomial openings, the zero-knowledge break could allow:
- Information leakage about validator secret shares during DKG
- Compromise of the randomness generation protocol
- Potential validator private key recovery through repeated observations

This would be **High Severity** per bug bounty criteria (significant protocol violation).

## Likelihood Explanation

**Current Likelihood: Zero** - The function is not used anywhere in the codebase.

**Future Likelihood if Deployed:** High - Any developer using this function would naturally assume it correctly handles batch operations without checking internal implementation details.

## Recommendation

Add length validation at the start of the function:

```rust
fn batch_open<R: RngCore + CryptoRng>(
    ck: Self::CommitmentKey,
    polys: Vec<Self::Polynomial>,
    challenge: Vec<Self::WitnessField>,
    rs: Option<Vec<Self::WitnessField>>,
    rng: &mut R,
    trs: &mut merlin::Transcript,
) -> Self::Proof {
    let rs = rs.expect("rs must be present");
    
    // Add validation
    assert_eq!(
        rs.len(),
        polys.len(),
        "Blinding factors vector length ({}) must match polynomials vector length ({})",
        rs.len(),
        polys.len()
    );
    
    // ... rest of implementation
}
```

Alternatively, return a `Result` type to allow graceful error handling.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use ark_bls12_381::Bls12_381;
    use rand::SeedableRng;

    #[test]
    #[should_panic(expected = "assertion")]  
    fn test_batch_open_length_mismatch() {
        type E = Bls12_381;
        let mut rng = rand::rngs::StdRng::seed_from_u64(0);
        
        // Setup with degree bounds for 3 polynomials
        let (ck, _vk) = Zeromorph::<E>::setup(vec![2, 2, 2], &mut rng);
        
        // Create 3 polynomials
        let poly1 = random_poly::<Zeromorph<E>, _>(&mut rng, 4, 8);
        let poly2 = random_poly::<Zeromorph<E>, _>(&mut rng, 4, 8);
        let poly3 = random_poly::<Zeromorph<E>, _>(&mut rng, 4, 8);
        let polys = vec![poly1, poly2, poly3];
        
        // Only provide 2 blinding factors (MISMATCH!)
        let r1 = Zeromorph::<E>::random_witness(&mut rng);
        let r2 = Zeromorph::<E>::random_witness(&mut rng);
        let rs = Some(vec![r1, r2]);  // Missing r3!
        
        let challenge = random_point::<Zeromorph<E>, _>(&mut rng, 2);
        let mut trs = merlin::Transcript::new(b"test");
        
        // This will compute incorrect blinding factor without validation
        let _proof = Zeromorph::<E>::batch_open(
            ck,
            polys,
            challenge,
            rs,
            &mut rng,
            &mut trs,
        );
        
        // The proof is generated with s = r1*1 + r2*gamma (missing r3*gamma^2 term)
        // Breaking zero-knowledge property
    }
}
```

## Notes

**Critical Limitation:** This vulnerability is **NOT currently exploitable** because the `batch_open()` function is never called in the Aptos codebase. However, it represents a serious latent bug that would compromise cryptographic security if the function were integrated into future DKG implementations without fixing the validation issue.

The vulnerability exists in the code but has no active attack surface in the current deployment.

### Citations

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L533-563)
```rust
    fn batch_open<R: RngCore + CryptoRng>(
        ck: Self::CommitmentKey,
        polys: Vec<Self::Polynomial>,
        //   coms: Vec<Commitment>,
        challenge: Vec<Self::WitnessField>,
        rs: Option<Vec<Self::WitnessField>>,
        rng: &mut R,
        trs: &mut merlin::Transcript,
    ) -> Self::Proof {
        let rs = rs.expect("rs must be present");

        let gamma = trs.challenge_scalar();
        let gammas = powers(gamma, polys.len());

        let combined_poly = polys
            .iter()
            .zip(gammas.iter())
            .fold(Self::Polynomial::zero(), |acc, (poly, gamma_i)| {
                acc + poly * gamma_i
            });
        let eval = Self::evaluate_point(&combined_poly, &challenge);

        let s = rs
            .iter()
            .zip(gammas.iter())
            .fold(Self::WitnessField::zero(), |acc, (r, gamma_i)| {
                acc + (*r * gamma_i)
            });

        Zeromorph::open(&ck, &combined_poly, &challenge, eval, Scalar(s), rng, trs)
    }
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L359-365)
```rust
        let mut scalars = Vec::with_capacity(input.values.len() + 1);
        scalars.push(input.hiding_randomness.0);
        scalars.extend(input.values.iter().map(|s| s.0.clone()));

        let mut bases = Vec::with_capacity(input.values.len() + 1);
        bases.push(self.xi_1);
        bases.extend(&self.msm_basis[..input.values.len()]);
```

**File:** crates/aptos-dkg/src/pcs/traits.rs (L43-51)
```rust
    fn batch_open<R: RngCore + CryptoRng>(
        ck: Self::CommitmentKey,
        polys: Vec<Self::Polynomial>,
        //   coms: Vec<Commitment>,
        challenge: Vec<Self::WitnessField>,
        rs: Option<Vec<Self::WitnessField>>,
        rng: &mut R,
        trs: &mut merlin::Transcript,
    ) -> Self::Proof;
```
