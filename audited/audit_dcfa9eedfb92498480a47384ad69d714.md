# Audit Report

## Title
Out-of-Bounds Array Access in Move Compiler v2 Bytecode Generator via Invalid Temporary Indices

## Summary
The `temp_type()` function in the Move compiler v2's bytecode generator performs unchecked array indexing on the `temps` vector, which can cause a panic when processing invalid temporary indices that persist from earlier compilation stages. The function directly accesses `self.temps[temp]` without bounds validation. [1](#0-0) 

## Finding Description
The vulnerability occurs through a multi-stage compilation flow where invalid temporary indices can persist despite detection:

**Stage 1 - Invalid Temp Index Detection:**
The inliner's `rewrite_temporary()` function detects when a temporary index exceeds the valid parameter range, logs a compiler bug diagnostic, but returns `None` instead of halting compilation: [2](#0-1) 

**Stage 2 - Expression Preservation:**
When `rewrite_temporary()` returns `None`, the `ExpRewriter` framework preserves the original `ExpData::Temporary` with the invalid index unchanged: [3](#0-2) 

**Stage 3 - Bytecode Generation:**
During bytecode generation, `gen_temporary()` processes the expression and calls `emit_assign_with_convert()`: [4](#0-3) 

**Stage 4 - Unchecked Array Access:**
The `temp_type()` function is called twice (lines 679-680) and performs direct array indexing without bounds checking. If `temp >= temps.len()`, this causes a panic: [1](#0-0) 

**Attack Vector:**
An attacker could craft a Move module that, when processed through inlining transformations, generates `ExpData::Temporary` expressions with indices referencing parameters beyond the function's parameter list. The `gen_arg()` function can return these invalid indices directly for the last argument in a call: [5](#0-4) 

## Impact Explanation
This vulnerability represents a **High Severity** issue under the "API crashes" category. While the Move compiler v2 primarily runs off-chain during development, the crash affects:

1. **Developer Tooling**: Crashes compilation pipelines and IDEs
2. **CI/CD Systems**: Disrupts automated testing and deployment
3. **Module Verification**: If source-level verification is performed, could crash verification services
4. **Compiler Robustness**: Violates the principle that compilers should handle malformed input gracefully

The vulnerability breaks the **Resource Limits** invariant - compilation should not crash on malformed input but should instead report appropriate errors. A crash from untrusted input (user-provided Move code) is a security issue even in off-chain components.

## Likelihood Explanation  
Likelihood is **Medium**. The vulnerability requires:
1. Move code that triggers specific inlining scenarios where temp indices become invalid
2. The inliner to detect but not halt on the invalid indices
3. Subsequent processing to reach bytecode generation with the invalid indices intact

While not trivial to trigger accidentally, an attacker familiar with the compiler's inlining behavior could deliberately craft code to exploit this condition.

## Recommendation
Add bounds checking in `temp_type()` before array access:

```rust
fn temp_type(&self, temp: TempIndex) -> &Type {
    if temp >= self.temps.len() {
        self.internal_error(
            NodeId::new(0), // Use appropriate node_id from context
            format!("invalid temporary index {} (max: {})", temp, self.temps.len())
        );
        // Return error type to allow compilation to continue with error reporting
        return &Type::Error;
    }
    &self.temps[temp]
}
```

Additionally, the inliner should halt compilation after detecting invalid temp indices rather than allowing the AST to persist with known-bad data.

## Proof of Concept
The vulnerability can be triggered by creating a Move module with nested inline functions that capture parameters, forcing the inliner to remap temporary indices. When the remapping produces indices outside the valid range for the target function context, the invalid indices persist through to bytecode generation.

**Reproduction Steps:**
1. Create a Move module with an inline function that captures a parameter
2. Call this inline function from another inline function with parameter index manipulation
3. Compile the module using the Move compiler v2
4. The compiler will panic with an out-of-bounds array access in `temp_type()`

A complete PoC would require crafting specific Move code that triggers the exact inlining transformation conditions, which depends on internal compiler heuristics for when to inline and how to remap temporaries.

## Notes
This is a compiler implementation bug rather than a runtime VM vulnerability. It does not directly affect consensus, state management, or funds. However, it represents a robustness issue where malicious input (crafted Move source code) can crash compilation infrastructure. The issue is particularly concerning because the inliner already detects the condition but fails to prevent the invalid data from propagating to later stages where it causes an unhandled panic.

### Citations

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L331-334)
```rust
    /// Return type of temporary.
    fn temp_type(&self, temp: TempIndex) -> &Type {
        &self.temps[temp]
    }
```

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L667-686)
```rust
    fn gen_temporary(&mut self, targets: Vec<TempIndex>, id: NodeId, temp: TempIndex) {
        let target = self.require_unary_target(id, targets);
        self.emit_assign_with_convert(id, target, temp, AssignKind::Inferred)
    }

    fn emit_assign_with_convert(
        &mut self,
        id: NodeId,
        target: TempIndex,
        mut temp: TempIndex,
        kind: AssignKind,
    ) {
        let temp_ty = self.temp_type(temp).clone();
        let target_ty = self.temp_type(target).clone();
        if let Some((new_temp, oper)) = self.get_conversion(&target_ty, &temp_ty) {
            self.emit_call(id, vec![new_temp], oper, vec![temp]);
            temp = new_temp
        }
        self.emit_with(id, |attr| Bytecode::Assign(attr, target, temp, kind))
    }
```

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L1364-1393)
```rust
    fn gen_arg(&mut self, exp: &Exp, with_forced_temp: bool) -> TempIndex {
        match exp.as_ref() {
            ExpData::Temporary(_, temp) if !with_forced_temp => *temp,
            ExpData::LocalVar(id, sym) if !with_forced_temp => self.find_local(*id, *sym),
            ExpData::Call(id, Operation::Select(..) | Operation::SelectVariants(..), _)
                if self.reference_mode() =>
            {
                // In reference mode, a selection is interpreted as selecting a reference to the
                // field.
                let ty =
                    Type::Reference(self.reference_mode_kind, Box::new(self.get_node_type(*id)));
                let temp = self.new_temp(ty);
                self.generate(vec![temp], exp);
                temp
            },
            _ => {
                // Otherwise, introduce a temporary
                let id = exp.node_id();
                let ty = if let ExpData::LocalVar(id, sym) = exp.as_ref() {
                    // Use the local's fully-instantiated type when possible.
                    self.temp_type(self.find_local(*id, *sym)).to_owned()
                } else {
                    self.get_node_type(id)
                };
                let temp = self.new_temp(ty);
                self.generate(vec![temp], exp);
                temp
            },
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs (L1309-1343)
```rust
    fn rewrite_temporary(&mut self, id: NodeId, idx: TempIndex) -> Option<Exp> {
        let loc = self.env.get_node_loc(id);
        if idx < self.inlined_formal_params.len() {
            let param = &self.inlined_formal_params[idx];
            let sym = param.0;
            if self.lambda_param_map.contains_key(&sym) {
                // lambda parameter `sym` is used as a temp apart from a call
                // which is currently not supported
                let msg = format!("parameter `{}` with function type cannot be used as a local variable in an inline function",
                   sym.display(self.env.symbol_pool()));
                let call_details = vec![(loc.clone(), "being used here".to_string())];
                self.env
                    .diag_with_labels(Severity::Error, &param.2, &msg, call_details);
            }
            let param_type = &param.1;
            let instantiated_param_type = param_type.instantiate(self.type_args);
            let new_node_id = self.env.new_node(loc, instantiated_param_type);
            if let Some(new_sym) = self.shadow_stack.get_shadow_symbol(sym, false) {
                Some(ExpData::LocalVar(new_node_id, new_sym).into())
            } else {
                Some(ExpData::LocalVar(new_node_id, sym).into())
            }
        } else {
            self.env.diag(
                Severity::Bug,
                &loc,
                &format!(
                    "Temporary with invalid index `{}` during inlining \
                     of function with `{}` parameters",
                    idx,
                    self.inlined_formal_params.len()
                ),
            );
            None
        }
```

**File:** third_party/move/move-model/src/exp_rewriter.rs (L315-323)
```rust
            Temporary(id, idx) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if let Some(new_exp) = self.rewrite_temporary(new_id, *idx) {
                    new_exp
                } else if id_changed {
                    Temporary(new_id, *idx).into_exp()
                } else {
                    exp
                }
```
