# Audit Report

## Title
Indexer gRPC Service Crash via Panic in `standardize_address()` Due to Missing Input Validation

## Summary
The `standardize_address()` function in the transaction filter component does not validate input length or trim whitespace, allowing an attacker to crash the indexer gRPC service with a single malicious filter request containing an address with whitespace and length exceeding 64 characters after prefix removal.

## Finding Description

The `standardize_address()` function processes address strings to normalize them for comparison in transaction filters. [1](#0-0) 

The function attempts to remove the "0x" prefix, but if the prefix is not at the start (due to leading whitespace), the original string is used. [2](#0-1) 

When formatting non-special addresses, the function calculates the padding needed by subtracting the trimmed length from 64. [3](#0-2) 

**Attack Path:**

1. Attacker sends a gRPC transaction filter request via the indexer API
2. The filter contains `sender = " 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"` (leading space + 0x + 64 hex chars = 67 chars total)
3. When the filter is converted from protobuf, `standardize_address()` is called [4](#0-3) 
4. The function processes the malicious input:
   - `strip_prefix("0x")` returns `None` (no match due to leading space)
   - `trimmed = " 0xffff...ffff"` (67 chars)
   - The string is not a special address (has 'x' and space)
   - Line 33 executes: `&ZEROS[..64 - 67]`
5. In debug mode: Integer underflow panic
6. In release mode: Wraps to large number, then panics on out-of-bounds array access
7. The gRPC handler thread panics, crashing the service

The same issue occurs with trailing whitespace like `"0x1\n"`, which creates malformed standardized addresses that break filter matching even when not causing panics.

## Impact Explanation

This vulnerability allows **remote, unauthenticated Denial of Service** against the Aptos indexer gRPC service. The indexer is a critical infrastructure component that:

- Enables dApps to query blockchain state efficiently
- Provides real-time transaction filtering for wallets and applications
- Supports the broader Aptos ecosystem's data access layer

According to Aptos bug bounty severity categories, this qualifies as **High Severity** because it causes **"API crashes"**. A single malicious request can crash the indexer service, requiring manual restart and affecting all users depending on that indexer instance.

While not affecting consensus directly, indexer availability is essential for ecosystem functionality. Many applications depend on indexers for their core operations, making this a significant availability vulnerability.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity**: Trivial - requires only sending a gRPC request with a specially crafted address string
- **Authentication Required**: None - the indexer gRPC API accepts filter requests from any client
- **User Interaction**: None required
- **Exploit Reliability**: 100% - the panic occurs deterministically
- **Detection Difficulty**: Low - attackers can easily test against public indexer endpoints

The vulnerability is in production code with no input validation, making exploitation straightforward for any attacker with network access to an indexer gRPC endpoint.

## Recommendation

Add input validation to trim whitespace and validate address length before processing:

```rust
pub fn standardize_address(address: &str) -> String {
    // Trim whitespace from input
    let address = address.trim();
    
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate length to prevent panic
    if trimmed.len() > 64 {
        // Return error or truncate - for now, just use first 64 chars
        let trimmed = &trimmed[..64];
    }
    
    // ... rest of function unchanged
}
```

Alternatively, return `Result<String, AddressError>` to properly handle invalid inputs and propagate errors to the API layer for graceful rejection.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_standardize_address_panic_with_long_whitespace_address() {
    // This demonstrates the panic vulnerability
    let malicious_address = format!(" 0x{}", "f".repeat(64));
    let _ = standardize_address(&malicious_address);
    // Panics with "index out of bounds: the len is 64 but the index is <very large number>"
}

#[test]
fn test_standardize_address_whitespace_not_trimmed() {
    // This demonstrates the whitespace preservation bug
    let address_with_leading_space = " 0x1";
    let result = standardize_address(address_with_leading_space);
    
    // The result will be malformed with embedded whitespace
    // This will not match against properly formatted addresses
    assert_ne!(result, "0x1");
    
    let address_with_trailing_newline = "0x1\n";
    let result = standardize_address(address_with_trailing_newline);
    assert_ne!(result, "0x1");
}
```

**Notes:**

1. The panic occurs in both debug and release modes due to array bounds checking
2. Filter addresses are accepted via the protobuf `UserTransactionFilter.sender` field with no validation [5](#0-4) 
3. The only validation performed is filter size checking, not content validation [6](#0-5) 
4. Other parts of the codebase properly trim addresses, but this function does not [7](#0-6)

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-12)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L30-35)
```rust
    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L51-56)
```rust
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L33-35)
```text
message UserTransactionFilter {
  optional string sender = 1;
  optional UserTransactionPayloadFilter payload_filter = 2;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** third_party/move/move-core/types/src/account_address.rs (L369-380)
```rust
impl FromStr for AccountAddress {
    type Err = AccountAddressParseError;

    /// NOTE: This function has relaxed parsing behavior. For strict behavior, please use
    /// the `from_str_strict` function. Where possible use `from_str_strict` rather than
    /// this function.
    ///
    /// Create an instance of AccountAddress by parsing a hex string representation.
    ///
    /// This function allows all formats defined by AIP-40. In short this means the
    /// following formats are accepted:
    ///
```
