# Audit Report

## Title
World-Readable Consensus Key Files Due to Missing File Permission Enforcement in Configuration Persistence

## Summary
The `write_file()` function in `persistable_config.rs` and `write_yaml()` function in genesis builder use `File::create()` without setting restrictive file permissions, creating world-readable files (mode 0644) that expose consensus private keys to any local user on the validator system.

## Finding Description

The Aptos Core codebase contains multiple file writing functions that handle sensitive cryptographic material, specifically BLS12-381 consensus private keys used by validators to participate in the AptosBFT consensus protocol. These functions fail to set appropriate file permissions, resulting in world-readable files that expose consensus keys.

**Primary Vulnerable Code Paths:**

1. **PersistableConfig trait implementation** - The `write_file()` function uses `File::create()` without setting permissions [1](#0-0) 

2. **Genesis builder key persistence** - The `write_yaml()` function also uses `File::create()` without permissions when writing validator identity files containing consensus keys [2](#0-1) 

**Sensitive Data at Risk:**

The `SafetyRulesConfig` struct can contain `SafetyRulesTestConfig` with a `consensus_key` field holding BLS12-381 private keys [3](#0-2) 

More critically, the `IdentityBlob` struct written during validator setup contains `consensus_private_key` - the actual BLS12-381 private key used by validators [4](#0-3) 

**How the Vulnerability Manifests:**

During validator initialization, the genesis builder writes identity files to disk [5](#0-4) 

On Unix-like systems, `File::create()` creates files with default permissions determined by:
- Base mode: 0666 (rw-rw-rw-)
- Process umask (typically 022)
- **Result: 0644 (rw-r--r--) - world-readable**

**Security Guarantee Violation:**

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." When consensus private keys are exposed via world-readable files, any local user can:
- Read the validator's consensus private key
- Sign malicious blocks as that validator
- Create equivocating votes (signing conflicting blocks at the same height)
- Violate AptosBFT consensus safety guarantees

**Existing Secure Alternative:**

The codebase already has secure file writing functions that set mode 0o600 (user-only read/write):
- `write_to_user_only_file()` [6](#0-5) 
- `save_to_file_confidential()` [7](#0-6) 

However, these secure functions are **not used** for configuration persistence or identity file writing.

## Impact Explanation

**Severity: Critical**

This vulnerability qualifies as **Critical** under the Aptos Bug Bounty Program categories because it enables:

1. **Consensus Safety Violations**: An attacker with local system access who obtains a validator's consensus private key can sign blocks and votes, causing equivocation that violates BFT safety assumptions. Under AptosBFT, consensus safety requires that no two conflicting blocks are committed, which depends on honest validators never signing conflicting blocks. A compromised key breaks this guarantee.

2. **Validator Impersonation**: The attacker can fully impersonate the validator in consensus operations, potentially participating in Byzantine behavior that could lead to chain splits or double-spending if combined with other compromised validators (approaching the 1/3 Byzantine fault tolerance threshold).

3. **Network-Wide Impact**: If multiple validators are affected (e.g., validators running on shared or poorly secured infrastructure), the cumulative effect could approach or exceed the 1/3 Byzantine threshold, leading to consensus failures requiring manual intervention or even a hard fork.

The impact aligns with Critical severity criteria: "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)" if widespread exploitation occurs.

## Likelihood Explanation

**Likelihood: High**

The vulnerability has high exploitability because:

1. **Attack Prerequisites Are Common**:
   - Attacker needs local user access on the validator machine
   - Many validators run on cloud infrastructure, shared servers, or systems with multiple administrative accounts
   - Container escapes, privilege escalation from other services, or compromised monitoring tools provide local access

2. **Automatic Exposure During Setup**:
   - Every validator initialization automatically creates world-readable identity files
   - No manual misconfiguration required - this is the default behavior
   - Operators may not notice the insecure permissions since the validator appears to function normally

3. **Long Exposure Window**:
   - Files remain world-readable indefinitely until manually corrected
   - Old backup copies or log files may retain copies with insecure permissions
   - Keys are typically rotated infrequently, extending the exploitation window

4. **Detection Difficulty**:
   - File permission issues don't generate alerts or logs
   - Standard monitoring doesn't check file permissions on configuration files
   - Key compromise may not be detected until malicious consensus messages are observed

## Recommendation

**Immediate Fix:**

Modify `write_file()` in `persistable_config.rs` to use `OpenOptions` with mode 0o600 on Unix systems:

```rust
fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
    #[cfg(unix)]
    use std::os::unix::fs::OpenOptionsExt;
    
    let mut opts = std::fs::OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    let mut file = opts.open(output_file.as_ref())
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    file.write_all(&serialized_config)
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

    Ok(())
}
```

Similarly, modify `write_yaml()` in `builder.rs`:

```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    #[cfg(unix)]
    use std::os::unix::fs::OpenOptionsExt;
    
    let mut opts = std::fs::OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    opts.open(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**Additional Remediation Steps:**

1. Add a startup check that validates file permissions on all identity and configuration files
2. Document secure file permission requirements in validator setup guides
3. Provide a utility script to audit and fix permissions on existing deployments
4. Consider encrypting identity files at rest as defense-in-depth

## Proof of Concept

**Reproduction Steps (Rust):**

```rust
// File: permission_test.rs
use std::fs::{File, OpenOptions};
use std::io::Write;
use std::os::unix::fs::PermissionsExt;

fn main() {
    // Simulate current vulnerable behavior
    let test_file = "/tmp/test_validator_identity.yaml";
    
    // Write using File::create (vulnerable)
    let mut file = File::create(test_file).unwrap();
    file.write_all(b"consensus_private_key: <sensitive_key_data>").unwrap();
    
    // Check permissions
    let metadata = std::fs::metadata(test_file).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    println!("File created with permissions: {:o}", mode & 0o777);
    // Expected output: "File created with permissions: 644"
    
    assert_eq!(mode & 0o777, 0o644, "File is world-readable!");
    
    // Demonstrate exploit: any user can read
    let contents = std::fs::read_to_string(test_file).unwrap();
    println!("Any user can read: {}", contents);
    
    // Clean up
    std::fs::remove_file(test_file).unwrap();
    
    // Now demonstrate secure approach
    let secure_file = "/tmp/test_validator_identity_secure.yaml";
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    opts.mode(0o600);
    
    let mut secure = opts.open(secure_file).unwrap();
    secure.write_all(b"consensus_private_key: <sensitive_key_data>").unwrap();
    
    let secure_metadata = std::fs::metadata(secure_file).unwrap();
    let secure_mode = secure_metadata.permissions().mode();
    
    println!("Secure file created with permissions: {:o}", secure_mode & 0o777);
    // Expected output: "Secure file created with permissions: 600"
    
    assert_eq!(secure_mode & 0o777, 0o600, "File should be user-only!");
    
    std::fs::remove_file(secure_file).unwrap();
}
```

**Exploitation Scenario:**

1. Validator operator initializes a new validator node using genesis builder
2. Identity files are written to `/opt/aptos/validator-identity.yaml` with mode 0644
3. Attacker gains local access (e.g., via compromised monitoring agent running as different user)
4. Attacker executes: `cat /opt/aptos/validator-identity.yaml`
5. Attacker extracts `consensus_private_key` field containing BLS12-381 private key
6. Attacker can now sign malicious consensus messages as this validator
7. If attacker compromises multiple validators, they can violate consensus safety

**Notes**

This vulnerability affects all validators using the standard genesis builder and configuration management. The issue is platform-specific to Unix-like systems (Linux, macOS) where file permissions are enforced. Windows systems have different permission models and may not exhibit the same vulnerability, though Windows-based validators are uncommon in production Aptos deployments.

The vulnerability is particularly concerning because secure file writing functions already exist in the codebase but are not consistently applied to all sensitive file operations. This suggests a systemic issue in code review processes for identifying security-sensitive file operations.

### Citations

**File:** config/src/config/persistable_config.rs (L43-50)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
    }
```

**File:** crates/aptos-genesis/src/builder.rs (L145-148)
```rust
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** config/src/config/safety_rules_config.rs (L242-245)
```rust
pub struct SafetyRulesTestConfig {
    pub author: PeerId,
    pub consensus_key: Option<ConfigKey<bls12381::PrivateKey>>,
    pub waypoint: Option<Waypoint>,
```

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```
