# Audit Report

## Title
Race Condition in Pipeline Abort During State Sync Causes Validator Node Crashes

## Summary
The `abort_pipeline_for_state_sync()` function contains a Time-of-Check-Time-of-Use (TOCTOU) race condition that allows new blocks to be inserted with active pipelines after the abort snapshot is taken. When these missed pipelines attempt to commit during state sync, the storage layer detects concurrent committing and panics, crashing the validator node.

## Finding Description

The vulnerability exists in the pipeline abortion mechanism used during state synchronization. The function takes a snapshot of all blocks, then aborts their pipelines. However, between taking the snapshot and completing the abort process, consensus can insert new blocks with active pipelines that are never aborted. [1](#0-0) 

The race occurs because:

1. **Snapshot taken with temporary lock**: The function acquires a READ lock to get all blocks, which is immediately released after the snapshot is taken.

2. **No lock held during abort**: During the iteration and waiting phases, no lock prevents concurrent block insertion.

3. **Concurrent block insertion**: The `insert_block_inner()` function can be called by consensus threads to insert new blocks with pipelines. [2](#0-1) 

4. **State sync proceeds with active pipelines**: The state sync process continues while missed pipelines remain active. [3](#0-2) 

5. **Crash on concurrent commit detection**: When the missed pipeline attempts to commit while state sync is also committing, the storage layer detects this and panics. [4](#0-3) 

**Attack Scenario Timeline:**
- T0: State sync triggered by receiving far-ahead LedgerInfo
- T1: `abort_pipeline_for_state_sync()` called, snapshot = [B1, B2, B3]
- T2: READ lock released
- T3: Consensus inserts block B4 via `insert_block_inner()`
- T4: Pipeline built for B4 with abort handles set
- T5: State sync aborts only [B1, B2, B3] pipelines
- T6: State sync calls `sync_to_target()`
- T7: B4's pipeline attempts to commit
- T8: **Storage panics**: "Concurrent committing detected"
- T9: **Validator node crashes**

## Impact Explanation

This vulnerability has **High Severity** impact according to Aptos bug bounty criteria:

1. **Validator Node Crashes**: Affected nodes panic and become unavailable, falling under "API crashes" and "Validator node slowdowns" categories.

2. **Network Liveness Degradation**: If multiple validators experience this race condition simultaneously (which is likely during network-wide state sync events), it can significantly impact network availability and consensus.

3. **Non-Deterministic Failures**: The crash is timing-dependent, making it difficult to diagnose and potentially allowing it to repeatedly affect nodes during critical network synchronization periods.

4. **State Consistency Violation**: Breaks the invariant that state transitions must be atomic and properly synchronized between consensus and state sync components.

## Likelihood Explanation

**High Likelihood** - This race condition can occur naturally without malicious intent:

1. **Common Trigger**: State sync is triggered whenever a node falls behind, which happens regularly in production networks due to network partitions, node restarts, or catching up after maintenance.

2. **Wide Race Window**: The window between taking the snapshot and completing all aborts can be substantial if many blocks need aborting, increasing collision probability.

3. **Concurrent Consensus Activity**: Consensus continues operating during state sync preparation, meaning block insertion is actively occurring during the vulnerable window.

4. **No Synchronization**: There is no mechanism to pause block insertion during pipeline abortion, making the race inevitable under high load conditions.

## Recommendation

The function must hold a write lock for the entire duration of pipeline abortion to prevent concurrent block insertions:

```rust
pub async fn abort_pipeline_for_state_sync(&self) {
    // Take write lock to prevent concurrent block insertions
    let mut inner = self.inner.write();
    let blocks = inner.get_all_blocks();
    drop(inner); // Release write lock before async operations
    
    // Abort pipelines for snapshot
    let futs: Vec<_> = blocks
        .into_iter()
        .filter_map(|b| b.abort_pipeline())
        .collect();
    
    for f in futs {
        f.wait_until_finishes().await;
    }
    
    // After all aborts complete, verify no new blocks were inserted
    let inner = self.inner.write();
    let new_blocks = inner.get_all_blocks();
    let new_block_ids: HashSet<_> = new_blocks.iter().map(|b| b.id()).collect();
    let old_block_ids: HashSet<_> = blocks.iter().map(|b| b.id()).collect();
    
    // Abort any newly inserted blocks
    let additional_blocks: Vec<_> = new_blocks
        .into_iter()
        .filter(|b| !old_block_ids.contains(&b.id()))
        .collect();
    
    drop(inner);
    
    if !additional_blocks.is_empty() {
        let additional_futs: Vec<_> = additional_blocks
            .into_iter()
            .filter_map(|b| b.abort_pipeline())
            .collect();
        
        for f in additional_futs {
            f.wait_until_finishes().await;
        }
    }
}
```

Alternatively, implement a proper state sync lock that prevents block insertion:

```rust
// Add to BlockStore struct
state_sync_in_progress: Arc<AtomicBool>,

// In abort_pipeline_for_state_sync()
self.state_sync_in_progress.store(true, Ordering::SeqCst);
// ... perform abort ...
self.state_sync_in_progress.store(false, Ordering::SeqCst);

// In insert_block_inner(), check before insertion:
if self.state_sync_in_progress.load(Ordering::SeqCst) {
    bail!("Cannot insert block during state sync");
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_pipeline_abort_race_condition() {
    // Setup: Create block store with pipeline builder
    let (block_store, mut block_sender) = setup_test_block_store().await;
    
    // Start state sync in background
    let block_store_clone = block_store.clone();
    let state_sync_handle = tokio::spawn(async move {
        // Simulate state sync trigger
        let target_li = create_far_ahead_ledger_info();
        block_store_clone.fast_forward_sync(target_li).await
    });
    
    // Introduce small delay to let abort start
    tokio::time::sleep(Duration::from_millis(10)).await;
    
    // Concurrently insert new block during abort process
    let new_block = create_test_block_with_pipeline();
    let insert_result = block_store.insert_block(new_block).await;
    
    // Expected: State sync should either:
    // 1. Successfully abort all pipelines (including new block)
    // 2. Or fail gracefully without crashing
    
    // Actual: This will panic with "Concurrent committing detected"
    // when the new block's pipeline tries to commit during state sync
    
    match state_sync_handle.await {
        Ok(_) => panic!("Expected panic due to concurrent commit"),
        Err(e) if e.is_panic() => {
            let panic_msg = e.into_panic();
            assert!(format!("{:?}", panic_msg).contains("Concurrent committing detected"));
        }
        Err(e) => panic!("Unexpected error: {:?}", e),
    }
}
```

**Notes**

This is a critical synchronization bug in the consensus layer that violates the invariant that all execution pipelines must be properly quiesced before state synchronization begins. The vulnerability is particularly dangerous because it can manifest during normal network operations without requiring any malicious activity, and the resulting crashes can cascade across multiple validators during network-wide synchronization events, potentially causing significant liveness degradation.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L463-497)
```rust
        // build pipeline
        if let Some(pipeline_builder) = &self.pipeline_builder {
            let parent_block = self
                .get_block(pipelined_block.parent_id())
                .ok_or_else(|| anyhow::anyhow!("Parent block not found"))?;

            // need weak pointer to break the cycle between block tree -> pipeline block -> callback
            let block_tree = Arc::downgrade(&self.inner);
            let storage = self.storage.clone();
            let id = pipelined_block.id();
            let round = pipelined_block.round();
            let window_size = self.window_size;
            let callback = Box::new(
                move |finality_proof: WrappedLedgerInfo,
                      commit_decision: LedgerInfoWithSignatures| {
                    if let Some(tree) = block_tree.upgrade() {
                        tree.write().commit_callback(
                            storage,
                            id,
                            round,
                            finality_proof,
                            commit_decision,
                            window_size,
                        );
                    }
                },
            );
            pipeline_builder.build_for_consensus(
                &pipelined_block,
                parent_block.pipeline_futs().ok_or_else(|| {
                    anyhow::anyhow!("Parent future doesn't exist, potentially epoch ended")
                })?,
                callback,
            );
        }
```

**File:** consensus/src/block_storage/block_store.rs (L617-627)
```rust
    pub async fn abort_pipeline_for_state_sync(&self) {
        let blocks = self.inner.read().get_all_blocks();
        // the blocks are not ordered by round here, so we need to abort all then wait
        let futs: Vec<_> = blocks
            .into_iter()
            .filter_map(|b| b.abort_pipeline())
            .collect();
        for f in futs {
            f.wait_until_finishes().await;
        }
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L503-514)
```rust
        storage.save_tree(blocks.clone(), quorum_certs.clone())?;
        // abort any pending executor tasks before entering state sync
        // with zaptos, things can run before hitting buffer manager
        if let Some(block_store) = maybe_block_store {
            monitor!(
                "abort_pipeline_for_state_sync",
                block_store.abort_pipeline_for_state_sync().await
            );
        }
        execution_client
            .sync_to_target(highest_commit_cert.ledger_info().clone())
            .await?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L50-53)
```rust
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```
