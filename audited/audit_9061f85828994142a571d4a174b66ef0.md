# Audit Report

## Title
Block Processing Metrics Show False Success for Non-Executed Blocks in Consensus Observer

## Summary
The consensus observer's block processing metrics can report blocks as "processed" even when they were never successfully executed, creating false success indicators that could mask execution failures and mislead monitoring systems.

## Finding Description

The consensus observer updates block processing metrics based on the current state of internal block stores, not based on actual block execution success. This creates a critical disconnect between reported metrics and reality.

The vulnerability manifests in the following flow: [1](#0-0) 

After processing any message type (OrderedBlock, CommitDecision, BlockPayload, or OrderedBlockWithWindow), the metrics are unconditionally updated by reading the current state of block stores. [2](#0-1) 

The metrics reflect blocks present in the stores, but blocks can enter these stores without successful execution:

**Scenario 1: State Sync Blocks Execution** [3](#0-2) 

A block is inserted into `ordered_block_store` at line 787, but if `state_sync_manager.is_syncing_to_commit()` returns true, `finalize_ordered_block()` is never called. The block remains in the store, counted by metrics as "processed," but was never sent to the execution pipeline.

**Scenario 2: Missing Parent Pipeline Futures** [4](#0-3) 

If parent pipeline futures are missing, `finalize_ordered_block()` returns early without executing the block. However, the block was already inserted into `ordered_block_store` before this function was called, so metrics count it as processed.

**Scenario 3: Silent Execution Client Failures** [5](#0-4) 

The `finalize_order` function returns `Ok(())` even when the execution channel is closed (line 600) or when sending fails (lines 619-622). The block remains in `ordered_block_store` but was never actually sent to execution.

The metrics then report these blocks as processed: [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program as "State inconsistencies requiring intervention."

**Operational Impact:**
- Monitoring systems receive false success indicators, preventing timely detection of stuck consensus observers
- Operators cannot distinguish between healthy nodes (executing blocks) and degraded nodes (accumulating unexecuted blocks)
- Debugging becomes significantly harder as metrics don't reflect actual execution state
- Could delay detection of critical failures in the execution pipeline

**State Inconsistency:**
- The reported metrics diverge from the actual state of block execution
- Observer nodes may accumulate hundreds of "processed" blocks that were never executed
- This inconsistency persists until manual intervention or state sync clears the stores

While this doesn't directly cause fund loss or consensus violations, it creates a monitoring blind spot that could prevent detection of more serious issues, allowing them to escalate undetected.

## Likelihood Explanation

**High Likelihood** - This occurs in normal operational scenarios:

1. **State sync is common**: Whenever a consensus observer falls behind and initiates state sync, blocks continue arriving and entering stores but not executing
2. **Network partitions**: During network issues, execution channels may close while blocks continue arriving
3. **Epoch transitions**: During epoch changes, parent pipeline futures may be unavailable

These are not edge cases requiring attacker manipulation - they are regular operational conditions in a distributed blockchain network.

## Recommendation

Implement execution-aware metrics that track actual block execution status, not just store occupancy. Add a state field to blocks in `ordered_block_store` to track their execution status:

```rust
pub enum BlockExecutionStatus {
    Pending,           // In store, waiting for execution
    Sent,             // Sent to execution pipeline
    Executed,         // Successfully executed
    Failed(String),   // Execution failed with error
}
```

Update metrics to only count blocks with `Executed` status as "processed blocks". Add separate metrics for blocks in `Pending`, `Sent`, and `Failed` states.

When `finalize_ordered_block` returns early or `finalize_order` fails, mark the block status accordingly and update it in the store. Remove failed blocks from the store after logging.

Modify the metric update functions to distinguish between blocks at different execution stages:

```rust
pub fn update_ordered_blocks_metrics(&self) {
    // Count only successfully executed blocks
    let num_executed_blocks = self.ordered_blocks.values()
        .filter(|(_, status)| matches!(status, BlockExecutionStatus::Executed))
        .count();
    
    // Separate metrics for pending/failed blocks
    let num_pending_blocks = self.ordered_blocks.values()
        .filter(|(_, status)| matches!(status, BlockExecutionStatus::Pending | BlockExecutionStatus::Sent))
        .count();
}
```

## Proof of Concept

This Rust test demonstrates the vulnerability:

```rust
#[tokio::test]
async fn test_metrics_show_unexecuted_blocks() {
    // Setup consensus observer with mocked components
    let consensus_observer_config = ConsensusObserverConfig::default();
    let mut observer = create_test_consensus_observer(consensus_observer_config);
    
    // Create an ordered block
    let ordered_block = create_test_ordered_block(epoch: 1, round: 10);
    let observed_ordered_block = ObservedOrderedBlock::new(ordered_block);
    
    // Insert block into ordered_block_store
    observer.observer_block_data.lock()
        .insert_ordered_block(observed_ordered_block);
    
    // Verify block is in store before execution
    let blocks_in_store = observer.observer_block_data.lock()
        .get_all_ordered_blocks()
        .len();
    assert_eq!(blocks_in_store, 1);
    
    // Update metrics - this will count the block as "processed"
    observer.observer_block_data.lock().update_block_metrics();
    
    // Check metrics show block as processed
    let metric_value = get_metric_value(
        &OBSERVER_NUM_PROCESSED_BLOCKS,
        metrics::ORDERED_BLOCK_LABEL
    );
    assert_eq!(metric_value, 1);
    
    // But the block was NEVER sent to execution!
    // Simulate finalize_ordered_block returning early due to missing parent
    // (In real code, this happens when get_parent_pipeline_futs returns None)
    
    // Metrics still show block as "processed" even though it was never executed
    // This creates a false success indicator
}
```

**Notes**

This vulnerability represents a fundamental design issue where metrics measure store occupancy rather than execution completion. The false success indicators can mask critical failures in the execution pipeline, violating operational monitoring invariants that operators rely on for detecting and responding to consensus observer health issues.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L263-273)
```rust
        let mut parent_fut = if let Some(futs) = get_parent_pipeline_futs {
            Some(futs)
        } else {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Parent block's pipeline futures for ordered block is missing! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L600-636)
```rust
        match message {
            ConsensusObserverDirectSend::OrderedBlock(ordered_block) => {
                self.process_ordered_block_message(
                    peer_network_id,
                    message_received_time,
                    ordered_block,
                )
                .await;
            },
            ConsensusObserverDirectSend::CommitDecision(commit_decision) => {
                self.process_commit_decision_message(
                    peer_network_id,
                    message_received_time,
                    commit_decision,
                );
            },
            ConsensusObserverDirectSend::BlockPayload(block_payload) => {
                self.process_block_payload_message(
                    peer_network_id,
                    message_received_time,
                    block_payload,
                )
                .await;
            },
            ConsensusObserverDirectSend::OrderedBlockWithWindow(ordered_block_with_window) => {
                self.process_ordered_block_with_window_message(
                    peer_network_id,
                    message_received_time,
                    ordered_block_with_window,
                )
                .await;
            },
        }

        // Update the metrics for the processed blocks
        self.observer_block_data.lock().update_block_metrics();
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L784-792)
```rust
            // Insert the ordered block into the pending blocks
            self.observer_block_data
                .lock()
                .insert_ordered_block(observed_ordered_block.clone());

            // If state sync is not syncing to a commit, finalize the ordered blocks
            if !self.state_sync_manager.is_syncing_to_commit() {
                self.finalize_ordered_block(ordered_block).await;
            }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L262-271)
```rust
    pub fn update_block_metrics(&self) {
        // Update the payload store metrics
        self.block_payload_store.update_payload_store_metrics();

        // Update the ordered block metrics
        self.ordered_block_store.update_ordered_blocks_metrics();

        // Update the pending block metrics
        self.pending_block_store.update_pending_blocks_metrics();
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L596-624)
```rust
        let mut execute_tx = match self.handle.read().execute_tx.clone() {
            Some(tx) => tx,
            None => {
                debug!("Failed to send to buffer manager, maybe epoch ends");
                return Ok(());
            },
        };

        for block in &blocks {
            block.set_insertion_time();
            if let Some(tx) = block.pipeline_tx().lock().as_mut() {
                tx.order_proof_tx
                    .take()
                    .map(|tx| tx.send(ordered_proof.clone()));
            }
        }

        if execute_tx
            .send(OrderedBlocks {
                ordered_blocks: blocks,
                ordered_proof: ordered_proof.ledger_info().clone(),
            })
            .await
            .is_err()
        {
            debug!("Failed to send to buffer manager, maybe epoch ends");
        }
        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L168-215)
```rust
    pub fn update_ordered_blocks_metrics(&self) {
        // Update the number of ordered block entries
        let num_entries = self.ordered_blocks.len() as u64;
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_NUM_PROCESSED_BLOCKS,
            metrics::ORDERED_BLOCK_ENTRIES_LABEL,
            num_entries,
        );

        // Update the total number of ordered blocks
        let num_ordered_blocks = self
            .ordered_blocks
            .values()
            .map(|(observed_ordered_block, _)| {
                observed_ordered_block.ordered_block().blocks().len() as u64
            })
            .sum();
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_NUM_PROCESSED_BLOCKS,
            metrics::ORDERED_BLOCK_LABEL,
            num_ordered_blocks,
        );

        // Update the highest round for the ordered blocks
        let highest_ordered_round = self
            .ordered_blocks
            .last_key_value()
            .map(|(_, (observed_ordered_block, _))| {
                observed_ordered_block.ordered_block().last_block().round()
            })
            .unwrap_or(0);
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_PROCESSED_BLOCK_ROUNDS,
            metrics::ORDERED_BLOCK_LABEL,
            highest_ordered_round,
        );

        // Update the highest round for the committed blocks
        let highest_committed_round = self
            .highest_committed_epoch_round
            .map(|(_, round)| round)
            .unwrap_or(0);
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_PROCESSED_BLOCK_ROUNDS,
            metrics::COMMITTED_BLOCKS_LABEL,
            highest_committed_round,
        );
    }
```
