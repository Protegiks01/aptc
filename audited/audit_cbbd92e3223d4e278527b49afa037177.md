# Audit Report

## Title
State Divergence via Inconsistent Transaction Filter Configurations Across Validators in Decoupled Execution Mode

## Summary
The Aptos consensus protocol allows validators to independently configure `execution_filter` settings without any protocol-level validation or consistency checks. In the current decoupled execution mode (where `decoupled_execution()` always returns `true`), validators vote on transaction ordering without including execution results in their votes. This architectural design allows validators with different `execution_filter` configurations to execute different transaction sets from the same ordered block, causing state divergence and breaking the fundamental deterministic execution invariant of blockchain consensus.

## Finding Description

The vulnerability stems from three critical design elements that interact to enable state divergence:

**1. Separate Filter Configurations Without Validation**

The system maintains two independent transaction filter configurations: [1](#0-0) 

These filters serve different purposes but have no validation ensuring consistency across validators or even within a single validator's configuration.

**2. Limited Scope of Consensus Filter**

During proposal validation, the `consensus_filter` only checks inline transactions: [2](#0-1) 

Transactions in proof-based batches bypass this consensus-time validation entirely.

**3. Execution Filter Applied During Block Execution**

When executing blocks, all transactions (both inline and proof-based) are filtered using the `execution_filter`: [3](#0-2) 

The actual filtering logic: [4](#0-3) 

**4. Decoupled Execution Always Enabled**

The protocol enforces decoupled execution mode: [5](#0-4) 

In this mode, validators vote with dummy state roots rather than actual execution results: [6](#0-5) 

**Attack Scenario:**

While this vulnerability requires validator misconfiguration (making it an operational/protocol design issue rather than directly exploitable by external attackers), it represents a critical consensus safety violation:

1. Validator A configures: `execution_filter` to deny transactions from address 0xMALICIOUS
2. Validator B maintains default: `execution_filter` disabled (allows all)
3. Transaction T from 0xMALICIOUS gets included in a proof-based batch
4. Both validators vote for the proposal (T bypasses `consensus_filter` checks, and votes use dummy state roots)
5. During execution:
   - Validator A's execution filter removes T → computes state root R_A
   - Validator B's execution filter allows T → computes state root R_B
   - R_A ≠ R_B → **State Divergence**

## Impact Explanation

**Severity: Critical (Consensus Safety Violation)**

This breaks the most fundamental blockchain invariant: **Deterministic Execution**. All validators must produce identical state roots for identical blocks.

The impact includes:
- **Consensus Safety Violation**: Different validators compute different state roots from the same ordered transactions
- **Chain Fork Risk**: Validators may form incompatible chains based on divergent states
- **Liveness Failure**: If sufficient validators have inconsistent states, quorum formation becomes impossible
- **Non-recoverable Without Hard Fork**: Once state divergence occurs, manual intervention or hard fork required

This qualifies as **Critical Severity** under Aptos Bug Bounty criteria: "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium to High in Production**

While exploitation requires validator configuration differences (not direct attacker control), the likelihood is elevated due to:

1. **No Protocol Enforcement**: Zero validation that execution filters are consistent across validators
2. **Operational Complexity**: Large validator sets increase probability of configuration drift
3. **Silent Failure Mode**: Divergence may not be immediately detected until quorum formation fails
4. **Legitimate Use Case Confusion**: Operators may intentionally configure different filters thinking it's a local policy decision without understanding consensus implications
5. **No Default Safety**: The default configuration has filters disabled, but enabling them is a documented feature that operators might use

The vulnerability is inherent to the protocol design - the architecture *allows* this divergence rather than preventing it.

## Recommendation

**Immediate Mitigations:**

1. **Add Configuration Validation**: Implement a startup check that warns or errors if `consensus_filter` and `execution_filter` differ:

```rust
// In TransactionFiltersConfig
impl TransactionFiltersConfig {
    pub fn validate_consistency(&self) -> Result<(), String> {
        if self.consensus_filter != self.execution_filter {
            return Err(
                "consensus_filter and execution_filter must be identical to prevent state divergence. \
                 Current implementation does not support different filter configurations."
                    .to_string(),
            );
        }
        Ok(())
    }
}
```

2. **Protocol-Level Solution**: Since filters are node-local configuration, implement one of:
   - **Option A (Recommended)**: Include execution results in votes even in decoupled mode for blocks with enabled filters, forcing consensus on execution outcomes
   - **Option B**: Move to on-chain filter governance where filter rules are consensus parameters, ensuring all validators use identical rules
   - **Option C**: Document and enforce that transaction filters must never be enabled in production, marking them as testing-only features

3. **Runtime Detection**: Add state root cross-validation between validators post-execution to detect divergence before it causes consensus failure

**Long-term Solution:**

Redesign the transaction filtering mechanism to be part of the consensus protocol rather than node-local configuration, ensuring Byzantine fault tolerance properties are maintained.

## Proof of Concept

**Setup (requires validator node access):**

```rust
// validator_a/config.yaml
transaction_filters:
  execution_filter:
    filter_enabled: true
    block_transaction_filter:
      block_transaction_rules:
        - Deny:
          - Transaction:
              Sender: "0xMALICIOUS_ADDRESS"

// validator_b/config.yaml  
transaction_filters:
  execution_filter:
    filter_enabled: false  // Default
```

**Exploitation Steps:**

1. Submit transaction from `0xMALICIOUS_ADDRESS` to mempool
2. Transaction gets included in quorum store batch (proof-based, not inline)
3. Proposer creates block containing the batch
4. Both validators vote (transaction bypasses consensus_filter check since it's not inline)
5. Block achieves quorum and gets certified
6. During execution pipeline:
   - Validator A: `BlockPreparer::prepare_block()` filters out the transaction
   - Validator B: `BlockPreparer::prepare_block()` includes the transaction
7. Validators compute different state roots
8. Next block proposal contains mismatched parent state → consensus failure

**Expected Result:** Network halts or forks due to state inconsistency between validators.

---

**Notes:**

This vulnerability represents a fundamental architectural issue where node-local configuration can break consensus-critical determinism guarantees. While not directly exploitable by external attackers without validator access, it violates the protocol's safety properties and could occur through operational error, intentional malicious configuration by compromised validators, or misunderstanding of the filter mechanism's consensus implications.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L13-17)
```rust
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L93-113)
```rust
    pub fn filter_block_transactions(
        &self,
        block_id: HashValue,
        block_author: Option<AccountAddress>,
        block_epoch: u64,
        block_timestamp_usecs: u64,
        transactions: Vec<SignedTransaction>,
    ) -> Vec<SignedTransaction> {
        transactions
            .into_iter()
            .filter(|txn| {
                self.allows_transaction(
                    block_id,
                    block_author,
                    block_epoch,
                    block_timestamp_usecs,
                    txn,
                )
            })
            .collect()
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L238-241)
```rust
    /// Decouple execution from consensus or not.
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L88-100)
```rust
    pub fn gen_vote_data(&self) -> anyhow::Result<VoteData> {
        if self.decoupled_execution {
            Ok(self.vote_data_ordering_only())
        } else {
            let proposed_block = self.block();
            let new_tree = self.accumulator_extension_proof().verify(
                proposed_block
                    .quorum_cert()
                    .certified_block()
                    .executed_state_id(),
            )?;
            Ok(self.vote_data_with_extension_proof(&new_tree))
        }
```
