# Audit Report

## Title
Stale Epoch Tracking After Block Store Clearing Due to Missing `highest_committed_epoch_round` Reset

## Summary
The `clear_all_ordered_blocks()` function fails to reset the `highest_committed_epoch_round` field, causing `get_highest_committed_epoch_round()` to return stale epoch data after epoch transitions or state resets. This creates a window where the observer tracks an incorrect epoch, though due to tuple comparison semantics, critical commit decisions are not incorrectly dropped.

## Finding Description
During epoch transitions or fallback synchronization, the consensus observer calls `clear_all_ordered_blocks()` to reset its block tracking state. However, this function only clears the `ordered_blocks` map and fails to reset the `highest_committed_epoch_round` field. [1](#0-0) 

The problematic sequence occurs during fallback sync completion:

1. Observer is at epoch 10 with `highest_committed_epoch_round = Some((10, 80))`
2. Fallback sync completes to epoch 11, round 0
3. Root is updated to (11, 0): [2](#0-1) 
4. Then `clear_pending_block_state()` is called which invokes `clear_block_data()`: [3](#0-2) 
5. This calls `clear_all_ordered_blocks()` which clears blocks but NOT `highest_committed_epoch_round`
6. Now: Root = (11, 0), but `highest_committed_epoch_round` = (10, 80) [STALE]

When `get_highest_committed_epoch_round()` is subsequently called, it returns the stale epoch 10 value instead of falling back to the current epoch 11 root: [4](#0-3) 

This function is used to check if incoming commit decisions should be ignored: [5](#0-4) 

**Mitigating Factor:** Due to Rust tuple comparison semantics (which compare epoch first), commit decisions from the new epoch (11, X) will always be greater than stale values from the old epoch (10, Y), preventing incorrect rejection of valid commits from new epochs.

## Impact Explanation
This qualifies as **Medium severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention."

The stale epoch tracking creates incorrect internal state that persists until corrected by subsequent commit processing. While the consensus observer is not a consensus-critical component (it doesn't participate in voting), incorrect epoch tracking could cause:

1. Misleading metrics and monitoring data
2. Incorrect state tracking during epoch boundaries
3. Potential confusion in debugging scenarios
4. Future bugs if logic changes rely on accurate epoch tracking

The impact is limited because:
- No consensus safety violation occurs (observers don't vote)
- No funds are at risk
- Commit decisions from new epochs aren't incorrectly rejected
- The bug self-corrects when new commits arrive

## Likelihood Explanation
**Likelihood: High** - This bug triggers automatically during every epoch transition that involves fallback synchronization or block state clearing. The sequence is deterministic and requires no attacker interaction.

## Recommendation
Clear the `highest_committed_epoch_round` field when clearing ordered blocks:

```rust
pub fn clear_all_ordered_blocks(&mut self) {
    self.ordered_blocks.clear();
    self.highest_committed_epoch_round = None;  // Reset to None
}
```

This ensures that after clearing, `get_highest_committed_epoch_round()` will correctly fall back to the root epoch rather than returning stale data.

## Proof of Concept

```rust
#[test]
fn test_clear_blocks_resets_highest_committed() {
    use aptos_config::config::ConsensusObserverConfig;
    
    // Create ordered block store at epoch 10
    let mut store = OrderedBlockStore::new(ConsensusObserverConfig::default());
    
    // Simulate commit at epoch 10, round 80
    let commit_info = create_ledger_info(10, 80);
    let commit_decision = CommitDecision::new(commit_info);
    store.update_commit_decision(&commit_decision);
    
    // Verify highest committed is set
    assert_eq!(store.get_highest_committed_epoch_round(), Some((10, 80)));
    
    // Clear all blocks (simulating epoch transition)
    store.clear_all_ordered_blocks();
    
    // BUG: highest_committed_epoch_round should be None but is still Some((10, 80))
    assert_eq!(store.get_highest_committed_epoch_round(), Some((10, 80))); // FAILS - still stale!
    // Expected: None
}
```

**Notes:**
- This is a real data integrity bug that affects epoch tracking accuracy
- The security impact is mitigated by tuple comparison preventing incorrect commit rejections
- The bug affects observer state consistency rather than consensus safety
- Automatic occurrence during epoch transitions makes it deterministic but non-exploitable by external attackers

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L41-43)
```rust
    pub fn clear_all_ordered_blocks(&mut self) {
        self.ordered_blocks.clear();
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L453-460)
```rust
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L947-950)
```rust
        // Update the root with the latest synced ledger info
        self.observer_block_data
            .lock()
            .update_root(latest_synced_ledger_info);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L960-961)
```rust
        // Reset the pending block state
        self.clear_pending_block_state().await;
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L132-141)
```rust
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```
