# Audit Report

## Title
Faucet Bypass Mechanism Partially Enforces Funder-Level Restrictions Despite Checker Bypass

## Summary
When `request_can_bypass()` returns true, the faucet properly bypasses all Checkers (including rate limiters, captcha validators, and IP blocklists). However, Funder implementations contain internal business logic restrictions that are NOT bypassed, causing inconsistent behavior where bypassed requests can still be rejected.

## Finding Description

The BypasserTrait interface documents that when `request_can_bypass()` returns true, requests should "bypass all checkers and storage." [1](#0-0) 

The bypass mechanism correctly skips all Checkers when any bypasser returns true: [2](#0-1) 

The system also correctly skips calling `checker.complete()` for bypassed requests: [3](#0-2) 

However, the Funder implementations enforce their own internal restrictions regardless of the `bypass` flag:

**TransferFunder** rejects requests if the receiver account already exists, even when `did_bypass_checkers` is true: [4](#0-3) 

**MintFunder** rejects requests if the receiver account exists AND the amount is zero, even when bypassed: [5](#0-4) 

Additionally, **TransferFunder** completely ignores the `did_bypass_checkers` parameter in its amount calculation: [6](#0-5) 

This creates a split-brain behavior where:
1. All Checkers are bypassed (rate limits, captcha, IP blocks) ✓
2. Storage operations are bypassed ✓  
3. But Funder-level business logic restrictions are still enforced ✗

## Impact Explanation

This issue represents a **Medium severity** operational inconsistency. While the faucet is not a consensus-critical component, this bug creates confusion about bypass semantics and can break legitimate workflows:

- **Automated CI/Testing**: Tests using bypass tokens/IPs may unexpectedly fail when attempting to fund existing accounts or make zero-amount requests, despite having bypass permissions
- **Documentation Violation**: The behavior contradicts the documented contract of the BypasserTrait
- **Operational Confusion**: Operators must understand that "bypass" only means "bypass Checkers," not "bypass all restrictions"

This does not qualify as High or Critical severity because:
- The faucet is an off-chain testing utility, not core blockchain infrastructure
- No consensus, state integrity, or validator operations are affected
- No actual funds (beyond testnet tokens) can be lost or stolen

## Likelihood Explanation

This issue occurs with **100% certainty** when:
1. A bypasser (IP allowlist or auth token) returns true
2. The request attempts to fund an existing account (TransferFunder)
3. OR the request attempts a zero-amount mint to an existing account (MintFunder)

The issue is **guaranteed to manifest** in CI/testing environments where:
- Bypass credentials are used for automated testing
- Tests need to repeatedly fund the same accounts
- Tests use zero-amount requests for validation checks

## Recommendation

Pass the `did_bypass_checkers` flag through to Funder-level restrictions and conditionally skip them when bypass is active:

**For TransferFunder**, modify the account existence check:
```rust
// In transfer.rs, fund() method:
if receiver_seq_num.is_some() && !did_bypass_checkers {
    return Err(AptosTapError::new(
        "Account ineligible".to_string(),
        AptosTapErrorCode::Rejected,
    )
    .rejection_reasons(vec![RejectionReason::new(
        format!("Account {} already exists", receiver_address),
        RejectionReasonCode::AccountAlreadyExists,
    )]));
}
```

**For MintFunder**, modify the zero-amount check:
```rust
// In mint.rs, process() method:
if receiver_seq.is_some() && amount == 0 && !did_bypass_checkers {
    return Err(AptosTapError::new(
        format!(
            "Account {} already exists and amount asked for is 0",
            receiver_address
        ),
        AptosTapErrorCode::InvalidRequest,
    ));
}
```

**For TransferFunder amount calculation**, use the `did_bypass_checkers` parameter:
```rust
fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
    let max_amount = if did_bypass_checkers {
        // Allow unrestricted amounts when bypassed
        u64::MAX
    } else {
        self.amount_to_fund.0
    };
    match amount {
        Some(amount) => std::cmp::min(amount, max_amount),
        None => self.amount_to_fund.0,
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the inconsistency
#[tokio::test]
async fn test_bypass_still_enforces_funder_restrictions() {
    // Setup faucet with IP allowlist bypasser and TransferFunder
    let bypasser = IpAllowlistBypasser::new(IpRangeManagerConfig {
        // Allow 127.0.0.1
        ranges: vec!["127.0.0.1/32".to_string()],
    }).unwrap();
    
    // Create an account that already exists
    let existing_account = AccountAddress::from_hex_literal("0x123").unwrap();
    
    // Make request from bypassed IP
    let checker_data = CheckerData {
        receiver: existing_account,
        source_ip: IpAddr::from_str("127.0.0.1").unwrap(),
        headers: Arc::new(HeaderMap::new()),
        time_request_received_secs: 1234567890,
    };
    
    // Verify bypass returns true
    assert!(bypasser.request_can_bypass(checker_data.clone()).await.unwrap());
    
    // Call TransferFunder.fund() with bypass=true
    // EXPECTED: Request succeeds since all restrictions should be bypassed
    // ACTUAL: Request fails with "Account already exists" error
    // This demonstrates the inconsistency
}
```

**Notes:**
- This vulnerability is limited to the faucet service and does not affect blockchain consensus, state management, or core protocol security
- The TransferFunder explicitly comments that it "generally" doesn't use Bypassers, suggesting this limitation may be intentional but undocumented
- The MintFunder correctly uses `did_bypass_checkers` for amount calculation but not for business logic restrictions
- This creates a tiered bypass system: Checkers are fully bypassed, amounts are conditionally bypassed (MintFunder only), but business logic is never bypassed

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/mod.rs (L22-24)
```rust
    /// Returns true if the request should be allowed to bypass all checkers
    /// and storage.
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool>;
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-258)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L332-346)
```rust
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L297-306)
```rust
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L333-344)
```rust
    fn get_amount(
        &self,
        amount: Option<u64>,
        // Ignored for now with TransferFunder, since generally we don't use Bypassers
        // when using the TransferFunder.
        _did_bypass_checkers: bool,
    ) -> u64 {
        match amount {
            Some(amount) => std::cmp::min(amount, self.amount_to_fund.0),
            None => self.amount_to_fund.0,
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L416-424)
```rust
        if receiver_seq.is_some() && amount == 0 {
            return Err(AptosTapError::new(
                format!(
                    "Account {} already exists and amount asked for is 0",
                    receiver_address
                ),
                AptosTapErrorCode::InvalidRequest,
            ));
        }
```
