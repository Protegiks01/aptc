# Audit Report

## Title
CLI Key Rotation Trusts Unverified REST API Success Field Enabling Account Lockout via Malicious Endpoint

## Summary
The Aptos CLI key rotation command (`aptos account rotate-key`) trusts the `success` field from the REST API response without independent cryptographic verification. A malicious or compromised REST endpoint can return `success: true` for a transaction that failed or was never executed, causing the CLI to save a new profile with a key that doesn't actually control the account on-chain. This can result in permanent account lockout if the user deletes their old private key.

## Finding Description

The key rotation flow in the CLI proceeds as follows:

1. **Transaction Submission** - The CLI constructs and submits a key rotation transaction to the REST endpoint [1](#0-0) 

2. **Transaction Status Polling** - The CLI waits for the transaction to be committed by calling `wait_for_signed_transaction()` [2](#0-1) 

3. **HTTP GET Without Verification** - The REST client performs a simple HTTP GET request to fetch transaction status, with no cryptographic proof verification [3](#0-2) 

4. **JSON Deserialization** - The response is deserialized into a `Transaction` object and the `success()` method simply reads the `info.success` boolean field [4](#0-3) 

5. **Blind Trust** - The CLI checks this field and proceeds if true, with **no validation** that the rotation actually occurred on-chain [5](#0-4) 

6. **Profile Saved** - The CLI immediately saves a new profile with the new key, assuming it now controls the account [6](#0-5) 

**The vulnerability**: The REST API response has no cryptographic binding to blockchain state. Despite Aptos having proof verification mechanisms via `TransactionWithProof` structures, the CLI's `wait_for_signed_transaction` path performs only JSON deserialization with zero proof verification.

**Attack Scenario**:
1. Attacker operates or compromises a REST endpoint (MITM, malicious third-party provider, or hacked official node)
2. User connects CLI to this endpoint and initiates key rotation
3. Endpoint accepts the transaction but never submits it to the blockchain (or submits but it fails)
4. Endpoint returns HTTP 200 with `{"success": true, ...}` in the Transaction JSON
5. CLI trusts this response and saves new profile with new key
6. User's account remains controlled by old key on-chain
7. All subsequent CLI operations with new key fail with authentication errors
8. If user deleted old key (common after rotation), account access is permanently lost

## Impact Explanation

This qualifies as **High Severity** per Aptos Bug Bounty criteria:
- **"Significant protocol violations"**: The CLI violates the fundamental security principle that transaction success must be cryptographically verified, not blindly trusted
- **Account Availability Loss**: Users lose access to their accounts, which is a critical operational failure
- **Affects Critical Security Operation**: Key rotation is the most security-sensitive account operation

The impact includes:
- **Permanent Account Lockout**: If the user deletes their old key after believing rotation succeeded, they cannot recover account access
- **Transaction Failures**: All future transactions fail until the user realizes and switches back to old key
- **False Security Sense**: User believes they've rotated to a new secure key while the account remains controlled by potentially compromised old key
- **No Blockchain Recovery**: The blockchain state is correct; only the user's CLI state is corrupted, making this a client-side vulnerability

This is not Critical severity because it doesn't directly enable fund theft, consensus violations, or validator node compromise. However, it's definitively High due to the severity of account lockout combined with the realistic attack vector.

## Likelihood Explanation

**HIGH Likelihood** - This attack is practical and realistic:

**Attacker Requirements**:
- Control over the REST endpoint the user connects to (achievable via multiple vectors)
- No validator access, consensus participation, or on-chain state manipulation needed
- No cryptographic key material required

**Attack Vectors**:
1. **Third-Party REST Providers**: Users commonly use third-party Aptos REST endpoints for convenience/performance
2. **Network MITM**: Attacker intercepts HTTP(S) traffic and modifies responses
3. **Compromised Infrastructure**: Attacker hacks a legitimate REST endpoint server
4. **Malicious Endpoint Operator**: Operator of a community REST endpoint acts maliciously

**User Behavior Factors**:
- Users frequently change REST endpoints (mainnet, testnet, custom nodes)
- Key rotation is a common operation (rotating compromised keys, moving to hardware wallets)
- Users typically delete old keys after rotation to prevent their use

**No Existing Defenses**: The codebase shows no cryptographic verification of transaction success at the CLI level, making this trivially exploitable once an attacker controls the REST endpoint.

## Recommendation

Implement **post-rotation verification** by querying the account's authentication key from the blockchain and comparing it to the expected new authentication key before saving the profile:

```rust
// After line 280 in key_rotation.rs, add verification:

// Verify the rotation actually occurred on-chain by querying the account's auth key
let verification_client = self.txn_options.rest_client()?;
let account_resource = verification_client
    .get_account_resource::<AccountResource>(current_address)
    .await
    .map_err(|err| CliError::ApiError(format!(
        "Failed to verify key rotation: {}", err
    )))?
    .into_inner();

let expected_new_auth_key = AuthenticationKey::ed25519(&new_public_key);
let actual_auth_key = AuthenticationKey::from_bytes(account_resource.authentication_key())
    .map_err(|err| CliError::UnableToParse("authentication_key", err.to_string()))?;

if actual_auth_key != expected_new_auth_key {
    return Err(CliError::UnexpectedError(format!(
        "Key rotation verification failed: on-chain auth key {:?} doesn't match expected {:?}. \
         Transaction may have succeeded but key was not rotated. \
         DO NOT delete your old key. Use it to retry rotation.",
        actual_auth_key,
        expected_new_auth_key
    )));
}

// Only proceed to save profile after verification passes
if self.new_profile_options.skip_saving_profile {
    return Ok(RotateSummary { ... });
}
```

**Additional Hardening**:
1. Add Merkle proof verification when available via `wait_for_transaction_by_hash_bcs` with proof validation
2. Warn users about untrusted REST endpoints during key rotation
3. Consider requiring multi-step confirmation for profile saves after key rotation
4. Log the verified auth key to help debugging if issues occur

## Proof of Concept

```rust
// Conceptual PoC demonstrating the vulnerability
// This would need to be integrated into the test harness

use aptos_rest_client::Client;
use mockito::{mock, server_url};
use aptos_types::transaction::SignedTransaction;

#[tokio::test]
async fn test_malicious_rest_endpoint_key_rotation() {
    // Setup: Mock REST endpoint that returns fake success
    let fake_success_response = r#"{
        "type": "user_transaction",
        "version": "12345",
        "hash": "0xabc...",
        "success": true,
        "vm_status": "Executed successfully",
        "gas_used": "100",
        "sender": "0x1",
        "sequence_number": "5"
    }"#;
    
    let _m = mock("GET", "/v1/transactions/by_hash/0xabc...")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(fake_success_response)
        .create();
    
    // User initiates key rotation through malicious endpoint
    let malicious_client = Client::new(server_url().parse().unwrap());
    
    // The CLI will trust the fake success response
    // and save a new profile with the new key
    // Meanwhile, on-chain the old key still controls the account
    
    // Verification: Query actual on-chain state
    let real_client = Client::new(/* real endpoint */);
    let account = real_client.get_account(test_address).await.unwrap();
    
    // The on-chain auth key is STILL the old one
    assert_ne!(
        account.authentication_key,
        derive_auth_key_from_new_public_key(new_key),
        "Key was not actually rotated on-chain!"
    );
    
    // But the CLI saved a profile with the new key
    let config = CliConfig::load().unwrap();
    let profile = config.profiles.get("new_profile").unwrap();
    assert_eq!(
        profile.public_key.unwrap(),
        new_key,
        "CLI saved profile with new key despite failed rotation"
    );
    
    // Result: User is now locked out if they delete old key
}
```

**Manual Testing Steps**:
1. Set up a local mock REST server that accepts POST to `/v1/transactions` but never submits to blockchain
2. Configure mock to return HTTP 200 with `{"success": true}` for GET `/v1/transactions/by_hash/{hash}`
3. Point CLI to mock endpoint: `aptos init --rest-url http://localhost:8080`
4. Execute key rotation: `aptos account rotate-key --save-to-profile rotated`
5. Observe CLI saves new profile despite transaction never executing on real blockchain
6. Attempt transaction with new profile - fails with authentication error
7. Query on-chain account state - confirms old authentication key still active

**Notes**

This vulnerability represents a fundamental trust model violation where the CLI treats REST API responses as authoritative without cryptographic proof. While Aptos provides `TransactionWithProof` mechanisms for verified state queries, the commonly-used `wait_for_signed_transaction` code path bypasses all verification.

The severity is amplified because:
1. Key rotation is a rare but critical operation where users are most vulnerable
2. Users naturally delete old keys after rotation, making lockout permanent  
3. The attack surface includes any compromised network path between user and REST endpoint
4. No warning or verification feedback is provided to users

The fix is straightforward: query and verify the on-chain authentication key matches the expected value before persisting the new profile configuration.

### Citations

**File:** crates/aptos/src/account/key_rotation.rs (L251-264)
```rust
        let txn_summary = self
            .txn_options
            .submit_transaction(aptos_stdlib::account_rotate_authentication_key(
                0,
                current_public_key.to_bytes().to_vec(),
                0,
                new_public_key.to_bytes().to_vec(),
                rotation_proof_signed_by_current_private_key
                    .to_bytes()
                    .to_vec(),
                rotation_proof_signed_by_new_private_key.to_bytes().to_vec(),
            ))
            .await
            .map(TransactionSummary::from)?;
```

**File:** crates/aptos/src/account/key_rotation.rs (L270-280)
```rust
        if let Some(txn_success) = txn_summary.success {
            if !txn_success {
                return Err(CliError::ApiError(
                    "Transaction was not executed successfully".to_string(),
                ));
            }
        } else {
            return Err(CliError::UnexpectedError(
                "Malformed transaction response".to_string(),
            ));
        }
```

**File:** crates/aptos/src/account/key_rotation.rs (L282-324)
```rust
        if self.new_profile_options.skip_saving_profile {
            return Ok(RotateSummary {
                transaction: txn_summary,
                message: None,
            });
        }

        // Can safe unwrap here since NewProfileOptions arg group requires either that
        // skip_saving_profile is set, or that a new profile name is specified. If a new profile is
        // specified, then it will have already been error checked above.
        let new_profile_name = self.new_profile_options.save_to_profile.unwrap();

        // If no config exists, then the error should've been caught earlier during the profile
        // name verification step.
        let mut config = CliConfig::load(ConfigSearchMode::CurrentDirAndParents)?;
        if config.profiles.is_none() {
            config.profiles = Some(BTreeMap::new());
        }

        // Create new config.
        let mut new_profile_config = ProfileConfig {
            public_key: Some(new_public_key),
            account: Some(current_address),
            private_key: new_private_key,
            derivation_path: new_derivation_path,
            ..self.txn_options.profile_options.profile()?
        };

        if let Some(url) = self.txn_options.rest_options.url {
            new_profile_config.rest_url = Some(url.into());
        }

        config
            .profiles
            .as_mut()
            .unwrap()
            .insert(new_profile_name.clone(), new_profile_config);
        config.save()?;

        Ok(RotateSummary {
            transaction: txn_summary,
            message: Some(format!("Saved new profile {}", new_profile_name)),
        })
```

**File:** crates/aptos/src/common/types.rs (L2117-2122)
```rust
        let response = client
            .wait_for_signed_transaction(&transaction)
            .await
            .map_err(|err| CliError::ApiError(err.to_string()))?;

        Ok(response.into_inner())
```

**File:** crates/aptos-rest-client/src/lib.rs (L1052-1057)
```rust
    async fn get_transaction_by_hash_inner(
        &self,
        hash: HashValue,
    ) -> AptosResult<reqwest::Response> {
        let url = self.build_path(&format!("transactions/by_hash/{}", hash.to_hex_literal()))?;
        Ok(self.inner.get(url).send().await?)
```

**File:** api/types/src/transaction.rs (L241-251)
```rust
    pub fn success(&self) -> bool {
        match self {
            Transaction::UserTransaction(txn) => txn.info.success,
            Transaction::BlockMetadataTransaction(txn) => txn.info.success,
            Transaction::PendingTransaction(_txn) => false,
            Transaction::GenesisTransaction(txn) => txn.info.success,
            Transaction::StateCheckpointTransaction(txn) => txn.info.success,
            Transaction::BlockEpilogueTransaction(txn) => txn.info.success,
            Transaction::ValidatorTransaction(txn) => txn.transaction_info().success,
        }
    }
```
