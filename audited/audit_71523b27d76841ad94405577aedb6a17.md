# Audit Report

## Title
Configuration Sanitizer Bypass Enables Validator Equivocation Through In-Memory Safety Storage

## Summary
A malicious validator can bypass critical consensus safety checks by setting `skip_config_sanitizer: true` in their node configuration, allowing the use of non-persistent storage (`InMemoryStorage`) for safety data. This enables double-signing attacks after node restarts, violating the consensus safety invariant that prevents validator equivocation.

## Finding Description

The Aptos consensus layer implements double-sign prevention through `SafetyRules`, which tracks `last_voted_round` in persisted `SafetyData`. The configuration sanitizer enforces that mainnet validators must use persistent storage backends to maintain this critical state across restarts. [1](#0-0) 

However, when a validator sets `node_startup.skip_config_sanitizer: true` in their configuration YAML, the entire sanitization process is bypassed, including safety-critical checks. [2](#0-1) 

This allows bypassing the `SafetyRulesConfig` sanitization that normally prevents mainnet validators from using `InMemoryStorage`: [3](#0-2) 

**Attack Mechanism:**

When using `InMemoryStorage` as the safety rules backend: [4](#0-3) 

The storage is ephemeral and lost on node restart. After restart, `SafetyData` is re-initialized with `last_voted_round = 0`: [5](#0-4) 

This defeats the double-sign prevention check that relies on persisted `last_voted_round`: [6](#0-5) 

**Exploitation Path:**

1. Malicious validator creates configuration:
```yaml
node_startup:
  skip_config_sanitizer: true
consensus:
  safety_rules:
    backend:
      type: in_memory_storage
```

2. Validator votes on round N with vote V1
3. Validator intentionally restarts their node
4. After restart, `last_voted_round` resets to 0 (stored state is lost)
5. Validator receives proposal for round N again
6. Check at line 218 passes (`N > 0`), allowing vote V2 for same round
7. Validator equivocates by signing conflicting votes for round N [7](#0-6) 

## Impact Explanation

**Severity: Critical** (Consensus/Safety Violation)

This vulnerability enables validators to violate the fundamental consensus safety guarantee: **no validator shall vote twice for different values in the same round**. While AptosBFT tolerates up to 1/3 Byzantine validators, this bug provides an easy mechanism for validators to behave Byzantine without detection, as the safety rule checks pass due to lost state.

The impact qualifies as Critical per Aptos Bug Bounty criteria because:
- **Consensus Safety Violation**: Enables validator equivocation, breaking the core BFT assumption
- **Non-recoverable if widespread**: If multiple validators collude using this technique, network forks become possible
- **Defeats safety mechanism**: The sanitizer exists specifically to prevent this scenario

## Likelihood Explanation

**Likelihood: Medium-to-High**

- **Requires**: Validator operator access to modify configuration file
- **Complexity**: Trivial - single YAML flag change
- **Detection**: Difficult - appears as legitimate configuration option
- **Prerequisites**: None beyond validator access
- **Barriers**: Trust in validator operators, but insider threats are real

While this requires validator operator privileges (insider threat), the sanitizer exists **specifically** to protect against misconfigured or malicious validators. The ability to trivially bypass it with a documented configuration flag defeats its purpose.

## Recommendation

**Fix 1: Remove Skip Sanitizer Flag (Recommended)**

Remove the `skip_config_sanitizer` option entirely from production code, or make it only available in test builds:

```rust
// In config/src/config/node_startup_config.rs
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool,
    #[cfg(test)]  // Only allow in test builds
    pub skip_config_sanitizer: bool,
}
```

**Fix 2: Non-Bypassable Safety Checks**

Move critical safety rule validation outside the sanitizer framework into mandatory initialization checks:

```rust
// In consensus/safety-rules/src/safety_rules_manager.rs
impl SafetyRulesManager {
    pub fn new(config: &SafetyRulesConfig, chain_id: ChainId) -> Self {
        // Mandatory check - cannot be bypassed
        if chain_id.is_mainnet() && config.backend.is_in_memory() {
            panic!("InMemoryStorage is not allowed for mainnet validators");
        }
        // ... rest of initialization
    }
}
```

**Fix 3: Audit Logging**

If the flag must remain for operational reasons, enforce audit logging when sanitization is skipped:

```rust
if node_config.node_startup.skip_config_sanitizer {
    error!("SECURITY WARNING: Config sanitization bypassed! Chain: {:?}", chain_id);
    // Log to immutable audit trail
    return Ok(());
}
```

## Proof of Concept

**Malicious Validator Configuration (validator_unsafe.yaml):**

```yaml
base:
  role: validator
  data_dir: "/opt/aptos/data"

# BYPASS ALL SAFETY CHECKS
node_startup:
  skip_config_sanitizer: true

consensus:
  safety_rules:
    # Use non-persistent storage (normally blocked by sanitizer)
    backend:
      type: in_memory_storage
    service:
      type: local

validator_network:
  network_id: "Validator"
  discovery_method: "Onchain"
  listen_address: "/ip4/0.0.0.0/tcp/6180"
  mutual_authentication: true
```

**Steps to Reproduce:**

1. Deploy validator with above configuration
2. Start node: `aptos-node -f validator_unsafe.yaml`
3. Observe: Config loads without sanitizer errors despite dangerous settings
4. Wait for validator to vote on round N
5. Restart validator node: `systemctl restart aptos-node`
6. Observe: `last_voted_round` reset to 0 (check logs for "SafetyData" initialization)
7. Validator can now vote again on round N or earlier rounds
8. Evidence: Check consensus logs for conflicting votes with same author, same round, different block IDs

**Validation:**

```bash
# Check if InMemoryStorage is active (should fail on mainnet with proper sanitization)
grep -r "InMemoryStorage" /opt/aptos/logs/

# Monitor for safety data resets after restart
grep "Initialize.*SafetyData.*last_voted_round: 0" /opt/aptos/logs/

# Detect potential equivocation (same author, round, different blocks)
grep "IncorrectLastVotedRound" /opt/aptos/logs/
```

## Notes

This vulnerability exists at the intersection of configuration management and consensus safety. While the AptosBFT protocol is designed to tolerate Byzantine validators, the sanitizer's purpose is to prevent validators from **accidentally or intentionally** misconfiguring their nodes in ways that enable Byzantine behavior. The `skip_config_sanitizer` flag defeats this defense-in-depth mechanism, creating an easy path for validators to equivocate.

The fix should prioritize making safety-critical checks non-bypassable, even if operational flexibility is desired for other configuration aspects.

### Citations

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/consensus_config.rs (L503-532)
```rust
impl ConfigSanitizer for ConsensusConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Verify that the safety rules and quorum store configs are valid
        SafetyRulesConfig::sanitize(node_config, node_type, chain_id)?;
        QuorumStoreConfig::sanitize(node_config, node_type, chain_id)?;

        // Verify that the consensus-only feature is not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && is_consensus_only_perf_test_enabled() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "consensus-only-perf-test should not be enabled in mainnet!".to_string(),
                ));
            }
        }

        // Sender block limits must be <= receiver block limits
        Self::sanitize_send_recv_block_limits(&sanitizer_name, &node_config.consensus)?;

        // Quorum store batches must be <= consensus blocks
        Self::sanitize_batch_block_limits(&sanitizer_name, &node_config.consensus)?;

        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/secure_backend_config.rs (L162-195)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
        }
    }
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L33-61)
```rust
    pub fn initialize(
        mut internal_store: Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
        waypoint: Waypoint,
        enable_cached_safety_data: bool,
    ) -> Self {
        // Initialize the keys and accounts
        Self::initialize_keys_and_accounts(&mut internal_store, author, consensus_private_key)
            .expect("Unable to initialize keys and accounts in storage");

        // Create the new persistent safety storage
        let safety_data = SafetyData::new(1, 0, 0, 0, None, 0);
        let mut persisent_safety_storage = Self {
            enable_cached_safety_data,
            cached_safety_data: Some(safety_data.clone()),
            internal_store,
        };

        // Initialize the safety data and waypoint
        persisent_safety_storage
            .set_safety_data(safety_data)
            .expect("Unable to initialize safety data");
        persisent_safety_storage
            .set_waypoint(&waypoint)
            .expect("Unable to initialize waypoint");

        persisent_safety_storage
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```
