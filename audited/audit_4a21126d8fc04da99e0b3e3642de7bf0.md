# Audit Report

## Title
State Corruption in SecretShareStore Due to Improper Error Handling in add_share_with_metadata()

## Summary
The `SecretShareStore::add_self_share()` function contains a critical state corruption bug where calling `add_share_with_metadata()` can leave the secret share aggregator in a permanently corrupted state with an incorrect author (`Author::ONE`) when an error occurs, breaking the secret sharing protocol required for consensus randomness generation.

## Finding Description

The vulnerability exists in the error handling path of `SecretShareItem::add_share_with_metadata()`. [1](#0-0) 

The function uses `std::mem::replace(self, Self::new(Author::ONE))` to temporarily take ownership of the current state. [2](#0-1) 

However, when the state is `PendingDecision`, the function calls `bail!()` returning an error. [3](#0-2) 

Similarly, when the state is `Decided`, it returns early with `Ok(())`. [4](#0-3) 

In both cases, the final restoration `std::mem::replace(self, new_item)` never executes, leaving the `SecretShareItem` corrupted as `PendingMetadata(SecretShareAggregator::new(Author::ONE))` with the wrong author instead of the correct validator's author. [5](#0-4) 

When `add_self_share()` propagates this error, the corrupted state persists in the `secret_share_map`. [6](#0-5) 

**Triggering Conditions:**

This occurs when `add_self_share()` is called multiple times for the same round, which can happen when:

1. **Equivocation**: Multiple different blocks are proposed for the same round by a Byzantine validator. The block tree explicitly logs warnings about this scenario. [7](#0-6) 

2. **Block Reprocessing**: Network issues, redelivery, or upstream bugs cause the same round to be processed multiple times through the pipeline. [8](#0-7) 

**Breaking Consensus Invariants:**

Once corrupted, the `SecretShareItem` has `self_author = Author::ONE` instead of the correct validator author. When `get_self_share()` is called, it searches for a share from `Author::ONE` which doesn't exist. [9](#0-8) 

This prevents:
- Successful share aggregation for that round
- Secret key derivation required for randomness generation
- Consensus progress if randomness is required

**Comparison with Correct Implementation:**

The parallel `RandStore` implementation handles this correctly by returning the item unchanged rather than bailing. [10](#0-9) 

## Impact Explanation

**Severity: MEDIUM**

This vulnerability causes **state inconsistencies requiring intervention**, which explicitly qualifies as Medium severity per the Aptos bug bounty program.

**Specific Impacts:**

1. **Liveness Degradation**: Affected validator nodes cannot complete secret share aggregation for the corrupted round, blocking randomness generation needed for consensus
2. **Protocol Disruption**: Secret sharing protocol fails silently (in the `Decided` case) or with errors (in the `PendingDecision` case)
3. **Requires Intervention**: The corrupted state persists in memory until the node restarts or the epoch changes
4. **Validator Subset Impact**: Only validators that process multiple blocks for the same round are affected, not the entire network

This does not reach Critical severity because:
- It doesn't cause permanent fund loss
- It doesn't break consensus safety (only liveness)
- It doesn't require a hard fork to recover
- Impact is limited to specific nodes under specific conditions

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability can be triggered by:

1. **Byzantine Equivocation** (Most Likely): A malicious proposer creates multiple blocks at the same round. While consensus validation should reject these, the `SecretShareManager` processes blocks before/concurrently with validation, and the block tree explicitly acknowledges this scenario can occur.

2. **Network Anomalies** (Less Likely): Duplicate block delivery due to network retransmissions, though block deduplication at the storage layer should prevent this.

3. **Implementation Bugs** (Possible): Bugs in the upstream pipeline causing duplicate round processing.

The Aptos codebase demonstrates awareness of this scenario through explicit warnings about multiple blocks per round, indicating the developers anticipated this possibility but the `SecretShareStore` lacks proper defensive handling.

## Recommendation

**Fix the state restoration in `add_share_with_metadata()`:**

The function should follow the pattern used in `RandStore::add_metadata()`, returning the item unchanged when already in `PendingDecision` or `Decided` states instead of bailing or returning early:

```rust
fn add_share_with_metadata(
    &mut self,
    share: SecretShare,
    share_weights: &HashMap<Author, u64>,
) -> anyhow::Result<()> {
    let item = std::mem::replace(self, Self::new(Author::ONE));
    let share_weight = *share_weights
        .get(share.author())
        .expect("Author must exist in weights");
    let new_item = match item {
        SecretShareItem::PendingMetadata(mut share_aggregator) => {
            let metadata = share.metadata.clone();
            share_aggregator.retain(share.metadata(), share_weights);
            share_aggregator.add_share(share, share_weight);
            SecretShareItem::PendingDecision {
                metadata,
                share_aggregator,
            }
        },
        // FIX: Return item unchanged instead of bailing
        item @ (SecretShareItem::PendingDecision { .. } | SecretShareItem::Decided { .. }) => {
            item
        },
    };
    let _ = std::mem::replace(self, new_item);
    Ok(())
}
```

Alternatively, add deduplication in `process_incoming_block()` to prevent processing the same round multiple times.

## Proof of Concept

```rust
#[cfg(test)]
mod test_state_corruption {
    use super::*;
    use aptos_types::secret_sharing::{SecretShare, SecretShareConfig, SecretShareMetadata};
    use futures_channel::mpsc::unbounded;
    
    #[test]
    fn test_add_self_share_state_corruption() {
        // Setup
        let epoch = 1;
        let author = Author::from_hex_literal("0x1").unwrap();
        let config = SecretShareConfig::default(); // simplified
        let (tx, _rx) = unbounded();
        let mut store = SecretShareStore::new(epoch, author, config, tx);
        
        // Create self share
        let metadata = SecretShareMetadata { epoch, round: 100, /* ... */ };
        let share1 = SecretShare::new(author, metadata.clone(), /* ... */);
        
        // First call succeeds, transitions to PendingDecision
        store.add_self_share(share1.clone()).expect("First call should succeed");
        
        // Second call with same round corrupts state
        let result = store.add_self_share(share1.clone());
        
        // Either returns error (PendingDecision case) or Ok (Decided case)
        // But in both cases, the internal state is now corrupted
        
        // Verify corruption: try to get self share
        let retrieved = store.get_self_share(&metadata).unwrap();
        
        // This will return None because the aggregator now has Author::ONE
        // as self_author instead of the correct author
        assert!(retrieved.is_none(), "State corrupted: cannot retrieve self share");
    }
}
```

**Notes:**

The actual PoC would require proper initialization of `SecretShareConfig` and `SecretShare` objects with valid cryptographic data. The key demonstration is that calling `add_self_share()` twice for the same round leaves the store unable to retrieve the self share due to the corrupted `Author::ONE` state.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L83-85)
```rust
    fn get_self_share(&self) -> Option<SecretShare> {
        self.shares.get(&self.self_author).cloned()
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L156-182)
```rust
    fn add_share_with_metadata(
        &mut self,
        share: SecretShare,
        share_weights: &HashMap<Author, u64>,
    ) -> anyhow::Result<()> {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
        let new_item = match item {
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
                SecretShareItem::PendingDecision {
                    metadata,
                    share_aggregator,
                }
            },
            SecretShareItem::PendingDecision { .. } => {
                bail!("Cannot add self share in PendingDecision state");
            },
            SecretShareItem::Decided { .. } => return Ok(()),
        };
        let _ = std::mem::replace(self, new_item);
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L254-254)
```rust
        item.add_share_with_metadata(share, peer_weights)?;
```

**File:** consensus/src/block_storage/block_tree.rs (L327-332)
```rust
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L132-147)
```rust
    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
        let metadata = self_secret_share.metadata().clone();

        // Now acquire lock and update store
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L180-193)
```rust
    fn add_metadata(&mut self, rand_config: &RandConfig, rand_metadata: FullRandMetadata) {
        let item = std::mem::replace(self, Self::new(Author::ONE, PathType::Slow));
        let new_item = match item {
            RandItem::PendingMetadata(mut share_aggregator) => {
                share_aggregator.retain(rand_config, &rand_metadata);
                Self::PendingDecision {
                    metadata: rand_metadata,
                    share_aggregator,
                }
            },
            item @ (RandItem::PendingDecision { .. } | RandItem::Decided { .. }) => item,
        };
        let _ = std::mem::replace(self, new_item);
    }
```
