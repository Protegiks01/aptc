# Audit Report

## Title
Type Layout Gas Bypass in `native_from_bytes` Allows CPU Exhaustion via Deeply Nested Generic Types

## Summary
The `native_from_bytes()` function in `aptos-move/framework/src/natives/util.rs` computes type layouts for complex generic types without charging gas proportional to the computational cost. An attacker can exploit this by repeatedly calling `any::unpack<T>()` with deeply nested vector types (up to 128 levels deep), consuming excessive validator CPU resources while only paying minimal gas based on serialized byte length. [1](#0-0) 

## Finding Description

The vulnerability exists in the gas charging sequence of `native_from_bytes()`. At line 38, a TODO comment explicitly acknowledges the missing gas charge: `// TODO(Gas): charge for getting the layout`. The expensive `type_to_type_layout()` operation executes at line 39 before any gas is charged. [2](#0-1) 

Gas charging only occurs after layout computation (lines 42-44) and charges based solely on the serialized byte length (`UTIL_FROM_BYTES_BASE + UTIL_FROM_BYTES_PER_BYTE * bytes.len()`), not the type's structural complexity.

The `type_to_type_layout()` operation performs recursive tree traversal through the type structure. For deeply nested types like `vector<vector<vector<...>>>`, this involves: [3](#0-2) 

Each recursive level processes the type structure, allocating and constructing `MoveTypeLayout` objects. With a maximum depth of 128 and up to 512 nodes allowed: [4](#0-3) [5](#0-4) 

Critically, layout caching only applies to struct types, not vectors: [6](#0-5) 

**Attack Path:**

1. Attacker crafts a deeply nested vector type: `vector<vector<vector<...<u8>...>>>` with 127 levels (within limit)
2. Creates an `Any` value using `aptos_std::any::pack<ComplexType>(empty_value)`
3. In a transaction loop, repeatedly calls `any::unpack<ComplexType>()` [7](#0-6) 

4. Each `unpack()` invokes the friend function `from_bcs::from_bytes<T>()` [8](#0-7) 

5. This triggers `native_from_bytes()`, which computes the layout without proportional gas charging
6. With 1000 iterations in a loop, the attacker forces 128,000 recursive layout computations (1000 × 128 depth)
7. Gas paid: ~1,102 + 18×(small_bytes) per iteration ≈ 1.2M gas units total
8. Actual CPU cost: significantly higher, consuming validator processing time

The gas parameters show minimal charging: [9](#0-8) 

This breaks the invariant that "all operations must respect gas limits and computational limits" by allowing disproportionate CPU consumption relative to gas payment.

## Impact Explanation

**High Severity** - This vulnerability enables:

1. **Validator Node Slowdowns**: Attackers can submit transactions that consume excessive CPU during execution, degrading validator performance and increasing block processing latency
2. **Resource Exhaustion Attack**: Multiple malicious transactions can amplify the effect, potentially causing validators to fall behind consensus
3. **Gas Metering Bypass**: Significant computational work is performed without adequate gas payment, violating the fundamental gas economics of the blockchain

This qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations" (gas metering bypass).

While not reaching Critical severity (no direct fund loss or consensus break), this enables a practical DoS vector against validator infrastructure with minimal attacker cost.

## Likelihood Explanation

**High Likelihood** - The attack is highly feasible because:

1. **Low Barrier to Entry**: Any user can submit transactions with public function calls
2. **No Special Permissions Required**: `any::unpack()` is a public function accessible to all
3. **Deterministic Exploitation**: The vulnerability is consistently exploitable on every transaction
4. **Cost-Effective**: Attacker pays minimal gas (≈1.2M units for 1000 iterations) while consuming significant validator CPU
5. **Amplifiable**: Multiple transactions can be submitted in parallel or across blocks
6. **Type Flexibility**: Various deeply nested type structures (vectors, nested structs with generics) can trigger the issue

The acknowledged TODO comment indicates the development team is aware of the missing gas charge but it remains unpatched in production.

## Recommendation

Implement gas charging proportional to the type layout complexity before computing the layout:

**Fix for `aptos-move/framework/src/natives/util.rs`:**

```rust
fn native_from_bytes(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(ty_args.len(), 1);
    debug_assert_eq!(args.len(), 1);

    // Charge for type layout computation based on depth/complexity
    let ty = &ty_args[0];
    let layout_cost = estimate_layout_cost(ty, context);
    context.charge(layout_cost)?;
    
    let layout = context.type_to_type_layout(ty)?;

    let bytes = safely_pop_arg!(args, Vec<u8>);
    context.charge(
        UTIL_FROM_BYTES_BASE + UTIL_FROM_BYTES_PER_BYTE * NumBytes::new(bytes.len() as u64),
    )?;

    // ... rest of function
}

// Helper to estimate cost based on type structure
fn estimate_layout_cost(ty: &Type, context: &SafeNativeContext) -> InternalGas {
    let (depth, node_count) = compute_type_metrics(ty);
    UTIL_FROM_BYTES_LAYOUT_BASE 
        + UTIL_FROM_BYTES_LAYOUT_PER_DEPTH * depth
        + UTIL_FROM_BYTES_LAYOUT_PER_NODE * node_count
}
```

Add new gas parameters to `aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs`:
- `UTIL_FROM_BYTES_LAYOUT_BASE`: Base cost for layout computation
- `UTIL_FROM_BYTES_LAYOUT_PER_DEPTH`: Cost per level of type nesting
- `UTIL_FROM_BYTES_LAYOUT_PER_NODE`: Cost per type node in the layout

Alternatively, implement conservative pre-charging based on maximum possible layout complexity given the depth/size limits, then refund unused gas.

## Proof of Concept

```move
#[test_only]
module attacker::exploit {
    use std::vector;
    use aptos_std::any;
    
    // Create a deeply nested vector type
    struct DeepVector has store, drop {
        v: vector<vector<vector<vector<vector<vector<vector<vector<
           vector<vector<vector<vector<vector<vector<vector<vector<
           vector<vector<vector<vector<u8>
           >>>>>>>>>>>>>>>>>>>>
    }
    
    #[test]
    public fun test_gas_bypass() {
        // Create minimal payload with deeply nested type
        let empty = DeepVector { 
            v: vector::empty()
        };
        
        // Pack into Any
        let packed = any::pack(empty);
        
        // Repeatedly unpack - each iteration computes expensive layout
        // but only pays ~1102 + 18*bytes gas
        let i = 0;
        while (i < 1000) {
            let _ = any::unpack<DeepVector>(copy packed);
            i = i + 1;
        };
        // Total gas: ~1.2M units
        // Actual CPU: 1000 * (20-level recursive traversal) = substantial overhead
    }
}
```

**Expected Result**: The test completes with minimal gas consumption despite performing 1000 expensive layout computations, demonstrating the gas bypass vulnerability.

**Notes**

The vulnerability is explicitly documented in the codebase via the TODO comment, indicating developer awareness but no implemented fix. The issue is compounded by the fact that vector type layouts are not cached, ensuring every call recomputes the full layout structure. The production configuration allows up to 128 depth and 512 nodes per layout, providing ample opportunity for exploitation within system limits.

### Citations

**File:** aptos-move/framework/src/natives/util.rs (L38-39)
```rust
    // TODO(Gas): charge for getting the layout
    let layout = context.type_to_type_layout(&ty_args[0])?;
```

**File:** aptos-move/framework/src/natives/util.rs (L42-44)
```rust
    context.charge(
        UTIL_FROM_BYTES_BASE + UTIL_FROM_BYTES_PER_BYTE * NumBytes::new(bytes.len() as u64),
    )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L89-106)
```rust
        if self.vm_config().enable_layout_caches {
            let key = match ty {
                Type::Struct { idx, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(&[]);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                Type::StructInstantiation { idx, ty_args, .. } => {
                    let ty_args_id = ty_pool.intern_ty_args(ty_args);
                    Some(StructKey {
                        idx: *idx,
                        ty_args_id,
                    })
                },
                _ => None,
            };
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L283-296)
```rust
            Type::Vector(ty) => self
                .type_to_type_layout_impl::<ANNOTATED>(
                    gas_meter,
                    traversal_context,
                    modules,
                    ty,
                    count,
                    depth + 1,
                    check_option_type,
                )
                .map(|(elem_layout, contains_delayed_fields)| {
                    let vec_layout = MoveTypeLayout::Vector(Box::new(elem_layout));
                    (vec_layout, contains_delayed_fields)
                })?,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L215-219)
```rust
    let layout_max_size = if gas_feature_version >= RELEASE_V1_30 {
        512
    } else {
        256
    };
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L245-245)
```rust
        layout_max_depth: 128,
```

**File:** aptos-move/framework/aptos-stdlib/sources/any.move (L39-42)
```text
    public fun unpack<T>(self: Any): T {
        assert!(type_info::type_name<T>() == self.type_name, error::invalid_argument(ETYPE_MISMATCH));
        from_bytes<T>(self.data)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/from_bcs.move (L69-69)
```text
    native friend fun from_bytes<T>(bytes: vector<u8>): T;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L300-301)
```rust
        [util_from_bytes_base: InternalGas, "util.from_bytes.base", 1102],
        [util_from_bytes_per_byte: InternalGasPerByte, "util.from_bytes.per_byte", 18],
```
