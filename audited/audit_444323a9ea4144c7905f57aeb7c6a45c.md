# Audit Report

## Title
Integer Underflow in `standardize_address()` Causes Indexer Service Crash via Oversized Address Input

## Summary
The `standardize_address()` function in the transaction filter utility contains an integer underflow vulnerability when processing addresses exceeding 64 hexadecimal characters. An attacker can trigger a panic and crash the indexer-grpc service by submitting filter requests with malformed addresses, causing a denial of service.

## Finding Description

The `standardize_address()` function is used throughout the indexer-grpc transaction filtering system to normalize Aptos addresses according to AIP-40 display format. The function contains a critical boundary bug in its address padding logic. [1](#0-0) 

The vulnerability occurs at the non-special address handling path. When an address string (after removing the "0x" prefix) exceeds 64 characters, the expression `64 - trimmed.len()` causes an integer underflow. In Rust's default configuration (with overflow checks enabled), this triggers a panic and crashes the service.

**Attack Flow:**

1. Attacker crafts a gRPC or REST API filter request containing an address field with more than 64 hex characters (e.g., 65+ characters)
2. The request is deserialized into a filter struct (UserTransactionFilter, EntryFunctionFilter, or MoveStructTagFilter)
3. During filter construction, the `From<proto>` trait implementation calls `standardize_address()` [2](#0-1) 

4. The function attempts to calculate `&ZEROS[..64 - trimmed.len()]` where `trimmed.len() > 64`
5. Integer underflow occurs, causing a panic
6. The indexer service crashes, becoming unavailable

**Test Coverage Gaps:**

The existing test suite does not verify boundary cases: [3](#0-2) 

Missing test cases:
- 64-character non-special addresses at exact boundary (e.g., addresses starting at 0x10)
- 65-character addresses (should be rejected or handled gracefully)
- Arbitrarily long addresses (e.g., 100+ characters)

**Additional Issue - Special Address Length Validation:**

The special address detection logic does not validate address length. An address consisting of 100 zeros followed by 'f' would incorrectly return "0xf" instead of being rejected, as the check only verifies that all characters except the last are '0', without enforcing the 64-character limit. [4](#0-3) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria: "API crashes."

**Impact:**
- **Denial of Service**: The indexer-grpc service crashes and becomes unavailable
- **Service Disruption**: Transaction filtering and indexing functionality is disrupted
- **Cascading Effects**: Dependent services relying on the indexer may also fail
- **Trivial Exploitation**: No authentication or special privileges required; any user can send malformed filter requests

The indexer-grpc service is a critical infrastructure component used by:
- Blockchain explorers
- Analytics platforms  
- DApp backends
- Data aggregation services

A crash of this service disrupts the entire ecosystem's ability to query and filter blockchain data.

## Likelihood Explanation

**Likelihood: High**

**Ease of Exploitation:**
- Attack requires only sending a single malformed gRPC/REST request
- No authentication, validator access, or special permissions needed
- Attacker can repeatedly crash the service
- Exploit is trivial to automate

**Attacker Requirements:**
- Network access to the indexer-grpc API endpoint
- Ability to craft protobuf or JSON filter messages
- Basic knowledge of API structure

**Discovery Probability:**
- Fuzzing or basic boundary testing would immediately reveal this issue
- Address validation is a common security testing target
- Natural user errors (copy-paste mistakes) could accidentally trigger this

## Recommendation

**Immediate Fix:**

Add length validation before the padding calculation to prevent integer underflow:

```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate address length (must be <= 64 hex characters)
    if trimmed.len() > 64 {
        // Option 1: Truncate to 64 characters
        let trimmed = &trimmed[..64];
        // Option 2 (preferred): Return error or panic with clear message
        // panic!("Address exceeds maximum length of 64 hex characters: {}", trimmed.len());
    }
    
    // Validate hex characters
    if !trimmed.chars().all(|c| c.is_ascii_hexdigit()) {
        // Handle invalid characters
    }

    // Check if the address is a special address
    // Also add length check: special addresses should be <= 64 chars
    if trimmed.len() <= 64 {
        if let Some(last_char) = trimmed.chars().last() {
            if trimmed[..trimmed.len().saturating_sub(1)]
                .chars()
                .all(|c| c == '0')
                && last_char.is_ascii_hexdigit()
                && last_char.to_digit(16).unwrap_or(16) < 16
            {
                // Return special addresses in short format
                let mut result = String::with_capacity(3);
                result.push_str("0x");
                result.push(last_char);
                return result;
            }
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**Better Approach:**

Use the existing AccountAddress validation:

```rust
use aptos_types::account_address::AccountAddress;
use std::str::FromStr;

pub fn standardize_address(address: &str) -> Result<String, String> {
    // Validate using AccountAddress parser
    let parsed = AccountAddress::from_str(address)
        .map_err(|e| format!("Invalid address: {}", e))?;
    
    // Convert to standardized format using AIP-40 rules
    // (implementation details...)
}
```

**Add Test Coverage:**

```rust
#[test]
fn test_standardize_address_boundary_cases() {
    // Exactly 64 characters
    assert_eq!(
        standardize_address("0x1234567890123456789012345678901234567890123456789012345678901234"),
        "0x1234567890123456789012345678901234567890123456789012345678901234"
    );
    
    // 65 characters - should handle gracefully
    let result = std::panic::catch_unwind(|| {
        standardize_address("0x12345678901234567890123456789012345678901234567890123456789012345")
    });
    assert!(result.is_err(), "Should panic or return error for 65-char address");
    
    // Special address boundary (0xf vs 0x10)
    assert_eq!(standardize_address("0xf"), "0xf");
    assert_eq!(
        standardize_address("0x10"),
        "0x0000000000000000000000000000000000000000000000000000000000000010"
    );
}
```

## Proof of Concept

```rust
#[test]
#[should_panic]
fn test_address_overflow_panic() {
    // Create an address with 65 hex characters (exceeds the 64-char limit)
    let oversized_address = format!("0x{}", "a".repeat(65));
    
    // This will panic due to integer underflow at line 33
    let _ = standardize_address(&oversized_address);
}

#[test]
fn test_filter_construction_with_oversized_address() {
    use aptos_transaction_filter::UserTransactionFilterBuilder;
    
    // Attacker sends filter with 100-character address
    let malicious_address = format!("0x{}", "f".repeat(100));
    
    // This will panic when the builder tries to standardize the address
    let result = std::panic::catch_unwind(|| {
        UserTransactionFilterBuilder::default()
            .sender(malicious_address)
            .build()
    });
    
    assert!(result.is_err(), "Service should crash with oversized address");
}

#[test]
fn test_protobuf_deserialization_crash() {
    use aptos_protos::indexer::v1::UserTransactionFilter as ProtoFilter;
    
    // Simulate attacker sending protobuf with oversized address
    let proto = ProtoFilter {
        sender: Some(format!("0x{}", "1".repeat(70))),
        payload_filter: None,
    };
    
    // Conversion will panic in standardize_address
    let result = std::panic::catch_unwind(|| {
        let _filter: UserTransactionFilter = proto.into();
    });
    
    assert!(result.is_err(), "Protobuf conversion should panic");
}
```

**Notes**

This vulnerability represents a clear violation of the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The service must handle all user inputs gracefully without crashing. The lack of input validation on address length is a fundamental boundary condition failure that enables trivial denial-of-service attacks against critical indexing infrastructure.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L38-103)
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_standardize_special_address() {
        assert_eq!(standardize_address("0x1"), "0x1");
        assert_eq!(standardize_address("0x01"), "0x1");
        assert_eq!(standardize_address("0x001"), "0x1");
        assert_eq!(standardize_address("0x000000001"), "0x1");
        assert_eq!(standardize_address("0xf"), "0xf");
        assert_eq!(standardize_address("0x0f"), "0xf");
        assert_eq!(
            standardize_address(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
            "0x1"
        );

        assert_eq!(standardize_address("1"), "0x1");
        assert_eq!(
            standardize_address("0000000000000000000000000000000000000000000000000000000000000001"),
            "0x1"
        );
    }

    #[test]
    fn test_standardize_not_special_address() {
        assert_eq!(
            standardize_address("0x10"),
            "0x0000000000000000000000000000000000000000000000000000000000000010"
        );

        assert_eq!(
            standardize_address("10"),
            "0x0000000000000000000000000000000000000000000000000000000000000010"
        );

        assert_eq!(
            standardize_address("0x123abc"),
            "0x0000000000000000000000000000000000000000000000000000000000123abc"
        );

        assert_eq!(
            standardize_address(
                "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
            ),
            "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
        );
    }

    #[test]
    fn test_standardize_address_with_missing_leading_zero() {
        assert_eq!(
            standardize_address(
                "0x234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
            ),
            "0x0234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
        );

        assert_eq!(
            standardize_address("234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"),
            "0x0234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
        );
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-61)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
}
```
