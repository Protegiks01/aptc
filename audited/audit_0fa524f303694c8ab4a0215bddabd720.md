# Audit Report

## Title
Protocol Encoding Mismatch in Reliable Broadcast Causing Consensus Divergence

## Summary
The reliable broadcast implementation in JWK consensus (and other consensus modules) uses `to_bytes_by_protocol()` to serialize messages using **DirectSend protocols**, but then sends those bytes via `send_rpc_raw()` which negotiates **RPC protocols**. When validators have mismatched protocol support (common during upgrades), this causes messages serialized with one encoding (e.g., plain BCS) to be tagged and deserialized with a different encoding (e.g., compressed BCS), leading to deserialization failures or consensus divergence.

## Finding Description
The vulnerability exists in the interaction between `NetworkClient::to_bytes_by_protocol()` and `NetworkClient::send_to_peer_rpc_raw()`: [1](#0-0) 

The `to_bytes_by_protocol()` method calls `group_peers_by_protocol()`: [2](#0-1) 

This uses `self.direct_send_protocols_and_preferences` at line 169 to determine which protocol to use for serialization.

However, `send_to_peer_rpc_raw()` uses a different protocol list: [3](#0-2) 

At line 282, it uses `self.rpc_protocols_and_preferences` to determine the protocol for sending.

The reliable broadcast library exploits this mismatch: [4](#0-3) 

At lines 131-135, messages are pre-serialized using `to_bytes_by_protocol()` (DirectSend protocols). At lines 148-149, those bytes are sent via `send_rb_rpc_raw()` which uses RPC protocols.

**Attack Scenario:**

1. Validator A supports: `[JWKConsensusDirectSendBcs, JWKConsensusRpcCompressed]`
2. Validator B's preferences are:
   - DirectSend: `[JWKConsensusDirectSendCompressed, JWKConsensusDirectSendBcs, JWKConsensusDirectSendJson]`
   - RPC: `[JWKConsensusRpcCompressed, JWKConsensusRpcBcs, JWKConsensusRpcJson]` [5](#0-4) 

3. When multicasting to A:
   - `to_bytes_by_protocol()` selects `JWKConsensusDirectSendBcs` → serializes with **plain BCS**
   - `send_rpc_raw()` selects `JWKConsensusRpcCompressed` → tags as **compressed BCS**
   
4. Validator A receives bytes tagged as `JWKConsensusRpcCompressed` but containing plain BCS data

5. Protocol deserialization logic attempts decompression: [6](#0-5) [7](#0-6) 

6. Decompression attempts to read LZ4 header from plain BCS data: [8](#0-7) 

7. Result: Either decompression error (most likely) or garbage data (rare but possible)

This breaks the **Deterministic Execution** invariant: validators with different protocol configurations will process the same message differently.

## Impact Explanation

**High to Critical Severity:**

**Most Likely Outcome (High):** Decompression fails with error, causing RPC failures. Reliable broadcast retries with backoff, but if multiple validators have mismatched configurations, consensus can stall indefinitely. This constitutes "Validator node slowdowns" and "Significant protocol violations" (High severity).

**Rare but Possible Outcome (Critical):** If the first 4 bytes of BCS data happen to form a valid size prefix, decompression might succeed with garbage data. Different validators could deserialize different message contents based on their protocol preferences, causing **consensus divergence** (Critical severity: "Consensus/Safety violations").

## Likelihood Explanation

**High Likelihood** during protocol upgrades when validators run different software versions with different protocol support. This is not an attack requiring malicious behavior—it's a natural consequence of the code design.

During upgrades:
- Old validators might support only `DirectSendBcs` and `RpcBcs`
- New validators support `DirectSendCompressed` and `RpcCompressed` 
- The preference lists differ, triggering the mismatch

The bug affects all reliable broadcast users: [9](#0-8) 

Similar patterns exist in DKG and consensus modules.

## Recommendation

**Fix:** Make `to_bytes_by_protocol()` use the same protocol preference list as the actual sending method. Since these bytes are used for RPCs, they should be serialized using RPC protocols:

```rust
fn to_bytes_by_protocol(
    &self,
    peers: Vec<PeerNetworkId>,
    message: Message,
) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
    let mut bytes_per_peer = HashMap::new();
    for peer in peers {
        // Use RPC protocols for RPC messages!
        let protocol_id = self.get_preferred_protocol_for_peer(
            &peer, 
            &self.rpc_protocols_and_preferences  // Changed from direct_send
        )?;
        let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
        bytes_per_peer.insert(peer, bytes);
    }
    Ok(bytes_per_peer)
}
```

Alternatively, add a parameter to specify which protocol list to use, or create separate methods for DirectSend and RPC serialization.

## Proof of Concept

```rust
#[test]
fn test_protocol_mismatch_in_reliable_broadcast() {
    use aptos_network::protocols::wire::handshake::v1::ProtocolId;
    
    // Simulate validator with mismatched protocol support
    let peer_protocols = vec![
        ProtocolId::JWKConsensusDirectSendBcs,  // Supports plain BCS for DirectSend
        ProtocolId::JWKConsensusRpcCompressed,   // Supports compressed for RPC
    ];
    
    let sender_direct_prefs = vec![
        ProtocolId::JWKConsensusDirectSendCompressed,
        ProtocolId::JWKConsensusDirectSendBcs,
    ];
    
    let sender_rpc_prefs = vec![
        ProtocolId::JWKConsensusRpcCompressed,
        ProtocolId::JWKConsensusRpcBcs,
    ];
    
    // Simulate protocol selection
    let direct_protocol = select_preferred(&peer_protocols, &sender_direct_prefs);
    assert_eq!(direct_protocol, ProtocolId::JWKConsensusDirectSendBcs);
    
    let rpc_protocol = select_preferred(&peer_protocols, &sender_rpc_prefs);
    assert_eq!(rpc_protocol, ProtocolId::JWKConsensusRpcCompressed);
    
    // Create test message
    let test_msg = create_test_jwk_message();
    
    // Serialize using DirectSend protocol (plain BCS)
    let serialized_bytes = direct_protocol.to_bytes(&test_msg).unwrap();
    
    // Attempt to deserialize using RPC protocol (compressed BCS)
    let result = rpc_protocol.from_bytes::<JWKConsensusMsg>(&serialized_bytes);
    
    // This will fail with decompression error
    assert!(result.is_err(), "Should fail to decompress plain BCS as compressed");
}
```

## Notes

This vulnerability affects multiple consensus modules (JWK consensus, DKG, regular consensus) that use the reliable broadcast pattern. The issue is particularly dangerous during protocol upgrades when validator software versions diverge. The fix should be applied consistently across all affected modules to prevent consensus failures.

### Citations

**File:** network/framework/src/application/interface.rs (L160-191)
```rust
    fn group_peers_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
    ) -> HashMap<ProtocolId, Vec<PeerNetworkId>> {
        // Sort peers by protocol
        let mut peers_per_protocol = HashMap::new();
        let mut peers_without_a_protocol = vec![];
        for peer in peers {
            match self
                .get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences)
            {
                Ok(protocol) => peers_per_protocol
                    .entry(protocol)
                    .or_insert_with(Vec::new)
                    .push(peer),
                Err(_) => peers_without_a_protocol.push(peer),
            }
        }

        // We only periodically log any unavailable peers (to prevent log spamming)
        if !peers_without_a_protocol.is_empty() {
            sample!(
                SampleRate::Duration(Duration::from_secs(10)),
                warn!(
                    "[sampled] Unavailable peers (without a common network protocol): {:?}",
                    peers_without_a_protocol
                )
            );
        }

        peers_per_protocol
    }
```

**File:** network/framework/src/application/interface.rs (L274-286)
```rust
    async fn send_to_peer_rpc_raw(
        &self,
        message: Bytes,
        rpc_timeout: Duration,
        peer: PeerNetworkId,
    ) -> Result<Message, Error> {
        let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
        let rpc_protocol_id =
            self.get_preferred_protocol_for_peer(&peer, &self.rpc_protocols_and_preferences)?;
        Ok(network_sender
            .send_rpc_raw(peer.peer_id(), rpc_protocol_id, message, rpc_timeout)
            .await?)
    }
```

**File:** network/framework/src/application/interface.rs (L288-304)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
        message: Message,
    ) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);
        // Convert to bytes per protocol
        let mut bytes_per_peer = HashMap::new();
        for (protocol_id, peers) in peers_per_protocol {
            let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
            for peer in peers {
                bytes_per_peer.insert(peer, bytes.clone());
            }
        }

        Ok(bytes_per_peer)
    }
```

**File:** crates/reliable-broadcast/src/lib.rs (L127-156)
```rust
            let peers = receivers.clone();
            let sender = network_sender.clone();
            let message_clone = message.clone();
            let protocols = Arc::new(
                tokio::task::spawn_blocking(move || {
                    sender.to_bytes_by_protocol(peers, message_clone)
                })
                .await??,
            );

            let send_message = |receiver, sleep_duration: Option<Duration>| {
                let network_sender = network_sender.clone();
                let time_service = time_service.clone();
                let message = message.clone();
                let protocols = protocols.clone();
                async move {
                    if let Some(duration) = sleep_duration {
                        time_service.sleep(duration).await;
                    }
                    let send_fut = if receiver == self_author {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    } else if let Some(raw_message) = protocols.get(&receiver).cloned() {
                        network_sender.send_rb_rpc_raw(receiver, raw_message, rpc_timeout_duration)
                    } else {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    };
                    (receiver, send_fut.await)
                }
                .boxed()
            };
```

**File:** crates/aptos-jwk-consensus/src/network_interface.rs (L14-26)
```rust
/// Supported protocols in preferred order (from highest priority to lowest).
pub const DIRECT_SEND: &[ProtocolId] = &[
    ProtocolId::JWKConsensusDirectSendCompressed,
    ProtocolId::JWKConsensusDirectSendBcs,
    ProtocolId::JWKConsensusDirectSendJson,
];

/// Supported protocols in preferred order (from highest priority to lowest).
pub const RPC: &[ProtocolId] = &[
    ProtocolId::JWKConsensusRpcCompressed,
    ProtocolId::JWKConsensusRpcBcs,
    ProtocolId::JWKConsensusRpcJson,
];
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L156-172)
```rust
    fn encoding(self) -> Encoding {
        match self {
            ProtocolId::ConsensusDirectSendJson | ProtocolId::ConsensusRpcJson => Encoding::Json,
            ProtocolId::ConsensusDirectSendCompressed | ProtocolId::ConsensusRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::MempoolDirectSend => Encoding::CompressedBcs(USER_INPUT_RECURSION_LIMIT),
            ProtocolId::MempoolRpc => Encoding::Bcs(USER_INPUT_RECURSION_LIMIT),
            _ => Encoding::Bcs(RECURSION_LIMIT),
        }
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L226-252)
```rust
    pub fn from_bytes<T: DeserializeOwned>(&self, bytes: &[u8]) -> anyhow::Result<T> {
        // Start the deserialization timer
        let deserialization_timer = start_serialization_timer(*self, DESERIALIZATION_LABEL);

        // Deserialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_decode(bytes, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let raw_bytes = aptos_compression::decompress(
                    &bytes.to_vec(),
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow! {"{:?}", e})?;
                self.bcs_decode(&raw_bytes, limit)
            },
            Encoding::Json => serde_json::from_slice(bytes).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if deserialization was successful
        if result.is_ok() {
            deserialization_timer.observe_duration();
        }

        result
    }
```

**File:** crates/aptos-compression/src/lib.rs (L92-121)
```rust
pub fn decompress(
    compressed_data: &CompressedData,
    client: CompressionClient,
    max_size: usize,
) -> Result<Vec<u8>, Error> {
    // Start the decompression timer
    let start_time = Instant::now();

    // Check size of the data and initialize raw_data
    let decompressed_size = match get_decompressed_size(compressed_data, max_size) {
        Ok(size) => size,
        Err(error) => {
            let error_string = format!("Failed to get decompressed size: {}", error);
            return create_decompression_error(&client, error_string);
        },
    };
    let mut raw_data = vec![0u8; decompressed_size];

    // Decompress the data
    if let Err(error) = lz4::block::decompress_to_buffer(compressed_data, None, &mut raw_data) {
        let error_string = format!("Failed to decompress the data: {}", error);
        return create_decompression_error(&client, error_string);
    };

    // Stop the timer and update the metrics
    metrics::observe_decompression_operation_time(&client, start_time);
    metrics::update_decompression_metrics(&client, compressed_data, &raw_data);

    Ok(raw_data)
}
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L59-71)
```rust
#[async_trait::async_trait]
impl RBNetworkSender<JWKConsensusMsg> for NetworkSender {
    async fn send_rb_rpc_raw(
        &self,
        receiver: AccountAddress,
        raw_message: Bytes,
        timeout: Duration,
    ) -> anyhow::Result<JWKConsensusMsg> {
        Ok(self
            .jwk_network_client
            .send_rpc_raw(receiver, raw_message, timeout)
            .await?)
    }
```
