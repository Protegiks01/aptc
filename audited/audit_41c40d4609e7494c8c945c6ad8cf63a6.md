# Audit Report

## Title
Unvalidated Gas Schedule Updates Enable Network-Wide Denial of Service via Mempool Flooding

## Summary
The gas schedule update mechanism lacks validation of gas parameter values, allowing governance proposals to set critical gas costs (e.g., `min_transaction_gas_units`, instruction costs) to extremely low or zero values. This enables attackers to create millions of ultra-cheap valid transactions that flood the mempool, blocking legitimate transactions and causing network-wide denial of service.

## Finding Description

The Aptos blockchain allows gas schedule updates through governance proposals. The `generate_script()` function in the gas schedule updator creates scripts that call `gas_schedule::set_gas_schedule()` to update on-chain gas parameters. [1](#0-0) 

However, the gas schedule validation contains only TODO comments with no actual implementation: [2](#0-1) [3](#0-2) 

The parsing logic only validates that parameter keys exist, not that values are within safe bounds: [4](#0-3) 

**Attack Scenario:**

1. A governance proposal (malicious or accidentally misconfigured) sets `min_transaction_gas_units` to 100 (from 2,760,000) and `intrinsic_gas_per_byte` to 1 (from 1,158).

2. Transaction validation now accepts transactions with ~27,600x lower gas costs: [5](#0-4) 

3. Attackers create millions of cheap valid transactions that pass all validation checks.

4. Mempool has finite capacity (2 million transactions, 2GB): [6](#0-5) 

5. When mempool is full, it only evicts non-ready transactions from the parking lot: [7](#0-6) 

6. Spam transactions using orderless (nonce-based) replay protectors are always "ready" and cannot be evicted, permanently occupying mempool slots.

7. Legitimate transactions are rejected with `MempoolIsFull` errors, causing network-wide DoS.

**Invariant Violations:**
- **Resource Limits**: Gas limits can be subverted to near-zero values
- **Move VM Safety**: Bytecode execution no longer respects proper gas constraints
- **Transaction Validation**: Spam transactions are valid under manipulated parameters

## Impact Explanation

This vulnerability meets **HIGH severity** criteria per the Aptos bug bounty program:

- **Validator node slowdowns**: Nodes must process and reject millions of incoming spam transactions
- **Significant protocol violations**: Core gas metering invariants are broken
- **Network availability impact**: Legitimate users cannot submit transactions when mempool is full

While not causing permanent loss of funds or consensus safety violations (Critical severity), it enables sustained network degradation that requires governance intervention to fix (reverting the gas schedule), meeting the High severity threshold.

## Likelihood Explanation

**Likelihood: MEDIUM-LOW**

The attack requires:
1. A governance proposal with malicious/misconfigured gas parameters to pass voting
2. This could occur through:
   - Malicious governance participants (requires significant stake compromise)
   - Accidental misconfiguration in upgrade proposals (more likely)
   - Social engineering of governance voters

Once deployed, execution is trivial:
- Attacker submits millions of cheap transactions via standard RPC
- Cost is minimal due to manipulated gas costs
- Effect is immediate and network-wide

The primary barrier is the governance requirement, but the lack of validation means even well-intentioned upgrades could accidentally introduce dangerous gas configurations. The presence of multiple TODO comments suggests this was recognized as needed but never implemented.

## Recommendation

Implement comprehensive gas schedule validation in `gas_schedule.move`:

**Recommended Fix:**

1. Define minimum bounds for critical gas parameters:
```move
// In gas_schedule.move, replace TODO comments with actual validation:

const EGAS_PARAMETER_OUT_OF_BOUNDS: u64 = 4;
const MIN_TRANSACTION_GAS_UNITS: u64 = 1_000_000; // Minimum 1M gas units
const MIN_INTRINSIC_GAS_PER_BYTE: u64 = 100; // Minimum per-byte cost
const MIN_STORAGE_IO_PER_SLOT: u64 = 10_000; // Minimum storage costs

fun validate_gas_schedule(gas_schedule: &GasScheduleV2) {
    // Validate transaction parameters
    assert!(
        get_gas_param(gas_schedule, b"txn.min_transaction_gas_units") >= MIN_TRANSACTION_GAS_UNITS,
        error::invalid_argument(EGAS_PARAMETER_OUT_OF_BOUNDS)
    );
    assert!(
        get_gas_param(gas_schedule, b"txn.intrinsic_gas_per_byte") >= MIN_INTRINSIC_GAS_PER_BYTE,
        error::invalid_argument(EGAS_PARAMETER_OUT_OF_BOUNDS)
    );
    // Add bounds for all critical parameters...
}
```

2. Call validation in all gas schedule update functions: [8](#0-7) 

3. Add bounds checking in the Rust gas parameter parsing to provide defense in depth.

4. Consider implementing per-parameter validation ranges in the gas schedule definition itself.

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_dos_test {
    use aptos_framework::gas_schedule;
    use aptos_framework::account;
    use std::vector;
    use std::bcs;

    #[test(aptos_framework = @0x1)]
    fun test_malicious_gas_schedule_enables_spam(aptos_framework: signer) {
        // Create malicious gas schedule with extremely low costs
        let malicious_entries = vector::empty<gas_schedule::GasEntry>();
        
        // Set min_transaction_gas_units to 100 (from 2,760,000)
        vector::push_back(&mut malicious_entries, gas_schedule::GasEntry {
            key: string::utf8(b"txn.min_transaction_gas_units"),
            val: 100, // 27,600x cheaper!
        });
        
        // Set intrinsic_gas_per_byte to 1 (from 1,158)
        vector::push_back(&mut malicious_entries, gas_schedule::GasEntry {
            key: string::utf8(b"txn.intrinsic_gas_per_byte"),
            val: 1, // ~1,158x cheaper!
        });
        
        // ... add other required parameters ...
        
        let malicious_schedule = gas_schedule::GasScheduleV2 {
            feature_version: 100,
            entries: malicious_entries,
        };
        
        let malicious_blob = bcs::to_bytes(&malicious_schedule);
        
        // This should fail with validation error, but currently succeeds:
        // gas_schedule::set_gas_schedule(&aptos_framework, malicious_blob);
        
        // After setting malicious schedule, attacker can create millions
        // of transactions with max_gas_amount = 100 (ultra cheap!)
        // Each transaction is valid and enters mempool
        // Mempool fills up with 2M spam transactions
        // Legitimate transactions are rejected with MempoolIsFull
    }
}
```

**Notes:**

The vulnerability stems from incomplete implementation indicated by TODO comments at lines 47, 67, and 75 in `gas_schedule.move`. The system was designed to have validation but it was never implemented. This represents a critical gap in defense-in-depth - even though governance is trusted, the system should prevent catastrophic misconfigurations that violate fundamental protocol invariants. The attack is realistic because governance upgrades are complex and misconfiguration is possible, especially as gas parameters evolve across feature versions.

### Citations

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L39-96)
```rust
fn generate_script(gas_schedule: &GasScheduleV2) -> Result<String> {
    let gas_schedule_blob = bcs::to_bytes(gas_schedule).unwrap();

    assert!(gas_schedule_blob.len() < 65536);

    let writer = CodeWriter::new(Loc::default());
    emitln!(writer, "// Gas schedule update proposal\n");

    emitln!(
        writer,
        "// Feature version: {}",
        gas_schedule.feature_version
    );
    emitln!(writer, "//");
    emitln!(writer, "// Entries:");
    let max_len = gas_schedule
        .entries
        .iter()
        .fold(0, |acc, (name, _)| usize::max(acc, name.len()));
    for (name, val) in &gas_schedule.entries {
        let name_with_spaces = format!("{}{}", name, " ".repeat(max_len - name.len()));
        emitln!(writer, "//     {} : {}", name_with_spaces, val);
    }
    emitln!(writer);

    emitln!(writer, "script {");
    writer.indent();

    emitln!(writer, "use aptos_framework::aptos_governance;");
    emitln!(writer, "use aptos_framework::gas_schedule;");
    emitln!(writer);

    emitln!(writer, "fun main(proposal_id: u64) {");
    writer.indent();

    emitln!(
        writer,
        "let framework_signer = aptos_governance::resolve(proposal_id, @{});\n",
        AccountAddress::ONE,
    );

    emit!(writer, "let gas_schedule_blob: vector<u8> = ");
    generate_blob(&writer, &gas_schedule_blob);
    emitln!(writer, ";\n");

    emitln!(
        writer,
        "gas_schedule::set_gas_schedule(&framework_signer, gas_schedule_blob);"
    );

    writer.unindent();
    emitln!(writer, "}");

    writer.unindent();
    emitln!(writer, "}");

    Ok(writer.process_result(|s| s.to_string()))
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L57-81)
```text
    public fun set_gas_schedule(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasSchedule, GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        chain_status::assert_genesis();

        if (exists<GasScheduleV2>(@aptos_framework)) {
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
        }
        else {
            if (exists<GasSchedule>(@aptos_framework)) {
                _ = move_from<GasSchedule>(@aptos_framework);
            };
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
        };

        // Need to trigger reconfiguration so validator nodes can sync on the updated gas schedule.
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L415-447)
```rust
    fn check_is_full_after_eviction(
        &mut self,
        txn: &MempoolTransaction,
        account_sequence_number: Option<u64>,
    ) -> bool {
        if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
            let now = Instant::now();
            // try to free some space in Mempool from ParkingLot by evicting non-ready txns
            let mut evicted_txns = 0;
            let mut evicted_bytes = 0;
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
            }
```
