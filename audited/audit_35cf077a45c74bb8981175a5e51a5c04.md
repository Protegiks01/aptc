# Audit Report

## Title
Validator Network Address Validation Bypass Allows Self-Induced Network Isolation

## Summary
The `NetworkAddress::from_protocols()` function accepts empty protocol vectors, creating a validation inconsistency with `NetworkAddress::try_from()` which rejects them. This allows validator operators to advertise malformed network addresses through the staking module that serialize successfully but fail deserialization, causing other validators to be unable to connect to them.

## Finding Description

The vulnerability exists due to an inconsistency between two validation paths in the `NetworkAddress` type: [1](#0-0) 

The `from_protocols()` function accepts empty protocol vectors and returns `Ok(Self(protocols))` without validation. However, the deserialization path uses `try_from()` which explicitly rejects empty vectors: [2](#0-1) 

This creates an exploitable validation gap. A malicious validator operator can:

1. Create an empty `NetworkAddress` using `NetworkAddress::from_protocols(vec![]).unwrap()`
2. Serialize it with BCS: `bcs::to_bytes(&vec![empty_address]).unwrap()`
3. Submit these bytes to the staking module via `update_network_and_fullnode_addresses()`

The Move function accepts these bytes without any validation: [3](#0-2) 

The function stores the raw bytes directly without verifying they represent valid network addresses. When other validators attempt to read this configuration during peer discovery, deserialization fails: [4](#0-3) 

The failure is handled by returning an empty address list: [5](#0-4) 

This causes the connectivity manager to mark the validator as ineligible for dialing: [6](#0-5) 

## Impact Explanation

This qualifies as **High Severity** based on the following impacts:

1. **Significant Protocol Violation**: Validators can bypass address validation and store invalid configuration data on-chain that breaks the peer discovery mechanism

2. **Network Connectivity Disruption**: Affected validators become unreachable to other validators, potentially impacting consensus participation and network health

3. **Validation Gap**: The staking module lacks critical input validation, allowing malformed data to be permanently stored in `ValidatorConfig` resources

4. **Cascading Effects**: If multiple validators exploit this, it could degrade network connectivity and consensus performance below acceptable thresholds

While the issue requires validator operator credentials, it represents a fundamental validation flaw that violates the integrity of the network discovery system and could be exploited for denial-of-service against specific validators or the broader network.

## Likelihood Explanation

**Likelihood: Medium**

- Requires validator operator role, limiting the attack surface to existing operators
- Simple to execute - requires only basic Rust coding to create malformed addresses
- No specialized knowledge needed beyond understanding the BCS serialization format
- Could occur accidentally through buggy tooling, or deliberately by malicious/compromised operators
- The validation inconsistency makes this bug easy to trigger unintentionally

## Recommendation

**Fix the validation inconsistency** by making `from_protocols()` reject empty protocol vectors:

```rust
pub fn from_protocols(protocols: Vec<Protocol>) -> Result<Self, ParseError> {
    use Protocol::*;
    
    // Add check for empty protocols at the start
    if protocols.is_empty() {
        return Err(ParseError::EmptyProtocolString);
    }

    let mut iter = protocols.iter();
    let mut p = iter.next();
    
    // Remove the now-unreachable check
    // if p.is_none() {
    //     return Ok(Self(protocols));
    // }

    if !is_network_layer(p) {
        return Err(ParseError::NetworkLayerMissing);
    }
    // ... rest of validation
}
```

**Add validation to the Move staking module** to prevent invalid addresses from being stored:

Add a native function in Rust to validate network address bytes before storing them, and call it from the Move `update_network_and_fullnode_addresses()` function.

## Proof of Concept

```rust
use aptos_types::network_address::NetworkAddress;
use bcs;

fn main() {
    // Step 1: Create empty NetworkAddress - this succeeds due to validation gap
    let empty_addr = NetworkAddress::from_protocols(vec![]).unwrap();
    println!("Created empty NetworkAddress: {:?}", empty_addr);
    
    // Step 2: Serialize into bytes for submission to Move
    let addresses = vec![empty_addr];
    let encoded_bytes = bcs::to_bytes(&addresses).unwrap();
    println!("Serialized bytes: {:?}", encoded_bytes);
    
    // Step 3: Demonstrate deserialization failure
    let deserialize_result: Result<Vec<NetworkAddress>, _> = bcs::from_bytes(&encoded_bytes);
    match deserialize_result {
        Ok(_) => println!("ERROR: Empty address should not deserialize!"),
        Err(e) => println!("Deserialization failed as expected: {}", e),
    }
    
    // This proves that:
    // 1. Empty NetworkAddresses can be created and serialized
    // 2. When deserialized (as other validators would do), they fail
    // 3. This would cause connectivity failures in the validator discovery system
}
```

When other validators read the `ValidatorConfig` and attempt to deserialize these addresses, they receive an empty address list, making the validator unreachable as shown in: [7](#0-6) 

## Notes

The vulnerability represents a **validation inconsistency** that creates an attack surface in the validator network discovery system. While detection mechanisms exist (warnings and metrics), the ability to store invalid data on-chain represents a fundamental validation gap that should be addressed. The fix should ensure consistent validation across all NetworkAddress creation paths and add native validation in the Move staking module to prevent storage of malformed network addresses.

### Citations

**File:** types/src/network_address/mod.rs (L270-272)
```rust
        if p.is_none() {
            return Ok(Self(protocols));
        }
```

**File:** types/src/network_address/mod.rs (L492-493)
```rust
        if value.is_empty() {
            Err(ParseError::EmptyProtocolString)
```

**File:** types/src/network_address/mod.rs (L561-563)
```rust
            Wrapper::deserialize(deserializer)
                .and_then(|v| bcs::from_bytes(&v.0).map_err(de::Error::custom))
                .and_then(|v: Vec<Protocol>| NetworkAddress::try_from(v).map_err(de::Error::custom))
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-971)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;
```

**File:** network/discovery/src/validator_set.rs (L121-140)
```rust
            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();
```

**File:** network/framework/src/connectivity_manager/mod.rs (L260-262)
```rust
    pub fn is_eligible_to_be_dialed(&self) -> bool {
        self.is_eligible() && !self.addrs.is_empty()
    }
```
