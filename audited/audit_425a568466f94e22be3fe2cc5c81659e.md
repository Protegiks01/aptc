# Audit Report

## Title
Optimistic Signature Verification Bypass Enables False Quorum Detection and Consensus Liveness Attack in OrderVote Processing

## Summary
The `verify_order_vote()` function uses optimistic signature verification that skips BLS signature validation when enabled (default: true). Malicious validators can submit OrderVotes with cryptographically invalid signatures that pass initial verification, get counted toward quorum, but fail during aggregation—triggering expensive individual signature verification and causing consensus delays.

## Finding Description

The vulnerability exists in the OrderVote verification flow where optimistic signature verification is employed to improve performance. When `optimistic_sig_verification` is enabled by default, the system defers signature validation until aggregation time. [1](#0-0) 

The verification calls `order_vote.verify()`: [2](#0-1) 

Which delegates to `validator.optimistic_verify()`: [3](#0-2) 

When optimistic verification is enabled and the author is not in the `pessimistic_verify_set`, this function returns `Ok()` **without verifying the signature**. The signature's `is_verified()` flag remains false, but the vote is accepted.

The voting power is then counted toward quorum: [4](#0-3) 

When the system believes quorum is reached, it attempts signature aggregation and verification: [5](#0-4) 

**Attack Path:**

1. Malicious validator creates an OrderVote with an invalid BLS signature (e.g., not a valid subgroup element that deserializes but fails verification)
2. The signature passes deserialization but is cryptographically invalid
3. `verify_order_vote()` is called at network message processing [6](#0-5) 

4. Optimistic verification skips validation and returns `Ok()`
5. The vote is inserted with full voting power counted [7](#0-6) 

6. System detects "quorum reached" based on accumulated voting power including the invalid signature
7. `aggregate_and_verify()` is triggered, aggregation succeeds (aggregation doesn't validate) [8](#0-7) 

8. Multi-signature verification **fails** because the aggregate contains an invalid signature
9. System falls back to expensive individual verification of ALL signatures [9](#0-8) 

10. Invalid signature is detected, validator added to pessimistic set, but damage is done
11. If remaining valid votes don't meet quorum, consensus stalls with `ErrorAggregatingSignature`

**Why This Breaks Security Guarantees:**

This violates the **Cryptographic Correctness** invariant and causes **Consensus Liveness Degradation**. The system incorrectly counts invalid signatures toward quorum, leading to false positive quorum detection. Each malicious validator can force one expensive aggregation failure per epoch before being added to the pessimistic set.

Optimistic verification is enabled by default: [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **HIGH SEVERITY** under Aptos Bug Bounty criteria:

1. **Validator Node Slowdowns**: Forces expensive individual signature verification across all validators when aggregate verification fails. With N validators, this changes O(1) aggregate verification to O(N) individual verifications.

2. **Significant Protocol Violations**: False quorum detection violates the fundamental consensus assumption that accumulated voting power represents valid votes. The system incorrectly believes it has reached consensus threshold.

3. **Liveness Degradation**: Repeated attacks can prevent timely certificate formation. If 10-15 Byzantine validators (well below 1/3 threshold) coordinate to each submit one invalid signature per epoch, they can cause sustained consensus delays without being detected as Byzantine.

4. **Resource Exhaustion**: Each failed aggregation triggers parallel verification of all accumulated signatures, consuming significant CPU resources on validator nodes.

The attack is particularly effective because:
- Default configuration enables the vulnerability
- Each validator gets one "free" attack per epoch before pessimistic verification kicks in
- Multiple malicious validators can coordinate timing to maximize impact
- The attack is undetectable as Byzantine behavior until aggregation fails

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any validator can execute this attack—no special privileges, stake majority, or coordination required for initial exploitation.

2. **Default Configuration**: Optimistic verification is enabled by default, meaning all production Aptos networks are potentially vulnerable.

3. **Simple Attack Vector**: Creating an invalid BLS signature is straightforward—just use a random group element or corrupt a valid signature's bytes.

4. **Per-Epoch Reset**: The `pessimistic_verify_set` protection only lasts for the current validator set, which resets at epoch boundaries. Malicious validators can repeat the attack each epoch.

5. **Economic Incentive**: Validators benefit from slowing down competitors or disrupting consensus during critical periods (e.g., high-value transaction processing, governance votes).

6. **Detection Difficulty**: The attack appears as legitimate consensus participation until aggregation fails, making it hard to distinguish from network issues or honest errors.

## Recommendation

Implement mandatory signature validation before counting voting power toward quorum, even with optimistic verification enabled. The fix should verify signatures before accepting votes, not after aggregation.

**Recommended Fix:**

1. **Immediate verification for quorum calculation**: Modify `optimistic_verify()` to always verify signatures when the vote would contribute to reaching quorum threshold:

```rust
pub fn optimistic_verify<T: Serialize + CryptoHash>(
    &self,
    author: AccountAddress,
    message: &T,
    signature_with_status: &SignatureWithStatus,
) -> std::result::Result<(), VerifyError> {
    if self.get_public_key(&author).is_none() {
        return Err(VerifyError::UnknownAuthor);
    }
    
    // Always verify if not already verified, even in optimistic mode
    // The optimization benefit isn't worth the security risk
    if !signature_with_status.is_verified() {
        self.verify(author, message, signature_with_status.signature())?;
        signature_with_status.set_verified();
    }
    Ok(())
}
```

2. **Alternative: Stricter quorum threshold**: Add a safety margin to quorum voting power to account for potentially invalid optimistic signatures, then verify before final certificate formation.

3. **Enhanced monitoring**: Add metrics to track aggregate verification failures and pessimistic_verify_set growth rate to detect coordinated attacks.

4. **Rate limiting**: Implement per-validator rate limits on order votes that trigger aggregation failures.

The first approach (immediate verification) is recommended as it eliminates the vulnerability entirely while maintaining reasonable performance (individual verification is parallelized).

## Proof of Concept

```rust
#[cfg(test)]
mod test_order_vote_optimistic_bypass {
    use super::*;
    use aptos_consensus_types::{order_vote::OrderVote, quorum_cert::QuorumCert};
    use aptos_crypto::{bls12381, hash::CryptoHash};
    use aptos_types::{
        block_info::BlockInfo, ledger_info::LedgerInfo,
        validator_verifier::random_validator_verifier,
    };
    use consensus::pending_order_votes::{OrderVoteReceptionResult, PendingOrderVotes};

    #[test]
    fn test_invalid_signature_causes_false_quorum() {
        // Setup: Create 4 validators with quorum = 3
        let (signers, mut verifier) = random_validator_verifier(4, Some(3), false);
        verifier.set_optimistic_sig_verification_flag(true);

        let mut pending_order_votes = PendingOrderVotes::new();
        let li = LedgerInfo::new(
            BlockInfo::new(1, 0, HashValue::random(), HashValue::random(), 0, 0, None),
            HashValue::zero(),
        );
        let qc = QuorumCert::dummy();

        // Submit 2 valid votes
        let vote1 = OrderVote::new_with_signature(
            signers[0].author(),
            li.clone(),
            signers[0].sign(&li).unwrap(),
        );
        let vote2 = OrderVote::new_with_signature(
            signers[1].author(),
            li.clone(),
            signers[1].sign(&li).unwrap(),
        );

        assert_eq!(
            pending_order_votes.insert_order_vote(&vote1, &verifier, Some(qc.clone())),
            OrderVoteReceptionResult::VoteAdded(1)
        );
        assert_eq!(
            pending_order_votes.insert_order_vote(&vote2, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(2)
        );

        // ATTACK: Submit invalid signature (dummy signature on wrong message)
        let wrong_message = b"wrong message";
        let invalid_sig = signers[2].sign_arbitrary_message(wrong_message);
        let malicious_vote = OrderVote::new_with_signature(
            signers[2].author(),
            li.clone(),
            invalid_sig,
        );

        // The invalid signature passes optimistic verification
        // and voting power is counted toward quorum (2 + 1 = 3, reaches quorum!)
        let result = pending_order_votes.insert_order_vote(&malicious_vote, &verifier, None);

        // System attempts aggregation thinking quorum is reached
        // but verification FAILS due to invalid signature
        match result {
            OrderVoteReceptionResult::ErrorAggregatingSignature(_) => {
                // Expected: Aggregation fails, expensive individual verification triggered
                println!("Attack successful: False quorum detected, aggregation failed");
                
                // Verify the attacker is now in pessimistic set
                assert!(verifier.pessimistic_verify_set().contains(&signers[2].author()));
            }
            OrderVoteReceptionResult::VoteAdded(power) => {
                // Unexpected: Should have triggered aggregation
                panic!("Should have attempted aggregation at voting power {}", power);
            }
            _ => panic!("Unexpected result: {:?}", result),
        }

        // Even after filtering, we only have 2 valid votes (below quorum of 3)
        // Consensus cannot progress until additional valid votes arrive
        assert!(!pending_order_votes.has_enough_order_votes(&li));
    }
}
```

**Expected Behavior:** The test demonstrates that an invalid signature passes optimistic verification, gets counted toward quorum, triggers aggregation, fails verification, and causes consensus delay. The pessimistic_verify_set grows but the damage is already done.

## Notes

This vulnerability represents a fundamental tension between performance optimization (optimistic verification) and security (immediate validation). The current implementation prioritizes performance but creates a window for consensus disruption attacks. The recommended fix removes the optimization for unverified signatures, which is the correct security tradeoff for a blockchain consensus system where liveness is critical.

The issue is particularly concerning because it affects the **order vote** path, which is used for block ordering in the pipeline consensus. Disrupting order votes can delay block commits and affect finality guarantees across the entire network.

### Citations

**File:** consensus/consensus-types/src/order_vote_msg.rs (L63-67)
```rust
        self.order_vote
            .verify(validator)
            .context("[OrderVoteMsg] OrderVote verification failed")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/order_vote.rs (L83-93)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.ledger_info.consensus_data_hash() == HashValue::zero(),
            "Failed to verify OrderVote. Consensus data hash is not Zero"
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify OrderVote")?;

        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/pending_order_votes.rs (L61-82)
```rust
    pub fn insert_order_vote(
        &mut self,
        order_vote: &OrderVote,
        validator_verifier: &ValidatorVerifier,
        verified_quorum_cert: Option<QuorumCert>,
    ) -> OrderVoteReceptionResult {
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });

```

**File:** consensus/src/pending_order_votes.rs (L111-118)
```rust
                sig_aggregator
                    .add_signature(order_vote.author(), order_vote.signature_with_status());
                match sig_aggregator.check_voting_power(validator_verifier, true) {
                    Ok(aggregated_voting_power) => {
                        assert!(
                            aggregated_voting_power >= validator_verifier.quorum_voting_power(),
                            "QC aggregation should not be triggered if we don't have enough votes to form a QC"
                        );
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/src/round_manager.rs (L156-164)
```rust
            UnverifiedEvent::OrderVoteMsg(v) => {
                if !self_message {
                    v.verify_order_vote(peer_id, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["order_vote"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::OrderVoteMsg(v)
            },
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L69-76)
```rust
    pub fn aggregate(sigs: Vec<Self>) -> Result<Signature> {
        let sigs: Vec<_> = sigs.iter().map(|s| &s.sig).collect();
        let agg_sig = blst::min_pk::AggregateSignature::aggregate(&sigs[..], false)
            .map_err(|e| anyhow!("{:?}", e))?;
        Ok(Signature {
            sig: agg_sig.to_signature(),
        })
    }
```

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```
