# Audit Report

## Title
Frozen Code Objects Can Be Modified by Adding New Mutable Packages via ManagingRefs

## Summary
After a code object is frozen using `freeze_code_object`, the owner can still use the stored `ManagingRefs` to deploy new packages with mutable upgrade policies to the same object address. This violates the immutability guarantee that freezing is intended to provide, allowing modification of supposedly frozen code.

## Finding Description
The `freeze_code_object` function is designed to make code objects immutable by setting all existing packages to `upgrade_policy_immutable()`. [1](#0-0) 

However, the freeze operation only affects **existing** packages in the PackageRegistry. The `ManagingRefs` resource, which contains the `ExtendRef`, persists after freezing and can still be used to call the `upgrade` function. [2](#0-1) 

When `upgrade` is called with a package that has a **different name** from all existing packages, the `publish_package` function's logic treats it as a new package addition rather than an upgrade of existing packages. [3](#0-2) 

The critical issue is that `check_upgradability` is only invoked when the package name matches an existing package. [4](#0-3)  For new packages with different names, only `check_coexistence` is called, which merely verifies that module names don't clashâ€”it does **not** verify upgrade policies. [5](#0-4) 

This allows an attacker (the owner) to:
1. Deploy legitimate code to a code object
2. Freeze the code object to establish trust with users
3. Use the ManagingRefs to deploy a new package with a different name and `upgrade_policy_compat()` (mutable)
4. The new mutable package shares the same address as the frozen code
5. The new package can interact with user resources or capabilities granted to that address

## Impact Explanation
This vulnerability constitutes **Critical Severity** under the Aptos bug bounty program for the following reasons:

**Loss of Funds**: Users who trust frozen code objects may grant capabilities or deposit funds based on audited, frozen code. The owner can then deploy unaudited malicious modules at the same address to steal these funds.

**Breaking Security Guarantees**: The freeze mechanism is explicitly documented to make modules immutable with "no unfreeze function" because "once modules are marked as immutable, they cannot be made mutable again." [6](#0-5)  This vulnerability completely undermines that guarantee.

**Consensus Impact**: If different validators make different trust assumptions about frozen code objects, this could lead to state inconsistencies, though this is a secondary concern.

## Likelihood Explanation
**High Likelihood** of exploitation:

1. **Low Technical Complexity**: The attack requires only calling the standard `upgrade` function with a new package name
2. **Realistic Attack Scenario**: DeFi protocols commonly freeze code to demonstrate commitment. This is a well-established pattern in the ecosystem
3. **High Value Target**: Frozen code objects protecting high-value assets (vaults, bridges, governance) are attractive targets
4. **Owner Incentive**: A compromised owner key or malicious insider could exploit this after establishing user trust

The attack is trivially executable by anyone with access to the owner account's private key.

## Recommendation

Add a check in `publish_package` to prevent adding any new packages to a code object that contains frozen packages:

```move
// In publish_package function, after line 188:
let has_immutable_package = vector::any(&borrow_global<PackageRegistry>(addr).packages, |pack| {
    let pack: &PackageMetadata = pack;
    pack.upgrade_policy == upgrade_policy_immutable()
});

// Before line 192:
if (has_immutable_package) {
    // If any package is immutable, verify we're upgrading an existing package, not adding a new one
    let found_matching_name = vector::any(package_immutable, |old| {
        let old: &PackageMetadata = old;
        old.name == pack.name
    });
    assert!(found_matching_name, error::invalid_argument(EUPGRADE_IMMUTABLE));
}
```

This ensures that once any package in a code object is frozen, only upgrades to existing packages are allowed (which will then fail the immutability check), effectively making the entire code object immutable.

## Proof of Concept

```move
// This test demonstrates adding a new package to a frozen code object
#[test]
fun test_add_package_after_freeze() {
    let mut context = TestContext::new(None, None);
    let acc = context.account.clone();

    // Deploy initial package named "vault"
    assert_success!(context.execute_object_code_action(
        &acc,
        "object_code_deployment.data/pack_vault",
        ObjectCodeAction::Deploy,
    ));

    // Freeze the code object - users now trust it
    assert_success!(context.execute_object_code_action(
        &acc, 
        "", 
        ObjectCodeAction::Freeze
    ));

    // Verify the package is frozen
    let registry = context.read_resource::<PackageRegistry>(
        &context.object_address, 
        PACKAGE_REGISTRY_ACCESS_PATH
    ).unwrap();
    assert_eq!(registry.packages[0].upgrade_policy, UpgradePolicy::immutable());

    // EXPLOIT: Deploy a new package named "backdoor" with different modules
    // This should FAIL but currently SUCCEEDS
    let status = context.execute_object_code_action(
        &acc,
        "object_code_deployment.data/pack_backdoor",  // Different package name, different modules
        ObjectCodeAction::Upgrade,
    );
    
    // Currently this succeeds - it shouldn't!
    assert_success!(status);
    
    // The frozen code object now contains a new mutable package
    let registry = context.read_resource::<PackageRegistry>(
        &context.object_address,
        PACKAGE_REGISTRY_ACCESS_PATH
    ).unwrap();
    assert_eq!(registry.packages.len(), 2);  // Two packages now
    assert_eq!(registry.packages[1].upgrade_policy, UpgradePolicy::compat());  // New package is mutable!
}
```

## Notes

This vulnerability specifically exploits the gap between the semantic intent of "freezing" code (making it completely immutable) and the implementation (which only prevents modification of existing packages but not addition of new ones). The `ManagingRefs` resource remains functional after freezing, enabling this bypass.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L192-202)
```text
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L240-243)
```text
        vector::for_each_mut(&mut registry.packages, |pack| {
            let package: &mut PackageMetadata = pack;
            package.upgrade_policy = upgrade_policy_immutable();
        });
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L265-268)
```text
    fun check_upgradability(
        old_pack: &PackageMetadata, new_pack: &PackageMetadata, new_modules: &vector<String>) {
        assert!(old_pack.upgrade_policy.policy < upgrade_policy_immutable().policy,
            error::invalid_argument(EUPGRADE_IMMUTABLE));
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L282-293)
```text
    fun check_coexistence(old_pack: &PackageMetadata, new_modules: &vector<String>) {
        // The modules introduced by each package must not overlap with `names`.
        vector::for_each_ref(&old_pack.modules, |old_mod| {
            let old_mod: &ModuleMetadata = old_mod;
            let j = 0;
            while (j < vector::length(new_modules)) {
                let name = vector::borrow(new_modules, j);
                assert!(&old_mod.name != name, error::already_exists(EMODULE_NAME_CLASH));
                j = j + 1;
            };
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object_code_deployment.move (L29-30)
```text
/// Note: There is no unfreeze function as this gives no benefit if the user can freeze/unfreeze modules at will.
///       Once modules are marked as immutable, they cannot be made mutable again.
```

**File:** aptos-move/framework/aptos-framework/sources/object_code_deployment.move (L57-60)
```text
    struct ManagingRefs has key {
        /// We need to keep the extend ref to be able to generate the signer to upgrade existing code.
        extend_ref: ExtendRef,
    }
```
