# Audit Report

## Title
VFN Identification Through Public Inspection Service Endpoint Enables Targeted Infrastructure Attacks

## Summary
The inspection service's `/identity_information` endpoint publicly exposes network identifiers that allow attackers to distinguish Validator Full Nodes (VFNs) from Public Full Nodes (PFNs). This information disclosure enables targeted attacks on critical validator infrastructure, as VFNs serve as the trusted bridge between validators and the public network.

## Finding Description

The `get_identity_information()` function in the inspection service exposes the `network_id` for all configured fullnode networks without any access control or sanitization for VFNs. [1](#0-0) 

VFNs are configured with two distinct fullnode networks: a public network (`NetworkId::Public`) and a private VFN network (`NetworkId::Vfn`). Regular PFNs only have public networks. [2](#0-1) 

The `NetworkId` enum defines distinct values, with `Vfn` displaying as "vfn" via the `as_str()` method: [3](#0-2) [4](#0-3) 

The inspection service is publicly accessible by default, binding to `0.0.0.0:9101` with `expose_identity_information` enabled: [5](#0-4) 

Critically, while the config sanitizer prevents mainnet validators from exposing the configuration endpoint, **there is no sanitizer check preventing VFNs from exposing identity information**: [6](#0-5) 

**Attack Scenario:**

1. Attacker scans fullnodes on port 9101 and sends: `GET http://<node_ip>:9101/identity_information`
2. Response containing `"Fullnode network (vfn)"` identifies a VFN
3. Response with only `"Fullnode network (Public)"` identifies a regular PFN
4. Attacker now has a list of VFNs to target with:
   - DDoS attacks to disrupt validator connectivity
   - Sophisticated exploitation attempts on trusted infrastructure
   - Network reconnaissance and topology mapping

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty program criteria:

- **"Validator node slowdowns"**: VFNs are critical infrastructure that validators depend on for network connectivity. The Aptos network documentation explicitly states that VFNs serve as the connection point between validators and the public network, prioritizing connections from trusted peers. [7](#0-6) 

- **"Significant protocol violations"**: Exposing infrastructure topology violates security principles. By enabling attackers to identify and target VFNs specifically, this creates an asymmetric advantage for malicious actors.

- **Information disclosure enabling targeted attacks**: While general network-level DoS is out of scope, this vulnerability specifically enables **targeted** attacks on critical validator infrastructure, which falls within scope as it can lead to validator slowdowns and network degradation.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Minimal - any attacker with network access can query the public endpoint
- **Technical Complexity**: Trivial - requires only a simple HTTP GET request
- **Default Configuration**: The endpoint is **enabled by default** for all nodes, and the config optimizer automatically enables it for non-mainnet networks
- **Current Deployment**: Production VFNs likely have this endpoint exposed unless operators explicitly disabled it [8](#0-7) 

## Recommendation

**Immediate Fix**: Add a sanitizer check to prevent VFNs from exposing identity information by default, similar to the existing check for validator configuration endpoints:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Existing check for validator configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
            
            // NEW: Prevent VFNs from exposing identity information on mainnet
            if node_type == NodeType::ValidatorFullnode
                && chain_id.is_mainnet()
                && inspection_service_config.expose_identity_information
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet VFNs should not expose identity information that reveals VFN status!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**Alternative/Additional Fix**: Modify `get_identity_information()` to redact or filter VFN network information:

```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // For each fullnode network, only expose public networks
    for fullnode_network in &node_config.full_node_networks {
        if fullnode_network.network_id.is_public_network() {
            identity_information.push(format!(
                "\t- Fullnode network ({}), peer ID: {}",
                fullnode_network.network_id,
                fullnode_network.peer_id()
            ));
        }
    }

    identity_information.join("\n")
}
```

## Proof of Concept

**Setup**: Deploy a VFN using the default configuration.

**Attack Steps**:

```bash
# 1. Identify potential fullnodes on the network (example IPs)
TARGETS=("203.0.113.10" "203.0.113.20" "203.0.113.30")

# 2. Query the inspection service identity endpoint
for target in "${TARGETS[@]}"; do
    echo "Checking $target..."
    response=$(curl -s "http://$target:9101/identity_information")
    
    # 3. Check if response contains VFN network identifier
    if echo "$response" | grep -q "Fullnode network (vfn)"; then
        echo "[!] VFN IDENTIFIED: $target"
        echo "$response"
    else
        echo "[ ] Regular PFN: $target"
    fi
done
```

**Expected Output for VFN**:
```
Identity Information:
	- Fullnode network (Public), peer ID: <peer_id_1>
	- Fullnode network (vfn), peer ID: <peer_id_2>
```

**Expected Output for Regular PFN**:
```
Identity Information:
	- Fullnode network (Public), peer ID: <peer_id_1>
```

The presence of the `"vfn"` network identifier definitively reveals that the node is a VFN, enabling attackers to create a target list of critical validator infrastructure for subsequent attacks.

## Notes

This vulnerability is particularly concerning because:

1. **Default Configuration Risk**: The endpoint is enabled by default, meaning most VFNs are likely exposed unless operators explicitly disabled it
2. **No Documentation Warning**: There's no clear documentation warning VFN operators about this information disclosure risk
3. **Asymmetric Information**: Attackers gain valuable intelligence about network topology while defenders may not be aware of the exposure
4. **Defense in Depth Violation**: Even though VFNs must be publicly reachable, revealing their VFN status unnecessarily increases attack surface by enabling targeted attacks rather than opportunistic attacks on arbitrary fullnodes

The fix should be backported to all active releases and VFN operators should be notified to either upgrade or manually disable the `expose_identity_information` flag in their configurations.

### Citations

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-52)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** config/src/config/test_data/validator_full_node.yaml (L15-40)
```yaml
# For validator fullnode we setup two network ids, the private "vfn" identity will allow it to connect to the validator node,
# and the public identity will allow it to connects to other fullnodes onchain.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6180"
      discovery_method: "onchain"
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id: "public"
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 1
      network_id:
          private: "vfn"
      seeds:
        00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237:
          addresses:
          - "/ip4/127.0.0.1/tcp/6181/noise-ik/f0274c2774519281a8332d0bb9d8101bd58bc7bb154b38039bc9096ce04e1237/handshake/0"
          role: "Validator"
```

**File:** config/src/network_id.rs (L77-83)
```rust
#[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord, EnumIter)]
#[repr(u8)]
pub enum NetworkId {
    Validator = 0,
    Vfn = 3,
    Public = 4,
}
```

**File:** config/src/network_id.rs (L206-212)
```rust
    pub fn as_str(&self) -> &str {
        match self {
            NetworkId::Validator => "Validator",
            NetworkId::Public => "Public",
            NetworkId::Vfn => VFN_NETWORK,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L81-105)
```rust
        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }
```

**File:** network/README.md (L36-39)
```markdown
In contrast, Validator Full Node (VFNs) servers will only prioritize connections
from more trusted peers in the on-chain discovery set; they will still service
any public clients. Public Full Nodes (PFNs) connecting to VFNs will always
authenticate the VFN server using the available discovery information.
```
