# Audit Report

## Title
Indexer gRPC Service Denial of Service via Unvalidated Timestamp Nanos Field

## Summary
The `parse_timestamp()` function does not validate that `ts.nanos` is within the valid range (0-999999999) before casting to u32, allowing malformed protobuf data to cause panic-based denial of service in the indexer gRPC data service.

## Finding Description
The `parse_timestamp()` function performs an unchecked cast of the `nanos` field from `i32` to `u32` without validating it falls within the valid range specified by the protobuf definition. [1](#0-0) 

The protobuf specification explicitly requires `nanos` to be in range [0, 999,999,999]: [2](#0-1) 

However, since `nanos` is declared as `int32`, it can contain values outside this range. When an out-of-range value is cast to `u32` and passed to `chrono::NaiveDateTime::from_timestamp_opt()`, it returns `None`, causing a panic.

The vulnerability manifests in the following execution path:

1. Transactions are deserialized from Redis cache or file store: [3](#0-2) 

2. Timestamps are extracted and passed to logging: [4](#0-3) 

3. The `log_grpc_step()` function calls `timestamp_to_iso()`: [5](#0-4) 

4. Which invokes the vulnerable `parse_timestamp()`: [6](#0-5) 

An attacker with write access to Redis cache or cloud storage (S3/GCS) could inject a malformed `Transaction` protobuf with `timestamp.nanos = -1` (which becomes 4,294,967,295 as u32) or any value > 999,999,999, triggering the panic.

## Impact Explanation
This qualifies as **Medium Severity** per the Aptos bug bounty criteria under "API crashes". When triggered, it causes:

- Crash of the data service task processing the malformed transaction
- Potential cascading failures if the same malformed data is repeatedly fetched
- Degradation or unavailability of the indexer gRPC service

However, this does NOT affect:
- Core blockchain consensus or validator operation  
- Transaction processing or state commitment
- Funds, governance, or staking systems

The impact is limited to the availability of the read-only indexer API service, which is built on top of the blockchain and is not part of the critical consensus path.

## Likelihood Explanation
**Likelihood: Low to Medium**

Exploitation requires one of:
1. **Write access to Redis cache** - Infrastructure-level compromise
2. **Write access to file store (S3/GCS)** - Cloud infrastructure compromise  
3. **Compromised fullnode** - Sending malformed protobuf data

In normal operation, timestamps are always created with valid values: [7](#0-6) 

The `subsec_nanos()` method guarantees values in [0, 999,999,999], so internally created timestamps are always valid.

## Recommendation
Add validation before the cast to ensure defensive programming against malformed external data:

```rust
pub fn parse_timestamp(ts: &Timestamp, version: i64) -> chrono::NaiveDateTime {
    // Validate nanos is in valid range [0, 999_999_999]
    if ts.nanos < 0 || ts.nanos > 999_999_999 {
        panic!(
            "Invalid timestamp nanos value {} (must be 0-999999999) for version {}",
            ts.nanos, version
        );
    }
    
    #[allow(deprecated)]
    chrono::NaiveDateTime::from_timestamp_opt(ts.seconds, ts.nanos as u32)
        .unwrap_or_else(|| panic!("Could not parse timestamp {:?} for version {}", ts, version))
}
```

Alternatively, use a more graceful error handling approach that logs the error and uses a default timestamp rather than panicking.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::util::timestamp::Timestamp;

    #[test]
    #[should_panic(expected = "Could not parse timestamp")]
    fn test_parse_timestamp_invalid_nanos_negative() {
        let ts = Timestamp {
            seconds: 1700000000,
            nanos: -1, // Invalid: negative value
        };
        parse_timestamp(&ts, 12345);
    }

    #[test]
    #[should_panic(expected = "Could not parse timestamp")]
    fn test_parse_timestamp_invalid_nanos_too_large() {
        let ts = Timestamp {
            seconds: 1700000000,
            nanos: 2_000_000_000, // Invalid: > 999,999,999
        };
        parse_timestamp(&ts, 12345);
    }
}
```

---

**Notes**

While this is technically a valid bug that violates defensive programming principles, its practical exploitability is limited by the requirement for infrastructure-level access. The issue represents a gap in input validation for deserialized protobuf data, but normal operation through the fullnode always produces valid timestamps. This is primarily an operational robustness concern for the indexer service rather than a core blockchain security vulnerability.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L125-128)
```rust
pub fn timestamp_to_iso(timestamp: &Timestamp) -> String {
    let dt = parse_timestamp(timestamp, 0);
    dt.format("%Y-%m-%dT%H:%M:%S%.9fZ").to_string()
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L135-139)
```rust
pub fn parse_timestamp(ts: &Timestamp, version: i64) -> chrono::NaiveDateTime {
    #[allow(deprecated)]
    chrono::NaiveDateTime::from_timestamp_opt(ts.seconds, ts.nanos as u32)
        .unwrap_or_else(|| panic!("Could not parse timestamp {:?} for version {}", ts, version))
}
```

**File:** protos/proto/aptos/util/timestamp/timestamp.proto (L14-18)
```text
  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  int32 nanos = 2;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L142-157)
```rust
    pub fn into_transaction(self) -> Transaction {
        match self {
            CacheEntry::Lz4CompressionProto(bytes) => {
                let mut decompressor = Decoder::new(&bytes[..]).expect("Lz4 decompression failed.");
                let mut decompressed = Vec::new();
                decompressor
                    .read_to_end(&mut decompressed)
                    .expect("Lz4 decompression failed.");
                Transaction::decode(decompressed.as_slice()).expect("proto deserialization failed.")
            },
            CacheEntry::Base64UncompressedProto(bytes) => {
                let bytes: Vec<u8> = base64::decode(bytes).expect("base64 decoding failed.");
                Transaction::decode(bytes.as_slice()).expect("proto deserialization failed.")
            },
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L739-765)
```rust
            let start_version_timestamp = transactions.first().unwrap().timestamp.as_ref();
            let end_version_timestamp = transactions.last().unwrap().timestamp.as_ref();

            log_grpc_step(
                SERVICE_TYPE,
                IndexerGrpcStep::DataServiceDataFetchedCache,
                Some(starting_version as i64),
                Some(starting_version as i64 + num_of_transactions as i64 - 1),
                start_version_timestamp,
                end_version_timestamp,
                Some(duration_in_secs),
                Some(size_in_bytes),
                Some(num_of_transactions as i64),
                Some(&request_metadata),
            );
            log_grpc_step(
                SERVICE_TYPE,
                IndexerGrpcStep::DataServiceTxnsDecoded,
                Some(starting_version as i64),
                Some(starting_version as i64 + num_of_transactions as i64 - 1),
                start_version_timestamp,
                end_version_timestamp,
                Some(decoding_start_time.elapsed().as_secs_f64()),
                Some(size_in_bytes),
                Some(num_of_transactions as i64),
                Some(&request_metadata),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/counters.rs (L284-285)
```rust
    let start_txn_timestamp_iso = start_version_timestamp.map(timestamp_to_iso);
    let end_txn_timestamp_iso = end_version_timestamp.map(timestamp_to_iso);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L562-568)
```rust
pub fn convert_timestamp_usecs(timestamp: u64) -> timestamp::Timestamp {
    let ts = Duration::from_micros(timestamp);
    timestamp::Timestamp {
        seconds: ts.as_secs() as i64,
        nanos: ts.subsec_nanos() as i32,
    }
}
```
