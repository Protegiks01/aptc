# Audit Report

## Title
Staking Contract Creation Allows Invalid Operator Addresses Leading to Dysfunctional Validator Operations

## Summary
The `create_staking_contract` function accepts arbitrary operator addresses without validation, allowing creation of staking contracts with invalid or inaccessible operator addresses. This renders the staking contract unable to perform critical validator operations until manually corrected by the staker.

## Finding Description

The staking contract creation flow lacks operator address validation at multiple critical points:

**1. CLI Layer (Rust):** The `CreateStakingContract::execute()` function accepts any valid `AccountAddress` for the operator parameter without checking if the operator account exists or is accessible. [1](#0-0) 

**2. Move Contract Layer:** The `create_staking_contract_with_coins()` function passes the operator address to `create_stake_pool()` without any validation. [2](#0-1) 

**3. Stake Pool Initialization:** The `create_stake_pool()` function calls `stake::initialize_stake_owner()` which simply stores the operator address. [3](#0-2) 

**4. Operator Assignment:** The `set_operator_with_cap()` function assigns the operator address without validating account existence or accessibility. [4](#0-3) 

**Attack Vector:**
When a user creates a staking contract with an invalid operator address (e.g., typo, non-existent account, or address they don't control), all critical validator operations fail because they require the operator's signature:

- `join_validator_set()` requires: `signer::address_of(operator) == stake_pool.operator_address` [5](#0-4) 

- `rotate_consensus_key()` requires: `signer::address_of(operator) == stake_pool.operator_address` [6](#0-5) 

- `update_network_and_fullnode_addresses()` requires: `signer::address_of(operator) == stake_pool.operator_address` [7](#0-6) 

**Broken Invariant:** The staking system should ensure that validly created staking contracts can perform their intended validator operations. This gap allows creation of permanently dysfunctional contracts (until manual intervention).

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Operational Dysfunction:** The staking contract cannot join the validator set or perform any operator-required functions
2. **Resource Wastage:** Gas spent on contract creation with invalid configuration
3. **Opportunity Cost:** Time lost before discovering and fixing the issue
4. **User Confusion:** No upfront error prevents users from making this mistake

**Mitigation Factor:** The vulnerability is **recoverable** - the staker can use `switch_operator()` to change to a valid operator address, preventing permanent fund loss. [8](#0-7) 

However, this still qualifies as Medium severity because it creates state inconsistencies that require manual intervention to resolve.

## Likelihood Explanation

**High Likelihood:**
- User error is common when manually entering addresses
- No validation prevents incorrect operator addresses
- No clear error message at creation time
- Impact is silent until attempting validator operations
- Realistic scenarios include: address typos, copy-paste errors, using wrong network addresses, specifying addresses without private key access

## Recommendation

Add operator address validation in `create_staking_contract_with_coins()`:

```move
public fun create_staking_contract_with_coins(
    staker: &signer,
    operator: address,
    voter: address,
    coins: Coin<AptosCoin>,
    commission_percentage: u64,
    contract_creation_seed: vector<u8>
): address acquires Store {
    // Existing commission validation
    assert!(
        commission_percentage >= 0 && commission_percentage <= 100,
        error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE)
    );
    
    // ADD: Validate operator account exists
    assert!(
        account::exists_at(operator),
        error::invalid_argument(EINVALID_OPERATOR_ADDRESS)
    );
    
    // ADD: Validate voter account exists  
    assert!(
        account::exists_at(voter),
        error::invalid_argument(EINVALID_VOTER_ADDRESS)
    );
    
    // Continue with existing logic...
}
```

Add corresponding error codes:
```move
const EINVALID_OPERATOR_ADDRESS: u64 = 10;
const EINVALID_VOTER_ADDRESS: u64 = 11;
```

**Note:** With the `default_account_resource` feature flag, `account::exists_at()` returns true for all addresses (implicit accounts), reducing effectiveness. Consider additional validation such as checking for specific resources or requiring prior registration.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, staker = @0x123, invalid_operator = @0x999)]
#[expected_failure(abort_code = 0x50004, location = aptos_framework::stake)]
public fun test_invalid_operator_cannot_join_validator_set(
    aptos_framework: &signer,
    staker: &signer,
    invalid_operator: &signer,
) {
    // Setup framework
    timestamp::set_time_has_started_for_testing(aptos_framework);
    
    // Initialize staker account
    account::create_account_for_test(signer::address_of(staker));
    
    // Create staking contract with invalid_operator address (address we don't control)
    let invalid_operator_addr = @0xDEADBEEF; // Address without private key access
    let voter_addr = signer::address_of(staker);
    
    staking_contract::create_staking_contract(
        staker,
        invalid_operator_addr,  // Invalid operator
        voter_addr,
        100000000000, // 1000 APT
        10, // 10% commission
        vector::empty()
    );
    
    // Get pool address
    let pool_address = staking_contract::stake_pool_address(
        signer::address_of(staker),
        invalid_operator_addr
    );
    
    // Attempt to join validator set as invalid_operator
    // This will FAIL because we cannot sign as @0xDEADBEEF
    // In practice, this call would never succeed
    stake::join_validator_set(invalid_operator, pool_address);
    // Expected failure: ENOT_OPERATOR (0x50004)
}
```

**Execution Flow:**
1. Staker creates staking contract with operator address `0xDEADBEEF`
2. Contract is successfully created (no validation)
3. Operator address `0xDEADBEEF` is stored in `stake_pool.operator_address`
4. When attempting `join_validator_set()`, assertion fails: `signer::address_of(invalid_operator) == stake_pool.operator_address`
5. Contract remains dysfunctional until staker calls `switch_operator()` with valid address

## Notes

This vulnerability demonstrates a defense-in-depth failure where lack of input validation at contract creation time creates operational risks. While recoverable through `switch_operator()`, the missing validation violates the principle of fail-fast and allows users to create dysfunctional staking contracts that cannot fulfill their primary purpose without manual remediation.

### Citations

**File:** crates/aptos/src/stake/mod.rs (L526-549)
```rust
    async fn execute(mut self) -> CliTypedResult<TransactionSummary> {
        let pool_address = default_stake_pool_address(
            self.txn_options.profile_options.account_address()?,
            self.operator,
        );
        prompt_yes_with_override(
            &format!(
                "Creating a new staking contract with pool address 0x{}. Confirm?",
                pool_address
            ),
            self.txn_options.prompt_options,
        )?;

        self.txn_options
            .submit_transaction(aptos_stdlib::staking_contract_create_staking_contract(
                self.operator,
                self.voter,
                self.amount,
                self.commission_percentage,
                vec![],
            ))
            .await
            .map(|inner| inner.into())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L402-447)
```text
    public fun create_staking_contract_with_coins(
        staker: &signer,
        operator: address,
        voter: address,
        coins: Coin<AptosCoin>,
        commission_percentage: u64,
        // Optional seed used when creating the staking contract account.
        contract_creation_seed: vector<u8>
    ): address acquires Store {
        assert!(
            commission_percentage >= 0 && commission_percentage <= 100,
            error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE)
        );
        // The amount should be at least the min_stake_required, so the stake pool will be eligible to join the
        // validator set.
        let (min_stake_required, _) =
            staking_config::get_required_stake(&staking_config::get());
        let principal = coin::value(&coins);
        assert!(
            principal >= min_stake_required,
            error::invalid_argument(EINSUFFICIENT_STAKE_AMOUNT)
        );

        // Initialize Store resource if this is the first time the staker has delegated to anyone.
        let staker_address = signer::address_of(staker);
        if (!exists<Store>(staker_address)) {
            move_to(staker, new_staking_contracts_holder(staker));
        };

        // Cannot create the staking contract if it already exists.
        let store = borrow_global_mut<Store>(staker_address);
        let staking_contracts = &mut store.staking_contracts;
        assert!(
            !simple_map::contains_key(staking_contracts, &operator),
            error::already_exists(ESTAKING_CONTRACT_ALREADY_EXISTS)
        );

        // Initialize the stake pool in a new resource account. This allows the same staker to contract with multiple
        // different operators.
        let (stake_pool_signer, stake_pool_signer_cap, owner_cap) =
            create_stake_pool(
                staker,
                operator,
                voter,
                contract_creation_seed
            );
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L826-866)
```text
    public entry fun switch_operator(
        staker: &signer,
        old_operator: address,
        new_operator: address,
        new_commission_percentage: u64
    ) acquires Store, BeneficiaryForOperator {
        let staker_address = signer::address_of(staker);
        assert_staking_contract_exists(staker_address, old_operator);

        assert!(
            new_commission_percentage <= 100,
            error::invalid_argument(EINVALID_COMMISSION_PERCENTAGE)
        );
        // Merging two existing staking contracts is too complex as we'd need to merge two separate stake pools.
        let store = borrow_global_mut<Store>(staker_address);
        let staking_contracts = &mut store.staking_contracts;
        assert!(
            !simple_map::contains_key(staking_contracts, &new_operator),
            error::invalid_state(ECANT_MERGE_STAKING_CONTRACTS)
        );

        let (_, staking_contract) = simple_map::remove(staking_contracts, &old_operator);
        // Force distribution of any already inactive stake.
        distribute_internal(
            staker_address,
            old_operator,
            &mut staking_contract,
            &mut store.distribute_events
        );

        // For simplicity, we request commission to be paid out first. This avoids having to ensure to staker doesn't
        // withdraw into the commission portion.
        request_commission_internal(
            old_operator,
            &mut staking_contract,
            &mut store.add_distribution_events,
            &mut store.request_commission_events
        );

        // Update the staking contract's commission rate and stake pool's operator.
        stake::set_operator_with_cap(&staking_contract.owner_cap, new_operator);
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1074-1096)
```text
    fun create_stake_pool(
        staker: &signer,
        operator: address,
        voter: address,
        contract_creation_seed: vector<u8>
    ): (signer, SignerCapability, OwnerCapability) {
        // Generate a seed that will be used to create the resource account that hosts the staking contract.
        let seed =
            create_resource_account_seed(
                signer::address_of(staker), operator, contract_creation_seed
            );

        let (stake_pool_signer, stake_pool_signer_cap) =
            account::create_resource_account(staker, seed);
        stake::initialize_stake_owner(&stake_pool_signer, 0, operator, voter);

        // Extract owner_cap from the StakePool, so we have control over it in the staking_contracts flow.
        // This is stored as part of the staking_contract. Thus, the staker would not have direct control over it without
        // going through well-defined functions in this module.
        let owner_cap = stake::extract_owner_cap(&stake_pool_signer);

        (stake_pool_signer, stake_pool_signer_cap, owner_cap)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L759-784)
```text
    public fun set_operator_with_cap(owner_cap: &OwnerCapability, new_operator: address) acquires StakePool {
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        let old_operator = stake_pool.operator_address;
        stake_pool.operator_address = new_operator;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                SetOperator {
                    pool_address,
                    old_operator,
                    new_operator,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.set_operator_events,
                SetOperatorEvent {
                    pool_address,
                    old_operator,
                    new_operator,
                },
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L910-921)
```text
    public entry fun rotate_consensus_key(
        operator: &signer,
        pool_address: address,
        new_consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);

        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-965)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1059-1066)
```text
    public(friend) fun join_validator_set_internal(
        operator: &signer,
        pool_address: address
    ) acquires StakePool, ValidatorConfig, ValidatorSet {
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
```
