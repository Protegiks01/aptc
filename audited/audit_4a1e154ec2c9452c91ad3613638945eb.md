# Audit Report

## Title
Dependency Download Uses Full Git Clones Without Depth Limits Enabling Resource Exhaustion DoS

## Summary
The Move package dependency download mechanism performs full git clones without using shallow clone options (`--depth` flag), allowing malicious package authors to cause disk space exhaustion and excessive bandwidth consumption through repositories with large git histories.

## Finding Description

The Move package build system downloads git dependencies using the `download_deps_for_package()` function, which delegates to `ResolutionGraph::download_dependency_repos()`. This eventually calls `git::clone()` which executes shell git commands without any shallow clone flags or resource limits. [1](#0-0) 

The clone operation uses a bare `git clone` command without `--depth=1` or any other limiting flags: [2](#0-1) 

This full clone behavior is invoked during package resolution: [3](#0-2) 

**Attack Propagation:**
1. Attacker creates a git repository with artificially large history (e.g., committing large binary files repeatedly, then removing them)
2. Attacker publishes a Move package referencing this repository as a dependency
3. When a developer or validator builds a package depending on this malicious package, the build system downloads the entire git history
4. The download consumes excessive disk space (potentially gigabytes) and bandwidth
5. Build process slows dramatically or fails due to resource exhaustion

The code provides no protection against:
- Repositories with gigabytes of history
- Timeout mechanisms for git operations
- Disk space quota enforcement
- Network bandwidth limits [4](#0-3) 

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." While this applies primarily to runtime operations, build-time operations should also have reasonable resource bounds to prevent DoS attacks on development and deployment infrastructure.

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria for the following reasons:

While not directly causing runtime consensus or state issues, this vulnerability can:
- **Prevent validator operators from updating software** by exhausting disk space during builds, potentially blocking critical security patches
- **Hinder Move package deployment** by making the build process extremely slow or impossible
- **Consume significant infrastructure resources** through bandwidth and storage exhaustion

The impact is amplified because:
- The attack is transitive (packages depending on malicious dependencies are affected)
- No warning or size limit is presented to users before download
- The issue affects both local development environments and CI/CD pipelines

However, it does not reach High/Critical severity because:
- It affects build-time, not runtime blockchain operations
- It does not directly compromise consensus, state integrity, or funds
- Mitigation is possible by skipping dependency updates (`--skip-fetch-latest-git-deps`)

## Likelihood Explanation

**Likelihood: Medium-High**

Attack requirements:
- Attacker needs only to create a git repository with large history (trivial)
- Attacker publishes a Move package referencing this repo (low barrier)
- Victims must attempt to build packages with this dependency (common operation)

The attack is:
- **Low complexity**: Creating a bloated git history requires only basic git knowledge
- **No special privileges required**: Any developer can publish packages with dependencies
- **Wide attack surface**: Affects all Move package builds using git dependencies
- **Difficult to detect beforehand**: Users don't see repository size before cloning

The likelihood is somewhat reduced by:
- Dependency chains in Move packages are typically short
- Malicious packages may be identified and removed from common dependency lists
- Build caching reduces repeated impact

## Recommendation

Implement shallow clones with depth limits for dependency downloads:

**Option 1: Use shallow clones (recommended)**
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", "--depth", "1", url, target_path])  // Add shallow clone
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        // ... rest of implementation
}
```

**Option 2: Add timeout and resource limits**
```rust
use std::time::Duration;

pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let mut child = Command::new("timeout")  // Use timeout wrapper
        .args(["300"])  // 5 minute timeout
        .arg("git")
        .args(["clone", "--depth", "1", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()?;
    
    let status = child.wait()?;
    // ... check status
}
```

**Additional hardening:**
- Configure git to disable hooks globally: `git config --global core.hooksPath /dev/null`
- Add disk space checks before cloning
- Implement maximum repository size limits
- Provide user warnings for large downloads

## Proof of Concept

**Step 1: Create malicious repository**
```bash
#!/bin/bash
# Create a repo with artificially large history

mkdir malicious-move-package
cd malicious-move-package
git init

# Create Move.toml
cat > Move.toml << 'EOF'
[package]
name = "MaliciousPackage"
version = "0.1.0"

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-core.git", subdir = "aptos-move/framework/aptos-framework", rev = "main" }
EOF

# Create minimal Move source
mkdir sources
cat > sources/main.move << 'EOF'
module MaliciousPackage::Test {
    public fun dummy() {}
}
EOF

# Commit initial version
git add .
git commit -m "Initial commit"

# Create bloated history (100MB of data, repeated 20 times)
for i in {1..20}; do
    dd if=/dev/urandom of=large_file_$i.bin bs=1M count=100
    git add large_file_$i.bin
    git commit -m "Add large file $i"
    git rm large_file_$i.bin
    git commit -m "Remove large file $i"
done

# Repository now has ~2GB of history but minimal working tree
git push origin main
```

**Step 2: Create victim package that depends on malicious package**
```toml
# Victim Move.toml
[package]
name = "VictimPackage"
version = "0.1.0"

[dependencies]
MaliciousPackage = { git = "https://github.com/attacker/malicious-move-package.git", rev = "main" }
```

**Step 3: Trigger the attack**
```bash
# When victim tries to build their package:
cd victim-package
aptos move compile

# This will download the entire 2GB+ git history, exhausting disk space
# Monitor with: watch -n 1 'du -sh ~/.move'
```

**Expected Result:**
- Download consumes 2GB+ of disk space
- Build process takes significantly longer (or fails with disk full)
- No warning presented to user before download begins
- Subsequent builds are affected if cache is cleared

## Notes

The newer `move-package-cache` implementation using the `git2` library (libgit2) also performs full clones without depth limits [5](#0-4) , though it creates bare repositories which are slightly more efficient. However, the primary Move package build system used by Aptos CLI still relies on the shell-based implementation.

Regarding git hooks: While git does not automatically execute hooks from remote repositories during clone operations (hooks must be installed locally), the use of full clones still presents the resource exhaustion vulnerability described above.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-616)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
        }
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L190-201)
```rust
    pub fn download_deps_for_package<W: Write>(&self, path: &Path, writer: &mut W) -> Result<()> {
        let path = SourcePackageLayout::try_find_root(path)?;
        let toml_manifest =
            self.parse_toml_manifest(path.join(SourcePackageLayout::Manifest.path()))?;
        let mutx = PackageLock::strict_lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        ResolutionGraph::download_dependency_repos(&manifest, self, &path, writer)?;
        mutx.unlock();
        Ok(())
    }
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L160-172)
```rust
            // If the repo does not exist, clone it.
            let mut repo_builder = RepoBuilder::new();
            repo_builder.fetch_options(fetch_options);
            repo_builder.bare(true);

            self.listener.on_repo_clone_start(git_url.as_str());
            let repo = repo_builder
                .clone(git_url.as_str(), &repo_path)
                .map_err(|err| anyhow!("Failed to clone git repo at {}: {}", git_url, err))?;
            self.listener.on_repo_clone_complete(git_url.as_str());

            repo
        };
```
