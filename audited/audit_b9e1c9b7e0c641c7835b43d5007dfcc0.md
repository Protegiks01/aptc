# Audit Report

## Title
Mixed-Version Batch Panic Causes Validator Node Crash During Epoch Transitions

## Summary
The `persist_and_send_digests()` function in the batch coordinator only checks the first batch's version to determine how to process all batches in a request. During epoch transitions when the batch protocol version changes from V1 to V2, a malicious peer can send a mixed-version batch message causing the validator node to panic and crash.

## Finding Description

The vulnerability exists in the `persist_and_send_digests()` function which assumes all batches in a `persist_requests` vector have the same version, but this assumption is not validated. [1](#0-0) 

The function checks only the first batch's version to decide the processing path for ALL batches. However, the `BatchMsg::verify()` method does not validate version consistency across batches. [2](#0-1) 

The batch generator uses a configuration flag `enable_batch_v2` to determine which version to create: [3](#0-2) 

During epoch transitions, this configuration can change, allowing both V1 and V2 batches to coexist in the network. A malicious peer can exploit this by constructing a `ConsensusMsg::BatchMsgV2` containing:
- First batch: `Batch<BatchInfoExt>` with `batch_info` as `BatchInfoExt::V1`
- Subsequent batches: `Batch<BatchInfoExt>` with `batch_info` as `BatchInfoExt::V2`

When this message is processed:
1. Line 102 checks `persist_requests[0].batch_info().is_v2()` which returns `false`
2. The code enters the else branch (line 112)
3. The batches are persisted, correctly generating mixed `SignedBatchInfo<BatchInfoExt>` variants
4. Line 124 attempts to convert ALL signed batch infos to V1: [4](#0-3) 

5. The `TryFrom` implementation ensures only V1 batches can be converted: [5](#0-4) 

6. When a V2 batch is encountered, `try_into()` returns an error and the `.expect()` causes a **panic, crashing the validator node**.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:
- **Validator node crashes**: The panic causes immediate node termination
- **Consensus availability impact**: If multiple validators are crashed simultaneously, the network could lose liveness
- **Significant protocol violation**: The crash prevents the node from participating in consensus

The vulnerability enables a Denial of Service attack on validator nodes during critical epoch transitions when protocol upgrades occur.

## Likelihood Explanation

**Likelihood: High during epoch transitions**

- **Trigger condition**: Occurs when `enable_batch_v2` configuration changes during epoch transitions
- **Attacker requirements**: Any network peer can send batch messages; no special privileges required
- **Exploit complexity**: Low - attacker simply crafts a malicious `BatchMsgV2` with mixed version batches
- **Detection difficulty**: The malicious message passes all verification checks since `BatchMsg::verify()` doesn't validate version consistency

The vulnerability is most exploitable during network upgrades when the batch protocol version is transitioning, making it a high-risk window for attackers.

## Recommendation

Add version consistency validation to prevent mixed-version batches from being processed together. There are two possible fix locations:

**Option 1: Validate in BatchMsg::verify()**
Add a check that all batches in a message have consistent versions:

```rust
// In consensus/src/quorum_store/types.rs, BatchMsg::verify()
// After line 446, add:
if std::any::TypeId::of::<T>() == std::any::TypeId::of::<BatchInfoExt>() {
    let first_is_v2 = self.batches[0].batch_info().is_v2();
    for batch in self.batches.iter().skip(1) {
        ensure!(
            batch.batch_info().is_v2() == first_is_v2,
            "Version mismatch: all batches must have the same protocol version"
        );
    }
}
```

**Option 2: Validate in persist_and_send_digests()**
Add version consistency check before processing:

```rust
// In consensus/src/quorum_store/batch_coordinator.rs, after line 86, add:
if !persist_requests.is_empty() {
    let first_is_v2 = persist_requests[0].batch_info().is_v2();
    for req in persist_requests.iter().skip(1) {
        if req.batch_info().is_v2() != first_is_v2 {
            error!("Mixed version batches detected, dropping request");
            return;
        }
    }
}
```

**Option 1 is preferred** as it prevents malicious messages from entering the system at the earliest validation point.

## Proof of Concept

```rust
// Add to consensus/src/quorum_store/tests/batch_coordinator_test.rs

#[tokio::test]
async fn test_mixed_version_batch_panic() {
    use crate::quorum_store::{
        batch_coordinator::{BatchCoordinator, BatchCoordinatorCommand},
        types::Batch,
    };
    use aptos_consensus_types::proof_of_store::BatchInfoExt;
    use aptos_types::PeerId;
    
    // Setup test environment
    let (coordinator, mut rx) = create_test_batch_coordinator();
    
    // Create mixed-version batches: first is V1, second is V2
    let peer_id = PeerId::random();
    let mut batches = vec![
        Batch::new_v1(/* V1 batch parameters */),
        Batch::new_v2(/* V2 batch parameters with BatchKind::Normal */),
    ];
    
    // Send the mixed-version batch message
    let command = BatchCoordinatorCommand::NewBatches(peer_id, batches);
    
    // This should panic when trying to convert V2 batch to V1
    // Expected panic message: "Batch must be V1 batch"
    coordinator.handle_batches_msg(peer_id, batches).await;
    
    // If we reach here without panic, the vulnerability is not present
    assert!(false, "Expected panic did not occur");
}
```

The test demonstrates that sending a message with the first batch as V1 and subsequent batches as V2 will cause a panic in the `persist_and_send_digests()` function when it attempts to convert the V2 `SignedBatchInfo` to V1.

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-102)
```rust
            if persist_requests[0].batch_info().is_v2() {
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L122-125)
```rust
                    let signed_batch_infos = signed_batch_infos
                        .into_iter()
                        .map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
                        .collect();
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-211)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
        } else {
            Batch::new_v1(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
            )
        }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L520-538)
```rust
impl TryFrom<SignedBatchInfo<BatchInfoExt>> for SignedBatchInfo<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(signed_batch_info: SignedBatchInfo<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(signed_batch_info.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let SignedBatchInfo {
            info,
            signer,
            signature,
        } = signed_batch_info;
        Ok(Self {
            info: info.unpack_info(),
            signer,
            signature,
        })
    }
```
