# Audit Report

## Title
Missing Cryptographic Binding Validation Between PeerId and Public Key in Mutual Authentication Mode

## Summary
The Noise handshake implementation in mutual authentication mode fails to validate that the claimed PeerId cryptographically derives from the authenticated public key, creating an inconsistent security posture compared to non-mutual authentication mode and violating defense-in-depth principles.

## Finding Description
The PeerId-to-public-key binding validation is **inconsistently enforced** between authentication modes:

In **MaybeMutual mode** for untrusted peers, the code correctly validates the cryptographic binding: [1](#0-0) 

However, in **Mutual mode** for trusted peers, this validation is **completely absent**: [2](#0-1) 

The Mutual mode authentication only checks that the public key exists in the trusted peer's key set: [3](#0-2) 

The PeerId is derived deterministically from the last 16 bytes of the x25519 public key: [4](#0-3) 

**Attack Scenario (requires misconfiguration):**
If a validator's trusted peers configuration incorrectly includes a public key K_attacker in `trusted_peers[victim_peer_id].keys` where `victim_peer_id ≠ from_identity_public_key(K_attacker)`, an attacker controlling K_attacker could:

1. Connect to another validator
2. Claim to be `victim_peer_id` in the handshake prologue
3. Authenticate using their own key K_attacker via Noise protocol
4. Pass validation because K_attacker ∈ `trusted_peers[victim_peer_id].keys`
5. Successfully impersonate the victim validator

The Peer structure supports multiple keys per validator: [5](#0-4) 

## Impact Explanation
**Critical Severity** - This violates the fundamental security invariant that PeerId must be cryptographically bound to the identity key. If exploitable through configuration errors or compromised validator set updates, it enables:

- **Validator impersonation** in consensus networks
- **Consensus safety violations** through equivocation or malicious voting
- **Byzantine behavior attribution** to innocent validators
- **Network partition attacks** by disrupting validator communication

However, the attack requires **pre-existing misconfiguration or system compromise** to place the attacker's key in a victim's trusted key set, which significantly limits direct exploitability.

## Likelihood Explanation
**Low Likelihood for Direct Exploitation** - The vulnerability requires preconditions not under an unprivileged attacker's control:

1. Attacker's public key must already exist in `trusted_peers[victim_id].keys`
2. This requires either:
   - Operational misconfiguration by validator operators
   - Compromise of the validator set update mechanism
   - Malicious validator with privileged access

The validator set discovery extracts keys from on-chain network addresses: [6](#0-5) 

An unprivileged external attacker cannot directly exploit this without additional system compromise or configuration errors.

## Recommendation
**Enforce consistent PeerId validation across all authentication modes.** Add the cryptographic binding check to Mutual mode authentication:

```rust
// In authenticate_inbound function or before it's called
fn authenticate_inbound(
    remote_peer_short: ShortHexStr,
    remote_peer_id: PeerId,  // Add this parameter
    peer: &Peer,
    remote_public_key: &x25519::PublicKey,
) -> Result<PeerRole, NoiseHandshakeError> {
    // Validate cryptographic binding FIRST
    let derived_peer_id = aptos_types::account_address::from_identity_public_key(
        *remote_public_key,
    );
    if derived_peer_id != remote_peer_id {
        return Err(NoiseHandshakeError::ClientPeerIdMismatch(
            remote_peer_short,
            remote_peer_id,
            derived_peer_id,
        ));
    }
    
    // Then check key is in trusted set
    if !peer.keys.contains(remote_public_key) {
        return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
            remote_peer_short,
            hex::encode(remote_public_key.as_slice()),
        ));
    }
    Ok(peer.role)
}
```

This provides defense-in-depth by catching configuration errors early and ensuring cryptographic correctness regardless of trust assumptions.

## Proof of Concept
```rust
#[test]
fn test_mutual_auth_peer_id_mismatch_should_fail() {
    use aptos_crypto::x25519::PrivateKey;
    use aptos_types::account_address::from_identity_public_key;
    
    // Create two different key pairs
    let mut rng = ::rand::rngs::StdRng::from_seed(TEST_SEED);
    let (attacker_key, attacker_pubkey) = create_key_pair(&mut rng);
    let (victim_key, victim_pubkey) = create_key_pair(&mut rng);
    
    // Derive correct PeerIds from keys
    let attacker_peer_id = from_identity_public_key(attacker_pubkey);
    let victim_peer_id = from_identity_public_key(victim_pubkey);
    
    // Verify PeerIds are different
    assert_ne!(attacker_peer_id, victim_peer_id);
    
    // Build validator network with MISCONFIGURED trusted peers:
    // victim_peer_id's key set includes attacker_pubkey (configuration error)
    let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Validator]);
    let victim_peer = Peer::new(
        vec![],
        [victim_pubkey, attacker_pubkey].into_iter().collect(), // MISCONFIGURED!
        PeerRole::Validator,
    );
    insert_new_trusted_peers(
        &peers_and_metadata,
        NetworkId::Validator,
        vec![(victim_peer_id, victim_peer)],
    );
    
    // Attacker creates client claiming to be victim
    let mut attacker_client = NoiseUpgrader::new(
        NetworkContext::mock_with_peer_id(victim_peer_id), // Claims victim's PeerId!
        attacker_key,  // But uses attacker's key
        HandshakeAuthMode::mutual(peers_and_metadata.clone()),
    );
    
    // Server with correct configuration
    let server = NoiseUpgrader::new(
        NetworkContext::mock(),
        victim_key,
        HandshakeAuthMode::mutual(peers_and_metadata),
    );
    
    // Attempt handshake - CURRENTLY SUCCEEDS (vulnerability)
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_res, server_res) = block_on(join(
        attacker_client.upgrade_outbound(
            dialer_socket,
            server.network_context.peer_id(),
            victim_pubkey,
            AntiReplayTimestamps::now,
        ),
        server.upgrade_inbound(listener_socket),
    ));
    
    // This should FAIL but currently SUCCEEDS
    // After fix, both should return Err(ClientPeerIdMismatch)
    assert!(client_res.is_err() || server_res.is_err(), 
            "Handshake should fail when PeerId doesn't match public key");
}
```

**Notes:**
- This is a **defense-in-depth failure** rather than a directly exploitable vulnerability by external attackers
- Exploitation requires pre-existing misconfiguration or system compromise to place attacker keys in victim's trusted set
- The inconsistency between Mutual and MaybeMutual validation modes indicates incomplete security design
- The fix provides additional validation to catch configuration errors and enforce cryptographic invariants
- Real-world exploitability is limited by the need for privileged access to validator configuration or compromise of validator set updates

### Citations

**File:** network/framework/src/noise/handshake.rs (L369-383)
```rust
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
```

**File:** network/framework/src/noise/handshake.rs (L394-404)
```rust
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** config/src/config/network_config.rs (L460-464)
```rust
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```
