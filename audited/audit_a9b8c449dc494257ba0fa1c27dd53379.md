# Audit Report

## Title
Environment Variable Injection Leading to Arbitrary Code Execution in Revela Decompiler

## Summary
The `decompile_v1()` function in the Aptos CLI tool executes an external Revela binary with no validation of the binary path. An attacker who can control the `REVELA_EXE` environment variable can cause arbitrary code execution by pointing it to a malicious binary. This vulnerability affects developer environments and CI/CD pipelines using the `aptos move decompile` command.

## Finding Description

The vulnerability exists in a three-step chain:

**Step 1: Unvalidated Environment Variable Reading** [1](#0-0) 

The `get_path()` function directly returns any path specified in the environment variable without validation, signature checking, or path restrictions.

**Step 2: Path Resolution** [2](#0-1) 

The `get_revela_path()` function calls `get_path()` with `REVELA_EXE_ENV` ("REVELA_EXE") as the environment variable name.

**Step 3: Arbitrary Command Execution** [3](#0-2) 

The `decompile_v1()` function uses the path returned by `get_revela_path()` directly in `Command::new()` without any validation, allowing execution of any binary specified by the environment variable.

**Attack Scenario:**

1. Attacker creates malicious binary at `/tmp/evil_binary`
2. Attacker sets or influences victim's environment: `export REVELA_EXE=/tmp/evil_binary`
3. Victim runs: `aptos move decompile --decompiler-version v1 --bytecode-path <file>`
4. Malicious binary executes with victim's privileges

The most realistic exploitation scenarios are:
- **CI/CD Pipeline Injection**: Environment variables injected through workflow parameters or pull requests
- **Shared Development Environments**: Malicious user sets environment variable affecting other users
- **Developer Machine Compromise**: Attacker modifies shell initialization files (.bashrc, .zshrc)

## Impact Explanation

This vulnerability enables **arbitrary code execution** but with important context:

**NOT Critical Severity** because:
- Does not affect blockchain consensus, state integrity, or validator operations
- Validators do not use the decompile command in production
- Does not impact funds, network liveness, or blockchain safety
- This is a CLI developer tool, not a core blockchain component

**Medium to High Severity** because:
- Arbitrary code execution in developer/CI/CD environments
- Potential supply chain attack vector
- No cryptographic validation or integrity checks
- Could compromise developer credentials, source code, or deployment pipelines

This does **not** break any of the 10 critical blockchain invariants (consensus safety, deterministic execution, state consistency, etc.) as it's isolated to CLI tool usage outside the blockchain runtime.

## Likelihood Explanation

**Medium Likelihood** for exploitation:

**Favorable to Attacker:**
- No validation exists - trivial to exploit once environment control achieved
- Common CI/CD systems allow environment variable injection
- Developers often run CLI commands from scripts with inherited environment

**Unfavorable to Attacker:**
- Requires control over victim's execution environment
- Validators and production nodes don't use this command
- Requires victim to use `--decompiler-version v1` (v2 is default)
- Most developer machines have controlled environments

## Recommendation

Implement multiple security controls:

```rust
pub fn get_path(
    name: &str,
    exe_env: &str,
    binary_name: &str,
    exe: &str,
    find_in_path: bool,
) -> Result<PathBuf> {
    // Look at the environment variable first.
    if let Ok(path) = std::env::var(exe_env) {
        let path_buf = PathBuf::from(path);
        
        // SECURITY: Validate the binary before using it
        validate_binary_integrity(&path_buf, name)?;
        
        return Ok(path_buf);
    }
    
    // ... rest of function
}

fn validate_binary_integrity(path: &PathBuf, expected_name: &str) -> Result<()> {
    // 1. Verify file exists and is executable
    if !path.is_file() {
        bail!("Binary path does not point to a file: {:?}", path);
    }
    
    // 2. Check file is executable (Unix-like systems)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = std::fs::metadata(path)?;
        let permissions = metadata.permissions();
        if permissions.mode() & 0o111 == 0 {
            bail!("Binary is not executable: {:?}", path);
        }
    }
    
    // 3. Verify binary signature or checksum (recommended for production)
    // verify_binary_signature(path, expected_name)?;
    
    // 4. Warn user about using custom binary from environment
    eprintln!("WARNING: Using {} from environment variable: {:?}", expected_name, path);
    eprintln!("WARNING: Ensure this binary is from a trusted source.");
    
    Ok(())
}
```

**Additional Recommendations:**
1. Remove environment variable override capability entirely
2. Require explicit `--revela-path` CLI flag with warning
3. Implement cryptographic signature verification for external binaries
4. Document security implications in CLI help text

## Proof of Concept

```bash
#!/bin/bash
# PoC: Arbitrary Code Execution via REVELA_EXE

# Step 1: Create malicious binary
cat > /tmp/evil_revela.sh << 'EOF'
#!/bin/bash
echo "[MALICIOUS] Arbitrary code executed!"
echo "[MALICIOUS] User: $(whoami)"
echo "[MALICIOUS] PWD: $(pwd)"
echo "[MALICIOUS] Arguments: $@"
# Attacker code here: steal keys, exfiltrate data, etc.
exit 0
EOF

chmod +x /tmp/evil_revela.sh

# Step 2: Set environment variable
export REVELA_EXE=/tmp/evil_revela.sh

# Step 3: Run aptos decompile command
# (Requires a valid .mv bytecode file)
echo "module 0x1::test { fun foo() {} }" > /tmp/test.move
# Compile to get bytecode...
# aptos move decompile --decompiler-version v1 --bytecode-path /tmp/test.mv

echo "Environment variable set to: $REVELA_EXE"
echo "When 'aptos move decompile --decompiler-version v1' runs,"
echo "it will execute /tmp/evil_revela.sh with user privileges."
```

**Verification Steps:**
1. Create malicious binary as shown above
2. Set `REVELA_EXE` environment variable
3. Run `aptos move decompile --decompiler-version v1 --bytecode-path <any_valid_bytecode.mv>`
4. Observe malicious code execution

## Notes

**Scope Clarification:** This vulnerability affects the Aptos CLI developer tool, not the blockchain consensus, validator operations, or on-chain execution. It does not compromise blockchain safety, state integrity, or fund security. The primary risk is to developer environments and CI/CD pipelines where the CLI is used for bytecode analysis.

**Attack Surface:** Limited to scenarios where attackers can influence environment variables in execution contexts where `aptos move decompile` is invoked. This excludes validator production environments but includes developer workstations, CI/CD runners, and shared development systems.

**Mitigation Priority:** Medium - while arbitrary code execution is serious, the limited attack surface and lack of impact on blockchain operations reduce urgency compared to consensus or Move VM vulnerabilities.

### Citations

**File:** crates/aptos/src/update/update_helper.rs (L88-90)
```rust
    if let Ok(path) = std::env::var(exe_env) {
        return Ok(PathBuf::from(path));
    }
```

**File:** crates/aptos/src/update/revela.rs (L121-129)
```rust
pub fn get_revela_path() -> Result<PathBuf> {
    get_path(
        "decompiler",
        REVELA_EXE_ENV,
        REVELA_BINARY_NAME,
        REVELA_EXE,
        false,
    )
}
```

**File:** crates/aptos/src/move_tool/bytecode.rs (L512-527)
```rust
    fn decompile_v1(&self, bytecode_path: &Path) -> Result<String, CliError> {
        let exe = get_revela_path()?;
        let to_cli_error = |e| CliError::IO(exe.display().to_string(), e);
        let mut cmd = Command::new(exe.as_path());
        // WORKAROUND: if the bytecode is v7, try to downgrade to v6 since Revela
        // does not support v7
        let v6_temp_file = self.downgrade_to_v6(bytecode_path)?;
        if let Some(file) = &v6_temp_file {
            cmd.arg(format!("--bytecode={}", file.path().display()));
        } else {
            cmd.arg(format!("--bytecode={}", bytecode_path.display()));
        }
        if self.is_script {
            cmd.arg("--script");
        }
        let out = cmd.output().map_err(to_cli_error)?;
```
