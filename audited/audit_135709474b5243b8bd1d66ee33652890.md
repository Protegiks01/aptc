# Audit Report

## Title
CaptchaApi Memory Exhaustion Attack Due to Lack of Isolation and Rate Limiting

## Summary
The CaptchaApi component lacks rate limiting and state size constraints, allowing an attacker to exhaust server memory by spamming the `/request_captcha` endpoint. This breaks the isolation between API components, as the memory exhaustion crashes the entire faucet service, affecting BasicApi and FundApi components that share the same process space.

## Finding Description
The three API components (BasicApi, CaptchaApi, FundApi) are bundled together in a single OpenAPI service but are not properly isolated in terms of resource consumption. While BasicApi and FundApi share a `concurrent_requests_semaphore` for rate limiting [1](#0-0) , the CaptchaApi component is instantiated without any semaphore [2](#0-1) .

The CaptchaManager maintains an unbounded HashMap to store captcha challenges [3](#0-2) . The code explicitly warns about this vulnerability [4](#0-3) . When `/request_captcha` is called, it creates a new challenge and inserts it into the HashMap without checking capacity [5](#0-4) . Challenges are only removed upon successful validation [6](#0-5) , meaning unused challenges accumulate indefinitely.

**Attack Path:**
1. Attacker discovers the public `/request_captcha` endpoint
2. Attacker writes a simple script to spam this endpoint (no authentication required)
3. Each request adds ~50-100 bytes to the HashMap (u32 key + String value + overhead)
4. After millions of requests, the HashMap exhausts available memory
5. The process crashes with OOM, taking down all three API components
6. BasicApi health checks fail, FundApi cannot process funding requests, CaptchaApi is unavailable

## Impact Explanation
This vulnerability falls under **High Severity** per Aptos bug bounty criteria: "API crashes" (up to $50,000). The entire faucet service becomes unavailable, preventing legitimate users from obtaining testnet tokens and developers from testing their applications. While this doesn't directly affect blockchain consensus or mainnet operations, it significantly disrupts the developer ecosystem and testnet availability.

The lack of proper isolation between components means that a vulnerability in one component (CaptchaApi) can compromise the availability of all other components (BasicApi, FundApi), violating the principle of defense in depth.

## Likelihood Explanation
**Likelihood: HIGH**

- **Attack Complexity: Very Low** - Requires only basic HTTP client knowledge
- **Authentication Required: None** - Endpoint is publicly accessible
- **Privileges Required: None** - Any internet user can exploit this
- **User Interaction: None** - Fully automated attack
- **Rate Limiting: Absent** - No protection mechanisms in place

The explicit warning comment in the code indicates this is a known architectural weakness that has not been addressed.

## Recommendation
Implement multiple layers of defense:

1. **Add Rate Limiting to CaptchaApi**: Share the concurrent_requests_semaphore with CaptchaApi:
```rust
let captcha_api = CaptchaApi {
    enabled: tap_captcha_api_enabled,
    captcha_manager,
    concurrent_requests_semaphore: concurrent_requests_semaphore.clone(),
};
```

2. **Implement Capacity Limits in CaptchaManager**: Add a maximum size constraint:
```rust
const MAX_CHALLENGES: usize = 10_000;

pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
    if self.challenges.len() >= MAX_CHALLENGES {
        bail!("Maximum captcha challenges reached");
    }
    // ... existing code
}
```

3. **Add Time-Based Cleanup**: Implement a periodic task to remove stale challenges:
```rust
pub struct Challenge {
    solution: String,
    created_at: std::time::Instant,
}

// Periodic cleanup task
async fn cleanup_stale_challenges(captcha_manager: Arc<Mutex<CaptchaManager>>) {
    loop {
        tokio::time::sleep(Duration::from_secs(300)).await;
        let mut manager = captcha_manager.lock().await;
        manager.remove_stale_challenges(Duration::from_secs(600));
    }
}
```

## Proof of Concept
```rust
// PoC: Captcha Memory Exhaustion Attack
use reqwest::Client;
use tokio;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();
    let faucet_url = "http://localhost:8081/v1/request_captcha";
    
    println!("Starting captcha memory exhaustion attack...");
    
    // Spam the endpoint without rate limiting
    for i in 0..1_000_000 {
        match client.get(faucet_url).send().await {
            Ok(response) => {
                if i % 1000 == 0 {
                    println!("Requests sent: {}, Status: {}", i, response.status());
                }
            }
            Err(e) => {
                println!("Service crashed after {} requests: {}", i, e);
                break;
            }
        }
    }
    
    Ok(())
}
```

This PoC demonstrates how an attacker can repeatedly call `/request_captcha` until the service exhausts memory and crashes. The attack succeeds because:
1. No rate limiting on the endpoint [7](#0-6) 
2. No capacity limits in CaptchaManager
3. No cleanup of stale challenges
4. All components share the same process memory space [8](#0-7) 

## Notes
While the faucet service is not part of the core blockchain consensus layer, this vulnerability demonstrates a fundamental isolation failure where one API component's resource exhaustion can crash the entire service. The shared process space between BasicApi, CaptchaApi, and FundApi means they are not truly isolated from resource-based attacks. This violates the security principle that "all operations must respect gas, storage, and computational limits."

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L93-96)
```rust
        let concurrent_requests_semaphore = self
            .handler_config
            .max_concurrent_requests
            .map(|v| Arc::new(Semaphore::new(v)));
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L166-169)
```rust
        let captcha_api = CaptchaApi {
            enabled: tap_captcha_api_enabled,
            captcha_manager,
        };
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L126-131)
```rust
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-161)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/api.rs (L9-28)
```rust
pub fn build_openapi_service(
    basic_api: BasicApi,
    captcha_api: CaptchaApi,
    fund_api: FundApi,
) -> OpenApiService<(BasicApi, CaptchaApi, FundApi), ()> {
    let version = VERSION.to_string();
    let license =
        LicenseObject::new("Apache 2.0").url("https://www.apache.org/licenses/LICENSE-2.0.html");
    let contact = ContactObject::new()
        .name("Aptos Labs")
        .url("https://github.com/aptos-labs");

    let apis = (basic_api, captcha_api, fund_api);

    OpenApiService::new(apis, "Aptos Tap", version.trim())
        .server("/v1")
        .description("todo")
        .license(license)
        .contact(contact)
}
```
