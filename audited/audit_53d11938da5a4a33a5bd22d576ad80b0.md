# Audit Report

## Title
Resource Exhaustion via Unvalidated Message Size in SignedBatchInfoMsg Processing

## Summary
The `SignedBatchInfoMsg::epoch()` method iterates through all batch entries to check epoch consistency before the `verify()` method enforces size limits. An attacker can send messages with tens of thousands of entries (within the 64 MiB network limit), forcing validators to waste CPU cycles iterating through all entries before the message is rejected for exceeding the configured limit (default: 20 batches).

## Finding Description
When a `SignedBatchInfoMsg` is received from the network, it undergoes the following processing sequence:

1. **Network Reception & Deserialization**: The message is deserialized as `ConsensusMsg::SignedBatchInfo` [1](#0-0) 

2. **Epoch Checking (Unvalidated)**: In `epoch_manager.rs`, the message is converted to an `UnverifiedEvent` and `event.epoch()` is called to check if it matches the current epoch [2](#0-1) 

3. **Epoch Consistency Iteration**: The `SignedBatchInfoMsg::epoch()` method iterates through **all** `signed_infos` entries without any size validation [3](#0-2) 

4. **Size Validation (Too Late)**: Only after the epoch check completes, the `verify()` method is called which enforces the `max_num_batches` limit [4](#0-3) 

The vulnerability is that **step 3 happens before step 4**. An attacker can exploit this by:
- Crafting a message with ~260,000 `SignedBatchInfo` entries (within the 64 MiB network limit [5](#0-4) )
- Each entry is ~250 bytes (BatchInfo + PeerId + Signature)
- The default `receiver_max_num_batches` limit is only 20 [6](#0-5) 

The `epoch()` method will iterate through all 260,000 entries checking epoch consistency, wasting significant CPU resources, before `verify()` rejects the message.

While `SignedBatchInfo::new_with_signature()` accepts pre-signed signatures without verification by design [7](#0-6) , the vulnerability lies in the message processing order that allows resource exhaustion before validation.

## Impact Explanation
This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria for the following reasons:

- **Resource Exhaustion**: An attacker can force validators to waste CPU cycles processing oversized messages before rejection
- **Validator Slowdown**: Repeated attacks can degrade validator performance by consuming CPU in the epoch consistency check
- **DoS Vector**: Multiple malicious peers can amplify the impact by sending such messages concurrently
- **No Consensus Break**: This does not compromise consensus safety or cause state corruption
- **Limited Liveness Impact**: While it can slow down validators, it doesn't cause total network unavailability

The impact aligns with "Validator node slowdowns" (High) but is closer to Medium since it requires sustained attacks and doesn't completely halt processing.

## Likelihood Explanation
This vulnerability is **highly likely** to be exploited because:

- **Low Attack Complexity**: Any network peer can send consensus messages without authentication before signature verification
- **No Special Privileges Required**: The attacker doesn't need validator access or credentials
- **Easy to Execute**: Simply craft a serialized message with many batch entries
- **Predictable Behavior**: The epoch iteration is deterministic and always happens before size checking
- **Network-Accessible**: All validator nodes expose consensus networking interfaces to peers

The verification happens in a bounded executor [8](#0-7) , which provides some isolation, but the resource waste still occurs.

## Recommendation
Move the size limit check **before** the epoch consistency check in `SignedBatchInfoMsg::epoch()`:

```rust
pub fn epoch(&self) -> anyhow::Result<u64> {
    ensure!(!self.signed_infos.is_empty(), "Empty message");
    // ADD SIZE CHECK HERE BEFORE ITERATION
    // Note: This requires passing max_num_batches as parameter
    let epoch = self.signed_infos[0].epoch();
    for info in self.signed_infos.iter() {
        ensure!(
            info.epoch() == epoch,
            "Epoch mismatch: {} != {}",
            info.epoch(),
            epoch
        );
    }
    Ok(epoch)
}
```

**Better Solution**: Refactor to validate size before calling `epoch()`. Modify `check_epoch()` in `epoch_manager.rs` to perform basic structural validation before epoch checking:

```rust
// In check_epoch(), before line 1646:
let event: UnverifiedEvent = msg.into();
// Add size validation for batch messages
if let UnverifiedEvent::SignedBatchInfo(ref msg) = event {
    ensure!(
        msg.signed_infos.len() <= max_num_batches,
        "Too many batches before epoch check"
    );
}
if event.epoch()? == self.epoch() {
    return Ok(Some(event));
}
```

This ensures the size limit is enforced before any iteration occurs.

## Proof of Concept

```rust
// Reproduction steps for the vulnerability:
// 
// 1. Create a malicious SignedBatchInfoMsg with many entries
use aptos_consensus_types::proof_of_store::{SignedBatchInfo, SignedBatchInfoMsg, BatchInfo};
use aptos_crypto::bls12381;
use aptos_types::PeerId;

// Attacker creates oversized message
let mut malicious_batches = Vec::new();
for i in 0..100_000 {  // Create 100K entries (within 64 MiB limit)
    let batch_info = BatchInfo::new(
        PeerId::random(),
        i.into(),
        1,  // epoch
        1000000,
        HashValue::random(),
        100,
        1000,
        0,
    );
    let signed = SignedBatchInfo::new_with_signature(
        batch_info,
        PeerId::random(),
        bls12381::Signature::dummy_signature(),
    );
    malicious_batches.push(signed);
}

let malicious_msg = SignedBatchInfoMsg::new(malicious_batches);

// When this message is received:
// 1. Network deserializes it (expensive but unavoidable)
// 2. epoch_manager calls malicious_msg.epoch()
//    -> This iterates through ALL 100K entries
// 3. ONLY THEN verify() is called
//    -> Rejects because 100K > 20 (max_num_batches)
// 
// The iteration in step 2 wastes ~100K loop iterations before rejection

// To measure impact:
use std::time::Instant;
let start = Instant::now();
let _ = malicious_msg.epoch();  // Wastes CPU here
let elapsed = start.elapsed();
println!("Wasted CPU time before validation: {:?}", elapsed);

// Then verify() rejects it:
// verify() would fail with "Too many batches: 100000 > 20"
```

**Notes**
The vulnerability exists because size validation happens too late in the message processing pipeline. The `epoch()` method performs an O(n) operation on unvalidated input before the O(1) size check occurs. This violates the security principle of "validate early, validate often" and creates a resource exhaustion vector. The fix requires reordering validation logic to check message size before performing any expensive operations on the message contents.

### Citations

**File:** consensus/src/network_interface.rs (L76-76)
```rust
    SignedBatchInfo(Box<SignedBatchInfoMsg<BatchInfo>>),
```

**File:** consensus/src/epoch_manager.rs (L1587-1622)
```rust
            self.bounded_executor
                .spawn(async move {
                    match monitor!(
                        "verify_message",
                        unverified_event.clone().verify(
                            peer_id,
                            &epoch_state.verifier,
                            &proof_cache,
                            quorum_store_enabled,
                            peer_id == my_peer_id,
                            max_num_batches,
                            max_batch_expiry_gap_usecs,
                        )
                    ) {
                        Ok(verified_event) => {
                            Self::forward_event(
                                quorum_store_msg_tx,
                                round_manager_tx,
                                buffered_proposal_tx,
                                peer_id,
                                verified_event,
                                payload_manager,
                                pending_blocks,
                            );
                        },
                        Err(e) => {
                            error!(
                                SecurityEvent::ConsensusInvalidMessage,
                                remote_peer = peer_id,
                                error = ?e,
                                unverified_event = unverified_event
                            );
                        },
                    }
                })
                .await;
```

**File:** consensus/src/epoch_manager.rs (L1645-1647)
```rust
                let event: UnverifiedEvent = msg.into();
                if event.epoch()? == self.epoch() {
                    return Ok(Some(event));
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L363-381)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_num_batches: usize,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.signed_infos.is_empty(), "Empty message");
        ensure!(
            self.signed_infos.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.signed_infos.len(),
            max_num_batches
        );
        for signed_info in &self.signed_infos {
            signed_info.verify(sender, max_batch_expiry_gap_usecs, validator)?
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L383-395)
```rust
    pub fn epoch(&self) -> anyhow::Result<u64> {
        ensure!(!self.signed_infos.is_empty(), "Empty message");
        let epoch = self.signed_infos[0].epoch();
        for info in self.signed_infos.iter() {
            ensure!(
                info.epoch() == epoch,
                "Epoch mismatch: {} != {}",
                info.epoch(),
                epoch
            );
        }
        Ok(epoch)
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L438-448)
```rust
    pub fn new_with_signature(
        batch_info: T,
        signer: PeerId,
        signature: bls12381::Signature,
    ) -> Self {
        Self {
            info: batch_info,
            signer,
            signature: SignatureWithStatus::from(signature),
        }
    }
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** config/src/config/quorum_store_config.rs (L122-122)
```rust
            receiver_max_num_batches: 20,
```
