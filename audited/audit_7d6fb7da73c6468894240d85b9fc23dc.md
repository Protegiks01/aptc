# Audit Report

## Title
Epoch-Crossing JWK Updates Enable OIDC Provider Configuration State Divergence

## Summary
The JWK consensus mechanism lacks epoch validation for `ObservedJWKUpdate` validator transactions, allowing stale JWK updates from previous OIDC provider configurations to be applied after rapid config_url changes. This violates the protocol invariant that `ObservedJWKs` accurately reflects the current `SupportedOIDCProviders` configuration, potentially causing authentication failures or security bypasses in keyless account systems.

## Finding Description
The vulnerability exists in how validator transactions for JWK updates are validated across epoch boundaries when OIDC provider configurations change.

**Root Cause**: The `QuorumCertifiedUpdate` structure does not include epoch information: [1](#0-0) 

Unlike `DKGResult` validator transactions which include epoch metadata in `DKGTranscriptMetadata`: [2](#0-1) 

And perform epoch validation during VM processing: [3](#0-2) 

The VM's validation in `process_jwk_update_inner()` only checks version number, voting power, and multi-signature: [4](#0-3) 

Critically, there is **no validation** that:
- The update was created in the current epoch
- The JWKs match the current OIDC provider configuration
- The config_url hasn't changed since the update was signed

**Attack Scenario**:
1. **Epoch N**: Issuer "https://accounts.google.com" has `config_url = URL_A`, `ObservedJWKs` version = 5
2. Validators fetch JWKs from URL_A, reach quorum on version 6, create validator transaction T and place it in the pool: [5](#0-4) 

3. Governance proposal executes `upsert_oidc_provider_for_next_epoch()` with `config_url = URL_B`, then `reconfigure()`: [6](#0-5) 

4. Reconfiguration applies the new config atomically via `on_new_epoch`: [7](#0-6) 

5. **Epoch N+1** starts with `SupportedOIDCProviders` pointing to URL_B, but `ObservedJWKs` still at version 5

6. Validator transaction T (containing JWKs from URL_A) is included in a block and processed. The validator transaction pool uses no epoch-based filtering: [8](#0-7) 

7. The update passes all validations despite being from the wrong config_url, and `ObservedJWKs` is updated to version 6 with JWKs from URL_A

8. **State Divergence**: `SupportedOIDCProviders` shows URL_B but `ObservedJWKs` contains JWKs from URL_A

Notably, when config changes occur, the `ObservedJWKs` version is **not** reset or invalidated, as shown by the `on_new_epoch` implementation which only updates `SupportedOIDCProviders`.

## Impact Explanation
This is a **High Severity** issue representing a significant protocol invariant violation.

**Protocol Invariant Broken**: The system violates the invariant that on-chain `ObservedJWKs` reflects the JWKs from the current OIDC provider `config_url` specified in `SupportedOIDCProviders`.

**Security Impact**:
- Applications using keyless authentication query `ObservedJWKs` to verify JWT signatures
- If `ObservedJWKs` contains keys from URL_A but the config points to URL_B, JWT signature validation operates on inconsistent state
- In a malicious scenario: if an OIDC provider is temporarily compromised and governance quickly switches to a backup URL, the malicious JWKs could persist in `ObservedJWKs` even after the config points to the legitimate backup
- Users could have their JWTs rejected (DoS) or the system could accept JWTs signed with keys from the wrong provider (authentication bypass)

**State Consistency**: This breaks the fundamental assumption that `SupportedOIDCProviders` and `ObservedJWKs` remain synchronized, allowing these two critical authentication resources to diverge.

## Likelihood Explanation
**Moderate to High Likelihood** in production:
- Requires governance proposals updating OIDC provider configs (legitimate operational actions)
- Likely scenarios include: emergency response to compromised OIDC provider, provider URL changes, DNS/domain migrations
- The bug will trigger whenever config changes occur during active JWK consensus rounds
- No malicious intent required - legitimate operational actions trigger the bug
- The vulnerability is not a race condition but a design flaw: validator transactions created in epoch N can be applied in epoch N+1 with no epoch validation

While governance access is required to trigger the scenario, the bug is in the protocol's lack of epoch validation, not in governance itself. This is a logic vulnerability in the validator transaction validation system.

## Recommendation
Implement epoch validation for `ObservedJWKUpdate` validator transactions to match the pattern used by `DKGResult`:

1. Add an `epoch` field to `QuorumCertifiedUpdate` structure in `types/src/jwks/mod.rs`
2. Populate the epoch field when creating the update in `jwk_manager/mod.rs`
3. Add epoch validation in `process_jwk_update_inner()` similar to DKG:
   - Check that `update.epoch == current_epoch()`
   - Return an appropriate error if epochs don't match
4. Consider resetting or incrementing `ObservedJWKs` version when OIDC provider configs change to prevent version collisions

## Proof of Concept
The vulnerability can be demonstrated by:
1. Setting up an OIDC provider with initial config_url
2. Initiating JWK consensus that creates a validator transaction
3. Before the transaction is processed, executing a governance proposal to change the config_url and trigger reconfiguration
4. Observing the stale validator transaction being applied in the new epoch
5. Verifying that `SupportedOIDCProviders` points to the new URL while `ObservedJWKs` contains keys from the old URL

A complete PoC would require access to a test environment with governance capabilities and multiple validators to demonstrate the full attack scenario.

## Notes
This vulnerability represents a fundamental design flaw in the JWK consensus validation system where epoch boundaries are not properly enforced. The asymmetry between `DKGResult` (which has epoch validation) and `ObservedJWKUpdate` (which lacks it) indicates this was likely an oversight rather than an intentional design decision. The impact is particularly severe for keyless account systems that rely on the correctness and consistency of on-chain JWK state.

### Citations

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** types/src/dkg/mod.rs (L28-32)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq, CryptoHasher, BCSCryptoHash)]
pub struct DKGTranscriptMetadata {
    pub epoch: u64,
    pub author: AccountAddress,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L99-102)
```rust
        // Check epoch number.
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-142)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L323-350)
```rust
    pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
        let issuer = update.update.issuer.clone();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            version = update.update.version,
            "JWKManager processing certified update."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L366-376)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            let new_config = config_buffer::extract_v2<SupportedOIDCProviders>();
            if (exists<SupportedOIDCProviders>(@aptos_framework)) {
                *borrow_global_mut<SupportedOIDCProviders>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            }
        }
    }
```

**File:** crates/validator-transaction-pool/src/lib.rs (L15-35)
```rust
pub enum TransactionFilter {
    PendingTxnHashSet(HashSet<HashValue>),
}

impl TransactionFilter {
    pub fn no_op() -> Self {
        Self::PendingTxnHashSet(HashSet::new())
    }
}

impl TransactionFilter {
    pub fn empty() -> Self {
        Self::PendingTxnHashSet(HashSet::new())
    }

    pub fn should_exclude(&self, txn: &ValidatorTransaction) -> bool {
        match self {
            TransactionFilter::PendingTxnHashSet(set) => set.contains(&txn.hash()),
        }
    }
}
```
