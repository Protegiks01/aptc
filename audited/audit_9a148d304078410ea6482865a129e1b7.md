# Audit Report

## Title
Cross-Proposal Interference in Gas Schedule Updates Causes Legitimate Governance Proposals to Fail Validation

## Summary
When multiple gas schedule governance proposals are created and submitted concurrently, their hash validation checks can interfere with each other, causing the second proposal to fail with `EINVALID_GAS_SCHEDULE_HASH` error even though it was legitimately created and approved. This occurs when synchronous reconfiguration is enabled (DKG disabled), as the first proposal's execution immediately updates the global gas schedule, invalidating the hash recorded by subsequent proposals.

## Finding Description

The gas schedule update mechanism uses a hash-based validation check to ensure proposals are applied to the expected state. The vulnerability exists in the interaction between three components:

1. **Proposal Generation** [1](#0-0)  - When a proposal is created, it computes and stores the hash of the current gas schedule to validate against during execution.

2. **Hash Validation** [2](#0-1)  - During execution, the function reads the current on-chain gas schedule, computes its hash, and requires it to match the hash recorded at proposal creation time. If the hashes don't match, the transaction aborts.

3. **Reconfiguration Behavior** [3](#0-2)  - When reconfiguration is called, it either triggers immediate synchronous reconfiguration (if DKG is disabled) or asynchronous reconfiguration (if DKG is enabled).

**Attack Scenario:**

1. **Time T0**: Current gas schedule is `GS0` with SHA3-512 hash `H0`
2. **Time T1**: Governance participant creates Proposal P1 to update gas schedule to `GS1`, recording `old_hash = H0`
3. **Time T2**: Another participant creates Proposal P2 to update gas schedule to `GS2`, also recording `old_hash = H0` (since global state is still `GS0`)
4. **Time T3**: Both proposals pass governance voting independently
5. **Time T4**: Proposal P1 executes successfully:
   - Hash check passes: `current_hash(GS0) == H0` âœ“
   - Calls `config_buffer::upsert(GS1)`
   - Calls `reconfigure()` [4](#0-3) 
   - If DKG is disabled, `finish()` is called immediately [5](#0-4) 
   - This applies the buffered gas schedule: global state becomes `GS1` with hash `H1`
6. **Time T5**: Proposal P2 attempts to execute:
   - Hash check reads current gas schedule: `GS1` (not `GS0`)
   - Computes `current_hash(GS1) = H1`
   - Compares `H1 == H0`: **FAIL**
   - **Aborts with `EINVALID_GAS_SCHEDULE_HASH` error** [6](#0-5) 

This breaks **Governance Integrity** (Invariant #5) - a legitimately created and approved proposal fails unexpectedly, wasting governance resources and requiring the proposal to be recreated and re-voted.

## Impact Explanation

This issue constitutes a **HIGH severity** governance protocol violation under the Aptos bug bounty criteria:

- **Significant Protocol Violations**: The governance system is a critical protocol component. When legitimate proposals fail validation unexpectedly, it disrupts the governance process, potentially blocking urgent parameter updates or security fixes.

- **Governance Liveness Impact**: While not a complete loss of liveness, this creates operational friction where concurrent proposals (a natural occurrence in active governance) cause failures requiring manual intervention, recreation, and re-voting.

- **Resource Waste**: Each failed proposal wastes significant governance resources including voting power, validator participation, and time. In scenarios requiring urgent updates (e.g., emergency gas parameter adjustments), this delay could have cascading effects.

The impact is amplified in asynchronous mode (DKG enabled), where instead of failing, the first proposal is silently overwritten by the second [7](#0-6) , causing data loss without any error indication.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability will occur whenever:
1. Two or more gas schedule proposals are created before any execute (common in active governance)
2. Both proposals are approved by governance voting (legitimate governance activity)
3. Synchronous reconfiguration is enabled (testnet, or production if DKG disabled)
4. Proposals execute sequentially in separate transactions

This is not a theoretical edge case - it's a natural consequence of concurrent governance activity. No malicious intent is required; this happens through normal governance operations. The issue is more likely during:
- Active governance periods with multiple parameter updates
- Emergency situations requiring rapid governance response
- Testnet environments where DKG is commonly disabled

## Recommendation

Implement one of the following fixes:

**Option 1: Semantic Validation Instead of Hash Validation**
Replace the point-in-time hash check with semantic validation that verifies the changes are still applicable:
- Check that the feature version is being incremented appropriately
- Validate that the new gas schedule parameters are within acceptable ranges
- Remove the brittle hash comparison that fails on any intermediate state change

**Option 2: Proposal Queuing with Conflict Detection**
Implement a queue mechanism for gas schedule proposals that:
- Detects when multiple gas schedule proposals are pending
- Either rejects new proposals while one is pending, or
- Automatically rebases the second proposal against the new state

**Option 3: Advisory Hash Check**
Convert the hash check from a hard requirement (abort) to an advisory warning:
- Log when hashes don't match but allow execution to proceed
- Include hash mismatch information in events for monitoring
- Let governance participants decide whether to proceed

**Recommended Fix (Option 1):**

Modify `set_for_next_epoch_check_hash` to use semantic validation:

```move
public fun set_for_next_epoch_check_hash(
    aptos_framework: &signer,
    old_gas_schedule_hash: vector<u8>,  // Keep for backward compatibility
    new_gas_schedule_blob: vector<u8>
) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&new_gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

    let new_gas_schedule: GasScheduleV2 = from_bytes(new_gas_schedule_blob);
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        // Semantic validation: feature version must increase
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
        // Remove brittle hash check that fails on concurrent proposals
        // The hash parameter is ignored but kept for backward compatibility
    };

    config_buffer::upsert(new_gas_schedule);
}
```

## Proof of Concept

```move
#[test(aptos_framework = @0x1)]
fun test_concurrent_gas_schedule_proposals_fail(aptos_framework: &signer) 
    acquires GasScheduleV2 {
    use std::features;
    
    // Setup: Initialize with GS0
    let gs0 = GasScheduleV2 {
        feature_version: 1,
        entries: vector[GasEntry { key: utf8(b"test"), val: 100 }],
    };
    move_to(aptos_framework, gs0);
    
    // Record hash at T0 (both proposals record this)
    let gs0_bytes = bcs::to_bytes(&borrow_global<GasScheduleV2>(@aptos_framework));
    let h0 = aptos_hash::sha3_512(gs0_bytes);
    
    // Proposal P1: Update to GS1
    let gs1 = GasScheduleV2 {
        feature_version: 2,
        entries: vector[GasEntry { key: utf8(b"test"), val: 200 }],
    };
    let gs1_blob = bcs::to_bytes(&gs1);
    
    // Execute P1 - should succeed
    set_for_next_epoch_check_hash(aptos_framework, h0, gs1_blob);
    
    // Simulate synchronous reconfiguration
    features::change_feature_flags_for_next_epoch(
        aptos_framework, 
        vector[], 
        vector[features::get_reconfigure_with_dkg_feature()]
    );
    reconfiguration_with_dkg::finish(aptos_framework);
    
    // Now global state is GS1, hash is H1 (different from H0)
    
    // Proposal P2: Update to GS2 (created at T0, still has H0)
    let gs2 = GasScheduleV2 {
        feature_version: 3,
        entries: vector[GasEntry { key: utf8(b"test"), val: 300 }],
    };
    let gs2_blob = bcs::to_bytes(&gs2);
    
    // Execute P2 - FAILS with EINVALID_GAS_SCHEDULE_HASH
    // Expected error code: 0x010003 (EINVALID_GAS_SCHEDULE_HASH)
    set_for_next_epoch_check_hash(aptos_framework, h0, gs2_blob); // ABORTS HERE
}
```

## Notes

This vulnerability has two manifestations depending on reconfiguration mode:

1. **Synchronous reconfiguration (DKG disabled)**: Second proposal fails validation with hash mismatch - this directly answers the security question posed.

2. **Asynchronous reconfiguration (DKG enabled)**: Both proposals pass validation but the first is silently overwritten in the config buffer, causing data loss without error indication.

The hash check mechanism was designed to prevent stale proposals, but creates a race condition for concurrent legitimate proposals. The recommended fix removes this brittle validation in favor of semantic checks that validate the change is appropriate regardless of intermediate state changes.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L101-113)
```rust
    let old_hash = match old_gas_schedule {
        Some(old_gas_schedule) => {
            let old_bytes = bcs::to_bytes(old_gas_schedule)?;
            let old_hash = hex::encode(Sha3_512::digest(old_bytes.as_slice()));
            emitln!(writer, "//");
            emitln!(writer, "// Old Gas Schedule Hash (Sha3-512): {}", old_hash);

            emit_gas_schedule_diff(&writer, old_gas_schedule, new_gas_schedule)?;

            Some(old_hash)
        },
        None => None,
    };
```

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L149-149)
```rust
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L108-132)
```text
    public fun set_for_next_epoch_check_hash(
        aptos_framework: &signer,
        old_gas_schedule_hash: vector<u8>,
        new_gas_schedule_blob: vector<u8>
    ) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&new_gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        let new_gas_schedule: GasScheduleV2 = from_bytes(new_gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
            let cur_gas_schedule_bytes = bcs::to_bytes(cur_gas_schedule);
            let cur_gas_schedule_hash = aptos_hash::sha3_512(cur_gas_schedule_bytes);
            assert!(
                cur_gas_schedule_hash == old_gas_schedule_hash,
                error::invalid_argument(EINVALID_GAS_SCHEDULE_HASH)
            );
        };

        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```
