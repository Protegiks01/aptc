# Audit Report

## Title
Missing Version Range Validation in TransactionStreamEngine Causes Permanent Stream Hang

## Summary
The `TransactionStreamEngine::create_data_client_requests()` function extracts `request_end_version` from stream requests without validating that `end_version >= start_version`. If `end_version < start_version`, the stream enters a permanent hung state where it never completes and cannot make progress, causing node synchronization failures.

## Finding Description

The vulnerability exists in the data streaming service's transaction stream engine. When a stream request is processed, the system extracts version ranges but performs no validation on their relationship. [1](#0-0) 

The extracted `request_end_version` is passed to `create_data_client_request_batch()` along with `self.next_request_version` (initialized to `start_version`). This helper function has logic to return an empty vector when the range is invalid: [2](#0-1) 

When an empty vector is returned, no data requests are sent to the network. The stream's completion flag (`stream_is_complete`) is only set to `true` when data is actually received and processed: [3](#0-2) 

Since no requests are sent, no responses arrive, `update_stream_version()` is never called, and the stream never marks itself as complete. The stream engine initialization performs no validation: [4](#0-3) 

The stream processing loop checks if the stream is complete before sending end-of-stream notifications: [5](#0-4) 

With `is_stream_complete()` permanently returning `false`, the stream remains active indefinitely, consuming resources and blocking synchronization progress.

## Impact Explanation

This issue meets **Medium Severity** criteria per the Aptos bug bounty program: "State inconsistencies requiring intervention."

**Concrete Impacts:**
1. **Node Synchronization Failure**: If triggered during bootstrapping, the node cannot sync from genesis and remains permanently stuck
2. **Resource Leak**: The stream remains in the active streams map indefinitely, consuming memory
3. **Operational Downtime**: Requires manual node restart and intervention to recover
4. **Cascading Failures**: During epoch transitions with inconsistent state, multiple nodes could encounter this simultaneously

While not directly exploitable by external attackers, this represents a critical defensive programming gap. In production environments with:
- Corrupted epoch state data
- Race conditions during epoch transitions  
- System recovery scenarios
- Bugs in epoch version calculations

This validation gap transforms what should be a caught error into a silent permanent hang.

## Likelihood Explanation

**Likelihood: Low to Medium** in current implementation, but **High impact when triggered**.

The bootstrapper calculates versions from verified epoch states: [6](#0-5) 

In normal operation, `next_epoch_ending_version(highest_synced_version)` should always return a version â‰¥ `highest_synced_version + 1`. However, edge cases include:

1. **Epoch State Corruption**: Disk corruption or database inconsistencies in `verified_epoch_states`
2. **Logic Bugs**: Potential bugs in `next_epoch_ending_version()` calculation during complex epoch transitions
3. **Recovery Scenarios**: System recovery from crashes during epoch changes with partial state
4. **Race Conditions**: Concurrent modifications to epoch state during network partitions

The lack of validation means these edge cases result in silent hangs rather than explicit errors.

## Recommendation

Add explicit validation in `TransactionStreamEngine::new()` to ensure version ranges are valid:

```rust
fn new(stream_request: &StreamRequest) -> Result<Self, Error> {
    match stream_request {
        StreamRequest::GetAllTransactions(request) => {
            // Validate version range
            if request.end_version < request.start_version {
                return Err(Error::InvalidStreamRequest(format!(
                    "Invalid version range: end_version ({}) < start_version ({})",
                    request.end_version, request.start_version
                )));
            }
            Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            })
        },
        StreamRequest::GetAllTransactionOutputs(request) => {
            // Validate version range
            if request.end_version < request.start_version {
                return Err(Error::InvalidStreamRequest(format!(
                    "Invalid version range: end_version ({}) < start_version ({})",
                    request.end_version, request.start_version
                )));
            }
            Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            })
        },
        StreamRequest::GetAllTransactionsOrOutputs(request) => {
            // Validate version range
            if request.end_version < request.start_version {
                return Err(Error::InvalidStreamRequest(format!(
                    "Invalid version range: end_version ({}) < start_version ({})",
                    request.end_version, request.start_version
                )));
            }
            Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            })
        },
        request => invalid_stream_request!(request),
    }
}
```

Additionally, add similar validation in `StateStreamEngine::new()` and `EpochEndingStreamEngine::new()` for consistency.

## Proof of Concept

```rust
#[tokio::test]
async fn test_invalid_version_range_causes_stream_hang() {
    use aptos_data_streaming_service::{
        data_stream::DataStream,
        streaming_client::{GetAllTransactionsRequest, StreamRequest},
    };
    use aptos_config::config::{DataStreamingServiceConfig, AptosDataClientConfig};
    use aptos_storage_service_types::requests::DataRequest;
    
    // Create a stream request with invalid version range (end < start)
    let invalid_request = StreamRequest::GetAllTransactions(GetAllTransactionsRequest {
        start_version: 1000,
        end_version: 500,  // end_version < start_version
        proof_version: 1000,
        include_events: false,
    });
    
    // Create stream engine - this should fail with validation error but currently succeeds
    let stream_engine = StreamEngine::new(
        DataStreamingServiceConfig::default(),
        &invalid_request,
        &AdvertisedData::default(),
    );
    
    // Currently this succeeds, creating a broken stream
    assert!(stream_engine.is_ok());
    
    // Attempting to create data client requests returns empty vector
    let mut engine = stream_engine.unwrap();
    let requests = engine.create_data_client_requests(
        10, // max_number_of_requests
        5,  // max_in_flight_requests  
        0,  // num_in_flight_requests
        &GlobalDataSummary::default(),
        Arc::new(U64IdGenerator::new()),
    ).unwrap();
    
    // No requests created due to invalid range
    assert_eq!(requests.len(), 0);
    
    // Stream is NOT marked as complete
    assert_eq!(engine.is_stream_complete(), false);
    
    // This stream will hang indefinitely waiting for completion that never comes
}
```

**Notes:**
- This vulnerability requires internal code bugs or state corruption to trigger, not direct external exploitation
- When triggered, it causes permanent node hang requiring manual intervention
- The fix is straightforward: add validation to reject invalid version ranges explicitly
- This represents a critical defensive programming gap that could manifest in production edge cases

### Citations

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1668-1690)
```rust
    fn new(stream_request: &StreamRequest) -> Result<Self, Error> {
        match stream_request {
            StreamRequest::GetAllTransactions(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionsOrOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            request => invalid_stream_request!(request),
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1740-1741)
```rust
        if last_received_version >= stream_end_version {
            self.stream_is_complete = true;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1807-1826)
```rust
            StreamRequest::GetAllTransactions(request) => (
                request.end_version,
                global_data_summary
                    .optimal_chunk_sizes
                    .transaction_chunk_size,
            ),
            StreamRequest::GetAllTransactionOutputs(request) => (
                request.end_version,
                global_data_summary
                    .optimal_chunk_sizes
                    .transaction_output_chunk_size,
            ),
            StreamRequest::GetAllTransactionsOrOutputs(request) => (
                request.end_version,
                global_data_summary
                    .optimal_chunk_sizes
                    .transaction_output_chunk_size,
            ),
            request => invalid_stream_request!(request),
        };
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2056-2058)
```rust
    if start_index > end_index {
        return Ok(vec![]);
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L446-453)
```rust
        if self.stream_engine.is_stream_complete()
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L739-747)
```rust
        let next_version = highest_synced_version.checked_add(1).ok_or_else(|| {
            Error::IntegerOverflow("The next output version has overflown!".into())
        })?;
        let end_version = self
            .verified_epoch_states
            .next_epoch_ending_version(highest_synced_version)
            .ok_or_else(|| {
                Error::UnexpectedError("No higher epoch ending version known!".into())
            })?;
```
