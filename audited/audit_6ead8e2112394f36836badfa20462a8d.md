# Audit Report

## Title
Information Disclosure via Partial Checker Failure in Faucet Request Preprocessing

## Summary
The `FundApiComponents::preprocess_request()` function exposes which specific security checkers passed or failed through detailed rejection reasons, allowing attackers to incrementally map the faucet's security architecture.

## Finding Description

The faucet's request preprocessing logic runs multiple security checkers (IP blocklist, captcha validation, rate limiting, magic header verification, etc.) to validate funding requests. When configured with `return_rejections_early: false` (the default), all checkers execute regardless of earlier failures. [1](#0-0) 

Each checker returns a `Vec<RejectionReason>` - empty if it passes, populated if it rejects. The preprocessing function accumulates all rejection reasons and returns them to the client: [2](#0-1) 

Each `RejectionReason` includes a specific `RejectionReasonCode` enum value identifying the checker type: [3](#0-2) [4](#0-3) 

The default configuration enables detailed errors: [5](#0-4) 

**Attack Vector**: An attacker can observe which `RejectionReasonCode` values appear in responses to infer which checkers failed (present in list) versus which passed (conspicuously absent). Through iterative requests, they map the complete security control architecture:

1. Initial request: Receives `[IpInBlocklist, CaptchaInvalid]` → learns IP is blocklisted, captcha required, but rate limit/magic header checks PASSED
2. Clean IP retry: Receives `[CaptchaInvalid]` → confirms IP check now passes
3. With captcha: Receives `[MagicHeaderIncorrect]` → confirms captcha passes, discovers magic header requirement
4. With header: Success → has mapped all controls

## Impact Explanation

This is a **Low severity** information disclosure vulnerability per Aptos bug bounty criteria. It does not directly enable:
- Funds theft or loss
- Consensus violations
- State corruption
- Denial of service

However, it reduces the effectiveness of "defense in depth" by allowing attackers to systematically discover and bypass security controls incrementally rather than having to guess the complete security posture.

## Likelihood Explanation

**High likelihood** - This is the default configuration and requires no special privileges. Any attacker can send multiple requests to the public faucet endpoint and observe the structured error responses to map security controls.

## Recommendation

Set `return_rejections_early: true` in production configurations to stop processing after the first checker failure. This prevents attackers from learning about subsequent checkers:

```rust
handler_config: HandlerConfig {
    use_helpful_errors: true,
    return_rejections_early: true,  // Stop at first failure
    max_concurrent_requests: None,
}
```

Alternatively, return a generic error message without specific rejection codes when multiple checkers fail, or return only the first/highest-priority failure reason.

## Proof of Concept

**Step 1**: Deploy faucet with default config (multiple checkers: IP blocklist, captcha, magic header)

**Step 2**: Send request from blocklisted IP without captcha:
```bash
curl -X POST http://faucet/fund -H "Content-Type: application/json" -d '{"address":"0x1"}'
```

**Response**:
```json
{
  "message": "Request rejected by 2 checkers",
  "error_code": 42,
  "rejection_reasons": [
    {"reason": "IP 1.2.3.4 is in blocklist", "code": 102},
    {"reason": "Captcha invalid", "code": 106}
  ]
}
```

**Analysis**: Attacker learns magic header check (code 105) is NOT in the list → it passed (or doesn't exist).

**Step 3**: Retry from clean IP with captcha but no magic header:
```bash
curl -X POST http://faucet/fund -H "Content-Type: application/json" \
  -H "X-Captcha: valid_token" -d '{"address":"0x1"}'
```

**Response**:
```json
{
  "message": "Request rejected by 1 checkers", 
  "error_code": 42,
  "rejection_reasons": [
    {"reason": "Magic header X-Custom-Header not found", "code": 105}
  ]
}
```

**Analysis**: Attacker confirms IP and captcha checks passed, discovers magic header requirement.

This incremental learning violates the principle that security control architecture should be opaque to attackers.

## Notes

This vulnerability is specific to the Aptos faucet service and does not impact core blockchain consensus, state management, or Move VM execution. While categorized as Low severity due to limited direct impact, operators should consider enabling `return_rejections_early: true` to reduce information leakage about their security control stack.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L272-278)
```rust
        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L198-204)
```rust
#[derive(Debug, Clone, Object)]
pub struct RejectionReason {
    reason: String,
    code: RejectionReasonCode,
    #[oai(skip)]
    pub retry_after: Option<u64>,
}
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L235-267)
```rust
#[derive(Copy, Clone, Debug, Enum, Eq, Hash, PartialEq)]
#[repr(u32)]
pub enum RejectionReasonCode {
    /// Intentionally unhelpful reason code.
    Hehe = 1,

    /// Account already has funds.
    AccountAlreadyExists = 100,

    /// Key (IP / Firebase UID) has exhausted its usage limit.
    UsageLimitExhausted = 101,

    /// IP is in the blocklist.
    IpInBlocklist = 102,

    /// The origin of the request is from a VPN.
    RequestFromVpn = 103,

    /// The origin of the request is a cloud.
    RequestFromCloud = 104,

    /// The request did not contain the required magic header.
    MagicHeaderIncorrect = 105,

    /// The captcha was missing or incorrect.
    CaptchaInvalid = 106,

    /// Auth token was not given, is invalid, or is not allowed by the server.
    AuthTokenInvalid = 107,

    /// Referer was in the blocklist.
    RefererBlocklisted = 108,
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L306-310)
```rust
            handler_config: HandlerConfig {
                use_helpful_errors: true,
                return_rejections_early: false,
                max_concurrent_requests: None,
            },
```
