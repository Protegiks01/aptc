# Audit Report

## Title
Node ID Corruption in Spec update_map Causes Ghost Variable Update Loss During Verification

## Summary
The `ExpData::rewrite_node_id()` function creates new NodeIds for expression nodes during type instantiation and inlining, but the `Spec.update_map` keys (which are NodeIds) are not rewritten accordingly. This causes ghost variable update lookups to fail, silently dropping specification updates from Move Prover verification.

## Finding Description

The Move model's expression rewriting mechanism has a critical inconsistency in how it handles NodeIds stored in the `Spec.update_map` data structure. [1](#0-0) 

The `update_map` field stores ghost variable update conditions indexed by NodeId. When expressions are rewritten (during inlining or type instantiation), new NodeIds are created for expression nodes: [2](#0-1) [3](#0-2) 

However, during the rewriting process, the NodeId **keys** in `update_map` are not updated, only the Condition **values** are rewritten: [4](#0-3) 

This creates a mismatch where expressions in the AST have new NodeIds (post-rewriting), but the `update_map` still uses old NodeIds as keys. When the verification pipeline attempts to look up ghost updates, it fails: [5](#0-4) [6](#0-5) 

The lookup fails because `prop.node_id()` returns the **new** NodeId (after rewriting), but `update_map` contains **old** NodeIds as keys.

## Impact Explanation

**Severity: Low to Medium** (does not meet Critical/High criteria)

This vulnerability affects the **Move Prover verification tool**, not the blockchain runtime execution. Specifically:

- **NO Consensus Impact**: This bug does not affect AptosBFT consensus, block production, or validator behavior
- **NO Transaction Execution Impact**: Ghost variables and update statements only exist in specifications, not in compiled bytecode
- **NO Fund Loss**: Cannot be exploited to steal or mint tokens
- **Verification Soundness Impact**: The Move Prover may produce false positives (claiming properties hold when they don't)

While this is a serious soundness bug in the verification infrastructure, it does not directly compromise the blockchain. Developers relying on Move Prover for contract verification may deploy contracts with undetected vulnerabilities if ghost updates are silently dropped.

However, this does **NOT** meet the Aptos bug bounty's Critical, High, or Medium severity criteria, which focus on actual blockchain vulnerabilities (consensus, funds, liveness) rather than verification tool bugs.

## Likelihood Explanation

**Likelihood: High** (for verification scenarios using ghost updates with inlining/instantiation)

The bug triggers whenever:
1. A Move contract uses inline specs with `update` conditions for ghost variables
2. The code undergoes inlining (function calls) or type instantiation (generics)
3. `ExpData::rewrite_node_id()` is invoked

Both inlining and type instantiation are common in the compilation pipeline: [7](#0-6) [8](#0-7) 

## Recommendation

Rewrite the NodeId **keys** in `update_map` when rewriting specs. Maintain a mapping from old NodeIds to new NodeIds during rewriting and use it to update the map keys:

```rust
// In exp_rewriter.rs, rewrite_spec_descent function:
let mut update_map = BTreeMap::new();
for (node_id, cond) in &spec.update_map {
    let (this_changed, new_cond) = self.internal_rewrite_condition(target, cond);
    // Get the rewritten node_id for the key
    let new_key = self.rewrite_node_id(*node_id).unwrap_or(*node_id);
    update_map.insert(new_key, new_cond);
    changed |= this_changed
}
```

However, this requires tracking which NodeId in the rewritten condition corresponds to the original key NodeId, which may require additional refactoring.

## Proof of Concept

This bug affects the Move Prover verification pipeline, not runtime execution. A PoC would require:

1. Writing a Move module with inline specs containing ghost variable updates
2. Compiling with inlining enabled
3. Running the Move Prover
4. Observing that ghost updates are silently dropped from verification

However, since this is a **verification tool bug** and not a blockchain vulnerability, it does not meet the acceptance criteria for the Aptos bug bounty program.

---

**Notes:**

This is a real bug in the Move Prover's expression rewriting mechanism, but it does **not** constitute a blockchain security vulnerability per the bug bounty criteria. The vulnerability affects verification soundness (potentially allowing unverified contracts to pass verification), but does not enable attacks on consensus, fund theft, or protocol violations at runtime. Ghost variables and update statements are purely verification constructs that do not exist in compiled bytecode or affect on-chain execution.

### Citations

**File:** third_party/move/move-model/src/ast.rs (L365-365)
```rust
    pub update_map: BTreeMap<NodeId, Condition>,
```

**File:** third_party/move/move-model/src/ast.rs (L1741-1751)
```rust
    pub fn rewrite_node_id<F>(exp: Exp, node_rewriter: &mut F) -> Exp
    where
        F: FnMut(NodeId) -> Option<NodeId>,
    {
        ExpRewriter {
            exp_rewriter: &mut RewriteResult::Unchanged,
            node_rewriter,
            pattern_rewriter: &mut |_, _| None,
        }
        .rewrite_exp(exp)
    }
```

**File:** third_party/move/move-model/src/ast.rs (L1773-1791)
```rust
    pub fn instantiate_node(env: &GlobalEnv, id: NodeId, targs: &[Type]) -> Option<NodeId> {
        if targs.is_empty() {
            // shortcut
            return None;
        }
        let node_ty = env.get_node_type(id);
        let new_node_ty = node_ty.instantiate(targs);
        let node_inst = env.get_node_instantiation_opt(id);
        let new_node_inst = node_inst.clone().map(|i| Type::instantiate_vec(i, targs));
        if node_ty != new_node_ty || node_inst != new_node_inst {
            let loc = env.get_node_loc(id);
            let new_id = env.new_node(loc, new_node_ty);
            if let Some(inst) = new_node_inst {
                env.set_node_instantiation(new_id, inst);
            }
            Some(new_id)
        } else {
            None
        }
```

**File:** third_party/move/move-model/src/exp_rewriter.rs (L678-683)
```rust
        let mut update_map = BTreeMap::new();
        for (node_id, cond) in &spec.update_map {
            let (this_changed, new_cond) = self.internal_rewrite_condition(target, cond);
            update_map.insert(*node_id, new_cond);
            changed |= this_changed
        }
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/spec_instrumentation.rs (L468-468)
```rust
                        let cond_opt = binding.update_map.get(&prop.node_id());
```

**File:** third_party/move/move-model/src/spec_translator.rs (L286-286)
```rust
        let cond_opt = binding.update_map.get(&prop.node_id());
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs (L1295-1298)
```rust
    fn rewrite_node_id(&mut self, id: NodeId) -> Option<NodeId> {
        let loc = self.env.get_node_loc(id);
        let new_loc = loc.inlined_from(self.call_site_loc);
        ExpData::instantiate_node_new_loc(self.env, id, self.type_args, &new_loc)
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L604-614)
```rust
    fn rewrite_node_id(&mut self, id: NodeId) -> Option<NodeId> {
        if !self.in_spec || self.reference_strip_exempted.contains(&id) {
            // Skip the processing below
            return None;
        }
        if let Some(new_ty) = self
            .env
            .get_node_type_opt(id)
            .map(|ty| ty.skip_reference().clone())
        {
            let new_id = self.env.new_node(self.env.get_node_loc(id), new_ty);
```
