# Audit Report

## Title
Config Sanitization Bypass via skip_config_sanitizer Flag Enables In-Memory Safety Rules on Mainnet Validators

## Summary
The PersistableConfig trait implementations for NodeConfig and SafetyRulesConfig lack built-in validation. While a sanitization framework exists, it can be bypassed by setting `skip_config_sanitizer: true` in the config file itself before loading. This allows mainnet validators to run with in-memory safety rules storage, enabling potential equivocation after restarts. [1](#0-0) 

## Finding Description

The PersistableConfig trait provides default implementations for loading and saving configs via YAML deserialization without any validation. [2](#0-1) 

While SafetyRulesConfig implements a ConfigSanitizer that validates mainnet requirements (persistent storage, no test config, local service), [3](#0-2)  this validation is only invoked when loading via `NodeConfig::load_from_path()`.

The critical vulnerability is that NodeConfig's sanitization can be bypassed by a flag that is deserialized from the untrusted config file itself: [4](#0-3) 

**Attack Path:**
1. Validator operator creates/receives malicious config containing:
   - `node_startup.skip_config_sanitizer: true`
   - `consensus.safety_rules.backend: InMemoryStorage`
   - `consensus.safety_rules.test: <test_config>`
2. Config is loaded via `load_from_path()` â†’ `load_and_sanitize_config()` [5](#0-4) 
3. The config (including skip flag) is deserialized at line 74
4. Sanitization is invoked at line 87 but immediately returns due to the skip flag
5. Validator runs with in-memory safety rules storage

**Consensus Safety Impact:**

SafetyData tracks critical voting state including `last_voted_round`, `last_vote`, and `preferred_round`. [6](#0-5) 

InMemoryStorage explicitly states it "should not be used in production" and loses all data on restart. [7](#0-6) 

After restart, the validator re-initializes with `SafetyData::new(1, 0, 0, 0, None, 0)` - forgetting previous votes. [8](#0-7) 

This enables **equivocation**: the validator can vote for conflicting blocks in the same round because it has forgotten its previous vote, breaking the fundamental BFT safety guarantee that prevents double-voting.

## Impact Explanation

This qualifies as **Critical Severity** under "Consensus/Safety violations" because:

1. **Breaks Consensus Safety Invariant**: AptosBFT requires that honest validators never equivocate (vote for two different blocks in the same round). This vulnerability enables equivocation after restart.

2. **Network-Wide Impact**: Multiple validators running with this misconfiguration could cause consensus failures, chain forks, or total liveness loss if enough validators restart simultaneously and their voting state diverges.

3. **Permanent State Damage**: Equivocation detected by other validators could lead to slashing or validator exclusion, requiring manual intervention to restore network health.

## Likelihood Explanation

**Likelihood: Medium**

**Factors Increasing Likelihood:**
- The vulnerability is triggered by operator misconfiguration or use of malicious configs
- Config files may be shared or templated across deployments
- No runtime warning when skip_config_sanitizer is enabled
- The flag's purpose is not immediately obvious to operators

**Factors Decreasing Likelihood:**
- Requires validator operator to either create malicious config or use untrusted config source
- Production deployments typically use vetted, organization-approved configs
- Mainnet validators are operated by security-conscious entities

**Note on Attack Model:** This vulnerability requires the attacker to control or influence the config file used by a validator operator. This could occur through:
- Operator error when creating configs
- Supply chain attack on config templates
- Compromised config management systems
- Social engineering of operators

While this requires operator involvement, it does not require the operator to be intentionally malicious - merely to make a configuration mistake or use a config from a compromised source.

## Recommendation

**Fix 1: Remove the skip_config_sanitizer bypass**
The ability to skip sanitization via a config file field is fundamentally insecure. The flag that controls validation should not be controllable from the data being validated.

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Remove this bypass - always perform sanitization
        // if node_config.node_startup.skip_config_sanitizer {
        //     return Ok(());
        // }
        
        // Sanitize all sub-configs (always)
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        // ... rest of sanitization
```

**Fix 2: Add chain-specific validation in deserialization**
SafetyRulesConfig should validate critical fields during deserialization for mainnet:

```rust
impl SafetyRulesConfig {
    fn validate_mainnet(&self, chain_id: Option<ChainId>) -> Result<(), Error> {
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if self.backend.is_in_memory() {
                    return Err(Error::ConfigSanitizerFailed(
                        "SafetyRulesConfig".to_string(),
                        "In-memory storage forbidden on mainnet".to_string(),
                    ));
                }
            }
        }
        Ok(())
    }
}
```

**Fix 3: Runtime protection**
Add a runtime check when initializing SafetyRules to prevent in-memory storage on mainnet, regardless of config loading path.

## Proof of Concept

```rust
// Create malicious mainnet validator config
use aptos_config::config::{NodeConfig, PersistableConfig, SafetyRulesConfig, SecureBackend, NodeStartupConfig};

#[test]
fn test_config_sanitization_bypass() {
    // Create a malicious config for mainnet validator
    let mut malicious_config = NodeConfig::default();
    
    // Set the bypass flag
    malicious_config.node_startup = NodeStartupConfig {
        skip_config_sanitizer: true,
        skip_config_optimizer: false,
    };
    
    // Use in-memory storage (should be forbidden on mainnet)
    malicious_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
    
    // Save to disk
    let temp_dir = tempfile::tempdir().unwrap();
    let config_path = temp_dir.path().join("malicious_config.yaml");
    malicious_config.save_config(&config_path).unwrap();
    
    // Load via the "safe" path that should sanitize
    let loaded_config = NodeConfig::load_from_path(&config_path).unwrap();
    
    // Validation was bypassed! Config loaded successfully despite in-memory storage
    assert!(matches!(
        loaded_config.consensus.safety_rules.backend,
        SecureBackend::InMemoryStorage
    ));
    
    // This validator can now run on mainnet with in-memory safety rules,
    // losing voting state on every restart and enabling equivocation
}
```

**Notes**
- The vulnerability exists in production code paths used by mainnet validators
- While exploitation requires operator involvement (config file control), it does not require intentional malice
- The defense-in-depth principle is violated: validation should not be bypassable via the data being validated
- This represents a significant gap in the security model where a configuration mistake can lead to consensus safety violations

### Citations

**File:** config/src/config/persistable_config.rs (L12-56)
```rust
pub trait PersistableConfig: Serialize + DeserializeOwned {
    /// Load the config from disk at the given path
    fn load_config<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        // Read the file into a string
        let file_contents = Self::read_config_file(&path)?;

        // Parse the file string
        Self::parse_serialized_config(&file_contents)
    }

    /// Save the config to disk at the given output path
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        // Serialize the config to a string
        let serialized_config = serde_yaml::to_vec(&self)
            .map_err(|e| Error::Yaml(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Self::write_file(serialized_config, output_file)
    }

    /// Read the config at the given path and return the contents as a string
    fn read_config_file<P: AsRef<Path>>(path: P) -> Result<String, Error> {
        let config_path_string = path.as_ref().to_str().unwrap().to_string();
        read_to_string(config_path_string.clone()).map_err(|error| {
            Error::Unexpected(format!(
                "Failed to read the config file into a string: {:?}. Error: {:?}",
                config_path_string, error
            ))
        })
    }

    /// Create the file and write the serialized config to the file
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
    }

    /// Parse the config from the serialized string
    fn parse_serialized_config(serialized_config: &str) -> Result<Self, Error> {
        serde_yaml::from_str(serialized_config).map_err(|e| Error::Yaml("config".to_string(), e))
    }
}
```

**File:** config/src/config/persistable_config.rs (L59-60)
```rust
impl PersistableConfig for NodeConfig {}
impl PersistableConfig for SafetyRulesConfig {}
```

**File:** config/src/config/safety_rules_config.rs (L71-117)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/node_config_loader.rs (L72-90)
```rust
    pub fn load_and_sanitize_config(&self) -> Result<NodeConfig, Error> {
        // Load the node config from disk
        let mut node_config = NodeConfig::load_config(&self.node_config_path)?;

        // Load the execution config
        let input_dir = RootPath::new(&self.node_config_path);
        node_config.execution.load_from_path(&input_dir)?;

        // Update the data directory. This needs to be done before
        // we optimize and sanitize the node configs (because some optimizers
        // rely on the data directory for file reading/writing).
        node_config.set_data_dir(node_config.get_data_dir().to_path_buf());

        // Optimize and sanitize the node config
        let local_config_yaml = get_local_config_yaml(&self.node_config_path)?;
        optimize_and_sanitize_node_config(&mut node_config, local_config_yaml)?;

        Ok(node_config)
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** secure/storage/src/in_memory.rs (L9-19)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
#[derive(Default)]
pub struct InMemoryStorage {
    data: HashMap<String, Vec<u8>>,
    time_service: TimeService,
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L45-45)
```rust
        let safety_data = SafetyData::new(1, 0, 0, 0, None, 0);
```
