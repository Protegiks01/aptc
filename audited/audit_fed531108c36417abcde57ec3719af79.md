# Audit Report

## Title
Out-of-Order Notification Race Condition Causes Transaction Parking Lot Stalls

## Summary
Out-of-order delivery of reject notifications (from consensus) and commit notifications (from state sync) can cause the mempool to fail promoting sequential transactions from the parking lot, resulting in valid transactions becoming permanently stuck and never being proposed to consensus.

## Finding Description

The Aptos mempool receives transaction state updates through two independent channels:

1. **Reject notifications** from consensus (via `quorum_store_requests` mpsc channel) - sent in the `post_ledger_update` pipeline phase
2. **Commit notifications** from state sync (via `MempoolNotificationListener` channel) - sent after block commit in `notify_state_sync` phase [1](#0-0) [2](#0-1) 

These channels are processed concurrently in the mempool coordinator's event loop, allowing messages to arrive in any order depending on network and processing latencies.

The vulnerability occurs in the sequence number promotion logic. When `commit_transaction` is called, it updates the account's sequence number and invokes `process_ready_seq_num_based_transactions`: [3](#0-2) 

The promotion function uses a while loop that stops at the first missing transaction: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Alice has transactions T5 (seq=5), T6 (seq=6), T7 (seq=7) in mempool
2. Block N proposes T5 and T6
3. T5 succeeds (will be committed)
4. T6 fails with validation error (will be rejected)
5. Consensus sends reject notification for T6 via `quorum_store_requests`
6. Block N commits, state sync sends commit notification for T5 via mempool listener

**If reject notification arrives first:**
- `reject_transaction(Alice, 6, hash_T6)` removes T6
- `commit_transaction(Alice, 5)` sets sequence to 6, calls `process_ready_seq_num_based_transactions(Alice, 6)`
- The function tries to promote T6 (seq=6) but it's already removed
- `process_ready_transaction` returns false
- The while loop exits immediately
- **T7 remains in parking lot despite being next in sequence**

The mempool now believes it needs seq=6 to be ready before promoting T7, but T6 was already rejected and will never return. T7 is permanently stuck until it expires or Alice manually submits a new valid T6. [6](#0-5) [7](#0-6) [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: The mempool's view of ready transactions diverges from the actual blockchain state
- **Transaction liveness degradation**: Valid transactions become permanently stuck in parking lot
- **Selective censorship vector**: Under sustained load with frequent out-of-order notifications, users could experience significant delays in transaction inclusion
- **No direct fund loss**: Does not enable theft or unauthorized minting
- **Requires intervention**: Stuck transactions need manual resubmission or timeout expiration

While not causing consensus safety violations or fund loss, this creates a persistent availability issue affecting transaction throughput and user experience.

## Likelihood Explanation

This vulnerability has **medium-to-high likelihood** of occurring in production:

- **No attacker required**: Happens naturally due to system design with two independent channels
- **Timing-dependent**: Occurs when network latency or processing delays cause notification reordering
- **More likely under load**: High transaction volume and block production rate increases probability
- **Affects legitimate users**: Any account with sequential transactions in mempool
- **Reproducible**: Can be triggered consistently by introducing artificial delays

The separate channel architecture makes this a race condition inherent to the system design rather than a rare edge case.

## Recommendation

Implement sequence number gap handling in `process_ready_seq_num_based_transactions` to skip missing transactions and continue promoting subsequent ones:

```rust
fn process_ready_seq_num_based_transactions(
    &mut self,
    address: &AccountAddress,
    account_sequence_num: u64,
) {
    let mut min_seq = account_sequence_num;
    const MAX_GAP: u64 = 5; // Allow small gaps for race conditions
    let mut gap_count = 0;
    
    loop {
        if self.process_ready_transaction(address, ReplayProtector::SequenceNumber(min_seq)) {
            min_seq += 1;
            gap_count = 0; // Reset gap counter on success
        } else {
            gap_count += 1;
            if gap_count > MAX_GAP {
                break; // Stop after too many consecutive gaps
            }
            min_seq += 1; // Skip this gap and try next sequence number
        }
        
        // Safety check: don't scan too far ahead
        if min_seq > account_sequence_num + 100 {
            break;
        }
    }
    
    // Rest of function remains the same...
}
```

**Alternative solution**: Add timestamp-based ordering guarantees or sequence numbers to notifications to ensure processing order matches logical causality.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::transaction::{ReplayProtector, SignedTransaction};
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    
    #[test]
    fn test_out_of_order_notification_parking_lot_stall() {
        let mut store = TransactionStore::new(&default_mempool_config());
        let sender = AccountAddress::random();
        let private_key = Ed25519PrivateKey::generate_for_testing();
        
        // Insert transactions T5, T6, T7
        let t5 = create_test_transaction(sender, 5, &private_key);
        let t6 = create_test_transaction(sender, 6, &private_key);
        let t7 = create_test_transaction(sender, 7, &private_key);
        
        store.insert_transaction(t5.clone(), TimelineState::NotReady);
        store.insert_transaction(t6.clone(), TimelineState::NotReady);
        store.insert_transaction(t7.clone(), TimelineState::NotReady);
        
        // Set initial account sequence to 5, making T5 ready
        store.commit_transaction(&sender, ReplayProtector::SequenceNumber(4));
        
        // Simulate out-of-order: reject T6 before committing T5
        store.reject_transaction(&sender, ReplayProtector::SequenceNumber(6), &t6.committed_hash());
        
        // Now commit T5 - this should promote T7 but won't due to the bug
        store.commit_transaction(&sender, ReplayProtector::SequenceNumber(5));
        
        // Check if T7 is ready (it should be, but isn't due to the bug)
        let t7_state = store.get_mempool_txn(&sender, ReplayProtector::SequenceNumber(7));
        assert!(t7_state.is_some(), "T7 should still exist");
        
        // Bug: T7 is still in parking lot, not promoted to ready
        let is_ready = store.priority_index.contains(t7_state.unwrap());
        assert!(!is_ready, "BUG: T7 remains in parking lot despite being next in sequence");
    }
}
```

This test demonstrates that when T6 is rejected before T5 commits, T7 (the next sequential transaction) fails to be promoted from the parking lot, confirming the vulnerability.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L558-566)
```rust
        let post_ledger_update_fut = spawn_shared_fut(
            Self::post_ledger_update(
                prepare_fut.clone(),
                ledger_update_fut.clone(),
                self.txn_notifier.clone(),
                block.clone(),
            ),
            Some(&mut abort_handles),
        );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L926-974)
```rust
    async fn post_ledger_update(
        prepare_fut: TaskFuture<PrepareResult>,
        ledger_update_fut: TaskFuture<LedgerUpdateResult>,
        mempool_notifier: Arc<dyn TxnNotifier>,
        block: Arc<Block>,
    ) -> TaskResult<PostLedgerUpdateResult> {
        let mut tracker = Tracker::start_waiting("post_ledger_update", &block);
        let (user_txns, _) = prepare_fut.await?;
        let (compute_result, _, _) = ledger_update_fut.await?;

        tracker.start_working();
        let compute_status = compute_result.compute_status_for_input_txns();
        // the length of compute_status is user_txns.len() + num_vtxns + 1 due to having blockmetadata
        if user_txns.len() >= compute_status.len() {
            // reconfiguration suffix blocks don't have any transactions
            // otherwise, this is an error
            if !compute_status.is_empty() {
                error!(
                        "Expected compute_status length and actual compute_status length mismatch! user_txns len: {}, compute_status len: {}, has_reconfiguration: {}",
                        user_txns.len(),
                        compute_status.len(),
                        compute_result.has_reconfiguration(),
                    );
            }
        } else {
            let user_txn_status = &compute_status[compute_status.len() - user_txns.len()..];
            // todo: avoid clone
            let txns: Vec<SignedTransaction> = user_txns
                .iter()
                .map(|txn| {
                    txn.borrow_into_inner()
                        .try_as_signed_user_txn()
                        .expect("must be a user txn")
                })
                .cloned()
                .collect();

            // notify mempool about failed transaction
            if let Err(e) = mempool_notifier
                .notify_failed_txn(&txns, user_txn_status)
                .await
            {
                error!(
                    error = ?e, "Failed to notify mempool of rejected txns",
                );
            }
        }
        Ok(())
    }
```

**File:** mempool/src/shared_mempool/coordinator.rs (L106-129)
```rust
    loop {
        let _timer = counters::MAIN_LOOP.start_timer();
        ::futures::select! {
            msg = client_events.select_next_some() => {
                handle_client_request(&mut smp, &bounded_executor, msg).await;
            },
            msg = quorum_store_requests.select_next_some() => {
                tasks::process_quorum_store_request(&smp, msg);
            },
            reconfig_notification = mempool_reconfig_events.select_next_some() => {
                handle_mempool_reconfig_event(&mut smp, &bounded_executor, reconfig_notification.on_chain_configs).await;
            },
            (peer, backoff) = scheduled_broadcasts.select_next_some() => {
                tasks::execute_broadcast(peer, backoff, &mut smp, &mut scheduled_broadcasts, executor.clone()).await;
            },
            (network_id, event) = events.select_next_some() => {
                handle_network_event(&bounded_executor, &mut smp, network_id, event).await;
            },
            _ = update_peers_interval.tick().fuse() => {
                handle_update_peers(peers_and_metadata.clone(), &mut smp, &mut scheduled_broadcasts, executor.clone()).await;
            },
            complete => break,
        }
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L547-596)
```rust
    fn process_ready_transaction(
        &mut self,
        address: &AccountAddress,
        txn_replay_protector: ReplayProtector,
    ) -> bool {
        if let Some(txns) = self.transactions.get_mut(address) {
            if let Some(txn) = txns.get_mut(&txn_replay_protector) {
                let sender_bucket = sender_bucket(address, self.num_sender_buckets);
                let ready_for_quorum_store = !self.priority_index.contains(txn);

                self.priority_index.insert(txn);

                // If timeline_state is `NonQualified`, then the transaction is never added to the timeline_index,
                // and never broadcasted to the shared mempool.
                let ready_for_mempool_broadcast = txn.timeline_state == TimelineState::NotReady;
                if ready_for_mempool_broadcast {
                    self.timeline_index
                        .get_mut(&sender_bucket)
                        .unwrap()
                        .insert(txn);
                }

                if ready_for_quorum_store {
                    let bucket = self
                        .timeline_index
                        .get(&sender_bucket)
                        .unwrap()
                        .get_bucket(txn.ranking_score);
                    let bucket = format!("{}_{}", sender_bucket, bucket);

                    Self::log_ready_transaction(
                        txn.ranking_score,
                        bucket.as_str(),
                        &mut txn.insertion_info,
                        ready_for_mempool_broadcast,
                        txn.priority_of_sender
                            .clone()
                            .map_or_else(|| "Unknown".to_string(), |priority| priority.to_string())
                            .as_str(),
                    );
                }
                // Remove txn from parking lot after it has been promoted to
                // priority_index / timeline_index, i.e., txn status is ready.
                self.parking_lot_index.remove(txn);

                return true;
            }
        }
        false
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L603-611)
```rust
    fn process_ready_seq_num_based_transactions(
        &mut self,
        address: &AccountAddress,
        account_sequence_num: u64,
    ) {
        let mut min_seq = account_sequence_num;
        while self.process_ready_transaction(address, ReplayProtector::SequenceNumber(min_seq)) {
            min_seq += 1;
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L671-707)
```rust
    pub fn commit_transaction(
        &mut self,
        account: &AccountAddress,
        replay_protector: ReplayProtector,
    ) {
        match replay_protector {
            ReplayProtector::SequenceNumber(txn_sequence_number) => {
                let current_account_seq_number =
                    self.get_account_sequence_number(account).map_or(0, |v| *v);
                let new_account_seq_number =
                    max(current_account_seq_number, txn_sequence_number + 1);
                self.account_sequence_numbers
                    .insert(*account, new_account_seq_number);
                self.clean_committed_transactions_below_account_seq_num(
                    account,
                    new_account_seq_number,
                );
                self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
            },
            ReplayProtector::Nonce(nonce) => {
                if let Some(txns) = self.transactions.get_mut(account) {
                    if let Some(txn) = txns.remove(&ReplayProtector::Nonce(nonce)) {
                        self.index_remove(&txn);
                        trace!(
                            LogSchema::new(LogEntry::CleanCommittedTxn).txns(TxnsLog::new_txn(
                                txn.get_sender(),
                                txn.get_replay_protector()
                            )),
                            "txns cleaned with committing tx {}:{:?}",
                            txn.get_sender(),
                            txn.get_replay_protector()
                        );
                    }
                }
            },
        }
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L685-696)
```rust
        QuorumStoreRequest::RejectNotification(transactions, callback) => {
            counters::mempool_service_transactions(
                counters::COMMIT_CONSENSUS_LABEL,
                transactions.len(),
            );
            process_rejected_transactions(&smp.mempool, transactions);
            (
                QuorumStoreResponse::CommitResponse(),
                callback,
                counters::COMMIT_CONSENSUS_LABEL,
            )
        },
```

**File:** mempool/src/shared_mempool/tasks.rs (L745-759)
```rust
pub(crate) fn process_rejected_transactions(
    mempool: &Mutex<CoreMempool>,
    transactions: Vec<RejectedTransactionSummary>,
) {
    let mut pool = mempool.lock();

    for transaction in transactions {
        pool.reject_transaction(
            &transaction.sender,
            transaction.replay_protector,
            &transaction.hash,
            &transaction.reason,
        );
    }
}
```
