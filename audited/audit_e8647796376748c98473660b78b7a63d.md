# Audit Report

## Title
DKG Transcript Verification Panic Enables Validator DoS During Epoch Transitions

## Summary
The DKG transcript verification code contains two critical panic vulnerabilities: (1) unchecked array access to `powers_of_radix[j]` that triggers index-out-of-bounds panics when malicious transcripts contain oversized chunk vectors, and (2) `.expect()` calls on MSM operations that can fail. A malicious validator can exploit these to crash honest validators during DKG, potentially preventing epoch transitions.

## Finding Description

The vulnerability exists in the PVSS transcript verification path where the code fails to validate chunk vector sizes before array access and uses `.expect()` for error handling in critical operations.

**Primary Vulnerability - Index-Out-of-Bounds Panic:**

During transcript verification, the code iterates over ciphertext chunks and directly accesses `pp.powers_of_radix[j]` without bounds checking: [1](#0-0) 

The array `pp.powers_of_radix` has length `num_chunks_per_scalar(ell)`: [2](#0-1) 

However, if a malicious transcript contains ciphertexts where `Cs_flat[i].len() > num_chunks_per_scalar(ell)`, then `j` will exceed the array bounds, causing an immediate panic.

**Validation Gap:**

The verification function only validates the outer vector dimensions: [3](#0-2) 

There is NO validation that each inner ciphertext vector `Cs[i][j]` has the correct number of chunks. The code assumes `Cs_flat[i].len() == num_chunks_per_scalar(ell)` but never verifies this assumption.

**Secondary Vulnerability - MSM Panic:**

The MSM operations use `.expect()` which converts errors into panics: [4](#0-3) [5](#0-4) 

The DKG crate documentation acknowledges that MSM operations can fail: [6](#0-5) 

**Attack Vector:**

When validators process DKG transcripts during epoch transitions, they call the verification function: [7](#0-6) 

This flows through the verification chain: [8](#0-7) 

A malicious validator can craft a transcript that:
1. Passes BCS deserialization
2. Has valid outer dimensions (`Cs.len() == num_players`)
3. Contains inner chunk vectors with length > `num_chunks_per_scalar(ell)`

When honest validators verify this transcript, the panic occurs deterministically, crashing their processes. This is a Byzantine fault amplification attack where one malicious validator can crash multiple honest validators.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability enables:

1. **Validator Node Crashes**: Each honest validator attempting to verify the malicious transcript will panic and crash
2. **DKG Session Failure**: If enough validators crash, the DKG cannot reach quorum, blocking successful completion
3. **Epoch Transition Blocking**: Failed DKG prevents the network from transitioning to new epochs, halting validator set updates, stake changes, and governance execution
4. **Consensus Disruption**: Repeated crashes during epoch transitions may require manual intervention to restore network progression

The impact qualifies as **"Validator node slowdowns"** under High Severity criteria (up to $50,000). While not directly causing fund loss, it can halt critical network functions and requires coordinated recovery efforts. The deterministic nature of the crash (as opposed to performance degradation) makes this a severe availability issue.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Crafting an oversized chunk vector requires only modifying array sizes in the transcript structure
- **No Special Privileges Beyond Validator Role**: Any validator within the Byzantine threshold can execute this attack
- **Deterministic Trigger**: The panic occurs with 100% reliability when chunk lengths exceed bounds  
- **Multiple Attack Windows**: Occurs during every epoch transition when DKG runs
- **Bypasses Initial Checks**: The malicious transcript passes deserialization and outer dimension validation

The attack is trivial to execute and guaranteed to disrupt the DKG process on every attempt.

## Recommendation

Add validation for inner chunk vector lengths before the iteration:

```rust
// After line 195 in weighted_transcript.rs, add:
let expected_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
for (i, ciphertext_row) in self.subtrs.Cs.iter().enumerate() {
    for (j, chunk_vec) in ciphertext_row.iter().enumerate() {
        if chunk_vec.len() != expected_chunks {
            bail!(
                "Invalid chunk vector length at Cs[{}][{}]: expected {}, got {}",
                i, j, expected_chunks, chunk_vec.len()
            );
        }
    }
}
```

Additionally, replace `.expect()` calls with proper error propagation:

```rust
// Replace line 264-265:
let weighted_Cs = E::G1::msm(&E::G1::normalize_batch(&base_vec), &exp_vec)
    .map_err(|e| anyhow!("MSM computation failed: {:?}", e))?;
```

## Proof of Concept

```rust
// Proof of concept demonstrating the vulnerability
// This would be added as a test in the DKG crate

#[test]
#[should_panic(expected = "index out of bounds")]
fn test_oversized_chunks_cause_panic() {
    let mut rng = thread_rng();
    let sc = /* initialize secret sharing config */;
    let pp = /* initialize public parameters */;
    
    // Create transcript with oversized chunk vectors
    let mut transcript = Transcript::generate(&sc, &pp, &mut rng);
    
    // Maliciously extend chunk vectors beyond expected size
    let expected_chunks = num_chunks_per_scalar::<Fr>(pp.ell) as usize;
    for player_chunks in transcript.subtrs.Cs.iter_mut() {
        for chunk_vec in player_chunks.iter_mut() {
            // Add extra chunks beyond expected length
            chunk_vec.extend(vec![G1Projective::generator(); expected_chunks]);
        }
    }
    
    // This verification will panic with index out of bounds
    transcript.verify(&sc, &pp, &spks, &eks, &sid).unwrap();
}
```

## Notes

This vulnerability represents a critical failure in input validation where the code makes implicit assumptions about data structure sizes without enforcing them. The panic-based error handling pattern (`.expect()`) is inappropriate for validator-facing code that processes untrusted inputs from peer validators. The fix requires both defensive validation at the verification entry point and replacing panic-inducing error handling with proper Result-based error propagation throughout the cryptographic operation chain.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L255-262)
```rust
        for i in 0..Cs_flat.len() {
            for j in 0..Cs_flat[i].len() {
                let base = Cs_flat[i][j];
                let exp = pp.powers_of_radix[j] * powers_of_beta[i];
                base_vec.push(base);
                exp_vec.push(exp);
            }
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L264-265)
```rust
        let weighted_Cs = E::G1::msm(&E::G1::normalize_batch(&base_vec), &exp_vec)
            .expect("Failed to compute MSM of Cs in chunky");
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L35-40)
```rust
fn compute_powers_of_radix<E: Pairing>(ell: u8) -> Vec<E::ScalarField> {
    utils::powers(
        E::ScalarField::from(1u64 << ell),
        num_chunks_per_scalar::<E::ScalarField>(ell) as usize,
    )
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_scalar_mul.rs (L118-120)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput {
        C::msm(input.bases(), input.scalars()).expect("MSM failed in Schnorr") // TODO: custom MSM here, because only length 1 MSM except during verification
    }
```

**File:** crates/aptos-dkg/README.md (L37-45)
```markdown
### $g_1^0$ and $g_2^0$ multiexps can fail
test_crypto_g1_multiexp_less_points
See `test_crypto_g_2_to_zero_multiexp` and `test_crypto_g_1_to_zero_multiexp`.

### Multiexps with more exponents than bases fail. 

See `test_crypto_g1_multiexp_less_points`.

Instead, they should truncate the exponents to be the size of the bases.
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```
