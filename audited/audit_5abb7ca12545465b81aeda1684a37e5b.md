# Audit Report

## Title
Race Condition in SafetyRulesConfig Loading Enables Consensus Safety Violations via Sanitizer Bypass

## Summary
The `load_config()` function in `persistable_config.rs` lacks file locking, allowing concurrent read/write access to SafetyRulesConfig files. This race condition can result in validators loading corrupted configurations with default values, bypassing critical sanitizer checks when chain ID extraction fails, and enabling mainnet validators to run with non-persistent storage backends that violate consensus safety invariants.

## Finding Description

The configuration loading mechanism has a critical race condition that can lead to consensus safety violations through the following attack path:

**1. Unsynchronized File I/O Operations**

The `load_config()` function uses standard file read operations without any file locking mechanism: [1](#0-0) 

The read operation uses `read_to_string()`: [2](#0-1) 

While the write operation uses `File::create()` followed by `write_all()`: [3](#0-2) 

Neither operation employs file locking, allowing a reading process to access a file that another process is actively writing to, potentially reading an empty, partial, or corrupted YAML file.

**2. Default Value Injection via Serde**

The `SafetyRulesConfig` struct is annotated with `#[serde(default)]`: [4](#0-3) 

When YAML fields are missing due to partial reads, the Default implementation is used: [5](#0-4) 

Critically, the default `backend` is `SecureBackend::InMemoryStorage`, which does NOT persist safety-critical consensus state.

**3. Sanitizer Bypass via Chain ID Extraction Failure**

The sanitizer is designed to prevent mainnet validators from using in-memory storage: [6](#0-5) 

However, these checks only execute when `chain_id` is `Some`: [7](#0-6) 

When configuration corruption prevents genesis file loading, chain ID extraction fails and returns `None`: [8](#0-7) 

The genesis transaction is loaded from the config's execution settings: [9](#0-8) 

If the corrupted config has an incorrect genesis path, `get_genesis_txn()` returns `None`, causing chain ID extraction to fail, and ALL mainnet-specific sanitizer checks are bypassed.

**4. Loss of Safety-Critical State**

When a validator starts with `InMemoryStorage`, the safety rules manager initializes storage: [10](#0-9) 

In-memory storage does not persist critical safety data including `last_voted_round`, `preferred_round`, and `one_chain_round`, which enforce the fundamental consensus voting rules that prevent equivocation.

**5. Equivocation Attack Scenario**

1. Mainnet validator is running with correct `OnDiskStorage` configuration
2. Operator updates config file (e.g., changing network settings)
3. During file write, another process/script restarts the validator (race condition)
4. Validator reads partially-written config file with corrupted genesis path
5. Chain ID extraction fails → `chain_id = None`
6. Sanitizer skips mainnet checks
7. Validator starts with `InMemoryStorage` backend (default value)
8. Safety storage is created fresh in memory with no prior voting history
9. Validator participates in consensus and votes on round N
10. Validator restarts later with correct config
11. Persistent storage is restored, but the in-memory voting at round N was never recorded
12. Validator can vote again on round N with different content → **EQUIVOCATION**

This breaks the fundamental AptosBFT consensus invariant that validators can only vote once per round, enabling potential chain splits.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability enables consensus safety violations, specifically equivocation (double-voting), which is explicitly listed as Critical severity in the Aptos bug bounty program under "Consensus/Safety violations." 

Equivocation can lead to:
- Chain splits when different validators commit to different blocks at the same round
- Violation of BFT safety guarantees if multiple validators simultaneously equivocate
- Potential for Byzantine behavior even from honest validators due to configuration corruption
- Risk of network partition requiring emergency intervention or hardfork

The vulnerability directly violates the consensus safety invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine."

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

This vulnerability requires specific operational circumstances:

**Required Conditions:**
- Concurrent config file write and node startup (race timing)
- YAML truncation pattern that causes genesis path corruption
- Validator restart scenario during config updates

**Realistic Scenarios:**
- Automated deployment tools updating config while orchestration system restarts nodes
- Operator error: two terminal sessions, one editing config, one restarting service
- Configuration management systems (Ansible, Terraform) with improper synchronization
- Multiple validator instances accidentally sharing config files (misconfiguration)

While not trivial to trigger accidentally, the race window exists in any production environment performing config updates, making this a legitimate operational security risk.

## Recommendation

Implement atomic file operations with exclusive file locking to prevent concurrent read/write access:

**Solution 1: Use Atomic Write Pattern (Recommended)**
```rust
fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
    let serialized_config = serde_yaml::to_vec(&self)
        .map_err(|e| Error::Yaml(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    
    // Write to temporary file first
    let temp_path = output_file.as_ref().with_extension("tmp");
    let mut file = File::create(&temp_path)
        .map_err(|e| Error::IO(temp_path.to_str().unwrap().to_string(), e))?;
    file.write_all(&serialized_config)
        .map_err(|e| Error::IO(temp_path.to_str().unwrap().to_string(), e))?;
    file.sync_all()
        .map_err(|e| Error::IO(temp_path.to_str().unwrap().to_string(), e))?;
    
    // Atomic rename
    std::fs::rename(temp_path, output_file.as_ref())
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    
    Ok(())
}
```

**Solution 2: Add File Locking**
Use the `fs2` crate to implement advisory file locks during read/write operations.

**Solution 3: Strengthen Sanitizer**
Make sanitizer checks mandatory even when chain ID is None:
```rust
// Treat None chain_id as potentially mainnet and enforce strict checks
if (chain_id.map(|c| c.is_mainnet()).unwrap_or(true)) 
    && node_type.is_validator()
    && safety_rules_config.backend.is_in_memory()
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "The secure backend should not be set to in memory storage for validators!"
            .to_string(),
    ));
}
```

## Proof of Concept

```rust
// Test demonstrating the race condition vulnerability
// File: config/src/config/persistable_config_race_test.rs

use crate::config::{NodeConfig, SafetyRulesConfig, PersistableConfig};
use std::fs::File;
use std::io::Write;
use std::thread;
use std::time::Duration;
use tempfile::TempDir;

#[test]
fn test_race_condition_causes_corrupted_config_load() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("validator.yaml");
    
    // Create initial valid config
    let mut config = NodeConfig::default();
    config.save_to_path(&config_path).unwrap();
    
    // Simulate race condition: writer truncates file
    let config_path_clone = config_path.clone();
    let writer_thread = thread::spawn(move || {
        // Start writing new config
        let mut file = File::create(&config_path_clone).unwrap();
        thread::sleep(Duration::from_millis(10)); // Simulate slow write
        
        let partial_yaml = b"base:\n  role: validator\n"; // Incomplete YAML
        file.write_all(partial_yaml).unwrap();
    });
    
    // Simulate concurrent reader during write
    thread::sleep(Duration::from_millis(5));
    
    // Attempt to load config during write
    let load_result = NodeConfig::load_config(&config_path);
    
    writer_thread.join().unwrap();
    
    // Verify the race condition can occur:
    // - Either YAML parsing fails (most likely)
    // - OR config loads with default values (dangerous case)
    match load_result {
        Err(_) => {
            // YAML parsing failed - DoS but not consensus violation
            println!("Race caused parsing failure (DoS)");
        },
        Ok(loaded_config) => {
            // Config loaded with defaults - potential consensus violation
            println!("Race caused default value injection");
            // In production, this could result in InMemoryStorage backend
        }
    }
}

#[test]
fn test_sanitizer_bypass_with_none_chain_id() {
    // Demonstrates that chain_id = None bypasses mainnet checks
    use crate::config::{SafetyRulesConfig, SecureBackend};
    use crate::config::config_sanitizer::ConfigSanitizer;
    use crate::config::node_config_loader::NodeType;
    
    let mut node_config = NodeConfig::default();
    
    // Set validator role
    node_config.base.role = crate::config::RoleType::Validator;
    
    // Configure InMemoryStorage (should fail on mainnet)
    node_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
    
    // With chain_id = None, sanitizer check is skipped!
    let result = SafetyRulesConfig::sanitize(
        &node_config,
        NodeType::Validator,
        None, // chain_id = None bypasses the check
    );
    
    // This passes even though it shouldn't!
    assert!(result.is_ok(), "Sanitizer bypass successful with chain_id = None");
}
```

## Notes

The vulnerability stems from three compounding issues:
1. **Lack of atomic file operations** in the config persistence layer
2. **Permissive default values** with `#[serde(default)]` allowing dangerous fallbacks
3. **Conditional sanitizer checks** that can be bypassed when chain ID extraction fails

While the race condition timing window is narrow, the consequences are severe when it occurs. The vulnerability is particularly concerning because it can affect honest validators through operational errors rather than requiring malicious intent. Production environments with automated config management, orchestration systems, or frequent updates are at higher risk.

The issue is exacerbated by the warning-only behavior when chain ID extraction fails, which allows node startup to proceed with potentially unsafe configurations rather than failing fast.

### Citations

**File:** config/src/config/persistable_config.rs (L14-20)
```rust
    fn load_config<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        // Read the file into a string
        let file_contents = Self::read_config_file(&path)?;

        // Parse the file string
        Self::parse_serialized_config(&file_contents)
    }
```

**File:** config/src/config/persistable_config.rs (L32-40)
```rust
    fn read_config_file<P: AsRef<Path>>(path: P) -> Result<String, Error> {
        let config_path_string = path.as_ref().to_str().unwrap().to_string();
        read_to_string(config_path_string.clone()).map_err(|error| {
            Error::Unexpected(format!(
                "Failed to read the config file into a string: {:?}. Error: {:?}",
                config_path_string, error
            ))
        })
    }
```

**File:** config/src/config/persistable_config.rs (L43-50)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L23-34)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct SafetyRulesConfig {
    pub backend: SecureBackend,
    pub logger: LoggerConfig,
    pub service: SafetyRulesService,
    pub test: Option<SafetyRulesTestConfig>,
    // Read/Write/Connect networking operation timeout in milliseconds.
    pub network_timeout_ms: u64,
    pub enable_cached_safety_data: bool,
    pub initial_safety_rules_config: InitialSafetyRulesConfig,
}
```

**File:** config/src/config/safety_rules_config.rs (L36-49)
```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
            logger: LoggerConfig::default(),
            service: SafetyRulesService::Local,
            test: None,
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
            enable_cached_safety_data: true,
            initial_safety_rules_config: InitialSafetyRulesConfig::None,
        }
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/node_config_loader.rs (L117-123)
```rust
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
```

**File:** config/src/utils.rs (L220-222)
```rust
pub fn get_genesis_txn(config: &NodeConfig) -> Option<&Transaction> {
    config.execution.genesis.as_ref()
}
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L21-26)
```rust
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    let internal_storage: Storage = backend.into();
    if let Err(error) = internal_storage.available() {
        panic!("Storage is not available: {:?}", error);
    }
```
