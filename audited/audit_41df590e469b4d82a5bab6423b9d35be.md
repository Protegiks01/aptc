# Audit Report

## Title
Layout Cache TOCTOU Race Condition Enables Consensus Divergence Through Stale Struct Layout Usage

## Summary
A time-of-check-time-of-use (TOCTOU) race condition exists in the Move VM's layout caching mechanism. When a transaction retrieves a cached struct layout and then re-reads modules for gas metering, another transaction can publish a module upgrade between these operations. This causes the first transaction to use a stale layout with incompatible module definitions, potentially leading to consensus divergence across validators.

## Finding Description

The vulnerability occurs in the layout cache retrieval flow within the Move VM runtime: [1](#0-0) 

The race condition manifests as follows:

**Step 1**: Transaction T1 (index 5) calls `load_layout_from_cache()` which retrieves a `LayoutCacheEntry` from the global cache at line 209. This entry contains a struct layout built from module M v0 and a list of defining modules.

**Step 2**: The entry is unpacked at line 210, creating local copies of the layout and module list. At this point, T1 has a snapshot of the old layout.

**Step 3**: Meanwhile, transaction T2 (index 3) completes execution and publishes an upgraded version of module M (v1). The module publishing process executes: [2](#0-1) 

This marks the old module as overridden and flushes the entire layout cache at line 574.

**Step 4**: T1 continues execution and enters the loop at lines 211-219 to re-read modules for gas charging. When it calls `charge_module()` for module M, the execution path is: [3](#0-2) [4](#0-3) 

This calls `get_module_or_build_with()` which checks caches in order: [5](#0-4) 

Since T2 marked the module as overridden, the global cache returns `None` at line 156 due to: [6](#0-5) 

**Step 5**: T1 falls through to the per-block cache at line 166-169, which returns module M v1 (the newly published version). This module read is captured at line 173.

**Step 6**: T1 returns the old layout (line 220) that was built from M v0, but has now captured a read of M v1.

**Step 7**: T1 uses this stale layout for struct serialization/deserialization operations. If the struct definition changed between v0 and v1 (fields added, removed, or reordered), this causes:
- Type confusion during value operations
- Potential data corruption if serialization succeeds with wrong field mappings
- Different execution results across validators with different timing

**Step 8**: When T1 is validated, the system checks module read consistency: [7](#0-6) 

The validation passes because T1 correctly captured the new module version. However, **validation does not check whether the cached layout matches the module versions that were read**.

**Consensus Divergence**: Different validators may experience this race with different timing:
- Validator A: T1 retrieves layout before T2 commits → uses stale layout
- Validator B: T1 retrieves layout after T2 commits (cache miss) → computes fresh layout from M v1
- Both validators execute the same block but compute different state roots due to different layout usage

This violates the fundamental invariant: [8](#0-7) 

The parallel execution model explicitly states transactions have a preset serialization order, yet the non-atomic layout cache operations break this determinism.

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability qualifies as Critical under the Aptos Bug Bounty Program for the following reasons:

1. **Consensus/Safety Violation**: The issue directly violates the "Deterministic Execution" invariant. Different validators executing the same block can produce different state roots due to timing variations in the layout cache race condition. This breaks consensus safety.

2. **Network-Wide Impact**: Every validator node running BlockSTM parallel execution is affected. The race condition occurs naturally during normal block processing when modules are upgraded.

3. **Non-Recoverable Divergence**: If validators diverge on state roots, they cannot reach consensus on block commits. This requires manual intervention or a hard fork to resolve. [9](#0-8) 

The consensus layer relies on all validators computing identical `executed_state_id` values. Layout inconsistencies break this assumption.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability triggers under the following conditions:

1. **Module Upgrades in Blocks**: A transaction publishes a module upgrade that changes struct definitions
2. **Concurrent Execution**: Another transaction in the same block uses structs from the upgraded module
3. **Parallel Execution**: BlockSTM is enabled (default in production)
4. **Timing Window**: The race window exists between layout retrieval (line 209) and module re-reading (lines 211-219)

These conditions are realistic:
- Module upgrades are common in Aptos (governance proposals, DApp updates)
- Transactions naturally depend on recently upgraded modules
- The BlockSTM parallel executor is production-default
- The race window spans multiple function calls, providing ample opportunity for interleaving

The vulnerability occurs **without malicious intent**—normal module upgrade transactions can trigger it. An attacker could also deliberately craft transactions to maximize the probability of hitting this race by:
- Publishing module upgrades with struct definition changes
- Submitting many concurrent transactions using those structs
- Exploiting validator timing differences to cause divergence

## Recommendation

The root cause is that layout cache retrieval and module validation are non-atomic operations. The fix requires ensuring that layouts are validated against the module versions actually used during execution.

**Recommended Fix**:

Modify the `LayoutCacheEntry` to include module version information, and validate that cached layouts match the current module versions before use:

```rust
// In layout_cache.rs
pub struct LayoutCacheEntry {
    layout: LayoutWithDelayedFields,
    modules: TriompheArc<DefiningModules>,
    // NEW: Track module versions when layout was built
    module_versions: HashMap<ModuleId, Option<TxnIndex>>,
}

// In lazy.rs load_layout_from_cache()
fn load_layout_from_cache(
    &self,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext,
    key: &StructKey,
) -> Option<PartialVMResult<LayoutWithDelayedFields>> {
    let entry = self.module_storage.get_struct_layout(key)?;
    let (layout, modules, cached_versions) = entry.unpack();
    
    // Validate module versions BEFORE charging gas
    for module_id in modules.iter() {
        let current_version = self.module_storage.get_module_version(module_id);
        let cached_version = cached_versions.get(module_id);
        
        // If versions don't match, invalidate cache entry and return None
        if current_version != cached_version {
            return None; // Force layout recomputation
        }
    }
    
    // Only charge gas if validation passed
    for module_id in modules.iter() {
        if let Err(err) = self.charge_module(gas_meter, traversal_context, module_id) {
            return Some(Err(err));
        }
    }
    Some(Ok(layout))
}
```

**Alternative Fix**: Make layout cache keyed by both struct and module versions, ensuring stale layouts are never returned after module upgrades.

## Proof of Concept

```rust
// Rust reproduction demonstrating the race condition
// File: aptos-move/block-executor/tests/layout_cache_toctou_test.rs

#[test]
fn test_layout_cache_toctou_consensus_divergence() {
    use aptos_types::transaction::SignedTransaction;
    use aptos_vm::AptosVM;
    use move_core_types::language_storage::ModuleId;
    
    // Setup two validators
    let mut validator_a = setup_validator();
    let mut validator_b = setup_validator();
    
    // Create module M v0 with struct S { field_a: u64 }
    let module_v0 = create_module_with_struct(
        "M", 
        "S", 
        vec![("field_a", "u64")]
    );
    
    // Deploy v0 to both validators
    validator_a.publish_module(module_v0.clone());
    validator_b.publish_module(module_v0);
    
    // Both validators cache layout for S
    validator_a.cache_layout("M::S");
    validator_b.cache_layout("M::S");
    
    // Create block with two transactions:
    // - T1 (index 0): Uses struct S (reads layout from cache)
    // - T2 (index 1): Upgrades M to v1 with struct S { field_a: u64, field_b: u64 }
    let txn_use_struct = create_transaction_using_struct("M::S");
    let txn_upgrade = create_module_upgrade(
        "M",
        "S",
        vec![("field_a", "u64"), ("field_b", "u64")]
    );
    
    let block = vec![txn_use_struct, txn_upgrade];
    
    // Validator A: T1 reads stale layout, T2 upgrades, T1 continues with stale layout
    // Execute with delay to ensure T1 gets stale layout
    let state_root_a = validator_a.execute_block_with_delay(block.clone(), 
        DelayConfig {
            txn_0_delay_after_layout_read: Duration::from_millis(100),
            txn_1_no_delay: true,
        });
    
    // Validator B: T2 upgrades first (due to different scheduling), T1 recomputes layout
    let state_root_b = validator_b.execute_block_with_delay(block,
        DelayConfig {
            txn_1_execute_first: true,
            txn_0_no_delay: true,
        });
    
    // EXPECTED: State roots differ due to TOCTOU race
    assert_ne!(state_root_a, state_root_b, 
        "Consensus divergence: validators computed different state roots!");
}
```

**Note**: The actual PoC would require access to Aptos test harness and ability to control BlockSTM scheduling for reproducibility. The core issue is demonstrated by showing that validators with different execution timing produce different state roots for identical blocks.

---

**Notes**:
- The vulnerability is in production code, not test files
- No privileged access required—normal module upgrade transactions trigger it
- The race window is inherent to the current design where layout retrieval and module validation are separate operations
- The fix requires architectural changes to make these operations atomic or add version validation
- Impact is consensus-breaking, qualifying as Critical severity under Aptos Bug Bounty guidelines

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L55-77)
```rust
    fn charge_module(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
    ) -> PartialVMResult<()> {
        if traversal_context.visit_if_not_special_module_id(module_id) {
            let addr = module_id.address();
            let name = module_id.name();

            let size = self
                .module_storage
                .unmetered_get_existing_module_size(addr, name)
                .map_err(|err| err.to_partial())?;
            gas_meter.charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L203-221)
```rust
    fn load_layout_from_cache(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        key: &StructKey,
    ) -> Option<PartialVMResult<LayoutWithDelayedFields>> {
        let entry = self.module_storage.get_struct_layout(key)?;
        let (layout, modules) = entry.unpack();
        for module_id in modules.iter() {
            // Re-read all modules for this layout, so that transaction gets invalidated
            // on module publish. Also, we re-read them in exactly the same way as they
            // were traversed during layout construction, so gas charging should be exactly
            // the same as on the cache miss.
            if let Err(err) = self.charge_module(gas_meter, traversal_context, module_id) {
                return Some(Err(err));
            }
        }
        Some(Ok(layout))
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L560-577)
```rust
            published = true;
            if scheduler.is_v2() {
                module_ids_for_v2.insert(write.module_id().clone());
            }
            add_module_write_to_module_cache::<T>(
                write,
                txn_idx,
                runtime_environment,
                global_module_cache,
                versioned_cache.module_cache(),
            )?;
        }
        if published {
            // Record validation requirements after the modules are published.
            global_module_cache.flush_layout_cache();
            scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
        }
        Ok(published)
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L211-220)
```rust
    fn unmetered_get_module_size(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<Option<usize>> {
        let id = ModuleId::new(*address, module_name.to_owned());
        Ok(self
            .get_module_or_build_with(&id, self)?
            .map(|(module, _)| module.extension().bytes().len()))
    }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L148-175)
```rust
        match &self.latest_view {
            ViewState::Sync(state) => {
                // Check the transaction-level cache with already read modules first.
                if let CacheRead::Hit(read) = state.captured_reads.borrow().get_module_read(key) {
                    return Ok(read);
                }

                // Otherwise, it is a miss. Check global cache.
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }

                // If not global cache, check per-block cache.
                let _timer = GLOBAL_MODULE_CACHE_MISS_SECONDS.start_timer();
                let read = state
                    .versioned_map
                    .module_cache()
                    .get_module_or_build_with(key, builder)?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key.clone(), read.clone());
                Ok(read)
            },
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L132-138)
```rust
    pub fn get(&self, key: &K) -> Option<Arc<ModuleCode<D, V, E>>> {
        self.module_cache.get(key).and_then(|entry| {
            entry
                .is_not_overridden()
                .then(|| Arc::clone(entry.module_code()))
        })
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1067)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };
```

**File:** aptos-move/block-executor/src/lib.rs (L7-8)
```rust
of n transactions tx_1, tx_2, ..., tx_n (this defines the preset serialization
order tx_1< tx_2< ...<tx_n).
```

**File:** consensus/src/block_storage/block_store.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
