# Audit Report

## Title
Missing Validation in JWK Consensus Allows Acceptance of Mismatched Quorum-Certified Updates

## Summary
The `process_quorum_certified_update()` function in the JWK consensus manager fails to validate that a received `QuorumCertifiedUpdate` matches the node's local proposal (`my_proposal`). This creates a race condition where a node can accept a quorum-certified update for different JWK data than what it actually observed and proposed, potentially causing consensus inconsistencies across validators.

## Finding Description

The JWK consensus system operates on a per-issuer basis where validators observe JWK updates from OIDC providers and reach consensus through a reliable broadcast protocol. When a validator observes new JWKs for an issuer, it creates a proposal and initiates a broadcast to collect signatures from other validators.

The vulnerability exists in the `process_quorum_certified_update()` function which processes incoming quorum-certified updates: [1](#0-0) 

The function extracts the issuer from the update, retrieves the corresponding state, and if the state is `InProgress`, it accepts the update without any validation. Critically, it does NOT verify that:
1. `update.update.issuer` matches `my_proposal.observed.issuer`
2. `update.update` (the complete `ProviderJWKs` struct) matches `my_proposal.observed`

The `ConsensusState` enum defines the state structure: [2](#0-1) 

And `ObservedUpdate` contains the proposal: [3](#0-2) 

**Attack Scenario - Race Condition:**

1. Validator observes JWKs version v1 for issuer "https://example.com"
2. Validator creates `my_proposal` with this v1 data and starts broadcast (creates `InProgress` state)
3. Before the broadcast completes, the issuer rotates keys and validator observes v2
4. Validator calls `process_new_observation()` with v2 data: [4](#0-3) 

5. This overwrites the state to a new `InProgress` with v2 proposal
6. The old `QuorumCertProcessGuard` drops, attempting to abort the v1 broadcast
7. However, the v1 broadcast task may have already completed and sent the v1 QC to the channel before being aborted
8. When `process_quorum_certified_update()` receives the v1 QC:
   - It looks up the state for issuer "https://example.com"  
   - Finds state is `InProgress` (with v2 proposal)
   - Accepts the v1 QC **without validating it matches the v2 proposal**
9. The validator now has a `Finished` state with:
   - `my_proposal` = v2 (what it currently observes)
   - `quorum_certified` = v1 (stale/wrong data)

This breaks the critical invariant that a validator should only accept quorum-certified data that matches what it proposed.

## Impact Explanation

This vulnerability qualifies as **High Severity** based on the following impacts:

1. **Consensus Safety Violation**: Different validators may accept different JWK updates for the same issuer, leading to inconsistent validator transaction pools. While the blockchain's consensus would eventually converge on one version when included in a block, the divergence during the consensus phase violates safety guarantees.

2. **Protocol Violation**: Validators could vote for (via their signatures in the multi-sig) JWK data they didn't actually observe or intend to support. This undermines the security model of the JWK consensus protocol where validators should only certify what they've independently verified.

3. **State Inconsistency**: The mismatch between `my_proposal` and `quorum_certified` in the `Finished` state creates an inconsistent internal state that could lead to undefined behavior in downstream code that assumes these values are related.

4. **Trust Model Breach**: The JWK consensus system is designed to ensure that only authentically observed JWK updates are certified. Accepting mismatched updates allows a node to be "tricked" into supporting data it didn't verify, even without Byzantine validator collusion.

## Likelihood Explanation

The likelihood is **MEDIUM** for the following reasons:

**Factors Increasing Likelihood:**
- JWK rotations can occur frequently in production systems
- The race window exists between broadcast completion and state update
- No special privileges required - can occur naturally during normal operation
- Multiple concurrent observations for the same issuer during key rotations

**Factors Decreasing Likelihood:**
- Requires precise timing of JWK rotation during an in-flight broadcast
- The async task abort mechanism usually prevents stale QCs from being sent
- In practice, JWK rotations may not be rapid enough to trigger this consistently

However, an attacker who can influence the timing of JWK observations (e.g., by controlling when their OIDC provider's JWK endpoint returns different data) could potentially increase the probability of triggering this race condition.

## Recommendation

Add validation in `process_quorum_certified_update()` to ensure the received update matches the current proposal:

```rust
pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
    let issuer = update.update.issuer.clone();
    info!(
        epoch = self.epoch_state.epoch,
        issuer = String::from_utf8(issuer.clone()).ok(),
        version = update.update.version,
        "JWKManager processing certified update."
    );
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    match &state.consensus_state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // ADD VALIDATION HERE
            if update.update != my_proposal.observed {
                return Err(anyhow!(
                    "Quorum certified update does not match local proposal for issuer {:?}. Expected version {}, got version {}",
                    String::from_utf8(issuer),
                    my_proposal.observed.version,
                    update.update.version
                ));
            }
            
            let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
            let vtxn_guard =
                self.vtxn_pool
                    .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
            state.consensus_state = ConsensusState::Finished {
                vtxn_guard,
                my_proposal: my_proposal.clone(),
                quorum_certified: update.clone(),
            };
            info!(
                epoch = self.epoch_state.epoch,
                issuer = String::from_utf8(issuer).ok(),
                version = update.update.version,
                "certified update accepted."
            );
            Ok(())
        },
        _ => Err(anyhow!(
            "qc update not expected for issuer {:?} in state {}",
            String::from_utf8(issuer.clone()),
            state.consensus_state.name()
        )),
    }
}
```

This validation ensures that the complete `ProviderJWKs` (issuer, version, and jwks) match between the certified update and the local proposal, preventing acceptance of stale or mismatched updates.

## Proof of Concept

```rust
#[tokio::test]
async fn test_race_condition_mismatched_qc() {
    // Setup: Create epoch state with validators
    let private_keys: Vec<Arc<PrivateKey>> = (0..4)
        .map(|_| Arc::new(PrivateKey::generate_for_testing()))
        .collect();
    let public_keys: Vec<PublicKey> = private_keys
        .iter()
        .map(|sk| PublicKey::from(sk.as_ref()))
        .collect();
    let addrs: Vec<AccountAddress> = (0..4).map(|_| AccountAddress::random()).collect();
    let validator_consensus_infos: Vec<ValidatorConsensusInfo> = (0..4)
        .map(|i| ValidatorConsensusInfo::new(addrs[i], public_keys[i].clone(), 1))
        .collect();
    let epoch_state = Arc::new(EpochState {
        epoch: 999,
        verifier: ValidatorVerifier::new(validator_consensus_infos).into(),
    });

    let update_certifier = DummyUpdateCertifier::default();
    let vtxn_pool = VTxnPoolState::default();
    let mut jwk_manager = IssuerLevelConsensusManager::new(
        private_keys[0].clone(),
        addrs[0],
        epoch_state.clone(),
        Arc::new(update_certifier),
        vtxn_pool,
    );

    let issuer = issuer_from_str("https://example.com");
    
    // Step 1: Observe v1 JWKs
    let jwks_v1 = vec![JWK::Unsupported(UnsupportedJWK::new_for_testing("key1", "payload1")).into()];
    jwk_manager.process_new_observation(issuer.clone(), jwks_v1.clone()).unwrap();
    
    // Step 2: Simulate rapid rotation - observe v2 JWKs before v1 consensus completes
    let jwks_v2 = vec![JWK::Unsupported(UnsupportedJWK::new_for_testing("key2", "payload2")).into()];
    jwk_manager.process_new_observation(issuer.clone(), jwks_v2.clone()).unwrap();
    
    // Now state has my_proposal for v2
    let state = jwk_manager.states_by_issuer.get(&issuer).unwrap();
    let my_proposal_v2 = match &state.consensus_state {
        ConsensusState::InProgress { my_proposal, .. } => my_proposal.clone(),
        _ => panic!("Expected InProgress state"),
    };
    assert_eq!(my_proposal_v2.observed.version, 1); // v2 is version 1
    
    // Step 3: Simulate receiving stale QC for v1 (from the first broadcast)
    let observed_v1 = ProviderJWKs {
        issuer: issuer.clone(),
        version: 1,
        jwks: jwks_v1,
    };
    let signer_bit_vec = BitVec::from(vec![true, true, true, true]);
    let sig = Signature::aggregate(
        private_keys.iter().map(|sk| sk.sign(&observed_v1).unwrap()).collect()
    ).unwrap();
    let multi_sig = AggregateSignature::new(signer_bit_vec, Some(sig));
    let qc_v1 = QuorumCertifiedUpdate {
        update: observed_v1.clone(),
        multi_sig,
    };
    
    // BUG: This should fail but currently succeeds because there's no validation
    let result = jwk_manager.process_quorum_certified_update(qc_v1.clone());
    
    // The function accepts the mismatched QC
    assert!(result.is_ok(), "BUG: Function accepts QC that doesn't match my_proposal");
    
    // Verify the inconsistent state: my_proposal is v2 but quorum_certified is v1
    let final_state = jwk_manager.states_by_issuer.get(&issuer).unwrap();
    match &final_state.consensus_state {
        ConsensusState::Finished { my_proposal, quorum_certified, .. } => {
            // This demonstrates the bug: my_proposal and quorum_certified don't match!
            assert_ne!(my_proposal.observed, quorum_certified.update,
                "BUG: Accepted QC doesn't match proposal");
        },
        _ => panic!("Expected Finished state"),
    }
}
```

This PoC demonstrates that the function accepts a quorum-certified update even when it doesn't match the current `my_proposal`, creating an inconsistent `Finished` state where the proposal and certified update differ.

## Notes

The vulnerability stems from incomplete validation in the state machine transitions. While the `ObservationAggregationState` correctly validates that all peers agree on the same view during aggregation [5](#0-4) , the final acceptance logic fails to verify that the aggregated result still matches the current node state. This is a classic TOCTOU (Time-Of-Check-Time-Of-Use) vulnerability where the state can change between when the broadcast was initiated and when the result is processed.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L184-228)
```rust
    pub fn process_new_observation(
        &mut self,
        issuer: Issuer,
        jwks: Vec<JWKMoveStruct>,
    ) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L323-358)
```rust
    pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
        let issuer = update.update.issuer.clone();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            version = update.update.version,
            "JWKManager processing certified update."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
            },
            _ => Err(anyhow!(
                "qc update not expected for issuer {:?} in state {}",
                String::from_utf8(issuer.clone()),
                state.consensus_state.name()
            )),
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L44-49)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq)]
pub struct ObservedUpdate {
    pub author: AccountAddress,
    pub observed: ProviderJWKs,
    pub signature: Signature,
}
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L104-115)
```rust
pub enum ConsensusState<T: Debug + Clone + Eq + PartialEq> {
    NotStarted,
    InProgress {
        my_proposal: T,
        abort_handle_wrapper: QuorumCertProcessGuard,
    },
    Finished {
        vtxn_guard: TxnGuard,
        my_proposal: T,
        quorum_certified: QuorumCertifiedUpdate,
    },
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```
