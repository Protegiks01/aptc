# Audit Report

## Title
Authentication Bypass in VFN Network Allowing Unauthenticated Peers to Impersonate Trusted ValidatorFullNode Role

## Summary
Validators using `MaybeMutual` authentication mode on the VFN network automatically assign the `PeerRole::ValidatorFullNode` role to any inbound connection based solely on network context, without requiring authentication. Combined with special eviction exemptions for ValidatorFullNode peers, this allows attackers to establish persistent, unauthenticated connections to validators while being treated as trusted VFN peers.

## Finding Description

The vulnerability exists in the network authentication logic across three key locations:

**1. Authentication Mode Configuration**
Validators use non-mutual authentication (`MaybeMutual` mode) on the VFN network by default: [1](#0-0) 

The `is_validator_network()` check returns `false` for VFN networks: [2](#0-1) 

This causes validators to use `HandshakeAuthMode::MaybeMutual` instead of `HandshakeAuthMode::Mutual` on VFN networks: [3](#0-2) 

**2. Peer Role Inference Without Authentication**
In `MaybeMutual` mode, when a peer is NOT in the trusted peers set, the handshake logic infers the peer role based solely on network context: [4](#0-3) 

At lines 407-410, the code automatically assigns `PeerRole::ValidatorFullNode` to ANY inbound connection on the VFN network to a validator, regardless of whether the peer is authenticated or in the trusted peers set.

**3. Eviction Exemption for ValidatorFullNode Peers**
The connectivity manager specifically exempts ValidatorFullNode peers from eviction in non-mutual authentication mode: [5](#0-4) 

Lines 494-498 prevent closing connections to inbound ValidatorFullNode peers even when they are not in the trusted peers set.

**Attack Scenario:**
1. Attacker establishes TCP connection to validator on VFN network port
2. Performs Noise handshake with self-generated keypair and peer ID
3. Validator accepts handshake in MaybeMutual mode without checking trusted peers
4. Validator infers attacker's role as `PeerRole::ValidatorFullNode` based on network context
5. Attacker maintains persistent connection that won't be evicted
6. Attacker is now treated as a trusted VFN peer in the network hierarchy

## Impact Explanation

**Critical Severity** - This qualifies as Critical under the Aptos bug bounty program for the following reasons:

1. **Authentication Bypass**: Complete bypass of the trusted peers authentication mechanism on a critical network interface
2. **Trusted Peer Impersonation**: Attacker gains `ValidatorFullNode` privilege level, which places them in the trusted upstream hierarchy: [6](#0-5) 

3. **Resource Exhaustion**: Attacker can consume validator connection slots, potentially preventing legitimate VFNs from connecting and disrupting the network
4. **Persistent Unauthorized Access**: Connections won't be cleaned up during normal stale connection eviction
5. **Protocol Access**: Attacker gains access to protocols exposed on the VFN network, potentially including mempool transaction propagation, state sync data, and other validator services

The ValidatorFullNode role designation means the attacker is treated as "Always upstream for incoming connections" per the PeerRole documentation: [7](#0-6) 

## Likelihood Explanation

**High Likelihood** - The vulnerability is:
- Trivially exploitable (requires only basic network connectivity)
- No special permissions or resources required
- No race conditions or timing dependencies
- Reproducible 100% of the time
- Affects all validators running default VFN network configurations
- No authentication credentials needed

Any attacker with network access to a validator's VFN port can exploit this vulnerability.

## Recommendation

**Immediate Fix**: Require authentication for all inbound connections on the VFN network, or implement proper validation before inferring ValidatorFullNode role.

**Option 1 - Validate Peer ID Construction**:
The existing code validates that the peer ID matches the public key but doesn't verify the peer is authorized. Add an additional check to ensure unknown peers on VFN network are marked as `Unknown` instead of `ValidatorFullNode`:

```rust
// In handshake.rs, lines 406-423, change to:
if self.network_context.role().is_validator() {
    if network_id.is_vfn_network() {
        // Don't automatically trust inbound connections as VFNs
        // They should be explicitly in the trusted peer set
        Ok(PeerRole::Unknown)
    } else {
        Ok(PeerRole::Unknown)
    }
} else {
    Ok(PeerRole::Unknown)
}
```

**Option 2 - Enforce Mutual Authentication on VFN Network**:
Change the default to require mutual authentication on VFN networks for validators:
```rust
// In network_config.rs:
let mutual_authentication = network_id.is_validator_network() 
    || (role.is_validator() && network_id.is_vfn_network());
```

**Option 3 - Remove Eviction Exemption**:
Remove the special eviction exemption for unauthenticated ValidatorFullNode peers:
```rust
// In connectivity_manager/mod.rs, lines 492-502:
// Remove the ValidatorFullNode exemption for non-authenticated peers
if !self.mutual_authentication
    && metadata.origin == ConnectionOrigin::Inbound
    && metadata.role == PeerRole::Unknown  // Only exempt Unknown, not VFN
{
    None
} else {
    Some(*peer_id)
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_unauthenticated_vfn_impersonation() {
    use aptos_config::network_id::{NetworkContext, NetworkId};
    use aptos_config::config::RoleType;
    use aptos_types::PeerId;
    use aptos_crypto::x25519;
    
    // Setup: Create validator on VFN network
    let validator_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let validator_peer_id = PeerId::random();
    let validator_context = NetworkContext::new(
        RoleType::Validator,
        NetworkId::Vfn,
        validator_peer_id
    );
    
    // Setup: Create attacker with random keys (not in trusted peers)
    let attacker_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let attacker_peer_id = aptos_types::account_address::from_identity_public_key(
        attacker_key.public_key()
    );
    
    // Create empty trusted peers (attacker not included)
    let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Vfn]);
    
    // Create validator with MaybeMutual auth mode (default for VFN)
    let validator_upgrader = NoiseUpgrader::new(
        validator_context,
        validator_key,
        HandshakeAuthMode::maybe_mutual(peers_and_metadata)
    );
    
    // Attacker connects and completes handshake
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    
    let attacker_upgrader = NoiseUpgrader::new(
        NetworkContext::new(RoleType::FullNode, NetworkId::Vfn, attacker_peer_id),
        attacker_key,
        HandshakeAuthMode::server_only(&[NetworkId::Vfn])
    );
    
    // Execute handshake
    let (_, server_result) = block_on(join(
        attacker_upgrader.upgrade_outbound(
            dialer_socket,
            validator_peer_id,
            validator_upgrader.noise_config.public_key(),
            AntiReplayTimestamps::now
        ),
        validator_upgrader.upgrade_inbound(listener_socket)
    ));
    
    // Verify: Attacker successfully connected and was marked as ValidatorFullNode
    let (_, peer_id, peer_role) = server_result.unwrap();
    assert_eq!(peer_id, attacker_peer_id);
    assert_eq!(peer_role, PeerRole::ValidatorFullNode); // VULNERABILITY: Unauthenticated peer marked as trusted VFN
    
    // Verify: This connection would NOT be evicted in close_stale_connections
    // because it has ValidatorFullNode role and is inbound in non-mutual auth mode
}
```

## Notes

The vulnerability stems from an architectural decision to use role inference based on network context rather than requiring explicit authentication. The comment "Inbound connections to validators on the VFN network must be VFNs" at line 409 of handshake.rs reveals this assumption, but it's an unsafe assumption that allows authentication bypass.

The TODO comment at line 493 of connectivity_manager/mod.rs ("We should prevent `Unknown` from discovery sources") suggests awareness of potential issues with unauthenticated peers, but the current implementation fails to address the ValidatorFullNode inference vulnerability.

### Citations

**File:** config/src/config/network_config.rs (L135-136)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
```

**File:** config/src/config/network_config.rs (L396-404)
```rust
/// Rules for upstream nodes via Peer Role:
///
/// Validator -> Always upstream if not Validator else P2P
/// PreferredUpstream -> Always upstream, overriding any other discovery
/// ValidatorFullNode -> Always upstream for incoming connections (including other ValidatorFullNodes)
/// Upstream -> Upstream, if no ValidatorFullNode or PreferredUpstream.  Useful for initial seed discovery
/// Downstream -> Downstream, defining a controlled downstream that I always want to connect
/// Known -> A known peer, but it has no particular role assigned to it
/// Unknown -> Undiscovered peer, likely due to a non-mutually authenticated connection always downstream
```

**File:** config/src/network_id.rs (L168-170)
```rust
    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** config/src/network_id.rs (L199-203)
```rust
            NetworkId::Vfn => match role {
                RoleType::Validator => &[PeerRole::ValidatorFullNode],
                RoleType::FullNode => &[],
            },
        }
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-503)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });
```
