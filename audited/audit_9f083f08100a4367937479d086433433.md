# Audit Report

## Title
ViewFunction Execution Lacks State Root Verification - Allows Malicious Nodes to Serve Forged Blockchain State

## Summary
The ViewFunction API and all state read endpoints use an unverified `DbStateView` that does not perform Merkle proof verification against the state root hash. This allows a malicious or compromised API node to serve forged blockchain state to users without cryptographic detection, breaking the fundamental integrity guarantees of blockchain data access.

## Finding Description

The Aptos API layer creates state views without cryptographic verification when serving view function calls and state queries to users. The codebase provides two methods for creating state views:

1. **Unverified**: `state_view_at_version` - sets `maybe_verify_against_state_root_hash: None`
2. **Verified**: `verified_state_view_at_version` - verifies transaction proofs and sets the state root hash for Merkle verification

The API uses the unverified method throughout: [1](#0-0) 

This calls: [2](#0-1) 

Which creates an unverified DbStateView: [3](#0-2) 

The DbStateView only performs Merkle proof verification when `maybe_verify_against_state_root_hash` is Some, but the API sets it to None: [4](#0-3) 

**Attack Scenario:**

1. Attacker runs a malicious API node with a modified database
2. User queries ViewFunction or any state endpoint on this node
3. Malicious database returns forged state values (e.g., fake account balances, fake module code)
4. API executes ViewFunction or returns resources based on this forged data
5. User receives incorrect results with no way to detect the forgery cryptographically
6. User makes financial decisions or transactions based on forged data

The codebase already provides the correct secure implementation that verifies against the state root: [5](#0-4) 

This secure version is used in executor tests but not in the production API: [6](#0-5) 

## Impact Explanation

This vulnerability has **High Severity** impact:

**Critical Invariant Violated**: "State Consistency: State transitions must be atomic and verifiable via Merkle proofs" - The API serves state without Merkle proof verification.

**Security Impact**:
- Users querying malicious API nodes receive cryptographically unverified state data
- No way for users to detect forged state without running their own node
- Can lead to financial losses if users make decisions based on forged balances, governance state, or staking information
- Breaks the fundamental blockchain guarantee that all state is cryptographically verifiable
- Affects ALL API state read operations: ViewFunctions, account resources, modules, table items, etc.

**Scope**: Every user querying the API is vulnerable when connecting to a malicious or compromised node.

While this doesn't directly cause on-chain loss of funds (which would be Critical), it enables significant off-chain attacks and violates core blockchain security guarantees, qualifying as **High Severity** under "Significant protocol violations" and potentially "API crashes" if considering the integrity failure.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements**:
- Run a malicious API node (low barrier - anyone can run a node)
- Modify database to return forged state (requires system access but feasible)
- Social engineer users to query their node, OR wait for users to discover it via DNS/load balancers

**Feasibility**:
- Many users rely on public API endpoints rather than running their own nodes
- Users often trust API providers without verification mechanisms
- Node operators have full database access
- Database corruption bugs could also trigger this unintentionally

**Detection Difficulty**: 
- Users have no cryptographic way to verify correctness of API responses
- Requires comparing responses across multiple trusted nodes
- Silent failure - no error indicates the data is forged

## Recommendation

The API should use `verified_state_view_at_version` instead of `state_view_at_version` for all user-facing state queries. This ensures Merkle proof verification against the state root hash.

**Fix for `api/src/context.rs`:**

Replace the `state_view()` method to use verified state views:

```rust
pub fn state_view<E: StdApiError>(
    &self,
    requested_ledger_version: Option<u64>,
) -> Result<(LedgerInfo, u64, DbStateView), E> {
    let (latest_ledger_info, requested_ledger_version) =
        self.get_latest_ledger_info_and_verify_lookup_version(requested_ledger_version)?;

    // Use VERIFIED state view that validates against Merkle root
    let state_view = self
        .db
        .verified_state_view_at_version(Some(requested_ledger_version), &latest_ledger_info)
        .map_err(|err| {
            E::internal_with_code(err, AptosErrorCode::InternalError, &latest_ledger_info)
        })?;

    Ok((latest_ledger_info, requested_ledger_version, state_view))
}
```

**Performance Consideration**: This adds Merkle proof verification overhead. If performance is critical, implement sampling-based verification (verify a random subset of reads) as suggested in the TODO comments. [7](#0-6) 

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_view_function_accepts_forged_state() {
    // Create a malicious DbReader that returns forged state
    struct MaliciousDbReader {
        real_db: Arc<dyn DbReader>,
    }
    
    impl DbReader for MaliciousDbReader {
        fn get_state_value_with_version_by_version(
            &self,
            state_key: &StateKey,
            version: Version,
        ) -> Result<Option<(Version, StateValue)>> {
            // Return forged state value instead of real one
            let forged_value = StateValue::new_legacy(vec![0xFF; 100]);
            Ok(Some((version, forged_value)))
        }
        // ... implement other required methods ...
    }
    
    // Create API context with malicious DB
    let malicious_db = Arc::new(MaliciousDbReader { real_db: db.clone() });
    let context = Context::new(/* ... with malicious_db ... */);
    
    // Execute view function - it will use forged state without verification
    let view_request = ViewRequest {
        function: EntryFunctionId::from_str("0x1::coin::balance").unwrap(),
        type_arguments: vec![],
        arguments: vec![],
    };
    
    let result = view_function(&context, view_request, None).await;
    
    // Result is based on forged state, no error is raised
    assert!(result.is_ok()); // Vulnerability: accepts forged data
    
    // Compare with verified version (if we used it)
    let verified_view = db.verified_state_view_at_version(Some(version), &ledger_info).unwrap();
    // This would fail proof verification and return error
}
```

## Notes

The TODO comments in the code indicate this is a known limitation related to "buffered state," but the API serves committed state at specific versions where proofs are available. The secure `verified_state_view_at_version` implementation exists and is used in executor tests, demonstrating the intended security model is not applied to production API endpoints.

This represents a gap between the blockchain's cryptographic security guarantees (state is verifiable via Merkle proofs) and the API's actual implementation (no verification performed).

### Citations

**File:** api/src/view_function.rs (L105-113)
```rust
    let state_view = context
        .state_view_at_version(requested_version)
        .map_err(|err| {
            BasicErrorWith404::bad_request_with_code(
                err,
                AptosErrorCode::InternalError,
                &ledger_info,
            )
        })?;
```

**File:** api/src/context.rs (L193-195)
```rust
    pub fn state_view_at_version(&self, version: Version) -> Result<DbStateView> {
        Ok(self.db.state_view_at_version(Some(version))?)
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L97-105)
```rust
impl DbStateViewAtVersion for Arc<dyn DbReader> {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L107-147)
```rust
pub trait VerifiedStateViewAtVersion {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView>;
}

impl VerifiedStateViewAtVersion for Arc<dyn DbReader> {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
        } else {
            Ok(DbStateView {
                db,
                version: None,
                maybe_verify_against_state_root_hash: None,
            })
        }
    }
}
```

**File:** execution/executor-test-helpers/src/integration_test_impl.rs (L266-269)
```rust
    let view = db
        .reader
        .verified_state_view_at_version(Some(current_version), latest_li)
        .unwrap();
```
