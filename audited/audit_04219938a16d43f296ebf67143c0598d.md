# Audit Report

## Title
Position Invariant Violation in Transaction Accumulator Pruner for Near-Maximum Version Values

## Summary
The transaction accumulator pruner can violate the Position invariant constraint (`Position.0 < u64::MAX - 1`) when processing versions near `u64::MAX`, leading to a panic that crashes validator nodes and causes loss of availability.

## Finding Description

The vulnerability exists in the interaction between the pruning logic and the Position data structure's invariant constraints. The Position struct has a documented invariant that requires `Position.0 < u64::MAX - 1`. [1](#0-0) 

This invariant is actively enforced through assertions in critical Position methods: [2](#0-1) 

When the transaction accumulator pruner processes versions close to `u64::MAX`, the algorithm in `TransactionAccumulatorDb::prune()` performs position calculations that can create Position values approaching or exceeding this invariant bound. [3](#0-2) 

The pruning algorithm iterates through versions and for odd versions, it:
1. Finds the first ancestor that is a left child via bit manipulation
2. Iteratively descends the tree calling `right_child()` to delete nodes [4](#0-3) 

The `find_first_ancestor_that_is_a_left_child()` function uses bit shifts and `Position::from_level_and_pos()`: [5](#0-4) 

When `version` is near `u64::MAX - 2` (an odd number close to the maximum), the calculation `index_in_level = version >> level` combined with the left shift in `from_level_and_pos()` at line 66 can produce Position values very close to `u64::MAX - 1`. Subsequently, calling `right_child()` in the pruning loop increments these position values, potentially reaching or exceeding `u64::MAX - 1`, which triggers the invariant assertion panic. [6](#0-5) 

The target version is set by the ledger pruner manager without any upper bound validation: [7](#0-6) 

## Impact Explanation

This is a **HIGH severity** issue per the Aptos bug bounty criteria because:

1. **Validator Node Crash**: The panic in the pruner causes the validator node to crash, affecting network availability
2. **Loss of Liveness**: Affected validators cannot participate in consensus, potentially degrading network liveness
3. **Denial of Service**: If multiple validators are affected (e.g., all running similar software versions with high ledger versions), this could cause significant network disruption

While the issue qualifies as "Validator node slowdowns/API crashes" under High Severity, the deterministic panic makes this particularly severe.

## Likelihood Explanation

The likelihood is currently **LOW** in production environments because:

1. Current Aptos mainnet version numbers are in the billions, far from `2^64 - 1 â‰ˆ 18.4 quintillion`
2. At current transaction rates, it would take millennia to reach problematic version numbers

However, the likelihood increases in specific scenarios:
- Test networks or forks initialized with artificially high version numbers
- Future long-running networks (though extremely distant future)
- Potential bugs that could cause version number corruption to high values

Despite low current likelihood, this is a **latent** vulnerability that violates code invariants and will eventually manifest if the network runs long enough.

## Recommendation

Add explicit validation to prevent pruning near the maximum version value. Implement a safety check in the pruner to reject target versions that could trigger the invariant violation:

```rust
pub(crate) fn prune(begin: Version, end: Version, db_batch: &mut SchemaBatch) -> Result<()> {
    // Safety check: ensure we don't process versions that could violate Position invariants
    // Position invariant requires Position.0 < u64::MAX - 1
    // Conservative bound accounting for position calculations and tree depth
    const MAX_SAFE_VERSION: Version = u64::MAX - (1 << 16); // ~64K safety margin
    
    if end > MAX_SAFE_VERSION {
        return Err(anyhow::anyhow!(
            "Cannot prune versions above {} to maintain Position invariants. Requested end: {}",
            MAX_SAFE_VERSION,
            end
        ).into());
    }
    
    // existing pruning logic...
    for version_to_delete in begin..end {
        // ...
    }
    Ok(())
}
```

Additionally, add validation in the ledger pruner manager:

```rust
fn set_pruner_target_db_version(&self, latest_version: Version) {
    assert!(self.pruner_worker.is_some());
    let min_readable_version = latest_version.saturating_sub(self.prune_window);
    
    // Validate min_readable_version is within safe bounds
    const MAX_SAFE_PRUNER_VERSION: Version = u64::MAX - (1 << 16);
    if min_readable_version > MAX_SAFE_PRUNER_VERSION {
        // Log warning and skip pruning rather than panic
        warn!(
            "Pruner target version {} exceeds safety threshold {}. Skipping pruning.",
            min_readable_version,
            MAX_SAFE_PRUNER_VERSION
        );
        return;
    }
    
    // existing code...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod position_invariant_violation_test {
    use super::*;
    use aptos_schemadb::batch::SchemaBatch;

    #[test]
    #[should_panic(expected = "assertion failed: self.0 < u64::MAX - 1")]
    fn test_prune_near_max_version_triggers_panic() {
        // This test demonstrates that pruning near u64::MAX causes a panic
        // due to Position invariant violation
        
        let mut batch = SchemaBatch::new();
        
        // Attempt to prune a range ending very close to u64::MAX
        // The loop will process version u64::MAX - 2 (if odd) or nearby odd versions
        // which will trigger position calculations that violate the invariant
        let begin = u64::MAX - 10;
        let end = u64::MAX - 1;
        
        // This should panic when processing high odd versions
        // due to Position invariant assertion failure in child() or related methods
        let result = TransactionAccumulatorDb::prune(begin, end, &mut batch);
        
        // If we reach here without panic, the test fails
        panic!("Expected panic from Position invariant violation did not occur");
    }
    
    #[test]
    fn test_position_calculation_near_max() {
        // Demonstrate that position calculations for high versions
        // can produce values near the invariant boundary
        let version = u64::MAX - 2; // An even number near max
        
        // For odd version one less
        let odd_version = u64::MAX - 3;
        
        // Find first ancestor that is a left child
        let level = odd_version.trailing_ones();
        let index_in_level = odd_version >> level;
        
        // This will create a Position very close to u64::MAX - 1
        let pos = Position::from_level_and_pos(level, index_in_level);
        
        // Verify the position value is dangerously close to the limit
        assert!(pos.to_inorder_index() > u64::MAX - 100);
    }
}
```

**Notes:**

While this vulnerability has extremely low practical likelihood in current production environments, it represents a violation of fundamental code invariants and could cause node crashes under specific conditions. The issue should be addressed to ensure long-term robustness and to prevent potential future exploitation scenarios where version numbers might be artificially manipulated or in extremely long-running test networks.

### Citations

**File:** types/src/proof/position/mod.rs (L33-35)
```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord, PartialOrd)]
pub struct Position(u64);
// invariant Position.0 < u64::MAX - 1
```

**File:** types/src/proof/position/mod.rs (L62-68)
```rust
    pub fn from_level_and_pos(level: u32, pos: u64) -> Self {
        assert!(level < 64);
        assert!(1u64 << level > 0); // bitwise and integer operations don't mix.
        let level_one_bits = (1u64 << level) - 1;
        let shifted_pos = if level == 63 { 0 } else { pos << (level + 1) };
        Position(shifted_pos | level_one_bits)
    }
```

**File:** types/src/proof/position/mod.rs (L112-114)
```rust
    fn child(self, dir: NodeDirection) -> Self {
        assert!(!self.is_leaf());
        assert!(self.0 < u64::MAX - 1); // invariant
```

**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L149-172)
```rust
    pub(crate) fn prune(begin: Version, end: Version, db_batch: &mut SchemaBatch) -> Result<()> {
        for version_to_delete in begin..end {
            db_batch.delete::<TransactionAccumulatorRootHashSchema>(&version_to_delete)?;
            // The even version will be pruned in the iteration of version + 1.
            if version_to_delete % 2 == 0 {
                continue;
            }

            let first_ancestor_that_is_a_left_child =
                Self::find_first_ancestor_that_is_a_left_child(version_to_delete);

            // This assertion is true because we skip the leaf nodes with address which is a
            // a multiple of 2.
            assert!(!first_ancestor_that_is_a_left_child.is_leaf());

            let mut current = first_ancestor_that_is_a_left_child;
            while !current.is_leaf() {
                db_batch.delete::<TransactionAccumulatorSchema>(&current.left_child())?;
                db_batch.delete::<TransactionAccumulatorSchema>(&current.right_child())?;
                current = current.right_child();
            }
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L175-192)
```rust
    fn find_first_ancestor_that_is_a_left_child(version: Version) -> Position {
        // We can get the first ancestor's position based on the two observations:
        // - floor(level position of a node / 2) = level position of its parent.
        // - if a node is a left child of its parent, its level position should be a multiple of 2.
        // - level position means the position counted from 0 of a single tree level. For example,
        //                a (level position = 0)
        //         /                                \
        //    b (level position = 0)      c(level position = 1)
        //
        // To find the first ancestor which is a left child of its parent, we can keep diving the
        // version by 2 (to find the ancestor) until we get a number which is a multiple of 2
        // (to make sure the ancestor is a left child of its parent). The number of time we
        // divide the version is the level of the ancestor. The remainder is the level position
        // of the ancestor.
        let first_ancestor_that_is_a_left_child_level = version.trailing_ones();
        let index_in_level = version >> first_ancestor_that_is_a_left_child_level;
        Position::from_level_and_pos(first_ancestor_that_is_a_left_child_level, index_in_level)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```
