# Audit Report

## Title
Config Sanitizer Failpoints Validation Bypass via Missing Chain ID

## Summary
The `sanitize_failpoints_config` function has zero test coverage and contains an uncovered validation branch that skips the mainnet failpoints check when `chain_id` is `None`, potentially allowing failpoints-enabled binaries to bypass mainnet restrictions.

## Finding Description
The config sanitizer's failpoints validation logic contains a conditional check that only validates against mainnet when the chain ID is present: [1](#0-0) 

When the genesis transaction extraction fails in the node config loader, the system continues with `chain_id = None`: [2](#0-1) 

This creates a validation gap where:
1. A node is configured without a valid genesis transaction (or with a corrupted genesis file)
2. The `get_chain_id()` function fails and returns an error
3. The `extract_node_type_and_chain_id()` function catches the error and returns `None` for chain_id
4. The sanitizer runs with `chain_id = None`
5. The mainnet failpoints check at lines 84-90 is completely skipped
6. Both compile-time failpoints (via feature flag) and runtime failpoints config (lines 95-105) proceed without mainnet validation

The entire `sanitize_failpoints_config` function has **zero test coverage**. The test file shows no tests for:
- The mainnet failpoints check
- The failpoints consistency validation
- The `chain_id = None` edge case
- Any error paths in this function [3](#0-2) 

A similar bypass exists in the API config sanitizer: [4](#0-3) 

## Impact Explanation
This qualifies as **Medium severity** per the bug bounty criteria because:

1. **State Inconsistencies**: If a failpoints-enabled node were to start on mainnet (even partially), it could cause state inconsistencies requiring manual intervention
2. **Defense-in-Depth Violation**: The sanitizer is the first line of defense for catching misconfigurations; this bypass weakens that layer
3. **Limited Exploitability**: The impact is mitigated by later validation stages (genesis waypoint checks, DB initialization requirements)

However, the node will likely fail during database initialization without a valid genesis transaction: [5](#0-4) 

This limits real-world exploitability, but the sanitizer should still catch the issue early rather than relying on downstream failures.

## Likelihood Explanation
**Low to Medium likelihood** in practice:

**Why Low:**
- Requires compiling a custom binary with `--features failpoints`
- Requires deliberately omitting or corrupting the genesis transaction
- Node will likely crash during DB initialization without valid genesis
- Other validators won't accept connections from improperly initialized nodes

**Why Medium:**
- Accidental misconfigurations could occur (corrupted genesis file, incorrect deployment)
- The sanitizer's job is to catch these issues EARLY, before node startup
- The complete lack of test coverage means this code path has never been validated
- Similar patterns exist in multiple sanitizers (failpoints, API config)

## Recommendation
Add comprehensive test coverage for all validation branches in `sanitize_failpoints_config`:

```rust
#[test]
fn test_sanitize_failpoints_on_mainnet_with_none_chain_id() {
    // Create a node config (simulating missing genesis scenario)
    let node_config = NodeConfig {
        failpoints: Some(HashMap::new()),
        ..Default::default()
    };
    
    // When chain_id is None, the sanitizer should still enforce checks
    // or explicitly fail for validators
    let result = sanitize_failpoints_config(
        &node_config,
        NodeType::Validator,
        None  // Simulates missing/invalid genesis
    );
    
    // Should either enforce checks or fail explicitly
    assert!(result.is_err(), "Sanitizer should not allow None chain_id for validators");
}

#[test]
fn test_sanitize_failpoints_enabled_on_mainnet() {
    // This test requires the failpoints feature to be enabled
    #[cfg(feature = "failpoints")]
    {
        let node_config = NodeConfig::default();
        
        let error = sanitize_failpoints_config(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet())
        ).unwrap_err();
        
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }
}

#[test]
fn test_sanitize_failpoints_config_consistency() {
    // Test the failpoints enabled but empty config case
    #[cfg(feature = "failpoints")]
    {
        let node_config = NodeConfig {
            failpoints: Some(HashMap::new()),  // Empty
            ..Default::default()
        };
        
        let error = sanitize_failpoints_config(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet())
        ).unwrap_err();
        
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }
}
```

**Code Fix**: Make the sanitizer explicitly fail when chain_id is None for validators:

```rust
fn sanitize_failpoints_config(
    node_config: &NodeConfig,
    node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints = &node_config.failpoints;
    let failpoints_enabled = are_failpoints_enabled();
    
    // For validators, chain_id must be known
    if node_type.is_validator() && chain_id.is_none() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Chain ID must be available for validators (check genesis configuration)".into(),
        ));
    }
    
    // Verify that failpoints are not enabled in mainnet
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
    
    // Rest of validation...
}
```

## Proof of Concept

```rust
// Test demonstrating the bypass (add to config_sanitizer.rs tests)
#[test]
fn test_failpoints_bypass_with_missing_genesis() {
    use crate::config::node_startup_config::NodeStartupConfig;
    
    // Create a validator config without genesis transaction
    let mut node_config = NodeConfig {
        base: BaseConfig {
            role: RoleType::Validator,
            ..Default::default()
        },
        execution: ExecutionConfig {
            genesis: None,  // Missing genesis transaction
            ..Default::default()
        },
        ..Default::default()
    };
    
    // Simulate what happens in production: chain_id extraction fails â†’ returns None
    // In node_config_loader.rs, this would result in:
    // "Failed to extract the chain ID from the genesis transaction: ... Continuing with None."
    
    // When sanitizer runs with chain_id = None, the mainnet check is bypassed
    let result = NodeConfig::sanitize(&node_config, NodeType::Validator, None);
    
    // Currently this passes (bypassing the mainnet failpoints check)
    // It SHOULD fail for validators when chain_id is None
    println!("Sanitizer result with chain_id=None: {:?}", result);
    
    // The bug: sanitizer passes even though it should enforce chain_id for validators
}
```

## Notes

This finding demonstrates a **test coverage gap** that creates a **defense-in-depth weakness** rather than a directly exploitable vulnerability. The real-world impact is limited because:

1. Nodes require valid genesis transactions for proper operation
2. Database initialization will fail without genesis waypoint validation
3. Consensus participation requires proper genesis state

However, the sanitizer's purpose is to catch configuration errors **early** and **explicitly**, rather than allowing the node to proceed until it hits a runtime failure. The complete absence of test coverage for this critical validation function means these edge cases have never been validated, which violates the principle of defense-in-depth.

The recommended fix makes the sanitizer more robust by explicitly requiring chain_id for validators, ensuring misconfigurations are caught at the earliest possible stage.

### Citations

**File:** config/src/config/config_sanitizer.rs (L84-91)
```rust
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }
```

**File:** config/src/config/config_sanitizer.rs (L203-407)
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        config::{node_startup_config::NodeStartupConfig, NetworkConfig},
        network_id::NetworkId,
    };

    #[test]
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }

    #[test]
    fn test_sanitize_missing_pfn_network_configs() {
        // Create a PFN config with empty fullnode network configs
        let node_config = NodeConfig {
            full_node_networks: vec![],
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::PublicFullnode,
            Some(ChainId::mainnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_sanitize_missing_vfn_network_configs() {
        // Create a VFN config with empty fullnode network configs
        let node_config = NodeConfig {
            full_node_networks: vec![],
            ..Default::default()
        };

        // Sanitize the PFN config and verify that it fails
        let error = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::ValidatorFullnode,
            Some(ChainId::testnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_sanitize_validator_network_for_fullnode() {
        // Create a fullnode config that includes a validator network
        let node_config = NodeConfig {
            full_node_networks: vec![NetworkConfig {
                network_id: NetworkId::Validator,
                ..Default::default()
            }],
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::PublicFullnode,
            Some(ChainId::testnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_sanitize_duplicate_fullnode_network_configs() {
        // Create a node config with multiple fullnode network configs with the same network id
        let node_config = NodeConfig {
            full_node_networks: vec![
                NetworkConfig {
                    network_id: NetworkId::Public,
                    ..Default::default()
                },
                NetworkConfig {
                    network_id: NetworkId::Public,
                    ..Default::default()
                },
            ],
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::ValidatorFullnode,
            Some(ChainId::testnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_sanitize_missing_validator_network_config() {
        // Create a node config with an empty validator network config
        let node_config = NodeConfig {
            validator_network: None,
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = sanitize_validator_network_config(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_sanitize_validator_network_fullnode() {
        // Create a validator network config
        let node_config = NodeConfig {
            validator_network: Some(NetworkConfig {
                network_id: NetworkId::Validator,
                mutual_authentication: true,
                ..Default::default()
            }),
            ..Default::default()
        };

        // Sanitize the config (for a fullnode) and verify that it fails
        let error = sanitize_validator_network_config(
            &node_config,
            NodeType::PublicFullnode,
            Some(ChainId::testnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_sanitize_validator_disabled_authentication() {
        // Create a validator config with disabled mutual authentication
        let node_config = NodeConfig {
            validator_network: Some(NetworkConfig {
                network_id: NetworkId::Validator,
                mutual_authentication: false,
                ..Default::default()
            }),
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = sanitize_validator_network_config(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_sanitize_validator_incorrect_network_id() {
        // Create a validator config with the wrong network ID
        let node_config = NodeConfig {
            validator_network: Some(NetworkConfig {
                network_id: NetworkId::Public,
                ..Default::default()
            }),
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = sanitize_validator_network_config(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }
}
```

**File:** config/src/config/node_config_loader.rs (L117-123)
```rust
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
```

**File:** config/src/config/api_config.rs (L178-185)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** aptos-node/src/storage.rs (L80-84)
```rust
            // FastSyncDB requires ledger info at epoch 0 to establish provenance to genesis
            let ledger_info = db_arc
                .get_temporary_db_with_genesis()
                .get_epoch_ending_ledger_info(0)
                .expect("Genesis ledger info must exist");
```
