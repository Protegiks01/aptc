# Audit Report

## Title
IP Allowlist Bypass Enables Resource Exhaustion Attack on Faucet Transaction Submission Capacity

## Summary
An attacker controlling an allowlisted IP address can flood the Aptos faucet with concurrent requests, completely bypassing rate limiting mechanisms and exhausting the funder backend's transaction submission capacity. This occurs because the IP allowlist bypasser skips ALL checkers including rate limiters, and the only protection mechanism (optional concurrent request semaphore) may be disabled or set too high.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **IP Allowlist Bypasser** - When an IP is allowlisted, it returns true to bypass all checks: [1](#0-0) 

2. **Request Processing** - When a bypasser returns true, the system skips ALL checkers including rate limiters: [2](#0-1) 

3. **Weak Concurrency Control** - The only protection is an optional semaphore that can be None: [3](#0-2) 

**Attack Flow:**
1. Attacker controls or compromises an allowlisted IP (e.g., CI system, partner network)
2. Sends hundreds of concurrent fund requests from this IP
3. All requests bypass rate limiting because `request_can_bypass()` returns true
4. If `concurrent_requests_semaphore` is None (as in CLI configuration) or set high, all requests enter the system
5. Funder backend queues and processes requests with only 15 outstanding transactions at a time: [4](#0-3) 

6. The funder's sequence numbers get consumed rapidly, legitimate requests are delayed indefinitely, and the funder account floods the mempool with transactions

The rate limiters that should prevent this are completely bypassed: [5](#0-4) 

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Service Disruption**: The faucet becomes unable to serve legitimate users, affecting developer onboarding and testnet operations
2. **Resource Exhaustion**: The funder backend's transaction submission capacity is exhausted, consuming sequence numbers and flooding the mempool
3. **Limited Blast Radius**: While impactful, this only affects the faucet service, not consensus, validator operations, or blockchain state
4. **Requires Privileged Access**: Attack requires access to an allowlisted IP, though such IPs may include CI systems or partner networks that could be compromised

The configuration showing the semaphore can be disabled: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attack Complexity**: Low - simple HTTP flood from allowlisted IP
- **Attacker Requirements**: Access to allowlisted IP (CI systems, development environments, partner networks could be targets)
- **Detection**: Would appear as legitimate traffic from trusted IPs, making it harder to detect initially
- **Common Misconfigurations**: The CLI builder sets `max_concurrent_requests: None`: [7](#0-6) 

## Recommendation

**Solution 1: Implement Separate Rate Limiting for Bypassed Requests**

Modify the bypass mechanism to skip only authentication/captcha checks but still enforce rate limits. Add a separate rate limiter specifically for bypassed requests with higher but still bounded limits.

**Solution 2: Always Enforce Concurrency Limits**

Make `concurrent_requests_semaphore` mandatory with a reasonable default (e.g., 100) and enforce it even for bypassed requests. Update the configuration:

```rust
// In HandlerConfig
pub struct HandlerConfig {
    pub use_helpful_errors: bool,
    pub return_rejections_early: bool,
    // Make this non-optional with a reasonable default
    #[serde(default = "HandlerConfig::default_max_concurrent_requests")]
    pub max_concurrent_requests: usize,
}

impl HandlerConfig {
    fn default_max_concurrent_requests() -> usize {
        100
    }
}
```

**Solution 3: Implement Per-IP Rate Limiting at Bypass Level**

Add rate limiting specifically in the bypass logic before skipping other checkers, ensuring that even trusted IPs have resource bounds.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_allowlisted_ip_resource_exhaustion() -> Result<()> {
    // Setup: Create faucet config with IP allowlist and NO concurrent_requests_semaphore
    let config = RunConfig {
        handler_config: HandlerConfig {
            use_helpful_errors: true,
            return_rejections_early: false,
            max_concurrent_requests: None, // Vulnerable: no limit
        },
        bypasser_configs: vec![
            BypasserConfig::IpAllowlist(IpRangeManagerConfig {
                file_path: Some("/tmp/allowlist.txt".into()),
                lists: None,
            })
        ],
        // ... other config
    };
    
    // Add attacker's IP to allowlist
    std::fs::write("/tmp/allowlist.txt", "127.0.0.1/32\n")?;
    
    let (port, _handle) = start_server(config).await?;
    
    // Attack: Send 1000 concurrent requests from allowlisted IP
    let mut tasks = Vec::new();
    for _ in 0..1000 {
        let task = tokio::spawn(async move {
            reqwest::Client::new()
                .post(format!("http://127.0.0.1:{}/fund", port))
                .json(&FundRequest {
                    amount: Some(1000),
                    address: Some(AccountAddress::random().to_string()),
                    ..Default::default()
                })
                .send()
                .await
        });
        tasks.push(task);
    }
    
    // All requests will be accepted and processed, exhausting capacity
    let results = futures::future::join_all(tasks).await;
    
    // Verify: Most requests succeed because rate limiting was bypassed
    let successful_requests = results.iter()
        .filter(|r| r.is_ok() && r.as_ref().unwrap().is_ok())
        .count();
    
    // Without the vulnerability, rate limiting would have rejected most requests
    // With the vulnerability, many requests succeed, proving the bypass
    assert!(successful_requests > 500, "Rate limiting was bypassed");
    
    Ok(())
}
```

**Notes:**
- This vulnerability demonstrates a design flaw where security bypassers (intended for trusted IPs) completely disable resource protection mechanisms
- The attack is realistic because allowlisted IPs often include CI systems, development networks, or partner infrastructure that could be compromised or abused
- The fix should maintain the convenience of allowlists while still enforcing reasonable resource bounds to prevent exhaustion attacks

### Citations

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L204-215)
```rust
        let permit = match &self.concurrent_requests_semaphore {
            Some(semaphore) => match semaphore.try_acquire() {
                Ok(permit) => Some(permit),
                Err(_) => {
                    return Err(AptosTapError::new(
                        "Server overloaded, please try again later".to_string(),
                        AptosTapErrorCode::ServerOverloaded,
                    ))
                },
            },
            None => None,
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L38-39)
```rust
// Default max in mempool is 20.
const MAX_NUM_OUTSTANDING_TRANSACTIONS: u64 = 15;
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L68-91)
```rust
    async fn check(
        &self,
        data: CheckerData,
        dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        self.clear_if_new_day().await;

        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }

        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L93-96)
```rust
        let concurrent_requests_semaphore = self
            .handler_config
            .max_concurrent_requests
            .map(|v| Arc::new(Semaphore::new(v)));
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L306-310)
```rust
            handler_config: HandlerConfig {
                use_helpful_errors: true,
                return_rejections_early: false,
                max_concurrent_requests: None,
            },
```
