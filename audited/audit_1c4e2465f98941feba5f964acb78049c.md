# Audit Report

## Title
TPS Checker Completely Bypasses Chain ID Validation, Allowing Nodes on Fake Chains to Pass Performance Tests

## Summary
The TPS checker in the node health checking system trusts the target node's reported chain ID without any validation against the baseline. Due to concurrent checker execution, a malicious node operator can report an arbitrary chain ID, process fake transactions, and pass TPS validation despite not being on the legitimate Aptos network.

## Finding Description

The TPS checker obtains the chain ID directly from the target node being tested and uses it to build the transaction emitter cluster, without any cross-validation against a known correct baseline. [1](#0-0) 

The code contains a misleading comment claiming chain ID validation has already occurred: [2](#0-1) 

However, this assumption is **false**. All checkers execute concurrently without dependencies: [3](#0-2) 

Even though a `NodeIdentityChecker` exists to validate chain IDs, it runs in parallel with the TPS checker, providing no guarantee of execution order or validation. [4](#0-3) 

When the cluster is built, the provided chain ID is trusted completely: [5](#0-4) 

**Attack Scenario:**

1. Malicious node operator configures a fake Aptos node with `chain_id=999` (not mainnet/testnet)
2. Node operator runs node-checker pointing at their fake node
3. TPS checker queries the fake node's API, receives `chain_id=999`
4. Cluster is built using `chain_id=999` without validation
5. Transactions are submitted to the fake node
6. Fake node returns fabricated "committed" transaction responses
7. TPS checker reports 100/100 score, believing transactions were processed at required TPS
8. Node appears to meet performance requirements despite not being on the legitimate Aptos network

The transaction commitment verification only queries the target node itself: [6](#0-5) 

A compromised node can trivially fake these responses, making the entire TPS measurement meaningless.

## Impact Explanation

This vulnerability represents a **High Severity** issue under the Aptos bug bounty criteria as a "Significant protocol violation." 

The node health checking protocol is designed to ensure nodes meet performance and network requirements before being trusted for validator operations or community reliance. By bypassing chain ID validation, this vulnerability:

1. **Undermines Validator Qualification**: Node operators can demonstrate fake performance metrics without actually processing transactions on the legitimate network
2. **Breaks Trust Assumptions**: The node-checker's results become unreliable, potentially misleading stakeholders about network health
3. **Violates Documented Design**: The comment explicitly states chain ID validation should occur first, indicating this is unintended behavior (a bug, not a design choice)

While this doesn't directly affect consensus safety or fund security, it compromises the integrity of the node qualification and monitoring infrastructure, which is critical for maintaining network reliability.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is easily exploitable by any node operator:
- No special privileges required beyond running a node-checker instance
- No sophisticated attacks needed - just configure a fake node to return fake responses
- The node-checker is commonly used for validator qualification and network monitoring
- The concurrent execution model makes this bug unavoidable in current implementation

The only mitigating factor is that actual validator consensus participation requires staking and on-chain verification, which would catch non-functioning nodes. However, the damage to monitoring infrastructure integrity and potential for misleading performance claims makes this a realistic threat.

## Recommendation

**Immediate Fix:**

1. Make TPS checker explicitly depend on NodeIdentityChecker completion
2. Use baseline chain ID instead of target-provided chain ID
3. Add independent chain ID verification before TPS testing

**Code Fix:**

Modify the TPS checker to validate chain ID against baseline before testing:

```rust
async fn check(
    &self,
    providers: &ProviderCollection,
) -> Result<Vec<CheckResult>, CheckerError> {
    // Get BOTH baseline and target providers
    let baseline_api_index_provider = get_provider!(
        providers.baseline_api_index_provider,
        self.config.common.required,
        ApiIndexProvider
    );
    
    let target_api_index_provider = get_provider!(
        providers.target_api_index_provider,
        self.config.common.required,
        ApiIndexProvider
    );

    // Verify baseline and target chain IDs match BEFORE proceeding
    let baseline_response = baseline_api_index_provider.provide().await?;
    let target_response = match target_api_index_provider.provide().await {
        Ok(response) => response,
        Err(err) => {
            return Ok(vec![Self::build_result(
                "Failed to get chain ID of your node".to_string(),
                0,
                format!("There was an error querying your node's API: {:#}", err),
            )]);
        },
    };
    
    // CRITICAL: Validate chain IDs match
    if baseline_response.chain_id != target_response.chain_id {
        return Ok(vec![Self::build_result(
            "Chain ID mismatch - cannot perform TPS test".to_string(),
            0,
            format!(
                "Your node reports chain ID {} but baseline is {}. TPS testing requires matching chain IDs.",
                target_response.chain_id, baseline_response.chain_id
            ),
        )]);
    }

    // Use BASELINE chain ID for cluster building (not target's)
    let chain_id = ChainId::new(baseline_response.chain_id);
    
    // Continue with existing TPS testing logic...
}
```

**Structural Fix:**

Implement a checker dependency system in `SyncRunner` to enforce execution ordering when required, preventing race conditions between validation and testing checkers.

## Proof of Concept

```rust
// Demonstration of the vulnerability
// File: test_tps_chain_bypass.rs

use aptos_node_checker::checker::tps::{TpsChecker, TpsCheckerConfig};
use aptos_node_checker::checker::Checker;
use aptos_node_checker::provider::{ApiIndexProvider, ProviderCollection};
use aptos_rest_client::Client;
use aptos_sdk::types::chain_id::ChainId;
use std::sync::Arc;
use url::Url;

#[tokio::test]
async fn test_tps_checker_accepts_arbitrary_chain_id() {
    // Setup fake node that reports chain_id=999 (not legitimate Aptos network)
    let fake_node_url = "http://malicious-node.example.com:8080";
    
    // Mock target provider that returns fake chain_id
    let fake_client = Client::new(Url::parse(fake_node_url).unwrap());
    let target_provider = Arc::new(ApiIndexProvider::new(
        Default::default(),
        fake_client,
    ));
    
    // Build provider collection with compromised target
    let mut providers = ProviderCollection::default();
    providers.target_api_index_provider = Some(target_provider);
    
    // TPS checker configuration
    let tps_config = TpsCheckerConfig {
        minimum_tps: 100,
        // ... other config
        ..Default::default()
    };
    
    let tps_checker = TpsChecker::new(tps_config).unwrap();
    
    // VULNERABILITY: TPS checker will use chain_id=999 from the fake node
    // without any validation against legitimate Aptos chain IDs
    // The fake node can then return fake "committed" transaction responses
    // and pass the TPS check with 100/100 score
    
    let results = tps_checker.check(&providers).await;
    
    // Fake node passes TPS check despite being on wrong chain
    assert!(results.is_ok());
    assert_eq!(results.unwrap()[0].score, 100);
}
```

**Reproduction Steps:**

1. Set up a mock HTTP server that responds to Aptos REST API endpoints
2. Configure mock to return `chain_id: 999` on `/` (index endpoint)  
3. Configure mock to return fake transaction commit responses
4. Point node-checker's TPS test at the mock server
5. Observe TPS checker reports success despite fake chain ID
6. Verify NodeIdentityChecker (if configured) fails concurrently, but TPS result is already reported

This demonstrates that **all security guarantees of TPS checking are bypassed** when the target provider is compromised or malicious, validating the security question's premise.

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L102-104)
```rust
    // You'll see that we're using the baseline chain ID here. This is okay
    // because at this point we've already asserted the baseline and target
    // have the same chain id.
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L119-128)
```rust
        let chain_id = match target_api_index_provider.provide().await {
            Ok(response) => ChainId::new(response.chain_id),
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to get chain ID of your node".to_string(),
                    0,
                    format!("There was an error querying your node's API: {:#}", err),
                )]);
            },
        };
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L155-163)
```rust
        // Call each of the Checkers without awaiting them yet.
        let mut futures = Vec::new();
        for checker in &self.checkers {
            futures.push(self.call_check(checker, &provider_collection));
        }

        // Run all the Checkers concurrently and collect their results.
        let check_results: Vec<CheckResult> =
            try_join_all(futures).await?.into_iter().flatten().collect();
```

**File:** ecosystem/node-checker/src/checker/node_identity.rs (L100-111)
```rust
        let check_results = vec![
            self.help_build_check_result(
                baseline_response.chain_id,
                target_response.chain_id,
                "Chain ID",
            ),
            self.help_build_check_result(
                baseline_response.node_role,
                target_response.node_role,
                "Role Type",
            ),
        ];
```

**File:** crates/transaction-emitter-lib/src/cluster.rs (L100-110)
```rust
        let chain_id_from_instances = get_chain_id_from_instances(instance_states.clone())?;
        let chain_id: ChainId = match maybe_chain_id {
            Some(c) => c,
            None => {
                warn!(
                    "Chain ID not provided, using the chain ID derived from the rest endpoints: {}",
                    chain_id_from_instances
                );
                chain_id_from_instances
            },
        };
```

**File:** crates/aptos-rest-client/src/lib.rs (L885-909)
```rust
            |hash| async move {
                let resp = self.get_transaction_by_hash_inner(hash).await?;
                if resp.status() != StatusCode::NOT_FOUND {
                    let txn_resp: Response<Transaction> = self.json(resp).await?;
                    let (transaction, state) = txn_resp.into_parts();

                    if !transaction.is_pending() {
                        if !transaction.success() {
                            Ok(WaitForTransactionResult::FailedExecution(
                                transaction.vm_status(),
                            ))
                        } else {
                            Ok(WaitForTransactionResult::Success(Response::new(
                                transaction,
                                state,
                            )))
                        }
                    } else {
                        Ok(WaitForTransactionResult::Pending(state))
                    }
                } else {
                    let error_response = parse_error(resp).await;
                    Ok(WaitForTransactionResult::NotFound(error_response))
                }
            },
```
