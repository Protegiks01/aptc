# Audit Report

## Title
Unbounded kv_responses Channel Enables Memory Exhaustion Attack on Shard Executors

## Summary
The executor service's remote state view system uses unbounded channels for kv_responses, allowing a malicious or compromised coordinator to flood shard executors with excessive response messages. This causes memory exhaustion and processing delays on validator nodes, as the `kv_responses` metric only tracks but does not prevent this attack.

## Finding Description

The remote executor architecture uses a coordinator-shard model where shards request state values via `RemoteKVRequest` and receive `RemoteKVResponse` messages. The vulnerability exists in the message queue implementation:

**Unbounded Channel Creation:**
The NetworkController creates unbounded channels for all message types including kv_responses: [1](#0-0) [2](#0-1) 

**Response Processing Without Bounds:**
The RemoteStateValueReceiver processes all incoming kv_responses from the unbounded channel: [3](#0-2) 

Each response is deserialized and processed without any validation of request-response correlation: [4](#0-3) 

**Metrics Track But Don't Prevent:**
The kv_responses metric only increments a counter without imposing any limits: [5](#0-4) 

**Attack Scenario:**
1. A compromised coordinator sends legitimate ExecuteBlockCommand to shard
2. Coordinator simultaneously floods the shard with excessive RemoteKVResponse messages (each up to 80MB per GRPC limit) [6](#0-5) 
3. Messages accumulate in the unbounded channel consuming memory
4. The shard's thread pool is overwhelmed processing spurious responses
5. Legitimate block execution is delayed or the node crashes from OOM

**No Protection Mechanisms:**
- No authentication/validation of responses against pending requests
- No rate limiting on incoming responses
- No backpressure mechanism
- No queue size limits
- No correlation tracking between requests and responses

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

**Validator Node Slowdowns:** A malicious coordinator can deliberately slow down shard execution by flooding the kv_responses channel, causing processing delays that impact block execution times and consensus participation.

**Potential API Crashes:** If the attack causes sufficient memory exhaustion, the validator node process may crash, leading to temporary unavailability.

**Consensus Liveness Impact:** Delayed or crashed shard executors cannot complete block execution in time, potentially causing validators to miss consensus rounds and affecting network liveness.

The attack requires compromising the coordinator role, but does not require validator-level Byzantine behavior (< 1/3 threshold). A single compromised coordinator can target all shards under its control.

## Likelihood Explanation

**High Likelihood** because:

1. **Easy to Execute:** Once a coordinator is compromised, the attack is trivial - simply send excessive kv_responses
2. **No Detection:** The metric tracks message counts but triggers no alerts or rate limiting
3. **No Authentication:** Responses are not validated against legitimate requests
4. **Large Attack Surface:** Each GRPC message can be 80MB, multiplied by unlimited queue depth
5. **Immediate Impact:** Effects are immediate - memory consumption and processing delays occur instantly

**Attack Requirements:**
- Compromise coordinator node (single point of attack)
- Network access to send GRPC messages to shards
- No special cryptographic keys or validator privileges needed

## Recommendation

Implement bounded channels with backpressure and request-response correlation:

```rust
// 1. Use bounded channels instead of unbounded
pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    // Define reasonable bound based on expected concurrent requests
    const KV_RESPONSE_CHANNEL_SIZE: usize = 1000;
    let (inbound_sender, inbound_receiver) = bounded(KV_RESPONSE_CHANNEL_SIZE);
    
    self.inbound_handler
        .lock()
        .unwrap()
        .register_handler(message_type, inbound_sender);
    
    inbound_receiver
}

// 2. Add request-response correlation tracking in RemoteStateView
pub struct RemoteStateView {
    state_values: DashMap<StateKey, RemoteStateValue>,
    pending_requests: Arc<DashMap<RequestId, HashSet<StateKey>>>, // NEW
    request_counter: Arc<AtomicU64>, // NEW
}

// 3. Validate responses against pending requests in handle_message
fn handle_message(...) {
    let response: RemoteKVResponse = bcs::from_bytes(&message.data).unwrap();
    
    // NEW: Validate response contains only requested keys
    for (state_key, _) in &response.inner {
        if !state_view_lock.has_state_key(state_key) {
            warn!("Received unrequested state key: {:?}", state_key);
            continue; // Ignore unrequested keys
        }
    }
    
    // Process only validated keys
    response.inner.into_iter().for_each(|(state_key, state_value)| {
        if state_view_lock.has_state_key(&state_key) {
            state_view_lock.set_state_value(&state_key, state_value);
        }
    });
}

// 4. Add rate limiting on coordinator response sending
// In RemoteStateViewService::handle_message
pub fn handle_message(...) {
    // Add rate limiter check before processing
    if !rate_limiter.check_and_update(shard_id) {
        warn!("Rate limit exceeded for shard {}", shard_id);
        return;
    }
    // ... existing code
}
```

## Proof of Concept

```rust
// PoC demonstrating unbounded queue memory exhaustion
// Add to execution/executor-service/src/tests.rs

#[test]
fn test_kv_response_flooding_memory_exhaustion() {
    use crate::{RemoteKVResponse};
    use aptos_types::state_store::{state_key::StateKey, state_value::StateValue};
    use crossbeam_channel::unbounded;
    use std::thread;
    use std::time::Duration;
    
    // Simulate unbounded channel (current implementation)
    let (tx, rx) = unbounded();
    
    // Simulate malicious coordinator flooding with responses
    let flood_handle = thread::spawn(move || {
        let large_state_value = StateValue::new_legacy(vec![0u8; 1024 * 1024]); // 1MB value
        
        for i in 0..10000 {
            // Create response with 80 key-value pairs (approaching 80MB GRPC limit)
            let mut response_data = vec![];
            for j in 0..80 {
                let key = StateKey::raw(format!("key_{}_{}", i, j).as_bytes().to_vec());
                response_data.push((key, Some(large_state_value.clone())));
            }
            
            let response = RemoteKVResponse::new(response_data);
            let message = bcs::to_bytes(&response).unwrap();
            
            // Send without any throttling (current behavior)
            tx.send(crate::Message::new(message)).unwrap();
            
            if i % 100 == 0 {
                println!("Sent {} flooding messages, queue size unbounded", i);
            }
        }
    });
    
    // Simulate shard receiver trying to process
    let mut processed = 0;
    let start = std::time::Instant::now();
    
    // Try to process for 5 seconds
    while start.elapsed() < Duration::from_secs(5) {
        if let Ok(_msg) = rx.try_recv() {
            processed += 1;
            // Simulate processing delay
            thread::sleep(Duration::from_millis(10));
        }
    }
    
    let queue_size = rx.len();
    println!("Processed {} messages in 5 seconds", processed);
    println!("Remaining queue size: {} (unbounded growth)", queue_size);
    
    // With unbounded channel, queue grows without limit
    // In production, this would cause OOM
    assert!(queue_size > 5000, "Queue should accumulate thousands of unprocessed messages");
    
    flood_handle.join().unwrap();
}
```

**Notes:**

The security question mentions "malicious shards" flooding the executor, but the actual vulnerability is that the **coordinator** can flood **shard executors** with kv_responses. This is because:
- Shards send `RemoteKVRequest` messages (not responses)
- Coordinator sends `RemoteKVResponse` messages (which are received by shards)
- The unbounded channel is on the receiving side (shard's RemoteStateValueReceiver)

The vulnerability breaks the **Resource Limits** invariant (invariant #9): "All operations must respect gas, storage, and computational limits" - the unbounded message queue violates memory resource limits.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L120-120)
```rust
        let (outbound_sender, outbound_receiver) = unbounded();
```

**File:** secure/net/src/network_controller/mod.rs (L129-129)
```rust
        let (inbound_sender, inbound_receiver) = unbounded();
```

**File:** execution/executor-service/src/remote_state_view.rs (L233-240)
```rust
    fn start(&self) {
        while let Ok(message) = self.kv_rx.recv() {
            let state_view = self.state_view.clone();
            let shard_id = self.shard_id;
            self.thread_pool.spawn(move || {
                Self::handle_message(shard_id, message, state_view);
            });
        }
```

**File:** execution/executor-service/src/remote_state_view.rs (L243-272)
```rust
    fn handle_message(
        shard_id: ShardId,
        message: Message,
        state_view: Arc<RwLock<RemoteStateView>>,
    ) {
        let _timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&[&shard_id.to_string(), "kv_responses"])
            .start_timer();
        let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&[&shard_id.to_string(), "kv_resp_deser"])
            .start_timer();
        let response: RemoteKVResponse = bcs::from_bytes(&message.data).unwrap();
        drop(bcs_deser_timer);

        REMOTE_EXECUTOR_REMOTE_KV_COUNT
            .with_label_values(&[&shard_id.to_string(), "kv_responses"])
            .inc();
        let state_view_lock = state_view.read().unwrap();
        trace!(
            "Received state values for shard {} with size {}",
            shard_id,
            response.inner.len()
        );
        response
            .inner
            .into_iter()
            .for_each(|(state_key, state_value)| {
                state_view_lock.set_state_value(&state_key, state_value);
            });
    }
```

**File:** execution/executor-service/src/metrics.rs (L33-46)
```rust
pub static REMOTE_EXECUTOR_REMOTE_KV_COUNT: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        // metric name
        "remote_executor_remote_kv_count",
        // metric description
        "KV counts on a shard for: \
         1. kv_responses: the number of remote key value responses received on a shard; \
         2. non_prefetch_kv: the number of remote key value responses received on a shard that were not prefetched; \
         3. prefetch_kv: the number of remote key value responses received on a shard that were prefetched; ",
        // metric labels (dimensions)
        &["shard_id", "name"],
    )
    .unwrap()
});
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```
