# Audit Report

## Title
Conflict Multiplier Manipulation Allows Denial of Competing Transactions

## Summary
Transaction senders can artificially inflate the conflict multiplier of competing transactions by strategically submitting high gas-price transactions that write to resources the victim will read. This causes the victim's effective gas consumption to be multiplied by up to 10×, potentially exceeding the block gas limit and resulting in transaction exclusion despite paying sufficient gas fees.

## Finding Description

The block executor uses a conflict penalty mechanism to account for parallelization overhead when transactions conflict. The `accumulate_fee_statement()` function computes a conflict multiplier based on how many of the previous `conflict_penalty_window` transactions (default: 9) conflict with the current transaction. [1](#0-0) 

The conflict multiplier is computed by counting conflicts with previous transactions in the window: [2](#0-1) 

A conflict occurs when the current transaction reads a resource that a previous transaction wrote to: [3](#0-2) 

Transaction ordering in mempool prioritizes higher gas prices: [4](#0-3) 

**Attack Execution:**

1. **Victim submits transaction** to execute a high-value operation (NFT purchase, DEX arbitrage) that reads resources A, B, C, ..., I
2. **Attacker observes** the pending transaction in mempool and analyzes its read set
3. **Attacker submits 9 transactions** with gas prices higher than the victim's:
   - Transaction 1: writes only to resource A
   - Transaction 2: writes only to resource B
   - ...
   - Transaction 9: writes only to resource I
4. **Mempool orders transactions** by gas price: attacker's 9 transactions first, then victim's
5. **Block execution proceeds**:
   - Each attacker transaction has multiplier = 1 (no conflicts with each other)
   - Victim's transaction has multiplier = 10 (conflicts with all 9 attacker transactions)
6. **Victim's effective gas** = 10 × raw_gas, which may exceed remaining block gas budget
7. **Block execution halts** when gas limit is exceeded: [5](#0-4) 

The victim's transaction is marked as skipped: [6](#0-5) 

**Key Insight:** The attacker can structure transactions to avoid conflicts between themselves while maximizing conflicts with the victim. This asymmetry allows the attacker to execute with low multipliers while forcing the victim to have a high multiplier.

## Impact Explanation

This vulnerability falls under **Medium Severity** ($10,000) per the Aptos bug bounty program as it enables:

1. **Limited funds manipulation**: In competitive scenarios (NFT drops, MEV opportunities), attackers can exclude competing bids to monopolize high-value transactions
2. **Unfair transaction inclusion**: Users paying legitimate gas fees can be systematically excluded, violating the fairness guarantee that higher gas prices ensure inclusion
3. **MEV extraction**: Enables sophisticated MEV attacks where attackers both execute profitable transactions AND prevent competition

While not causing direct fund loss or consensus violations (Critical severity), it does create state manipulation requiring potential intervention and enables economic attacks in competitive markets.

## Likelihood Explanation

**High Likelihood** of exploitation in practice:

1. **Low complexity**: Attack requires only the ability to submit transactions with specific read/write patterns and high gas prices—capabilities available to any user
2. **Observable targets**: Pending transactions in mempool are visible, allowing attackers to identify high-value targets
3. **Profitable scenarios**: Common in:
   - NFT drops with limited supply
   - High-value DEX arbitrage opportunities  
   - Initial token offerings/auctions
   - Any competitive on-chain mechanism
4. **Economic incentive**: For sufficiently valuable opportunities, the cost of submitting 9 high-gas transactions is justified by the monopoly profit
5. **No detection**: The attack appears as legitimate high-gas transactions; difficult to distinguish from normal priority bidding

## Recommendation

Implement one or more of the following mitigations:

**1. Cap the conflict multiplier:**
```rust
fn compute_conflict_multiplier(&self, conflict_overlap_length: usize) -> u64 {
    // ... existing code ...
    let capped_multiplier = std::cmp::min((conflict_count + 1) as u64, MAX_MULTIPLIER);
    capped_multiplier
}
```
Where `MAX_MULTIPLIER` (e.g., 3) limits the penalty to prevent extreme inflation.

**2. Use median/smoothed multiplier:**
Instead of counting all conflicts, use the median conflict count from recent transactions to reduce manipulation impact.

**3. Reserve minimum block gas per transaction:**
Guarantee that any transaction paying sufficient gas can fit in a block regardless of multiplier:
```rust
fn should_end_block(&mut self, mode: &str) -> bool {
    if let Some(per_block_gas_limit) = self.block_gas_limit() {
        let accumulated_block_gas = self.get_effective_accumulated_block_gas();
        let reserved_gas = MIN_RESERVED_GAS_PER_TXN * remaining_txns;
        if accumulated_block_gas + reserved_gas >= per_block_gas_limit {
            // Only halt if we've used the reserved budget too
        }
    }
    // ... existing code ...
}
```

**4. Implement conflict-aware gas pricing:**
Charge transactions for the conflicts they CREATE (writes) rather than penalizing transactions for conflicts they experience (reads), making the attacker pay for the manipulation.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::{
        combinatorial_tests::{
            mock_executor::MockEvent,
            types::{KeyType, MockTransaction},
        },
        types::InputOutputKey,
    };
    use std::collections::HashSet;
    
    type TestTxn = MockTransaction<KeyType<u64>, MockEvent>;
    type TestProcessor = BlockGasLimitProcessor<TestTxn>;
    
    fn to_map(keys: &[u64]) -> HashSet<InputOutputKey<KeyType<u64>, u32>> {
        keys.iter()
            .map(|k| InputOutputKey::Resource(KeyType(*k)))
            .collect()
    }
    
    #[test]
    fn test_conflict_multiplier_exploitation() {
        // Block gas limit of 10,000
        let block_gas_limit = BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 10000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 9,
            use_module_publishing_block_conflict: false,
            block_output_limit: None,
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: false,
            use_granular_resource_group_conflicts: false,
        };
        
        let mut processor = TestProcessor::new(block_gas_limit, None, 20);
        
        // Attacker submits 9 transactions, each writing to a different resource
        // Each uses 900 gas, will have multiplier = 1
        for i in 0..9 {
            processor.accumulate_fee_statement(
                FeeStatement::new(900, 900, 0, 0, 0),
                Some(ReadWriteSummary::new(
                    HashSet::new(), // no reads
                    to_map(&[i]), // write to resource i
                )),
                None,
            );
            // Each has multiplier = 1 (no conflicts)
            assert_eq!(1, processor.compute_conflict_multiplier(9));
        }
        
        // After 9 attacker txns: 9 * 1 * 900 = 8100 effective gas
        assert_eq!(processor.accumulated_effective_block_gas, 8100);
        assert!(!processor.should_end_block_parallel());
        
        // Victim's transaction reads all 9 resources that attacker wrote
        // Victim pays 500 gas
        processor.accumulate_fee_statement(
            FeeStatement::new(500, 500, 0, 0, 0),
            Some(ReadWriteSummary::new(
                to_map(&[0, 1, 2, 3, 4, 5, 6, 7, 8]), // reads all attacker resources
                to_map(&[100]), // writes to own resource
            )),
            None,
        );
        
        // Victim's multiplier = 10 (conflicts with all 9 previous)
        assert_eq!(10, processor.compute_conflict_multiplier(9));
        
        // Victim's effective gas = 10 * 500 = 5000
        // Total: 8100 + 5000 = 13100 > 10000
        assert_eq!(processor.accumulated_effective_block_gas, 13100);
        
        // Block limit exceeded - victim's transaction causes halt
        assert!(processor.should_end_block_parallel());
        
        // Victim's transaction would be skipped despite paying valid gas
    }
}
```

**Expected Result:** The test demonstrates that a victim transaction paying 500 gas units can be excluded from the block when preceded by 9 strategically crafted attacker transactions, even though there is sufficient raw block gas capacity (10,000 total, only 9×900 + 500 = 8,600 raw gas used). The 10× multiplier on the victim's transaction causes the effective gas to exceed the limit.

## Notes

This vulnerability represents a sophisticated MEV (Maximal Extractable Value) attack vector where the cost of exclusion (9 high-gas transactions) can be economically justified in high-value competitive scenarios. The asymmetry in the conflict penalty—where transactions are penalized for what they READ rather than what they WRITE—creates the exploitable condition. The default `conflict_penalty_window` of 9 and lack of multiplier caps make this attack practical with realistic parameters.

### Citations

**File:** aptos-move/block-executor/src/limit_processor.rs (L63-117)
```rust
    pub(crate) fn accumulate_fee_statement(
        &mut self,
        fee_statement: FeeStatement,
        txn_read_write_summary: Option<ReadWriteSummary<T>>,
        approx_output_size: Option<u64>,
    ) {
        self.accumulated_fee_statement
            .add_fee_statement(&fee_statement);
        self.txn_fee_statements.push(fee_statement);

        let conflict_multiplier = if let Some(conflict_overlap_length) =
            self.block_gas_limit_type.conflict_penalty_window()
        {
            let txn_read_write_summary = txn_read_write_summary.expect(
                "txn_read_write_summary needs to be computed if conflict_penalty_window is set",
            );
            if self.print_conflicts_info {
                println!("{:?}", txn_read_write_summary);
            }
            let rw_summary = if self
                .block_gas_limit_type
                .use_granular_resource_group_conflicts()
            {
                txn_read_write_summary
            } else {
                txn_read_write_summary.collapse_resource_group_conflicts()
            };
            if let Some(x) = &mut self.hot_state_op_accumulator {
                x.add_transaction(rw_summary.keys_written(), rw_summary.keys_read());
            }
            self.txn_read_write_summaries.push(rw_summary);
            self.compute_conflict_multiplier(conflict_overlap_length as usize)
        } else {
            assert_none!(txn_read_write_summary);
            1
        };

        // When the accumulated execution and io gas of the committed txns exceeds
        // PER_BLOCK_GAS_LIMIT, early halt BlockSTM. Storage fee does not count towards
        // the per block gas limit, as we measure execution related cost here.
        let raw_gas_used = fee_statement.execution_gas_used()
            * self
                .block_gas_limit_type
                .execution_gas_effective_multiplier()
            + fee_statement.io_gas_used() * self.block_gas_limit_type.io_gas_effective_multiplier();
        self.accumulated_raw_block_gas += raw_gas_used;
        self.accumulated_effective_block_gas += conflict_multiplier * raw_gas_used;

        if self.block_gas_limit_type.block_output_limit().is_some() {
            self.accumulated_approx_output_size += approx_output_size
                .expect("approx_output_size needs to be computed if block_output_limit is set");
        } else {
            assert_none!(approx_output_size);
        }
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L127-157)
```rust
    fn should_end_block(&mut self, mode: &str) -> bool {
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
        }

        if let Some(per_block_output_limit) = self.block_gas_limit_type.block_output_limit() {
            let accumulated_output = self.get_accumulated_approx_output_size();
            if accumulated_output >= per_block_output_limit {
                counters::EXCEED_PER_BLOCK_OUTPUT_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_output {} >= PER_BLOCK_OUTPUT_LIMIT {}",
                    mode, accumulated_output, per_block_output_limit,
                );
                return true;
            }
        }

        false
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L175-203)
```rust
    fn compute_conflict_multiplier(&self, conflict_overlap_length: usize) -> u64 {
        let start = self
            .txn_read_write_summaries
            .len()
            .saturating_sub(conflict_overlap_length);
        let end = self.txn_read_write_summaries.len() - 1;

        let mut conflict_count = 0;
        let current = &self.txn_read_write_summaries[end];
        for prev in &self.txn_read_write_summaries[start..end] {
            if current.conflicts_with_previous(prev) {
                if self.print_conflicts_info {
                    println!(
                        "Conflicts with previous: {:?}",
                        current.find_conflicts(prev)
                    );
                }
                conflict_count += 1;
            }
        }
        if self.print_conflicts_info {
            println!(
                "Number of conflicts: {} out of {}",
                conflict_count, conflict_overlap_length
            );
        }
        assert_le!(conflict_count + 1, conflict_overlap_length);
        (conflict_count + 1) as u64
    }
```

**File:** aptos-move/block-executor/src/types.rs (L31-33)
```rust
    pub fn conflicts_with_previous(&self, previous: &Self) -> bool {
        !self.reads.is_disjoint(&previous.writes)
    }
```

**File:** mempool/src/core_mempool/index.rs (L192-215)
```rust
impl Ord for OrderedQueueKey {
    fn cmp(&self, other: &OrderedQueueKey) -> Ordering {
        // Higher gas preferred
        match self.gas_ranking_score.cmp(&other.gas_ranking_score) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Lower insertion time preferred
        match self.insertion_time.cmp(&other.insertion_time).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Higher address preferred
        match self.address.cmp(&other.address) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        match self.replay_protector.cmp(&other.replay_protector).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        self.hash.cmp(&other.hash)
    }
}
```

**File:** aptos-move/block-executor/src/executor.rs (L2507-2514)
```rust
            if must_skip || block_limit_processor.should_end_block_sequential() || idx == num_txns {
                let mut has_reconfig = false;
                if let Some(last_output) = ret.last() {
                    if last_output.after_materialization()?.has_new_epoch_event() {
                        has_reconfig = true;
                    }
                }
                ret.resize_with(num_txns, E::Output::skip_output);
```
