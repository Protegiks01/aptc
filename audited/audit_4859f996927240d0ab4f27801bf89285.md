# Audit Report

## Title
DKG Transcript Panic on Empty Commitment Vectors Leading to Validator Denial of Service

## Summary
The DKG (Distributed Key Generation) weighted transcript implementation contains a panic vulnerability when processing malformed transcripts with empty commitment vectors. While the security question references `maul_signature()` at line 522, the exploitable vulnerability exists in the related `get_dealt_public_key()` function at line 216, which is called during transcript verification before size validation occurs. A Byzantine validator can craft a malformed transcript to crash other validators when the fast path feature is enabled. [1](#0-0) 

## Finding Description

The `Transcript` struct contains commitment vectors `V_hat` that represent cryptographic commitments to polynomial evaluations in the PVSS protocol. The `get_dealt_public_key()` function unsafely accesses the last element of `V_hat` using `.last().unwrap()` without checking if the vector is empty. [2](#0-1) 

When a DKG transcript is received from a peer validator, it follows this execution path:

1. **Deserialization without validation**: The `TryFrom<&[u8]>` implementation deserializes transcripts using BCS without validating vector sizes. [3](#0-2) 

2. **Early verification call**: The transcript aggregation logic calls `verify_transcript_extra()` before `verify_transcript()`. [4](#0-3) 

3. **Panic before size validation**: When fast path is enabled, `verify_transcript_extra()` calls `get_dealt_public_key()` on line 326, which panics if `V_hat` is empty. [5](#0-4) 

4. **Size validation occurs too late**: The proper size validation in `check_sizes()` is only called within `verify_transcript()`, which executes after the panic has already occurred. [6](#0-5) 

**Attack scenario**: A Byzantine validator crafts a `Transcripts` struct where `main.V_hat` is an empty vector. When this transcript is broadcast and processed by honest validators (with fast path enabled), they will panic at line 216 during the comparison check, crashing before proper validation.

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables a Byzantine validator to crash other validators during DKG execution, breaking the liveness invariant. According to the Aptos bug bounty criteria:
- **High Severity** ($50,000): "Validator node slowdowns, API crashes, Significant protocol violations"
- A panic crash is more severe than a slowdown, qualifying as a significant availability issue

The impact is conditional on whether the fast path feature is enabled (controlled by on-chain configuration). When enabled, a single malformed transcript can cause all receiving validators to panic, disrupting the DKG protocol and potentially preventing epoch transitions. This affects **Consensus Safety** and validator availability.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. Attacker must be a validator in the current validator set (checked in transcript aggregation)
2. Fast path must be enabled in on-chain configuration
3. Attacker must craft a malformed transcript with empty `V_hat` vector
4. Broadcast occurs during DKG phase

The technical barrier is low - crafting the malformed transcript is trivial using the existing `dummy()` test function pattern. The main limiting factor is that fast path is an optional feature. [7](#0-6) 

Validators are expected to follow the < 1/3 Byzantine fault tolerance model, making this a realistic attack vector within the protocol's threat model.

## Recommendation

Add defensive validation before accessing vector elements with `.unwrap()`. The `get_dealt_public_key()` function should return a `Result` type and validate that `V_hat` is non-empty:

```rust
fn get_dealt_public_key(&self) -> anyhow::Result<Self::DealtPubKey> {
    let last_elem = self.V_hat.last()
        .ok_or_else(|| anyhow::anyhow!("V_hat vector is empty"))?;
    Ok(Self::DealtPubKey::new(*last_elem))
}
```

Additionally, move the `check_sizes()` validation earlier in the verification pipeline, before any vector access operations in `verify_transcript_extra()`. The call order in transcript aggregation should be:

1. Deserialize transcript
2. Call `check_sizes()` to validate structure
3. Call `verify_transcript_extra()` for additional checks
4. Call `verify_transcript()` for cryptographic verification

This follows the defense-in-depth principle by validating structural invariants before performing any operations on the data.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::bls12381;
    
    #[test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    fn test_empty_vector_panic() {
        // Create a malformed transcript with empty V_hat
        let malformed_transcript = Transcript {
            soks: vec![],
            R: vec![],
            R_hat: vec![],
            V: vec![],
            V_hat: vec![], // Empty vector
            C: vec![],
        };
        
        // This will panic when accessing V_hat.last().unwrap()
        let _ = malformed_transcript.get_dealt_public_key();
    }
    
    #[test]
    fn test_malformed_transcript_deserialization() {
        // Demonstrate that malformed transcript can be serialized and deserialized
        let malformed = Transcript::dummy(); // Creates empty vectors
        let bytes = bcs::to_bytes(&malformed).unwrap();
        
        // Deserialization succeeds without validation
        let deserialized = bcs::from_bytes::<Transcript>(&bytes).unwrap();
        assert_eq!(deserialized.V_hat.len(), 0);
        
        // Calling get_dealt_public_key() would panic here
    }
}
```

**Note**: Regarding `maul_signature()` mentioned in the security question: this function also uses `.last().unwrap()` on line 529 with the same vulnerability pattern, but it is only called in benchmark code and explicitly documented as a "testing-only and benchmarking-only interface" in the `MalleableTranscript` trait. Therefore, `maul_signature()` does not pose a production security risk. [8](#0-7) [9](#0-8)

### Citations

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L48-72)
```rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, BCSCryptoHash, CryptoHasher)]
#[allow(non_snake_case)]
pub struct Transcript {
    /// Proofs-of-knowledge (PoKs) for the dealt secret committed in $c = g_2^{p(0)}$.
    /// Since the transcript could have been aggregated from other transcripts with their own
    /// committed secrets in $c_i = g_2^{p_i(0)}$, this is a vector of PoKs for all these $c_i$'s
    /// such that $\prod_i c_i = c$.
    ///
    /// Also contains BLS signatures from each player $i$ on that player's contribution $c_i$, the
    /// player ID $i$ and auxiliary information `aux[i]` provided during dealing.
    soks: Vec<SoK<G1Projective>>,
    /// Commitment to encryption randomness $g_1^{r_j} \in G_1, \forall j \in [W]$
    R: Vec<G1Projective>,
    /// Same as $R$ except uses $g_2$.
    R_hat: Vec<G2Projective>,
    /// First $W$ elements are commitments to the evaluations of $p(X)$: $g_1^{p(\omega^i)}$,
    /// where $i \in [W]$. Last element is $g_1^{p(0)}$ (i.e., the dealt public key).
    V: Vec<G1Projective>,
    /// Same as $V$ except uses $g_2$.
    V_hat: Vec<G2Projective>,
    /// ElGamal encryption of the $j$th share of player $i$:
    /// i.e., $C[s_i+j-1] = h_1^{p(\omega^{s_i + j - 1})} ek_i^{r_j}, \forall i \in [n], j \in [w_i]$.
    /// We sometimes denote $C[s_i+j-1]$ by C_{i, j}.
    C: Vec<G1Projective>,
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L82-90)
```rust
impl TryFrom<&[u8]> for Transcript {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        // NOTE: The `serde` implementation in `blstrs` already performs the necessary point validation
        // by ultimately calling `GroupEncoding::from_bytes`.
        bcs::from_bytes::<Transcript>(bytes).map_err(|_| CryptoMaterialError::DeserializationError)
    }
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L215-217)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V_hat.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-425)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L552-563)
```rust
    #[cfg(any(test, feature = "fuzzing"))]
    pub fn dummy() -> Self {
        Self {
            soks: vec![],
            R: vec![],
            R_hat: vec![],
            V: vec![],
            V_hat: vec![],
            C: vec![],
        }
    }
}
```

**File:** dkg/src/transcript_aggregation/mod.rs (L88-101)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
        let mut trx_aggregator = self.trx_aggregator.lock();
        if trx_aggregator.contributors.contains(&metadata.author) {
            return Ok(None);
        }

        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L324-328)
```rust
        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
        Ok(())
```

**File:** crates/aptos-dkg/src/pvss/traits/transcript.rs (L321-332)
```rust
/// This traits defines testing-only and benchmarking-only interfaces.
pub trait MalleableTranscript: Transcript {
    /// This is useful for generating many PVSS transcripts from different dealers from a single
    /// PVSS transcript by recomputing its signature. It is used to deal quickly when benchmarking
    /// aggregated PVSS transcript verification
    fn maul_signature<A: Serialize + Clone>(
        &mut self,
        ssk: &Self::SigningSecretKey,
        session_id: &A,
        dealer: &Player,
    );
}
```

**File:** crates/aptos-dkg/benches/pvss.rs (L392-396)
```rust
                for (i, ssk) in ssks.iter().enumerate().skip(1).take(num_aggr - 1) {
                    let mut trx = trxs[0].clone();
                    trx.maul_signature(ssk, &NoAux, &sc.get_player(i));
                    trxs.push(trx);
                }
```
