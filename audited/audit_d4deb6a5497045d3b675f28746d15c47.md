# Audit Report

## Title
Jellyfish Merkle Tree Restoration Allows Finalization of Incomplete Trees Without Root Hash Verification

## Summary
The `finish_impl()` function in the Jellyfish Merkle tree restoration logic contains a critical vulnerability where incomplete trees can be permanently written to storage without verifying that the final root hash matches the expected root hash. This occurs in special case handling for trees with 0 or 1 children at the root level, bypassing normal verification safeguards.

## Finding Description

The vulnerability exists in the special case handling within `finish_impl()` [1](#0-0) 

When finalizing a Jellyfish Merkle tree restoration, the code checks if `partial_nodes.len() == 1` (only the root level exists) and handles two special cases:

1. **Zero children case**: Writes a `Node::Null` directly to storage without verifying its hash (`SPARSE_MERKLE_PLACEHOLDER_HASH`) matches `expected_root_hash` [2](#0-1) 

2. **Single leaf case**: Writes a single leaf node as the root without verifying its hash matches `expected_root_hash` [3](#0-2) 

The normal restoration process verifies each chunk against `expected_root_hash` using the `verify()` method [4](#0-3) , which properly reconstructs and validates the root hash [5](#0-4) 

However, the special case code paths return early without performing this critical final verification, breaking the **State Consistency** invariant that requires all state transitions to be verifiable via Merkle proofs.

**Attack Propagation Path:**

1. A malicious state sync peer provides state chunks to a syncing node
2. The peer sends only a partial subset of the actual state (e.g., 1 leaf out of 1000)
3. Each chunk passes incremental verification because valid proofs are provided
4. The malicious peer signals `is_last_chunk()` = true prematurely [6](#0-5) 
5. The storage synchronizer calls `finish_box()` which invokes `finish_impl()` [7](#0-6) 
6. Since only 1 leaf was added, `partial_nodes.len() == 1` and `num_children == 1`
7. The special case code writes the single leaf as root WITHOUT checking its hash
8. The incomplete tree with incorrect root hash is permanently persisted to storage

**Subsequent Impact:**

When the node later attempts legitimate state sync, the constructor checks for existing root nodes and validates their hash [8](#0-7) . Since the corrupted root exists and doesn't match `expected_root_hash`, restoration fails permanently, requiring manual database cleanup or hard fork recovery.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria under multiple categories:

**1. Consensus/Safety Violations:** Different nodes receiving state sync from different malicious peers could end up with different Merkle tree roots for the same version. This breaks deterministic executionâ€”all validators must produce identical state roots for identical blocks. Nodes with corrupted state trees will diverge from consensus, unable to validate transactions or produce valid state proofs.

**2. Non-recoverable Network Partition:** Once an incorrect root is written to storage, the affected node cannot complete legitimate state restoration. The validation check at initialization [9](#0-8)  will perpetually fail, preventing recovery without manual intervention or a hard fork to reset the corrupted state database.

**3. State Database Corruption:** The Jellyfish Merkle tree is the cryptographic commitment to the entire blockchain state. Corruption of this structure undermines the integrity of the entire state storage layer, affecting all state-dependent operations including transaction execution, proof generation, and state queries.

The vulnerability directly violates Aptos's **Critical Invariant #4 (State Consistency)**: "State transitions must be atomic and verifiable via Merkle proofs" and **Critical Invariant #1 (Deterministic Execution)**: "All validators must produce identical state roots for identical blocks."

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Control over a state sync data source (malicious fullnode or compromised peer)
- Ability to craft valid Merkle proofs for partial state chunks
- No validator privileges or Byzantine collusion required
- No special cryptographic capabilities needed

**Attack Complexity: Low**
- The attack requires only truncating legitimate state chunks and setting `is_last_chunk()` flag
- Valid proofs can be obtained from the legitimate tree for the partial data
- No sophisticated cryptographic attacks or race conditions involved
- Triggerable through normal state sync protocol operations

**Detection Difficulty: High**
- The corrupted root is written silently without errors or warnings
- Affected nodes only discover the issue on subsequent restoration attempts
- No immediate consensus failures if the node doesn't participate in validation
- Logs would show normal state sync completion

**Real-world Scenarios:**
1. **Malicious state sync peers** during fast sync or state snapshot restoration
2. **Compromised backup/restore pipelines** in disaster recovery operations [10](#0-9) 
3. **Network partitions** where nodes sync from untrusted sources
4. **Supply chain attacks** on snapshot distribution infrastructure

## Recommendation

Add explicit root hash verification before writing in the special cases:

```rust
pub fn finish_impl(mut self) -> Result<()> {
    self.wait_for_async_commit()?;
    
    // Deal with the special case when the entire tree has a single leaf or null node.
    if self.partial_nodes.len() == 1 {
        let mut num_children = 0;
        let mut leaf = None;
        for i in 0..16 {
            if let Some(ref child_info) = self.partial_nodes[0].children[i] {
                num_children += 1;
                if let ChildInfo::Leaf(node) = child_info {
                    leaf = Some(node.clone());
                }
            }
        }

        match num_children {
            0 => {
                let node_key = NodeKey::new_empty_path(self.version);
                assert!(self.frozen_nodes.is_empty());
                
                // SECURITY FIX: Verify root hash before writing
                let null_hash = Node::<K>::Null.hash();
                ensure!(
                    null_hash == self.expected_root_hash,
                    "Null root hash {} does not match expected {}",
                    null_hash,
                    self.expected_root_hash
                );
                
                self.frozen_nodes.insert(node_key, Node::Null);
                self.store.write_node_batch(&self.frozen_nodes)?;
                return Ok(());
            },
            1 => {
                if let Some(node) = leaf {
                    let node_key = NodeKey::new_empty_path(self.version);
                    assert!(self.frozen_nodes.is_empty());
                    
                    // SECURITY FIX: Verify root hash before writing
                    let leaf_hash = node.hash();
                    ensure!(
                        leaf_hash == self.expected_root_hash,
                        "Single leaf root hash {} does not match expected {}",
                        leaf_hash,
                        self.expected_root_hash
                    );
                    
                    self.frozen_nodes.insert(node_key, node.into());
                    self.store.write_node_batch(&self.frozen_nodes)?;
                    return Ok(());
                }
            },
            _ => (),
        }
    }

    self.freeze(0);
    self.store.write_node_batch(&self.frozen_nodes)?;
    
    // ADDITIONAL FIX: Verify final root after freezing all nodes
    let final_root = self.store
        .get_node_option(&NodeKey::new_empty_path(self.version), "finish_verify")?
        .expect("Root node must exist after finalization");
    ensure!(
        final_root.hash() == self.expected_root_hash,
        "Final root hash {} does not match expected {}",
        final_root.hash(),
        self.expected_root_hash
    );
    
    Ok(())
}
```

## Proof of Concept

```rust
use aptos_jellyfish_merkle::{
    JellyfishMerkleTree, 
    restore::JellyfishMerkleRestore,
    mock_tree_store::MockTreeStore,
    test_helper::{init_mock_db, ValueBlob},
};
use aptos_crypto::{hash::CryptoHash, HashValue};
use std::{sync::Arc, collections::BTreeMap};

#[test]
fn test_incomplete_tree_finalization_exploit() {
    // Step 1: Create legitimate source tree with multiple leaves
    let mut source_kvs = BTreeMap::new();
    for i in 0..100 {
        let key = ValueBlob(vec![i]);
        let value = ValueBlob(vec![i + 100]);
        source_kvs.insert(
            CryptoHash::hash(&key),
            (key, value)
        );
    }
    
    let (source_store, version) = init_mock_db(&source_kvs);
    let source_tree = JellyfishMerkleTree::new(&source_store);
    let expected_root_hash = source_tree.get_root_hash(version).unwrap();
    
    // Step 2: Malicious restoration with only FIRST leaf
    let target_store = Arc::new(MockTreeStore::default());
    let mut restore = JellyfishMerkleRestore::new(
        target_store.clone(),
        version,
        expected_root_hash, // Expecting full tree hash
        false, // async_commit
    ).unwrap();
    
    // Step 3: Add only the FIRST chunk (1 leaf instead of 100)
    let first_key = source_kvs.keys().next().unwrap();
    let first_kv = source_kvs.get(first_key).unwrap();
    let proof = source_tree.get_range_proof(*first_key, version).unwrap();
    
    // This verification PASSES because the proof is valid for the first leaf
    restore.add_chunk_impl(
        vec![(&first_kv.0, CryptoHash::hash(&first_kv.1))],
        proof
    ).unwrap();
    
    // Step 4: Maliciously call finish_impl() with incomplete tree
    // VULNERABILITY: This should fail but succeeds, writing incorrect root
    restore.finish_impl().unwrap(); // <-- Should fail but doesn't!
    
    // Step 5: Verify the corruption
    let corrupted_tree = JellyfishMerkleTree::new(target_store.as_ref());
    let actual_root = corrupted_tree.get_root_hash(version).unwrap();
    
    // The actual root hash is from a tree with 1 leaf,
    // NOT the expected hash from a tree with 100 leaves
    assert_ne!(actual_root, expected_root_hash);
    
    // Step 6: Subsequent legitimate restoration FAILS
    let result = JellyfishMerkleRestore::new(
        target_store.clone(),
        version,
        expected_root_hash, // Correct expected hash
        false,
    );
    
    // This fails because corrupted root exists and doesn't match
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("expecting"));
}
```

**Notes:**

The vulnerability exploits a logic gap where special-case optimizations bypass critical security checks. The `expected_root_hash` field exists specifically to ensure restoration integrity [11](#0-10) , but the special case code paths at lines 766-780 write directly to storage without consulting it. This creates a window for incomplete or malicious state trees to be permanently persisted, breaking the fundamental trust model of the Jellyfish Merkle tree as a cryptographic commitment to blockchain state.

### Citations

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L175-176)
```rust
    /// When the restoration process finishes, we expect the tree to have this root hash.
    expected_root_hash: HashValue,
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L196-206)
```rust
        let (finished, partial_nodes, previous_leaf) = if let Some(root_node) =
            tree_reader.get_node_option(&NodeKey::new_empty_path(version), "restore")?
        {
            info!("Previous restore is complete, checking root hash.");
            ensure!(
                root_node.hash() == expected_root_hash,
                "Previous completed restore has root hash {}, expecting {}",
                root_node.hash(),
                expected_root_hash,
            );
            (true, vec![], None)
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L628-697)
```rust
    fn verify(&self, proof: SparseMerkleRangeProof) -> Result<()> {
        let previous_leaf = self
            .previous_leaf
            .as_ref()
            .expect("The previous leaf must exist.");

        let previous_key = previous_leaf.account_key();
        // If we have all siblings on the path from root to `previous_key`, we should be able to
        // compute the root hash. The siblings on the right are already in the proof. Now we
        // compute the siblings on the left side, which represent all the states that have ever
        // been added.
        let mut left_siblings = vec![];

        // The following process might add some extra placeholder siblings on the left, but it is
        // nontrivial to determine when the loop should stop. So instead we just add these
        // siblings for now and get rid of them in the next step.
        let mut num_visited_right_siblings = 0;
        for (i, bit) in previous_key.iter_bits().enumerate() {
            if bit {
                // This node is a right child and there should be a sibling on the left.
                let sibling = if i >= self.partial_nodes.len() * 4 {
                    *SPARSE_MERKLE_PLACEHOLDER_HASH
                } else {
                    Self::compute_left_sibling(
                        &self.partial_nodes[i / 4],
                        previous_key.get_nibble(i / 4),
                        (3 - i % 4) as u8,
                    )
                };
                left_siblings.push(sibling);
            } else {
                // This node is a left child and there should be a sibling on the right.
                num_visited_right_siblings += 1;
            }
        }
        ensure!(
            num_visited_right_siblings >= proof.right_siblings().len(),
            "Too many right siblings in the proof.",
        );

        // Now we remove any extra placeholder siblings at the bottom. We keep removing the last
        // sibling if 1) it's a placeholder 2) it's a sibling on the left.
        for bit in previous_key.iter_bits().rev() {
            if bit {
                if *left_siblings.last().expect("This sibling must exist.")
                    == *SPARSE_MERKLE_PLACEHOLDER_HASH
                {
                    left_siblings.pop();
                } else {
                    break;
                }
            } else if num_visited_right_siblings > proof.right_siblings().len() {
                num_visited_right_siblings -= 1;
            } else {
                break;
            }
        }

        // Left siblings must use the same ordering as the right siblings in the proof
        left_siblings.reverse();

        // Verify the proof now that we have all the siblings
        proof
            .verify(
                self.expected_root_hash,
                SparseMerkleLeafNode::new(*previous_key, previous_leaf.value_hash()),
                left_siblings,
            )
            .map_err(Into::into)
    }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L752-785)
```rust
        // Deal with the special case when the entire tree has a single leaf or null node.
        if self.partial_nodes.len() == 1 {
            let mut num_children = 0;
            let mut leaf = None;
            for i in 0..16 {
                if let Some(ref child_info) = self.partial_nodes[0].children[i] {
                    num_children += 1;
                    if let ChildInfo::Leaf(node) = child_info {
                        leaf = Some(node.clone());
                    }
                }
            }

            match num_children {
                0 => {
                    let node_key = NodeKey::new_empty_path(self.version);
                    assert!(self.frozen_nodes.is_empty());
                    self.frozen_nodes.insert(node_key, Node::Null);
                    self.store.write_node_batch(&self.frozen_nodes)?;
                    return Ok(());
                },
                1 => {
                    if let Some(node) = leaf {
                        let node_key = NodeKey::new_empty_path(self.version);
                        assert!(self.frozen_nodes.is_empty());
                        self.frozen_nodes.insert(node_key, node.into());
                        self.store.write_node_batch(&self.frozen_nodes)?;
                        return Ok(());
                    }
                },
                _ => (),
            }
        }

```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L874-874)
```rust
                    let all_states_synced = states_with_proof.is_last_chunk();
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1123-1128)
```rust
    state_snapshot_receiver.finish_box().map_err(|error| {
        format!(
            "Failed to finish the state value synchronization! Error: {:?}",
            error
        )
    })?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L228-228)
```rust
        tokio::task::spawn_blocking(move || receiver.lock().take().unwrap().finish()).await??;
```
