# Audit Report

## Title
Integer Underflow in MemoryRatelimitChecker Allows Complete Rate Limit Bypass

## Summary
The `complete()` method in `MemoryRatelimitChecker` contains a critical integer underflow vulnerability that can wrap a u32 counter from 0 to u32::MAX (4,294,967,295), completely disabling rate limiting for affected IP addresses and allowing unlimited faucet token drainage.

## Finding Description

The vulnerability exists in the rate limit rollback logic for 500 errors. [1](#0-0) 

When a request fails with a 500 server error, the `complete()` method attempts to decrement the request counter to avoid penalizing users for server-side failures. However, the code uses `get_or_insert_mut(data.checker_data.source_ip, || 1)` which inserts a default value of 1 if the IP is not present in the cache.

**Attack Flow:**

1. An attacker sends two concurrent requests from IP address X
2. Request A: `check()` acquires lock, inserts/gets counter value, increments it, releases lock
3. Request B: `check()` acquires lock, gets counter value, increments it, releases lock  
4. Between `check()` and `complete()`, many requests from other IPs fill the LRU cache (default: 1,000,000 entries)
5. IP X is evicted from the cache as the least recently used entry
6. Request A fails with 500 error: `complete()` acquires lock, calls `get_or_insert_mut(X, || 1)` which inserts 1 (since X was evicted), decrements to 0, releases lock
7. Request B fails with 500 error: `complete()` acquires lock, calls `get_or_insert_mut(X, || 0)` which returns reference to existing value 0, decrements 0 to u32::MAX (wrapping underflow), releases lock [2](#0-1) 

The `check()` method now sees a counter value of 4,294,967,295 and will allow approximately 4.3 billion requests before rate limiting is re-enabled for that IP.

**Root Cause:** The `complete()` method uses `|| 1` as the default value in `get_or_insert_mut()`, which is incorrect when the IP has been evicted. If the IP was evicted, we have no knowledge of its prior state, and inserting 1 before decrementing creates the underflow opportunity. Additionally, there is no check to prevent decrementing below 0.

## Impact Explanation

**Critical Severity** - This vulnerability allows complete bypass of the faucet's rate limiting mechanism, enabling attackers to drain all available funds from the faucet. 

Per Aptos bug bounty criteria, this qualifies as **Critical** because:
1. **Loss of Funds**: An attacker can drain the entire faucet balance by bypassing rate limits
2. **Complete Security Control Bypass**: Rate limiting is a core protection mechanism for the faucet service [3](#0-2) 

The `complete()` method is called for all requests regardless of success/failure state, making this vulnerability consistently exploitable.

## Likelihood Explanation

**High Likelihood** - The attack requires:

1. **Concurrent requests with 500 errors**: Achievable by sending multiple requests simultaneously and triggering server errors (resource exhaustion, malformed requests that cause panics, database failures, etc.)

2. **LRU cache eviction**: With a default cache size of 1,000,000 entries [4](#0-3) , an attacker controlling multiple IPs (via botnet, cloud providers, or Tor) can fill the cache to force evictions

3. **Precise timing**: While the window between `check()` and `complete()` is small, with enough concurrent requests and controlled 500 errors, the probability of hitting the race condition becomes significant

The vulnerability is more likely in production environments with:
- High request volume (natural cache evictions)
- Server instability (increased 500 errors)
- Distributed attackers (easier to fill cache)

## Recommendation

**Fix 1: Check for zero before decrementing (Immediate Fix)**

```rust
async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
    if data.response_is_500 {
        let mut cache = self.ip_to_requests_today.lock().await;
        if let Some(count) = cache.get_mut(&data.checker_data.source_ip) {
            *count = count.saturating_sub(1);
        }
        // Don't insert if IP was evicted - we can't reliably restore state
    }
    Ok(())
}
```

**Fix 2: Use saturating arithmetic and remove get_or_insert_mut (Recommended)**

```rust
async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
    if data.response_is_500 {
        let mut cache = self.ip_to_requests_today.lock().await;
        if let Some(count) = cache.peek_mut(&data.checker_data.source_ip) {
            *count = count.saturating_sub(1);
        }
    }
    Ok(())
}
```

**Fix 3: Track request IDs to ensure complete() matches check() (Most Robust)**

Maintain a separate map tracking request IDs to ensure `complete()` only decrements if the corresponding `check()` incremented. This prevents all eviction-related issues.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use std::net::IpAddr;
    
    #[tokio::test]
    async fn test_underflow_via_lru_eviction() {
        // Create checker with cache size of 2 to easily trigger eviction
        let config = MemoryRatelimitCheckerConfig {
            max_requests_per_day: 10,
            max_entries_in_map: NonZeroUsize::new(2).unwrap(),
        };
        let checker = MemoryRatelimitChecker::new(config);
        
        let ip_x: IpAddr = "1.2.3.4".parse().unwrap();
        let ip_y: IpAddr = "5.6.7.8".parse().unwrap();
        let ip_z: IpAddr = "9.10.11.12".parse().unwrap();
        
        // Request 1 from IP X - passes check
        let data_x = CheckerData {
            source_ip: ip_x,
            receiver: AccountAddress::random(),
            headers: Arc::new(HeaderMap::new()),
            time_request_received_secs: 0,
        };
        checker.check(data_x.clone(), false).await.unwrap();
        
        // Request 2 from IP X - passes check (concurrent)
        checker.check(data_x.clone(), false).await.unwrap();
        
        // Fill cache with IP Y and Z to evict IP X
        let data_y = CheckerData { source_ip: ip_y, ..data_x.clone() };
        let data_z = CheckerData { source_ip: ip_z, ..data_x.clone() };
        checker.check(data_y, false).await.unwrap();
        checker.check(data_z, false).await.unwrap();
        
        // IP X has been evicted from LRU cache
        
        // Complete request 1 with 500 error
        let complete_data_1 = CompleteData {
            checker_data: data_x.clone(),
            txn_hashes: vec![],
            response_is_500: true,
        };
        checker.complete(complete_data_1).await.unwrap();
        
        // Complete request 2 with 500 error - triggers underflow
        let complete_data_2 = CompleteData {
            checker_data: data_x.clone(),
            txn_hashes: vec![],
            response_is_500: true,
        };
        checker.complete(complete_data_2).await.unwrap();
        
        // Verify counter wrapped to u32::MAX
        let cache = checker.ip_to_requests_today.lock().await;
        let count = cache.peek(&ip_x).unwrap();
        assert_eq!(*count, u32::MAX, "Counter should have wrapped to u32::MAX");
        
        // IP X can now make billions of requests
        println!("VULNERABILITY CONFIRMED: IP {} has counter value {}", ip_x, count);
    }
}
```

**Notes:**

While this vulnerability is in the faucet service (not consensus-critical infrastructure), it represents a **Critical** security issue for faucet deployments. The integer underflow completely breaks the rate limiting protection, allowing attackers to drain faucet funds. The vulnerability is exploitable through a race condition involving concurrent requests, server errors, and LRU cache evictionâ€”all realistic conditions in production environments.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L23-26)
```rust
impl MemoryRatelimitCheckerConfig {
    fn default_max_entries_in_map() -> NonZeroUsize {
        NonZeroUsize::new(1000000).unwrap()
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L68-91)
```rust
    async fn check(
        &self,
        data: CheckerData,
        dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        self.clear_if_new_day().await;

        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }

        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L93-102)
```rust
    async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
        if data.response_is_500 {
            *self
                .ip_to_requests_today
                .lock()
                .await
                .get_or_insert_mut(data.checker_data.source_ip, || 1) -= 1;
        }
        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L332-346)
```rust
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
```
