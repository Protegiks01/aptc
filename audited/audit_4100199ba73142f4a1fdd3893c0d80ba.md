# Audit Report

## Title
Root Progression Invariant Violation During State Sync Rebuild - Commit Root Can Advance Beyond Ordered Root

## Summary
A critical race condition during block tree rebuild operations allows the `commit_root` to advance to a higher round than `ordered_root`, violating the fundamental invariant `commit_root.round() ≤ ordered_root.round()`. This occurs when commit callbacks from pre-rebuild blocks fire after the rebuild completes, updating the commit root in the new tree to rounds higher than the new ordered root.

## Finding Description

The Aptos consensus maintains two critical roots tracked in `BlockTree`:
- `ordered_root`: The last block sent for execution (ordering phase)
- `commit_root`: The last block that completed execution (commit phase)

The invariant `commit_root.round() ≤ ordered_root.round()` must always hold because blocks must be ordered before they can be committed. [1](#0-0) 

During initialization and rebuild operations, both roots are reset to the same block: [2](#0-1) 

The vulnerability arises from the following sequence:

1. **Callback Registration**: When blocks are inserted into the pipeline, commit callbacks are registered with weak references to the BlockTree: [3](#0-2) 

2. **Rebuild Operation**: During state sync, `rebuild()` is called which replaces the BlockTree contents but reuses the same Arc wrapper: [4](#0-3) 

The critical issue: The BlockTree instance is replaced via `*tree_to_replace.write() = tree`, meaning the Arc<RwLock<BlockTree>> remains the same but its contents change. Old callbacks holding weak references to this Arc can still upgrade and access the NEW tree.

3. **Pipeline Abortion**: Before rebuild, `abort_pipeline_for_state_sync()` attempts to abort pending pipelines: [5](#0-4) 

However, the abortion only affects unfinished pipelines: [6](#0-5) 

If a pipeline completes between the check (`!handle.is_finished()`) and the abort, its callback can still fire.

4. **Commit Root Update Without Validation**: The commit callback updates commit_root without checking if it would violate the ordering invariant: [7](#0-6) [8](#0-7) 

There is no validation that `new_commit_root.round() ≤ ordered_root.round()`.

**Attack Scenario:**
1. Node processes blocks up to round 100, updating `ordered_root` to round 100
2. Block at round 100 completes execution, commit callback about to fire
3. State sync is triggered (node falls behind), syncing to round 50
4. `abort_pipeline_for_state_sync()` called, but round 100's pipeline already finished
5. `rebuild()` resets both roots to round 50
6. Old callback for round 100 fires, upgrading weak reference to NEW tree
7. `update_highest_commit_cert()` checks: 100 > 50 (new highest_commit_cert), proceeds
8. `commit_root` updated to round 100
9. **Invariant violated**: `commit_root` (100) > `ordered_root` (50)

## Impact Explanation

This is a **Critical Severity** consensus invariant violation with multiple severe impacts:

1. **Back-pressure Mechanism Failure**: The `vote_back_pressure()` function calculates pressure as `ordered_round - commit_round`: [9](#0-8) 

With commit_root > ordered_root, this produces negative pressure values, breaking vote backpressure logic and potentially causing voting to proceed when it shouldn't.

2. **Consensus State Inconsistency**: The system believes it has committed blocks (at round 100) that haven't been ordered yet (only at round 50 in the new tree), creating fundamental inconsistency between ordering and commit phases.

3. **Recovery/Restart Issues**: If the node crashes and restarts in this state, the persisted commit root will be at a higher round than what can be properly recovered, potentially causing assertion failures or undefined behavior.

4. **Liveness Risks**: The inconsistent state could cause deadlocks or stalls in consensus progression as different components have conflicting views of chain progress.

This violates the fundamental consensus safety guarantee that blocks must be ordered before being committed, potentially enabling double-spending or state divergence scenarios.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability can occur whenever:
1. A node performs state sync (common during catch-up scenarios)
2. Blocks are in the execution pipeline when sync is triggered
3. A pipeline completes execution just before or during the abort phase

This is not a rare edge case - state sync happens regularly in production:
- Nodes joining the network
- Nodes recovering from temporary downtime
- Nodes falling behind due to network issues
- Fast-forward sync during epoch transitions

The race window exists because:
- Pipeline abortion is not atomic with rebuild
- No validation prevents commit_root from exceeding ordered_root
- Weak references allow old callbacks to access new tree state

## Recommendation

**Primary Fix**: Add explicit validation in `update_commit_root()` and `update_highest_commit_cert()` to prevent commit_root from advancing beyond ordered_root:

```rust
// In block_tree.rs
fn update_highest_commit_cert(&mut self, new_commit_cert: WrappedLedgerInfo) {
    let new_round = new_commit_cert.commit_info().round();
    
    // CRITICAL: Ensure commit root never exceeds ordered root
    if new_round > self.ordered_root().round() {
        warn!(
            "Attempted to update commit_root to round {} beyond ordered_root at round {}. Ignoring stale callback.",
            new_round,
            self.ordered_root().round()
        );
        return;
    }
    
    if new_round > self.highest_commit_cert.commit_info().round() {
        self.highest_commit_cert = Arc::new(new_commit_cert);
        self.update_commit_root(self.highest_commit_cert.commit_info().id());
    }
}
```

**Secondary Fix**: Improve callback isolation during rebuild by using epoch/generation counters:

```rust
// Add to BlockTree
struct BlockTree {
    // ... existing fields ...
    generation: u64,  // Incremented on each rebuild
}

// In callback
let callback = Box::new(
    move |finality_proof: WrappedLedgerInfo,
          commit_decision: LedgerInfoWithSignatures| {
        if let Some(tree) = block_tree.upgrade() {
            let mut tree_lock = tree.write();
            // Only proceed if generation matches
            if tree_lock.generation == expected_generation {
                tree_lock.commit_callback(...);
            } else {
                debug!("Ignoring callback from previous generation");
            }
        }
    },
);
```

**Additional Safeguards**:
1. Add assertion in `vote_back_pressure()` to detect invariant violations early
2. Add monitoring/alerting for commit_root > ordered_root conditions
3. Ensure `abort_pipeline_for_state_sync()` completes synchronously before any rebuild

## Proof of Concept

```rust
// Rust test demonstrating the race condition
#[tokio::test]
async fn test_commit_root_exceeds_ordered_root_during_rebuild() {
    // Setup: Create block store with blocks up to round 100
    let (block_store, mut block_tree_handle) = setup_block_store().await;
    
    // Send block at round 100 for execution
    let block_100 = create_test_block(100);
    block_store.insert_block(block_100.clone()).await.unwrap();
    let finality_proof = create_finality_proof_for_block(&block_100);
    
    // Start execution - this registers callback
    block_store.send_for_execution(finality_proof.clone()).await.unwrap();
    
    // Verify ordered_root updated to 100
    assert_eq!(block_store.ordered_root().round(), 100);
    
    // Simulate pipeline completing execution but callback not yet fired
    // (In real scenario, this happens due to timing)
    
    // Trigger state sync rebuild to round 50
    let (new_root, new_metadata, blocks, qcs) = create_recovery_data_at_round_50();
    
    // Rebuild resets both roots to 50
    block_store.rebuild(new_root, new_metadata, blocks, qcs).await;
    
    assert_eq!(block_store.ordered_root().round(), 50);
    assert_eq!(block_store.commit_root().round(), 50);
    
    // Now simulate the callback firing for block 100
    // (The callback holds weak ref that upgrades to NEW tree)
    trigger_pending_commit_callback(&block_store, &finality_proof).await;
    
    // BUG: commit_root advances to 100, ordered_root stays at 50
    let commit_round = block_store.commit_root().round();
    let ordered_round = block_store.ordered_root().round();
    
    println!("After callback: commit_root={}, ordered_root={}", 
             commit_round, ordered_round);
    
    // INVARIANT VIOLATED
    assert!(commit_round > ordered_round, 
            "Invariant violated: commit_root ({}) > ordered_root ({})",
            commit_round, ordered_round);
}
```

The test demonstrates that after rebuild, a stale callback can update commit_root to round 100 while ordered_root remains at round 50, conclusively proving the invariant violation.

## Notes

This vulnerability requires specific timing conditions but is not theoretical - it can occur in production environments where state sync and pipeline execution overlap. The lack of validation in `update_commit_root()` combined with weak reference reuse across rebuild operations creates a critical safety violation in the consensus layer. Immediate remediation is recommended to prevent potential consensus divergence or liveness failures.

### Citations

**File:** consensus/src/block_storage/block_tree.rs (L76-79)
```rust
    /// Root of the tree. This is the root of ordering phase
    ordered_root_id: HashValue,
    /// Commit Root id: this is the root of commit phase
    commit_root_id: HashValue,
```

**File:** consensus/src/block_storage/block_tree.rs (L133-136)
```rust
        BlockTree {
            id_to_block,
            ordered_root_id: commit_root_id,
            commit_root_id, // initially we set commit_root_id = root_id
```

**File:** consensus/src/block_storage/block_tree.rs (L341-346)
```rust
    fn update_highest_commit_cert(&mut self, new_commit_cert: WrappedLedgerInfo) {
        if new_commit_cert.commit_info().round() > self.highest_commit_cert.commit_info().round() {
            self.highest_commit_cert = Arc::new(new_commit_cert);
            self.update_commit_root(self.highest_commit_cert.commit_info().id());
        }
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L441-444)
```rust
    pub(super) fn update_commit_root(&mut self, root_id: HashValue) {
        assert!(self.block_exists(&root_id));
        self.commit_root_id = root_id;
    }
```

**File:** consensus/src/block_storage/block_store.rs (L250-265)
```rust
        let tree = BlockTree::new(
            root_block_id,
            window_root,
            root_qc,
            root_ordered_cert,
            root_commit_cert,
            max_pruned_blocks_in_mem,
            highest_2chain_timeout_cert.map(Arc::new),
        );
        let inner = if let Some(tree_to_replace) = tree_to_replace {
            *tree_to_replace.write() = tree;
            tree_to_replace
        } else {
            Arc::new(RwLock::new(tree))
        };

```

**File:** consensus/src/block_storage/block_store.rs (L470-489)
```rust
            let block_tree = Arc::downgrade(&self.inner);
            let storage = self.storage.clone();
            let id = pipelined_block.id();
            let round = pipelined_block.round();
            let window_size = self.window_size;
            let callback = Box::new(
                move |finality_proof: WrappedLedgerInfo,
                      commit_decision: LedgerInfoWithSignatures| {
                    if let Some(tree) = block_tree.upgrade() {
                        tree.write().commit_callback(
                            storage,
                            id,
                            round,
                            finality_proof,
                            commit_decision,
                            window_size,
                        );
                    }
                },
            );
```

**File:** consensus/src/block_storage/block_store.rs (L617-627)
```rust
    pub async fn abort_pipeline_for_state_sync(&self) {
        let blocks = self.inner.read().get_all_blocks();
        // the blocks are not ordered by round here, so we need to abort all then wait
        let futs: Vec<_> = blocks
            .into_iter()
            .filter_map(|b| b.abort_pipeline())
            .collect();
        for f in futs {
            f.wait_until_finishes().await;
        }
    }
```

**File:** consensus/src/block_storage/block_store.rs (L698-703)
```rust
        let commit_round = self.commit_root().round();
        let ordered_round = self.ordered_root().round();
        counters::OP_COUNTERS
            .gauge("back_pressure")
            .set((ordered_round - commit_round) as i64);
        ordered_round > self.vote_back_pressure_limit + commit_round
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L528-546)
```rust
    pub fn abort_pipeline(&self) -> Option<PipelineFutures> {
        if let Some(abort_handles) = self.pipeline_abort_handle.lock().take() {
            let mut aborted = false;
            for handle in abort_handles {
                if !handle.is_finished() {
                    handle.abort();
                    aborted = true;
                }
            }
            if aborted {
                info!(
                    "[Pipeline] Aborting pipeline for block {} {} {}",
                    self.id(),
                    self.epoch(),
                    self.round()
                );
            }
        }
        self.pipeline_futs.lock().take()
```
