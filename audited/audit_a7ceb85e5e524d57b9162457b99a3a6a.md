# Audit Report

## Title
Signature Bypass in RoundTimeout Verification Allows Timeout Reason Manipulation

## Summary
The `verify()` method in `RoundTimeout` does not validate that the cryptographic signature covers the `reason` field, allowing malicious validators to inject arbitrary timeout reasons (including `PayloadUnavailable` with fabricated `missing_authors` data) that pass verification and influence consensus liveness behavior.

## Finding Description

The `RoundTimeout` struct contains four fields: `timeout`, `author`, `reason`, and `signature`. [1](#0-0) 

The `verify()` method only validates that the signature covers `self.timeout.signing_format()`, which returns a `TimeoutSigningRepr` containing only `epoch`, `round`, and `hqc_round`. [2](#0-1) 

The `TimeoutSigningRepr` structure explicitly excludes the `reason` field from signature coverage. [3](#0-2) 

This breaks the **Cryptographic Correctness** invariant: the signature does not cover all security-relevant fields. A malicious validator can:

1. Create a legitimate `RoundTimeout` for their local timeout
2. Sign it using `TwoChainTimeout.sign()` (signature covers only epoch/round/hqc_round)
3. Replace the `reason` field with a malicious `PayloadUnavailable { missing_authors: <targeted_validators> }`
4. Broadcast the modified message

The modified message passes verification because `verify()` only checks that the signature is valid for the `timeout` component, not the `reason` field.

The `reason` field has significant behavioral impact:

**Timeout Reason Aggregation**: When forming a timeout certificate, validators aggregate timeout reasons by voting power, and the reason with f+1 voting power becomes the consensus reason. [4](#0-3) 

**Failure Tracking**: The `ExponentialWindowFailureTracker` treats `PayloadUnavailable` timeouts specially - they trigger exponential window growth (doubling up to max_window) and exclude authors listed in `missing_authors` from optimistic proposal generation. [5](#0-4) 

Other timeout reasons (`ProposalNotReceived`, `NoQC`, `Unknown`) are treated as successes and do not trigger these penalties. [6](#0-5) 

## Impact Explanation

**Severity: High** (per Aptos bug bounty: "Significant protocol violations")

A malicious validator can:
- Inject fabricated `PayloadUnavailable` reasons claiming arbitrary validators failed to provide payload
- Manipulate the timeout reason aggregation weighted by their voting power
- If they control sufficient voting power (f+1), force the aggregated reason to be their malicious `PayloadUnavailable`
- Trigger exponential backoff in the failure tracker
- Cause honest validators to be excluded from optimistic proposal generation

This constitutes a **significant protocol violation** affecting consensus liveness behavior. While it does not directly cause consensus safety violations or total network failure (Critical severity), it allows manipulation of the timeout mechanism and degradation of proposal efficiency.

The attack does not require network-level capabilities (MitM) - a single malicious validator with sufficient voting power can exploit this by crafting their own timeout messages.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attack Complexity**: Low - a malicious validator simply modifies the `reason` field before broadcasting their timeout message
- **Attacker Requirements**: Requires being a registered validator with voting power; impact proportional to voting power controlled
- **Detection Difficulty**: Hard to detect - the manipulated messages pass cryptographic verification and appear legitimate
- **Preconditions**: Requires timeout scenarios (which occur during network partitions, slow proposals, or payload unavailability)

The vulnerability exists in every round timeout scenario and is exploitable by any malicious validator.

## Recommendation

Include the `reason` field in the signed data structure. Modify `TwoChainTimeout.signing_format()` to return a structure that includes the reason field, or create a separate signing representation for `RoundTimeout` that covers all fields.

**Recommended Fix:**

```rust
// In round_timeout.rs, create a dedicated signing format
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct RoundTimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub author: Author,
    pub reason: RoundTimeoutReason,
}

impl RoundTimeout {
    pub fn signing_format(&self) -> RoundTimeoutSigningRepr {
        RoundTimeoutSigningRepr {
            epoch: self.timeout.epoch(),
            round: self.timeout.round(),
            hqc_round: self.timeout.hqc_round(),
            author: self.author,
            reason: self.reason.clone(),
        }
    }

    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.signing_format(), // Now includes reason
                &self.signature,
            )
            .context("Failed to verify round timeout signature")?;
        Ok(())
    }
}
```

This ensures the signature cryptographically binds the `reason` field, preventing post-signature modification.

## Proof of Concept

```rust
#[cfg(test)]
mod test_signature_bypass {
    use super::*;
    use aptos_types::validator_verifier::random_validator_verifier;
    use aptos_consensus_types::{
        round_timeout::{RoundTimeout, RoundTimeoutReason},
        timeout_2chain::TwoChainTimeout,
        quorum_cert::QuorumCert,
    };
    use aptos_bitvec::BitVec;

    #[test]
    fn test_timeout_reason_not_covered_by_signature() {
        let (signers, verifier) = random_validator_verifier(4, None, false);
        let signer = &signers[0];
        
        // Create a legitimate timeout with reason ProposalNotReceived
        let qc = QuorumCert::certificate_for_genesis();
        let timeout = TwoChainTimeout::new(1, 10, qc);
        let signature = timeout.sign(signer).unwrap();
        
        let original_reason = RoundTimeoutReason::ProposalNotReceived;
        let round_timeout = RoundTimeout::new(
            timeout.clone(),
            signer.author(),
            original_reason,
            signature.clone(),
        );
        
        // Verify the original timeout
        assert!(round_timeout.verify(&verifier).is_ok());
        
        // ATTACK: Modify the reason field to PayloadUnavailable with malicious missing_authors
        let mut malicious_missing_authors = BitVec::with_num_bits(verifier.len() as u16);
        malicious_missing_authors.set(1); // Falsely claim validator 1 is missing
        malicious_missing_authors.set(2); // Falsely claim validator 2 is missing
        
        let malicious_reason = RoundTimeoutReason::PayloadUnavailable {
            missing_authors: malicious_missing_authors,
        };
        
        let manipulated_timeout = RoundTimeout::new(
            timeout.clone(),
            signer.author(),
            malicious_reason, // Changed reason
            signature,        // Same signature (doesn't cover reason)
        );
        
        // The manipulated timeout still passes verification!
        // This demonstrates the signature bypass vulnerability
        assert!(manipulated_timeout.verify(&verifier).is_ok());
        
        // The manipulated reason will be aggregated and used in consensus logic
        // causing innocent validators 1 and 2 to be excluded from proposals
    }
}
```

This test demonstrates that a `RoundTimeout` message with a modified `reason` field passes verification despite having the same signature, proving that the signature does not cryptographically bind the reason field.

---

## Notes

This vulnerability represents a **signature verification bypass** where security-critical data (the timeout reason) is not covered by cryptographic protection. While the immediate impact is limited to validators with significant voting power, it violates fundamental cryptographic correctness principles and enables manipulation of consensus liveness mechanisms.

The `PayloadUnavailable` reason with `missing_authors` data is particularly sensitive as it directly controls which validators are excluded from proposal generation through the `ExponentialWindowFailureTracker`. The lack of signature coverage over this field creates an attack vector for consensus manipulation.

### Citations

**File:** consensus/consensus-types/src/round_timeout.rs (L38-45)
```rust
pub struct RoundTimeout {
    // The timeout
    timeout: TwoChainTimeout,
    author: Author,
    reason: RoundTimeoutReason,
    /// Signature on the Timeout
    signature: bls12381::Signature,
}
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L96-103)
```rust
/// Validators sign this structure that allows the TwoChainTimeoutCertificate to store a round number
/// instead of a quorum cert per validator in the signatures field.
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
}
```

**File:** consensus/src/pending_votes.rs (L93-153)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-98)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }

    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```
