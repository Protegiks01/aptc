# Audit Report

## Title
Lazy Loading Bypasses Cyclic Dependency Detection Allowing Publication of Invalid Module DAGs

## Summary
When lazy loading is enabled (default in Aptos), the module publishing verification explicitly skips cyclic dependency checks, allowing circular module dependencies to be published. This violates the fundamental invariant that modules must form a Directed Acyclic Graph (DAG), though existing runtime protections prevent infinite loops during execution.

## Finding Description

The Aptos Move VM supports two module loading modes: eager loading and lazy loading. Lazy loading is enabled by default as confirmed in the features configuration. [1](#0-0) 

During module publishing with lazy loading enabled, the verification code explicitly states that cyclic dependencies are NOT checked: [2](#0-1) 

The lazy loading verification path only performs local bytecode verification and linking checks to immediate dependencies, without traversing the full dependency graph: [3](#0-2) 

In contrast, eager loading mode properly detects and rejects cyclic dependencies through the `visit_dependencies_and_verify()` function which maintains a visited set and returns a cycle error: [4](#0-3) 

The proper cycle detection implementation exists in the bytecode verifier: [5](#0-4) 

**Attack Path:**
1. Attacker crafts Module A that imports Module B
2. Attacker crafts Module B that imports Module A  
3. Both modules are published together in a single bundle
4. With lazy loading enabled (default), verification loads each module's immediate dependencies via `unmetered_get_existing_lazily_verified_module()`
5. When verifying A, B is loaded and locally verified WITHOUT checking B's dependencies
6. When verifying B, B is already marked as verified in cache, so verification returns early
7. The circular dependency A→B→A is never detected and both modules are published

## Impact Explanation

**Medium Severity**: This issue violates the fundamental DAG invariant for module dependencies but does not directly cause infinite loops or consensus violations.

Runtime dependency traversal code paths include cycle protection via visited sets: [6](#0-5) 

However, tools that compute topological order will fail when encountering circular dependencies: [7](#0-6) 

This creates a state inconsistency requiring intervention, qualifying as Medium severity per bug bounty criteria: "State inconsistencies requiring intervention." Circular dependencies could cause:
- Module upgrade mechanisms to fail
- Package management tools to error
- Test infrastructure to malfunction
- Analysis tools assuming DAG structure to produce incorrect results

## Likelihood Explanation

**High Likelihood**: 
- Lazy loading is enabled by default in production
- Any user can publish modules to their account
- The attack requires only crafting two modules with mutual dependencies
- No special privileges or validator access required
- The vulnerability is deterministic - circular dependencies will always bypass detection

## Recommendation

Add explicit cyclic dependency checking for lazy loading mode during module publishing. The check should be performed after all modules in the bundle have been locally verified but before marking them as fully verified.

**Recommended Fix** in `publishing.rs`:

```rust
if is_lazy_loading_enabled {
    // ... existing local verification code ...
    
    // After all modules are locally verified, check for cycles
    // by traversing immediate dependencies with visited set
    let mut visited = HashSet::new();
    visited.insert(compiled_module.self_id());
    
    fn check_no_cycles(
        module_id: &ModuleId,
        visited: &mut HashSet<ModuleId>,
        storage: &impl ModuleStorage,
    ) -> VMResult<()> {
        let module = storage.unmetered_get_existing_deserialized_module(
            module_id.address(), 
            module_id.name()
        )?;
        for (dep_addr, dep_name) in module.immediate_dependencies_iter() {
            let dep_id = ModuleId::new(*dep_addr, dep_name.to_owned());
            if !visited.insert(dep_id.clone()) {
                return Err(module_cyclic_dependency_error!(dep_addr, dep_name));
            }
            check_no_cycles(&dep_id, visited, storage)?;
            visited.remove(&dep_id);
        }
        Ok(())
    }
    
    check_no_cycles(&compiled_module.self_id(), &mut visited, staged_module_storage)?;
}
```

## Proof of Concept

```rust
// Test demonstrating circular dependency bypass with lazy loading
// Place in: third_party/move/move-vm/integration-tests/src/tests/

#[test]
fn test_circular_dependency_with_lazy_loading() {
    // Module A depends on B
    let module_a_code = r#"
        module 0xCAFE::A {
            use 0xCAFE::B;
            public fun use_b(): u64 {
                B::get_value()
            }
        }
    "#;
    
    // Module B depends on A (circular!)
    let module_b_code = r#"
        module 0xCAFE::B {
            use 0xCAFE::A;
            public fun get_value(): u64 { 42 }
            public fun use_a(): u64 {
                A::use_b()
            }
        }
    "#;
    
    // Compile both modules
    let module_a = compile_module(module_a_code);
    let module_b = compile_module(module_b_code);
    
    // Create VM config with lazy loading enabled
    let vm_config = VMConfig {
        enable_lazy_loading: true,
        ..Default::default()
    };
    
    // Attempt to publish both modules in a bundle
    let bundle = vec![module_a.serialize(), module_b.serialize()];
    
    // With lazy loading, this SHOULD fail but currently SUCCEEDS
    let result = StagingModuleStorage::create(
        &AccountAddress::from_hex_literal("0xCAFE").unwrap(),
        &base_storage,
        bundle,
    );
    
    // Expected: Err with CYCLIC_MODULE_DEPENDENCY
    // Actual: Ok - circular dependency not detected!
    assert!(result.is_ok(), "Circular dependency was not detected with lazy loading");
    
    // Demonstrate the published modules violate DAG invariant
    let dep_graph = DependencyGraph::new([&module_a, &module_b]);
    let topo_result = dep_graph.compute_topological_order();
    
    // Topological sort will fail on circular dependencies
    assert!(topo_result.is_err(), "Topological sort fails on circular deps");
}
```

**Notes:**
- The issue violates the module DAG invariant but does not cause infinite loops during execution due to visited set protections in runtime code
- The vulnerability is specific to lazy loading mode which is enabled by default
- Eager loading mode correctly detects and rejects circular dependencies
- Impact is limited to tool failures and state inconsistencies rather than direct fund loss or consensus violations

### Citations

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L399-415)
```rust
        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** third_party/move/move-bytecode-verifier/src/cyclic_dependencies.rs (L88-94)
```rust
    // collect and check that there is no cyclic dependency relation
    let all_deps = collect_all_with_cycle_detection(
        &self_id,
        &module.immediate_dependencies(),
        &imm_deps,
        StatusCode::CYCLIC_MODULE_DEPENDENCY,
    )?;
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L59-65)
```rust
    pub fn visit_if_not_special_address(
        &mut self,
        addr: &'a AccountAddress,
        name: &'a IdentStr,
    ) -> bool {
        !addr.is_special() && self.visited.insert((addr, name), ()).is_none()
    }
```

**File:** third_party/move/tools/move-bytecode-utils/src/dependency_graph.rs (L55-59)
```rust
    pub fn compute_topological_order(&self) -> Result<impl Iterator<Item = &CompiledModule>> {
        match petgraph::algo::toposort(&self.graph, None) {
            Err(_) => bail!("Circular dependency detected"),
            Ok(ordered_idxs) => Ok(ordered_idxs.into_iter().map(move |idx| self.modules[idx.0])),
        }
```
