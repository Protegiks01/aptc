# Audit Report

## Title
Resource Group Migration Vulnerability: Orphaned Resources and Storage Inconsistency via Module Upgrade

## Summary
When the `SAFER_RESOURCE_GROUPS` feature flag is disabled, modules can be upgraded to add `#[resource_group_member]` attributes to existing resource structs. This causes resources that were previously stored as standalone resources to become inaccessible, as the VM now attempts to read them from a resource group location where they don't exist. This creates orphaned storage entries and allows creation of duplicate resources at different storage locations, violating state consistency invariants.

## Finding Description

The Aptos Move VM uses module metadata to determine whether a resource should be stored as a standalone resource or as a member within a resource group. The critical functions are: [1](#0-0) [2](#0-1) 

When `SAFER_RESOURCE_GROUPS` is enabled, the system prevents adding resource group attributes to existing structs: [3](#0-2) 

However, when this feature flag is disabled (which is possible via governance), the validation is skipped: [4](#0-3) 

**Attack Scenario:**

1. **Initial State**: Module `M` is published with struct `R` (no resource_group_member attribute). Resource instances are stored at `StateKey::resource(addr, R)`.

2. **Feature Flag Disabled**: Governance disables `SAFER_RESOURCE_GROUPS` feature flag.

3. **Module Upgrade**: Module `M` is upgraded to add `#[resource_group_member(group = M::G)]` to struct `R`. The upgrade succeeds: [5](#0-4) 

4. **Read Failure**: Future transactions attempting to read resource `R` will:
   - Load the upgraded module metadata showing `R` is a resource_group_member
   - Look for the resource at `StateKey::resource_group(addr, G)` 
   - Return `None` because the resource remains at the old `StateKey::resource(addr, R)` location
   - The resource becomes effectively inaccessible

5. **Write Duplication**: If a transaction attempts to create a new instance of `R`:
   - Checks `resource_exists_in_group()` which only checks the group location â†’ returns `false`
   - Creates new resource at `StateKey::resource_group(addr, G)`
   - **Result**: Two copies of the resource exist in storage at different locations [6](#0-5) 

The existence check only validates the resource doesn't exist in the group, not that it doesn't exist as a standalone resource.

## Impact Explanation

This vulnerability qualifies as **Medium to High Severity**:

**State Inconsistency** (Medium Severity - $10,000 range):
- Violates the "State Consistency" invariant that state transitions must be atomic and verifiable
- Creates orphaned resources in storage that are permanently inaccessible
- Causes storage bloat from unreachable data
- Leads to unexpected transaction failures when users attempt to access resources they know exist

**Potential for Higher Impact**:
- If critical system resources (staking, governance, token balances) are affected, could cause significant protocol violations
- Multiple validators would have identical orphaned data (deterministic), but the state is corrupted
- Requires manual intervention or migration scripts to resolve

The vulnerability is real but somewhat mitigated by:
1. `SAFER_RESOURCE_GROUPS` is enabled by default
2. Requires governance action to disable the flag
3. No direct loss of funds, but data becomes inaccessible

## Likelihood Explanation

**Likelihood: Low to Medium**

**Requirements:**
1. Governance must vote to disable `SAFER_RESOURCE_GROUPS` feature flag
2. A module owner must upgrade their module to add resource_group_member to existing structs
3. Resources of that type must already exist in storage from before the upgrade

**Scenarios where this could occur:**
- Unintentional: Developers upgrading modules without realizing the implications
- During testing/migration: If feature flag is temporarily disabled for migration purposes
- Historical: May have already occurred if the flag was ever disabled in the past

While governance control provides some protection, the fact that test cases explicitly demonstrate this "unsafe" upgrade path suggests it was considered acceptable behavior at some point, making it more likely to occur.

## Recommendation

**Short-term fix**: Never disable `SAFER_RESOURCE_GROUPS` feature flag in production. Consider marking it as a permanent feature that cannot be disabled.

**Long-term fix**: When module upgrades add resource_group_member attributes (even with the flag disabled), implement a migration validator that:

1. Checks if any instances of the struct exist at the standalone location
2. Either:
   - Reject the upgrade if orphaned resources would be created, OR
   - Automatically migrate existing resources to the group location during upgrade

**Code fix** in `validate_module_and_extract_new_entries`:

```rust
// After line 186, add migration check:
for member in new_members.keys() {
    if structs.remove(member) {
        // Check if any instances exist at standalone location
        let sample_key = StateKey::resource(&new_module.address(), 
            &StructTag { /* construct from member */ });
        
        if module_storage.check_resource_exists_at_key(&sample_key)? {
            metadata_validation_err(
                "Cannot add resource_group_member to struct with existing standalone instances. \
                 Migration required."
            )?;
        }
        
        if features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        }
    }
}
```

Additionally, implement a read fallback in `get_any_resource_with_layout` that checks the standalone location if the resource is not found in the group.

## Proof of Concept

```move
// File: test_resource_group_orphan.move
module 0xCAFE::OrphanTest {
    use std::signer;
    
    // Initial version: regular resource
    struct MyResource has key {
        value: u64
    }
    
    public entry fun create_resource(account: &signer) {
        move_to(account, MyResource { value: 42 });
    }
    
    public entry fun read_resource(addr: address): u64 acquires MyResource {
        borrow_global<MyResource>(addr).value
    }
}

// After upgrade with SAFER_RESOURCE_GROUPS disabled:
module 0xCAFE::OrphanTest {
    use std::signer;
    
    #[resource_group(scope = address)]
    struct ResourceGroup { }
    
    // Upgraded version: now a resource group member
    #[resource_group_member(group = 0xCAFE::OrphanTest::ResourceGroup)]
    struct MyResource has key {
        value: u64
    }
    
    public entry fun create_resource(account: &signer) {
        move_to(account, MyResource { value: 99 }); // Creates at group location
    }
    
    public entry fun read_resource(addr: address): u64 acquires MyResource {
        borrow_global<MyResource>(addr).value // Fails: looks in group, finds nothing
    }
}

// Test steps:
// 1. Publish initial module, call create_resource() -> stores at standalone location
// 2. Disable SAFER_RESOURCE_GROUPS via governance
// 3. Upgrade module to add resource_group_member attribute
// 4. Call read_resource() -> Returns error "resource not found"
// 5. Call create_resource() again -> Succeeds, creates duplicate at group location
// 6. Storage now contains TWO MyResource instances at different locations
```

## Notes

This vulnerability exists at the intersection of the module upgrade validation system and the resource storage/retrieval mechanism. The system correctly prevents the unsafe upgrade when `SAFER_RESOURCE_GROUPS` is enabled, but the feature flag provides a bypass that creates permanent storage inconsistencies. The fact that explicit test cases exist for "unsafe" upgrades suggests this may have been considered acceptable behavior, but the security implications are significant for state integrity.

### Citations

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L365-391)
```rust
            for (struct_tag, blob_op) in resources {
                let resource_group_tag = {
                    // INVARIANT:
                    //   We do not need to meter metadata access here. If this resource is in data
                    //   cache, we must have already fetched metadata for its tag.
                    let module = module_storage
                        .unmetered_get_existing_deserialized_module(
                            &struct_tag.address,
                            &struct_tag.module,
                        )
                        .map_err(|e| e.to_partial())?;

                    get_resource_group_member_from_metadata(&struct_tag, &module.metadata)
                };

                if let Some(resource_group_tag) = resource_group_tag {
                    if resource_groups
                        .entry(resource_group_tag)
                        .or_default()
                        .insert(struct_tag, blob_op)
                        .is_some()
                    {
                        return Err(common_error());
                    }
                } else {
                    resources_filtered.insert(struct_tag, blob_op);
                }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L417-425)
```rust
                        for (struct_tag, current_op) in resources.iter() {
                            let exists =
                                resolver.resource_exists_in_group(&state_key, struct_tag)?;
                            if matches!(current_op, MoveStorageOp::New(_)) == exists {
                                // Deletion and Modification require resource to exist,
                                // while creation requires the resource to not exist.
                                return Err(common_error());
                            }
                        }
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L167-186)
```rust
    if !features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
        return Ok((new_groups, new_members));
    }

    // At this point, only original structs that do not have resource group affiliation are left.
    // Note, we do not validate for being both a member and a group, because there are other
    // checks earlier on, such as, a resource group must have no abilities, while a resource group
    // member must.

    for group in new_groups.keys() {
        if structs.remove(group) {
            metadata_validation_err("Invalid addition of resource_group attribute")?;
        }
    }

    for member in new_members.keys() {
        if structs.remove(member) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L205-205)
```rust
            FeatureFlag::SAFER_RESOURCE_GROUPS,
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L474-507)
```rust
fn verify_unsafe_resource_group_member_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible addition of ResourceGroupMember
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
```
