# Audit Report

## Title
Gas Undercharging for Large AccessSpecifier Cloning in Move VM Function Entry

## Summary
The Move VM does not charge gas proportional to the size of `AccessSpecifier` structures when entering functions. At line 44 of `access_control.rs`, the `access_specifier().clone()` operation copies potentially large data structures containing hundreds of access control clauses with complex nested types, but the gas meter only charges a fixed cost per function call regardless of `AccessSpecifier` complexity. This enables DoS attacks through disproportionate CPU consumption. [1](#0-0) 

## Finding Description

When a Move function is called, the interpreter charges gas via `charge_call()` based only on the number of arguments and local variables, then enters the function by calling `access_control.enter_function()`. This function clones the entire `AccessSpecifier` structure from the function definition without any gas accounting for the clone operation. [2](#0-1) [3](#0-2) 

The `AccessSpecifier::Constraint` variant contains two `Vec<AccessSpecifierClause>` - one for inclusions and one for exclusions. Each clause can contain `ResourceSpecifier::ResourceInstantiation` with a `Vec<Type>` that can hold complex, deeply nested type structures. [4](#0-3) 

The gas charging implementation in Aptos only accounts for base cost, per-argument cost, and per-local cost, with no consideration for `AccessSpecifier` complexity: [5](#0-4) 

**Attack Path:**
1. Attacker publishes a Move module containing functions with hundreds of `AccessSpecifier` clauses
2. Each clause references complex type instantiations from the module's signature table (up to max_type_nodes limit of 128-256 nodes per type)
3. When transactions call these functions, the VM clones thousands of type nodes during `enter_function()`
4. Gas charged remains constant (CALL_BASE + args + locals) regardless of `AccessSpecifier` size
5. Attacker submits many transactions calling these functions, consuming disproportionate validator CPU time relative to gas paid

The bytecode verifier has no limit on the number of access specifiers per function, allowing arbitrary numbers within module size constraints: [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability breaks the **Move VM Safety** invariant: "Bytecode execution must respect gas limits and memory constraints" and the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

The issue enables **validator node slowdowns** through disproportionate CPU consumption, qualifying as **High Severity** ($50,000) per the Aptos bug bounty program. Alternatively, it could be classified as **Medium Severity** ($10,000) for causing resource exhaustion requiring intervention.

An attacker can:
- Consume validator CPU cycles without proportional gas payment
- Slow down block processing across the network
- Create performance degradation that affects all validators processing blocks containing the malicious transactions
- Potentially cause validators with different hardware specifications to process blocks at divergent speeds, risking consensus liveness issues

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to publish Move modules (requires gas payment, but one-time cost)
- Knowledge of the gas undercharging mechanism
- Ability to craft modules with large access specifier structures

**Complexity: Low**
- Publishing a module with many access specifiers is straightforward
- No special privileges required
- Attack can be amplified through repeated transaction submissions

**Detection: Difficult**
- The module appears legitimate with valid access control declarations
- Gas metering appears normal to transaction senders
- Performance degradation may be attributed to network load rather than malicious activity

## Recommendation

Add gas charging proportional to `AccessSpecifier` size before cloning. The gas should account for:
1. Number of inclusion and exclusion clauses
2. Complexity of each clause (resource specifier type nodes, address specifier complexity)
3. Total memory allocation required for the clone operation

**Recommended Fix:**

Add a new gas charging method in the `GasMeter` trait:
```rust
fn charge_access_specifier(&mut self, num_clauses: NumArgs, num_type_nodes: NumTypeNodes) -> PartialVMResult<()>;
```

Modify `enter_function()` to charge gas before cloning: [8](#0-7) 

The fix should calculate the total size of the `AccessSpecifier` (number of clauses + total type nodes) and charge proportional gas before performing the clone operation. Alternatively, consider caching the specialized access specifiers to avoid repeated cloning for frequently called functions.

## Proof of Concept

```move
// Malicious module with large access specifiers
module attacker::dos_module {
    use std::signer;
    
    // Function with many access specifier clauses
    // Each clause would reference complex type instantiations
    // Example: reads T1<T2<T3<...>>>@address, reads T4<T5<...>>@address, etc.
    // Repeated hundreds of times to maximize clone cost
    public fun expensive_call() 
        reads /* 100+ complex type instantiation clauses here */
    {
        // Minimal function body - the cost is in entering the function
    }
    
    // Entry function to trigger the attack
    public entry fun trigger_dos(account: &signer) {
        let i = 0;
        while (i < 100) {
            expensive_call();
            i = i + 1;
        }
    }
}
```

**Exploitation Steps:**
1. Compile and publish the module with maximum allowed access specifiers (hundreds of clauses with complex nested types up to max_type_nodes limit)
2. Submit transactions calling `trigger_dos()` repeatedly
3. Each call to `expensive_call()` clones thousands of type nodes without proportional gas charge
4. Observe validator CPU consumption spike while gas charged remains minimal
5. Multiply effect by submitting many such transactions across multiple blocks

The actual PoC would require constructing valid Move bytecode with a function definition containing a large `access_specifiers` vector, which can be done using the Move compiler or by crafting the binary format directly within the module size limits.

### Citations

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L26-49)
```rust
    pub(crate) fn enter_function(
        &mut self,
        env: &impl AccessSpecifierEnv,
        fun: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if matches!(fun.access_specifier(), AccessSpecifier::Any) {
            // Shortcut case that no access is specified
            return Ok(());
        }
        if self.specifier_stack.len() >= ACCESS_STACK_SIZE_LIMIT {
            Err(
                PartialVMError::new(StatusCode::ACCESS_STACK_LIMIT_EXCEEDED).with_message(format!(
                    "access specifier stack overflow (limit = {})",
                    ACCESS_STACK_SIZE_LIMIT
                )),
            )
        } else {
            // Specialize the functions access specifier and push it on the stack.
            let mut fun_specifier = fun.access_specifier().clone();
            fun_specifier.specialize(env)?;
            self.specifier_stack.push(fun_specifier);
            Ok(())
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L510-519)
```rust
                    gas_meter
                        .charge_call(
                            function.owner_as_module()?.self_id(),
                            function.name(),
                            self.operand_stack
                                .last_n(function.param_tys().len())
                                .map_err(|e| set_err_info!(current_frame, e))?,
                            (function.local_tys().len() as u64).into(),
                        )
                        .map_err(|e| set_err_info!(current_frame, e))?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L916-918)
```rust
        self.access_control
            .enter_function(&frame, &frame.function)
            .map_err(|e| self.set_location(e))?;
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L44-62)
```rust
/// Represents an access specifier.
#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Debug)]
pub enum AccessSpecifier {
    /// Universal access granted
    Any,
    /// A constraint in normalized form `Constraint(inclusions, exclusions)`.
    /// The inclusions are a _disjunction_ and the exclusions a _conjunction_ of
    /// access clauses. An access is valid if it is enabled by any of the
    /// inclusions, and not enabled for each of the exclusions.
    Constraint(Vec<AccessSpecifierClause>, Vec<AccessSpecifierClause>),
}

/// Represents an access specifier clause
#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Debug)]
pub struct AccessSpecifierClause {
    pub kind: AccessKind,
    pub resource: ResourceSpecifier,
    pub address: AddressSpecifier,
}
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L250-265)
```rust
    fn charge_call(
        &mut self,
        _module_id: &ModuleId,
        _func_name: &str,
        args: impl ExactSizeIterator<Item = impl ValueView>,
        num_locals: NumArgs,
    ) -> PartialVMResult<()> {
        let cost = CALL_BASE + CALL_PER_ARG * NumArgs::new(args.len() as u64);

        match self.feature_version() {
            0..=2 => self.algebra.charge_execution(cost),
            3.. => self
                .algebra
                .charge_execution(cost + CALL_PER_LOCAL * num_locals),
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-193)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L20-48)
```rust
pub fn load_access_specifier(
    module: BinaryIndexedView,
    signature_table: &[Vec<Type>],
    struct_names: &[StructIdentifier],
    specifier: &Option<Vec<FF::AccessSpecifier>>,
) -> PartialVMResult<AccessSpecifier> {
    if let Some(specs) = specifier {
        let mut incls = vec![];
        let mut excls = vec![];
        for spec in specs {
            let resource =
                load_resource_specifier(module, signature_table, struct_names, &spec.resource)?;
            let address = load_address_specifier(module, &spec.address)?;
            let clause = AccessSpecifierClause {
                kind: spec.kind,
                resource,
                address,
            };
            if spec.negated {
                excls.push(clause)
            } else {
                incls.push(clause)
            }
        }
        Ok(AccessSpecifier::Constraint(incls, excls))
    } else {
        Ok(AccessSpecifier::Any)
    }
}
```
