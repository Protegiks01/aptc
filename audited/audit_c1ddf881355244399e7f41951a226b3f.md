# Audit Report

## Title
Unvalidated Storage Summary Injection from New Peers Enables State Sync Disruption and Performance Degradation

## Summary
New peers without established peer states can inject malicious storage summaries that are accepted without cryptographic or sanity validation. These false summaries pollute the global data summary, enabling attackers to manipulate chunk sizes, advertise non-existent data ranges, and disrupt state synchronization across the network.

## Finding Description

At lines 206-212 in `peer_states.rs`, the `can_service_request()` function allows any peer—including newly connected peers without peer states—to respond to `storage_summary_request()`: [1](#0-0) 

When a new peer responds with a `StorageServerSummary`, the response is stored without validation via `update_summary()`: [2](#0-1) 

This enables the following attack chain:

1. **Malicious Summary Injection**: An attacker connects a malicious peer and responds to the initial storage summary poll with a crafted `StorageServerSummary` containing:
   - False `synced_ledger_info` with arbitrary version/epoch (no signature verification performed)
   - Fake data ranges (transactions, states, outputs) claiming to possess data they don't have
   - Extreme `protocol_metadata` chunk sizes (e.g., 1 or u64::MAX)

2. **Unvalidated Storage**: The malicious summary is stored directly without any validation:
   - No signature verification on the `LedgerInfoWithSignatures` within the summary
   - No sanity checks on data range validity
   - No verification that advertised data actually exists

3. **Global Summary Pollution**: The malicious summary is included in global data summary calculations: [3](#0-2) 

4. **Chunk Size Manipulation**: Malicious chunk sizes directly influence the median calculation used network-wide: [4](#0-3) 

5. **Peer Selection Impact**: Malicious peers appear serviceable for data requests they cannot fulfill: [5](#0-4) 

6. **Delayed Detection**: New peers start with a score of 50.0, well above the ignore threshold of 25.0: [6](#0-5) 

This means malicious peers remain active and influence the network until multiple failed requests drive their score below the ignore threshold.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: By injecting extremely small chunk sizes (e.g., chunk_size=1), an attacker forces nodes to request data in minimal increments, causing severe performance degradation. The median calculation means even a minority of malicious peers can significantly reduce optimal chunk sizes.

2. **Significant Protocol Violations**: Attackers can advertise false data availability, causing nodes to:
   - Select malicious peers for critical state sync operations
   - Experience repeated request failures and timeouts
   - Waste bandwidth and CPU on invalid peer interactions

3. **Sybil Attack Amplification**: An attacker can deploy multiple malicious peers, each advertising false summaries. This:
   - Increases the probability that victim nodes select malicious peers
   - Amplifies chunk size manipulation (multiple malicious values skew the median)
   - Degrades overall network state sync performance

4. **State Sync Disruption**: Nodes attempting to synchronize state (especially new nodes joining the network or nodes recovering from downtime) will experience significant delays due to false data availability and degraded chunk sizes.

## Likelihood Explanation

This attack is **highly likely** to occur because:

1. **Low Barrier to Entry**: Any actor can connect as a peer to Aptos nodes without authentication beyond basic network connectivity
2. **No Initial Validation**: Storage summaries from new peers are accepted without cryptographic verification or sanity checks
3. **Immediate Impact**: The malicious summary takes effect immediately upon being stored and included in the global data summary
4. **Detection Delay**: Malicious peers remain above the ignore threshold for multiple failed requests before being filtered out
5. **Persistent Effect**: Each polling cycle re-includes the malicious peer's summary until their score drops sufficiently low

## Recommendation

Implement validation for storage summaries received from peers:

1. **Signature Verification**: Verify the `LedgerInfoWithSignatures` in the storage summary has valid BLS signatures from a quorum of known validators before accepting it:

```rust
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Validate the synced ledger info has valid signatures
    if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
        if let Err(e) = self.verify_ledger_info_signatures(synced_ledger_info) {
            warn!("Rejecting storage summary from peer {} with invalid signatures: {}", peer, e);
            return;
        }
    }
    
    // Validate chunk sizes are within reasonable bounds
    let metadata = &storage_summary.protocol_metadata;
    if !self.validate_chunk_sizes(metadata) {
        warn!("Rejecting storage summary from peer {} with invalid chunk sizes", peer);
        return;
    }
    
    // Store the validated summary
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}
```

2. **Sanity Checks on Data Ranges**: Validate that advertised data ranges are reasonable and consistent with known network state

3. **Initial Score Penalty**: Consider giving new peers a lower initial score until they prove reliable, or require multiple successful summaries before including them in global calculations

4. **Outlier Detection**: Implement statistical outlier detection for chunk sizes to filter extreme values before calculating the median

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_config::config::AptosDataClientConfig;
    use aptos_storage_service_types::responses::{
        DataSummary, ProtocolMetadata, StorageServerSummary,
    };
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    #[test]
    fn test_malicious_storage_summary_injection() {
        // Create peer states
        let config = Arc::new(AptosDataClientConfig::default());
        let peer_states = PeerStates::new(config.clone());
        
        // Create a malicious peer
        let malicious_peer = PeerNetworkId::random();
        
        // Create a malicious storage summary with:
        // 1. Fake high version in ledger info
        // 2. Extremely small chunk size
        let malicious_summary = StorageServerSummary {
            protocol_metadata: ProtocolMetadata {
                max_epoch_chunk_size: 1,  // Extremely small to degrade performance
                max_state_chunk_size: 1,
                max_transaction_chunk_size: 1,
                max_transaction_output_chunk_size: 1,
            },
            data_summary: DataSummary {
                synced_ledger_info: Some(create_fake_ledger_info(999999)), // Fake high version
                epoch_ending_ledger_infos: Some(CompleteDataRange::new(0, 1000).unwrap()),
                states: Some(CompleteDataRange::new(0, 999999).unwrap()), // False advertisement
                transactions: Some(CompleteDataRange::new(0, 999999).unwrap()),
                transaction_outputs: Some(CompleteDataRange::new(0, 999999).unwrap()),
            },
        };
        
        // Inject the malicious summary - no validation occurs
        peer_states.update_summary(malicious_peer, malicious_summary.clone());
        
        // Calculate global data summary
        let global_summary = peer_states.calculate_global_data_summary();
        
        // Verify malicious data is included
        assert_eq!(
            global_summary.optimal_chunk_sizes.transaction_chunk_size, 
            1,  // Malicious chunk size affected the median
            "Malicious chunk size was included in global summary calculation"
        );
        
        // Verify malicious peer appears serviceable for requests it cannot fulfill
        let fake_request = StorageServiceRequest::new(
            DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                proof_version: 100,
                start_version: 0,
                end_version: 100,
                include_events: false,
            }),
            false,
        );
        
        let can_service = peer_states.can_service_request(
            &malicious_peer,
            TimeService::mock(),
            &fake_request,
        );
        
        assert!(
            can_service,
            "Malicious peer falsely appears serviceable for data it doesn't have"
        );
    }
    
    fn create_fake_ledger_info(version: u64) -> LedgerInfoWithSignatures {
        // Create a fake ledger info without valid signatures
        // In a real attack, this would have invalid/missing signatures
        // but still be accepted due to lack of validation
        LedgerInfoWithSignatures::new(/* ... */)
    }
}
```

This PoC demonstrates that:
1. Malicious storage summaries are accepted without validation
2. They directly influence global data summary calculations (chunk sizes)
3. Malicious peers appear serviceable for requests they cannot fulfill
4. The attack succeeds without requiring any validator privileges

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L85-93)
```rust
    pub fn new(data_client_config: Arc<AptosDataClientConfig>) -> Self {
        Self {
            data_client_config,
            received_responses_by_type: Arc::new(DashMap::new()),
            sent_requests_by_type: Arc::new(DashMap::new()),
            storage_summary: None,
            score: STARTING_SCORE,
        }
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L206-212)
```rust
        // Storage services can always respond to data advertisement requests.
        // We need this outer check, since we need to be able to send data summary
        // requests to new peers (who don't have a peer state yet).
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return true;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-330)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L363-394)
```rust
        for summary in storage_summaries {
            // Collect aggregate data advertisements
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
            }
            if let Some(states) = summary.data_summary.states {
                advertised_data.states.push(states);
            }
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
            if let Some(transactions) = summary.data_summary.transactions {
                advertised_data.transactions.push(transactions);
            }
            if let Some(transaction_outputs) = summary.data_summary.transaction_outputs {
                advertised_data
                    .transaction_outputs
                    .push(transaction_outputs);
            }

            // Collect preferred max chunk sizes
            max_epoch_chunk_sizes.push(summary.protocol_metadata.max_epoch_chunk_size);
            max_state_chunk_sizes.push(summary.protocol_metadata.max_state_chunk_size);
            max_transaction_chunk_sizes.push(summary.protocol_metadata.max_transaction_chunk_size);
            max_transaction_output_chunk_sizes
                .push(summary.protocol_metadata.max_transaction_output_chunk_size);
        }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L419-443)
```rust
pub(crate) fn calculate_optimal_chunk_sizes(
    config: &AptosDataClientConfig,
    max_epoch_chunk_sizes: Vec<u64>,
    max_state_chunk_sizes: Vec<u64>,
    max_transaction_chunk_sizes: Vec<u64>,
    max_transaction_output_chunk_size: Vec<u64>,
) -> OptimalChunkSizes {
    let epoch_chunk_size = median_or_max(max_epoch_chunk_sizes, config.max_epoch_chunk_size);
    let state_chunk_size = median_or_max(max_state_chunk_sizes, config.max_state_chunk_size);
    let transaction_chunk_size = median_or_max(
        max_transaction_chunk_sizes,
        config.max_transaction_chunk_size,
    );
    let transaction_output_chunk_size = median_or_max(
        max_transaction_output_chunk_size,
        config.max_transaction_output_chunk_size,
    );

    OptimalChunkSizes {
        epoch_chunk_size,
        state_chunk_size,
        transaction_chunk_size,
        transaction_output_chunk_size,
    }
}
```

**File:** state-sync/aptos-data-client/src/client.rs (L540-560)
```rust
    fn identify_serviceable(
        &self,
        peers_by_priorities: &BTreeMap<PeerPriority, HashSet<PeerNetworkId>>,
        priority: PeerPriority,
        request: &StorageServiceRequest,
    ) -> HashSet<PeerNetworkId> {
        // Get the peers for the specified priority
        let prospective_peers = peers_by_priorities
            .get(&priority)
            .unwrap_or(&hashset![])
            .clone();

        // Identify and return the serviceable peers
        prospective_peers
            .into_iter()
            .filter(|peer| {
                self.peer_states
                    .can_service_request(peer, self.time_service.clone(), request)
            })
            .collect()
    }
```
