# Audit Report

## Title
Parking Lot Resource Exhaustion Vulnerability in Mempool Allows Memory Exhaustion and Transaction Blocking

## Summary
The mempool's `ParkingLotIndex` for non-ready (future-sequence) transactions lacks proper eviction safeguards, allowing an attacker to fill the parking lot with up to 2 million transactions consuming up to 2 GB of memory. The eviction logic only triggers when ready transactions are inserted, creating a vulnerability where legitimate future-sequence transactions are permanently blocked and all ready transaction insertions suffer performance degradation from forced eviction overhead. [1](#0-0) 

## Finding Description
The mempool maintains a `ParkingLotIndex` for transactions that cannot be included in the next block due to having sequence numbers higher than the account's current sequence number. The critical vulnerability exists in the eviction logic: [2](#0-1) 

The `check_is_full_after_eviction` function only attempts to evict parking lot transactions when **both** conditions are met:
1. Mempool is full (`self.is_full()`)
2. The **new incoming transaction** is ready for broadcast (`self.check_txn_ready(txn, account_sequence_number)`) [3](#0-2) 

This design flaw allows the following attack:

**Attack Execution:**
1. Attacker creates approximately 20,000 accounts
2. For each account, attacker sends 100 transactions with future sequence numbers (e.g., sequence 1000-1099 when account sequence is 0)
3. Per-account limit check passes (100 transactions ≤ `capacity_per_user` of 100)
4. All 2,000,000 transactions are inserted and placed in the parking lot
5. Mempool becomes full (either by transaction count or the 2 GB byte limit) [4](#0-3) [5](#0-4) 

**Resulting State:**
- When attacker sends additional future-sequence transactions: rejected without eviction (condition at line 420 is false because new transaction is not ready)
- When legitimate users send future-sequence transactions: rejected without eviction
- When legitimate users send ready transactions: eviction occurs but causes performance degradation
- Parking lot remains monopolized by attacker's transactions [6](#0-5) 

The parking lot transactions will remain until system TTL expires (600 seconds default), but attacker can continuously refresh by sending new transactions as old ones expire. [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria:

**Validator Node Slowdowns:**
- Every ready transaction insertion when mempool is full must execute the eviction loop (lines 422-447)
- Random selection and removal from parking lot adds computational overhead
- Metrics logging adds additional latency [8](#0-7) 

**Resource Exhaustion:**
- Up to 2,000,000 transactions or 2 GB of memory consumed by attacker's parking lot transactions
- Memory held hostage for system TTL duration (600 seconds minimum)
- Forces all validator nodes to maintain bloated mempools

**Transaction Processing Disruption:**
- Legitimate future-sequence transactions (scheduled transactions, batched operations) are completely blocked
- Users cannot pre-submit transaction sequences
- Ready transactions experience insertion latency due to eviction overhead

**Availability Impact:**
- Sustained attack can degrade mempool performance across all validator nodes
- Transaction submission API becomes slower and less reliable
- Mempool becomes weaponized resource that attacker controls

## Likelihood Explanation
**High likelihood** of exploitation:

**Attacker Requirements:**
- Ability to create ~20,000 accounts (requires account creation fees but economically feasible)
- Ability to submit 2,000,000 transactions (requires gas fees but achievable for motivated attacker)
- No validator privileges or insider access required

**Attack Complexity:**
- Low complexity: straightforward to execute via automated scripts
- Attack is deterministic and predictable
- Can be sustained by continuously refreshing expired transactions

**Motivation:**
- Competitors seeking to degrade Aptos network performance
- Attackers profiting from network disruption (e.g., shorting positions)
- Nation-state actors targeting blockchain infrastructure
- Ransom/extortion scenarios

**Detection Difficulty:**
- Transactions appear valid (correct signatures, valid sequence numbers)
- Parking lot growth is a normal operation, making abnormal growth harder to detect initially
- No consensus violations or obvious red flags

## Recommendation

Implement defensive eviction for non-ready transaction insertions to prevent parking lot monopolization:

```rust
fn check_is_full_after_eviction(
    &mut self,
    txn: &MempoolTransaction,
    account_sequence_number: Option<u64>,
) -> bool {
    let txn_is_ready = self.check_txn_ready(txn, account_sequence_number);
    
    // NEW: Also evict for non-ready transactions if parking lot is disproportionately large
    let should_evict = if self.is_full() {
        if txn_is_ready {
            true  // Original logic: always evict for ready transactions
        } else {
            // NEW: Evict if parking lot exceeds threshold (e.g., 50% of capacity)
            let parking_lot_threshold = self.capacity / 2;
            self.parking_lot_index.size() >= parking_lot_threshold
        }
    } else {
        false
    };
    
    if should_evict {
        let now = Instant::now();
        let mut evicted_txns = 0;
        let mut evicted_bytes = 0;
        while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
            if let Some(txn) = self
                .transactions
                .get_mut(&txn_pointer.sender)
                .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
            {
                evicted_bytes += txn.get_estimated_bytes() as u64;
                evicted_txns += 1;
                self.index_remove(&txn);
                if !self.is_full() {
                    break;
                }
            } else {
                break;
            }
        }
        if evicted_txns > 0 {
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
            counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                .observe(now.elapsed().as_secs_f64());
        }
    }
    self.is_full()
}
```

**Additional Mitigations:**
1. Add monitoring/alerting for parking lot size relative to total mempool capacity
2. Reduce `capacity_per_user` or implement separate `parking_lot_capacity_per_user` limit
3. Implement aging-based eviction where oldest parking lot transactions are evicted first
4. Add rate limiting on future-sequence transaction submissions per account

## Proof of Concept

```rust
#[test]
fn test_parking_lot_exhaustion_attack() {
    use crate::core_mempool::CoreMempool;
    use aptos_config::config::NodeConfig;
    use aptos_types::{
        account_address::AccountAddress,
        transaction::{ReplayProtector, SignedTransaction},
    };
    
    // Configure mempool with default settings
    let config = NodeConfig::generate_random_config();
    let mut mempool = CoreMempool::new(&config);
    
    // Attacker creates 20,000 accounts and sends 100 future-sequence transactions each
    let num_attacker_accounts = 20_000;
    let txns_per_account = 100;
    
    let mut attacker_accounts = Vec::new();
    for _ in 0..num_attacker_accounts {
        attacker_accounts.push(AccountAddress::random());
    }
    
    // Fill parking lot with future-sequence transactions
    for account in &attacker_accounts {
        for seq_num in 1000..1100 {  // Future sequence numbers (current account seq is 0)
            let txn = TestTransaction::new_with_address(
                *account,
                ReplayProtector::SequenceNumber(seq_num),
                1,  // Low gas price
            );
            
            // Transactions should be accepted and placed in parking lot
            let status = add_txn(&mut mempool, txn);
            if seq_num < 1000 + txns_per_account {
                assert_eq!(status.code, MempoolStatusCode::Accepted);
            }
        }
    }
    
    // Verify parking lot is filled
    assert_eq!(mempool.get_parking_lot_size(), num_attacker_accounts * txns_per_account);
    
    // Legitimate user tries to send future-sequence transaction
    let legitimate_account = AccountAddress::random();
    let legitimate_future_txn = TestTransaction::new_with_address(
        legitimate_account,
        ReplayProtector::SequenceNumber(10),  // Future sequence
        1000,  // High gas price
    );
    
    // This should fail because parking lot is full and new transaction is not ready
    let status = add_txn(&mut mempool, legitimate_future_txn);
    assert_eq!(status.code, MempoolStatusCode::MempoolIsFull);
    
    // Ready transaction from legitimate user can still enter by triggering eviction
    let legitimate_ready_txn = TestTransaction::new_with_address(
        legitimate_account,
        ReplayProtector::SequenceNumber(0),  // Ready sequence
        1000,  // High gas price
    );
    
    let start = Instant::now();
    let status = add_txn(&mut mempool, legitimate_ready_txn);
    let eviction_time = start.elapsed();
    
    // Transaction is accepted but eviction caused latency
    assert_eq!(status.code, MempoolStatusCode::Accepted);
    println!("Eviction latency: {:?}", eviction_time);
    
    // Demonstrate that parking lot remains large after single eviction
    // (Only enough transactions were evicted to make space for the one ready transaction)
    assert!(mempool.get_parking_lot_size() > num_attacker_accounts * txns_per_account - 10);
}
```

## Notes

This vulnerability fundamentally breaks the resource limits invariant by allowing unprivileged attackers to monopolize mempool resources. The parking lot design assumes cooperative behavior where future-sequence transactions will eventually become ready and be processed. However, an adversarial actor can deliberately flood the parking lot with transactions that will never become ready, weaponizing this data structure against the network.

The fix must balance between allowing legitimate future-sequence transaction batching (a valid use case) while preventing parking lot monopolization. The recommended threshold-based eviction provides this balance by allowing moderate parking lot usage while preventing extreme cases.

### Citations

**File:** mempool/src/lib.rs (L42-47)
```rust
//! All transactions that are not ready to be included in the next block are part of separate
//! `ParkingLotIndex`. They will be moved to the ordered queue once some event unblocks them. For
//! example, Mempool has transaction with sequence number 4, while current sequence number for that
//! account is 3. Such transaction is considered to be “non-ready”. Then callback from Consensus
//! notifies that transaction was committed(i.e. transaction 3 was submitted to different node).
//! Such event “unblocks” local transaction and txn4 will be moved to OrderedQueue.
```

**File:** mempool/src/core_mempool/transaction_store.rs (L322-332)
```rust
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L412-456)
```rust
    /// Checks if Mempool is full.
    /// If it's full, tries to free some space by evicting transactions from the ParkingLot.
    /// We only evict on attempt to insert a transaction that would be ready for broadcast upon insertion.
    fn check_is_full_after_eviction(
        &mut self,
        txn: &MempoolTransaction,
        account_sequence_number: Option<u64>,
    ) -> bool {
        if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
            let now = Instant::now();
            // try to free some space in Mempool from ParkingLot by evicting non-ready txns
            let mut evicted_txns = 0;
            let mut evicted_bytes = 0;
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
            }
            if evicted_txns > 0 {
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                    .observe(now.elapsed().as_secs_f64());
            }
        }
        self.is_full()
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L458-460)
```rust
    fn is_full(&self) -> bool {
        self.system_ttl_index.size() >= self.capacity || self.size_bytes >= self.capacity_bytes
    }
```

**File:** config/src/config/mempool_config.rs (L121-123)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
```

**File:** config/src/config/mempool_config.rs (L129-129)
```rust
            system_transaction_timeout_secs: 600,
```
