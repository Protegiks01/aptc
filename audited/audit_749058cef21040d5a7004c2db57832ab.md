# Audit Report

## Title
Partial Deposit Commit in NativeValueCacheRawTransactionExecutor BatchTransfer on Failure

## Summary
The `NativeValueCacheRawTransactionExecutor` implementation in the executor benchmark lacks transaction atomicity for `BatchTransfer` operations. When a deposit or account check fails mid-batch, previous deposits remain committed to the shared cache, violating atomic transaction semantics and creating inconsistent state visible to parallel transactions.

## Finding Description

In the `execute_transaction()` method handling `BatchTransfer`, the code processes multiple deposits sequentially in a loop. [1](#0-0) 

The critical flaw exists in how `NativeValueCacheRawTransactionExecutor` handles state modifications. Unlike `NativeRawTransactionExecutor` which accumulates changes in a local `IncrementalOutput` structure, the cached executor directly modifies a shared `DashMap` cache. [2](#0-1) 

When `deposit_apt()` is called for each recipient, it invokes `update_fa_balance()` or `update_coin_balance()`, which directly mutate cached resources. [3](#0-2) 

**Attack Scenario:**
1. Transaction A: `BatchTransfer` from Alice to [Bob, Charlie, Dave] with amounts [100, 200, 300]
2. Alice's balance withdrawn: cache modified (Alice -= 600)
3. Deposit to Bob succeeds: cache modified (Bob += 100)
4. Deposit to Charlie succeeds: cache modified (Charlie += 200)  
5. `check_or_create_account()` for Charlie fails (e.g., account exists but `fail_on_recipient_account_existing=true`)
6. Function returns error via `?` operator
7. **Result:** Alice lost 600, Bob gained 100, Charlie gained 200, but transaction marked as FAILED

The shared cache retains these partial modifications, violating atomic transaction semantics. During parallel execution [4](#0-3) , other transactions can observe this inconsistent state before the failure propagates.

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

This vulnerability breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." However, the impact is limited because:

1. **Scope Limited to Benchmarks:** This code exists in `executor-benchmark/`, used only for performance testing, not production execution
2. **No Production Impact:** The production Aptos blockchain uses `AptosVM` with proper transaction isolation (BlockSTM), not these native executors
3. **Benchmark Corruption:** In benchmark scenarios, partial commits cause incorrect performance measurements and state corruption within the benchmark environment

While this represents a clear violation of atomicity, it does not affect production validator nodes, consensus, or real user funds.

## Likelihood Explanation

**Likelihood: High in benchmark contexts, Zero in production**

In benchmark execution scenarios using `NativeValueCacheParallelUncoordinated`, this issue occurs whenever:
- A `BatchTransfer` transaction contains multiple recipients
- Any deposit succeeds but a subsequent account check fails
- Parallel transactions are executing concurrently

However, this code path is never reached in production Aptos blockchain execution, making the real-world likelihood zero.

## Recommendation

For benchmark code correctness, implement transaction-local state accumulation with commit-on-success semantics:

```rust
// Add transaction-local cache overlay
struct TransactionContext {
    local_cache: HashMap<StateKey, CachedResource>,
    parent_cache: &DashMap<StateKey, CachedResource>,
}

impl TransactionContext {
    fn commit(&self) {
        // Only commit local changes to parent cache on transaction success
        for (key, value) in &self.local_cache {
            self.parent_cache.insert(key.clone(), value.clone());
        }
    }
}
```

Alternatively, since this is benchmark code and the standard `NativeRawTransactionExecutor` already has correct semantics, consider documenting the limitations or removing the cache-based executor if atomic semantics are required.

## Proof of Concept

```rust
#[test]
fn test_batch_transfer_partial_commit() {
    let executor = NativeValueCacheRawTransactionExecutor::new();
    let state_view = /* initialize with test state */;
    let block_state = executor.init_block_state(&state_view);
    
    // Create BatchTransfer: Alice -> [Bob (100), Charlie (200)]
    // Charlie's account exists, fail_on_recipient_account_existing=true
    let txn = NativeTransaction::BatchTransfer {
        sender: alice_address(),
        sequence_number: 0,
        recipients: vec![bob_address(), charlie_address()],
        amounts: vec![100, 200],
        fail_on_recipient_account_existing: true,  // Will fail for Charlie
        fail_on_recipient_account_missing: false,
    };
    
    // Execute transaction - should fail
    let result = executor.execute_transaction(txn, &state_view, &block_state);
    assert!(result.is_err());
    
    // BUG: Cache still contains partial deposits
    // Bob received 100, Charlie received 200, Alice lost 300
    // But transaction failed - state is inconsistent!
}
```

---

## Notes

**Critical Clarification:** This vulnerability exists only in benchmark/testing code (`executor-benchmark/`) and does NOT affect the production Aptos blockchain. The production execution engine uses `AptosVM` with proper transaction isolation via BlockSTM, which maintains atomic transaction semantics. This issue represents a limitation of the benchmark executor implementation that should be documented or corrected for benchmark accuracy, but poses no security risk to the production network.

### Citations

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L109-121)
```rust
        let transaction_outputs = NATIVE_EXECUTOR_POOL
            .install(|| {
                native_transactions
                    .into_par_iter()
                    .map(|txn| self.executor.execute_transaction(txn, state_view, &state))
                    .collect::<Result<Vec<_>>>()
            })
            .map_err(|e| {
                VMStatus::error(
                    StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                    Some(format!("{:?}", e).to_string()),
                )
            })?;
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L388-430)
```rust
            NativeTransaction::BatchTransfer {
                sender,
                sequence_number,
                recipients,
                amounts,
                fail_on_recipient_account_existing,
                fail_on_recipient_account_missing,
            } => {
                self.update_sequence_number(sender, sequence_number, state_view, &mut output)?;

                let (deltas, amount_to_sender) =
                    compute_deltas_for_batch(recipients, amounts, sender);

                self.withdraw_apt_from_signer(
                    fa_migration_complete,
                    sender,
                    amount_to_sender,
                    gas,
                    state_view,
                    &mut output,
                )?;

                for (recipient_address, transfer_amount) in deltas.into_iter() {
                    let existed = self.deposit_apt(
                        fa_migration_complete,
                        recipient_address,
                        transfer_amount as u64,
                        state_view,
                        &mut output,
                    )?;

                    if !existed || fail_on_recipient_account_existing {
                        self.check_or_create_account(
                            recipient_address,
                            fail_on_recipient_account_existing,
                            fail_on_recipient_account_missing,
                            true,
                            state_view,
                            &mut output,
                        )?;
                    }
                }
            },
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L797-810)
```rust
pub struct NativeValueCacheRawTransactionExecutor {
    db_util: DbAccessUtil,
    cache: DashMap<StateKey, CachedResource>,
    coin_supply_state_key: OnceCell<StateKey>,
}

impl CommonNativeRawTransactionExecutor for NativeValueCacheRawTransactionExecutor {
    fn new_impl() -> Self {
        Self {
            db_util: DbAccessUtil::new(),
            cache: DashMap::new(),
            coin_supply_state_key: OnceCell::new(),
        }
    }
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L1074-1112)
```rust
    fn update_fa_balance(
        &self,
        account: AccountAddress,
        state_view: &(impl StateView + Sync),
        increment: u64,
        decrement: u64,
        fail_on_missing: bool,
    ) -> bool {
        let store_address = primary_apt_store(account);
        let fungible_store_rg_tag = &self.db_util.common.fungible_store;
        let cache_key = StateKey::resource(&store_address, fungible_store_rg_tag).unwrap();

        let mut exists = true;
        let mut entry = self.cache.entry(cache_key).or_insert_with(|| {
            let fa_store_object_key = self
                .db_util
                .new_state_key_object_resource_group(&store_address);
            let rg_opt =
                DbAccessUtil::get_resource_group(&fa_store_object_key, state_view).unwrap();
            CachedResource::FungibleStore(match rg_opt {
                Some(mut rg) => {
                    bcs::from_bytes(&rg.remove(fungible_store_rg_tag).unwrap()).unwrap()
                },
                None => {
                    exists = false;
                    assert!(!fail_on_missing);
                    FungibleStoreResource::new(AccountAddress::TEN, 0, false)
                },
            })
        });
        match entry.value_mut() {
            CachedResource::FungibleStore(fungible_store_resource) => {
                fungible_store_resource.balance += increment;
                fungible_store_resource.balance -= decrement;
            },
            _ => panic!("wrong type"),
        };
        exists
    }
```
