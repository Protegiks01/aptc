# Audit Report

## Title
Lack of Graceful Degradation in JWK Consensus During OIDC Provider Downtime Causes Keyless Transaction Authentication Failures

## Summary
When an OIDC provider experiences downtime, validators cannot fetch updated JWKs, causing on-chain JWKs to become stale. If the provider rotates keys during downtime, users with new JWT tokens cannot authenticate keyless transactions, resulting in a denial of service. Additionally, compromised keys remain valid on-chain until manual governance intervention occurs. The system lacks graceful degradation mechanisms such as fallback endpoints, cached JWK expiration, or multi-provider redundancy.

## Finding Description
The JWK observation mechanism in Aptos validators operates as follows:

1. **JWK Fetching**: The `JWKObserver` periodically fetches JWKs from OIDC providers via HTTP requests. [1](#0-0) 

2. **HTTP Client Configuration**: The `fetch_jwks_from_jwks_uri` function uses `reqwest::Client::new()` with default settings and no explicit timeout or retry configuration. [2](#0-1) 

3. **Silent Failure on Downtime**: When an OIDC provider is unreachable (downtime, network issues, DDoS), the fetch fails. The error is logged and metrics are recorded, but critically, **no observation is pushed to the consensus channel**. [3](#0-2) 

4. **Stale JWKs Persist**: Without new observations, the consensus process is not triggered. The `process_new_observation` function only starts consensus when observed JWKs differ from on-chain JWKs. [4](#0-3) 

5. **Transaction Validation Failure**: When keyless transactions are validated, the system looks up JWKs by issuer and key ID (kid) from on-chain storage. [5](#0-4)  If an OIDC provider rotates keys during downtime and a user obtains a new JWT with a new kid, the validation fails with "JWK for {issuer} with KID {kid} was not found". [6](#0-5) 

**No Graceful Degradation Exists:**
- No fallback OIDC endpoints or redundant providers
- No JWK expiration or freshness checking
- No automatic retry with exponential backoff
- No cached JWK versions with time-based validity
- No warning to users about potentially stale JWKs

The only recovery mechanism is manual governance intervention via `set_patches`, which requires proposal submission, voting, and executionâ€”a process that takes considerable time. [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: The JWK consensus protocol fails to handle realistic operational scenarios (OIDC provider downtime, maintenance windows, DDoS attacks) with any graceful degradation mechanism.

2. **Availability Impact**: Users cannot submit keyless transactions when OIDC providers rotate keys during downtime, creating a denial of service condition for an entire authentication method.

3. **Security Risk Window**: If an OIDC provider detects key compromise and rotates keys while experiencing downtime, the compromised keys remain valid on-chain until manual governance intervention, potentially allowing attackers to continue using stolen credentials.

4. **Validator Operational Issues**: Validators cannot properly authenticate keyless transactions, requiring manual governance oversight and intervention to restore functionality.

## Likelihood Explanation
This scenario is **highly likely** to occur:

1. **Common Operational Events**: OIDC providers regularly experience downtime for maintenance, infrastructure failures, or capacity issues. Major providers like Google and Apple have documented service outages.

2. **Security Best Practices**: Key rotation during or immediately after security incidents is standard practice. If rotation occurs during downtime, the vulnerability manifests.

3. **DDoS Attacks**: Attackers can deliberately cause OIDC provider downtime through DDoS attacks on the provider's endpoints, triggering this vulnerability intentionally.

4. **Network Partitioning**: Validators may have heterogeneous network connectivity. If only some validators can reach the OIDC provider, this creates consensus divergence risks.

## Recommendation
Implement comprehensive graceful degradation mechanisms:

1. **Multi-Endpoint Redundancy**: Configure multiple OIDC endpoints per provider with automatic failover:
```rust
// In jwk_observer.rs
struct OIDCProviderConfig {
    primary_url: String,
    fallback_urls: Vec<String>,
    current_endpoint_index: usize,
}

// Implement automatic failover in fetch_jwks
async fn fetch_jwks_with_fallback(config: &mut OIDCProviderConfig) -> Result<Vec<JWK>> {
    for (idx, url) in std::iter::once(&config.primary_url)
        .chain(config.fallback_urls.iter())
        .enumerate() 
    {
        match fetch_jwks(url, None).await {
            Ok(jwks) => return Ok(jwks),
            Err(e) => {
                warn!("Endpoint {} failed: {}, trying next", url, e);
                continue;
            }
        }
    }
    Err(anyhow!("All OIDC endpoints failed"))
}
```

2. **JWK Freshness Tracking**: Add timestamp-based expiration to on-chain JWKs:
```move
struct ProviderJWKs has copy, drop, store {
    issuer: vector<u8>,
    version: u64,
    jwks: vector<JWK>,
    last_updated_timestamp_secs: u64,  // Add this
    max_age_secs: u64,                   // Add this
}
```

3. **Exponential Backoff with Alerts**: Implement retry logic with increasing intervals and alerting after repeated failures.

4. **HTTP Client Timeout**: Configure explicit timeouts in the HTTP client:
```rust
// In lib.rs
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))  // Add explicit timeout
        .build()?;
    // ... rest of the implementation
}
```

5. **Stale JWK Warnings**: Emit events when JWKs become stale to alert users and operators.

## Proof of Concept
```rust
// Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_oidc_downtime_causes_keyless_auth_failure() {
    // 1. Setup: Start validator with OIDC provider mock
    let mut oidc_mock_server = start_mock_oidc_server();
    let initial_jwk = create_test_jwk("kid_v1", "rsa_key_v1");
    oidc_mock_server.set_jwks(vec![initial_jwk.clone()]);
    
    // 2. Wait for validators to observe and reach consensus on initial JWK
    wait_for_jwk_consensus(&initial_jwk).await;
    
    // 3. User creates keyless transaction with kid_v1 - should succeed
    let tx1 = create_keyless_transaction("kid_v1");
    assert!(validate_transaction(tx1).is_ok());
    
    // 4. Simulate OIDC provider downtime
    oidc_mock_server.go_offline();
    
    // 5. Provider rotates keys during downtime (security incident response)
    let new_jwk = create_test_jwk("kid_v2", "rsa_key_v2");
    oidc_mock_server.set_jwks(vec![new_jwk.clone()]); // Still offline
    
    // 6. User obtains new JWT with kid_v2 from the offline provider
    // (via cached response or eventual consistency)
    let tx2 = create_keyless_transaction("kid_v2");
    
    // 7. Transaction validation FAILS because validators have stale JWKs
    assert!(matches!(
        validate_transaction(tx2),
        Err(VMStatus { status_code: StatusCode::INVALID_SIGNATURE, .. })
    ));
    
    // 8. Verify error message indicates missing JWK
    // Error: "JWK for {issuer} with KID kid_v2 was not found"
    
    // 9. Demonstrate that even after provider comes back online,
    // there's a delay until next observation interval
    oidc_mock_server.go_online();
    std::thread::sleep(Duration::from_secs(11)); // Wait for next observation
    
    // 10. Now transaction with kid_v2 succeeds
    let tx3 = create_keyless_transaction("kid_v2");
    assert!(validate_transaction(tx3).is_ok());
}
```

**Notes:**
- The vulnerability manifests whenever OIDC providers experience downtime coinciding with key rotation
- No graceful degradation mechanism exists; only manual governance intervention can update JWKs during provider outages
- Validators continue attempting to fetch JWKs at regular intervals but silently fail without alerting users
- The delay between provider recovery and JWK update creates an availability gap for keyless transactions with new keys

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L72-84)
```rust
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L196-225)
```rust
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L121-126)
```rust
    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-237)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;

    let training_wheels_pk = match &config.training_wheels_pubkey {
        None => None,
        // This takes ~4.4 microseconds, so we are not too concerned about speed here.
        // (Run `cargo bench -- ed25519/pk_deserialize` in `crates/aptos-crypto`.)
        Some(bytes) => Some(EphemeralPublicKey::ed25519(
            Ed25519PublicKey::try_from(bytes.as_slice()).map_err(|_| {
                // println!("[aptos-vm][groth16] On chain TW PK is invalid");

                invalid_signature!("The training wheels PK set on chain is not a valid PK")
            })?,
        )),
    };

    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L378-383)
```text
    /// Set the `Patches`. Only called in governance proposals.
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```
