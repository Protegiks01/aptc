# Audit Report

## Title
Storage Error Messages Expose Internal Database State to API Clients

## Summary
Storage errors from `AptosDbError` are propagated to REST API clients with detailed internal information including specific version numbers, pruning boundaries, and database configuration details. This enables attackers to fingerprint validator storage configurations and map out pruning policies through systematic probing.

## Finding Description

The Aptos REST API exposes detailed storage error messages that reveal internal database state. When storage operations fail, the error chain is preserved and returned to API clients with full context.

**Error Exposure Mechanism:** [1](#0-0) [2](#0-1) 

The `format!("{:#}", error)` formatter includes the complete error chain with context. Storage errors propagate through:

1. **Storage Layer**: Returns `AptosDbError` with specific details
2. **API Layer**: Wraps with `.context()` adding descriptive messages  
3. **Response Formatting**: Converts to `AptosError` preserving full error text
4. **JSON Response**: Sends complete error message to client

**Specific Information Leaked:** [3](#0-2) [4](#0-3) [5](#0-4) 

These errors expose:
- Exact version numbers where state roots are missing ("Missing state root node at version X, probably pruned")
- Minimum readable versions for different data types
- Pruning boundaries for state KV, state merkle, and epoch snapshots
- Database operational limits
- Whether data was pruned vs never existed

**Attack Scenario:**

An attacker can systematically probe the API with requests at different versions: [6](#0-5) 

By analyzing error responses, attackers can:
1. Map the complete pruning window across different data stores
2. Identify validators using aggressive vs conservative pruning policies
3. Profile database configurations (sharding, limits, snapshot policies)
4. Distinguish between different node implementations
5. Plan targeted attacks on specific version ranges known to be pruned

## Impact Explanation

This is classified as **Low Severity** information disclosure per the Aptos bug bounty program:

- **No funds loss**: Information disclosure alone cannot steal or mint funds
- **No consensus violation**: Does not affect consensus safety or liveness
- **No availability impact**: Does not cause crashes or performance degradation
- **Enables reconnaissance**: Allows fingerprinting and profiling of validator configurations

While the question categorizes this as "Medium" severity, the actual impact aligns with **Low Severity** ($1,000): "Minor information leaks" and "Non-critical implementation bugs."

The disclosed information is partially redundant with already-public data (oldest_ledger_version exposed in response headers), and upstream validation prevents many error cases from reaching clients. [7](#0-6) 

## Likelihood Explanation

**High likelihood** - This occurs on every storage error:
- No special permissions required
- Triggered by any API request for pruned/missing data
- Automatic propagation through error handling chain
- Affects all public REST API endpoints

## Recommendation

Sanitize storage error messages before exposing to API clients. Replace internal details with generic error messages:

```rust
// In api/src/state.rs or similar API handlers
.map_err(|err| {
    // Log detailed error internally for debugging
    error!("Storage error: {:#}", err);
    
    // Return sanitized message to client
    BasicErrorWith404::internal_with_code(
        "Failed to retrieve data from storage",
        AptosErrorCode::InternalError,
        &ledger_info,
    )
})
```

For pruned data specifically, use the existing upstream validation to return clean error codes without exposing min_readable_version values.

## Proof of Concept

```bash
# Query a pruned version to observe detailed error message
curl -X GET "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0x1/resource/0x1::account::Account?ledger_version=1" \
  -H "Accept: application/json"

# Expected sanitized response:
# {"message": "Ledger version(1) has been pruned", "error_code": "version_pruned"}

# Current response potentially includes:
# {"message": "Failed to query DB...: StateValue at version 1 is pruned, min available version is 495821847", "error_code": "internal_error"}

# Systematic probing to map pruning boundaries:
for v in $(seq 1 1000000 100000000); do
  curl -s "https://node/v1/accounts/0x1/resource/0x1::account::Account?ledger_version=$v" | jq '.message'
done
```

## Notes

While storage errors do expose internal state information as claimed in the security question, this represents **Low severity information disclosure** rather than Medium severity. The disclosed information:
- Does not directly enable funds theft, consensus attacks, or availability disruption
- Is partially redundant with public information in response headers
- Has limited exploitability beyond reconnaissance
- Follows common API patterns of providing actionable error details

The vulnerability is valid but the severity classification in the question appears overstated based on Aptos bug bounty criteria.

### Citations

**File:** storage/storage-interface/src/errors.rs (L13-19)
```rust
    #[error("{0} not found.")]
    NotFound(String),
    /// Requested too many items.
    #[error("Too many items requested: at least {0} requested, max is {1}")]
    TooManyRequested(u64, u64),
    #[error("Missing state root node at version {0}, probably pruned.")]
    MissingRootError(u64),
```

**File:** api/types/src/error.rs (L28-38)
```rust
impl AptosError {
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-302)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/jellyfish-merkle/src/lib.rs (L732-741)
```rust
            let next_node = self
                .reader
                .get_node_with_tag(&next_node_key, "get_proof")
                .map_err(|err| {
                    if nibble_depth == 0 {
                        AptosDbError::MissingRootError(version)
                    } else {
                        err
                    }
                })?;
```

**File:** api/src/state.rs (L289-303)
```rust
        let bytes = state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .find_resource(&state_view, address, &tag)
            .context(format!(
                "Failed to query DB to check for {} at {}",
                tag.to_canonical_string(),
                address
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
```

**File:** api/src/context.rs (L309-314)
```rust
        } else if requested_ledger_version < latest_ledger_info.oldest_ledger_version.0 {
            return Err(version_pruned(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        }
```
