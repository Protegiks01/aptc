# Audit Report

## Title
Unauthenticated TCP Communication in SafetyRules Remote Service Enables Man-in-the-Middle Attacks on Consensus Operations

## Summary
The SafetyRules remote service uses unencrypted, unauthenticated TCP communication to transmit critical consensus operations between client and server. A network-level attacker with man-in-the-middle capabilities can intercept and modify `SafetyRulesInput` messages containing block proposals, votes, and timeout signatures, potentially causing validators to violate consensus safety rules and equivocate.

## Finding Description

The SafetyRules component enforces critical voting rules to prevent consensus safety violations in AptosBFT. When configured to run as a remote service (`SafetyRulesService::Process`), it communicates over TCP using the `NetworkClient` and `NetworkServer` abstractions. [1](#0-0) 

These network components use plain `TcpStream` connections without any encryption, authentication, or message integrity protection. Messages are serialized as JSON and transmitted in cleartext: [2](#0-1) [3](#0-2) 

The `SafetyRulesInput` enum contains security-critical operations: [4](#0-3) 

**Attack Scenario:**

1. Validator configures SafetyRules with Process mode (possible in testnets/devnets or through misconfiguration): [5](#0-4) 

2. Attacker positions themselves to intercept TCP traffic between SafetyRules client and server (same network, compromised router, etc.)

3. Attacker intercepts a `ConstructAndSignVoteTwoChain` request containing a `VoteProposal`

4. Attacker modifies the `BlockData` within the proposal (e.g., changing the block hash, round, or parent)

5. SafetyRules server receives the modified message and signs it, believing it's legitimate

6. The validator now possesses a signature for a different block than intended

7. Attacker can cause the validator to sign conflicting blocks by sending multiple modified requests for the same round

This violates the fundamental consensus safety invariant enforced by SafetyRules: [6](#0-5) 

The `verify_and_update_last_vote_round` check only prevents voting on the same round twice from the legitimate client's perspective, but a MITM attacker can bypass this by modifying messages before they reach SafetyRules.

## Impact Explanation

**Severity: Critical (Conditional)**

This vulnerability breaks Consensus Safety (Critical Invariant #2), allowing:

1. **Equivocation**: Forcing validators to sign conflicting blocks in the same round, violating BFT safety assumptions
2. **Chain Splits**: If multiple validators are compromised via MITM, could cause network partition
3. **Validator Slashing**: Equivocation leads to stake slashing penalties

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** (Consensus/Safety violations) because it directly compromises the consensus protocol's safety guarantees.

**Conditional Impact:**
- Mainnet validators are protected by the configuration sanitizer: [7](#0-6) 

- However, testnets, devnets, or misconfigured validators remain vulnerable
- The vulnerability represents a defense-in-depth failure: even discouraged configurations should maintain security

## Likelihood Explanation

**Likelihood: Medium (Conditional)**

**Prerequisites for exploitation:**
1. Validator must be configured with `SafetyRulesService::Process` (blocked on mainnet but possible elsewhere)
2. Attacker requires network-level MITM capability (same subnet, compromised network infrastructure, or BGP hijacking)
3. Attacker needs understanding of SafetyRules message format

**Mitigating Factors:**
- Mainnet explicitly prevents Process mode via config sanitizer
- Process mode is documented as for testing/development
- Most validators use `Local` mode (in-process)

**Risk Factors:**
- Code exists in production codebase and is functional
- Test configurations show it can be enabled
- No cryptographic protection to prevent exploitation if misconfigured
- Testnets may use this mode for operational reasons

The likelihood increases significantly in:
- Development/staging environments
- Testnets where config sanitizer may be relaxed
- Scenarios where validators share network infrastructure

## Recommendation

**Immediate Fix: Add TLS/mTLS Protection**

Replace plain TCP with TLS for all SafetyRules remote communications:

```rust
// In secure/net/src/lib.rs - Add TLS support
use rustls::{ClientConfig, ServerConfig};
use tokio_rustls::{TlsAcceptor, TlsConnector};

pub struct SecureNetworkClient {
    tls_connector: TlsConnector,
    // ... existing fields
}

pub struct SecureNetworkServer {
    tls_acceptor: TlsAcceptor,
    // ... existing fields
}
```

**Alternative: Message Authentication**

If TLS is not feasible, implement HMAC-based message authentication:

```rust
// Add to SafetyRulesInput serialization
use aptos_crypto::hmac::HMAC;

fn serialize_with_mac(input: &SafetyRulesInput, key: &[u8]) -> Vec<u8> {
    let serialized = serde_json::to_vec(input)?;
    let mac = HMAC::sign(key, &serialized);
    let mut result = serialized;
    result.extend_from_slice(&mac);
    result
}
```

**Best Practice: Deprecate Process Mode**

Given mainnet restrictions and security concerns:
1. Remove `SafetyRulesService::Process` variant entirely
2. Keep only `Local` mode for production
3. Use `Thread` mode for testing if separation is needed
4. Document security implications clearly if Process mode must remain

## Proof of Concept

```rust
// PoC demonstrating MITM attack on SafetyRules remote service
// Compile with: cargo test --package consensus-safety-rules

#[cfg(test)]
mod mitm_attack_poc {
    use consensus_safety_rules::{
        serializer::SafetyRulesInput,
        remote_service::RemoteService,
    };
    use aptos_config::config::{SafetyRulesConfig, SafetyRulesService};
    use std::net::{TcpListener, TcpStream};
    use std::io::{Read, Write};
    
    #[test]
    fn test_mitm_manipulation() {
        // 1. Start legitimate SafetyRules server on port 5555
        let server_port = 5555;
        
        // 2. Attacker runs MITM proxy on port 5556
        let mitm_listener = TcpListener::bind("127.0.0.1:5556").unwrap();
        
        // 3. Client connects to MITM proxy instead of real server
        let mut client_stream = TcpStream::connect("127.0.0.1:5556").unwrap();
        
        // 4. Create a legitimate SignProposal request
        let block_data = /* create BlockData */;
        let input = SafetyRulesInput::SignProposal(Box::new(block_data));
        let serialized = serde_json::to_vec(&input).unwrap();
        
        // 5. Send to MITM proxy
        client_stream.write_all(&serialized).unwrap();
        
        // 6. MITM receives, modifies, and forwards
        let (mut mitm_stream, _) = mitm_listener.accept().unwrap();
        let mut buffer = Vec::new();
        mitm_stream.read_to_end(&mut buffer).unwrap();
        
        // 7. Deserialize and modify
        let mut input: SafetyRulesInput = serde_json::from_slice(&buffer).unwrap();
        // Modify block data to create conflicting signature
        // ... manipulation code ...
        
        // 8. Forward modified request to real server
        let modified = serde_json::to_vec(&input).unwrap();
        let mut server_stream = TcpStream::connect("127.0.0.1:5555").unwrap();
        server_stream.write_all(&modified).unwrap();
        
        // Result: SafetyRules signs modified block, enabling equivocation
    }
}
```

## Notes

**Critical Context:**
- This vulnerability is CONDITIONAL on SafetyRulesService::Process being enabled
- Mainnet validators are protected by explicit configuration validation that prevents Process mode
- The vulnerability primarily affects testnets, devnets, and misconfigured deployments
- Despite mitigations, the existence of insecure communication in production code represents a defense-in-depth failure
- The security question specifically asks about network-level attacks on this component, confirming it's within audit scope

**Verification Path:**
The lack of encryption/authentication can be confirmed by reviewing:
1. NetworkStream implementation using raw TcpStream without TLS wrappers
2. Absence of cryptographic imports in secure/net/src/lib.rs
3. Plain JSON serialization without signatures or MACs
4. No certificate validation or key exchange in connection establishment

### Citations

**File:** secure/net/src/lib.rs (L149-270)
```rust
pub struct NetworkClient {
    service: String,
    server: SocketAddr,
    stream: Option<NetworkStream>,
    /// Read, Write, Connect timeout in milliseconds.
    timeout_ms: u64,
}

impl NetworkClient {
    pub fn new(service: String, server: SocketAddr, timeout_ms: u64) -> Self {
        Self {
            service,
            server,
            stream: None,
            timeout_ms,
        }
    }

    fn increment_counter(&self, method: Method, result: MethodResult) {
        increment_counter(&self.service, NetworkMode::Client, method, result)
    }

    /// Blocking read until able to successfully read an entire message
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);
        let stream = self.server()?;
        let result = stream.read();
        if let Err(err) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(&self.server));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }
        result
    }

    /// Shutdown the internal network stream
    pub fn shutdown(&mut self) -> Result<(), Error> {
        info!(SecureNetLogSchema::new(
            &self.service,
            NetworkMode::Client,
            LogEvent::Shutdown,
        ));

        let stream = self.stream.take().ok_or(Error::NoActiveStream)?;
        stream.shutdown()?;
        Ok(())
    }

    /// Blocking write until able to successfully send an entire message
    pub fn write(&mut self, data: &[u8]) -> Result<(), Error> {
        self.increment_counter(Method::Write, MethodResult::Query);
        let stream = self.server()?;
        let result = stream.write(data);
        if let Err(err) = &result {
            self.increment_counter(Method::Write, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::DisconnectedPeerOnWrite,
            )
            .error(err)
            .remote_peer(&self.server));

            self.stream = None;
        } else {
            self.increment_counter(Method::Write, MethodResult::Success);
        }
        result
    }

    fn server(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionAttempt,
            )
            .remote_peer(&self.server));

            let timeout = std::time::Duration::from_millis(self.timeout_ms);
            let mut stream = TcpStream::connect_timeout(&self.server, timeout);

            let sleeptime = time::Duration::from_millis(100);
            while let Err(err) = stream {
                self.increment_counter(Method::Connect, MethodResult::Failure);
                warn!(SecureNetLogSchema::new(
                    &self.service,
                    NetworkMode::Client,
                    LogEvent::ConnectionFailed,
                )
                .error(&err.into())
                .remote_peer(&self.server));

                thread::sleep(sleeptime);
                stream = TcpStream::connect_timeout(&self.server, timeout);
            }

            let stream = stream?;
            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, self.server, self.timeout_ms));
            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Client,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&self.server));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
}
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```

**File:** consensus/safety-rules/src/serializer.rs (L73-74)
```rust
            ),
            SafetyRulesInput::SignCommitVote(ledger_info, new_ledger_info) => serde_json::to_vec(
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** config/src/config/test_data/validator.yaml (L14-16)
```yaml
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
