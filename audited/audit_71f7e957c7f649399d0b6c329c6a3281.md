# Audit Report

## Title
Critical Validator Set Depletion via Governance - Missing Boundary Check Causes Network Halt

## Summary
The `remove_validators` function in the staking module lacks the boundary condition check present in `leave_validator_set`, allowing governance to remove all active validators, resulting in an empty ValidatorSet that causes complete network liveness failure requiring a hard fork to recover.

## Finding Description

The vulnerability exists in two critical code paths that can lead to an empty active validator set:

**Path 1: Direct Governance Attack via `remove_validators`**

The `stake::remove_validators` function allows governance to remove validators from the active set without checking if this would leave the set empty: [1](#0-0) 

This function iterates through validators and moves them from `active_validators` to `pending_inactive` without any check preventing the set from becoming empty. In contrast, `leave_validator_set` has an explicit protection: [2](#0-1) 

**Path 2: Indirect Attack via Minimum Stake Manipulation**

During epoch transitions in `on_new_epoch`, validators are filtered based on minimum stake requirements. If all validators fall below the threshold, `next_epoch_validators` remains empty: [3](#0-2) 

The `staking_config::update_required_stake` function validates only that `minimum_stake <= maximum_stake`, not that any current validator meets the new minimum: [4](#0-3) 

**Impact Chain:**

1. Empty ValidatorSet is committed to on-chain configuration through reconfiguration: [5](#0-4) 

2. Network discovery layer receives empty ValidatorSet and returns empty PeerSet: [6](#0-5) 

3. Consensus EpochManager creates ValidatorVerifier with empty validator list: [7](#0-6) 

4. ValidatorVerifier initialization with empty list sets quorum_voting_power = 0: [8](#0-7) 

5. Multiple panic points in consensus:
   - `choose_leader` panics with "No trusted peers found!": [9](#0-8) 

   - `RotatingProposer::get_valid_proposer` causes division by zero (% 0): [10](#0-9) 

**Formal Specification Violation:**

The formal specification explicitly requires `len(active_validators) > 0` as an invariant: [11](#0-10) 

However, this invariant is not enforced at runtime in `remove_validators`, only in `leave_validator_set`.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program based on:

1. **Total loss of liveness/network availability**: With zero validators, no blocks can be proposed or validated. The consensus layer panics during proposer election, preventing any progress.

2. **Non-recoverable network partition (requires hardfork)**: Recovery requires either:
   - Hard fork to directly modify ValidatorSet on-chain state
   - Emergency protocol upgrade to add validators back
   - Manual state restoration from backup

3. **Consensus Safety violation**: The network cannot maintain consensus guarantees with an empty validator set, violating the fundamental AptosBFT safety properties.

The impact affects all network participants:
- Validators cannot propose or validate blocks
- Users cannot submit transactions
- Applications cannot read updated state
- The entire network is effectively frozen

## Likelihood Explanation

The likelihood is **Medium to High** for the following reasons:

**Factors increasing likelihood:**
1. **Legitimate governance mechanism**: Both attack paths use intended governance functions (`remove_validators`, `update_required_stake`)
2. **No technical barriers**: Exploitation requires only a successful governance proposal
3. **Potential accident scenarios**: Could occur unintentionally if:
   - Governance mistakenly removes too many validators
   - Minimum stake is raised without verifying current validator stakes
   - Mass validator slashing combined with minimum stake increase

**Factors decreasing likelihood:**
1. **Governance oversight**: Proposals undergo community review before execution
2. **Multi-step process**: Requires proposal creation, voting period, and execution
3. **Observable**: The validator count decrease would be visible on-chain before becoming critical

**Realistic attack scenarios:**
1. Compromised governance proposal during emergency situations
2. Coordinated attack by malicious governance majority
3. Accidental misconfiguration during protocol upgrades
4. Mass validator slashing event combined with minimum stake policy changes

## Recommendation

Implement the same boundary condition check in `remove_validators` that exists in `leave_validator_set`:

```move
public fun remove_validators(
    aptos_framework: &signer,
    validators: &vector<address>,
) acquires ValidatorSet {
    assert_reconfig_not_in_progress();
    system_addresses::assert_aptos_framework(aptos_framework);
    let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
    let active_validators = &mut validator_set.active_validators;
    let pending_inactive = &mut validator_set.pending_inactive;
    
    let len_validators = vector::length(validators);
    let i = 0;
    while (i < len_validators) {
        let validator = *vector::borrow(validators, i);
        let validator_index = find_validator(active_validators, validator);
        if (option::is_some(&validator_index)) {
            let validator_info = vector::swap_remove(active_validators, *option::borrow(&validator_index));
            
            // ADD THIS CHECK - Prevent emptying the validator set
            assert!(
                vector::length(active_validators) > 0, 
                error::invalid_state(ELAST_VALIDATOR)
            );
            
            vector::push_back(pending_inactive, validator_info);
        };
        i = i + 1;
    };
}
```

Additionally, add a check in `on_new_epoch` to ensure at least one validator remains after filtering:

```move
// After line 1399 in on_new_epoch
validator_set.active_validators = next_epoch_validators;

// ADD THIS CHECK
assert!(
    vector::length(&validator_set.active_validators) > 0,
    error::invalid_state(ELAST_VALIDATOR)
);
```

For the minimum stake path, add validation in `update_required_stake`:

```move
public fun update_required_stake(
    aptos_framework: &signer,
    minimum_stake: u64,
    maximum_stake: u64,
) acquires StakingConfig {
    system_addresses::assert_aptos_framework(aptos_framework);
    validate_required_stake(minimum_stake, maximum_stake);
    
    // ADD THIS CHECK - Ensure at least one validator meets new minimum
    let validator_set = borrow_global<stake::ValidatorSet>(@aptos_framework);
    let meets_minimum = false;
    let i = 0;
    while (i < vector::length(&validator_set.active_validators)) {
        let validator = vector::borrow(&validator_set.active_validators, i);
        let stake_pool = borrow_global<stake::StakePool>(validator.addr);
        let voting_power = stake::get_next_epoch_voting_power(stake_pool);
        if (voting_power >= minimum_stake) {
            meets_minimum = true;
            break
        };
        i = i + 1;
    };
    assert!(meets_minimum, error::invalid_argument(EINVALID_STAKE_RANGE));
    
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.minimum_stake = minimum_stake;
    staking_config.maximum_stake = maximum_stake;
}
```

## Proof of Concept

**PoC 1: Direct Governance Attack**

```move
#[test(aptos_framework = @aptos_framework, validator1 = @0x123, validator2 = @0x456)]
#[expected_failure(abort_code = 6, location = aptos_framework::stake)] // ELAST_VALIDATOR
public entry fun test_remove_all_validators_should_fail(
    aptos_framework: &signer,
    validator1: &signer,
    validator2: &signer,
) {
    // Setup: Initialize with 2 validators
    setup_validators(aptos_framework, validator1, validator2);
    
    // Attack: Try to remove all validators via governance
    let validators_to_remove = vector[@0x123, @0x456];
    stake::remove_validators(aptos_framework, &validators_to_remove);
    
    // Expected: Should abort with ELAST_VALIDATOR but currently doesn't
    // Actual: active_validators becomes empty, causing network halt
}
```

**PoC 2: Minimum Stake Attack**

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
#[expected_failure(abort_code = 3, location = aptos_framework::staking_config)] // EINVALID_STAKE_RANGE
public entry fun test_excessive_minimum_stake_should_fail(
    aptos_framework: &signer,
    validator: &signer,
) {
    // Setup: Initialize validator with 1,000,000 stake
    setup_validator_with_stake(aptos_framework, validator, 1000000);
    
    // Attack: Set minimum stake higher than any validator's stake
    staking_config::update_required_stake(
        aptos_framework,
        10000000, // 10x current validator stake
        20000000
    );
    
    // Trigger epoch change
    stake::on_new_epoch();
    
    // Expected: Should abort but currently doesn't
    // Actual: All validators filtered out, active_validators becomes empty
}
```

**Expected Runtime Behavior (demonstrating the panic):**

When the empty ValidatorSet propagates to consensus:

```rust
// In rotating_proposer_election.rs
let proposers = vec![]; // Empty from empty ValidatorSet
let proposer = choose_leader(proposers);
// Panic: "thread 'main' panicked at 'No trusted peers found!'"

// In RotatingProposer::get_valid_proposer
self.proposers[((round / u64::from(self.contiguous_rounds)) % 0) as usize]
// Panic: "attempt to calculate the remainder with a divisor of zero"
```

This demonstrates the complete liveness failure caused by the empty validator set, requiring a hard fork to recover network functionality.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L543-582)
```text
    public fun remove_validators(
        aptos_framework: &signer,
        validators: &vector<address>,
    ) acquires ValidatorSet {
        assert_reconfig_not_in_progress();
        system_addresses::assert_aptos_framework(aptos_framework);
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let active_validators = &mut validator_set.active_validators;
        let pending_inactive = &mut validator_set.pending_inactive;
        spec {
            update ghost_active_num = len(active_validators);
            update ghost_pending_inactive_num = len(pending_inactive);
        };
        let len_validators = vector::length(validators);
        let i = 0;
        // Remove each validator from the validator set.
        while ({
            spec {
                invariant i <= len_validators;
                invariant spec_validators_are_initialized(active_validators);
                invariant spec_validator_indices_are_valid(active_validators);
                invariant spec_validators_are_initialized(pending_inactive);
                invariant spec_validator_indices_are_valid(pending_inactive);
                invariant ghost_active_num + ghost_pending_inactive_num == len(active_validators) + len(pending_inactive);
            };
            i < len_validators
        }) {
            let validator = *vector::borrow(validators, i);
            let validator_index = find_validator(active_validators, validator);
            if (option::is_some(&validator_index)) {
                let validator_info = vector::swap_remove(active_validators, *option::borrow(&validator_index));
                vector::push_back(pending_inactive, validator_info);
                spec {
                    update ghost_active_num = ghost_active_num - 1;
                    update ghost_pending_inactive_num = ghost_pending_inactive_num + 1;
                };
            };
            i = i + 1;
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1253-1255)
```text
            let validator_info = vector::swap_remove(
                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1401)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L133-134)
```text
        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** consensus/src/epoch_manager.rs (L1165-1168)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
```

**File:** types/src/validator_verifier.rs (L206-213)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L20-23)
```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L684-684)
```text
        invariant len(active_validators) > 0;
```
