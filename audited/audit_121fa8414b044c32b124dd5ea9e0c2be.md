# Audit Report

## Title
Fee Distribution Failure When EMIT_FEE_STATEMENT Feature is Disabled

## Summary
When the `EMIT_FEE_STATEMENT` or `MODULE_EVENT` feature flags are disabled, `try_extract_fee_statement()` returns `Ok(None)` for all valid transactions, causing `AfterMaterializationGuard::fee_statement()` to return `FeeStatement::zero()`. This results in zero fee distribution to validators in the block epilogue, even though transaction fees were successfully charged to users. Validators lose their rightful share of transaction fees while users are still charged.

## Finding Description

The vulnerability exists in the fee extraction and distribution mechanism across multiple components:

**Root Cause:** The `TransactionOutput` structure does not store the complete `FeeStatement` object—it only stores `gas_used` as a u64. [1](#0-0) 

When `VMOutput` is converted to `TransactionOutput`, only the gas_used value is preserved, not the full fee breakdown: [2](#0-1) 

**Fee Statement Emission:** Fee statements are only emitted as events when the feature flag is enabled: [3](#0-2) 

The feature check requires both MODULE_EVENT and EMIT_FEE_STATEMENT to be enabled: [4](#0-3) 

**Extraction Failure:** After materialization, the only way to retrieve the full `FeeStatement` is from events: [5](#0-4) 

If no fee statement event exists, this returns `Ok(None)`, causing the guard to return zero: [6](#0-5) 

**Impact on Fee Distribution:** The block epilogue generation uses the after-materialization fee statement to calculate validator rewards: [7](#0-6) 

With `FeeStatement::zero()`, the calculations for `total_gas_unit` and `storage_fee_used()` are zero, resulting in zero fee distribution to validators despite fees being burned from user accounts.

**Attack Path:**
1. Governance disables `EMIT_FEE_STATEMENT` or `MODULE_EVENT` feature flag (legitimately or accidentally)
2. Transactions execute normally, prologue/epilogue charge fees via `transaction_fee::burn_fee()`
3. No fee statement events are emitted during epilogue
4. Block epilogue generation extracts fee statements via `after_materialization()`
5. `try_extract_fee_statement()` returns `Ok(None)` (no event found)
6. `gen_block_epilogue` calculates zero fees to distribute
7. Validators receive no portion of transaction fees

## Impact Explanation

**Severity: HIGH** 

This vulnerability meets the High severity criteria for "Significant protocol violations" in the Aptos bug bounty program:

1. **Economic Loss:** Validators lose 100% of their rightful transaction fee share while users are still charged. On a high-throughput network, this could represent millions of dollars in lost validator revenue per day.

2. **Protocol Violation:** Breaks the core economic invariant that validators are compensated for including transactions in blocks. This undermines the incentive structure of the blockchain.

3. **Validator Security Invariant Broken:** The documented invariant "Staking Security: Validator rewards and penalties must be calculated correctly" is violated.

4. **Consensus Impact:** While not directly breaking consensus safety, the economic disincentive could affect validator participation and liveness over time.

The feature flags are not marked as "cannot be disabled" (unlike critical flags like `_REJECT_UNSTABLE_BYTECODE`), meaning this is a realistic scenario. [8](#0-7) 

## Likelihood Explanation

**Likelihood: MEDIUM**

While this requires governance action, it has moderate likelihood because:

1. **Legitimate Disabling:** Governance might disable the feature for performance optimization, debugging, or to fix a separate bug in event emission, without realizing the fee distribution dependency.

2. **Feature Flag Dependency:** The feature depends on TWO flags (`MODULE_EVENT` and `EMIT_FEE_STATEMENT`). If either is disabled for any reason, the issue manifests.

3. **No Safeguards:** There are no runtime checks or warnings when the feature is disabled that fee distribution will fail.

4. **Default Enabled:** While the features are enabled by default, they CAN be disabled post-deployment through standard governance mechanisms. [9](#0-8) 

## Recommendation

**Fix 1: Store Full FeeStatement in TransactionOutput**

Modify `TransactionOutput` to store the complete `FeeStatement` instead of just `gas_used`:

```rust
// In types/src/transaction/mod.rs
pub struct TransactionOutput {
    write_set: WriteSet,
    events: Vec<ContractEvent>,
    gas_used: u64,
    fee_statement: FeeStatement,  // Add this field
    status: TransactionStatus,
    auxiliary_data: TransactionAuxiliaryData,
}
```

Update `VMOutput::into_transaction_output()` to pass the full fee statement:

```rust
// In aptos-move/aptos-vm-types/src/output.rs
Ok(TransactionOutput::new(
    write_set,
    events,
    fee_statement.gas_used(),
    fee_statement,  // Pass full statement
    status,
    TransactionAuxiliaryData::default(),
))
```

**Fix 2: Fallback Mechanism in AfterMaterializationGuard**

If modifying TransactionOutput is not feasible, add a fallback that uses `gas_used` to reconstruct a minimal fee statement when events are missing:

```rust
// In aptos-move/aptos-vm/src/block_executor/mod.rs
fn fee_statement(&self) -> FeeStatement {
    if let Ok(Some(fee_statement)) = self.output.try_extract_fee_statement() {
        return fee_statement;
    }
    // Fallback: reconstruct from gas_used if available
    // This prevents total fee loss when feature is disabled
    FeeStatement::new(
        self.output.gas_used(),
        0, 0, 0, 0  // Conservative: all gas as execution gas
    )
}
```

**Fix 3: Make EMIT_FEE_STATEMENT Non-Disableable**

Mark the feature as critical and prevent disabling once enabled, similar to other critical features.

## Proof of Concept

```rust
#[cfg(test)]
mod test_fee_loss {
    use super::*;
    
    #[test]
    fn test_fee_distribution_fails_when_emit_fee_statement_disabled() {
        // Setup: Create a test environment with EMIT_FEE_STATEMENT disabled
        let mut features = Features::default();
        features.disable(FeatureFlag::EMIT_FEE_STATEMENT);
        
        // Execute a transaction that charges fees
        let gas_price = 100;
        let gas_used = 1000;
        let expected_fee = gas_price * gas_used;
        
        // Transaction executes successfully, fees are charged
        // ... transaction execution ...
        
        // After materialization, try to extract fee statement
        let output = /* get TransactionOutput */;
        let fee_statement = output.try_extract_fee_statement().unwrap();
        
        // BUG: fee_statement is None even though fees were charged
        assert!(fee_statement.is_none());
        
        // Generate block epilogue
        let fee_distribution = gen_block_epilogue(/* ... */);
        
        // BUG: Validators receive ZERO fees despite user being charged
        assert_eq!(fee_distribution.total_amount(), 0);
        
        // Expected: Validators should receive their share of expected_fee
        // Actual: Validators receive 0
    }
}
```

## Notes

This vulnerability demonstrates a critical architectural flaw where feature flag management has unintended economic consequences. The separation between fee charging (in epilogue) and fee statement emission (conditional on feature flag) creates a dependency that is not enforced at compile time or runtime. The recommended fix is to ensure the `FeeStatement` is always available for fee distribution regardless of event emission settings, as these are separate concerns—one for transaction accounting, the other for external observers.

### Citations

**File:** types/src/transaction/mod.rs (L1767-1783)
```rust
pub struct TransactionOutput {
    /// The list of writes this transaction intends to do.
    write_set: WriteSet,

    /// The list of events emitted during this transaction.
    events: Vec<ContractEvent>,

    /// The amount of gas used during execution.
    gas_used: u64,

    /// The execution status. The detailed error info will not be stored here instead will be stored in the auxiliary data.
    status: TransactionStatus,

    /// The transaction auxiliary data that includes detail error info that is not used for calculating the hash
    #[serde(skip)]
    auxiliary_data: TransactionAuxiliaryData,
}
```

**File:** types/src/transaction/mod.rs (L1930-1938)
```rust
    pub fn try_extract_fee_statement(&self) -> Result<Option<FeeStatement>> {
        // Look backwards since the fee statement is expected to be the last event.
        for event in self.events.iter().rev() {
            if let Some(fee_statement) = event.try_v2_typed(&FEE_STATEMENT_EVENT_TYPE)? {
                return Ok(Some(fee_statement));
            }
        }
        Ok(None)
    }
```

**File:** aptos-move/aptos-vm-types/src/output.rs (L191-219)
```rust
    pub fn into_transaction_output(self) -> Result<TransactionOutput, PanicError> {
        let Self {
            change_set,
            module_write_set,
            fee_statement,
            status,
            trace,
        } = self;

        // INVARIANT:
        //   When converting to transaction output, trace is either irrelevant or has already been
        //   extracted.
        if !trace.is_empty() {
            return Err(PanicError::CodeInvariantError(
                "Non-empty trace found when converting to transaction output".to_string(),
            ));
        }

        let (write_set, events) = change_set
            .try_combine_into_storage_change_set(module_write_set)?
            .into_inner();
        Ok(TransactionOutput::new(
            write_set,
            events,
            fee_statement.gas_used(),
            status,
            TransactionAuxiliaryData::default(),
        ))
    }
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L590-598)
```rust
    // Emit the FeeStatement event
    if features.is_emit_fee_statement_enabled() {
        emit_fee_statement(session, module_storage, fee_statement, traversal_context)?;
    }

    maybe_raise_injected_error(InjectedError::EndOfRunEpilogue)?;

    Ok(())
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L46-48)
```rust
    MODULE_EVENT = 26,
    EMIT_FEE_STATEMENT = 27,
    STORAGE_DELETION_REFUND = 28,
```

**File:** types/src/on_chain_config/aptos_features.rs (L171-277)
```rust
    pub fn default_features() -> Vec<Self> {
        vec![
            FeatureFlag::CODE_DEPENDENCY_CHECK,
            FeatureFlag::TREAT_FRIEND_AS_PRIVATE,
            FeatureFlag::SHA_512_AND_RIPEMD_160_NATIVES,
            FeatureFlag::APTOS_STD_CHAIN_ID_NATIVES,
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
            FeatureFlag::MULTI_ED25519_PK_VALIDATE_V2_NATIVES,
            FeatureFlag::BLAKE2B_256_NATIVE,
            FeatureFlag::RESOURCE_GROUPS,
            FeatureFlag::MULTISIG_ACCOUNTS,
            FeatureFlag::DELEGATION_POOLS,
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BLS12_381_STRUCTURES,
            FeatureFlag::ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH,
            FeatureFlag::STRUCT_CONSTRUCTORS,
            FeatureFlag::PERIODICAL_REWARD_RATE_DECREASE,
            FeatureFlag::PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::_SIGNATURE_CHECKER_V2,
            FeatureFlag::STORAGE_SLOT_METADATA,
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
            FeatureFlag::DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::APTOS_UNIQUE_IDENTIFIERS,
            FeatureFlag::GAS_PAYER_ENABLED,
            FeatureFlag::BULLETPROOFS_NATIVES,
            FeatureFlag::SIGNER_NATIVE_FORMAT_FIX,
            FeatureFlag::MODULE_EVENT,
            FeatureFlag::EMIT_FEE_STATEMENT,
            FeatureFlag::STORAGE_DELETION_REFUND,
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
            FeatureFlag::AGGREGATOR_V2_API,
            FeatureFlag::SAFER_RESOURCE_GROUPS,
            FeatureFlag::SAFER_METADATA,
            FeatureFlag::SINGLE_SENDER_AUTHENTICATOR,
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
            FeatureFlag::FEE_PAYER_ACCOUNT_OPTIONAL,
            FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS,
            FeatureFlag::CONCURRENT_TOKEN_V2,
            FeatureFlag::LIMIT_MAX_IDENTIFIER_LENGTH,
            FeatureFlag::OPERATOR_BENEFICIARY_CHANGE,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET,
            FeatureFlag::COMMISSION_CHANGE_DELEGATION_POOL,
            FeatureFlag::WEBAUTHN_SIGNATURE,
            FeatureFlag::KEYLESS_ACCOUNTS,
            FeatureFlag::FEDERATED_KEYLESS,
            FeatureFlag::KEYLESS_BUT_ZKLESS_ACCOUNTS,
            FeatureFlag::JWK_CONSENSUS,
            FeatureFlag::REFUNDABLE_BYTES,
            FeatureFlag::OBJECT_CODE_DEPLOYMENT,
            FeatureFlag::MAX_OBJECT_NESTING_CHECK,
            FeatureFlag::KEYLESS_ACCOUNTS_WITH_PASSKEYS,
            FeatureFlag::MULTISIG_V2_ENHANCEMENT,
            FeatureFlag::DELEGATION_POOL_ALLOWLISTING,
            FeatureFlag::MODULE_EVENT_MIGRATION,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE,
            FeatureFlag::TRANSACTION_CONTEXT_EXTENSION,
            FeatureFlag::COIN_TO_FUNGIBLE_ASSET_MIGRATION,
            FeatureFlag::_OBJECT_NATIVE_DERIVED_ADDRESS,
            FeatureFlag::DISPATCHABLE_FUNGIBLE_ASSET,
            FeatureFlag::NEW_ACCOUNTS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::OPERATIONS_DEFAULT_TO_FA_APT_STORE,
            FeatureFlag::CONCURRENT_FUNGIBLE_ASSETS,
            FeatureFlag::_AGGREGATOR_V2_IS_AT_LEAST_API,
            FeatureFlag::CONCURRENT_FUNGIBLE_BALANCE,
            FeatureFlag::_LIMIT_VM_TYPE_SIZE,
            FeatureFlag::ABORT_IF_MULTISIG_PAYLOAD_MISMATCH,
            FeatureFlag::_DISALLOW_USER_NATIVES,
            FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS,
            FeatureFlag::_USE_COMPATIBILITY_CHECKER_V2,
            FeatureFlag::ENABLE_ENUM_TYPES,
            FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL,
            FeatureFlag::_REJECT_UNSTABLE_BYTECODE_FOR_SCRIPT,
            FeatureFlag::TRANSACTION_SIMULATION_ENHANCEMENT,
            FeatureFlag::_NATIVE_MEMORY_OPERATIONS,
            FeatureFlag::_ENABLE_LOADER_V2,
            FeatureFlag::_DISALLOW_INIT_MODULE_TO_PUBLISH_MODULES,
            FeatureFlag::COLLECTION_OWNER,
            FeatureFlag::PERMISSIONED_SIGNER,
            FeatureFlag::ENABLE_CALL_TREE_AND_INSTRUCTION_VM_CACHE,
            FeatureFlag::ACCOUNT_ABSTRACTION,
            FeatureFlag::BULLETPROOFS_BATCH_NATIVES,
            FeatureFlag::DERIVABLE_ACCOUNT_ABSTRACTION,
            FeatureFlag::VM_BINARY_FORMAT_V8,
            FeatureFlag::ENABLE_FUNCTION_VALUES,
            FeatureFlag::NEW_ACCOUNTS_DEFAULT_TO_FA_STORE,
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
            FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE,
            FeatureFlag::TRANSACTION_PAYLOAD_V2,
            FeatureFlag::ORDERLESS_TRANSACTIONS,
            FeatureFlag::CALCULATE_TRANSACTION_FEE_FOR_DISTRIBUTION,
            FeatureFlag::DISTRIBUTE_TRANSACTION_FEE,
            FeatureFlag::ENABLE_LAZY_LOADING,
            FeatureFlag::MONOTONICALLY_INCREASING_COUNTER,
            FeatureFlag::ENABLE_CAPTURE_OPTION,
            FeatureFlag::ENABLE_TRUSTED_CODE,
            FeatureFlag::ENABLE_ENUM_OPTION,
            FeatureFlag::VM_BINARY_FORMAT_V9,
            FeatureFlag::ENABLE_FRAMEWORK_FOR_OPTION,
            FeatureFlag::ENABLE_FUNCTION_REFLECTION,
            FeatureFlag::VM_BINARY_FORMAT_V10,
            FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE,
        ]
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L372-375)
```rust
    pub fn is_emit_fee_statement_enabled(&self) -> bool {
        // requires module events
        self.is_module_event_enabled() && self.is_enabled(FeatureFlag::EMIT_FEE_STATEMENT)
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L106-111)
```rust
    fn fee_statement(&self) -> FeeStatement {
        if let Ok(Some(fee_statement)) = self.output.try_extract_fee_statement() {
            return fee_statement;
        }
        FeeStatement::zero()
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2042-2078)
```rust
        for (i, output) in outputs.enumerate().take(epilogue_txn_idx as usize) {
            // TODO(grao): Also include other transactions that is "Keep" if we are confident
            // that we successfully charge enough gas amount as it appears in the FeeStatement
            // for every corner cases.
            if !output.is_materialized_and_success() {
                continue;
            }
            let output_after_guard = output.after_materialization()?;
            let fee_statement = output_after_guard.fee_statement();

            let txn = signature_verified_block.get_txn(i as TxnIndex);
            if let Some(user_txn) = txn.try_as_signed_user_txn() {
                let auxiliary_info = signature_verified_block.get_auxiliary_info(i as TxnIndex);
                if let Some(proposer_index) = auxiliary_info.proposer_index() {
                    let gas_price = user_txn.gas_unit_price();
                    let total_gas_unit = fee_statement.gas_used();
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
                        }
                    }
                }
            }
        }
```
