# Audit Report

## Title
Lack of Layout Validation Enables Potential Consensus Split via Malformed MoveTypeLayout

## Summary
The `process_resource_output_v2()` function passes `maybe_layout` to `write_v2()` without validation. While layouts are typically generated by the Move VM's type system, the absence of defensive validation creates a critical gap where any malformed layout reaching this point would be stored in the versioned cache and cause deserialization failures when read by other validators, leading to deterministic execution divergence.

## Finding Description

The block executor's parallel execution path (BlockSTMv2) stores resource layouts without validation when processing transaction outputs. [1](#0-0) 

These layouts are stored directly in the MVHashMap's versioned cache as part of `ValueWithLayout::Exchanged`: [2](#0-1) 

The layout is defined with an optional type: [3](#0-2) 

When validators later read these values during transaction execution, the stored layout is used for deserialization to handle delayed fields (aggregators/snapshots): [4](#0-3) 

The deserialization process explicitly uses the layout structure: [5](#0-4) 

When deserialization fails, it returns `None` which triggers an error, marks the view as having "incorrect use", and returns a `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR`. This causes the reading validator to produce a different execution result than the validator that wrote the value.

Significantly, while fuzzer tests include layout validation logic: [6](#0-5) 

This validation is **never applied in production code**. The fuzzer identifies that empty structs and decorated layouts are invalid, but these checks are absent from the write path.

The push validation logic in BlockSTMv2 treats any layout presence pessimistically: [7](#0-6) 

This conservative approach suggests awareness that layout handling is complex and error-prone, yet no defensive validation exists at the write boundary.

**Attack Vector**: While layouts are typically generated from verified Move modules by the type-to-layout converter [8](#0-7) , any bug in:
- The Move bytecode verifier that allows malformed type structures
- The type-to-layout conversion logic
- Module loading/linking for complex generics or Move enums
- Feature interactions (delayed field optimization, variant types)

Would directly propagate to consensus divergence without any defensive barrier.

## Impact Explanation

This issue violates **Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

If a malformed layout is written by one validator and successfully stored, subsequent reads by other validators would fail deserialization, causing:

1. **Consensus Split**: Validators would produce different execution results for the same block
2. **Chain Halt**: The network would fail to achieve consensus on subsequent blocks
3. **State Divergence**: Validators would have inconsistent state, requiring hard fork to resolve

This qualifies as **Critical Severity** under the Aptos Bug Bounty Program as it enables "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)."

The impact is systemic - once a single malformed layout enters the system through any validator, all validators processing blocks containing reads of that resource would diverge.

## Likelihood Explanation

**Likelihood: Low-to-Medium**

While the Move bytecode verifier and type system should prevent most malformed layouts, several factors increase likelihood:

1. **Complexity**: The type-to-layout conversion handles recursive structures, generics, variants, and delayed fields - complexity breeds edge cases
2. **No Defense-in-Depth**: Zero defensive validation means ANY upstream bug immediately becomes consensus-critical
3. **Recent Features**: Move enums (variants) and delayed field optimizations add new code paths that may have undiscovered edge cases
4. **Fuzzer Evidence**: The existence of `is_valid_layout()` in fuzzer code proves the developers identified specific invalid layout patterns (empty structs, decorated layouts) but didn't add production checks

The likelihood increases if:
- New Move language features are added
- Type system changes occur
- Module linking logic is modified
- Delayed field handling evolves

## Recommendation

Add defensive layout validation at the write boundary before storing in the versioned cache:

```rust
fn validate_layout(layout: &MoveTypeLayout) -> Result<(), PanicError> {
    use MoveTypeLayout as L;
    
    match layout {
        L::Bool | L::U8 | L::U16 | L::U32 | L::U64 | L::U128 | L::U256
        | L::I8 | L::I16 | L::I32 | L::I64 | L::I128 | L::I256
        | L::Address | L::Signer | L::Function => Ok(()),
        
        L::Vector(inner) | L::Native(_, inner) => validate_layout(inner),
        
        L::Struct(MoveStructLayout::Runtime(fields)) => {
            if fields.is_empty() {
                return Err(code_invariant_error("Empty struct layout is invalid"));
            }
            fields.iter().try_for_each(validate_layout)
        },
        
        L::Struct(MoveStructLayout::RuntimeVariants(variants)) => {
            if variants.is_empty() {
                return Err(code_invariant_error("Empty variants layout is invalid"));
            }
            variants.iter()
                .flat_map(|v| v.iter())
                .try_for_each(validate_layout)
        },
        
        L::Struct(_) => {
            Err(code_invariant_error("Decorated layouts not supported"))
        },
    }
}

fn process_resource_output_v2(
    maybe_output: Option<&E::Output>,
    idx_to_execute: TxnIndex,
    incarnation: Incarnation,
    last_input_output: &TxnLastInputOutput<T, E::Output>,
    versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
    abort_manager: &mut AbortManager,
) -> Result<(), PanicError> {
    // ... existing code ...
    
    match resource_write_set.remove_entry(prev_key_ref) {
        Some((key, (value, maybe_layout))) => {
            // Validate layout before storing
            if let Some(ref layout) = maybe_layout {
                validate_layout(layout)?;
            }
            
            abort_manager.invalidate_dependencies(
                versioned_cache.data().write_v2::<false>(
                    key,
                    idx_to_execute,
                    incarnation,
                    value,
                    maybe_layout,
                )?
            )?;
        },
        // ... rest of code ...
    }
}
```

Additionally, add similar validation in the V1 write path and at module publishing boundaries.

## Proof of Concept

A complete PoC requires discovering a specific bug in the Move type system or bytecode verifier that generates malformed layouts. However, the vulnerability can be demonstrated conceptually:

```rust
// Hypothetical scenario: Assume a bug in type-to-layout conversion
// produces a MoveStructLayout::Runtime with empty fields for some edge case

// Step 1: Validator A processes a transaction that hits the bug
// - Type conversion produces layout with empty fields
// - Layout passes through executor.rs line 198 without validation
// - Stored in versioned cache

// Step 2: Validator B processes same block
// - Reads the same resource in a later transaction
// - Attempts deserialization using the malformed layout
// - Deserialization fails (layout with empty struct is invalid)
// - Returns error, execution diverges

// Step 3: Consensus split
// - Validator A: Transaction succeeds with malformed layout stored
// - Validator B: Transaction execution fails due to deserialization error
// - Different state roots produced
// - Network cannot reach consensus
```

The actual exploitation requires identifying the specific type system bug, but the code path demonstrating the lack of validation and its consequences is clearly present in the codebase.

## Notes

This vulnerability exemplifies a classic defense-in-depth failure. While the Move VM's type system should generate valid layouts, the absence of validation at the critical write boundary means any upstream bug immediately becomes consensus-critical. The fuzzer's `is_valid_layout()` function proves the developers identified specific invalid patterns, making the absence of production validation particularly concerning.

The conservative push validation strategy (failing when layouts are present) suggests the developers are aware of layout complexity risks, yet this conservatism doesn't extend to write-time validation where it's most needed.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L190-200)
```rust
                match resource_write_set.remove_entry(prev_key_ref) {
                    Some((key, (value, maybe_layout))) => {
                        abort_manager.invalidate_dependencies(
                            versioned_cache.data().write_v2::<false>(
                                key,
                                idx_to_execute,
                                incarnation,
                                value,
                                maybe_layout,
                            )?,
                        )?;
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L397-404)
```rust
        // Layouts pass validation only if they are both None. Otherwise, validation pessimistically
        // fails. This is a simple logic that avoids potentially costly layout comparisons.
        prev_maybe_layout.is_none() && new_maybe_layout.is_none() && prev_value == new_value
    }
    // TODO(BlockSTMv2): optimize layout validation (potentially based on size, or by having
    // a more efficient representation. Optimizing value validation by having a configurable
    // size threshold above which validation can automatically pessimistically fail.
}
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L703-709)
```rust
        Self::write_impl(
            &mut v,
            txn_idx,
            incarnation,
            ValueWithLayout::Exchanged(data, maybe_layout),
            deps_to_retain,
        );
```

**File:** aptos-move/mvhashmap/src/types.rs (L131-139)
```rust
pub enum ValueWithLayout<V> {
    // When we read from storage, but don't have access to layout, we can only store the raw value.
    // This should never be returned to the user, before exchange is performed.
    RawFromStorage(Arc<V>),
    // We've used the optional layout, and applied exchange to the storage value.
    // The type layout is Some if there is a delayed field in the resource.
    // The type layout is None if there is no delayed field in the resource.
    Exchanged(Arc<V>, Option<Arc<MoveTypeLayout>>),
}
```

**File:** aptos-move/block-executor/src/view.rs (L1201-1224)
```rust
        let maybe_patched = match (value.as_state_value(), layout) {
            (Some(state_value), Some(layout)) => {
                let res = self.replace_values_with_identifiers(state_value, layout);
                match res {
                    Ok((value, _)) => Some(value),
                    Err(err) => {
                        let log_context =
                            AdapterLogSchema::new(self.base_view.id(), self.txn_idx as usize);
                        alert!(
                            log_context,
                            "[VM, ResourceView] Error during value to id replacement: {}",
                            err
                        );
                        self.mark_incorrect_use();
                        return Err(PartialVMError::new(
                            StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                        )
                        .with_message(format!("{}", err)));
                    },
                }
            },
            (state_value, _) => state_value,
        };
        Ok(TransactionWrite::from_state_value(maybe_patched))
```

**File:** aptos-move/block-executor/src/view.rs (L1243-1250)
```rust
                let patched_value =
                    ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
                        .with_delayed_fields_replacement(&mapping)
                        .with_func_args_deserialization(&function_value_extension)
                        .deserialize(bytes.as_ref(), layout)
                        .ok_or_else(|| {
                            anyhow::anyhow!("Failed to deserialize resource during id replacement")
                        })?;
```

**File:** testsuite/fuzzer/fuzz/fuzz_targets/move/utils/helpers.rs (L34-70)
```rust
pub(crate) fn is_valid_layout(layout: &MoveTypeLayout) -> bool {
    use MoveTypeLayout as L;

    match layout {
        L::Bool
        | L::U8
        | L::U16
        | L::U32
        | L::U64
        | L::U128
        | L::U256
        | L::I8
        | L::I16
        | L::I32
        | L::I64
        | L::I128
        | L::I256
        | L::Address
        | L::Signer
        | L::Function => true,

        L::Vector(layout) | L::Native(_, layout) => is_valid_layout(layout),
        L::Struct(MoveStructLayout::RuntimeVariants(variants)) => {
            variants.iter().all(|v| v.iter().all(is_valid_layout))
        },
        L::Struct(MoveStructLayout::Runtime(fields)) => {
            if fields.is_empty() {
                return false;
            }
            fields.iter().all(is_valid_layout)
        },
        L::Struct(_) => {
            // decorated layouts not supported
            false
        },
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L254-325)
```rust
    fn type_to_type_layout_impl<const ANNOTATED: bool>(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        modules: &mut DefiningModules,
        ty: &Type,
        count: &mut u64,
        depth: u64,
        check_option_type: bool,
    ) -> PartialVMResult<(MoveTypeLayout, bool)> {
        self.check_depth_and_increment_count(count, depth)?;

        Ok(match ty {
            Type::Bool => (MoveTypeLayout::Bool, false),
            Type::U8 => (MoveTypeLayout::U8, false),
            Type::U16 => (MoveTypeLayout::U16, false),
            Type::U32 => (MoveTypeLayout::U32, false),
            Type::U64 => (MoveTypeLayout::U64, false),
            Type::U128 => (MoveTypeLayout::U128, false),
            Type::U256 => (MoveTypeLayout::U256, false),
            Type::I8 => (MoveTypeLayout::I8, false),
            Type::I16 => (MoveTypeLayout::I16, false),
            Type::I32 => (MoveTypeLayout::I32, false),
            Type::I64 => (MoveTypeLayout::I64, false),
            Type::I128 => (MoveTypeLayout::I128, false),
            Type::I256 => (MoveTypeLayout::I256, false),
            Type::Address => (MoveTypeLayout::Address, false),
            Type::Signer => (MoveTypeLayout::Signer, false),
            Type::Function { .. } => (MoveTypeLayout::Function, false),
            Type::Vector(ty) => self
                .type_to_type_layout_impl::<ANNOTATED>(
                    gas_meter,
                    traversal_context,
                    modules,
                    ty,
                    count,
                    depth + 1,
                    check_option_type,
                )
                .map(|(elem_layout, contains_delayed_fields)| {
                    let vec_layout = MoveTypeLayout::Vector(Box::new(elem_layout));
                    (vec_layout, contains_delayed_fields)
                })?,
            Type::Struct { idx, .. } => self.struct_to_type_layout::<ANNOTATED>(
                gas_meter,
                traversal_context,
                modules,
                idx,
                &[],
                count,
                depth + 1,
                check_option_type,
            )?,
            Type::StructInstantiation { idx, ty_args, .. } => self
                .struct_to_type_layout::<ANNOTATED>(
                    gas_meter,
                    traversal_context,
                    modules,
                    idx,
                    ty_args,
                    count,
                    depth + 1,
                    check_option_type,
                )?,
            Type::Reference(_) | Type::MutableReference(_) | Type::TyParam(_) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message(format!("No type layout for {:?}", ty)),
                );
            },
        })
    }
```
