# Audit Report

## Title
Integer Overflow in Indexer Transaction Version Casting Leading to Database Corruption

## Summary
The Aptos indexer's transaction processing pipeline performs unchecked casts from `u64` to `i64` when converting transaction version numbers for database storage. When processing transactions with version numbers exceeding `i64::MAX` (9,223,372,036,854,775,807), these casts trigger integer overflow, wrapping to negative values and causing severe database corruption that breaks transaction ordering and data integrity.

## Finding Description

The vulnerability exists in multiple locations where transaction version numbers are cast from `u64` to `i64` without bounds validation:

**Primary Location (default_processor.rs):** [1](#0-0) 

Here, transaction versions from `UserTransaction` and `BlockMetadataTransaction` objects are cast to `i64` for use in object creation. The `U64` wrapper type stores a `u64` internally: [2](#0-1) 

**Additional Vulnerable Locations (transactions.rs):** [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) 

**Database Schema Constraint:**
All affected tables use `BIGINT` (signed 64-bit integer) for version fields: [10](#0-9) 

**Affected Database Models:** [11](#0-10) [12](#0-11) [13](#0-12) 

**Attack Scenario:**

1. An attacker compromises or controls a blockchain node that an indexer connects to, or performs a man-in-the-middle attack on the indexer's API connection
2. The attacker crafts malicious `Transaction` objects with `info.version` values exceeding `i64::MAX` (e.g., `9,223,372,036,854,775,808`)
3. These transactions are fed to the indexer via the node's API
4. The indexer's `process_transactions()` function receives these transactions without version bounds validation
5. When casting `version.0 as i64`, values above `i64::MAX` wrap around to negative numbers (e.g., `i64::MAX + 1` becomes `i64::MIN = -9,223,372,036,854,775,808`)
6. These negative version numbers are inserted into PostgreSQL tables: `transactions`, `objects`, `current_objects`, `write_set_changes`, `events`, `move_modules`, `move_resources`, `table_items`, etc.
7. Database corruption occurs:
   - Transaction ordering is completely broken (negative versions sort before all positive versions)
   - Queries expecting chronological ordering return incorrect results
   - Foreign key relationships become inconsistent
   - Dependent services (dApps, wallets, blockchain explorers) receive corrupted data
   - Database indices become invalid

## Impact Explanation

This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Impact Scope:**
- **Indexer Infrastructure Only**: This vulnerability affects the off-chain indexer component, not the blockchain consensus layer, validator nodes, or on-chain state
- **No Consensus Violation**: The blockchain continues operating correctly; only the indexer's database is affected
- **No Funds Loss**: No tokens can be stolen, minted, or frozen
- **Service Disruption**: Applications relying on the indexer (dApps, wallets, explorers) receive corrupted data
- **Recovery Required**: Full database reindexing from a clean blockchain state is necessary

**Severity Justification:**
- Does NOT meet Critical severity (no funds loss, no consensus violation)
- Does NOT meet High severity (no validator impact, no direct protocol violation)
- DOES meet Medium severity (state inconsistencies in indexer requiring manual intervention)

## Likelihood Explanation

**Likelihood: LOW to MEDIUM** depending on deployment configuration

**Natural Occurrence: Effectively Impossible**
- Transaction versions start at 0 and increment by 1
- At 10,000 TPS sustained throughput, reaching `i64::MAX` would require approximately 29 million years
- This will never occur under normal blockchain operations

**Malicious Exploitation: Possible Under Specific Conditions**
- Requires either:
  - Compromised or malicious blockchain node that the indexer connects to
  - Man-in-the-middle attack on API communications
  - Indexer configured to pull from an untrusted data source
- Attacker must have ability to inject crafted transaction data into the indexer's processing pipeline
- Does NOT require validator access or on-chain privileges

**Deployment Considerations:**
- Indexers typically connect to trusted nodes
- However, misconfigurations or compromised infrastructure could expose this vulnerability
- The lack of input validation makes the indexer vulnerable to malicious data sources

## Recommendation

Implement strict bounds checking before casting transaction versions from `u64` to `i64`:

```rust
// In default_processor.rs process_transactions():
fn safe_version_to_i64(version: u64) -> Result<i64, TransactionProcessingError> {
    i64::try_from(version).map_err(|_| {
        TransactionProcessingError::TransactionCommitError((
            anyhow::anyhow!("Transaction version {} exceeds i64::MAX", version),
            version,
            version,
            "version_bounds_check",
        ))
    })
}

// Then use it in the loop:
for (index, wsc) in changes.iter().enumerate() {
    let index = index as i64;
    let txn_version = safe_version_to_i64(user_txn.info.version.0)?;
    match wsc {
        WriteSetChange::WriteResource(inner) => {
            if let Some((object, current_object)) =
                &Object::from_write_resource(inner, txn_version, index).unwrap()
            // ... rest of code
```

**Apply similar validation in:**
- `transactions.rs` in `from_transaction_info()` (line 87)
- All other locations performing version casts (lines 125, 143, 153, 171, 181, 201)

**Alternative Mitigation:**
Consider redesigning the database schema to use `NUMERIC` or `BIGINT UNSIGNED` if PostgreSQL version supports it, though this requires more extensive migration.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_api_types::{Transaction, UserTransaction, TransactionInfo, U64};
    
    #[tokio::test]
    async fn test_version_overflow_vulnerability() {
        // Setup: Create a transaction with version > i64::MAX
        let malicious_version = (i64::MAX as u64) + 1000;
        
        let mut txn_info = TransactionInfo::default();
        txn_info.version = U64::from(malicious_version);
        
        let mut user_txn = UserTransaction::default();
        user_txn.info = txn_info;
        
        let transaction = Transaction::UserTransaction(user_txn);
        
        // Simulate the vulnerable cast
        let version_u64 = transaction.version().unwrap();
        let version_i64 = version_u64 as i64;
        
        // Verify overflow occurred
        assert!(version_u64 > i64::MAX as u64);
        assert!(version_i64 < 0, "Version wrapped to negative: {}", version_i64);
        
        println!("Original version (u64): {}", version_u64);
        println!("Cast version (i64): {}", version_i64);
        println!("Overflow detected: {} wrapped to {}", version_u64, version_i64);
        
        // This negative value would be inserted into the database,
        // corrupting transaction ordering and indices
    }
    
    #[test]
    fn test_i64_max_boundary() {
        let boundary_version = i64::MAX as u64;
        let overflow_version = boundary_version + 1;
        
        // Safe cast
        let safe_cast = boundary_version as i64;
        assert_eq!(safe_cast, i64::MAX);
        
        // Overflow cast
        let overflow_cast = overflow_version as i64;
        assert_eq!(overflow_cast, i64::MIN); // Wraps to minimum negative value
        
        println!("Boundary case: {} -> {}", boundary_version, safe_cast);
        println!("Overflow case: {} -> {}", overflow_version, overflow_cast);
    }
}
```

**Expected Output:**
```
Original version (u64): 9223372036854776807
Cast version (i64): -9223372036854774808
Overflow detected: 9223372036854776807 wrapped to -9223372036854774808
```

## Notes

This vulnerability is specific to the **indexer component** and does not affect:
- Blockchain consensus or validator operations
- On-chain state or transaction execution
- Smart contract security or Move VM

However, it represents a significant **data integrity risk** for indexer infrastructure that dApps, wallets, and explorers depend on for accurate blockchain data. The lack of input validation allows malicious or compromised data sources to corrupt the indexer's database, requiring manual intervention and full reindexing to recover.

### Citations

**File:** crates/indexer/src/processors/default_processor.rs (L534-543)
```rust
            let (changes, txn_version) = match txn {
                Transaction::UserTransaction(user_txn) => (
                    user_txn.info.changes.clone(),
                    user_txn.info.version.0 as i64,
                ),
                Transaction::BlockMetadataTransaction(bmt_txn) => {
                    (bmt_txn.info.changes.clone(), bmt_txn.info.version.0 as i64)
                },
                _ => continue,
            };
```

**File:** api/types/src/move_types.rs (L129-129)
```rust
define_integer_type!(U64, u64, "A string encoded U64.");
```

**File:** crates/indexer/src/models/transactions.rs (L35-35)
```rust
    pub version: i64,
```

**File:** crates/indexer/src/models/transactions.rs (L87-87)
```rust
            version: info.version.0 as i64,
```

**File:** crates/indexer/src/models/transactions.rs (L125-125)
```rust
                    user_txn.info.version.0 as i64,
```

**File:** crates/indexer/src/models/transactions.rs (L143-143)
```rust
                        user_txn.info.version.0 as i64,
```

**File:** crates/indexer/src/models/transactions.rs (L153-153)
```rust
                    genesis_txn.info.version.0 as i64,
```

**File:** crates/indexer/src/models/transactions.rs (L171-171)
```rust
                        genesis_txn.info.version.0 as i64,
```

**File:** crates/indexer/src/models/transactions.rs (L181-181)
```rust
                    block_metadata_txn.info.version.0 as i64,
```

**File:** crates/indexer/src/models/transactions.rs (L201-201)
```rust
                        block_metadata_txn.info.version.0 as i64,
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L33-33)
```sql
  version BIGINT UNIQUE PRIMARY KEY NOT NULL,
```

**File:** crates/indexer/src/models/v2_objects.rs (L31-31)
```rust
    pub transaction_version: i64,
```

**File:** crates/indexer/src/models/v2_objects.rs (L50-50)
```rust
    pub last_transaction_version: i64,
```
