# Audit Report

## Title
Timezone Mismatch in Faucet Rate Limiting Allows Premature Rate Limit Reset

## Summary
The Aptos faucet's Redis-based rate limiting system contains a timezone mismatch between day boundary calculations and key expiration logic, allowing users to bypass daily rate limits by making requests during a specific time window.

## Finding Description

The faucet rate limiting system uses two time-related calculations that operate on different timezone assumptions:

1. **Day counting** via `days_since_tap_epoch()` [1](#0-0)  uses `TAP_EPOCH_SECS` (defined as 12:01am PDT = 7:01am UTC) [2](#0-1)  as a reference point, meaning day boundaries occur at 7:01am UTC.

2. **Key expiration** via `seconds_until_next_day()` [3](#0-2)  calculates time until UTC midnight by using `current_time_secs % 86400`, which assumes day boundaries at midnight UTC.

In `RedisRatelimitChecker`, the system generates rate limit keys using the day number [4](#0-3)  and sets their TTL to expire at UTC midnight [5](#0-4) .

**Exploitation scenario:**
1. User makes `max_requests_per_day` requests on Day N (e.g., Sep 26, 2022 at 6:00pm UTC)
2. Redis key format: `"ip:1.2.3.4:{day_number}"` where `day_number = 1`
3. At 11:00pm UTC, TTL is set to 1 hour (until midnight)
4. At midnight UTC, Redis key expires and is deleted
5. At 12:01am UTC (still Day 1 according to epoch-based calculation since 7:01am hasn't occurred):
   - User makes new request
   - `days_since_tap_epoch()` still returns `1` 
   - System generates same key: `"ip:1.2.3.4:1"`
   - Redis returns `None` (key expired)
   - System creates fresh counter, allowing another `max_requests_per_day` requests
6. User can exploit the 7-hour window (midnight to 7:01am UTC) to double their daily allowance

## Impact Explanation

**Severity: Low** (does not meet Critical/High/Medium criteria)

This vulnerability affects the **Aptos Faucet service**, which is an auxiliary component for distributing test tokens on devnet/testnet, not a core blockchain protocol component. The impact is limited to:

- Extra faucet token distribution (test tokens only, no economic value)
- Does not affect consensus, validator operations, or Move VM execution
- Does not compromise on-chain funds or blockchain state
- Does not violate any of the 10 critical blockchain invariants listed in the audit scope

The faucet is explicitly excluded from core components (consensus, execution, storage, governance, staking) that this audit focuses on. While this is a legitimate implementation bug, it represents a **minor operational issue** in an auxiliary service, not a critical protocol vulnerability.

## Likelihood Explanation

**Likelihood: High** (Easy to exploit)

Any faucet user can exploit this by:
1. Knowing the UTC timezone offset (7 hours based on TAP_EPOCH_SECS)
2. Making requests to hit the daily limit
3. Waiting until midnight UTC
4. Making additional requests before 7:01am UTC

No special privileges, technical sophistication, or insider knowledge required beyond understanding the timing window.

## Recommendation

Align day boundary calculations by modifying `seconds_until_next_day()` to account for the TAP epoch's timezone offset:

```rust
pub fn seconds_until_next_day(current_time_secs: u64) -> u64 {
    let seconds_since_epoch = current_time_secs - TAP_EPOCH_SECS;
    let seconds_in_current_day = seconds_since_epoch % 86400;
    86400 - seconds_in_current_day
}
```

This ensures both day counting and TTL expiration use the same reference point (7:01am UTC daily boundaries).

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_timezone_mismatch_vulnerability() {
        // TAP_EPOCH_SECS = Sep 25, 2022 at 7:01:00 AM UTC
        let epoch = 1664089260u64;
        
        // Scenario: Sep 27, 2022 at 12:30 AM UTC (30 minutes after midnight)
        // This is 6.5 hours before the "day" should change (at 7:01 AM)
        let midnight_plus_30min = epoch + 86400 + 1800; // Day 1 + 30 minutes
        
        // Calculate day number - should still be Day 1
        let day_num = (midnight_plus_30min - epoch) / 86400;
        assert_eq!(day_num, 1, "Day number should be 1");
        
        // Calculate seconds until next day (current implementation)
        let seconds_since_midnight = midnight_plus_30min % 86400;
        let secs_until_next = 86400 - seconds_since_midnight;
        
        // This returns time until the NEXT midnight (23.5 hours away)
        // But the day actually changes in 6.5 hours!
        assert!(secs_until_next > 80000, "TTL set for ~23.5 hours");
        
        // The key would have expired ~6.5 hours ago at midnight
        // But we're still in "Day 1" according to days_since_tap_epoch
        // This allows users to reset their counter prematurely
    }
}
```

## Notes

**Important Context:** This finding is documented as **Low severity** because the Aptos Faucet is not part of the core blockchain protocol. It does not affect consensus, validator security, Move VM execution, state management, governance, or stakingâ€”the primary focus areas of this security audit. The vulnerability represents a rate-limiting implementation bug in an auxiliary service that distributes valueless test tokens, not a critical protocol-level security issue.

### Citations

**File:** crates/aptos-faucet/core/src/helpers.rs (L26-29)
```rust
/// This unixtime is 12:01am PDT on 2021-09-25. See the docstring for
/// RedisRatelimitChecker for more information on how we use this value.
/// We also use this in MemoryRatelimitChecker in a similar way.
pub const TAP_EPOCH_SECS: u64 = 1664089260;
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L33-35)
```rust
pub fn days_since_tap_epoch(current_time_secs: u64) -> u64 {
    (current_time_secs - TAP_EPOCH_SECS) / 86400
}
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L37-40)
```rust
pub fn seconds_until_next_day(current_time_secs: u64) -> u64 {
    let seconds_since_midnight = current_time_secs % 86400;
    86400 - seconds_since_midnight
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L186-200)
```rust
    fn get_key_and_secs_until_next_day(
        &self,
        ratelimit_key_prefix: &str,
        ratelimit_key_value: &str,
    ) -> (String, u64) {
        let now_secs = get_current_time_secs();
        let seconds_until_next_day = seconds_until_next_day(now_secs);
        let key = format!(
            "{}:{}:{}",
            ratelimit_key_prefix,
            ratelimit_key_value,
            days_since_tap_epoch(now_secs)
        );
        (key, seconds_until_next_day)
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L278-278)
```rust
                        .expire(&key, seconds_until_next_day as usize)
```
