# Audit Report

## Title
Missing Validator Set Validation in RoundProposer Configuration Allows Governance-Based Liveness Attack

## Summary
The `RoundProposer::new()` function accepts a HashMap of round-to-proposer mappings from on-chain governance configuration without validating that the specified addresses are valid validators in the current epoch. This allows malicious governance proposals to inject invalid or non-validator addresses, causing consensus rounds to timeout and degrading network liveness.

## Finding Description

The vulnerability exists in the consensus proposer election mechanism when using the `ProposerElectionType::RoundProposer` variant. The attack flow is:

**1. Configuration Injection Point:**
The on-chain governance system allows updating consensus configuration via `set_for_next_epoch()`. The Move-side validation only checks that the config bytes are non-empty, performing no semantic validation: [1](#0-0) 

**2. Missing Validation During Deserialization:**
When the on-chain config is deserialized, it performs BCS deserialization but no content validation: [2](#0-1) 

**3. Unchecked HashMap Acceptance:**
During epoch initialization, `EpochManager::create_proposer_election()` extracts the valid validator set from `epoch_state.verifier`: [3](#0-2) 

However, when creating a `RoundProposer` from the on-chain config, it directly clones the HashMap without validating that its values are in the valid proposer set: [4](#0-3) 

**4. No Validation in Constructor:**
The `RoundProposer::new()` function accepts the HashMap and default_proposer without any validation: [5](#0-4) 

**5. Invalid Proposer Usage:**
When consensus reaches an affected round, `get_valid_proposer()` returns the invalid address from the HashMap: [6](#0-5) 

**6. Proposer Validation Check:**
The `is_valid_proposer()` trait method only checks if the author equals what `get_valid_proposer()` returns, providing no independent validation: [7](#0-6) 

**Attack Scenario:**
1. Attacker creates governance proposal with malicious `ProposerElectionType::RoundProposer(HashMap::from([(100, 0xDEADBEEF...), (101, 0xBADBAD...)]))` where addresses are not validators
2. Proposal passes governance vote (requires sufficient stake)
3. Configuration is applied during epoch transition
4. When consensus reaches rounds 100, 101, etc., no valid validator will propose (as they don't match the invalid address)
5. Votes are sent to invalid addresses that don't exist in the network
6. Rounds timeout, degrading network liveness

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: The attack causes systematic round timeouts, slowing down block production and increasing latency across all validator nodes.

2. **Significant Protocol Violation**: The consensus protocol's liveness guarantee is violated. While the network eventually progresses past affected rounds, the forced timeouts represent a measurable degradation in network performance.

3. **Scope of Impact**: All validators and network participants experience the effects simultaneously when affected rounds are reached.

The attack does not reach Critical severity because:
- Network liveness is degraded but not completely halted (unaffected rounds still function)
- No permanent state corruption or funds loss occurs
- The attack is reversible through subsequent governance action

## Likelihood Explanation

**Likelihood: Medium-Low**

**Prerequisites:**
- Attacker must control sufficient governance voting power to pass a malicious proposal
- Requires understanding of the consensus configuration internals
- Must wait for governance voting period and epoch transition

**Mitigating Factors:**
- Governance proposals require stake-weighted voting approval
- Proposals are publicly visible, allowing community review
- Legitimate governance participants would likely detect suspicious config changes
- Attack requires coordination during governance voting period

**Aggravating Factors:**
- Once a malicious config is in place, the attack is automatic (no further attacker action needed)
- The vulnerability is subtle and might not be detected during normal proposal review
- Multiple rounds can be targeted in a single proposal

## Recommendation

Add validation in `EpochManager::create_proposer_election()` to ensure all addresses in the `RoundProposer` HashMap are valid validators:

```rust
ProposerElectionType::RoundProposer(round_proposers) => {
    // Validate all proposer addresses are in the validator set
    let valid_proposers_set: HashSet<_> = proposers.iter().cloned().collect();
    for (round, proposer) in round_proposers.iter() {
        if !valid_proposers_set.contains(proposer) {
            error!(
                "Invalid proposer {} for round {} not in validator set",
                proposer, round
            );
            return Err(anyhow::anyhow!(
                "RoundProposer config contains invalid address {} for round {}",
                proposer,
                round
            ));
        }
    }
    
    let default_proposer = proposers
        .first()
        .expect("INVARIANT VIOLATION: proposers is empty");
    Arc::new(RoundProposer::new(
        round_proposers.clone(),
        *default_proposer,
    ))
}
```

Additionally, consider adding Move-side validation in `consensus_config::set_for_next_epoch()` that deserializes and validates the config structure before accepting it, though this requires careful gas budgeting.

## Proof of Concept

```rust
#[test]
fn test_invalid_round_proposer_rejected() {
    use aptos_types::{
        account_address::AccountAddress,
        on_chain_config::{OnChainConsensusConfig, ProposerElectionType},
        validator_verifier::ValidatorVerifier,
        epoch_state::EpochState,
    };
    use std::collections::HashMap;

    // Create valid validator set
    let valid_validators = vec![
        AccountAddress::random(),
        AccountAddress::random(),
        AccountAddress::random(),
    ];
    
    // Create invalid proposer mapping with non-validator address
    let invalid_address = AccountAddress::random();
    let malicious_mapping = HashMap::from([
        (100u64, invalid_address), // This is NOT in valid_validators
    ]);
    
    let malicious_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::JolteonV2 {
            main: ConsensusConfigV1 {
                proposer_election_type: ProposerElectionType::RoundProposer(malicious_mapping),
                ..ConsensusConfigV1::default()
            },
            quorum_store_enabled: true,
            order_vote_enabled: true,
        },
        vtxn: ValidatorTxnConfig::default_for_genesis(),
        window_size: None,
        rand_check_enabled: true,
    };
    
    // Serialize the malicious config (simulating governance proposal)
    let config_bytes = bcs::to_bytes(&malicious_config).unwrap();
    
    // The Move validation only checks length > 0, which passes
    assert!(config_bytes.len() > 0); // Would pass Move validation
    
    // When EpochManager creates proposer election, it should reject invalid addresses
    // Currently, this passes without validation (demonstrating the vulnerability)
    let deserialized: OnChainConsensusConfig = bcs::from_bytes(&config_bytes).unwrap();
    match deserialized.proposer_election_type() {
        ProposerElectionType::RoundProposer(mappings) => {
            // Vulnerability: No check that invalid_address is in valid_validators
            assert!(mappings.contains_key(&100));
            assert_eq!(mappings[&100], invalid_address);
            // This should fail but currently doesn't
        },
        _ => panic!("Wrong proposer election type"),
    }
}
```

**Notes:**

This vulnerability represents a governance-based attack vector that compromises consensus liveness. While the barrier to exploitation is moderately high (requiring governance control), the impact on network performance is significant and affects all participants. The fix is straightforward: validate that all addresses in the round proposer mapping are members of the current epoch's validator set.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** consensus/src/epoch_manager.rs (L292-295)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
```

**File:** consensus/src/epoch_manager.rs (L396-405)
```rust
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
            },
```

**File:** consensus/src/liveness/round_proposer_election.rs (L18-23)
```rust
    pub fn new(proposers: HashMap<Round, Author>, default_proposer: Author) -> Self {
        Self {
            proposers,
            default_proposer,
        }
    }
```

**File:** consensus/src/liveness/round_proposer_election.rs (L27-32)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            None => self.default_proposer,
            Some(round_proposer) => *round_proposer,
        }
    }
```

**File:** consensus/src/liveness/proposer_election.rs (L14-16)
```rust
    fn is_valid_proposer(&self, author: Author, round: Round) -> bool {
        self.get_valid_proposer(round) == author
    }
```
