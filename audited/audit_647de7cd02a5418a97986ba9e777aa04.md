# Audit Report

## Title
Module Read Dependency Loss via HashMap Overwrite in CapturedReads

## Summary
The `capture_global_cache_read()` and `capture_per_block_cache_read()` functions unconditionally overwrite previous entries in the `module_reads` HashMap without validation. This causes module read dependencies to be silently lost when the same module is captured multiple times through different cache layers (GlobalCache → PerBlockCache), preventing proper validation of all module dependencies and potentially leading to validation inconsistencies.

## Finding Description

The vulnerability exists in the module read capture mechanism of the parallel block executor: [1](#0-0) 

Both `capture_global_cache_read()` and `capture_per_block_cache_read()` use `HashMap::insert()` which unconditionally overwrites any existing entry: [2](#0-1) 

During transaction execution, the following sequence occurs:

1. Transaction T1 reads module M from the global cache (deserialized but not yet verified)
2. The read is captured via `capture_global_cache_read(M, module_code_v1)`, storing `{M: GlobalCache(module_code_v1)}` [3](#0-2) 

3. Later in execution, the Move VM lazily verifies module M and calls `insert_verified_module()` [4](#0-3) 

4. Line 121 calls `capture_per_block_cache_read()` which **overwrites** the HashMap entry, replacing `GlobalCache(module_code_v1)` with `PerBlockCache(verified_code, None)`

5. During validation, only the PerBlockCache entry is checked: [5](#0-4) 

The critical issue: GlobalCache reads require validation via `global_module_cache.contains_not_overridden(key)` (line 1061) to ensure the cached module hasn't been republished. When the HashMap entry is overwritten, this validation check is **never performed**, even though the transaction initially depended on that global cache entry being valid.

## Impact Explanation

This breaks the **Deterministic Execution** invariant. The security impact includes:

1. **Validation Inconsistency**: Different validators may validate the same transaction differently depending on the timing of when module verification occurs relative to when other transactions publish modules.

2. **Non-deterministic Validation**: If a module is:
   - Read from global cache (valid at time T1)
   - Verified and captured as PerBlockCache
   - Global cache marked as overridden by concurrent transaction
   - Validation checks only PerBlockCache consistency, missing the global cache invalidation

3. **Consensus Divergence Risk**: In edge cases where per-block cache validation is insufficient to detect the inconsistency (e.g., when version comparisons happen to match despite global cache override), different validators could produce different validation results.

This constitutes **High Severity** per Aptos bug bounty criteria as it represents a significant protocol violation affecting the parallel execution validation mechanism.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific conditions:
- Transaction must read a module from global cache
- Module must undergo lazy verification during execution
- Concurrent transaction must publish the same module
- Timing must allow global cache to be overridden between read and validation

While not trivially exploitable, these conditions can occur naturally during normal block execution when:
- Multiple transactions interact with newly published modules
- Parallel execution causes interleaving of module reads and publications
- Module verification happens during transaction execution rather than at load time

The intentional design (as evidenced by the comment on lines 108-111) to update captured reads during verification suggests this behavior may not be fully understood or its security implications not fully considered.

## Recommendation

Modify the capture functions to detect and handle attempts to overwrite existing entries with different cache types:

```rust
pub(crate) fn capture_global_cache_read(&mut self, key: K, read: Arc<ModuleCode<DC, VC, S>>) {
    use hashbrown::hash_map::Entry;
    
    match self.module_reads.entry(key) {
        Entry::Vacant(e) => {
            e.insert(ModuleRead::GlobalCache(read));
        },
        Entry::Occupied(e) => {
            // If already captured from per-block cache, keep that entry
            // as it's more specific. But log for investigation.
            if !matches!(e.get(), ModuleRead::PerBlockCache(_)) {
                // Only overwrite if same cache type
                e.insert(ModuleRead::GlobalCache(read));
            }
        }
    }
}

pub(crate) fn capture_per_block_cache_read(
    &mut self,
    key: K,
    read: Option<(Arc<ModuleCode<DC, VC, S>>, Option<TxnIndex>)>,
) {
    use hashbrown::hash_map::Entry;
    
    match self.module_reads.entry(key.clone()) {
        Entry::Vacant(e) => {
            e.insert(ModuleRead::PerBlockCache(read));
        },
        Entry::Occupied(mut e) => {
            // If transitioning from GlobalCache to PerBlockCache,
            // preserve both dependencies for validation
            match e.get() {
                ModuleRead::GlobalCache(global_read) => {
                    // Store both: validate global cache not overridden
                    // AND per-block cache consistency
                    e.insert(ModuleRead::PerBlockCache(read));
                    // Additionally track that global cache must be validated
                    self.mark_global_cache_dependency(key);
                },
                ModuleRead::PerBlockCache(_) => {
                    e.insert(ModuleRead::PerBlockCache(read));
                }
            }
        }
    }
}
```

Alternative: Validate all module reads (both GlobalCache and PerBlockCache) separately, even if the HashMap entry was overwritten.

## Proof of Concept

**Reproduction Steps:**

1. Create a test scenario with two transactions in the same block:
   - Transaction T0: Publishes module `TestModule`
   - Transaction T1: Reads and uses `TestModule`

2. Execute transactions in parallel with specific ordering:
   - T1 starts execution, reads TestModule from global cache
   - T1's read is captured as GlobalCache entry
   - T1 performs lazy verification, updates to PerBlockCache entry (overwrites GlobalCache)
   - T0 commits, publishes TestModule, marks global cache as overridden
   - T1 validates: only PerBlockCache entry is checked

3. Observe that the global cache override check is skipped due to HashMap overwrite

**Rust Test Skeleton:**
```rust
#[test]
fn test_module_dependency_loss() {
    // Setup: Module M in global cache
    // T1: Read M from global cache → capture GlobalCache(M)
    // T1: Verify M → capture PerBlockCache(M) [overwrites]
    // T0: Publish M → mark_overridden(M) in global cache
    // T1: Validate → only checks PerBlockCache, misses global override
    // Assert: Validation should have checked global cache override
}
```

## Notes

The vulnerability is subtle because the validation logic assumes that the most recent captured state is sufficient for validation. However, this violates the security principle that all dependencies must be validated. The HashMap overwrite silently discards the GlobalCache dependency, which has different validation semantics than PerBlockCache dependencies. While BlockSTM's dependency tracking may catch many cases through re-execution, edge cases exist where timing-dependent validation inconsistencies could occur, potentially affecting consensus safety.

### Citations

**File:** aptos-move/block-executor/src/captured_reads.rs (L1013-1015)
```rust
    pub(crate) fn capture_global_cache_read(&mut self, key: K, read: Arc<ModuleCode<DC, VC, S>>) {
        self.module_reads.insert(key, ModuleRead::GlobalCache(read));
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1017-1025)
```rust
    /// Records the read to per-block level cache.
    pub(crate) fn capture_per_block_cache_read(
        &mut self,
        key: K,
        read: Option<(Arc<ModuleCode<DC, VC, S>>, Option<TxnIndex>)>,
    ) {
        self.module_reads
            .insert(key, ModuleRead::PerBlockCache(read));
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1067)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };
```

**File:** aptos-move/block-executor/src/code_cache.rs (L99-122)
```rust
    fn insert_verified_module(
        &self,
        key: Self::Key,
        verified_code: Self::Verified,
        extension: Arc<Self::Extension>,
        version: Self::Version,
    ) -> VMResult<Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
        match &self.latest_view {
            ViewState::Sync(state) => {
                // For parallel execution, if we insert a verified module, we might need to also
                // update module cache in captured reads so that they also store the verified code.
                // If we do not do that, reads to module cache will end up reading "old" code that
                // is stored in captured reads and is not verified.
                let module = state.versioned_map.module_cache().insert_verified_module(
                    key.clone(),
                    verified_code,
                    extension,
                    version,
                )?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key, Some((module.clone(), version)));
                Ok(module)
```

**File:** aptos-move/block-executor/src/code_cache.rs (L156-162)
```rust
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }
```
