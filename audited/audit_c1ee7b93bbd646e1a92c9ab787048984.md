# Audit Report

## Title
Resource Exhaustion via Large Script Code Vector in P2P Mempool Broadcast

## Summary
An attacker can craft a `SignedTransaction` containing a `Script` with an arbitrarily large code vector (up to ~60 MB) and send it through the P2P mempool broadcast protocol. The transaction is fully deserialized (allocating memory for the large code vector) before any size validation occurs, enabling memory exhaustion attacks against validator nodes.

## Finding Description

The vulnerability exists due to a timing gap between resource allocation (memory) and resource validation (size limits):

**1. No size validation in Script construction:** [1](#0-0) 

The `Script::new()` function accepts a `Vec<u8>` code parameter without any size validation.

**2. API validation only checks emptiness, not size:** [2](#0-1) 

The `validate_script()` function only verifies the code is not empty but does not enforce size limits.

**3. Network layer accepts large messages:** [3](#0-2) 

The network allows messages up to `MAX_MESSAGE_SIZE` of 64 MB, far exceeding the transaction size limit.

**4. Deserialization occurs without size checks:** [4](#0-3) 

BCS deserialization using `bcs::from_bytes(&frame)` allocates memory for the entire `Vec<u8>` code vector before any validation.

**5. Transaction size validation happens too late:** [5](#0-4) 

The `check_gas()` function validates that `transaction_size > max_transaction_size_in_bytes` (64 KB), but this check occurs AFTER the transaction has been fully deserialized and memory allocated. [6](#0-5) 

The `check_gas()` call in `run_prologue_with_payload()` happens during VM validation, long after deserialization.

**6. VM validation occurs after deserialization:** [7](#0-6) 

Transactions are validated via `validate_transaction()` only after they've been fully deserialized as `SignedTransaction` objects.

**7. Actual transaction size limit:** [8](#0-7) 

The maximum allowed transaction size is only 64 KB, creating a massive gap with the 64 MB network message size.

**Attack Flow:**
1. Attacker crafts a `SignedTransaction` with a `Script` containing a 60 MB code vector
2. Wraps it in `MempoolSyncMsg::BroadcastTransactionsRequest`
3. Sends it to validator nodes through P2P mempool synchronization
4. Network layer accepts the message (≤64 MB limit)
5. BCS deserialization allocates 60 MB for the Script code vector
6. VM validation rejects it for exceeding 64 KB limit
7. Memory has already been allocated—resource exhaustion achieved

## Impact Explanation

This is a **High Severity** vulnerability under the Aptos bug bounty criteria for "Validator node slowdowns."

**Impact:**
- **Validator Performance Degradation**: Multiple concurrent malicious transactions can consume hundreds of megabytes to gigabytes of memory
- **Liveness Threat**: Memory exhaustion can cause validator nodes to slow down, fail to participate in consensus, or crash entirely
- **Network Availability**: If sufficient validators are affected, the network could experience liveness issues or degraded performance
- **Breaks Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" — memory is allocated before limits are enforced

The vulnerability violates the defense-in-depth principle by allowing resources to be committed before validation occurs.

## Likelihood Explanation

**Likelihood: High**

- **Low Attacker Requirements**: Any network peer can send P2P mempool broadcast messages without authentication beyond basic network connectivity
- **Simple Exploitation**: Creating a transaction with a large code vector is straightforward
- **No Rate Limiting**: No per-peer memory quotas or early size checks prevent repeated attacks
- **Wide Attack Surface**: All validator nodes accepting P2P mempool broadcasts are vulnerable
- **No Early Detection**: Malicious transactions appear valid until VM validation, allowing memory exhaustion to occur

The attack is practical and requires minimal resources or sophistication to execute.

## Recommendation

Implement early size validation before deserialization to prevent resource exhaustion:

**1. Add size check during BCS deserialization:**
Validate the encoded transaction size before deserializing the full payload. Use streaming or length-prefix validation to reject oversized transactions early.

**2. Enforce size limits at network layer:**
Add application-level size validation for mempool messages before deserializing transaction payloads:

```rust
// In mempool message handling
fn validate_message_size(encoded_txn: &[u8]) -> Result<(), Error> {
    if encoded_txn.len() > MAX_TRANSACTION_SIZE_IN_BYTES {
        return Err(Error::TransactionTooLarge);
    }
    // Then proceed with deserialization
}
```

**3. Add size validation to Script::new():**
```rust
pub fn new(code: Vec<u8>, ty_args: Vec<TypeTag>, args: Vec<TransactionArgument>) -> Result<Self, Error> {
    const MAX_SCRIPT_CODE_SIZE: usize = 64 * 1024; // 64 KB
    if code.len() > MAX_SCRIPT_CODE_SIZE {
        return Err(Error::ScriptCodeTooLarge);
    }
    Ok(Script { code, ty_args, args })
}
```

**4. Add per-peer memory quotas:**
Implement memory tracking and limits per network peer to prevent resource exhaustion attacks.

## Proof of Concept

```rust
use aptos_types::transaction::{Script, SignedTransaction, RawTransaction, TransactionPayload};
use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
use aptos_types::chain_id::ChainId;

// Create a transaction with an oversized Script
fn create_malicious_transaction() -> SignedTransaction {
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    
    // Create a Script with 60 MB of code (far exceeding 64 KB limit)
    let malicious_code = vec![0u8; 60 * 1024 * 1024]; // 60 MB
    let script = Script::new(malicious_code, vec![], vec![]);
    
    let raw_txn = RawTransaction::new_script(
        AccountAddress::random(),
        0, // sequence number
        script,
        1_000_000, // max gas
        0, // gas price
        u64::MAX, // expiration
        ChainId::test(),
    );
    
    raw_txn.sign(&private_key, public_key).unwrap().into_inner()
}

// Attacker sends this via MempoolSyncMsg::BroadcastTransactionsRequest
// Memory is allocated during deserialization before validation rejects it
```

**Test Steps:**
1. Create multiple transactions with 60 MB Script code vectors
2. Send them concurrently through P2P mempool broadcast to validator nodes
3. Observe memory consumption spike during deserialization
4. VM validation rejects transactions, but memory has already been allocated
5. Repeated attacks exhaust validator memory, causing slowdowns or crashes

**Notes**

The vulnerability demonstrates a classic resource exhaustion pattern where validation occurs after resource commitment. While the API layer has an 8 MB content-length limit that prevents this attack vector, the P2P network layer remains vulnerable with its 64 MB message size limit. The 1000x gap between the network message size (64 MB) and the actual transaction size limit (64 KB) creates a significant attack surface for memory exhaustion attacks against validator nodes.

### Citations

**File:** types/src/transaction/script.rs (L72-78)
```rust
    pub fn new(code: Vec<u8>, ty_args: Vec<TypeTag>, args: Vec<TransactionArgument>) -> Self {
        Script {
            code,
            ty_args,
            args,
        }
    }
```

**File:** api/src/transactions.rs (L1188-1213)
```rust
    fn validate_script(
        ledger_info: &LedgerInfo,
        script: &Script,
    ) -> Result<(), SubmitTransactionError> {
        if script.code().is_empty() {
            return Err(SubmitTransactionError::bad_request_with_code(
                "Script payload bytecode must not be empty",
                AptosErrorCode::InvalidInput,
                ledger_info,
            ));
        }

        for arg in script.ty_args() {
            let arg = MoveType::from(arg);
            arg.verify(0)
                .context("Transaction script function type arg invalid")
                .map_err(|err| {
                    SubmitTransactionError::bad_request_with_code(
                        err,
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    )
                })?;
        }
        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L230-231)
```rust
                match bcs::from_bytes(&frame) {
                    Ok(message) => Poll::Ready(Some(Ok(message))),
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```
