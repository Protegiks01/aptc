# Audit Report

## Title
Keyless Authenticator Validation Bypass in Transaction Simulation Causes False Success Predictions

## Summary
The `AptosSimulationVM` unconditionally skips keyless authenticator validation during transaction simulation, while `AptosVM` always validates them during real execution. This causes users with invalid keyless authenticators to receive successful simulation results but experience transaction failures when submitting to the network, resulting in wasted gas fees.

## Finding Description
The vulnerability exists in the `validate_signed_transaction` function where keyless authenticator validation is conditionally skipped based on the `is_simulation` flag. [1](#0-0) 

When `AptosSimulationVM::create_vm_and_simulate_signed_transaction` is called, it sets `is_simulation = true`: [2](#0-1) 

This creates a critical divergence where:
1. **Simulation Path**: Keyless validation is skipped when `is_simulation = true`
2. **Execution Path**: Keyless validation always runs when `is_simulation = false`

The simulation API endpoint calls this function: [3](#0-2) 

**Attack Vector:**
1. Attacker constructs a transaction with an invalid keyless authenticator (expired JWT, wrong public key, invalid signature, etc.)
2. Calls `/transactions/simulate` endpoint
3. Simulation skips keyless validation → returns `ExecutionStatus::Success`
4. Attacker believes transaction will succeed
5. Submits transaction to network via `/transactions` endpoint
6. Real execution validates keyless authenticator → fails with `INVALID_SIGNATURE` or authentication error
7. Attacker loses gas fees for failed transaction

This violates **Invariant #7 (Transaction Validation)**: The simulation should accurately predict whether transaction validation will succeed or fail, but it provides false positives for transactions with invalid keyless authenticators.

## Impact Explanation
This is **High Severity** based on the Aptos bug bounty criteria for "Significant protocol violations". The simulation API is a critical component that users rely on to predict transaction outcomes before submission. This divergence:

- Causes financial harm through wasted gas fees on guaranteed-to-fail transactions
- Undermines user trust in the simulation API
- Creates a poor user experience for keyless account users
- Affects all users of keyless authentication (a growing segment as keyless accounts are promoted)

While not "loss of funds" in the traditional sense, users lose real value in the form of gas fees paid for transactions that the simulation incorrectly predicted would succeed. This is particularly harmful because keyless authentication is being actively promoted as a user-friendly feature.

## Likelihood Explanation
**High Likelihood** - This will occur every time a user with an invalid keyless authenticator uses the simulation API, which is a recommended best practice before transaction submission. The conditions are:

1. User has keyless authenticator (common - this is a promoted feature)
2. Authenticator is invalid (expired JWT, wrong signature, etc.)
3. User follows best practice of simulating before submission
4. No special setup or privileges required

The vulnerability is deterministic and affects normal API usage patterns.

## Recommendation
The keyless authenticator validation should run in both simulation and execution modes to ensure prediction accuracy. Modify the validation logic:

**Current code:**
```rust
if !keyless_authenticators.is_empty() && !self.is_simulation {
    keyless_validation::validate_authenticators(...)
}
```

**Fixed code:**
```rust
if !keyless_authenticators.is_empty() {
    keyless_validation::validate_authenticators(...)
}
```

The `is_simulation` check should be removed from this validation path. If there are performance concerns about validation costs in simulation, consider:
1. Allowing simulation to use cached validation results
2. Providing a separate "fast simulation" endpoint that explicitly disclaims accuracy
3. Documenting the limitation clearly in API responses

## Proof of Concept

```rust
// Rust PoC demonstrating the divergence
use aptos_types::transaction::SignedTransaction;
use aptos_vm::{AptosVM, AptosSimulationVM};
use aptos_types::keyless::Groth16Proof; // Keyless authenticator components

#[test]
fn test_keyless_simulation_divergence() {
    // Setup: Create a transaction with INVALID keyless authenticator
    let mut txn = create_transaction_with_keyless_auth();
    // Deliberately corrupt the keyless authenticator
    corrupt_keyless_authenticator(&mut txn);
    
    let state_view = create_test_state_view();
    
    // Step 1: Simulate the transaction
    let (sim_status, sim_output) = 
        AptosSimulationVM::create_vm_and_simulate_signed_transaction(
            &txn, 
            &state_view
        );
    
    // Simulation SUCCEEDS (incorrectly) - keyless validation skipped
    assert!(sim_status.status_code() == StatusCode::EXECUTED);
    
    // Step 2: Execute the same transaction in real VM
    let env = AptosEnvironment::new(&state_view);
    let mut vm = AptosVM::new(&env); // is_simulation = false
    let (exec_status, exec_output) = vm.execute_user_transaction(
        &resolver,
        &code_storage,
        &txn,
        &log_context,
        &aux_info,
    );
    
    // Execution FAILS - keyless validation runs and catches invalid authenticator
    assert!(exec_status.status_code() == StatusCode::INVALID_SIGNATURE);
    
    // This divergence causes users to waste gas!
    assert_ne!(sim_status, exec_status); // Divergence proven
}
```

**Notes:**
- The simulation API is explicitly designed to allow transactions with invalid signatures (zero-padded) for estimation purposes, as documented
- However, keyless authenticators represent actual cryptographic authentication that should be validated even in simulation
- The `TRANSACTION_SIMULATION_ENHANCEMENT` feature flag addresses similar divergences in other validation paths, but keyless validation bypass is unconditional and not gated by this flag [1](#0-0) [4](#0-3)

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1802-1811)
```rust
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3348-3378)
```rust
    pub fn create_vm_and_simulate_signed_transaction(
        transaction: &SignedTransaction,
        state_view: &impl StateView,
    ) -> (VMStatus, TransactionOutput) {
        assert_err!(
            transaction.verify_signature(),
            "Simulated transaction should not have a valid signature"
        );

        let env = AptosEnvironment::new(state_view);
        let mut vm = AptosVM::new(&env);
        vm.is_simulation = true;

        let log_context = AdapterLogSchema::new(state_view.id(), 0);
        let original_view = state_view.as_move_resolver();
        let patched_view = Self::patch_randomness_seed(&original_view);
        let resolver = vm.as_move_resolver(&patched_view);
        let code_storage = state_view.as_aptos_code_storage(&env);

        let (vm_status, vm_output) = vm.execute_user_transaction(
            &resolver,
            &code_storage,
            transaction,
            &log_context,
            &AuxiliaryInfo::new_timestamp_not_yet_assigned(0),
        );
        let txn_output = vm_output
            .try_materialize_into_transaction_output(&resolver)
            .expect("Materializing aggregator V1 deltas should never fail");
        (vm_status, txn_output)
    }
```

**File:** api/src/transactions.rs (L1641-1642)
```rust
        let (vm_status, output) =
            AptosSimulationVM::create_vm_and_simulate_signed_transaction(&txn, &state_view);
```
