# Audit Report

## Title
Silent Configuration Deletion in Override Config Diff Leading to Unintended Network Exposure

## Summary
The `diff_override_config_yaml()` function in `override_node_config.rs` fails to detect when configuration keys are deleted (set to empty/None) in override configs when those keys have `skip_serializing_if` attributes. This creates silent configuration inconsistencies where operators believe security-critical settings (like VFN network disablement) are applied, but the base values are actually preserved during config merges. [1](#0-0) 

## Finding Description

The vulnerability exists in the diff generation logic that only iterates over keys present in `override_mapping`, never checking keys that exist in `base_mapping` but not in `override_mapping`. [2](#0-1) 

The critical issue arises with fields using `skip_serializing_if`, particularly `full_node_networks`: [3](#0-2) 

**Attack Scenario:**

1. **Base config** has VFN networks configured (validator serving fullnodes)
2. **Operator intent**: Disable VFN by setting `full_node_networks = vec![]`
3. **Bug trigger**: When serialized to YAML, empty vector is skipped (not in override_mapping)
4. **Missing detection**: Diff function never checks this base-only key
5. **Silent preservation**: Saved config omits the deletion
6. **Merge failure**: Later merge operations via `merge_node_config` preserve base VFN values [4](#0-3) 

The config is used in critical Helm deployments: [5](#0-4) 

## Impact Explanation

**Severity: High** (per Aptos bug bounty: "Significant protocol violations")

This qualifies as a significant protocol violation because:

1. **Security Boundary Breach**: VFN networks are security-critical - they control validator data access. The sanitizer enforces strict rules: [6](#0-5) 

2. **Silent Failure**: No errors or warnings - operators have false confidence in their security posture

3. **Infrastructure Impact**: Affects validator deployment pipelines (Helm/Kubernetes)

4. **Configuration Drift**: Deployed state differs from intended state, violating deterministic deployment assumptions

5. **Persistent Bug**: Once wrong config is saved, all subsequent deployments inherit the flaw

## Likelihood Explanation

**Likelihood: Medium to High**

Common scenarios triggering this bug:
- Operators reconfiguring VFN networks during maintenance
- Security hardening requiring network disablement  
- Automated config generation tools using OverrideNodeConfig
- CI/CD pipelines managing validator configs
- Any programmatic config manipulation using the override mechanism

The bug is deterministic and triggers whenever:
- Base has non-empty value for skip_serialized field
- Override sets it to empty/None
- Config is saved via `get_yaml()`

## Recommendation

Fix the `diff_override_config_yaml()` function to detect deletions by checking base-only keys:

```rust
fn diff_override_config_yaml(
    override_config: serde_yaml::Value,
    base_config: serde_yaml::Value,
) -> anyhow::Result<Option<serde_yaml::Value>> {
    match (override_config.clone(), base_config.clone()) {
        (
            serde_yaml::Value::Mapping(override_mapping),
            serde_yaml::Value::Mapping(base_mapping),
        ) => {
            let mut overrides = serde_yaml::Mapping::new();
            
            // Check keys in override
            for (override_key, override_value) in override_mapping.iter() {
                match base_mapping.get(override_key) {
                    Some(base_value) => {
                        if let Some(diff_value) =
                            diff_override_config_yaml(override_value.clone(), base_value.clone())?
                        {
                            overrides.insert(override_key.clone(), diff_value);
                        }
                    },
                    None => {
                        overrides.insert(override_key.clone(), override_value.clone());
                    },
                }
            }
            
            // NEW: Check for keys only in base (deletions)
            for (base_key, base_value) in base_mapping.iter() {
                if !override_mapping.contains_key(base_key) {
                    // Key exists in base but not in override - this is a deletion
                    // Explicitly include it as Null or default to mark the deletion
                    overrides.insert(base_key.clone(), serde_yaml::Value::Null);
                }
            }
            
            if overrides.is_empty() {
                Ok(None)
            } else {
                Ok(Some(serde_yaml::Value::Mapping(overrides)))
            }
        },
        // ... rest of match arms unchanged
    }
}
```

## Proof of Concept

Add this test to `config/src/config/override_node_config.rs` to demonstrate the bug:

```rust
#[test]
fn test_missing_key_detection_bug() {
    use crate::config::NetworkConfig;
    
    // Base has VFN network configured
    let mut base_config = NodeConfig::default();
    base_config.full_node_networks.push(NetworkConfig::default());
    
    // Override intentionally clears VFN networks (security hardening)
    let override_config = NodeConfig::default();
    assert!(override_config.full_node_networks.is_empty());
    
    let override_node_config = OverrideNodeConfig::new(override_config, base_config);
    
    // Get the diff - this should show the deletion, but BUG: it doesn't!
    let diff_yaml = override_node_config.get_yaml().unwrap();
    
    // The diff should contain full_node_networks: [] to show deletion
    // But due to skip_serializing_if, the key is missing entirely
    println!("Diff YAML: {:?}", diff_yaml);
    
    // When merged back with base, the base value will be preserved
    // This demonstrates the security issue: operator thinks VFN is disabled,
    // but it's actually still active after merge!
    assert!(
        diff_yaml.get("full_node_networks").is_none(),
        "BUG: full_node_networks deletion not detected in diff!"
    );
}
```

**Expected behavior**: Diff should explicitly show `full_node_networks: []` or `full_node_networks: null` to indicate deletion.

**Actual behavior**: Diff omits the key entirely, causing silent configuration inconsistency during merge operations.

## Notes

This vulnerability specifically affects fields with `skip_serializing_if` attributes throughout the config system: [7](#0-6) 

Other affected fields include TLS certificate paths, optional rate limiting configs, and various security-critical optional settings. The impact extends beyond just `full_node_networks` to any configuration field that can be intentionally disabled or cleared.

### Citations

**File:** config/src/config/override_node_config.rs (L10-77)
```rust
fn diff_override_config_yaml(
    override_config: serde_yaml::Value,
    base_config: serde_yaml::Value,
) -> anyhow::Result<Option<serde_yaml::Value>> {
    match (override_config.clone(), base_config.clone()) {
        (
            serde_yaml::Value::Mapping(override_mapping),
            serde_yaml::Value::Mapping(base_mapping),
        ) => {
            let mut overrides = serde_yaml::Mapping::new();
            for (override_key, override_value) in override_mapping {
                match base_mapping.get(&override_key) {
                    Some(base_value) => {
                        if let Some(diff_value) =
                            diff_override_config_yaml(override_value, base_value.clone())?
                        {
                            overrides.insert(override_key, diff_value);
                        }
                    },
                    None => {
                        overrides.insert(override_key, override_value);
                    },
                }
            }
            if overrides.is_empty() {
                Ok(None)
            } else {
                Ok(Some(serde_yaml::Value::Mapping(overrides)))
            }
        },
        (serde_yaml::Value::Mapping(_), _) => Ok(Some(override_config)),
        (serde_yaml::Value::Null, serde_yaml::Value::Null) => Ok(None),
        (serde_yaml::Value::Bool(override_value), serde_yaml::Value::Bool(base_value)) => {
            if override_value == base_value {
                Ok(None)
            } else {
                Ok(Some(override_config))
            }
        },
        (serde_yaml::Value::Number(override_value), serde_yaml::Value::Number(base_value)) => {
            if override_value == base_value {
                Ok(None)
            } else {
                Ok(Some(override_config))
            }
        },
        (serde_yaml::Value::String(override_value), serde_yaml::Value::String(base_value)) => {
            if override_value == base_value {
                Ok(None)
            } else {
                Ok(Some(override_config))
            }
        },
        (serde_yaml::Value::Sequence(override_value), serde_yaml::Value::Sequence(base_value)) => {
            if override_value == base_value {
                Ok(None)
            } else {
                Ok(Some(override_config))
            }
        },
        (_, serde_yaml::Value::Null) => Ok(Some(override_config)),
        (_, _) => bail!(
            "base does not match override: {:?}, {:?}",
            override_config,
            base_config
        ),
    }
}
```

**File:** config/src/config/node_config.rs (L56-57)
```rust
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
```

**File:** config/src/config/node_config.rs (L282-296)
```rust
pub fn merge_node_config(
    node_config: NodeConfig,
    override_node_config: serde_yaml::Value,
) -> Result<NodeConfig, Error> {
    serde_merge::tmerge::<NodeConfig, serde_yaml::Value, NodeConfig>(
        node_config,
        override_node_config,
    )
    .map_err(|e| {
        Error::Unexpected(format!(
            "Unable to merge default config with override. Error: {}",
            e
        ))
    })
}
```

**File:** testsuite/forge/src/config.rs (L177-183)
```rust
        Some(Arc::new(move |helm_values: &mut serde_yaml::Value| {
            if let Some(override_config) = &validator_override_node_config {
                helm_values["validator"]["config"] = override_config.get_yaml().unwrap();
            }
            if let Some(override_config) = &fullnode_override_node_config {
                helm_values["fullnode"]["config"] = override_config.get_yaml().unwrap();
            }
```

**File:** config/src/config/config_sanitizer.rs (L112-154)
```rust
fn sanitize_fullnode_network_configs(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FULLNODE_NETWORKS_SANITIZER_NAME.to_string();
    let fullnode_networks = &node_config.full_node_networks;

    // Verify that the fullnode network configs are not empty for fullnodes
    if fullnode_networks.is_empty() && !node_type.is_validator() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Fullnode networks cannot be empty for fullnodes!".into(),
        ));
    }

    // Check each fullnode network config and ensure uniqueness
    let mut fullnode_network_ids = HashSet::new();
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // Verify that the fullnode network config is not a validator network config
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }

        // Verify that the fullnode network config is unique
        if !fullnode_network_ids.insert(network_id) {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "Each fullnode network config must be unique! Found duplicate: {}",
                    network_id
                ),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/api_config.rs (L24-31)
```rust
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_cert_path: Option<String>,
    /// Path to a local TLS key to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_key_path: Option<String>,
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
```
