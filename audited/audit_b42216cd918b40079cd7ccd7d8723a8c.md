# Audit Report

## Title
Race Condition in `update_latest_ledger_info()` Allows Newer Ledger Info to be Overwritten with Older Version

## Summary
The `update_latest_ledger_info()` function contains a Time-Of-Check-Time-Of-Use (TOCTOU) race condition that allows a newer ledger info to be overwritten with an older one when multiple threads concurrently update the latest ledger info. This violates the monotonicity invariant of ledger progression and can cause consensus recovery failures.

## Finding Description
The vulnerability exists in the `update_latest_ledger_info()` function which performs a non-atomic check-then-set operation on the latest ledger info. [1](#0-0) 

The function executes the following steps:
1. **Line 65**: Reads the current latest ledger info via `get_latest_ledger_info_option()`
2. **Lines 66-69**: Checks if the current epoch is greater than the new epoch
3. **Line 71**: If not, sets the new latest ledger info via `set_latest_ledger_info()`

Although the underlying `ArcSwap` provides atomic load and store operations individually, the check-then-set pattern as a whole is **not atomic**. This creates a race window between lines 65 and 71. [2](#0-1) [3](#0-2) 

The vulnerability manifests when two code paths execute concurrently:

**Path A**: `finalize_state_snapshot()` calls `update_latest_ledger_info()` at line 236 without any lock: [4](#0-3) 

**Path B**: `commit_ledger()` calls `post_commit()` which directly calls `set_latest_ledger_info()` at line 665: [5](#0-4) 

While `commit_ledger()` uses a `commit_lock`, this lock is released before `post_commit()` executes. The `finalize_state_snapshot()` function uses no lock at all, allowing concurrent execution: [6](#0-5) 

**Attack Scenario**:
1. Initial state: Latest ledger info at epoch 100, version 10000
2. Thread A (finalize_state_snapshot): Starts `update_latest_ledger_info()` with epoch 105, version 10500
3. Thread A reads current epoch 100 (line 65)
4. Thread A checks 100 > 105 = false, proceeds to update
5. **[CONTEXT SWITCH]**
6. Thread B (post_commit): Calls `set_latest_ledger_info()` with epoch 110, version 11000
7. Latest ledger info is now epoch 110, version 11000
8. **[CONTEXT SWITCH BACK]**
9. Thread A executes `set_latest_ledger_info()` with epoch 105, version 10500 (line 71)
10. **Result**: Latest ledger info regresses from epoch 110 to epoch 105

This breaks the **State Consistency** invariant that state transitions must be atomic and the ledger must monotonically increase in version and epoch.

The latest ledger info is critical for consensus recovery and bootstrap operations: [7](#0-6) 

If consensus recovers from an incorrectly reverted ledger info, it may re-make decisions that were already committed, potentially creating conflicting blocks or state divergence across validators.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **State Inconsistency**: Different nodes may have different views of the "latest" committed state, violating the State Consistency invariant
2. **Consensus Recovery Failure**: When a validator restarts and calls `recover_from_ledger()`, it may bootstrap from an outdated ledger info, causing it to re-process old transactions or miss new ones
3. **Protocol Violation**: The ledger version and epoch are expected to be monotonically increasing, and this race breaks that fundamental guarantee

While this may not directly cause fund loss, it can lead to:
- Validators becoming out of sync with the network
- Incorrect reporting of blockchain state via APIs
- Potential liveness issues if validators disagree on current epoch
- Recovery to incorrect state after node crashes

This meets the High Severity criteria of "Significant protocol violations" and "State inconsistencies requiring intervention."

## Likelihood Explanation
The likelihood is **Medium** for the following reasons:

**Factors Increasing Likelihood**:
- The race window exists during every state sync operation
- No locking mechanism prevents concurrent execution
- State sync operations can take time, increasing the window for the race
- The comment in the code suggests design intent for mutual exclusion but provides no enforcement

**Factors Decreasing Likelihood**:
- The race window is relatively small (between reading and writing)
- Design intent is for consensus and state sync to "hand over" to each other
- In normal operation, these paths may rarely execute concurrently
- Most nodes are either syncing OR participating in consensus, not both simultaneously

However, during edge cases such as:
- Node restart while network is active
- Network partition recovery
- Transition from state sync to consensus mode
- Bugs in the handover logic

The race condition can be triggered, making this a real exploitable vulnerability.

## Recommendation
The issue should be fixed by making the check-then-set operation atomic. There are two approaches:

**Option 1: Use Compare-And-Swap (CAS)**
```rust
pub(crate) fn update_latest_ledger_info(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    let new_li = ledger_infos.last().unwrap().clone();
    let new_epoch = new_li.ledger_info().epoch();
    
    // Atomically update only if current epoch is less than new epoch
    ledger_metadata_db.latest_ledger_info.rcu(|current| {
        match current.as_ref() {
            Some(li) if li.ledger_info().epoch() > new_epoch => {
                // Don't update if current is newer
                Arc::clone(current)
            }
            _ => {
                // Update to new value
                Arc::new(Some(new_li.clone()))
            }
        }
    });
    
    Ok(())
}
```

**Option 2: Add Proper Locking**
Add a mutex around the latest_ledger_info updates and acquisitions to ensure mutual exclusion across both `update_latest_ledger_info()` and direct `set_latest_ledger_info()` calls.

**Option 3: Enforce Design Intent**
Ensure `finalize_state_snapshot()` acquires the same `commit_lock` before updating the latest ledger info, enforcing the stated design intent that consensus and state sync don't run concurrently.

## Proof of Concept
```rust
// Concurrent test demonstrating the race condition
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_update_latest_ledger_info_race_condition() {
        // Setup: Create AptosDB and initialize with epoch 100
        let tmpdir = tempfile::tempdir().unwrap();
        let db = Arc::new(AptosDB::new_for_test(&tmpdir));
        
        // Initial state: epoch 100, version 10000
        let initial_li = create_ledger_info(100, 10000);
        db.ledger_db.metadata_db().set_latest_ledger_info(initial_li);
        
        let db1 = Arc::clone(&db);
        let db2 = Arc::clone(&db);
        
        // Thread A: Tries to update to epoch 105
        let thread_a = thread::spawn(move || {
            let ledger_infos = vec![create_ledger_info(105, 10500)];
            // Add small delay to increase race window
            thread::sleep(Duration::from_millis(1));
            update_latest_ledger_info(
                db1.ledger_db.metadata_db(),
                &ledger_infos
            ).unwrap();
        });
        
        // Thread B: Updates to epoch 110 (should be final value)
        let thread_b = thread::spawn(move || {
            thread::sleep(Duration::from_millis(2));
            let li = create_ledger_info(110, 11000);
            db2.ledger_db.metadata_db().set_latest_ledger_info(li);
        });
        
        thread_a.join().unwrap();
        thread_b.join().unwrap();
        
        // Verify: Due to race, might have epoch 105 instead of 110
        let final_li = db.ledger_db.metadata_db().get_latest_ledger_info().unwrap();
        
        // This assertion may fail, demonstrating the race:
        // Expected: epoch 110 (Thread B's update should be final)
        // Actual: epoch 105 (Thread A overwrote Thread B's update)
        assert_eq!(final_li.ledger_info().epoch(), 110, 
            "Race condition: newer ledger info was overwritten!");
    }
}
```

## Notes
The vulnerability is exacerbated by the architectural assumption that consensus and state sync operations are mutually exclusive, but this assumption is not enforced by code-level synchronization primitives. The comment at lines 46-49 in `aptosdb_writer.rs` indicates design intent but provides no runtime guarantees. Any violation of this assumption—whether through bugs, edge cases, or future code changes—will trigger this race condition.

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L61-74)
```rust
pub(crate) fn update_latest_ledger_info(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    if let Some(li) = ledger_metadata_db.get_latest_ledger_info_option() {
        if li.ledger_info().epoch() > ledger_infos.last().unwrap().ledger_info().epoch() {
            // No need to update latest ledger info.
            return Ok(());
        }
    }
    ledger_metadata_db.set_latest_ledger_info(ledger_infos.last().unwrap().clone());

    Ok(())
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L94-98)
```rust
    pub(crate) fn get_latest_ledger_info_option(&self) -> Option<LedgerInfoWithSignatures> {
        let ledger_info_ptr = self.latest_ledger_info.load();
        let ledger_info: &Option<_> = ledger_info_ptr.deref();
        ledger_info.clone()
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L180-183)
```rust
    pub(crate) fn set_latest_ledger_info(&self, ledger_info_with_sigs: LedgerInfoWithSignatures) {
        self.latest_ledger_info
            .store(Arc::new(Some(ledger_info_with_sigs)));
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L89-92)
```rust
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L236-236)
```rust
            restore_utils::update_latest_ledger_info(self.ledger_db.metadata_db(), ledger_infos)?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L662-666)
```rust
        if let Some(x) = ledger_info_with_sigs {
            self.ledger_db
                .metadata_db()
                .set_latest_ledger_info(x.clone());

```

**File:** consensus/src/persistent_liveness_storage.rs (L109-129)
```rust
        // We start from the block that storage's latest ledger info, if storage has end-epoch
        // LedgerInfo, we generate the virtual genesis block
        let (latest_commit_id, latest_ledger_info_sig) =
            if self.storage_ledger.ledger_info().ends_epoch() {
                let genesis =
                    Block::make_genesis_block_from_ledger_info(self.storage_ledger.ledger_info());
                let genesis_qc = QuorumCert::certificate_for_genesis_from_ledger_info(
                    self.storage_ledger.ledger_info(),
                    genesis.id(),
                );
                let genesis_ledger_info = genesis_qc.ledger_info().clone();
                let genesis_id = genesis.id();
                blocks.push(genesis);
                quorum_certs.push(genesis_qc);
                (genesis_id, genesis_ledger_info)
            } else {
                (
                    self.storage_ledger.ledger_info().consensus_block_id(),
                    self.storage_ledger.clone(),
                )
            };
```
