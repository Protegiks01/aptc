# Audit Report

## Title
Waypoint Verification Bypass Allows Node Bootstrap with Corrupted State

## Summary
The `verify_waypoint_is_satisfiable()` function in the bootstrapper bypasses cryptographic hash verification when storage has synced beyond the waypoint version, allowing nodes to bootstrap with corrupted or malicious state that could lead to consensus violations and network partitions.

## Finding Description

In [1](#0-0) , the waypoint satisfiability check contains a critical vulnerability. When the node's local storage version is >= the waypoint version, the code immediately marks the waypoint as verified and returns without performing cryptographic verification.

A waypoint is a trust anchor containing both a version number and a cryptographic hash computed from specific LedgerInfo fields (epoch, root_hash, version, timestamp_usecs, next_epoch_state) as defined in [2](#0-1) . The proper verification process, shown in [3](#0-2) , requires checking BOTH the version match AND the hash match.

The correct waypoint verification flow is demonstrated in [4](#0-3) , where epoch ending ledger infos are properly verified by calling `waypoint.verify(ledger_info)` at the exact waypoint version.

However, the vulnerable code path only checks if `latest_ledger_info.ledger_info().version() >= waypoint_version` without verifying the hash. This means:

1. An attacker provides a node with a corrupted/malicious database file
2. The corrupted database has synced past the waypoint version but contains invalid state
3. On node restart, the bootstrapper calls `verify_waypoint_is_satisfiable()` 
4. The version check passes, waypoint is marked as verified without hash verification
5. At [5](#0-4) , the node skips fetching epoch ending ledger infos from the network
6. At [6](#0-5) , the node completes bootstrapping with corrupted state

The storage interface provides [7](#0-6)  to retrieve the ledger info at the waypoint version for proper verification, but this is never called.

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple critical impacts:

1. **Consensus Safety Violations**: Different nodes bootstrapping from different corrupted databases would have divergent state, breaking consensus invariant #2 and potentially causing permanent network partitions requiring a hard fork.

2. **State Consistency Violation**: Nodes accept state without Merkle proof verification, violating invariant #4 that "State transitions must be atomic and verifiable via Merkle proofs."

3. **Trust Anchor Bypass**: Waypoints are the fundamental trust mechanism for preventing nodes from accepting invalid state during bootstrapping. This bypass undermines the entire security model.

4. **Deterministic Execution Violation**: Nodes with corrupted state would execute transactions differently than honest nodes, breaking invariant #1.

This meets the Critical Severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**High Likelihood** due to:

1. **Attack Surface**: Any attacker with filesystem access to a node (compromised hosting, misconfigured permissions, malicious backup restoration, or stolen database files) can exploit this.

2. **No Special Privileges Required**: Does not require validator keys, consensus participation, or blockchain state manipulation - only database file replacement.

3. **Realistic Scenarios**:
   - Node operators restoring from untrusted backups
   - Compromised hosting environments
   - Malicious cloud providers
   - Supply chain attacks on database snapshots

4. **Automatic Exploitation**: Once a corrupted database is in place, the vulnerability triggers automatically on node restart with no additional interaction required.

## Recommendation

The `verify_waypoint_is_satisfiable()` function must retrieve the ledger info at the exact waypoint version from storage and verify its cryptographic hash before marking the waypoint as verified:

```rust
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    let waypoint = &self.driver_configuration.waypoint;
    let waypoint_version = waypoint.version();
    
    // If our storage has synced beyond the waypoint, verify it against storage
    let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    if latest_ledger_info.ledger_info().version() >= waypoint_version {
        // Retrieve the ledger info at the waypoint version from storage
        let waypoint_ledger_info = self.storage
            .get_epoch_ending_ledger_info(waypoint_version)
            .map_err(|error| {
                Error::StorageError(format!(
                    "Failed to get ledger info at waypoint version {}: {:?}",
                    waypoint_version, error
                ))
            })?;
        
        // Verify the waypoint hash matches
        waypoint.verify(waypoint_ledger_info.ledger_info()).map_err(|error| {
            Error::VerificationError(format!(
                "Waypoint verification failed for stored state at version {}: {:?}",
                waypoint_version, error
            ))
        })?;
        
        self.verified_epoch_states.set_verified_waypoint(waypoint_version);
        return Ok(());
    }
    
    // Rest of the function remains the same...
    // Check network peers for waypoint satisfiability
}
```

This ensures the cryptographic hash is verified even when bootstrapping from pre-synced storage.

## Proof of Concept

```rust
#[tokio::test]
#[should_panic(expected = "Waypoint verification failed")]
async fn test_waypoint_bypass_with_corrupted_storage() {
    // Create a valid waypoint at version 100
    let waypoint_version = 100;
    let waypoint_epoch = 10;
    let valid_ledger_info = create_epoch_ending_ledger_info_for_epoch(waypoint_version, waypoint_epoch);
    let waypoint = Waypoint::new_any(valid_ledger_info.ledger_info());
    
    // Create driver configuration with this waypoint
    let mut driver_configuration = create_full_node_driver_configuration();
    driver_configuration.waypoint = waypoint;
    
    // Create corrupted storage that has synced to version 200 
    // but has DIFFERENT state at waypoint version 100
    let corrupted_ledger_info = create_epoch_ending_ledger_info_for_epoch(waypoint_version + 50, waypoint_epoch);
    let mock_storage = create_mock_db_reader_with_corrupted_state(
        waypoint_version,
        corrupted_ledger_info, // Wrong hash at waypoint version
        200, // Latest synced version > waypoint
    );
    
    // Create bootstrapper with corrupted storage
    let mut bootstrapper = create_bootstrapper(
        driver_configuration,
        create_mock_streaming_client(),
        mock_storage,
        true,
    );
    
    // Create global summary indicating peers have valid data
    let global_data_summary = create_global_summary_with_version(waypoint_version, waypoint_version + 100);
    
    // Drive progress - should panic due to waypoint verification failure
    // But currently it bypasses verification and succeeds!
    drive_progress(&mut bootstrapper, &global_data_summary, true)
        .await
        .unwrap();
}
```

This test demonstrates that a node with corrupted storage past the waypoint version will bootstrap successfully without detecting the corruption, violating the fundamental trust assumption of waypoint-based verification.

**Notes**

The vulnerability exists because the early return optimization at lines 884-891 was likely intended to avoid redundant network queries when local storage is already ahead. However, this optimization incorrectly assumes that synced storage is always valid. The fix requires retrieving and verifying the ledger info specifically at the waypoint version from local storage before accepting it as trusted, similar to how [8](#0-7)  provides the capability to get epoch ending ledger info at any version for verification purposes.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L131-166)
```rust
    /// Attempts to verify the waypoint using the new epoch ending ledger info
    fn verify_waypoint(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        if !self.verified_waypoint {
            // Fetch the waypoint and ledger info versions
            let waypoint_version = waypoint.version();
            let ledger_info = epoch_ending_ledger_info.ledger_info();
            let ledger_info_version = ledger_info.version();

            // Verify we haven't missed the waypoint
            if ledger_info_version > waypoint_version {
                panic!(
                    "Failed to verify the waypoint: ledger info version is too high! Waypoint version: {:?}, ledger info version: {:?}",
                    waypoint_version, ledger_info_version
                );
            }

            // Check if we've found the ledger info corresponding to the waypoint version
            if ledger_info_version == waypoint_version {
                match waypoint.verify(ledger_info) {
                    Ok(()) => self.set_verified_waypoint(waypoint_version),
                    Err(error) => {
                        panic!(
                            "Failed to verify the waypoint: {:?}! Waypoint: {:?}, given ledger info: {:?}",
                            error, waypoint, ledger_info
                        );
                    },
                }
            }
        }

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L461-465)
```rust
        if self.should_fetch_epoch_ending_ledger_infos() {
            return self
                .fetch_epoch_ending_ledger_infos(global_data_summary)
                .await;
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L483-488)
```rust
        } else if highest_synced_version >= highest_known_ledger_version {
            // Otherwise, if we've already synced to the highest known version, there's nothing to do
            info!(LogSchema::new(LogEntry::Bootstrapper)
                .message(&format!("Highest synced version {} is >= highest known ledger version {}, nothing needs to be done.",
                    highest_synced_version, highest_known_ledger_version)));
            return self.bootstrapping_complete().await;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L884-891)
```rust
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }
```

**File:** types/src/waypoint.rs (L28-35)
```rust
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct Waypoint {
    /// The version of the reconfiguration transaction that is being approved by this waypoint.
    version: Version,
    /// The hash of the chosen fields of LedgerInfo.
    value: HashValue,
}
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** storage/storage-interface/src/lib.rs (L420-424)
```rust
        /// Get the ledger info of the epoch that `known_version` belongs to.
        fn get_epoch_ending_ledger_info(
            &self,
            known_version: u64,
        ) -> Result<LedgerInfoWithSignatures>;
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L156-165)
```rust
    /// Returns ledger info at a specified version, and ensures it's an epoch ending.
    pub(crate) fn get_epoch_ending_ledger_info(
        &self,
        version: Version,
    ) -> Result<LedgerInfoWithSignatures> {
        let epoch = self.get_epoch(version)?;
        let li = self
            .db
            .get::<LedgerInfoSchema>(&epoch)?
            .ok_or_else(|| AptosDbError::NotFound(format!("LedgerInfo for epoch {}.", epoch)))?;
```
