# Audit Report

## Title
Lack of Anomaly Detection and Missing Content Length Limits in Telemetry Service Enables Resource Exhaustion and Monitoring Blind Spots

## Summary
The Aptos telemetry service lacks anomaly detection mechanisms to identify compromised or malicious node behavior. Additionally, custom contract telemetry endpoints do not enforce content length limits, unlike standard telemetry endpoints, enabling unbounded payload attacks. These gaps prevent detection of malicious telemetry patterns and create resource exhaustion vulnerabilities.

## Finding Description

The telemetry service has three critical deficiencies:

**1. No Anomaly Detection Mechanism**

The telemetry data structures in `telemetry.rs` define only basic event and dump structures with no monitoring or detection logic: [1](#0-0) 

There are no mechanisms to:
- Detect unusual request frequencies from individual peers
- Identify abnormal data volumes or patterns
- Alert on behavioral changes (e.g., a validator suddenly reporting 100x more data)
- Flag potentially malicious telemetry designed to hide compromised node behavior

The metrics collection exists but lacks pattern analysis: [2](#0-1) 

**2. Missing Content Length Limits on Custom Contract Endpoints**

Standard telemetry endpoints enforce a 1MB limit: [3](#0-2) [4](#0-3) [5](#0-4) 

However, custom contract endpoints lack this protection: [6](#0-5) [7](#0-6) 

**3. No Rate Limiting**

No rate limiting exists on any telemetry endpoint, allowing authenticated nodes to flood the service with requests at arbitrary frequencies without detection or throttling.

**Attack Scenario:**

A compromised validator or malicious custom contract participant could:
1. Send extremely large payloads (multi-GB) to custom contract endpoints, causing memory exhaustion
2. Submit telemetry at extremely high frequency without detection
3. Report false metrics to hide malicious behavior (e.g., showing normal CPU while attacking consensus)
4. Flood backend systems (VictoriaMetrics, Loki, BigQuery) with junk data

## Impact Explanation

**Low Severity** - While this creates operational concerns, it falls under the "Network-level DoS attacks are out of scope" exclusion in the bug bounty rules. The vulnerability does not:
- Break consensus safety or liveness
- Enable fund theft or manipulation  
- Corrupt state or execution integrity
- Compromise validator operations directly

The impact is limited to:
- Resource exhaustion on telemetry infrastructure (operational issue)
- Monitoring blind spots for compromised nodes (detection gap)
- Potential costs from backend system overload

## Likelihood Explanation

**High Likelihood** for exploitation:
- Custom contract authentication is readily available to authorized participants
- No technical barriers prevent sending large payloads or high-frequency requests
- Attackers can easily script automated attacks
- Detection mechanisms are absent, making attacks difficult to identify

However, the **security impact is limited** because this is an infrastructure/monitoring concern rather than a direct protocol vulnerability.

## Recommendation

**1. Add Content Length Limits to Custom Contract Endpoints:**

```rust
// In custom_contract_ingest.rs - metrics_ingest function
pub fn metrics_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "metrics")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::header::optional("content-encoding"))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))  // ADD THIS
        .and(warp::body::bytes())
        .and_then(handle_metrics_ingest)
        .boxed()
}

// Similarly for log_ingest function
pub fn log_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "logs")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::header::optional("content-encoding"))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))  // ADD THIS
        .and(warp::body::bytes())
        .and_then(handle_log_ingest)
        .boxed()
}
```

**2. Implement Rate Limiting:**

Add per-peer rate limiting using the existing `aptos-rate-limiter` crate:

```rust
use aptos_rate_limiter::rate_limit::TokenBucketRateLimiter;

// In context.rs
pub struct Context {
    // ... existing fields
    rate_limiter: Arc<RwLock<TokenBucketRateLimiter<PeerId>>>,
}

// In handlers, check rate limit before processing
if !context.rate_limiter.write().consume(peer_id, 1) {
    return Err(reject::custom(ServiceError::too_many_requests()));
}
```

**3. Add Anomaly Detection Metrics:**

```rust
// Track per-peer statistics for anomaly detection
pub(crate) static PEER_REQUEST_VOLUME: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "telemetry_peer_request_volume_bytes",
        "Request body sizes by peer for anomaly detection",
        &["peer_id", "endpoint"],
        vec![1024.0, 10240.0, 102400.0, 1048576.0]  // 1KB, 10KB, 100KB, 1MB buckets
    ).unwrap()
});

pub(crate) static PEER_REQUEST_RATE: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "telemetry_peer_request_rate_total",
        "Total requests by peer for rate anomaly detection",
        &["peer_id", "endpoint", "time_window"]
    ).unwrap()
});
```

**4. Configure Alerting Rules:**

Add Prometheus alerting rules to detect anomalies:
- Requests exceeding 90th percentile for peer size/frequency
- Sudden spikes in telemetry volume from individual peers
- Peers sending data patterns inconsistent with their node type

## Proof of Concept

```rust
// PoC: Send unbounded payload to custom contract endpoint
use reqwest::Client;
use std::vec;

#[tokio::test]
async fn test_unbounded_custom_contract_payload() {
    let client = Client::new();
    
    // Authenticate and get JWT token for custom contract
    let auth_response = client
        .post("https://telemetry-service/custom-contract/test-contract/auth")
        .json(&auth_request)
        .send()
        .await
        .unwrap();
    
    let token = auth_response.text().await.unwrap();
    
    // Send 1GB payload - should be rejected but isn't
    let huge_payload = vec![0u8; 1_073_741_824]; // 1GB
    
    let response = client
        .post("https://telemetry-service/custom-contract/test-contract/ingest/metrics")
        .header("Authorization", format!("Bearer {}", token))
        .body(huge_payload)
        .send()
        .await
        .unwrap();
    
    // This succeeds when it should fail with 413 Payload Too Large
    assert_eq!(response.status(), 200);
}

// PoC: High-frequency requests without rate limiting
#[tokio::test] 
async fn test_no_rate_limiting() {
    let client = Client::new();
    let token = get_auth_token().await;
    
    // Send 10,000 requests rapidly - all should succeed without throttling
    for _ in 0..10000 {
        let response = client
            .post("https://telemetry-service/ingest/metrics")
            .header("Authorization", format!("Bearer {}", token))
            .body("test_metric{} 1")
            .send()
            .await
            .unwrap();
        
        assert_eq!(response.status(), 200);
    }
}
```

## Notes

This issue represents an **operational security gap** rather than a direct protocol vulnerability. While it doesn't compromise consensus, state integrity, or fund safety, it creates monitoring blind spots that could allow compromised nodes to evade detection. The missing content length limits on custom contract endpoints are the most concrete exploitable issue, but fall under the DoS exclusion in the bug bounty scope. Organizations operating Aptos telemetry infrastructure should prioritize implementing these recommendations for defense-in-depth.

### Citations

**File:** crates/aptos-telemetry-service/src/types/telemetry.rs (L8-31)
```rust
/// A useful struct for serialization a telemetry event
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TelemetryEvent {
    pub name: String,
    pub params: BTreeMap<String, String>,
}

/// A useful struct for serializing a telemetry dump
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TelemetryDump {
    pub client_id: String,
    pub user_id: String,
    pub timestamp_micros: String,
    pub events: Vec<TelemetryEvent>,
}

#[derive(Debug, Serialize, Clone)]
pub(crate) struct BigQueryRow {
    #[serde(flatten)]
    pub event_identity: EventIdentity,
    pub event_name: String,
    pub event_timestamp: u64,
    pub event_params: Vec<serde_json::Value>,
}
```

**File:** crates/aptos-telemetry-service/src/metrics.rs (L85-92)
```rust
pub(crate) static SERVICE_ERROR_COUNTS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "telemetry_web_service_internal_error_counts",
        "Service errors returned by the telemety web service by error_code",
        &["error_code"]
    )
    .unwrap()
});
```

**File:** crates/aptos-telemetry-service/src/constants.rs (L4-5)
```rust
/// The maximum content length to accept in the http body.
pub const MAX_CONTENT_LENGTH: u64 = 1024 * 1024;
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L22-38)
```rust
pub fn metrics_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "metrics")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
        .and(warp::header::optional(CONTENT_ENCODING.as_str()))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
        .and(warp::body::bytes())
        .and_then(handle_metrics_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L23-39)
```rust
pub fn log_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "logs")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownFullNode,
            NodeType::UnknownValidator,
        ]))
        .and(warp::header::optional(CONTENT_ENCODING.as_str()))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
        .and(warp::body::aggregate())
        .and_then(handle_log_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L29-38)
```rust
pub fn metrics_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "metrics")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::header::optional("content-encoding"))
        .and(warp::body::bytes())
        .and_then(handle_metrics_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/custom_contract_ingest.rs (L143-152)
```rust
pub fn log_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("custom-contract" / String / "ingest" / "logs")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_custom_contract_auth(context.clone()))
        .and(warp::header::optional("content-encoding"))
        .and(warp::body::bytes())
        .and_then(handle_log_ingest)
        .boxed()
}
```
