# Audit Report

## Title
Peer Scoring Bypass via Compression Validation Error Path in State-Sync Data Client

## Summary
The `send_request_to_peer_and_decode()` function in `state-sync/aptos-data-client/src/client.rs` separates the response context (containing the callback) from the response payload at line 737, but fails to invoke the callback when compression validation fails, allowing malicious peers to evade the peer scoring system. [1](#0-0) 

## Finding Description
The vulnerability occurs in the response handling flow where:

1. At line 737, `into_parts()` separates the `ResponseContext` (containing the `response_callback`) from the `StorageServiceResponse` payload
2. Lines 738-748 perform compression validation checks
3. **If compression validation fails, the function returns early with an error without invoking `context.response_callback.notify_bad_response()`**
4. The context is dropped, and the peer's score is never updated [1](#0-0) 

In contrast, when payload type conversion fails inside `spawn_blocking` (lines 752-763), the callback IS properly invoked to notify about the bad response: [2](#0-1) 

The peer scoring system is critical for state-sync security. When a peer sends invalid data, the `notify_bad_response()` callback updates the peer's score, eventually causing low-scoring peers to be ignored: [3](#0-2) [4](#0-3) 

**Attack Scenario:**
1. Malicious peer P connects to the network
2. Node N requests compressed data from P (`request.use_compression = true`)
3. P sends valid data but uncompressed (`storage_response.is_compressed() = false`)
4. Compression validation fails at line 738, returning `Error::InvalidResponse`
5. The `context` (containing callback) is dropped without calling `notify_bad_response()`
6. P's score remains unchanged (should be multiplied by `NOT_USEFUL_MULTIPLIER = 0.95`)
7. P can repeat this attack indefinitely without being ignored (threshold is `IGNORE_PEER_THRESHOLD = 25.0`) [5](#0-4) 

## Impact Explanation
**Medium Severity** - This issue qualifies as "State inconsistencies requiring intervention" under the Aptos bug bounty program because:

- **Undermines Peer Reputation System**: The peer scoring mechanism is a critical security control for state-sync. Bypassing it allows malicious peers to remain serviceable indefinitely.
- **Enables Targeted DoS**: Malicious peers can repeatedly send improperly compressed responses, forcing nodes to retry requests and waste bandwidth without consequence.
- **Degrades Network Quality**: Bad peers that should be filtered out continue to be selected, degrading overall state-sync performance and reliability.
- **Breaks Security Invariant**: The system assumes that all bad responses are tracked and penalized. This bypass violates that fundamental assumption.

While this doesn't directly cause consensus violations or loss of funds, it requires manual intervention to identify and block malicious peers that should have been automatically ignored by the scoring system.

## Likelihood Explanation
**High Likelihood:**

- **Trivial to Exploit**: Simply send responses with the wrong compression flag (single bit flip)
- **No Privileges Required**: Any peer can perform this attack
- **No Detection Mechanism**: Nodes cannot distinguish between accidental misconfiguration and intentional attacks
- **Repeatable**: Attack can be executed indefinitely on every request
- **Already Tested Scenario**: The codebase has tests for compression mismatches, but they don't verify callback invocation, suggesting this path is exercised but not secured [6](#0-5) 

The existing tests confirm compression mismatches return errors but don't verify that peer scores are updated, indicating this is a real gap in the implementation.

## Recommendation
Invoke the callback before returning from compression validation errors. The fix should be:

**Before line 739, add:**
```rust
// Notify about compression mismatch before returning error
if request.use_compression && !storage_response.is_compressed() {
    context.response_callback.notify_bad_response(ResponseError::InvalidData);
    return Err(Error::InvalidResponse(format!(
        "Requested compressed data, but the response was uncompressed! Response: {:?}",
        storage_response.get_label()
    )));
} else if !request.use_compression && storage_response.is_compressed() {
    context.response_callback.notify_bad_response(ResponseError::InvalidData);
    return Err(Error::InvalidResponse(format!(
        "Requested uncompressed data, but the response was compressed! Response: {:?}",
        storage_response.get_label()
    )));
}
```

This ensures the peer is properly penalized before the context is dropped.

## Proof of Concept
Add this test to `state-sync/aptos-data-client/src/tests/compression.rs`:

```rust
#[tokio::test]
async fn compression_mismatch_updates_peer_score() {
    use crate::peer_states::STARTING_SCORE;
    
    let base_config = utils::create_validator_base_config();
    let data_client_config = AptosDataClientConfig {
        use_compression: true,
        ignore_low_score_peers: false, // Don't ignore to track score changes
        ..Default::default()
    };
    
    let (mut mock_network, mut mock_time, client, poller) =
        MockNetwork::new(Some(base_config.clone()), Some(data_client_config), None);
    
    tokio::spawn(poller::start_poller(poller));
    
    let (peer, network_id) = utils::add_peer_to_network(
        PeerPriority::HighPriority, 
        &mut mock_network
    );
    
    // Setup peer advertisement
    utils::advance_polling_timer(&mut mock_time, &data_client_config).await;
    let network_request = utils::get_network_request(&mut mock_network, network_id).await;
    utils::handle_storage_summary_request(
        network_request,
        utils::create_storage_summary(200),
    );
    
    let transaction_range = CompleteDataRange::new(0, 200).unwrap();
    utils::wait_for_transaction_advertisement(
        &client,
        &mut mock_time,
        &data_client_config,
        transaction_range,
    ).await;
    
    // Get initial peer score
    let peer_states = client.get_peer_states();
    let initial_score = peer_states.peer_to_state.get(&peer)
        .map(|state| state.get_score())
        .unwrap_or(STARTING_SCORE);
    
    // Send uncompressed response when compressed was requested
    tokio::spawn(async move {
        let network_request = utils::get_network_request(&mut mock_network, network_id).await;
        utils::handle_transactions_request(network_request, false); // Send uncompressed
    });
    
    // Make request (will fail due to compression mismatch)
    let _ = client
        .get_transactions_with_proof(100, 50, 100, false, data_client_config.response_timeout_ms)
        .await;
    
    // Verify peer score was reduced
    let final_score = peer_states.peer_to_state.get(&peer)
        .map(|state| state.get_score())
        .unwrap_or(STARTING_SCORE);
    
    assert!(final_score < initial_score, 
        "Peer score should have been reduced after compression mismatch. Initial: {}, Final: {}", 
        initial_score, final_score);
}
```

**Expected Result**: Test currently **FAILS** because the peer score is not updated when compression validation fails.

**After Fix**: Test should **PASS** with the peer score properly reduced.

## Notes
This vulnerability demonstrates a classic error handling oversight where early returns bypass critical cleanup logic. The `ResponseContext` abstraction is correctly designed to track bad responses, but the compression validation path was implemented before extracting the context, creating this bypass. The fix ensures consistent error handling across all validation paths.

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L737-748)
```rust
        let (context, storage_response) = storage_response.into_parts();
        if request.use_compression && !storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested compressed data, but the response was uncompressed! Response: {:?}",
                storage_response.get_label()
            )));
        } else if !request.use_compression && storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested uncompressed data, but the response was compressed! Response: {:?}",
                storage_response.get_label()
            )));
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L757-760)
```rust
                    context
                        .response_callback
                        .notify_bad_response(ResponseError::InvalidPayloadDataType);
                    Err(err.into())
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L37-43)
```rust
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L167-174)
```rust
    /// Updates the score of the peer according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L302-322)
```rust
    /// Updates the score of the peer according to an error
    pub fn update_score_error(&self, peer: PeerNetworkId, error: ErrorType) {
        if let Some(mut entry) = self.peer_to_state.get_mut(&peer) {
            // Get the peer's old score
            let old_score = entry.score;

            // Update the peer's score with an error
            entry.update_score_error(error);

            // Log if the peer is now ignored
            let new_score = entry.score;
            if old_score > IGNORE_PEER_THRESHOLD && new_score <= IGNORE_PEER_THRESHOLD {
                info!(
                    (LogSchema::new(LogEntry::PeerStates)
                        .event(LogEvent::PeerIgnored)
                        .message("Peer will be ignored")
                        .peer(&peer))
                );
            }
        }
    }
```

**File:** state-sync/aptos-data-client/src/tests/compression.rs (L20-98)
```rust
#[tokio::test]
async fn compression_mismatch_disabled() {
    // Create a base config for a validator
    let base_config = utils::create_validator_base_config();

    // Create a data client config that disables compression
    let data_client_config = AptosDataClientConfig {
        use_compression: false,
        ..Default::default()
    };

    // Ensure the properties hold for all peer priorities
    for peer_priority in PeerPriority::get_all_ordered_priorities() {
        // Create the mock network, mock time, client and poller
        let (mut mock_network, mut mock_time, client, poller) =
            MockNetwork::new(Some(base_config.clone()), Some(data_client_config), None);

        // Start the poller
        tokio::spawn(poller::start_poller(poller));

        // Add a connected peer
        let (_, network_id) = utils::add_peer_to_network(peer_priority, &mut mock_network);

        // Advance time so the poller sends a data summary request
        utils::advance_polling_timer(&mut mock_time, &data_client_config).await;

        // Receive their request and respond
        let highest_synced_version = 100;
        let network_request = utils::get_network_request(&mut mock_network, network_id).await;
        let data_response = DataResponse::StorageServerSummary(utils::create_storage_summary(
            highest_synced_version,
        ));
        network_request.response_sender.send(Ok(
            StorageServiceResponse::new(data_response, false).unwrap()
        ));

        // Wait for the poller to process the response
        let transaction_range = CompleteDataRange::new(0, highest_synced_version).unwrap();
        utils::wait_for_transaction_advertisement(
            &client,
            &mut mock_time,
            &data_client_config,
            transaction_range,
        )
        .await;

        // Handle the client's transactions request using compression
        tokio::spawn(async move {
            loop {
                // Verify the received network request
                let network_request =
                    utils::get_network_request(&mut mock_network, network_id).await;
                assert!(!network_request.storage_service_request.use_compression);

                // Fulfill the request if it is for transactions
                if matches!(
                    network_request.storage_service_request.data_request,
                    DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                        start_version: 50,
                        end_version: 100,
                        proof_version: 100,
                        include_events: false,
                    })
                ) {
                    // Compress the response
                    utils::handle_transactions_request(network_request, true);
                }
            }
        });

        // The client should receive a compressed response and return an error
        let request_timeout = data_client_config.response_timeout_ms;
        let response = client
            .get_transactions_with_proof(100, 50, 100, false, request_timeout)
            .await
            .unwrap_err();
        assert_matches!(response, Error::DataIsUnavailable(_));
    }
}
```
