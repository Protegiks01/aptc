# Audit Report

## Title
Single-Validator Network Indefinite Liveness Failure on Consensus Key Mismatch

## Summary
In a single-validator network, when the validator's consensus key mismatches the expected key in the epoch state, the node fails to initialize SafetyRules correctly and cannot sign votes. The system does not detect this single-validator edge case and continues attempting to reach quorum indefinitely, resulting in permanent network liveness failure without operator notification or automatic recovery.

## Finding Description

The vulnerability occurs through the following execution path:

**1. Key Mismatch Detection:**
When SafetyRules initializes with an epoch change proof, it verifies that the validator's current consensus key matches the expected key from the epoch state. If there's a mismatch, it attempts to retrieve the correct key from persistent storage. If unsuccessful, it returns `Error::ValidatorKeyNotFound` and sets `validator_signer` to `None`. [1](#0-0) 

**2. Single-Validator Quorum Calculation:**
For single-validator networks, the `ValidatorVerifier::new_single()` helper creates a validator verifier with voting power 1 and calculates quorum as `total_voting_power * 2 / 3 + 1 = 1`. This means the single validator's vote is both necessary and sufficient for consensus. [2](#0-1) [3](#0-2) 

**3. Vote Signing Failure:**
When RoundManager attempts to create a vote for a proposal, it calls `vote_block()` which invokes SafetyRules' `construct_and_sign_vote_two_chain()`. This immediately calls `signer()` which returns `Error::NotInitialized` when `validator_signer` is `None`. [4](#0-3) [5](#0-4) 

**4. Silent Error Handling:**
When vote creation fails, the error propagates back to the event loop where it is merely logged and the `ERROR_COUNT` metric is incremented. The node continues processing events without retry logic or crash behavior. [6](#0-5) 

**5. Permanent Liveness Loss:**
In a single-validator network requiring 1 vote for quorum:
- The validator cannot sign votes (0 votes produced)
- Quorum cannot be reached (need 1, have 0)
- No blocks can be committed
- The network is permanently stuck

**6. No Special Handling:**
The codebase does not check if the network is a single-validator network (`validator_verifier.len() == 1`) to apply special error handling, immediate crash behavior, or critical alerting.

**7. Health Check Blind Spot:**
The consensus health check endpoint only verifies that the `CONSENSUS_EXECUTING_GAUGE` metric is set to 1, which indicates consensus is the active state sync component. It does not verify the validator's ability to actually sign votes. [7](#0-6) 

## Impact Explanation

**Severity: Medium** - This qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty program.

**Impact Details:**
- **Liveness Failure**: Total loss of network liveness - no blocks can be committed
- **No Automatic Recovery**: The validator continues running but cannot make progress
- **Silent Failure**: Only observable through ERROR_COUNT metric and warning logs
- **Operational Blindness**: Standard health checks pass despite inability to produce votes
- **Manual Intervention Required**: Operator must diagnose the issue and fix the key mismatch

**Scope Limitation:**
This affects only single-validator networks (e.g., local testnets, development environments). In multi-validator networks, other validators can still form quorum. However, single-validator networks are used for:
- Local development and testing
- Private/permissioned deployments
- Initial network bootstrapping

## Likelihood Explanation

**Likelihood: Low to Medium**

**Scenarios enabling this vulnerability:**
1. **Key Rotation Failure**: During consensus key rotation, if the new key is registered on-chain but not properly stored in the validator's secure storage
2. **Configuration Mismatch**: Validator restored from backup with outdated key material while on-chain state has newer keys
3. **Storage Corruption**: Persistent storage corruption causing key retrieval failure
4. **Manual Misconfiguration**: Operator error during validator setup or key management

**Likelihood factors:**
- **Higher in dev/test environments**: Single-validator networks are common for development
- **Lower in production**: Production networks typically use multiple validators for redundancy
- **Requires operational error**: Not exploitable without legitimate access and misconfiguration
- **No detection mechanism**: Silent failure makes the issue harder to prevent

## Recommendation

**Immediate Fix: Add Single-Validator Detection and Fail-Fast Behavior**

Modify `SafetyRules::guarded_initialize()` to detect single-validator networks and panic immediately on key mismatch:

```rust
fn guarded_initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error> {
    // ... existing initialization code ...
    
    let author = self.persistent_storage.author()?;
    let expected_key = epoch_state.verifier.get_public_key(&author);
    let is_single_validator = epoch_state.verifier.len() == 1;
    
    let initialize_result = match expected_key {
        None => Err(Error::ValidatorNotInSet(author.to_string())),
        Some(expected_key) => {
            let current_key = self.signer().ok().map(|s| s.public_key());
            if current_key == Some(expected_key.clone()) {
                info!(
                    SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Success),
                    "in set",
                );
                Ok(())
            } else {
                match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                    Ok(consensus_key) => {
                        self.validator_signer =
                            Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                        Ok(())
                    },
                    Err(Error::SecureStorageMissingDataError(error)) => {
                        let err = Error::ValidatorKeyNotFound(error);
                        // CRITICAL: In single-validator networks, key mismatch means 
                        // total liveness failure. Fail fast to alert operator immediately.
                        if is_single_validator {
                            panic!(
                                "CRITICAL: Single-validator network cannot sign votes due to key mismatch. \
                                 Expected key not found in storage. This will cause permanent liveness failure. \
                                 Error: {:?}", err
                            );
                        }
                        Err(err)
                    },
                    Err(error) => Err(error),
                }
            }
        },
    };
    
    initialize_result.inspect_err(|error| {
        info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
        self.validator_signer = None;
    })
}
```

**Additional Recommendations:**

1. **Enhanced Health Check**: Add a `can_sign_votes()` check to the consensus health endpoint
2. **Critical Alerting**: Emit critical alerts when SafetyRules initialization fails
3. **Startup Validation**: Verify validator can sign votes before marking node as healthy
4. **Metric Enhancement**: Add dedicated metric for key reconciliation failures

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
// File: consensus/safety-rules/src/tests/single_validator_key_mismatch.rs

#[test]
#[should_panic(expected = "Single-validator network cannot sign votes")]
fn test_single_validator_key_mismatch_causes_panic() {
    use crate::{PersistentSafetyStorage, SafetyRules};
    use aptos_crypto::bls12381::PrivateKey;
    use aptos_types::{
        epoch_state::EpochState,
        validator_verifier::{ValidatorConsensusInfo, ValidatorVerifier},
        validator_signer::ValidatorSigner,
    };
    
    // Setup: Create single-validator epoch state
    let correct_key = PrivateKey::generate_for_testing();
    let wrong_key = PrivateKey::generate_for_testing();
    let validator_signer = ValidatorSigner::new(
        aptos_types::account_address::AccountAddress::random(),
        wrong_key, // Using wrong key in signer
    );
    
    let validator_info = ValidatorConsensusInfo::new(
        validator_signer.author(),
        correct_key.public_key(), // Expected key in epoch state
        1,
    );
    
    // Single validator verifier
    let verifier = ValidatorVerifier::new(vec![validator_info]);
    assert_eq!(verifier.len(), 1); // Verify single-validator
    assert_eq!(verifier.quorum_voting_power(), 1);
    
    // Create SafetyRules with mismatched key
    let storage = PersistentSafetyStorage::in_memory(validator_signer);
    let mut safety_rules = SafetyRules::new(storage, false);
    
    // Create epoch change proof with correct key in epoch state
    let epoch_state = EpochState {
        epoch: 1,
        verifier,
    };
    let proof = create_epoch_change_proof(epoch_state);
    
    // This should panic in single-validator networks with the fix applied
    // Without the fix, it returns Error and node continues silently failing
    safety_rules.initialize(&proof).unwrap();
}
```

**Expected Behavior After Fix:**
- Single-validator networks with key mismatches panic immediately on initialization
- Operators receive clear error message about the critical failure
- Node fails to start, preventing silent liveness loss
- Multi-validator networks continue with existing error handling

**Notes**

The vulnerability is particularly insidious because:

1. **Silent Failure**: The node appears healthy from external monitoring but cannot make progress
2. **Misleading Health Checks**: The `/consensus_health_check` endpoint returns 200 even though votes cannot be signed
3. **No Retry Logic**: The system doesn't attempt to reload keys or recover from this state
4. **Single Point of Failure**: In single-validator networks, this one issue causes total network halt

This vulnerability demonstrates the importance of fail-fast behavior in distributed systems, especially for edge cases like single-validator deployments where redundancy cannot mask operational errors.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L123-127)
```rust
    pub(crate) fn signer(&self) -> Result<&ValidatorSigner, Error> {
        self.validator_signer
            .as_ref()
            .ok_or_else(|| Error::NotInitialized("validator_signer".into()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L312-343)
```rust
        let author = self.persistent_storage.author()?;
        let expected_key = epoch_state.verifier.get_public_key(&author);
        let initialize_result = match expected_key {
            None => Err(Error::ValidatorNotInSet(author.to_string())),
            Some(expected_key) => {
                let current_key = self.signer().ok().map(|s| s.public_key());
                if current_key == Some(expected_key.clone()) {
                    info!(
                        SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Success),
                        "in set",
                    );
                    Ok(())
                } else {
                    // Try to export the consensus key directly from storage.
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
                        },
                        Err(Error::SecureStorageMissingDataError(error)) => {
                            Err(Error::ValidatorKeyNotFound(error))
                        },
                        Err(error) => Err(error),
                    }
                }
            },
        };
        initialize_result.inspect_err(|error| {
            info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
            self.validator_signer = None;
        })
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L249-252)
```rust
    pub fn new_single(author: AccountAddress, public_key: PublicKey) -> Self {
        let validator_infos = vec![ValidatorConsensusInfo::new(author, public_key, 1)];
        Self::new(validator_infos)
    }
```

**File:** consensus/src/round_manager.rs (L1520-1527)
```rust
        let vote_result = self.safety_rules.lock().construct_and_sign_vote_two_chain(
            &vote_proposal,
            self.block_store.highest_2chain_timeout_cert().as_deref(),
        );
        let vote = vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {}",
            block_arc.block()
        ))?;
```

**File:** consensus/src/round_manager.rs (L2136-2142)
```rust
                        match result {
                            Ok(_) => trace!(RoundStateLogSchema::new(round_state)),
                            Err(e) => {
                                counters::ERROR_COUNT.inc();
                                warn!(kind = error_kind(&e), RoundStateLogSchema::new(round_state), "Error: {:#}", e);
                            }
                        }
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L20-48)
```rust
pub async fn handle_consensus_health_check(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Verify the node is a validator. If not, return an error.
    if !node_config.base.role.is_validator() {
        return (
            StatusCode::BAD_REQUEST,
            Body::from("This node is not a validator!"),
            CONTENT_TYPE_TEXT.into(),
        );
    }

    // Check the value of the consensus execution gauge
    let metrics = utils::get_all_metrics();
    if let Some(gauge_value) = metrics.get(CONSENSUS_EXECUTION_GAUGE) {
        if gauge_value == "1" {
            return (
                StatusCode::OK,
                Body::from("Consensus health check passed!"),
                CONTENT_TYPE_TEXT.into(),
            );
        }
    }

    // Otherwise, consensus is not executing
    (
        StatusCode::INTERNAL_SERVER_ERROR,
        Body::from("Consensus health check failed! Consensus is not executing!"),
        CONTENT_TYPE_TEXT.into(),
    )
}
```
