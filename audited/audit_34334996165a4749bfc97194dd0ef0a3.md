# Audit Report

## Title
Lost Update Vulnerability in NFT Metadata Crawler Status Tracking Due to Incorrect Conflict Resolution Strategy

## Summary
The `insert_request_statuses()` function in the NFT metadata crawler uses `on_conflict().do_nothing()` which prevents legitimate status corrections when the system recovers from partial failures, causing persistent data inconsistency between the `parsed_asset_uris` and `asset_uploader_request_statuses` tables. [1](#0-0) 

## Finding Description

The vulnerability arises from a race condition between two separate database transactions in the asset upload workflow combined with an overly conservative conflict resolution strategy.

**The Worker's Two-Phase Update:**
The worker updates two tables in separate transactions when completing an upload:

1. First, it updates `parsed_asset_uris` with the CDN image URI [2](#0-1) 

2. Then, it updates `asset_uploader_request_statuses` with the completion status [3](#0-2) 

These operations use separate database connections, creating two distinct transactions with no atomicity guarantee between them.

**The Critical Window:**
If the worker process crashes, restarts, or encounters an error between these two updates, the system enters an inconsistent state:
- `parsed_asset_uris` contains the CDN image URI (upload succeeded)
- `asset_uploader_request_statuses` still shows ACCEPTED status (202) with NULL CDN URI

**The Lost Update:**
When a client retries the same upload request (using the same idempotency key), the API:
1. Queries `parsed_asset_uris` and finds the CDN image URI exists [4](#0-3) 

2. Creates a "completed" status record with OK (200) status and the CDN URI

3. Attempts to insert this corrected status, but encounters a conflict on the composite key `(idempotency_key, application_id, asset_uri)`

4. The `do_nothing()` strategy silently ignores the insert, leaving the stale ACCEPTED status in place [5](#0-4) 

**Status Query Impact:**
Clients querying the status receive incorrect information because the query reads directly from the inconsistent `asset_uploader_request_statuses` table: [6](#0-5) 

This breaks the **State Consistency** invariant that state transitions must be atomic and databases must remain synchronized.

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

This qualifies as Medium severity under the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistency**: Two authoritative data sources (`parsed_asset_uris` and `asset_uploader_request_statuses`) become permanently desynchronized, requiring manual database intervention to correct.

2. **Incorrect Status Reporting**: Clients receive ACCEPTED (202) status for successfully completed uploads, causing operational confusion and potentially triggering unnecessary retry logic.

3. **Persistent Data Corruption**: Unlike transient failures, this inconsistency persists indefinitely because the `do_nothing()` strategy prevents automatic recovery through idempotent retries.

4. **No Direct Fund Loss**: While this is a legitimate data integrity issue, it doesn't directly impact on-chain funds or blockchain consensus, preventing it from reaching High or Critical severity.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is relatively likely to occur in production because:

1. **Common Failure Scenarios**: Worker processes can crash, restart, or encounter transient database errors between the two update operations. This is a normal occurrence in distributed systems.

2. **No Atomicity Protection**: The two database updates use separate connections without transaction coordination, creating a wide window for inconsistency.

3. **Idempotent Retry Pattern**: Clients are expected to retry failed requests using the same idempotency key, which is the exact scenario that triggers the lost update.

4. **No Self-Healing**: The system cannot automatically recover from this state. The `do_nothing()` strategy actively prevents recovery through normal API operations.

## Recommendation

Replace `do_nothing()` with `do_update()` in the `insert_request_statuses()` function to allow legitimate status corrections during idempotent retries:

```rust
fn insert_request_statuses(
    conn: &mut PooledConnection<ConnectionManager<PgConnection>>,
    request_statuses: &[AssetUploaderRequestStatuses],
) -> anyhow::Result<usize> {
    use schema::nft_metadata_crawler::asset_uploader_request_statuses::dsl::*;

    let query =
        diesel::insert_into(schema::nft_metadata_crawler::asset_uploader_request_statuses::table)
            .values(request_statuses)
            .on_conflict((idempotency_key, application_id, asset_uri))
            .do_update()
            .set((
                status_code.eq(excluded(status_code)),
                cdn_image_uri.eq(excluded(cdn_image_uri)),
                error_messages.eq(excluded(error_messages)),
                num_failures.eq(excluded(num_failures)),
            ));

    let debug_query = diesel::debug_query::<diesel::pg::Pg, _>(&query).to_string();
    debug!("Executing Query: {}", debug_query);
    query.execute(conn).context(debug_query)
}
```

This matches the pattern already used by the worker's `update_request_status()` function: [7](#0-6) 

**Alternative Solution**: Wrap both database updates in a single transaction to ensure atomicity, but this would require more extensive refactoring.

## Proof of Concept

**Setup**: Deploy the NFT metadata crawler with the current codebase.

**Step 1**: Initial upload request
```bash
curl -X POST http://api/upload \
  -H "Content-Type: application/json" \
  -d '{
    "idempotency_key": "test-key-001",
    "application_id": "test-app",
    "urls": ["https://example.com/asset1.png"]
  }'
```

**Step 2**: Simulate worker partial failure
- Worker successfully uploads asset to Cloudflare
- Worker updates `parsed_asset_uris` table (commits transaction)
- Simulate crash: Kill worker process before `update_request_status()` executes

**Step 3**: Verify inconsistent state
```sql
-- parsed_asset_uris shows completion
SELECT asset_uri, cdn_image_uri FROM parsed_asset_uris 
WHERE asset_uri = 'https://example.com/asset1.png';
-- Returns: cdn_image_uri = 'https://cdn.cloudflare.com/...'

-- asset_uploader_request_statuses shows pending
SELECT status_code, cdn_image_uri FROM asset_uploader_request_statuses 
WHERE idempotency_key = 'test-key-001' 
  AND asset_uri = 'https://example.com/asset1.png';
-- Returns: status_code = 202, cdn_image_uri = NULL
```

**Step 4**: Retry upload (idempotent retry)
```bash
curl -X POST http://api/upload \
  -H "Content-Type: application/json" \
  -d '{
    "idempotency_key": "test-key-001",
    "application_id": "test-app",
    "urls": ["https://example.com/asset1.png"]
  }'
```

**Step 5**: Verify lost update
```sql
SELECT status_code, cdn_image_uri FROM asset_uploader_request_statuses 
WHERE idempotency_key = 'test-key-001' 
  AND asset_uri = 'https://example.com/asset1.png';
-- Returns: status_code = 202, cdn_image_uri = NULL
-- Status remains ACCEPTED despite do_nothing() preventing the update to OK
```

**Step 6**: Verify client sees wrong status
```bash
curl http://api/status/test-app/test-key-001
# Returns: {"status_code": 202, ...} 
# Client believes upload is still in progress when it's actually complete
```

**Expected Behavior**: After Step 4, the status should update to 200 with the CDN URI populated, correcting the inconsistency.

**Actual Behavior**: The status remains at 202 with NULL CDN URI, preventing clients from accessing the completed upload.

---

**Notes**

This vulnerability is specific to the NFT metadata crawler's asset upload tracking system and does not directly impact blockchain consensus or on-chain state. However, it represents a legitimate data integrity issue in production infrastructure that causes operational problems and requires manual database intervention to resolve.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/api/upload_batch.rs (L24-40)
```rust
    let existing_rows = get_existing_rows(&mut conn, &request.urls)?;

    let mut request_statuses = vec![];
    for url in &request.urls {
        if let Some(cdn_image_uri) = existing_rows.get(url.as_str()) {
            request_statuses.push(AssetUploaderRequestStatuses::new_completed(
                &request.idempotency_tuple,
                url.as_str(),
                cdn_image_uri.as_deref().unwrap(), // Safe to unwrap because we checked for existence when querying
            ));
        } else {
            request_statuses.push(AssetUploaderRequestStatuses::new(
                &request.idempotency_tuple,
                url.as_str(),
            ));
        }
    }
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/api/upload_batch.rs (L66-81)
```rust
fn insert_request_statuses(
    conn: &mut PooledConnection<ConnectionManager<PgConnection>>,
    request_statuses: &[AssetUploaderRequestStatuses],
) -> anyhow::Result<usize> {
    use schema::nft_metadata_crawler::asset_uploader_request_statuses::dsl::*;

    let query =
        diesel::insert_into(schema::nft_metadata_crawler::asset_uploader_request_statuses::table)
            .values(request_statuses)
            .on_conflict((idempotency_key, application_id, asset_uri))
            .do_nothing();

    let debug_query = diesel::debug_query::<diesel::pg::Pg, _>(&query).to_string();
    debug!("Executing Query: {}", debug_query);
    query.execute(conn).context(debug_query)
}
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/throttler/mod.rs (L135-140)
```rust
            asset.cdn_image_uri.clone_from(&cdn_image_uri);

            // Update the asset URI in the parsed_asset_uris table
            let mut parsed_asset_uri = ParsedAssetUris::new(&asset.asset_uri);
            parsed_asset_uri.set_cdn_image_uri(cdn_image_uri);
            upsert_uris(&mut self.pool.get()?, &parsed_asset_uri, 0)?;
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/throttler/mod.rs (L151-151)
```rust
        self.update_request_status(&asset)?;
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/throttler/mod.rs (L354-373)
```rust
    fn update_request_status(&self, asset: &AssetUploaderRequestStatuses) -> anyhow::Result<()> {
        use schema::nft_metadata_crawler::asset_uploader_request_statuses::dsl::*;

        let query = diesel::insert_into(asset_uploader_request_statuses)
            .values(asset)
            .on_conflict((idempotency_key, application_id, asset_uri))
            .do_update()
            .set((
                status_code.eq(excluded(status_code)),
                error_messages.eq(excluded(error_messages)),
                cdn_image_uri.eq(excluded(cdn_image_uri)),
                num_failures.eq(excluded(num_failures)),
                inserted_at.eq(excluded(inserted_at)),
            ));

        let debug_query = diesel::debug_query::<diesel::pg::Pg, _>(&query).to_string();
        debug!("Executing Query: {}", debug_query);
        query.execute(&mut self.pool.get()?)?;
        Ok(())
    }
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/api/get_status.rs (L24-36)
```rust
    for row in rows {
        if row.status_code == StatusCode::OK.as_u16() as i64 {
            status_response.insert(row.asset_uri, GetStatusResponseSuccess::Success {
                status_code: StatusCode::OK.as_u16(),
                cdn_image_uri: row.cdn_image_uri.unwrap_or_default(),
            });
        } else {
            status_response.insert(row.asset_uri, GetStatusResponseSuccess::Error {
                status_code: row.status_code as u16,
                error_message: row.error_messages,
            });
        };
    }
```
