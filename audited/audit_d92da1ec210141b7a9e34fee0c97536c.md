# Audit Report

## Title
State Confusion Vulnerability in REST Client Transaction Waiting Logic Allows Malicious Fullnodes to Cause False Transaction Expiration Reports

## Summary
The `wait_for_transaction_by_hash_inner()` function in the Aptos REST client contains a critical flaw where it trusts server-provided timestamps and transaction states to determine transaction expiration. A malicious fullnode operator can exploit this by returning alternating `Pending` and `NotFound` states with manipulated timestamps, causing the client to incorrectly conclude a successfully committed transaction has expired. [1](#0-0) 

## Finding Description

The vulnerability exists in the transaction waiting logic's state machine, which uses a `reached_mempool` flag to track whether a transaction was ever seen as pending. The critical flaw is in how this flag is used to make strong assertions about transaction finality: [2](#0-1) 

The attack exploits three key weaknesses:

1. **Trusted Server Timestamps**: The expiration check relies entirely on the server-provided `state.timestamp_usecs` value, which is extracted from HTTP response headers: [3](#0-2) 

2. **Irreversible State Flag**: Once `reached_mempool = true` is set, it never resets, even if the transaction has been committed and removed from mempool.

3. **False Guarantee**: The error message at line 791 claims "It is guaranteed it will not be committed on chain" - this is FALSE when trusting an untrusted fullnode's responses.

**Attack Sequence**:
1. User submits transaction with expiration timestamp T to malicious fullnode
2. Malicious node accepts transaction, returns `Pending` status â†’ sets `reached_mempool = true`
3. Malicious node forwards transaction to network where it successfully commits at time T-10 seconds
4. User's client continues polling the malicious node
5. Malicious node intentionally returns `NotFound` (404) with manipulated `X-APTOS-LEDGER-TIMESTAMP` header showing time > T
6. Client hits lines 789-791: expiration check passes, `reached_mempool` is true
7. Client returns error: "Used to be pending and now not found. Transaction expired. It is guaranteed it will not be committed on chain."
8. **Reality**: Transaction is successfully committed on-chain, but client believes it failed [4](#0-3) 

The transaction lookup logic queries a single node's view without any verification against the actual blockchain state or cross-validation with multiple nodes.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

**1. API State Confusion**: The client receives fundamentally incorrect information about transaction status, causing applications built on the REST client to malfunction.

**2. Potential Loss of Funds**: 
- Users may retry transactions thinking they failed, potentially causing unintended double transactions (though sequence numbers provide some protection)
- Multi-step protocols may execute incorrectly if they rely on transaction confirmation
- DeFi applications may enter incorrect states leading to loss of funds

**3. Significant Protocol Violation**: The REST client is a critical component of the Aptos ecosystem used by wallets, dApps, and services. This vulnerability breaks the fundamental trust model where clients can reliably determine transaction outcomes.

**4. Wide Attack Surface**: Many users connect to public fullnodes, load-balanced endpoints, or third-party RPC providers they don't control. Any operator of such nodes can exploit this vulnerability.

**5. No User-Visible Warning**: Users have no way to detect they're being misled - the error message confidently asserts a guarantee that doesn't exist.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements**:
- Operator of a fullnode that users connect to (low barrier - anyone can run a fullnode)
- Ability to manipulate HTTP responses (trivial for node operator)
- No privileged validator access required
- No cryptographic attacks required

**Real-World Scenarios**:
1. **Malicious RPC Providers**: Third-party RPC providers could exploit users
2. **Compromised Fullnodes**: Legitimate nodes that get compromised
3. **Load-Balanced Environments**: Even non-malicious scenarios where different nodes in a pool have different sync states can cause this issue
4. **Network Partitions**: Temporary network issues causing nodes to have stale state

**Ease of Exploitation**: Trivial - requires only HTTP response manipulation with no complex timing or cryptographic operations.

## Recommendation

The fundamental issue is that the client trusts a single untrusted node's view for making strong finality assertions. The fix should:

1. **Never Trust Single Node Timestamps**: Use client-side time (`Instant::now()`) for expiration checks rather than server-provided timestamps
2. **Remove False Guarantees**: Change error messages to reflect uncertainty
3. **Implement Multi-Node Verification**: Query multiple nodes before concluding expiration
4. **Add Blockchain State Verification**: Check the actual ledger version range where the transaction could have been committed

**Recommended Code Fix**:

```rust
async fn wait_for_transaction_by_hash_inner<F, Fut, T>(
    &self,
    hash: HashValue,
    expiration_timestamp_secs: u64,
    max_server_lag_wait: Option<Duration>,
    timeout_from_call: Option<Duration>,
    fetch: F,
) -> AptosResult<Response<T>>
where
    F: Fn(HashValue) -> Fut,
    Fut: Future<Output = AptosResult<WaitForTransactionResult<T>>>,
{
    const DEFAULT_DELAY: Duration = Duration::from_millis(500);
    let mut reached_mempool = false;
    let start = std::time::Instant::now();
    
    loop {
        let mut chain_timestamp_usecs = None;
        
        // Use CLIENT-SIDE time for expiration check
        let current_time_secs = aptos_infallible::duration_since_epoch().as_secs();
        
        match fetch(hash).await {
            Ok(WaitForTransactionResult::Success(result)) => {
                return Ok(result);
            },
            Ok(WaitForTransactionResult::FailedExecution(vm_status)) => {
                return Err(anyhow!(
                    "Transaction committed on chain, but failed execution: {}",
                    vm_status
                ))?;
            },
            Ok(WaitForTransactionResult::Pending(state)) => {
                reached_mempool = true;
                
                // Check expiration using CLIENT time, not server time
                if current_time_secs > expiration_timestamp_secs {
                    return Err(anyhow!(
                        "Transaction expired based on client time. \
                        Note: Transaction may still commit if submitted before expiration."
                    ).into());
                }
                chain_timestamp_usecs = Some(state.timestamp_usecs);
            },
            Ok(WaitForTransactionResult::NotFound(error)) => {
                // Check expiration using CLIENT time
                if current_time_secs > expiration_timestamp_secs {
                    if reached_mempool {
                        return Err(anyhow!(
                            "Transaction not found after client-side expiration timeout. \
                            Transaction was previously pending but may have expired or been dropped. \
                            WARNING: If transaction was submitted before expiration, it may still commit."
                        ).into());
                    } else {
                        return Err(anyhow!(
                            "Transaction not found and client-side expiration timeout reached. \
                            Transaction was never seen in mempool. \
                            WARNING: If transaction was submitted to a different node before expiration, it may still commit."
                        ).into());
                    }
                }
                
                if let RestError::Api(aptos_error_response) = error {
                    if let Some(state) = aptos_error_response.state {
                        chain_timestamp_usecs = Some(state.timestamp_usecs);
                    }
                } else {
                    return Err(error);
                }
                
                sample!(
                    SampleRate::Duration(Duration::from_secs(30)),
                    debug!(
                        "Cannot yet find transaction in mempool on {:?}, continuing to wait.",
                        self.path_prefix_string(),
                    )
                );
            },
            Err(err) => {
                debug!("Fetching error, will retry: {}", err);
            },
        }
        
        // Keep existing timeout checks...
        // (rest of function remains the same)
    }
}
```

**Key Changes**:
1. Use `aptos_infallible::duration_since_epoch().as_secs()` (client time) for all expiration checks
2. Remove false guarantees from error messages
3. Add warnings that transactions may still commit
4. Consider server timestamps only for informational logging, not security decisions

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_tests {
    use super::*;
    use mockito::{mock, server_url};
    use aptos_crypto::HashValue;
    
    #[tokio::test]
    async fn test_state_confusion_attack() {
        // Setup: Create a transaction that will "succeed" on-chain
        let txn_hash = HashValue::random();
        let expiration_time = aptos_infallible::duration_since_epoch().as_secs() + 10;
        
        // Step 1: First call returns Pending (sets reached_mempool = true)
        let pending_response = mock("GET", format!("/v1/transactions/by_hash/{}", txn_hash.to_hex_literal()).as_str())
            .with_status(200)
            .with_header("X-APTOS-LEDGER-TIMESTAMP", "1000000000")  
            .with_header("X-APTOS-CHAIN-ID", "1")
            .with_header("X-APTOS-LEDGER-VERSION", "1000")
            .with_header("X-APTOS-EPOCH", "1")
            .with_header("X-APTOS-LEDGER-OLDEST-VERSION", "0")
            .with_header("X-APTOS-BLOCK-HEIGHT", "100")
            .with_header("X-APTOS-OLDEST-BLOCK-HEIGHT", "0")
            .with_body(r#"{"type":"pending_transaction","hash":"0x..."}"#)
            .expect(1)
            .create();
        
        // Step 2: Simulate time passing and transaction committing on-chain
        tokio::time::sleep(Duration::from_secs(2)).await;
        
        // Step 3: Malicious node returns NotFound with FAKE future timestamp
        let fake_future_timestamp = (expiration_time + 1000) * 1_000_000; // microseconds
        let not_found_response = mock("GET", format!("/v1/transactions/by_hash/{}", txn_hash.to_hex_literal()).as_str())
            .with_status(404)
            .with_header("X-APTOS-LEDGER-TIMESTAMP", fake_future_timestamp.to_string())
            .with_header("X-APTOS-CHAIN-ID", "1")
            .with_header("X-APTOS-LEDGER-VERSION", "1100")
            .with_header("X-APTOS-EPOCH", "1")
            .with_header("X-APTOS-LEDGER-OLDEST-VERSION", "0")
            .with_header("X-APTOS-BLOCK-HEIGHT", "110")
            .with_header("X-APTOS-OLDEST-BLOCK-HEIGHT", "0")
            .with_body(r#"{"message":"Transaction not found","error_code":"transaction_not_found"}"#)
            .expect_at_least(1)
            .create();
        
        // Execute the attack
        let client = Client::new(Url::parse(&server_url()).unwrap());
        let result = client.wait_for_transaction_by_hash(
            txn_hash,
            expiration_time,
            Some(Duration::from_secs(5)),
            Some(Duration::from_secs(30)),
        ).await;
        
        // Verify exploitation: Client incorrectly reports transaction expired
        assert!(result.is_err());
        let err_msg = format!("{:?}", result.unwrap_err());
        assert!(err_msg.contains("expired") || err_msg.contains("guaranteed"));
        
        // In reality, the transaction succeeded on-chain, but client believes it failed!
        // This is the state confusion vulnerability.
        
        pending_response.assert();
        not_found_response.assert();
    }
}
```

**Notes**

This vulnerability fundamentally undermines the security assumption that clients can reliably determine transaction outcomes by querying a single node. The issue is particularly severe because:

1. The REST client is widely used across the Aptos ecosystem (wallets, dApps, CLIs)
2. Users commonly connect to untrusted fullnodes they don't operate
3. The false guarantee in the error message gives users false confidence
4. No warning or indication that the node's response might be untrustworthy

The fix must shift from trusting server timestamps to using client-side time and removing false finality guarantees when dealing with untrusted nodes.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L750-871)
```rust
    async fn wait_for_transaction_by_hash_inner<F, Fut, T>(
        &self,
        hash: HashValue,
        expiration_timestamp_secs: u64,
        max_server_lag_wait: Option<Duration>,

        timeout_from_call: Option<Duration>,
        fetch: F,
    ) -> AptosResult<Response<T>>
    where
        F: Fn(HashValue) -> Fut,
        Fut: Future<Output = AptosResult<WaitForTransactionResult<T>>>,
    {
        // TODO: make this configurable
        const DEFAULT_DELAY: Duration = Duration::from_millis(500);
        let mut reached_mempool = false;
        let start = std::time::Instant::now();
        loop {
            let mut chain_timestamp_usecs = None;
            match fetch(hash).await {
                Ok(WaitForTransactionResult::Success(result)) => {
                    return Ok(result);
                },
                Ok(WaitForTransactionResult::FailedExecution(vm_status)) => {
                    return Err(anyhow!(
                        "Transaction committed on chain, but failed execution: {}",
                        vm_status
                    ))?;
                },
                Ok(WaitForTransactionResult::Pending(state)) => {
                    reached_mempool = true;
                    if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                        return Err(anyhow!("Transaction expired. It is guaranteed it will not be committed on chain.").into());
                    }
                    chain_timestamp_usecs = Some(state.timestamp_usecs);
                },
                Ok(WaitForTransactionResult::NotFound(error)) => {
                    if let RestError::Api(aptos_error_response) = error {
                        if let Some(state) = aptos_error_response.state {
                            if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                                if reached_mempool {
                                    return Err(anyhow!("Used to be pending and now not found. Transaction expired. It is guaranteed it will not be committed on chain.").into());
                                } else {
                                    // We want to know whether we ever got Pending state from the mempool,
                                    // to warn in case we didn't.
                                    // Unless we are calling endpoint that is a very large load-balanced pool of nodes,
                                    // we should always see pending after submitting a transaction.
                                    // (i.e. if we hit the node we submitted a transaction to,
                                    // it shouldn't return NotFound on the first call)
                                    //
                                    // At the end, when the expiration happens, we might get NotFound or Pending
                                    // based on whether GC run on the full node to remove expired transaction,
                                    // so that information is not useful. So we need to keep this variable as state.
                                    return Err(anyhow!("Transaction expired, without being seen in mempool. It is guaranteed it will not be committed on chain.").into());
                                }
                            }
                            chain_timestamp_usecs = Some(state.timestamp_usecs);
                        }
                    } else {
                        return Err(error);
                    }
                    sample!(
                        SampleRate::Duration(Duration::from_secs(30)),
                        debug!(
                            "Cannot yet find transaction in mempool on {:?}, continuing to wait.",
                            self.path_prefix_string(),
                        )
                    );
                },
                Err(err) => {
                    debug!("Fetching error, will retry: {}", err);
                },
            }

            if let Some(max_server_lag_wait_duration) = max_server_lag_wait {
                if aptos_infallible::duration_since_epoch().as_secs()
                    > expiration_timestamp_secs + max_server_lag_wait_duration.as_secs()
                {
                    return Err(anyhow!(
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
                }
            }

            let elapsed = start.elapsed();
            if let Some(timeout_duration) = timeout_from_call {
                if elapsed > timeout_duration {
                    return Err(anyhow!(
                        "Timeout of {}s after calling wait_for_transaction reached. Warning, transaction ({}) might still succeed.",
                        timeout_duration.as_secs(),
                        hash,
                    ).into());
                }
            }

            if elapsed.as_secs() > 30 {
                sample!(
                    SampleRate::Duration(Duration::from_secs(30)),
                    debug!(
                        "Continuing to wait for transaction {}, ledger on endpoint ({}) is {}",
                        hash,
                        self.path_prefix_string(),
                        if let Some(timestamp_usecs) = chain_timestamp_usecs {
                            format!(
                                "{}s behind current time",
                                aptos_infallible::duration_since_epoch()
                                    .saturating_sub(Duration::from_micros(timestamp_usecs))
                                    .as_secs()
                            )
                        } else {
                            "unreachable".to_string()
                        },
                    )
                );
            }

            tokio::time::sleep(DEFAULT_DELAY).await;
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L886-911)
```rust
                let resp = self.get_transaction_by_hash_inner(hash).await?;
                if resp.status() != StatusCode::NOT_FOUND {
                    let txn_resp: Response<Transaction> = self.json(resp).await?;
                    let (transaction, state) = txn_resp.into_parts();

                    if !transaction.is_pending() {
                        if !transaction.success() {
                            Ok(WaitForTransactionResult::FailedExecution(
                                transaction.vm_status(),
                            ))
                        } else {
                            Ok(WaitForTransactionResult::Success(Response::new(
                                transaction,
                                state,
                            )))
                        }
                    } else {
                        Ok(WaitForTransactionResult::Pending(state))
                    }
                } else {
                    let error_response = parse_error(resp).await;
                    Ok(WaitForTransactionResult::NotFound(error_response))
                }
            },
        )
        .await
```

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```
