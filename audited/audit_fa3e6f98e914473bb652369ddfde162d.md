# Audit Report

## Title
Epoch Transition Verification Deadlock Causes Valid Transaction Rejection in Continuous Syncer

## Summary
The continuous syncer's proof verification logic fails during epoch transitions, causing nodes to incorrectly reject valid transactions. When the data streaming service provides a target ledger info from epoch N+1 while the node's speculative stream state is still at epoch N, the epoch mismatch check triggers a `VerificationError` before the node can process the epoch-ending transactions that would update its epoch state. This creates a deadlock where valid transactions are rejected during normal epoch transitions.

## Finding Description

The vulnerability exists in the transaction proof verification flow within the continuous syncer. The core issue is an ordering problem between epoch state verification and epoch state updates: [1](#0-0) 

The `process_transaction_or_output_payload` method first verifies the proof ledger info (line 293-298), then processes transactions (line 301-375), and finally updates the epoch state (line 382). The verification calls: [2](#0-1) 

Which delegates to: [3](#0-2) 

This verification method calls `epoch_state.verify()`, which performs a strict epoch equality check: [4](#0-3) 

The problem manifests when:

1. Node is syncing at version V-1 (epoch N)
2. Version V ends epoch N (contains `next_epoch_state` for epoch N+1)
3. Data streaming service selects a target ledger info at version V+100 (epoch N+1) from advertised data
4. Stream sends a batch containing transactions V to V+100 with target_ledger_info for epoch N+1
5. Continuous syncer attempts verification: `epoch_state.verify()` checks `self.epoch (N) == ledger_info.epoch() (N+1)` 
6. **Verification fails with `VerificationError: "LedgerInfo has unexpected epoch N+1, expected N"`**
7. Stream is reset before the node can process the epoch-ending transaction at version V

The epoch state update logic has a secondary issue: [5](#0-4) 

The `maybe_update_epoch_state` only updates when the ledger info version exactly matches `synced_version` and contains `next_epoch_state`. However, the target ledger info at epoch N+1 doesn't contain `next_epoch_state` (only epoch-ending ledger infos do), so even if verification succeeded, the epoch wouldn't update properly.

This breaks the **State Consistency** invariant that nodes must be able to continuously sync valid state transitions, and violates the protocol requirement that valid transactions with cryptographically valid proofs should be accepted.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator node slowdowns**: Nodes attempting to sync through epoch boundaries will repeatedly fail verification, reset their streams, and retry, causing significant synchronization delays.

2. **Significant protocol violations**: The protocol guarantees that transactions with valid proofs signed by 2f+1 validators should be accepted. This bug causes nodes to reject such valid transactions during the critical epoch transition period.

3. **Liveness impact**: While not total network liveness failure, this causes temporary unavailability for individual nodes during epoch transitions. Validators that fall behind during an epoch change may struggle to catch up, potentially affecting their participation in consensus.

4. **Network-wide synchronization issues**: During epoch changes, many nodes may simultaneously experience this issue, leading to cascading synchronization failures across the network.

The vulnerability does not directly cause fund loss or consensus safety violations, but significantly impacts network availability and node operational reliability during epoch transitionsâ€”a regular occurrence in the Aptos blockchain.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurring:

1. **Automatic trigger**: Happens naturally during every epoch transition when honest nodes are catching up
2. **No attacker required**: Simply requires normal network conditions where some nodes lag behind during epoch changes
3. **Predictable occurrence**: Epochs change at regular intervals based on `epoch_interval` configuration
4. **Broad impact**: Affects any node (validator or fullnode) that is syncing through an epoch boundary
5. **Currently observable**: This is likely already happening in production during epoch transitions but may be masked by stream retry logic

The vulnerability is **not exploitable for malicious purposes** (no way to profit or cause harm beyond what naturally occurs), but it represents a significant protocol bug that degrades system reliability during epoch transitions.

## Recommendation

Fix the ordering issue by allowing verification of ledger infos from the next epoch when processing epoch-ending transactions. The verification logic should be updated to:

```rust
pub fn verify_ledger_info_with_signatures(
    &mut self,
    ledger_info_with_signatures: &LedgerInfoWithSignatures,
) -> Result<(), Error> {
    let ledger_epoch = ledger_info_with_signatures.ledger_info().epoch();
    
    // Allow verification of next epoch if we're at an epoch boundary
    if ledger_epoch == self.epoch_state.epoch + 1 {
        // Next epoch is acceptable - we'll update after processing
        Ok(())
    } else if ledger_epoch == self.epoch_state.epoch {
        // Same epoch - verify normally
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    } else {
        // Epoch mismatch outside acceptable range
        Err(Error::VerificationError(format!(
            "Ledger info epoch {} is not within acceptable range (current: {}, next: {})",
            ledger_epoch,
            self.epoch_state.epoch,
            self.epoch_state.epoch + 1
        )))
    }
}
```

Additionally, improve `maybe_update_epoch_state` to properly detect epoch transitions by scanning the processed transaction range for epoch-ending versions, rather than relying solely on the target ledger info matching `synced_version`.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_epoch_transition_verification_failure() {
    // Setup: Create a node at version 999, epoch 5
    let mut continuous_syncer = create_test_continuous_syncer();
    let storage = create_mock_storage_at_version(999, 5);
    
    // Version 1000 ends epoch 5, contains next_epoch_state for epoch 6
    let epoch_ending_txn = create_epoch_ending_transaction(1000, 5);
    
    // Versions 1001+ are in epoch 6
    let epoch_6_txns = create_transactions_range(1001, 1100, 6);
    
    // Create target ledger info at version 1100, epoch 6
    // (as would be advertised by peers in epoch 6)
    let target_ledger_info = create_ledger_info_with_sigs(1100, 6);
    
    // Create payload combining epoch-ending txn and epoch 6 txns
    let payload = TransactionListWithProofV2 {
        transactions: [epoch_ending_txn].iter().chain(epoch_6_txns.iter()).collect(),
        first_transaction_version: Some(1000),
        ..
    };
    
    // Attempt to process - this should fail with VerificationError
    let result = continuous_syncer
        .process_transaction_or_output_payload(
            Arc::new(Mutex::new(None)),
            notification_metadata,
            target_ledger_info, // Epoch 6
            Some(payload),
            None,
            Some(1000),
        )
        .await;
    
    // Verify that we get VerificationError due to epoch mismatch
    assert!(matches!(result, Err(Error::VerificationError(msg)) if msg.contains("unexpected epoch 6, expected 5")));
    
    // Verify that valid transactions were rejected
    assert_eq!(storage.get_latest_version(), 999); // No progress made
}
```

## Notes

This vulnerability specifically affects the continuous syncing mode during epoch transitions. The bootstrapper component may have different behavior during initial sync. The issue is particularly impactful because:

1. Epoch transitions are frequent (every few hours depending on configuration)
2. The window of vulnerability spans from when the first epoch N+1 ledger info is advertised until all nodes complete syncing epoch N
3. The stream reset and retry mechanism provides resilience but causes performance degradation

The fix should maintain backward compatibility and not introduce new security issues. Careful consideration should be given to ensuring that allowing next-epoch ledger infos doesn't open up new attack vectors for malicious peers to cause state sync failures.

### Citations

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L275-384)
```rust
    async fn process_transaction_or_output_payload(
        &mut self,
        consensus_sync_request: Arc<Mutex<Option<ConsensusSyncRequest>>>,
        notification_metadata: NotificationMetadata,
        ledger_info_with_signatures: LedgerInfoWithSignatures,
        transaction_list_with_proof: Option<TransactionListWithProofV2>,
        transaction_outputs_with_proof: Option<TransactionOutputListWithProofV2>,
        payload_start_version: Option<Version>,
    ) -> Result<(), Error> {
        // Verify the payload starting version
        let payload_start_version = self
            .verify_payload_start_version(
                notification_metadata.notification_id,
                payload_start_version,
            )
            .await?;

        // Verify the given proof ledger info
        self.verify_proof_ledger_info(
            consensus_sync_request.clone(),
            notification_metadata.notification_id,
            &ledger_info_with_signatures,
        )
        .await?;

        // Execute/apply and commit the transactions/outputs
        let num_transactions_or_outputs = match self.get_continuous_syncing_mode() {
            ContinuousSyncingMode::ApplyTransactionOutputs => {
                if let Some(transaction_outputs_with_proof) = transaction_outputs_with_proof {
                    utils::apply_transaction_outputs(
                        &mut self.storage_synchronizer,
                        notification_metadata,
                        ledger_info_with_signatures.clone(),
                        None,
                        transaction_outputs_with_proof,
                    )
                    .await?
                } else {
                    self.reset_active_stream(Some(NotificationAndFeedback::new(
                        notification_metadata.notification_id,
                        NotificationFeedback::PayloadTypeIsIncorrect,
                    )))
                    .await?;
                    return Err(Error::InvalidPayload(
                        "Did not receive transaction outputs with proof!".into(),
                    ));
                }
            },
            ContinuousSyncingMode::ExecuteTransactions => {
                if let Some(transaction_list_with_proof) = transaction_list_with_proof {
                    utils::execute_transactions(
                        &mut self.storage_synchronizer,
                        notification_metadata,
                        ledger_info_with_signatures.clone(),
                        None,
                        transaction_list_with_proof,
                    )
                    .await?
                } else {
                    self.reset_active_stream(Some(NotificationAndFeedback::new(
                        notification_metadata.notification_id,
                        NotificationFeedback::PayloadTypeIsIncorrect,
                    )))
                    .await?;
                    return Err(Error::InvalidPayload(
                        "Did not receive transactions with proof!".into(),
                    ));
                }
            },
            ContinuousSyncingMode::ExecuteTransactionsOrApplyOutputs => {
                if let Some(transaction_list_with_proof) = transaction_list_with_proof {
                    utils::execute_transactions(
                        &mut self.storage_synchronizer,
                        notification_metadata,
                        ledger_info_with_signatures.clone(),
                        None,
                        transaction_list_with_proof,
                    )
                    .await?
                } else if let Some(transaction_outputs_with_proof) = transaction_outputs_with_proof
                {
                    utils::apply_transaction_outputs(
                        &mut self.storage_synchronizer,
                        notification_metadata,
                        ledger_info_with_signatures.clone(),
                        None,
                        transaction_outputs_with_proof,
                    )
                    .await?
                } else {
                    self.reset_active_stream(Some(NotificationAndFeedback::new(
                        notification_metadata.notification_id,
                        NotificationFeedback::PayloadTypeIsIncorrect,
                    )))
                    .await?;
                    return Err(Error::InvalidPayload(
                        "No transactions or output with proof was provided!".into(),
                    ));
                }
            },
        };
        let synced_version = payload_start_version
            .checked_add(num_transactions_or_outputs as u64)
            .and_then(|version| version.checked_sub(1)) // synced_version = start + num txns/outputs - 1
            .ok_or_else(|| Error::IntegerOverflow("The synced version has overflown!".into()))?;
        let speculative_stream_state = self.get_speculative_stream_state()?;
        speculative_stream_state.update_synced_version(synced_version);
        speculative_stream_state.maybe_update_epoch_state(ledger_info_with_signatures);

        Ok(())
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L423-466)
```rust
    /// Verifies the given ledger info to be used as a transaction or transaction
    /// output chunk proof. If verification fails, the active stream is terminated.
    async fn verify_proof_ledger_info(
        &mut self,
        consensus_sync_request: Arc<Mutex<Option<ConsensusSyncRequest>>>,
        notification_id: NotificationId,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // If we're syncing to a specific target, verify the ledger info isn't too high
        let sync_request_target = consensus_sync_request
            .lock()
            .as_ref()
            .and_then(|sync_request| sync_request.get_sync_target());
        if let Some(sync_request_target) = sync_request_target {
            let sync_request_version = sync_request_target.ledger_info().version();
            let proof_version = ledger_info_with_signatures.ledger_info().version();
            if sync_request_version < proof_version {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(Error::VerificationError(format!(
                    "Proof version is higher than the sync target. Proof version: {:?}, sync version: {:?}.",
                    proof_version, sync_request_version
                )));
            }
        }

        // Verify the ledger info state and signatures
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
        {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::PayloadProofFailed,
            )))
            .await?;
            Err(error)
        } else {
            Ok(())
        }
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L87-98)
```rust
    /// Updates the epoch state if we've hit the specified target ledger
    /// info version and the ledger info has a new epoch state.
    pub fn maybe_update_epoch_state(
        &mut self,
        ledger_info_with_signatures: LedgerInfoWithSignatures,
    ) {
        if let Some(epoch_state) = ledger_info_with_signatures.ledger_info().next_epoch_state() {
            if ledger_info_with_signatures.ledger_info().version() == self.synced_version {
                self.epoch_state = epoch_state.clone();
            }
        }
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L100-110)
```rust
    /// Verifies the given ledger info with signatures against the current epoch state
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```
