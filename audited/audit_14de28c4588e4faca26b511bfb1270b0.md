# Audit Report

## Title
Non-Atomic Pruner Progress Updates Cause Permanent Database Inconsistency and Potential Consensus Failures

## Summary
The `LedgerDb::write_pruner_progress()` method updates pruner progress across multiple databases using sequential, non-atomic writes. If a node crashes mid-execution, sub-pruners end up with inconsistent progress values. On restart, the catch-up logic in `TransactionAuxiliaryDataPruner::new()` and other sub-pruners unconditionally rolls back their progress to match the (potentially stale) `LedgerMetadataPruner` metadata_progress, creating permanent database inconsistency that violates critical state consistency invariants.

## Finding Description

The vulnerability exists in the pruner coordination mechanism between `LedgerMetadataPruner` and sub-pruners like `TransactionAuxiliaryDataPruner`. 

**Root Cause:** The `LedgerDb::write_pruner_progress()` method writes to all sub-databases sequentially without atomic guarantees: [1](#0-0) 

Each individual write is a separate database operation: [2](#0-1) [3](#0-2) 

**Attack Scenario:**

1. **Initial State**: All pruners at version 3000
2. **write_pruner_progress(5000) is called** during fast sync completion or by `LedgerPrunerManager::save_min_readable_version()`: [4](#0-3) 

3. **Partial Completion + Crash**:
   - EventPrunerProgress â†’ 5000 âœ“
   - PersistedAuxiliaryInfoPrunerProgress â†’ 5000 âœ“
   - TransactionAccumulatorPrunerProgress â†’ 5000 âœ“
   - **CRASH** ðŸ’¥
   - TransactionAuxiliaryDataPrunerProgress â†’ still 3000
   - LedgerPrunerProgress â†’ still 3000

4. **On Restart**, initialization occurs: [5](#0-4) 

   `metadata_progress` is read from `LedgerMetadataPruner`: [6](#0-5) 
   
   Returns 3000 (the stale value).

5. **Sub-pruner initialization cascades the incorrect progress**: [7](#0-6) 

   For EventStorePruner (which updated to 5000 before crash): [8](#0-7) 

   - `get_or_initialize_subpruner_progress` returns 5000 (existing value)
   - Calls `myself.prune(5000, 3000)` (empty range: 5000..3000)
   - **Progress is unconditionally updated to target_version (3000)**: [9](#0-8) 

6. **Result**: EventPrunerProgress rolled back from 5000 â†’ 3000, but actual data for versions 3000-4999 was already pruned. Permanent inconsistency.

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria for the following reasons:

1. **State Consistency Violation**: Breaks invariant #4 ("State transitions must be atomic and verifiable"). Different pruners now have inconsistent views of which data has been pruned.

2. **Consensus Risk**: If different validator nodes crash at different points during `write_pruner_progress()`, they end up with different pruned database states. This could cause:
   - Deterministic execution failures (invariant #1 violation)
   - State root mismatches between validators
   - Inability to sync or verify historical data

3. **Permanent Data Corruption**: The rollback is persisted to disk. There's no automatic recovery mechanism. The database remains in an inconsistent state permanently.

4. **Requires Manual Intervention**: Recovery requires manual database inspection and repair, qualifying as "State inconsistencies requiring intervention" (Medium severity minimum).

Given the potential for consensus impact if multiple nodes are affected differently, this escalates to **HIGH severity** (up to $50,000): "Significant protocol violations."

## Likelihood Explanation

**Likelihood: HIGH**

1. **Common Trigger Event**: Node crashes are common occurrences in production systems (power failures, OOM kills, hardware failures, software bugs)

2. **Write Window**: The vulnerability window exists during every call to `write_pruner_progress()`, which occurs:
   - During fast sync completion
   - When pruner target version is updated
   - Potentially during normal pruner operation checkpointing

3. **No Attacker Required**: This is a reliability bug that occurs naturally, not requiring malicious action

4. **Testnet/Mainnet Exposure**: Any Aptos node performing pruning is vulnerable

## Recommendation

**Immediate Fix**: Make `write_pruner_progress()` atomic using a single `SchemaBatch` across all databases, or add validation logic during sub-pruner initialization.

**Option 1 - Atomic Batch Write (Preferred)**:

```rust
// In LedgerDb::write_pruner_progress()
pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
    info!("Writing pruner progress {version} for all ledger sub pruners.");
    
    // Create a single batch for all metadata updates
    let mut batch = SchemaBatch::new();
    
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::EventPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::PersistedAuxiliaryInfoPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionAccumulatorPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionAuxiliaryDataPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionInfoPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::WriteSetPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::LedgerPrunerProgress,
        &DbMetadataValue::Version(version),
    )?;
    
    // Single atomic write to metadata DB
    self.ledger_metadata_db.write_schemas(batch)
}
```

**Option 2 - Defensive Initialization**:

```rust
// In TransactionAuxiliaryDataPruner::new() and other sub-pruners
pub(in crate::pruner) fn new(
    ledger_db: Arc<LedgerDb>,
    metadata_progress: Version,
) -> Result<Self> {
    let progress = get_or_initialize_subpruner_progress(
        ledger_db.transaction_auxiliary_data_db_raw(),
        &DbMetadataKey::TransactionAuxiliaryDataPrunerProgress,
        metadata_progress,
    )?;
    
    let myself = TransactionAuxiliaryDataPruner { ledger_db };
    
    // ONLY catch up if we're behind, never roll back
    if progress < metadata_progress {
        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up TransactionAuxiliaryDataPruner."
        );
        myself.prune(progress, metadata_progress)?;
    } else if progress > metadata_progress {
        // Log warning but don't roll back
        warn!(
            progress = progress,
            metadata_progress = metadata_progress,
            "TransactionAuxiliaryDataPruner ahead of metadata, keeping current progress"
        );
    }
    
    Ok(myself)
}
```

## Proof of Concept

**Rust Reproduction Steps**:

1. Set up an Aptos node with pruning enabled
2. Wait for normal operation with some pruning progress (e.g., version 1000)
3. Trigger `LedgerDb::write_pruner_progress(2000)` by initiating fast sync or manual call
4. Kill the process (SIGKILL) after 100ms to simulate crash mid-write
5. Restart the node
6. Query pruner progress for all sub-databases:
   ```rust
   let ledger_progress = ledger_db.metadata_db().get_pruner_progress()?;
   let event_progress = get_progress(event_db.db(), &DbMetadataKey::EventPrunerProgress)?;
   let aux_progress = get_progress(aux_db.db(), &DbMetadataKey::TransactionAuxiliaryDataPrunerProgress)?;
   ```
7. Observe inconsistent progress values
8. Check that sub-pruners with higher values got rolled back to ledger_progress

**Expected Result**: Some sub-pruners show version 2000, others show 1000. After restart, all show 1000 despite some having already pruned to 2000.

**Impact**: Database inconsistency where pruned data ranges differ across sub-components, violating state consistency invariants and potentially causing consensus divergence across nodes.

### Citations

**File:** storage/aptosdb/src/ledger_db/mod.rs (L373-388)
```rust
    pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        info!("Fast sync is done, writing pruner progress {version} for all ledger sub pruners.");
        self.event_db.write_pruner_progress(version)?;
        self.persisted_auxiliary_info_db
            .write_pruner_progress(version)?;
        self.transaction_accumulator_db
            .write_pruner_progress(version)?;
        self.transaction_auxiliary_data_db
            .write_pruner_progress(version)?;
        self.transaction_db.write_pruner_progress(version)?;
        self.transaction_info_db.write_pruner_progress(version)?;
        self.write_set_db.write_pruner_progress(version)?;
        self.ledger_metadata_db.write_pruner_progress(version)?;

        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L47-52)
```rust
    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.db.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L57-62)
```rust
    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.db.put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L80-89)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.ledger_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L118-134)
```rust
    pub fn new(
        ledger_db: Arc<LedgerDb>,
        internal_indexer_db: Option<InternalIndexerDB>,
    ) -> Result<Self> {
        info!(name = LEDGER_PRUNER_NAME, "Initializing...");

        let ledger_metadata_pruner = Box::new(
            LedgerMetadataPruner::new(ledger_db.metadata_db_arc())
                .expect("Failed to initialize ledger_metadata_pruner."),
        );

        let metadata_progress = ledger_metadata_pruner.progress()?;

        info!(
            metadata_progress = metadata_progress,
            "Created ledger metadata pruner, start catching up all sub pruners."
        );
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L152-155)
```rust
        let transaction_auxiliary_data_pruner = Box::new(TransactionAuxiliaryDataPruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
        )?);
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_metadata_pruner.rs (L58-63)
```rust
    pub(in crate::pruner) fn progress(&self) -> Result<Version> {
        self.ledger_metadata_db
            .get::<DbMetadataSchema>(&DbMetadataKey::LedgerPrunerProgress)?
            .map(|v| v.expect_version())
            .ok_or_else(|| AptosDbError::Other("LedgerPrunerProgress cannot be None.".to_string()))
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_auxiliary_data_pruner.rs (L25-35)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        TransactionAuxiliaryDataDb::prune(current_progress, target_version, &mut batch)?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionAuxiliaryDataPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        self.ledger_db
            .transaction_auxiliary_data_db()
            .write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_auxiliary_data_pruner.rs (L39-59)
```rust
    pub(in crate::pruner) fn new(
        ledger_db: Arc<LedgerDb>,
        metadata_progress: Version,
    ) -> Result<Self> {
        let progress = get_or_initialize_subpruner_progress(
            ledger_db.transaction_auxiliary_data_db_raw(),
            &DbMetadataKey::TransactionAuxiliaryDataPrunerProgress,
            metadata_progress,
        )?;

        let myself = TransactionAuxiliaryDataPruner { ledger_db };

        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up TransactionAuxiliaryDataPruner."
        );
        myself.prune(progress, metadata_progress)?;

        Ok(myself)
    }
```
