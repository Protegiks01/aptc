# Audit Report

## Title
Missing Uniqueness Validation for VFN Public Keys Enables Identity Confusion After Key Compromise

## Summary
The Aptos staking module lacks uniqueness validation for Validator Full Node (VFN) public keys in the `update_network_and_fullnode_addresses()` function. While duplicate keys are prevented during genesis, post-genesis updates allow multiple validators to register identical Noise protocol public keys. Combined with a compromised private key, this enables an attacker to impersonate multiple VFNs, causing identity confusion in network authentication.

## Finding Description

The vulnerability exists in the interaction between the staking module's address update mechanism and the network layer's authentication protocol.

**Location 1: Missing Uniqueness Check in Staking Module** [1](#0-0) 

The `update_network_and_fullnode_addresses()` function allows validators to update their fullnode network addresses without checking if the embedded public keys (extracted via `find_noise_proto()`) are already registered by other validators. The function only validates operator authentication, not key uniqueness.

**Location 2: Genesis-Only Uniqueness Validation** [2](#0-1) 

During genesis, there IS validation preventing duplicate fullnode public keys. However, this protection does not extend to post-genesis updates.

**Location 3: Network Authentication Mechanism** [3](#0-2) 

The network layer's `authenticate_inbound()` function validates connections by checking if the remote public key exists in the peer's key set (`peer.keys.contains(remote_public_key)`). It does NOT verify global uniqueness across all validators.

**Location 4: Peer Structure Allowing Multiple Keys** [4](#0-3) 

The `Peer` structure stores public keys in a `HashSet<x25519::PublicKey>`, allowing multiple keys per peer but no reverse mapping to detect if a single key belongs to multiple peers.

**Attack Scenario:**

1. Validator A operates a VFN with public key K and corresponding private key
2. Attacker compromises the private key for K (through operational security failure, not a protocol bug)
3. Attacker controls Validator B (either by registering as a new validator or compromising an operator account)
4. Attacker calls `update_network_and_fullnode_addresses()` on Validator B to register public key K in their fullnode addresses
5. Both Validator A and B now have key K in their trusted peer sets
6. When connecting to the network:
   - Attacker can send `peer_id = A` in the Noise handshake prologue
   - Complete the handshake using private key K
   - Network validates: "Does A's peer have key K?" → Yes, authenticated as A's VFN
   - OR send `peer_id = B` in the prologue with the same key → authenticated as B's VFN

**Broken Invariant:** The network assumes each VFN has a cryptographically unique identity. This vulnerability breaks that assumption by allowing key reuse, enabling an attacker to selectively impersonate multiple validator identities. [5](#0-4) 

The prologue containing `remote_peer_id` is not cryptographically authenticated—it's transmitted in plaintext before the Noise handshake. Only the public key is cryptographically proven through Diffie-Hellman exchanges. This creates an identity confusion vector when duplicate keys exist.

## Impact Explanation

**Severity: Medium**

This issue does NOT meet Critical or High severity because:
- **Prerequisite: Requires key compromise** - The attacker must first obtain a validator's VFN private key through operational security failures (not a protocol vulnerability)
- **Limited Scope** - Only affects VFN network identity, not consensus or validator-to-validator communication
- **Requires Validator Access** - Attacker must control a second validator account to register the duplicate key

However, it qualifies as **Medium severity** because:
- **State Inconsistency** - Creates network topology confusion requiring manual intervention
- **Trust Model Violation** - The network assumes validator VFNs have unique identities; this breaks that assumption
- **Defense-in-Depth Failure** - The protocol should prevent configuration errors that lead to security issues

Per Aptos bug bounty: "State inconsistencies requiring intervention" = Medium ($10,000).

## Likelihood Explanation

**Likelihood: Low to Medium**

Required conditions:
1. A validator's VFN private key must be compromised (operational security failure)
2. Attacker must control a second validator account (requires stake + operator access)
3. No automated detection exists to identify duplicate keys

While individual conditions have low probability, the **complete lack of validation** means if conditions align, exploitation is trivial.

## Recommendation

**Add uniqueness validation in `update_network_and_fullnode_addresses()`:**

```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
) acquires StakePool, ValidatorConfig, ValidatorSet {
    // ... existing validation ...
    
    // NEW: Validate fullnode public key uniqueness across all validators
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    let new_fullnode_keys = extract_public_keys(&new_fullnode_addresses);
    
    // Check against all active validators
    let i = 0;
    let len = vector::length(&validator_set.active_validators);
    while (i < len) {
        let other_validator = vector::borrow(&validator_set.active_validators, i);
        if (other_validator.addr != pool_address) {
            let other_config = borrow_global<ValidatorConfig>(other_validator.addr);
            let other_keys = extract_public_keys(&other_config.fullnode_addresses);
            assert!(
                !has_key_intersection(&new_fullnode_keys, &other_keys),
                error::invalid_argument(EDUPLICATE_FULLNODE_KEY)
            );
        };
        i = i + 1;
    };
    
    // ... rest of function ...
}
```

Add the error constant:
```move
const EDUPLICATE_FULLNODE_KEY: u64 = 30;
```

This mirrors the genesis validation logic but applies to all post-genesis updates.

## Proof of Concept

**Move Test:**

```move
#[test(aptos_framework = @0x1, validator_1 = @0x123, validator_2 = @0x456)]
#[expected_failure(abort_code = 0x1001e)] // EDUPLICATE_FULLNODE_KEY
fun test_duplicate_fullnode_key_rejected(
    aptos_framework: &signer,
    validator_1: &signer,
    validator_2: &signer
) {
    // Setup: Initialize two validators with different keys
    initialize_for_test(aptos_framework);
    
    let key_1 = x"c6b0..."; // Some x25519 public key
    let fullnode_addr_1 = create_network_address_with_key(key_1);
    
    stake::initialize_validator(
        validator_1,
        consensus_key_1,
        proof_of_possession_1,
        network_addr_1,
        fullnode_addr_1
    );
    
    let key_2 = x"a1b2..."; // Different key
    let fullnode_addr_2 = create_network_address_with_key(key_2);
    
    stake::initialize_validator(
        validator_2,
        consensus_key_2,
        proof_of_possession_2,
        network_addr_2,
        fullnode_addr_2
    );
    
    // Attack: Try to update validator_2's fullnode address to use validator_1's key
    let duplicate_fullnode_addr = create_network_address_with_key(key_1); // Reuse key_1
    
    // This should FAIL with EDUPLICATE_FULLNODE_KEY error
    stake::update_network_and_fullnode_addresses(
        validator_2,
        signer::address_of(validator_2),
        network_addr_2,
        duplicate_fullnode_addr
    );
}
```

**Current Behavior:** Test fails because the duplicate key is accepted.

**Expected Behavior (after fix):** Test passes with abort code `EDUPLICATE_FULLNODE_KEY`.

## Notes

While this vulnerability requires key compromise as a prerequisite (which is outside the protocol's control), the **lack of uniqueness validation** is a defense-in-depth failure. The protocol should prevent validators from registering duplicate keys, even accidentally, to maintain the network's identity model integrity. The fix prevents both malicious exploitation after key compromise and accidental configuration errors that could lead to network confusion.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L816-823)
```rust
                    if !unique_network_keys.insert(validator.full_node_network_public_key.unwrap())
                    {
                        errors.push(CliError::UnexpectedError(format!(
                            "Validator {} has a repeated full node network key {}",
                            name,
                            validator.full_node_network_public_key.unwrap()
                        )));
                    }
```

**File:** network/framework/src/noise/handshake.rs (L330-365)
```rust
        // extract prologue (remote_peer_id | self_public_key)
        let (remote_peer_id, self_expected_public_key) =
            client_message[..Self::PROLOGUE_SIZE].split_at(PeerId::LENGTH);

        // parse the client's peer id
        // note: in mutual authenticated network, we could verify that their peer_id is in the trust peer set now.
        // We do this later in this function instead (to batch a number of checks) as there is no known attack here.
        let remote_peer_id = PeerId::try_from(remote_peer_id)
            .map_err(|_| NoiseHandshakeError::InvalidClientPeerId(hex::encode(remote_peer_id)))?;
        let remote_peer_short = remote_peer_id.short_str();

        // reject accidental self-dials
        // this situation could occur either as a result of our own discovery
        // mis-configuration or a potentially malicious discovery peer advertising
        // a (loopback ip or mirror proxy) and our public key.
        if remote_peer_id == self.network_context.peer_id() {
            return Err(NoiseHandshakeError::SelfDialDetected);
        }

        // verify that this is indeed our public key
        let actual_public_key = self.noise_config.public_key();
        if self_expected_public_key != actual_public_key.as_slice() {
            return Err(NoiseHandshakeError::ClientExpectingDifferentPubkey(
                remote_peer_short,
                hex::encode(self_expected_public_key),
                hex::encode(actual_public_key.as_slice()),
            ));
        }

        // parse it
        let (prologue, client_init_message) = client_message.split_at(Self::PROLOGUE_SIZE);
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;

```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** config/src/config/network_config.rs (L460-504)
```rust
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}

impl Peer {
    /// Combines `Vec<NetworkAddress>` keys with the `HashSet` given
    pub fn new(
        addresses: Vec<NetworkAddress>,
        mut keys: HashSet<x25519::PublicKey>,
        role: PeerRole,
    ) -> Peer {
        let addr_keys = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto);
        keys.extend(addr_keys);
        Peer {
            addresses,
            keys,
            role,
        }
    }

    /// Combines two `Peer`.  Note: Does not merge duplicate addresses
    /// TODO: Instead of rejecting, maybe pick one of the roles?
    pub fn extend(&mut self, other: Peer) -> Result<(), Error> {
        if self.role == other.role {
            return Err(Error::InvariantViolation(format!(
                "Roles don't match self {:?} vs other {:?}",
                self.role, other.role
            )));
        }
        self.addresses.extend(other.addresses);
        self.keys.extend(other.keys);
        Ok(())
    }

    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
```
