# Audit Report

## Title
Named Address Mapping Confusion Enables Cross-Package Spec Module Injection

## Summary
The `merge_spec_modules::program()` function passes `named_address_maps` through without validation, allowing specification modules from packages with conflicting named address mappings to be incorrectly merged with target modules from other packages. This enables cross-package spec injection attacks that can compromise formal verification results and undermine security guarantees of the Aptos Framework.

## Finding Description

The vulnerability exists in the spec module merging logic where modules are matched by **unresolved named addresses** rather than their numerical address values. [1](#0-0) 

The `program()` function extracts `named_address_maps` from the input Program and passes it through unchanged in the output: [2](#0-1) 

The TODO comments explicitly flag this missing validation: [3](#0-2) [4](#0-3) 

The root cause is in the `module_key()` function, which creates keys for matching spec modules with target modules using raw `LeadingNameAccess_` values without resolving named addresses: [5](#0-4) 

The `LeadingNameAccess_` enum can be either a numerical address or a **named address**: [6](#0-5) 

**Attack Scenario:**

1. **MaliciousPackage** defines mapping: `AptosFramework = 0xBAD`
2. **MaliciousPackage** contains: `spec AptosFramework::coin { spec fun always_true(): bool { true } }`
3. **VictimPackage** defines mapping: `AptosFramework = 0x1` (legitimate address)
4. **VictimPackage** contains: `module AptosFramework::coin { ... }`
5. When compiled together, both have key: `(Some(Name("AptosFramework")), Symbol("coin"))`
6. The malicious spec module merges with the legitimate module
7. After expansion, the address resolves to VictimPackage's value (`0x1`), but the spec is from MaliciousPackage
8. Formal verification runs with incorrect/malicious specifications

Each package maintains its own `named_address_map` via `NamedAddressMapIndex`: [7](#0-6) 

During parsing, both targets and dependencies create `PackageDefinition` instances with their respective address maps: [8](#0-7) [9](#0-8) 

All packages' definitions (both source and lib) feed into the same spec module extraction: [10](#0-9) 

The merged spec modules are then processed in the expansion phase where named addresses are finally resolved, but by then it's too late - incorrect specs have already been merged: [11](#0-10) 

## Impact Explanation

This is a **HIGH severity** vulnerability because it undermines the formal verification security guarantees that protect the Aptos Framework:

1. **Compromised Verification Results**: Malicious specs can make vulnerable code pass formal verification by adding false invariants or weakening security properties
2. **Framework Security Risk**: The Aptos Framework extensively uses spec modules for security verification - incorrect specs could allow vulnerable framework code to be deployed
3. **Hidden Vulnerabilities**: Developers relying on Move Prover verification would have false confidence in code security
4. **Cross-Package Attack**: An attacker can inject specs into any module by creating a dependency with conflicting named address mappings

While this is a compile-time vulnerability affecting verification rather than runtime execution, it represents a "significant protocol violation" (High severity per bug bounty) because formal verification is a critical security control in the Move development process.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Multi-package compilation where a malicious package is included as a dependency
- Conflicting named address mappings between packages
- Target package relying on formal verification for security guarantees

This is realistic in scenarios where:
- Developers include third-party dependencies in their projects
- The Aptos Framework is compiled alongside community packages
- CI/CD pipelines run formal verification on multi-package builds

The TODO comments indicate this issue was recognized but not addressed, suggesting it's a known gap in the security model.

## Recommendation

**Fix 1: Resolve Named Addresses Before Merging**

Modify `extract_spec_modules()` and `merge_spec_modules()` to resolve named addresses to numerical addresses using each package's `named_address_map` before creating module keys: [12](#0-11) 

**Fix 2: Validate Address Mapping Consistency**

Implement the TODO validation to ensure packages don't have conflicting mappings for the same named address: [3](#0-2) 

**Fix 3: Restrict Spec Module Scope**

Prevent spec modules from dependencies from merging with source modules, allowing only specs from the same package to merge.

## Proof of Concept

**File: malicious_package/Move.toml**
```toml
[package]
name = "MaliciousPackage"

[addresses]
AptosFramework = "0xBAD"
```

**File: malicious_package/sources/malicious_spec.move**
```move
spec AptosFramework::coin {
    spec fun always_passes(): bool { true }
    
    spec transfer {
        // Malicious: weakens actual invariants
        ensures true;  
    }
}
```

**File: victim_package/Move.toml**
```toml
[package]
name = "VictimPackage"

[dependencies]
MaliciousPackage = { local = "../malicious_package" }

[addresses]  
AptosFramework = "0x1"
```

**File: victim_package/sources/coin.move**
```move
module AptosFramework::coin {
    public fun transfer(from: &signer, to: address, amount: u64) {
        // Implementation with actual security invariants
    }
}
```

**Compilation:**
```bash
cd victim_package
aptos move compile --named-addresses AptosFramework=0x1
```

**Result:** The malicious spec module from MaliciousPackage (with `AptosFramework=0xBAD`) incorrectly merges with the legitimate coin module from VictimPackage (with `AptosFramework=0x1`), causing `AptosFramework::coin` at address `0x1` to be verified with malicious specifications that weaken security invariants.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L25-30)
```rust
pub fn program(compilation_env: &mut CompilationEnv, prog: Program) -> Program {
    let Program {
        named_address_maps,
        source_definitions,
        lib_definitions,
    } = prog;
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L32-36)
```rust
    // Phase 1: extract all spec modules.
    let mut spec_modules = BTreeMap::new();
    let mut source_definitions = extract_spec_modules(&mut spec_modules, source_definitions);
    let mut lib_definitions = extract_spec_modules(&mut spec_modules, lib_definitions);

```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L64-68)
```rust
    Program {
        named_address_maps,
        source_definitions,
        lib_definitions,
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L71-106)
```rust
fn extract_spec_modules(
    spec_modules: &mut BTreeMap<(Option<LeadingNameAccess_>, Symbol), ModuleDefinition>,
    defs: Vec<PackageDefinition>,
) -> Vec<PackageDefinition> {
    // TODO check package name and address mappings line up
    defs.into_iter()
        .filter_map(
            |PackageDefinition {
                 package,
                 named_address_map,
                 def,
             }| {
                let def = match def {
                    Definition::Module(m) => {
                        Definition::Module(extract_spec_module(spec_modules, None, m)?)
                    },
                    Definition::Address(mut a) => {
                        let addr_ = Some(&a.addr.value);
                        a.modules = a
                            .modules
                            .into_iter()
                            .filter_map(|m| extract_spec_module(spec_modules, addr_, m))
                            .collect::<Vec<_>>();
                        Definition::Address(a)
                    },
                    Definition::Script(s) => Definition::Script(s),
                };
                Some(PackageDefinition {
                    package,
                    named_address_map,
                    def,
                })
            },
        )
        .collect()
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L127-127)
```rust
    // TODO check package name and address mappings line up
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/merge_spec_modules.rs (L162-171)
```rust
fn module_key(
    address_opt: Option<&LeadingNameAccess_>,
    m: &ModuleDefinition,
) -> (Option<LeadingNameAccess_>, Symbol) {
    let addr_ = match &m.address {
        Some(sp!(_, a_)) => Some(*a_),
        None => address_opt.copied(),
    };
    (addr_, m.name.value())
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs (L65-70)
```rust
#[derive(Debug, Clone)]
pub struct PackageDefinition {
    pub package: Option<Symbol>,
    pub named_address_map: NamedAddressMapIndex,
    pub def: Definition,
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs (L150-156)
```rust
/// - A named address
/// - An address numerical value
pub enum LeadingNameAccess_ {
    AnonymousAddress(NumericalAddress),
    Name(Name),
}
pub type LeadingNameAccess = Spanned<LeadingNameAccess_>;
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/mod.rs (L76-90)
```rust
    for IndexedPackagePath {
        package,
        path,
        named_address_map,
    } in targets
    {
        let (defs, comments, ds, file_hash) = parse_file(compilation_env, &mut files, path)?;
        source_definitions.extend(defs.into_iter().map(|def| PackageDefinition {
            package,
            named_address_map,
            def,
        }));
        source_comments.insert(file_hash, comments);
        diags.extend(ds);
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/mod.rs (L92-105)
```rust
    for IndexedPackagePath {
        package,
        path,
        named_address_map,
    } in deps
    {
        let (defs, _, ds, _) = parse_file(compilation_env, &mut files, path)?;
        lib_definitions.extend(defs.into_iter().map(|def| PackageDefinition {
            package,
            named_address_map,
            def,
        }));
        diags.extend(ds);
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L208-223)
```rust
    context.is_source_definition = true;
    for P::PackageDefinition {
        package,
        named_address_map,
        def,
    } in source_definitions
    {
        context.named_address_mapping = Some(named_address_maps.get(named_address_map));
        definition(
            &mut context,
            &mut source_module_map,
            &mut scripts,
            package,
            def,
        )
    }
```
