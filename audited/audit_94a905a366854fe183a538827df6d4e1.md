# Audit Report

## Title
Unverified Future Epoch Commit Decisions Enable Permanent Observer DoS and State Corruption

## Summary
The consensus observer's `process_commit_decision_message()` function fails to verify commit decisions for future epochs before updating the observer's root state and triggering state synchronization. An attacker can send a malicious commit decision with a forged signature for a future epoch, causing the observer to update its root to an invalid state, reject all legitimate commit decisions, and become permanently stuck.

## Finding Description

The vulnerability exists in the commit decision processing logic. [1](#0-0) 

The code only verifies commit decisions for the **current epoch**, but accepts and processes commit decisions for **future epochs** without any cryptographic verification: [2](#0-1) 

When a commit decision for a future epoch arrives, the verification at line 470 is skipped (since `commit_epoch != epoch_state.epoch`), and the code falls through to the state sync logic. The critical issue occurs here: [3](#0-2) 

At lines 520-522, the observer **unconditionally updates its root** to the unverified commit decision by calling `update_blocks_for_state_sync_commit()`: [4](#0-3) 

This root update is permanent and affects future commit decision validation. The `get_highest_committed_epoch_round()` function uses this root as the baseline: [5](#0-4) 

**Attack Path:**
1. Attacker sends malicious `CommitDecision` for epoch 100, round 1000 (far future) with forged signatures
2. Observer receives the message, checks if it's ahead of current highest committed block (passes)
3. Verification is skipped because `commit_epoch (100) != current_epoch_state.epoch (3)`
4. Observer updates root to the malicious commit (epoch 100, round 1000)
5. Observer triggers state sync to the non-existent target (will fail)
6. All future legitimate commit decisions with epoch ≤ 100 and round ≤ 1000 are **rejected** as "already committed"
7. Observer is permanently stuck, unable to process valid commits

The developers acknowledge this issue with a TODO comment: [6](#0-5) 

## Impact Explanation

This is **CRITICAL severity** per Aptos bug bounty criteria:

1. **Total loss of liveness/network availability**: Affected observer nodes become permanently unable to process consensus updates, requiring manual intervention or node restart with full state sync
2. **Consensus/Safety violations**: The observer's internal state (root) becomes corrupted with an unverified, potentially malicious commit decision
3. **Non-recoverable without intervention**: Once the root is corrupted, the node cannot self-recover and will continue rejecting legitimate commits

The attack affects consensus observer nodes, which are critical infrastructure for:
- Light clients and wallets that rely on observers for blockchain data
- Archive nodes and indexers that observe consensus without participating
- Monitoring and analytics infrastructure

The inability to verify future epoch commits is fundamental because `EpochState::verify()` requires epoch matching: [7](#0-6) 

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack complexity**: Very low - attacker only needs to craft and send a single malicious `CommitDecision` network message
- **Required privileges**: None - any network peer can send the message
- **Attack cost**: Negligible - no stake, gas, or computational resources required
- **Detection difficulty**: Low - the attack is subtle and may appear as a legitimate state sync failure
- **Affected systems**: All consensus observer nodes in the network

The attack is trivial to execute and has immediate impact.

## Recommendation

**Immediate Fix**: Reject commit decisions for future epochs entirely, or defer processing until the corresponding epoch state is available.

```rust
fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();
    
    // Check if behind highest committed block
    let get_highest_committed_epoch_round = self
        .observer_block_data
        .lock()
        .get_highest_committed_epoch_round();
    if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
        update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
        return;
    }
    
    update_metrics_for_commit_decision_message(peer_network_id, &commit_decision);
    
    let epoch_state = self.get_epoch_state();
    
    // NEW: Reject commit decisions for future epochs
    if commit_epoch > epoch_state.epoch {
        warn!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Rejecting commit decision for future epoch: {:?}. Current epoch: {}",
                commit_decision.proof_block_info(),
                epoch_state.epoch
            ))
        );
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    
    // Verify the commit decision (now guaranteed to be current epoch)
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        error!(/* ... */);
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    
    // Process verified commit decision...
    update_message_processing_latency_metrics(
        message_received_time,
        &peer_network_id,
        metrics::COMMIT_DECISION_LABEL,
    );
    
    if self.process_commit_decision_for_pending_block(&commit_decision) {
        return;
    }
    
    // Handle case where commit is ahead of ordered blocks
    let last_block = self.observer_block_data.lock().get_last_ordered_block();
    if commit_round > last_block.round() {
        // State sync to verified commit
        self.observer_block_data
            .lock()
            .update_blocks_for_state_sync_commit(&commit_decision);
        self.state_sync_manager.sync_to_commit(commit_decision, false);
    }
}
```

**Alternative approach**: Buffer future epoch commit decisions and verify them once the epoch state becomes available after epoch change.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_unverified_future_epoch_commit_dos() {
    // Setup: Create observer at epoch 3, round 100
    let observer = setup_consensus_observer(3, 100);
    
    // Attack: Malicious peer sends commit decision for epoch 100, round 1000
    let malicious_commit = create_commit_decision_with_invalid_signatures(100, 1000);
    let peer_id = create_test_peer_network_id();
    
    // Process the malicious commit decision
    observer.process_commit_decision_message(
        peer_id,
        Instant::now(),
        malicious_commit.clone(),
    );
    
    // Verify root has been corrupted
    let root = observer.observer_block_data.lock().root();
    assert_eq!(root.ledger_info().epoch(), 100);
    assert_eq!(root.ledger_info().round(), 1000);
    
    // Attack consequence: Legitimate commit at epoch 3, round 101 is rejected
    let legitimate_commit = create_valid_commit_decision(3, 101);
    observer.process_commit_decision_message(
        peer_id,
        Instant::now(),
        legitimate_commit,
    );
    
    // The legitimate commit is dropped because (3, 101) < (100, 1000)
    // Observer is now permanently stuck and cannot process any commits up to epoch 100
    verify_observer_stuck(observer);
}

fn create_commit_decision_with_invalid_signatures(epoch: u64, round: u64) -> CommitDecision {
    let block_info = BlockInfo::new(
        epoch,
        round,
        HashValue::random(),
        HashValue::random(),
        0,
        0,
        None,
    );
    let ledger_info = LedgerInfo::new(block_info, HashValue::random());
    // Create with INVALID/EMPTY signatures
    let ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        ledger_info,
        AggregateSignature::empty(), // Invalid signature
    );
    CommitDecision::new(ledger_info_with_sigs)
}
```

## Notes

This vulnerability demonstrates a critical gap in the consensus observer's security model. The inability to verify future epoch commit decisions, combined with unconditional root updates, creates a severe DoS vector. The TODO comment at line 497 indicates the developers were aware that future epoch handling needed improvement, but the current implementation allows state corruption before any verification can occur.

The fix must ensure that **all** commit decisions are cryptographically verified before any state updates occur, or future epoch commits should be explicitly rejected until the observer advances to that epoch through legitimate means.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L441-528)
```rust
    /// Processes the commit decision message
    fn process_commit_decision_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        message_received_time: Instant,
        commit_decision: CommitDecision,
    ) {
        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }

        // Update the metrics for the received commit decision
        update_metrics_for_commit_decision_message(peer_network_id, &commit_decision);

        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }

        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.

        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L131-141)
```rust
    /// Returns the highest committed block epoch and round
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L273-291)
```rust
    /// Updates the block data for the given commit decision
    /// that will be used by state sync to catch us up.
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```
