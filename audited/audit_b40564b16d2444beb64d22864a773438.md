# Audit Report

## Title
Privilege Escalation: Permissioned Signers Gain Master Signer Privileges When PERMISSIONED_SIGNER Feature is Disabled

## Summary
A critical privilege escalation vulnerability exists where permissioned signers (which should have restricted permissions) are incorrectly treated as master signers with full privileges when the `PERMISSIONED_SIGNER` feature flag is disabled. This occurs because `std::signer::borrow_address` lacks feature flag validation, while permission checks incorrectly return `true` (granting all permissions) for signers that `is_permissioned_signer()` identifies as non-permissioned.

## Finding Description

The vulnerability stems from an architectural mismatch between the VM-level signer representation and Move-level permission enforcement:

**The Core Issue:**

The `std::signer::borrow_address` native function does not validate the `PERMISSIONED_SIGNER` feature flag. [1](#0-0) 

This allows `std::signer::address_of()` to succeed on permissioned signers even when the feature is disabled. [2](#0-1) 

**The VM-Level Behavior:**

The underlying `SignerRef::borrow_signer()` implementation explicitly works for both Master and Permissioned signer variants without checking the variant tag, as documented in the code comments. [3](#0-2) 

**The Critical Permission Check Flaw:**

When the feature is disabled, `is_permissioned_signer()` deliberately returns `false` for all signers, even actual permissioned signers. [4](#0-3) 

The permission checking functions then treat these "non-permissioned" signers as master signers with unlimited permissions. [5](#0-4) 

**The Failed Mitigation:**

A feature-flag-aware version of `borrow_address` exists in `permissioned_signer.rs` that would prevent this issue. [6](#0-5) 

However, this implementation is registered for the `permissioned_signer` module, not the `signer` module. [7](#0-6) 

It is never called because it's not declared as a native function in the Move code, making it dead code. [8](#0-7) 

**Attack Scenario:**

1. Transaction begins with PERMISSIONED_SIGNER feature enabled
2. A permissioned signer is created with limited permissions (e.g., withdraw limit)
3. Feature flag is disabled via governance (e.g., due to discovered security issue)
4. Attacker continues using the permissioned signer
5. `signer::address_of()` succeeds despite feature being disabled
6. `is_permissioned_signer()` returns `false` (treating it as non-permissioned)
7. Permission checks like `check_permission_capacity_above()` return `true` (master signer privileges)
8. Attacker now has unrestricted access, bypassing all intended permission limits

## Impact Explanation

**Critical Severity** - This meets the "Loss of Funds" category in the Aptos bug bounty program.

The vulnerability enables privilege escalation from restricted to unrestricted access:

1. **Access Control Bypass**: Permissioned signers are designed to have limited capabilities (e.g., spending limits, specific operation restrictions). When treated as master signers, all restrictions are removed.

2. **Deterministic Execution Violation**: Different validators could process the same transaction differently depending on when they observe the feature flag change, potentially causing consensus divergence.

3. **Framework Security Model Breakdown**: The entire permissioned signer security model is predicated on permission enforcement. This vulnerability completely undermines that model during feature transitions.

The impact is particularly severe because:
- Feature flags can be toggled via governance proposals
- The transition window creates exploitable timing conditions
- Any framework function relying on permission checks becomes vulnerable
- Funds protected by permission-based access control can be stolen

## Likelihood Explanation

**High Likelihood** during feature flag transitions:

1. **Trigger Condition**: The vulnerability activates whenever the PERMISSIONED_SIGNER feature is disabled while permissioned signers exist or are being used.

2. **Realistic Scenarios**:
   - Governance disables the feature due to discovered bugs
   - Emergency feature rollback during incident response
   - Planned feature deprecation
   - Network upgrade with feature flag changes

3. **Exploitability**: 
   - No special privileges required
   - Attacker only needs a permissioned signer created before the feature was disabled
   - The signer type persists in transaction execution context
   - Standard framework functions unknowingly grant elevated privileges

4. **Attack Complexity**: Low - the vulnerability is automatically triggered by normal operations when the feature is disabled

## Recommendation

**Immediate Fix**: Implement feature flag checking in `std::signer::borrow_address` native function.

Modify `aptos-move/framework/move-stdlib/src/natives/signer.rs`:

```rust
fn native_borrow_address(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    let signer_reference = safely_pop_arg!(arguments, SignerRef);

    // Add feature flag check for permissioned signers
    if !context
        .get_feature_flags()
        .is_enabled(aptos_types::on_chain_config::FeatureFlag::PERMISSIONED_SIGNER)
        && signer_reference.is_permissioned()?
    {
        return SafeNativeResult::Err(SafeNativeError::Abort {
            abort_code: 9, // EPERMISSION_SIGNER_DISABLED
        });
    }

    context.charge(SIGNER_BORROW_ADDRESS_BASE)?;

    Ok(smallvec![signer_reference.borrow_signer()?])
}
```

**Additional Hardening**:
1. Remove the dead code in `permissioned_signer.rs::native_borrow_address` or properly wire it up
2. Add comprehensive tests for feature flag transition scenarios
3. Implement audit logging for permission escalation events
4. Consider making feature flag changes require delayed activation to allow cleanup

## Proof of Concept

```move
#[test_only]
module test_addr::privilege_escalation_poc {
    use std::signer;
    use aptos_framework::permissioned_signer;
    use aptos_framework::features;
    
    #[test(framework = @0x1, user = @0xcafe)]
    #[expected_failure(abort_code = 9, location = std::signer)]
    fun test_permissioned_signer_after_feature_disable(
        framework: &signer,
        user: &signer
    ) {
        // 1. Enable permissioned signer feature
        features::change_feature_flags(
            framework, 
            vector[features::get_permissioned_signer_feature()], 
            vector[]
        );
        
        // 2. Create permissioned handle and signer
        let handle = permissioned_signer::create_permissioned_handle(user);
        let perm_signer = permissioned_signer::signer_from_permissioned_handle(&handle);
        
        // 3. Verify it works when feature is enabled
        let addr = signer::address_of(&perm_signer);
        assert!(addr == signer::address_of(user), 1);
        
        // 4. Disable the feature
        features::change_feature_flags(
            framework,
            vector[],
            vector[features::get_permissioned_signer_feature()]
        );
        
        // 5. VULNERABILITY: This should fail but doesn't
        // signer::address_of() succeeds despite feature being disabled
        let addr_after_disable = signer::address_of(&perm_signer);
        
        // 6. The permissioned signer is now treated as master signer
        // with full permissions, bypassing all restrictions
        assert!(addr_after_disable == signer::address_of(user), 2);
        
        permissioned_signer::destroy_permissioned_handle(handle);
    }
}
```

This PoC demonstrates that `signer::address_of()` continues to work on permissioned signers after the feature is disabled, which combined with the permission check logic, results in privilege escalation.

## Notes

The vulnerability exists at the intersection of three layers:
1. **VM Layer**: Signer variants are structurally identical for address access
2. **Native Layer**: Feature flag validation missing in stdlib signer natives  
3. **Move Layer**: Permission checks assume feature flag consistency

The attempted fix in `permissioned_signer.rs` suggests this issue was previously identified but the mitigation was incorrectly implemented by registering it for the wrong module. This is a subtle but critical architecture flaw that requires fixing the native function registration and ensuring feature flag checks are consistently enforced across all signer operations.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/signer.rs (L27-40)
```rust
fn native_borrow_address(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    let signer_reference = safely_pop_arg!(arguments, SignerRef);

    context.charge(SIGNER_BORROW_ADDRESS_BASE)?;

    Ok(smallvec![signer_reference.borrow_signer()?])
}
```

**File:** aptos-move/framework/move-stdlib/sources/signer.move (L26-28)
```text
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2282-2287)
```rust
    pub fn borrow_signer(&self) -> PartialVMResult<Value> {
        // The signer is internally represented as an enum (Master or Permissioned), but both
        // variants store the account address at index 1. Thus, we can access it without checking
        // the variant tag.
        self.0.borrow_elem(MASTER_ADDRESS_FIELD_OFFSET, None)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/permissioned_signer.move (L161-169)
```text
    public fun is_permissioned_signer(s: &signer): bool {
        // When the permissioned signer is disabled, no one is able to construct a permissioned
        // signer. Thus we should return false here, as other on chain permission checks will
        // depend on this checks.
        if(!features::is_permissioned_signer_enabled()) {
            return false;
        };
        is_permissioned_signer_impl(s)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/permissioned_signer.move (L558-564)
```text
    public(package) fun check_permission_capacity_above<PermKey: copy + drop + store>(
        s: &signer, threshold: u256, perm: PermKey
    ): bool acquires PermissionStorage {
        if (!is_permissioned_signer(s)) {
            // master signer has all permissions
            return true
        };
```

**File:** aptos-move/framework/aptos-framework/sources/permissioned_signer.move (L633-635)
```text
    public fun borrow_address(_s: &signer): &address {
        abort error::permission_denied(EPERMISSION_SIGNER_DISABLED)
    }
```

**File:** aptos-move/framework/src/natives/permissioned_signer.rs (L128-151)
```rust
fn native_borrow_address(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(_ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    let signer_reference = safely_pop_arg!(arguments, SignerRef);

    if !context
        .get_feature_flags()
        .is_enabled(aptos_types::on_chain_config::FeatureFlag::PERMISSIONED_SIGNER)
        && signer_reference.is_permissioned()?
    {
        return SafeNativeResult::Err(SafeNativeError::Abort {
            abort_code: EPERMISSION_SIGNER_DISABLED,
        });
    }

    context.charge(SIGNER_BORROW_ADDRESS_BASE)?;

    Ok(smallvec![signer_reference.borrow_signer()?])
}
```

**File:** aptos-move/framework/src/natives/permissioned_signer.rs (L157-178)
```rust
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [
        (
            "is_permissioned_signer_impl",
            native_is_permissioned_signer_impl as RawSafeNative,
        ),
        (
            "is_permissioned_signer",
            native_is_permissioned_signer_impl as RawSafeNative,
        ),
        ("permission_address", native_permission_address),
        (
            "signer_from_permissioned_handle_impl",
            native_signer_from_permissioned,
        ),
        ("borrow_address", native_borrow_address),
    ];

    builder.make_named_natives(natives)
}
```
