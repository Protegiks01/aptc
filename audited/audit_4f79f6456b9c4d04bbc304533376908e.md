# Audit Report

## Title
Incomplete Recursive Type Validation for Struct Type Parameters in Entry Function Arguments

## Summary
The compile-time and runtime validation of entry function arguments fails to recursively validate type parameters of allowed struct types (Option, Object, String, FixedPoint32, FixedPoint64). This allows modules with invalid entry function signatures to be published and wastes gas when these functions are invoked.

## Finding Description

The `check_transaction_input_type()` function in `extended_checks.rs` performs compile-time validation of entry function parameters. When encountering a Struct type at line 257, it only validates whether the base struct type is in the allowed list, but completely ignores and does not validate the type parameters: [1](#0-0) 

The pattern match `Struct(mid, sid, _)` uses `_` to ignore the third parameter, which contains the type parameters. In contrast, Vector types ARE recursively validated: [2](#0-1) 

The same validation gap exists in the runtime validator `is_valid_txn_arg()`: [3](#0-2) 

This function also only checks if the struct name is in the allowed list, without recursively validating type parameters. The code comment explicitly states these two functions should be kept in sync: [4](#0-3) 

**Attack Path:**

1. Attacker publishes a module with an entry function like:
   ```move
   public entry fun attack(param: Option<&mut signer>) { }
   ```

2. The compile-time checker sees `Option<&mut signer>` and at line 257 matches it as a Struct type. It checks if `0x1::option::Option` is in the allowed list (it is) but does NOT validate the type parameter `&mut signer`.

3. Module publishing succeeds, storing an invalid module in blockchain state.

4. When a user attempts to call this function, runtime validation at line 142 calls `is_valid_txn_arg()`, which again only checks that `Option` is allowed, not its type parameter.

5. Type validation passes, and the system proceeds to argument construction at line 173-183.

6. Only during `recursively_construct_arg()` (line 330-405) when processing the constructor's parameters does it recursively validate the nested `&mut signer` type and fail at line 400: [5](#0-4) 

This breaks the **Transaction Validation** invariant: "Prologue/epilogue checks must enforce all invariants." Validation should happen early during type checking, not late during argument construction.

## Impact Explanation

**Severity: Medium**

This vulnerability meets the Medium severity criteria per Aptos bug bounty:

1. **State Inconsistencies**: Invalid modules can be published to the blockchain, requiring manual intervention to identify and remediate.

2. **Gas Wastage**: Users calling these invalid functions waste gas as transactions fail during construction rather than early validation. The gas is consumed before the error is detected.

3. **Protocol Violation**: Violates the defense-in-depth principle where validation should occur at the earliest possible stage. The comment at line 240 indicates this inconsistency is unintended.

4. **Operational Impact**: Creates confusing error messages and poor user experience as errors occur during construction rather than clear upfront validation failures.

While this does not directly lead to funds loss or consensus violations (Critical severity), it does create state inconsistencies and enables resource wastage (Medium severity).

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited:

1. **Easy to Execute**: Any user can publish a module with minimal technical expertise.

2. **No Special Privileges Required**: Does not require validator access or special permissions.

3. **Hard to Detect**: Developers may not realize their entry functions have invalid signatures until users attempt to call them.

4. **Already In Sync**: Both validators have the same bug, so the issue is consistent across the codebase, making it likely to persist unnoticed.

The allowed structs include commonly used types like `Option` and `Object`, making accidental misuse probable.

## Recommendation

Recursively validate struct type parameters, mirroring the approach used for Vector types. Modify `check_transaction_input_type()`:

```rust
fn check_transaction_input_type(&self, loc: &Loc, ty: &Type) {
    use Type::*;
    match ty {
        Primitive(_) | TypeParameter(_) => {
            // Any primitive type allowed, any parameter expected to instantiate with primitive
        },
        Reference(ReferenceKind::Immutable, bt)
            if matches!(bt.as_ref(), Primitive(PrimitiveType::Signer)) =>
        {
            // Immutable reference to signer allowed
        },
        Vector(ety) => {
            // Vectors are allowed if element type is allowed
            self.check_transaction_input_type(loc, ety)
        },
        Struct(mid, sid, type_args) if self.is_allowed_input_struct(mid.qualified(*sid)) => {
            // Specific struct types are allowed, but validate type parameters recursively
            for ty_arg in type_args {
                self.check_transaction_input_type(loc, ty_arg)
            }
        },
        _ => {
            // Everything else is disallowed.
            self.env.error(
                loc,
                &format!(
                    "type `{}` is not supported as a transaction parameter type",
                    ty.display(&self.env.get_type_display_ctx())
                ),
            );
        },
    }
}
```

Similarly update `is_valid_txn_arg()` in `transaction_arg_validation.rs` to recursively validate struct type parameters.

## Proof of Concept

Create a Move module that demonstrates the validation bypass:

```move
module 0xCAFE::invalid_entry {
    use std::option::Option;
    
    // This should be rejected at compile time but currently passes
    public entry fun invalid_option_signer(param: Option<&signer>) {
        // This function signature is invalid - Option<&signer> should not be allowed
        // But both compile-time and runtime type validation accept it
        // Only fails during argument construction
    }
    
    // This should also be rejected but passes
    public entry fun invalid_option_mut_signer(param: Option<&mut signer>) {
        // Even worse - mutable signer reference in Option
    }
}
```

**Compilation Test:**
1. Attempt to compile this module - it will pass compile-time checks
2. Attempt to publish to blockchain - it will succeed
3. Attempt to call `invalid_option_signer` - transaction will fail during argument construction with `INVALID_MAIN_FUNCTION_SIGNATURE` error
4. Gas is consumed before the error is detected

**Expected Behavior:** Both functions should be rejected at compile time with clear error messages that `&signer` and `&mut signer` are not valid type parameters for `Option` in entry function arguments.

**Actual Behavior:** Module compiles and publishes successfully, with errors only appearing at runtime during function invocation.

---

**Notes:**

The vulnerability exists in both the compile-time validator (extended_checks.rs) and runtime validator (transaction_arg_validation.rs), creating a consistent validation gap. While the runtime eventually catches invalid types during argument construction, this defense-in-depth failure allows invalid modules to pollute the blockchain state and wastes user gas. The explicit comment indicating these validators should be kept in sync suggests the recursive validation gap is unintended.

### Citations

**File:** aptos-move/framework/src/extended_checks.rs (L240-241)
```rust
    /// Note: this should be kept up in sync with `is_valid_txn_arg` in
    /// aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs
```

**File:** aptos-move/framework/src/extended_checks.rs (L253-256)
```rust
            Vector(ety) => {
                // Vectors are allowed if element type is allowed
                self.check_transaction_input_type(loc, ety)
            },
```

**File:** aptos-move/framework/src/extended_checks.rs (L257-259)
```rust
            Struct(mid, sid, _) if self.is_allowed_input_struct(mid.qualified(*sid)) => {
                // Specific struct types are allowed
            },
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L209-223)
```rust
        Struct { .. } | StructInstantiation { .. } => {
            // Note: Original behavior was to return false even if the module loading fails (e.g.,
            //       if struct does not exist. This preserves it.
            runtime_environment
                .get_struct_name(ty)
                .ok()
                .flatten()
                .is_some_and(|(module_id, identifier)| {
                    allowed_structs.contains_key(&format!(
                        "{}::{}",
                        module_id.short_str_lossless(),
                        identifier
                    ))
                })
        },
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L400-402)
```rust
        Signer | Reference(_) | MutableReference(_) | TyParam(_) | Function { .. } => {
            return Err(invalid_signature())
        },
```
