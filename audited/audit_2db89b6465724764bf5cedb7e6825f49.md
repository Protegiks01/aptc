# Audit Report

## Title
Error Code 1011 Category Mismatch Causes Prologue Validation Miscategorization

## Summary
A critical mismatch exists between the Move framework and Rust VM error handling for error code 1011. The Move code aborts with category `PERMISSION_DENIED` while the Rust code expects category `INVALID_STATE`, causing the error to be misclassified as an invariant violation (`UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`) instead of a proper permission denied error. This breaks deterministic execution guarantees and transaction validation invariants.

## Finding Description
The Aptos transaction validation system uses a dual-layer error categorization scheme where Move framework code aborts with errors encoded as `(category << 16) + reason`, and the Rust VM layer must correctly map these to appropriate `StatusCode` values.

For error code 1011, there is a fundamental mismatch:

**In the Move framework** [1](#0-0) , the error is defined as `PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT` and used with `error::permission_denied()` [2](#0-1) .

According to the canonical error encoding [3](#0-2) , this produces an abort code with category `PERMISSION_DENIED (0x5)` and reason `1011`.

**However, in the Rust VM layer** [4](#0-3) , error code 1011 is defined as `EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT`, and the match arm expects category `INVALID_STATE (0x3)` [5](#0-4) .

When the Move code aborts with `error::permission_denied(1011)`, it produces the tuple `(PERMISSION_DENIED=5, 1011)` after error splitting [6](#0-5) . This tuple does NOT match any case in the prologue error handler [7](#0-6) , causing it to fall through to the default handler that returns `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` [8](#0-7) .

This invariant violation status is then processed through `TransactionStatus::from_vm_status` [9](#0-8) , where with the `CHARGE_INVARIANT_VIOLATION` feature flag enabled (which it is by default [10](#0-9) ), the transaction is kept with `ExecutionStatus::MiscellaneousError` rather than being properly rejected as a permission denied validation error.

## Impact Explanation
This vulnerability has **Medium severity** impact:

1. **Transaction Validation Bypass**: Transactions that should be rejected during prologue validation with a proper permission denied error are instead kept and charged as invariant violations.

2. **State Consistency Risk**: The `ExecutionStatus` is part of the `TransactionInfo` structure that gets hashed for consensus [9](#0-8) . If different validator nodes have different versions of the error handling code, they could compute different transaction statuses, leading to different transaction info hashes and potentially causing consensus disagreements.

3. **Error Semantics Corruption**: Permission denied errors represent authorization failures that should not charge gas or affect account state, but they are being treated as miscellaneous errors that do charge gas.

4. **Future Vulnerability Amplification**: This demonstrates that the error code ranges (1001-1013 for prologue) are not only exhausted but also contain mismatches, making it dangerous to add new validation scenarios without risking similar miscategorizations.

## Likelihood Explanation
The likelihood is **MEDIUM to HIGH** because:

1. **Active Code Path**: The permissioned signer functionality with gas limits is an active feature used in the transaction validation prologue [2](#0-1) .

2. **Realistic Trigger**: Any transaction using a permissioned signer that exceeds its granted gas permission will trigger this code path.

3. **Current Production Code**: This mismatch exists in the current codebase and affects all transactions that use the permissioned signer feature with insufficient gas limits.

4. **Silent Failure**: The miscategorization happens silently - transactions are not rejected but are marked as invariant violations, making the issue harder to detect.

## Recommendation
**Immediate Fix**: Update the Rust error handler to correctly match the category used in Move code:

In `aptos-move/aptos-vm/src/errors.rs`, add a match arm for the correct category-code pair:

```rust
(PERMISSION_DENIED, 1011) => StatusCode::PERMISSIONED_GAS_LIMIT_INSUFFICIENT,
```

And define the corresponding StatusCode in the Move VM status codes.

**Long-term Fix**: 
1. Implement automated validation tests that verify Move error codes match their Rust handlers in both category and reason
2. Create a single source of truth for error code definitions shared between Move and Rust
3. Expand the error code ranges to allow for future growth (e.g., 1001-1099 for prologue)
4. Add compile-time or integration tests that verify error encoding consistency

## Proof of Concept
```move
#[test(framework = @aptos_framework, sender = @0x123, permissioned = @0x456)]
public fun test_permissioned_gas_limit_error(
    framework: &signer,
    sender: &signer, 
    permissioned: &signer
) {
    // Setup: Create permissioned signer with limited gas permission
    use aptos_framework::transaction_validation;
    use aptos_framework::account;
    
    // Grant only 1000 octas of gas permission
    transaction_validation::grant_gas_permission(sender, permissioned, 1000);
    
    // Try to execute transaction requiring more gas (e.g., 10000 octas)
    // This should abort with PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT
    // But the error will be miscategorized as UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION
    
    // The assertion in transaction_validation.move:199 will abort with:
    // error::permission_denied(1011) which encodes as (0x5, 1011)
    // But Rust expects (0x3, 1011) so it falls through to invariant violation
}
```

**Rust Verification**: Examine the error_split result:
```rust
// When Move aborts with error::permission_denied(1011):
// Encoded value: (0x5 << 16) + 1011 = 0x503F3
let code = 0x503F3u64;
let (category, reason) = error_split(code);
// category = 5 (PERMISSION_DENIED), reason = 1011
// This does NOT match (INVALID_STATE=3, 1011) in the match arms
// Falls through to UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION
```

## Notes
This vulnerability demonstrates the broader issue raised in the security question: the error code ranges are not only insufficient for future expansion but contain existing mismatches that cause validation errors to be forced into wrong categories. The gap between error codes 1001-1013 leaves no room for adding new prologue validation scenarios, and the existing mismatch on code 1011 proves that synchronization between Move and Rust error handling is already broken.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L71-72)
```text
    const PROLOGUE_EFEE_PAYER_NOT_ENABLED: u64 = 1010;
    const PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT: u64 = 1011;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L193-200)
```text
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
```

**File:** aptos-move/framework/move-stdlib/sources/error.move (L63-66)
```text
  /// Construct a canonical error code from a category and a reason.
  public fun canonical(category: u64, reason: u64): u64 {
    (category << 16) + reason
  }
```

**File:** aptos-move/aptos-vm/src/errors.rs (L38-38)
```rust
pub const EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT: u64 = 1011;
```

**File:** aptos-move/aptos-vm/src/errors.rs (L63-67)
```rust
fn error_split(code: u64) -> (u8, u64) {
    let reason = code & 0xFFFF;
    let category = ((code >> 16) & 0xFF) as u8;
    (category, reason)
}
```

**File:** aptos-move/aptos-vm/src/errors.rs (L124-155)
```rust
            let new_major_status = match error_split(code) {
                // Invalid authentication key
                (INVALID_ARGUMENT, EBAD_ACCOUNT_AUTHENTICATION_KEY) => StatusCode::INVALID_AUTH_KEY,
                // Sequence number too old
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_OLD) => StatusCode::SEQUENCE_NUMBER_TOO_OLD,
                // Sequence number too new
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_NEW) => StatusCode::SEQUENCE_NUMBER_TOO_NEW,
                // Sequence number too new
                (INVALID_ARGUMENT, EACCOUNT_DOES_NOT_EXIST) => {
                    StatusCode::SENDING_ACCOUNT_DOES_NOT_EXIST
                },
                // Can't pay for transaction gas deposit/fee
                (INVALID_ARGUMENT, ECANT_PAY_GAS_DEPOSIT) => {
                    StatusCode::INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE
                },
                (INVALID_ARGUMENT, ETRANSACTION_EXPIRED) => StatusCode::TRANSACTION_EXPIRED,
                (INVALID_ARGUMENT, EBAD_CHAIN_ID) => StatusCode::BAD_CHAIN_ID,
                // Sequence number will overflow
                (LIMIT_EXCEEDED, ESEQUENCE_NUMBER_TOO_BIG) => StatusCode::SEQUENCE_NUMBER_TOO_BIG,
                (INVALID_ARGUMENT, ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH) => {
                    StatusCode::SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH
                },
                (INVALID_ARGUMENT, EGAS_PAYER_ACCOUNT_MISSING) => {
                    StatusCode::GAS_PAYER_ACCOUNT_MISSING
                },
                (INVALID_STATE, EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT) => {
                    StatusCode::INSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT
                },
                (INVALID_ARGUMENT, ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE) => {
                    StatusCode::TRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE
                },
                (INVALID_ARGUMENT, ENONCE_ALREADY_USED) => StatusCode::NONCE_ALREADY_USED,
```

**File:** aptos-move/aptos-vm/src/errors.rs (L156-171)
```rust
                (category, reason) => {
                    let mut err_msg = format!(
                        "[aptos_vm] Unexpected prologue Move abort: {:?}::{:?} (Category: {:?} Reason: {:?})",
                        location, code, category, reason
                    );
                    if let Some(abort_msg) = message {
                        err_msg.push_str(" Message: ");
                        err_msg.push_str(&abort_msg);
                    }
                    speculative_error!(log_context, err_msg.clone());
                    return Err(VMStatus::Error {
                        status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                        sub_status: None,
                        message: Some(err_msg),
                    });
                },
```

**File:** types/src/transaction/mod.rs (L1620-1648)
```rust
    pub fn from_vm_status(
        vm_status: VMStatus,
        features: &Features,
        memory_limit_exceeded_as_miscellaneous_error: bool,
    ) -> Self {
        let status_code = vm_status.status_code();
        // TODO: keep_or_discard logic should be deprecated from Move repo and refactored into here.
        match vm_status.keep_or_discard(
            features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES),
            memory_limit_exceeded_as_miscellaneous_error,
            features.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10),
        ) {
            Ok(recorded) => match recorded {
                // TODO(bowu):status code should be removed from transaction status
                KeptVMStatus::MiscellaneousError => {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(status_code)))
                },
                _ => Self::Keep(recorded.into()),
            },
            Err(code) => {
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
            },
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L194-194)
```rust
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
```
