# Audit Report

## Title
Memory Exhaustion via Oversized Peer Monitoring Responses Due to Post-Deserialization Size Validation

## Summary
The peer monitoring service validates response sizes AFTER BCS deserialization, allowing malicious peers to force victim nodes to allocate up to ~60 MB per response before rejection. This creates a memory and CPU exhaustion attack vector that can slow down or crash validator nodes.

## Finding Description

The peer monitoring service implements a `max_num_response_bytes` configuration (default 100 KB) to limit response sizes. However, this validation occurs AFTER the response has been fully deserialized from BCS format, creating a time-of-check/time-of-use vulnerability.

**Attack Flow:**

1. A malicious peer constructs a `NodeInformationResponse` with an extremely large `build_information` BTreeMap (e.g., 100,000 entries with 500-byte values each, totaling ~52.5 MB when serialized) [1](#0-0) 

2. When victim nodes request node information (every 15 seconds by default), the malicious peer serializes and sends this oversized response via `ResponseSender::send()` [2](#0-1) 

3. The network layer accepts messages up to 64 MiB, so the 52.5 MB response passes through [3](#0-2) 

4. The victim's application layer deserializes the response using `bcs::from_bytes_with_limit(&bytes, 64)` where 64 is a recursion depth limit, NOT a size limit [4](#0-3) 

5. Deserialization allocates ~52.5 MB of memory for the BTreeMap and all its string entries

6. ONLY AFTER deserialization completes does `sanity_check_response_size()` validate the size [5](#0-4) 

7. The check calculates size by re-serializing and compares against the 100 KB limit, then rejects it—but memory is already allocated [6](#0-5) 

**Honest nodes cannot trigger this:** The legitimate `build_information` comes from compile-time metadata with only ~13 fixed keys and short values (~2 KB total) [7](#0-6) 

Only a malicious peer running modified software can construct arbitrary oversized responses.

## Impact Explanation

**HIGH SEVERITY** per Aptos bug bounty criteria: "Validator node slowdowns"

**Specific Impacts:**

1. **Memory Exhaustion**: Each malicious response forces allocation of up to ~60 MB before rejection
   - With 10 malicious peers and node info requests every 15 seconds (default): 10 peers × 4 requests/min × 50 MB = 2 GB/minute
   - Can exhaust node memory leading to OOM crashes

2. **CPU Exhaustion**: Deserializing large BTreeMap structures is CPU-intensive
   - Repeated deserialization of 50+ MB structures strains CPU
   - Can slow block processing and consensus participation

3. **Node Availability Impact**: 
   - Validator nodes affected by memory pressure may lag in consensus
   - Potential node crashes require manual restart
   - Degraded network performance if multiple validators affected

4. **Amplification**: Since peer monitoring requests are automatic and periodic, a single malicious peer can repeatedly attack without victim interaction

## Likelihood Explanation

**HIGH LIKELIHOOD** - Attack requires minimal sophistication:

1. **Attacker Requirements**:
   - Run a modified Aptos node (open-source, easy to modify)
   - Connect to victim nodes as a peer (standard P2P network behavior)
   - No validator privileges or stake required

2. **Automatic Triggering**:
   - Victim nodes automatically request node information every 15 seconds
   - No user interaction needed—attack is passive and persistent

3. **Detection Difficulty**:
   - Malicious responses appear valid until deserialization completes
   - No pre-deserialization size check to detect attack early
   - Logs may only show rejected oversized responses, not resource consumption

4. **Real-World Feasibility**:
   - The test suite already includes utilities for creating "large" responses [8](#0-7) 
   - Demonstrates awareness of size issues but confirms no pre-deserialization protection

## Recommendation

Implement size validation BEFORE deserialization by checking the raw byte length:

**Fix in `peer-monitoring-service/client/src/peer_states/peer_state.rs`:**

```rust
// After receiving response bytes but BEFORE deserialization
// Add to send_rpc_raw or in the network layer:

pub async fn send_rpc_raw(
    &self,
    recipient: PeerId,
    protocol: ProtocolId,
    req_msg: Bytes,
    timeout: Duration,
    max_response_bytes: u64, // Pass from config
) -> Result<TMessage, RpcError> {
    // Send the request and wait for the response
    let res_data = self
        .peer_mgr_reqs_tx
        .send_rpc(recipient, protocol, req_msg, timeout)
        .await?;

    // CHECK SIZE BEFORE DESERIALIZATION
    if res_data.len() as u64 > max_response_bytes {
        return Err(RpcError::InvalidRpcResponse(format!(
            "Response size {} exceeds maximum {}",
            res_data.len(),
            max_response_bytes
        )));
    }

    // Deserialize the response using a blocking task
    let res_msg = tokio::task::spawn_blocking(move || protocol.from_bytes(&res_data)).await??;
    Ok(res_msg)
}
```

**Alternative: Enforce at network layer** by adding protocol-specific size limits to `ProtocolId` configuration, similar to how recursion limits are specified.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_oversized_response_memory_exhaustion() {
    use aptos_peer_monitoring_service_types::response::NodeInformationResponse;
    use std::collections::BTreeMap;
    use std::time::Duration;

    // Create a malicious response with large BTreeMap
    let mut large_map = BTreeMap::new();
    for i in 0..100_000 {
        // Each entry: ~520 bytes (key + value)
        large_map.insert(
            format!("key_{:06}", i),
            "x".repeat(500),
        );
    }
    
    let malicious_response = NodeInformationResponse {
        build_information: large_map,
        highest_synced_epoch: 0,
        highest_synced_version: 0,
        ledger_timestamp_usecs: 0,
        lowest_available_version: 0,
        uptime: Duration::default(),
    };

    // Serialize to check size
    let serialized = bcs::to_bytes(&malicious_response).unwrap();
    println!("Malicious response size: {} bytes ({} MB)", 
             serialized.len(), 
             serialized.len() / (1024 * 1024));
    
    // This would be ~52 MB, under network limit but way over peer monitoring limit
    assert!(serialized.len() > 100 * 1024); // Exceeds 100 KB limit
    assert!(serialized.len() < 64 * 1024 * 1024); // Under 64 MB network limit

    // Simulate deserialization (this allocates memory BEFORE size check)
    let deserialized: NodeInformationResponse = 
        bcs::from_bytes(&serialized).unwrap();
    
    // Size check happens AFTER deserialization
    let size = deserialized.build_information.len();
    println!("Deserialized map has {} entries", size);
    
    // Memory is already allocated at this point
    // In real attack, this happens for every peer monitoring request
}
```

**Notes**

The vulnerability stems from a classic time-of-check/time-of-use (TOCTOU) flaw where the size validation occurs after resource allocation. While the network layer has a 64 MiB limit and the application specifies a 100 KB limit, the gap between these values (640x difference) combined with post-deserialization checking creates a significant attack surface. The BCS recursion limit of 64 prevents deeply nested structures but does not constrain flat collections like large BTrees, making this attack vector viable with simple data structures.

### Citations

**File:** peer-monitoring-service/types/src/response.rs (L94-102)
```rust
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}
```

**File:** peer-monitoring-service/server/src/network.rs (L106-112)
```rust
    pub fn send(self, response: Result<PeerMonitoringServiceResponse>) {
        let msg = PeerMonitoringServiceMessage::Response(response);
        let result = bcs::to_bytes(&msg)
            .map(Bytes::from)
            .map_err(RpcError::BcsError);
        let _ = self.response_tx.send(result);
    }
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L259-262)
```rust
    /// Deserializes the value using BCS encoding (with a specified limit)
    fn bcs_decode<T: DeserializeOwned>(&self, bytes: &[u8], limit: usize) -> anyhow::Result<T> {
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
    }
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L134-142)
```rust
            // Verify the response respects the message size limits
            if let Err(error) =
                sanity_check_response_size(max_num_response_bytes, &monitoring_service_response)
            {
                peer_state_value
                    .write()
                    .handle_monitoring_service_response_error(&peer_network_id, error);
                return;
            }
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L311-331)
```rust
/// Sanity checks that the monitoring service response size
/// is valid (i.e., it respects the max message size).
fn sanity_check_response_size(
    max_num_response_bytes: u64,
    monitoring_service_response: &PeerMonitoringServiceResponse,
) -> Result<(), Error> {
    // Calculate the number of bytes in the response
    let num_response_bytes = monitoring_service_response.get_num_bytes()?;

    // Verify the response respects the max message sizes
    if num_response_bytes > max_num_response_bytes {
        return Err(Error::UnexpectedError(format!(
            "The monitoring service response ({:?}) is too large: {:?}. Maximum allowed: {:?}",
            monitoring_service_response.get_label(),
            num_response_bytes,
            max_num_response_bytes
        )));
    }

    Ok(())
}
```

**File:** crates/aptos-build-info/src/lib.rs (L59-105)
```rust
pub fn get_build_information() -> BTreeMap<String, String> {
    shadow!(build);

    let mut build_information = BTreeMap::new();

    // Get Git metadata from shadow_rs crate.
    // This is applicable for native builds where the cargo has
    // access to the .git directory.
    build_information.insert(BUILD_BRANCH.into(), build::BRANCH.into());
    build_information.insert(BUILD_CARGO_VERSION.into(), build::CARGO_VERSION.into());
    build_information.insert(BUILD_CLEAN_CHECKOUT.into(), build::GIT_CLEAN.to_string());
    build_information.insert(BUILD_COMMIT_HASH.into(), build::COMMIT_HASH.into());
    build_information.insert(BUILD_TAG.into(), build::TAG.into());
    build_information.insert(BUILD_TIME.into(), build::BUILD_TIME.into());
    build_information.insert(BUILD_OS.into(), build::BUILD_OS.into());
    build_information.insert(BUILD_RUST_CHANNEL.into(), build::RUST_CHANNEL.into());
    build_information.insert(BUILD_RUST_VERSION.into(), build::RUST_VERSION.into());

    // Compilation information
    build_information.insert(BUILD_IS_RELEASE_BUILD.into(), is_release().to_string());
    build_information.insert(BUILD_PROFILE_NAME.into(), get_build_profile_name());
    build_information.insert(
        BUILD_USING_TOKIO_UNSTABLE.into(),
        std::env!("USING_TOKIO_UNSTABLE").to_string(),
    );

    // Get Git metadata from environment variables set during build-time.
    // This is applicable for docker based builds  where the cargo cannot
    // access the .git directory, or to override shadow_rs provided info.
    if let Ok(git_sha) = std::env::var("GIT_SHA") {
        build_information.insert(BUILD_COMMIT_HASH.into(), git_sha);
    }

    if let Ok(git_branch) = std::env::var("GIT_BRANCH") {
        build_information.insert(BUILD_BRANCH.into(), git_branch);
    }

    if let Ok(git_tag) = std::env::var("GIT_TAG") {
        build_information.insert(BUILD_TAG.into(), git_tag);
    }

    if let Ok(build_date) = std::env::var("BUILD_DATE") {
        build_information.insert(BUILD_TIME.into(), build_date);
    }

    build_information
}
```

**File:** peer-monitoring-service/client/src/tests/utils.rs (L99-106)
```rust
/// Returns a build info map that is too large
pub fn create_large_build_info_map() -> BTreeMap<String, String> {
    let mut build_info = BTreeMap::new();
    for i in 0..100_000 {
        build_info.insert(i.to_string(), i.to_string());
    }
    build_info
}
```
