# Audit Report

## Title
OldExpStatus State Machine Corruption in Nested Invalid old() Expressions

## Summary
The `old_status` state machine in `ExpTranslator` can be corrupted when processing nested `old()` expressions where the inner `old()` is invalid (nested old not allowed). The invalid inner `old()` incorrectly resets the state from `InsideOld` to `OutsideOld`, causing sibling expressions in the same argument list to be incorrectly evaluated as if they are outside the old context.

## Finding Description
The vulnerability exists in the `translate_fun_call` function's handling of the `old()` expression state machine. [1](#0-0) 

When processing an expression like `old(f(old(x), y))`:

1. The outer `old()` is detected and sets `old_status = InsideOld` [2](#0-1) 

2. `translate_call` is invoked, which translates the arguments including `f(old(x), y)`

3. During argument translation of `f()`, the inner `old(x)` is processed:
   - It's detected as a nested `old()` (invalid)
   - An error is reported [3](#0-2) 
   - But `translate_call` is still invoked for it
   - The state reset executes: `old_status = OutsideOld` [4](#0-3) 

4. When the sibling argument `y` is translated, `old_status` is now `OutsideOld`, so `y` is NOT marked as being accessed within an `old()` context [5](#0-4) 

5. The outer `old()` check sees `old_status == OutsideOld` and doesn't reset it (already reset by the invalid inner `old()`)

This breaks the specification semantics where `y` should be evaluated with its old (pre-state) value but instead uses its current value.

## Impact Explanation
This is a **specification correctness vulnerability** in the Move model builder. While it doesn't directly affect blockchain consensus or execution, it compromises the formal verification infrastructure that validates Move module safety properties.

**Severity Assessment: Medium** - This constitutes a "state inconsistency requiring intervention" in the specification tooling. Specifically:

- Specifications on critical modules (governance, staking) may incorrectly pass validation when they contain vulnerable logic
- Formal verification results become unreliable for specifications with complex `old()` expressions
- Runtime Assertion Checker (if enabled) would validate incorrect conditions
- This could enable deployment of Move modules with subtle bugs that should have been caught during verification

However, this does NOT qualify as Critical or High severity because:
- No direct impact on consensus protocol
- No direct loss of funds or state corruption in deployed code
- Requires specific specification patterns to trigger
- The bug is in the development/verification toolchain, not runtime execution

## Likelihood Explanation
**Likelihood: Low to Medium**

The bug requires:
1. A developer writing specifications with nested `old()` expressions (which is a natural mistake)
2. The specification being complex enough that the corrupted evaluation isn't immediately obvious
3. The specification being used to validate security-critical properties

While nested `old()` is already flagged as an error, the fact that the state machine is corrupted means that even when the error is reported, the subsequent translation produces incorrect semantics. Developers might not notice that sibling variables are being incorrectly evaluated if they focus only on fixing the "nested old not allowed" error.

## Recommendation
The state reset at lines 3368-3370 should only execute for VALID `old()` calls, not for error cases. The fix should track whether an error occurred and skip the reset:

```rust
// Process `old(E)` scoping
let is_old = self.is_spec_mode() && module_name.is_none() && name == self.parent.parent.old_symbol();
let mut old_error = false;
if is_old {
    match self.old_status {
        OldExpStatus::NotSupported => {
            self.error(loc, "`old(..)` expression not allowed in this context");
            old_error = true;
        },
        OldExpStatus::InsideOld => {
            self.error(loc, "`old(..old(..)..)` not allowed");
            old_error = true;
        },
        OldExpStatus::OutsideOld => {
            self.old_status = OldExpStatus::InsideOld;
        },
    }
}

let result = self.translate_call(
    loc,
    &self.to_loc(&maccess.loc),
    kind,
    &module_name,
    name,
    generics,
    args,
    expected_type,
    context,
);

// Only reset if this was a valid old() call
if is_old && !old_error && self.old_status == OldExpStatus::InsideOld {
    self.old_status = OldExpStatus::OutsideOld;
}
result
```

Alternatively, use RAII pattern with a guard structure to ensure proper state restoration.

## Proof of Concept

```move
module 0x1::test_spec {
    spec module {
        fun helper(x: u64, y: u64): u64 { x + y }
    }
    
    public fun test_function(x: u64, y: u64): u64 {
        x + y
    }
    
    spec test_function {
        // This will trigger the bug:
        // - Inner old(x) is invalid (nested old)
        // - Variable y will be incorrectly evaluated with current value instead of old value
        // - If y is modified before this check, the spec will use wrong value
        ensures old(helper(old(x), y)) == result;
    }
}
```

When the Move model builder processes this specification:
1. The inner `old(x)` triggers an error "old(..old(..)..) not allowed"
2. But the state machine is corrupted, causing `y` to be evaluated as if it's outside `old()` context
3. The resulting specification semantics are incorrect - `y` uses current value instead of pre-state value

### Citations

**File:** third_party/move/move-model/src/builder/exp_builder.rs (L3339-3372)
```rust
        // Process `old(E)` scoping
        let is_old =
            self.is_spec_mode() && module_name.is_none() && name == self.parent.parent.old_symbol();
        if is_old {
            match self.old_status {
                OldExpStatus::NotSupported => {
                    self.error(loc, "`old(..)` expression not allowed in this context");
                },
                OldExpStatus::InsideOld => {
                    self.error(loc, "`old(..old(..)..)` not allowed");
                },
                OldExpStatus::OutsideOld => {
                    self.old_status = OldExpStatus::InsideOld;
                },
            }
        }

        let result = self.translate_call(
            loc,
            &self.to_loc(&maccess.loc),
            kind,
            &module_name,
            name,
            generics,
            args,
            expected_type,
            context,
        );

        if is_old && self.old_status == OldExpStatus::InsideOld {
            self.old_status = OldExpStatus::OutsideOld;
        }
        result
    }
```

**File:** third_party/move/move-model/src/builder/exp_builder.rs (L3741-3747)
```rust
                if let Some(exp) = self.resolve_local(
                    loc,
                    sym,
                    self.old_status == OldExpStatus::InsideOld,
                    expected_type,
                    context,
                ) {
```
