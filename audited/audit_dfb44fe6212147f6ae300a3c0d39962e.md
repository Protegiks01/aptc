# Audit Report

## Title
Missing Subgroup Validation on BLS Public Key Deserialization from Blockchain State

## Summary
BLS12-381 public keys stored in the blockchain state database are deserialized without enforcing prime-order subgroup validation, relying solely on validation performed during initial key registration. While validation occurs at write time through `initialize_validator` and `rotate_consensus_key`, the absence of validation at read time creates a potential attack surface if the database state can be corrupted or if write-time validation is bypassed through other vulnerabilities.

## Finding Description

When validator BLS12-381 consensus public keys are stored in the blockchain state, they undergo validation through proof-of-possession (PoP) verification in the Move smart contracts. However, when these keys are later deserialized from the database into Rust structs for use in consensus, no subgroup validation is performed.

**Write Path (Validation Present):**
- Validators call `initialize_validator` or `rotate_consensus_key` in the stake module [1](#0-0) 
- These functions validate the public key with proof-of-possession [2](#0-1) 
- Raw bytes are stored in `ValidatorConfig.consensus_pubkey`

**Read Path (No Validation):**
- `ValidatorConfig` is deserialized from blockchain state into Rust [3](#0-2) 
- The `consensus_public_key` field uses `PublicKey::try_from` via the `DeserializeKey` derive macro [4](#0-3) 
- `PublicKey::try_from` explicitly does NOT perform subgroup validation [5](#0-4) 
- Signature verification assumes keys are valid without checking [6](#0-5) 
- The `aggregate_verify` call uses `pks_validate = false` [7](#0-6) 

This violates the **Cryptographic Correctness** invariant, which states that "BLS signatures, VRF, and hash operations must be secure."

## Impact Explanation

**Theoretical Impact:** Critical - If exploited, invalid public keys could be used in consensus, potentially enabling small-subgroup attacks or breaking cryptographic assumptions underlying the BLS signature scheme. This could compromise consensus safety.

**Realistic Assessment:** However, this is **NOT directly exploitable** without a separate vulnerability because:
1. All state writes go through Move VM execution, which enforces validation
2. The blockchain state is protected by Merkle tree commitments
3. State sync validates against consensus-committed state
4. Direct database corruption requires physical access, not a software exploit

This issue represents a **defense-in-depth gap** rather than a standalone exploitable vulnerability. It becomes exploitable only if combined with:
- A state sync vulnerability allowing injection of malformed state
- A Move VM bug bypassing validation in `initialize_validator`
- Database corruption through other means

## Likelihood Explanation

**Likelihood: Very Low**

The vulnerability requires:
- Bypassing Move VM validation (requires finding a separate VM bug)
- OR corrupting the Merkle-committed blockchain state (requires consensus compromise or physical access)
- OR exploiting an unknown state sync vulnerability

All realistic attack paths require exploitation of additional, currently unknown vulnerabilities. The defense-in-depth principle suggests validation should occur at both write and read time, but the absence of read-time validation alone is insufficient for exploitation under normal operation.

## Recommendation

Implement subgroup validation during deserialization to provide defense-in-depth:

**Option 1: Validate during deserialization**
Modify `ValidatorConfig` deserialization to validate public keys:

```rust
// In types/src/validator_config.rs
impl<'de> Deserialize<'de> for ValidatorConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct RawValidatorConfig {
            consensus_public_key: bls12381::PublicKey,
            validator_network_addresses: Vec<u8>,
            fullnode_network_addresses: Vec<u8>,
            validator_index: u64,
        }
        
        let raw = RawValidatorConfig::deserialize(deserializer)?;
        
        // Validate subgroup membership
        raw.consensus_public_key.subgroup_check()
            .map_err(|e| D::Error::custom(format!("Invalid public key: {}", e)))?;
            
        Ok(ValidatorConfig {
            consensus_public_key: raw.consensus_public_key,
            validator_network_addresses: raw.validator_network_addresses,
            fullnode_network_addresses: raw.fullnode_network_addresses,
            validator_index: raw.validator_index,
        })
    }
}
```

**Option 2: Enable validation in signature verification**
Change `pks_validate` to `true` in aggregate signature verification, though this adds runtime overhead.

## Proof of Concept

**Cannot provide a working PoC** because:
1. No direct path exists to inject invalid keys without database corruption
2. All valid code paths enforce validation at write time
3. Demonstrating the issue requires simulating database corruption, which is not a software vulnerability

A theoretical PoC would require:
1. Crafting a public key point on the BLS12-381 curve but not in the prime-order subgroup
2. Directly writing this to the database (bypassing Move VM)
3. Showing that deserialization accepts it
4. Demonstrating that signature verification fails or behaves unexpectedly

However, step 2 cannot be achieved through software exploitation alone.

---

**Notes:**

After rigorous analysis, while the code does lack validation at deserialization, this does not constitute a **standalone exploitable vulnerability** under the strict criteria provided. The issue is mitigated by:
- Mandatory validation at write time through Move smart contracts
- Merkle tree protection of blockchain state
- Absence of any realistic bypass path

This represents a **defense-in-depth recommendation** rather than a critical security flaw. The validation gap becomes relevant only if combined with other, currently undemonstrated vulnerabilities in state sync, Move VM, or consensus.

Given the extremely high bar for validity and the requirement for "realistic attack path with correct parameters and feasible execution," this finding does not meet the criteria for a valid vulnerability report without demonstration of the prerequisite attack vector.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L670-692)
```text
    public entry fun initialize_validator(
        account: &signer,
        consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
        network_addresses: vector<u8>,
        fullnode_addresses: vector<u8>,
    ) acquires AllowedValidators {
        check_stake_permission(account);
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));

        initialize_owner(account);
        move_to(account, ValidatorConfig {
            consensus_pubkey,
            network_addresses,
            fullnode_addresses,
            validator_index: 0,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L927-931)
```text
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
```

**File:** types/src/validator_config.rs (L36-37)
```rust
pub struct ValidatorConfig {
    pub consensus_public_key: bls12381::PublicKey,
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L174-177)
```rust
                    let value = Value::deserialize(deserializer)?;
                    #name::try_from(value.0).map_err(|s| {
                        <D::Error as ::serde::de::Error>::custom(format!("{} with {}", s, #name_string))
                    })
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L232-234)
```rust
    /// WARNING: Does NOT subgroup-check the public key! Instead, the caller is responsible for
    /// verifying the public key's proof-of-possession (PoP) via `ProofOfPossession::verify`,
    /// which implicitly subgroup-checks the public key.
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L83-84)
```rust
    /// WARNING: This function assumes that the public keys have been subgroup-checked by the caller
    /// implicitly when verifying their proof-of-possession (PoP) in `ProofOfPossession::verify`.
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L93-93)
```rust
            .aggregate_verify(true, msgs, DST_BLS_SIG_IN_G2_WITH_POP, &pks, false);
```
