# Audit Report

## Title
CommitVote Verification Flooding DoS via Pessimistic Verification Set Exploitation

## Summary
A malicious validator can cause a denial-of-service attack on the consensus layer by exploiting the optimistic signature verification mechanism. After being added to the `pessimistic_verify_set` through initial invalid votes, the attacker can flood the network with invalid `CommitVotes` that force expensive BLS signature verification operations, saturating the bounded executor and blocking legitimate consensus messages from being processed. [1](#0-0) 

## Finding Description

The vulnerability exists in the commit vote verification pipeline, which uses a bounded executor with limited concurrency (default: 16 tasks) combined with an optimistic signature verification optimization. The attack unfolds in two phases:

**Phase 1: Entering the Pessimistic Verification Set**

The system enables optimistic signature verification by default, which defers expensive BLS signature checks for most validators: [2](#0-1) 

When a validator sends invalid `CommitVotes`, they initially pass through optimistic verification without cryptographic checks: [3](#0-2) 

These invalid votes are stored and eventually trigger batch verification. When batch verification fails, individual signature verification occurs, and the malicious validator is added to the `pessimistic_verify_set`: [4](#0-3) 

**Phase 2: The Denial-of-Service Attack**

Once in the pessimistic set, ALL future votes from the attacker require immediate, expensive BLS signature verification in the verification task: [5](#0-4) 

The verification loop processes messages sequentially and spawns bounded executor tasks: [6](#0-5) 

The bounded executor has a default capacity of only 16 concurrent tasks: [7](#0-6) 

When at capacity, `spawn()` blocks asynchronously waiting for available permits: [8](#0-7) 

**The Attack:**

1. Malicious validator floods the network with invalid `CommitVotes` at high rate (thousands per second)
2. Each vote requires expensive BLS signature verification (~1-5ms each) due to pessimistic set membership
3. The bounded executor fills with 16 concurrent expensive verification tasks
4. The verification loop blocks on `spawn().await`, unable to process new messages
5. Legitimate `CommitVotes` from honest validators are queued but cannot be processed
6. Consensus stalls as quorum cannot be reached due to blocked legitimate votes

The CommitVote structure itself has no inherent rate limiting: [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

- **"Validator node slowdowns"**: The attack causes all validator nodes to experience severe slowdowns in consensus message processing, as the verification loop becomes bottlenecked
- **"Significant protocol violations"**: Breaks the Byzantine fault tolerance guarantee that the system should tolerate up to 1/3 malicious validators; a single malicious validator can cause network-wide consensus stall

The impact extends beyond a single node - all validators in the network experience the same issue when receiving the malicious validator's flood of invalid votes, effectively halting consensus progression network-wide.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible:

1. **Attacker Requirements**: Requires control of a single validator account (realistic in Byzantine threat model)
2. **Technical Complexity**: Low - simply requires sending invalid `CommitVotes` at high rate
3. **Detection Difficulty**: The attacker's address is added to pessimistic set, but this doesn't prevent the attack; it actually enables it
4. **No Built-in Mitigations**: The bounded executor is the only rate limiting mechanism, and it's insufficient

The attack can be sustained indefinitely as long as the attacker maintains network connectivity. The default configuration (16 concurrent verification tasks, optimistic verification enabled) makes the system particularly vulnerable.

## Recommendation

Implement multiple layers of defense:

**1. Per-Validator Rate Limiting in Verification Loop:**
```rust
// Add rate limiter per sender before bounded executor spawn
let rate_limiter = RateLimiter::new(max_votes_per_validator_per_second: 100);

while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
    if !rate_limiter.check_and_update(sender) {
        warn!("Rate limit exceeded for sender: {}", sender);
        continue;
    }
    // ... existing verification logic
}
```

**2. Increase Bounded Executor Capacity for Pessimistic Verifications:**
Create a separate bounded executor with higher capacity specifically for pessimistic verifications, or dynamically increase capacity when detecting high load.

**3. Immediate Rejection of Invalid Votes:**
After a validator accumulates multiple failed signatures (e.g., >10), temporarily ban them from sending votes for a cooldown period:

```rust
// In ValidatorVerifier
pessimistic_verify_set_with_counters: DashMap<AccountAddress, AtomicU32>

// When adding to pessimistic set:
let counter = pessimistic_verify_set_with_counters.entry(author).or_insert(AtomicU32::new(0));
if counter.fetch_add(1, Ordering::Relaxed) > THRESHOLD {
    // Add to temporary ban list, reject votes without verification
}
```

**4. Network-Layer Rate Limiting:**
Implement rate limiting at the network message reception layer before messages enter the verification pipeline.

## Proof of Concept

```rust
// Reproduction steps (pseudo-Rust test):

#[tokio::test]
async fn test_commit_vote_verification_flooding() {
    // Setup: Create consensus with default config (16 bounded executor tasks)
    let config = ConsensusConfig::default();
    assert_eq!(config.num_bounded_executor_tasks, 16);
    assert_eq!(config.optimistic_sig_verification, true);
    
    // Create malicious validator
    let malicious_validator = ValidatorSigner::random();
    let mut validator_signers = vec![malicious_validator.clone()];
    
    // Add honest validators
    for i in 0..10 {
        validator_signers.push(ValidatorSigner::random());
    }
    
    let verifier = ValidatorVerifier::new(validator_signers_to_infos(&validator_signers));
    
    // Phase 1: Get malicious validator into pessimistic set
    // Send invalid votes that will fail batch verification
    for _ in 0..10 {
        let invalid_vote = create_commit_vote_with_bad_signature(
            &malicious_validator,
            create_test_ledger_info()
        );
        // Process through verification - will eventually fail and add to pessimistic set
    }
    
    // Verify malicious validator is now in pessimistic set
    assert!(verifier.pessimistic_verify_set().contains(&malicious_validator.author()));
    
    // Phase 2: Flood with invalid votes
    // Spawn task that floods invalid votes at high rate
    let flood_handle = tokio::spawn(async move {
        loop {
            let invalid_vote = create_commit_vote_with_bad_signature(
                &malicious_validator,
                create_test_ledger_info()
            );
            send_commit_vote_to_network(invalid_vote).await;
            // Send 1000 votes per second
            tokio::time::sleep(Duration::from_micros(1000)).await;
        }
    });
    
    // Try to send legitimate votes from honest validators
    let start = Instant::now();
    let honest_validator = &validator_signers[1];
    let valid_vote = create_valid_commit_vote(honest_validator, create_test_ledger_info());
    
    // Attempt to process the valid vote
    send_commit_vote_to_network(valid_vote).await;
    
    // Measure time until vote is verified and processed
    // Expected: Significant delay or timeout due to bounded executor saturation
    let processing_time = start.elapsed();
    
    // Assert that processing is severely delayed (>1 second for a single vote)
    assert!(processing_time > Duration::from_secs(1), 
            "Legitimate vote processing should be blocked by flood");
    
    flood_handle.abort();
}

fn create_commit_vote_with_bad_signature(
    signer: &ValidatorSigner,
    ledger_info: LedgerInfo
) -> CommitVote {
    let bad_signature = bls12381::Signature::dummy(); // Invalid signature
    CommitVote::new_with_signature(
        signer.author(),
        ledger_info,
        bad_signature
    )
}
```

## Notes

This vulnerability demonstrates a critical weakness in the bounded executor pattern when combined with optimistic verification. The system correctly identifies malicious validators (via pessimistic set), but this identification actually enables the DoS attack by forcing expensive verification for all subsequent messages.

The attack is particularly concerning because:
- It affects all validators network-wide simultaneously
- It breaks the 1/3 Byzantine fault tolerance assumption (single validator causes network halt)
- The pessimistic set mechanism intended as a defense becomes an attack enabler
- No recovery mechanism exists other than manually blocking the malicious validator at the network layer

### Citations

**File:** consensus/src/pipeline/buffer_manager.rs (L919-934)
```rust
        spawn_named!("buffer manager verification", async move {
            while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
                let tx = verified_commit_msg_tx.clone();
                let epoch_state_clone = epoch_state.clone();
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
            }
        });
```

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** crates/bounded-executor/src/executor.rs (L45-52)
```rust
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```
