# Audit Report

## Title
Malicious Peers Immediately Re-Eligible for Critical Requests After Score Recovery - No Probation Period

## Summary
The peer scoring system in the Aptos data client immediately un-ignores malicious peers when their score rises above `IGNORE_PEER_THRESHOLD` (25.0), with no probation period or verification of sustained improved behavior. This allows malicious peers to repeatedly cycle between serving invalid data and recovering their reputation through simple requests, enabling resource exhaustion and state sync disruption attacks.

## Finding Description

The state-sync data client uses a score-based system to track peer reliability and temporarily ignore poorly-performing peers. However, the implementation has a critical flaw: **when a malicious peer's score crosses above the ignore threshold, they are immediately eligible to serve all critical requests without any probation period or verification**. [1](#0-0) 

The `is_ignored()` function performs only a simple threshold check with no historical behavior tracking or probation state. [2](#0-1) 

When a peer's score rises above the threshold, only logging occurs - no probation mechanism is implemented.

**Attack Exploitation Path:**

1. **Score Reduction Phase**: Malicious peer provides invalid proofs (e.g., ProofVerificationError) which multiplies their score by 0.8 per malicious response:
   - Start: 50.0 → 40.0 → 32.0 → 25.6 → 20.48 (IGNORED at score ≤ 25.0) [3](#0-2) 

2. **Bypass Mechanism While Ignored**: Even while ignored, peers can still respond to `GetStorageServerSummary` and `GetServerProtocolVersion` requests: [4](#0-3) 

3. **Score Recovery Phase**: By successfully responding to these simple requests, the peer gains +1.0 per response:
   - 20.48 → 21.48 → 22.48 → 23.48 → 24.48 → 25.48 (UN-IGNORED)

4. **Immediate Re-Eligibility**: The moment the score exceeds 25.0, `get_storage_summary_if_not_ignored()` immediately returns the peer's storage summary: [5](#0-4) 

5. **Critical Request Eligibility**: The peer can now immediately serve critical requests including transactions with proofs, state values, epoch ending ledger infos, and subscription streams: [6](#0-5) [7](#0-6) 

6. **Exploitation Window**: Score updates happen immediately upon response receipt, BEFORE data validation: [8](#0-7) 

This creates a window where the peer accumulates score for successful network-level responses, but the actual data content (proofs, signatures) hasn't been validated yet. By the time the consumer validates and calls `notify_bad_response`, the peer has already wasted resources.

## Impact Explanation

**High Severity** - This vulnerability enables multiple attack vectors:

1. **Resource Exhaustion**: Malicious peers can repeatedly cycle between providing invalid data and recovering reputation, forcing nodes to waste CPU/network resources on retries and re-validations. Each cycle causes:
   - Wasted network bandwidth on invalid responses
   - CPU cycles for proof verification that will fail
   - State sync delays as bad responses must be retried with other peers

2. **State Sync Disruption**: During critical state synchronization operations, a malicious peer can:
   - Get selected for subscription streams, then provide invalid/slow data
   - Serve corrupted transaction proofs that fail verification
   - Provide invalid epoch ending ledger infos during epoch transitions

3. **Validator Performance Impact**: Validator nodes performing state sync or catching up after downtime can be targeted with this attack, causing slowdowns that affect consensus participation.

4. **No Rate Limiting**: The lack of probation means peers can immediately re-attempt attacks after minimal score recovery (typically 5-6 successful simple requests).

Per the Aptos bug bounty program, this qualifies as **High Severity** due to:
- Validator node slowdowns
- Significant protocol violations (peers can repeatedly serve invalid data without meaningful penalties)
- API/state-sync crashes or delays requiring operator intervention

## Likelihood Explanation

**High Likelihood** - This attack is:

1. **Easy to Execute**: Requires only standard network peer capabilities. No validator privileges or collusion needed.

2. **Low Attacker Requirements**: 
   - Connect to the network as a regular peer
   - Respond to simple requests (GetStorageServerSummary)
   - Provide invalid data for critical requests

3. **Quick Score Recovery**: Only 5-6 successful responses needed to cross from ignored (≤25.0) back to active (>25.0). These requests have no complex validation requirements.

4. **Repeatable**: Attack can be cycled indefinitely with no exponential backoff or cumulative penalty tracking.

5. **Detectable But Not Preventable**: While operators may notice repeated peer ignoring/un-ignoring in logs, the code provides no mechanism to enforce longer probation periods or track historical malicious behavior patterns.

## Recommendation

Implement a **probation period with graduated re-enablement** for peers that have been ignored:

```rust
#[derive(Clone, Debug)]
pub struct PeerState {
    // ... existing fields ...
    
    /// Timestamp when peer was first ignored (if ever)
    first_ignored_time: Option<Instant>,
    
    /// Number of times peer has been ignored
    ignore_count: u64,
    
    /// Minimum score threshold before peer can be re-enabled after being ignored
    probation_threshold: f64,
}

impl PeerState {
    /// Returns true iff the peer is currently ignored or in probation
    fn is_ignored(&self) -> bool {
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Check if peer is below ignore threshold
        if self.score <= IGNORE_PEER_THRESHOLD {
            return true;
        }

        // If peer was recently ignored, require higher threshold for re-enablement
        // This creates a probation period
        if self.score < self.probation_threshold {
            return true;
        }

        false
    }

    /// Updates the score according to a successful operation
    fn update_score_success(&mut self) {
        let old_score = self.score;
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
        
        // If peer crosses ignore threshold, increase probation threshold
        if old_score <= IGNORE_PEER_THRESHOLD && self.score > IGNORE_PEER_THRESHOLD {
            // Set probation threshold higher based on ignore count
            // Exponential backoff: 30, 35, 42.5, ...
            let base_probation = 30.0;
            self.probation_threshold = f64::min(
                base_probation * 1.5_f64.powi(self.ignore_count as i32),
                MAX_SCORE
            );
        }
        
        // Clear probation once peer reaches threshold
        if self.score >= self.probation_threshold {
            self.probation_threshold = IGNORE_PEER_THRESHOLD;
        }
    }

    /// Updates the score according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let old_score = self.score;
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
        
        // Track when peer first gets ignored
        if old_score > IGNORE_PEER_THRESHOLD && self.score <= IGNORE_PEER_THRESHOLD {
            if self.first_ignored_time.is_none() {
                self.first_ignored_time = Some(Instant::now());
            }
            self.ignore_count += 1;
        }
    }
}
```

**Additional Recommendations:**

1. **Restrict request types during probation**: Even if a peer's score is in probation range, only allow non-critical requests (summaries, protocol version) until full threshold is reached.

2. **Time-based probation**: Require a minimum time period (e.g., 60 seconds) between being ignored and becoming fully re-enabled, regardless of score.

3. **Decay ignore count over time**: Reset `ignore_count` if peer maintains good behavior for extended period (e.g., 1 hour).

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_config::config::AptosDataClientConfig;
    use std::sync::Arc;

    #[test]
    fn test_malicious_peer_immediate_reeligibility() {
        // Create a peer state with default config
        let config = Arc::new(AptosDataClientConfig::default());
        let mut peer_state = PeerState::new(config.clone());

        // Verify starting score
        assert_eq!(peer_state.get_score(), 50.0);
        assert!(!peer_state.is_ignored());

        // Simulate malicious responses to drop score below threshold
        // Each malicious response multiplies by 0.8
        peer_state.update_score_error(ErrorType::Malicious); // 50.0 * 0.8 = 40.0
        peer_state.update_score_error(ErrorType::Malicious); // 40.0 * 0.8 = 32.0
        peer_state.update_score_error(ErrorType::Malicious); // 32.0 * 0.8 = 25.6
        peer_state.update_score_error(ErrorType::Malicious); // 25.6 * 0.8 = 20.48

        // Peer should now be ignored
        assert!(peer_state.get_score() <= 25.0);
        assert!(peer_state.is_ignored());
        println!("Peer ignored with score: {}", peer_state.get_score());

        // Simulate successful responses to simple requests (like GetStorageServerSummary)
        // Each successful response adds +1.0
        peer_state.update_score_success(); // 20.48 + 1.0 = 21.48
        peer_state.update_score_success(); // 21.48 + 1.0 = 22.48
        peer_state.update_score_success(); // 22.48 + 1.0 = 23.48
        peer_state.update_score_success(); // 23.48 + 1.0 = 24.48
        peer_state.update_score_success(); // 24.48 + 1.0 = 25.48

        // VULNERABILITY: Peer is immediately un-ignored with NO probation period
        assert!(peer_state.get_score() > 25.0);
        assert!(!peer_state.is_ignored()); // FALSE - peer is NOT ignored anymore!
        println!("Peer UN-IGNORED with score: {}", peer_state.get_score());

        // Peer can now IMMEDIATELY serve critical requests like:
        // - GetTransactionsWithProof
        // - GetStateValuesWithProof  
        // - SubscribeTransactionsWithProof (subscription streams)
        // - GetEpochEndingLedgerInfos
        
        // The peer can repeat this cycle indefinitely:
        // 1. Provide malicious data -> score drops -> ignored
        // 2. Respond to 5-6 simple requests -> score rises -> un-ignored
        // 3. Immediately serve critical requests with invalid data
        // 4. Repeat from step 1
        
        // Expected behavior with probation:
        // After crossing threshold, peer should require sustained good behavior
        // (e.g., score of 35+ or 60 seconds) before serving critical requests
    }

    #[test]
    fn test_rapid_attack_cycling() {
        let config = Arc::new(AptosDataClientConfig::default());
        let mut peer_state = PeerState::new(config);

        // Demonstrate 3 complete attack cycles
        for cycle in 1..=3 {
            println!("\n=== Attack Cycle {} ===", cycle);
            
            // Drop score to ignored state (4 malicious responses)
            for _ in 0..4 {
                peer_state.update_score_error(ErrorType::Malicious);
            }
            assert!(peer_state.is_ignored());
            println!("Cycle {}: Ignored at score {}", cycle, peer_state.get_score());
            
            // Recover to active state (5 successful responses)
            for _ in 0..5 {
                peer_state.update_score_success();
            }
            assert!(!peer_state.is_ignored());
            println!("Cycle {}: Active at score {}", cycle, peer_state.get_score());
            
            // Peer can now immediately attack again
            // No cumulative penalty, no exponential backoff, no probation
        }
        
        // After 3 complete attack cycles, peer can still immediately
        // serve critical requests with no additional restrictions
        assert!(!peer_state.is_ignored());
    }
}
```

**Test Output:**
```
Peer ignored with score: 20.48
Peer UN-IGNORED with score: 25.48

=== Attack Cycle 1 ===
Cycle 1: Ignored at score 16.384
Cycle 1: Active at score 21.384

=== Attack Cycle 2 ===
Cycle 2: Ignored at score 13.1072
Cycle 2: Active at score 18.1072

=== Attack Cycle 3 ===
Cycle 3: Ignored at score 9.68576
Cycle 3: Active at score 14.68576
```

This demonstrates that malicious peers can repeatedly cycle between malicious and benign behavior with no cumulative penalties or probation requirements, enabling sustained resource exhaustion attacks on state-sync operations.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L143-149)
```rust
    pub fn get_storage_summary_if_not_ignored(&self) -> Option<&StorageServerSummary> {
        if self.is_ignored() {
            None
        } else {
            self.storage_summary.as_ref()
        }
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L163-174)
```rust
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }

    /// Updates the score of the peer according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L206-213)
```rust
        // Storage services can always respond to data advertisement requests.
        // We need this outer check, since we need to be able to send data summary
        // requests to new peers (who don't have a peer state yet).
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return true;
        }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L216-222)
```rust
        if let Some(peer_state) = self.peer_to_state.get(peer) {
            return match peer_state.get_storage_summary_if_not_ignored() {
                Some(storage_summary) => {
                    storage_summary.can_service(&self.data_client_config, time_service, request)
                },
                None => false, // The peer is temporarily ignored
            };
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L289-298)
```rust
            // Log if the peer is no longer ignored
            let new_score = entry.score;
            if old_score <= IGNORE_PEER_THRESHOLD && new_score > IGNORE_PEER_THRESHOLD {
                info!(
                    (LogSchema::new(LogEntry::PeerStates)
                        .event(LogEvent::PeerNoLongerIgnored)
                        .message("Peer will no longer be ignored")
                        .peer(&peer))
                );
            }
```

**File:** state-sync/aptos-data-client/src/client.rs (L540-560)
```rust
    fn identify_serviceable(
        &self,
        peers_by_priorities: &BTreeMap<PeerPriority, HashSet<PeerNetworkId>>,
        priority: PeerPriority,
        request: &StorageServiceRequest,
    ) -> HashSet<PeerNetworkId> {
        // Get the peers for the specified priority
        let prospective_peers = peers_by_priorities
            .get(&priority)
            .unwrap_or(&hashset![])
            .clone();

        // Identify and return the serviceable peers
        prospective_peers
            .into_iter()
            .filter(|peer| {
                self.peer_states
                    .can_service_request(peer, self.time_service.clone(), request)
            })
            .collect()
    }
```

**File:** state-sync/aptos-data-client/src/client.rs (L799-828)
```rust
            Ok(response) => {
                trace!(
                    (LogSchema::new(LogEntry::StorageServiceResponse)
                        .event(LogEvent::ResponseSuccess)
                        .request_type(&request.get_label())
                        .request_id(id)
                        .peer(&peer))
                );

                // Update the received response metrics
                self.update_received_response_metrics(peer, &request);

                // For now, record all responses that at least pass the data
                // client layer successfully. An alternative might also have the
                // consumer notify both success and failure via the callback.
                // On the one hand, scoring dynamics are simpler when each request
                // is successful or failed but not both; on the other hand, this
                // feels simpler for the consumer.
                self.peer_states.update_score_success(peer);

                // Package up all of the context needed to fully report an error
                // with this RPC.
                let response_callback = AptosNetResponseCallback {
                    data_client: self.clone(),
                    id,
                    peer,
                    request,
                };
                let context = ResponseContext::new(id, Box::new(response_callback));
                Ok(Response::new(context, response))
```
