# Audit Report

## Title
Silent Error Promotion in Native Functions Causes Gas Undercharging Through Improper InvariantViolation Classification

## Summary
The automatic `From<PartialVMError>` implementation in `errors.rs` silently promotes legitimate user-controllable errors to `InvariantViolation`, causing native functions to bypass proper gas charging and error handling when using the `?` operator. This allows users to perform expensive computations with undercharged gas fees. [1](#0-0) 

## Finding Description
The vulnerability exists in the automatic error conversion mechanism for native functions. When native functions encounter errors and use the `?` operator, ALL `PartialVMError` instances are automatically converted to `SafeNativeError::InvariantViolation`, regardless of whether they represent true invariant violations or legitimate user errors. [2](#0-1) 

The code explicitly acknowledges this is problematic with a TODO comment stating this makes it "extremely easy to accidentally propagate a non-invariant violation, which is a violation of the contract." [3](#0-2) 

**Attack Vector:**

When a user calls `bcs::to_bytes<T>()` with a deeply nested or complex type (e.g., `vector<vector<vector<...>>>`), the type layout construction can fail with legitimate execution errors like `TOO_MANY_TYPE_NODES` (StatusCode 4029) or `VM_MAX_VALUE_DEPTH_REACHED` (StatusCode 4025). [4](#0-3) 

When lazy loading is enabled, `bcs::to_bytes` uses the `?` operator directly on `type_to_type_layout()`: [5](#0-4) 

This triggers the automatic conversion, promoting the user error to `InvariantViolation`. The native function then returns `Err(err)` instead of a proper `SafeNativeError::Abort`: [6](#0-5) 

**Gas Charging Bypass:**

When `InvariantViolation` returns `Err`, it propagates immediately through the `?` operator in the interpreter without charging the native function's execution cost: [7](#0-6) 

Compare this to proper `Abort` handling, which charges gas for partial execution: [8](#0-7) 

When lazy loading is disabled, `bcs::to_bytes` properly catches errors and charges failure gas: [9](#0-8) 

This inconsistency means users can avoid paying for expensive layout construction by exploiting the lazy loading path with complex types.

## Impact Explanation
This qualifies as **Medium Severity** under Aptos bug bounty criteria:
- **"Limited funds loss or manipulation"**: Users can perform expensive type layout construction and validation without paying the full gas cost, effectively stealing computational resources
- **Breaks Resource Limits Invariant**: The invariant "All operations must respect gas, storage, and computational limits" is violated
- **Deterministic Execution Risk**: Different gas charging behavior based on feature flags (lazy loading) could lead to transaction outcome differences across nodes if flags are inconsistent

The vulnerability affects all native functions that use `?` on operations that can fail with user-controllable errors, particularly type layout construction, serialization, and deserialization.

## Likelihood Explanation
**High Likelihood:**
- Any user can trigger this by constructing transactions with deeply nested types
- No special permissions or validator access required  
- The vulnerable pattern (`?` operator on `PartialVMResult`) is used throughout native function implementations
- Lazy loading feature flag makes this exploitable in production

**Easy to Exploit:**
- Create Move transactions that use `bcs::to_bytes<T>()` with types that exceed layout limits
- Example: `vector<vector<vector<...>>>` with sufficient nesting depth
- Or struct types with many generic parameters that expand the type node count

## Recommendation
Replace the automatic `From<PartialVMError>` implementation with explicit error handling in native functions. Following the pattern in `LimitExceededError::from_err()`, classify errors based on their `StatusCode`: [10](#0-9) 

**Recommended Fix:**

1. **Remove the automatic conversion:**
```rust
// DELETE this implementation
impl From<PartialVMError> for SafeNativeError {
    fn from(e: PartialVMError) -> Self {
        SafeNativeError::InvariantViolation(e)
    }
}
```

2. **Add proper error classification helper:**
```rust
impl SafeNativeError {
    pub fn from_partial_vm_error(err: PartialVMError) -> Self {
        match err.major_status() {
            // User-controllable execution errors should abort
            StatusCode::TOO_MANY_TYPE_NODES
            | StatusCode::VM_MAX_VALUE_DEPTH_REACHED 
            | StatusCode::VALUE_SERIALIZATION_ERROR
            | StatusCode::VALUE_DESERIALIZATION_ERROR => {
                SafeNativeError::Abort { abort_code: 0x10001 }
            },
            // Resource limit errors
            StatusCode::OUT_OF_GAS
            | StatusCode::EXECUTION_LIMIT_REACHED
            | StatusCode::MEMORY_LIMIT_EXCEEDED => {
                SafeNativeError::LimitExceeded(
                    LimitExceededError::LimitExceeded(MeteringError(err))
                )
            },
            // Everything else is invariant violation
            _ => SafeNativeError::InvariantViolation(err),
        }
    }
}
```

3. **Update native functions to use explicit classification:**
```rust
// In bcs.rs, replace line 78:
let layout = context.type_to_type_layout(arg_type)
    .map_err(SafeNativeError::from_partial_vm_error)?;
```

## Proof of Concept

```move
#[test_only]
module test_addr::gas_exploit {
    use std::bcs;
    
    // Create deeply nested type to exceed layout limits
    struct DeepNest has drop {
        level1: vector<Level1>,
    }
    
    struct Level1 has drop {
        level2: vector<Level2>,
    }
    
    struct Level2 has drop {
        level3: vector<Level3>,
    }
    
    struct Level3 has drop {
        level4: vector<Level4>,
    }
    
    struct Level4 has drop {
        data: vector<u8>,
    }
    
    #[test]
    #[expected_failure(abort_code = 0x10001)] // Should abort, not panic
    fun test_gas_undercharge() {
        // Create instance with deep nesting
        let nest = DeepNest {
            level1: vector[
                Level1 { level2: vector[
                    Level2 { level3: vector[
                        Level3 { level4: vector[
                            Level4 { data: vector[1, 2, 3] }
                        ]}
                    ]}
                ]}
            ]
        };
        
        // With lazy loading + ? operator, this fails without proper gas charging
        // The error gets promoted to InvariantViolation instead of Abort
        let _ = bcs::to_bytes(&nest);
    }
}
```

**Notes:**
- This vulnerability demonstrates how seemingly innocuous error handling patterns can create gas accounting bugs
- The TODO comment indicates developers are aware but the issue remains unfixed
- Multiple native functions throughout the codebase use this vulnerable pattern
- The impact extends beyond BCS serialization to any native function using `?` on `PartialVMResult` operations

### Citations

**File:** aptos-move/aptos-native-interface/src/errors.rs (L30-47)
```rust
    pub fn from_err(err: PartialVMError) -> SafeNativeError {
        match err.major_status() {
            StatusCode::OUT_OF_GAS
            | StatusCode::EXECUTION_LIMIT_REACHED
            | StatusCode::DEPENDENCY_LIMIT_REACHED
            | StatusCode::MEMORY_LIMIT_EXCEEDED
            | StatusCode::TOO_MANY_TYPE_NODES
            | StatusCode::VM_MAX_VALUE_DEPTH_REACHED => SafeNativeError::LimitExceeded(
                LimitExceededError::LimitExceeded(MeteringError(err)),
            ),
            // Treat all other code as invariant violations and leave it for the VM to propagate
            // these further. Note that we do not remap the errors. For example, if there is a
            // speculative error returned (signaling Block-STM to stop executing this transaction),
            // we better not remap it.
            // TODO(Gas): Have a single method to convert partial VM error to safe native error.
            _ => SafeNativeError::InvariantViolation(err),
        }
    }
```

**File:** aptos-move/aptos-native-interface/src/errors.rs (L97-109)
```rust
// Allows us to keep using the `?` operator on function calls that return `PartialVMResult` inside safe natives.
//
// TODO(Gas): This automatic conversion is VERY PROBLEMATIC as it makes it extremely easy to
//            accidentally propagate a non-invariant violation, which is a violation of the
//            contract.
//
//            We are actively seeking to remove this implementation.
//            Please help us stop the bleed by not using this conversion.
impl From<PartialVMError> for SafeNativeError {
    fn from(e: PartialVMError) -> Self {
        SafeNativeError::InvariantViolation(e)
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L202-221)
```rust
        let max_count = self.vm_config().layout_max_size;
        if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
            return Err(
                PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                    "Number of type nodes when constructing type layout exceeded the maximum of {}",
                    max_count
                )),
            );
        }
        *node_count += 1;

        if depth > self.vm_config().layout_max_depth {
            return Err(
                PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                    "Depth of a layout exceeded the maximum of {} during construction",
                    self.vm_config().layout_max_depth
                )),
            );
        }
        Ok(())
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L67-78)
```rust
    let layout = if context.get_feature_flags().is_lazy_loading_enabled() {
        // With lazy loading, propagate the error directly. This is because errors here are likely
        // from metering, so we should not remap them in any way. Note that makes it possible to
        // fail on constructing a very deep / large layout and not be charged, but this is already
        // the case for regular execution, so we keep it simple. Also, charging more gas after
        // out-of-gas failure in layout construction does not make any sense.
        //
        // Example:
        //   - Constructing layout runs into dependency limit.
        //   - We cannot do `context.charge(BCS_TO_BYTES_FAILURE)?;` because then we can end up in
        //     the state where out of gas and dependency limit are hit at the same time.
        context.type_to_type_layout(arg_type)?
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L80-88)
```rust
        match context.type_to_type_layout(arg_type) {
            Ok(layout) => layout,
            Err(_) => {
                context.charge(BCS_TO_BYTES_FAILURE)?;
                return Err(SafeNativeError::Abort {
                    abort_code: NFE_BCS_SERIALIZATION_FAILURE,
                });
            },
        }
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L149-151)
```rust
                    },
                    // TODO(Gas): Check if err is indeed an invariant violation.
                    InvariantViolation(err) => Err(err),
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1106-1106)
```rust
        let result = native_function(&mut native_context, ty_args, args)?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1150-1152)
```rust
            NativeResult::Abort { cost, abort_code } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
                Err(PartialVMError::new(StatusCode::ABORTED).with_sub_status(abort_code))
```
