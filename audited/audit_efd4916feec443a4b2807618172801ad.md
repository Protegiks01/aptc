# Audit Report

## Title
Faucet Silent Transaction Acceptance Leading to Sequence Number Desynchronization and Potential Double Funding

## Summary
The `submit_transaction()` function in the Aptos faucet can accept a transaction into mempool but return an error to the client due to network failures during response body reading. This causes a sequence number rollback via `decrement_sequence_number()` while the original transaction remains in mempool and will execute, creating a desynchronization between the faucet's local state and the actual blockchain state. While this does NOT enable double submission of the same transaction (due to mempool's duplicate prevention), it enables a different critical vulnerability: silent transaction success with error response, potentially leading to double funding if users retry.

## Finding Description

The vulnerability occurs in the transaction submission flow: [1](#0-0) 

The critical issue is in the error handling path. When `submit_bcs()` is called, it performs the following operations: [2](#0-1) 

The transaction submission can succeed at the server (mempool accepts it), but fail at the client during response processing: [3](#0-2) 

The `response.bytes().await?` call can fail due to network errors even after receiving HTTP 202 (Accepted) status, meaning the transaction is already in mempool.

**Attack Scenario:**

1. User requests funding via faucet (receiver X, amount Y)
2. Faucet increments sequence number from N to N+1 when signing
3. Transaction A (seq N) is submitted via `submit_bcs()`
4. Server validates and accepts transaction into mempool (returns HTTP 202)
5. Network error occurs while reading response body (`response.bytes().await?` fails)
6. Client propagates error, faucet calls `decrement_sequence_number()` (rollback to N)
7. Error returned to user as `TransactionFailed` (HTTP 403) [4](#0-3) 

8. Transaction A remains in mempool and will execute, funding receiver X
9. Rate limiting does NOT rollback because 403 is not a 5xx error: [5](#0-4) 

10. User, seeing the error, retries the request
11. On retry, `update_sequence_numbers()` synchronizes with on-chain state: [6](#0-5) 

12. If transaction A executed, on-chain seq is N+1, local syncs to N+1
13. New transaction B created with seq N+1, funding same or different receiver
14. Both transactions execute, causing double funding

**Regarding "Double Submission of Same Transaction":**

The mempool prevents true double submission via its duplicate detection logic: [7](#0-6) 

If an identical transaction (same payload, expiration, max gas) is resubmitted with the same sequence number, mempool treats it as idempotent. Different payloads or parameters are rejected with `InvalidUpdate`. Thus, the SAME transaction cannot be submitted twice.

However, the vulnerability enables **double funding with different transactions** at different sequence numbers, violating the at-most-once funding guarantee.

## Impact Explanation

**Severity: Medium** (Limited funds loss or manipulation)

This qualifies as Medium severity per Aptos bug bounty criteria:
- **Limited funds loss**: Faucet funds can be drained faster than intended through double funding
- **State inconsistency**: Faucet's local sequence number becomes desynchronized from blockchain state during the error window
- **User confusion**: Users receive errors for successful transactions, leading to retries and potential double funding

While not Critical (as it requires user retry and doesn't directly enable arbitrary theft), it represents a real funds loss vector that violates the faucet's intended single-funding-per-request semantic.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
1. Network error during HTTP response body reading (moderately rare but not impossible)
2. User retry after receiving error (highly likely given user behavior)
3. Rate limit not exceeded (depends on configuration)

Network errors during response body reads can occur naturally in unstable conditions or could potentially be induced by connection manipulation. The window is small but exploitable. Users routinely retry failed requests, making the second condition highly likely.

## Recommendation

Implement idempotency protection in the faucet by:

1. **Track submitted transaction hashes**: Before submitting, store the transaction hash with receiver address in Redis/storage
2. **Check on-chain before retry**: Before processing a retry, verify if the previous transaction was actually executed
3. **Use transaction hash for deduplication**: Check if a transaction with the same hash was recently submitted

**Code Fix:**

```rust
pub async fn submit_transaction(
    client: &Client,
    faucet_account: &RwLock<LocalAccount>,
    signed_transaction: SignedTransaction,
    receiver_address: &AccountAddress,
    wait_for_transactions: bool,
) -> Result<SignedTransaction, AptosTapError> {
    let tx_hash = signed_transaction.committed_hash();
    
    // Store submitted transaction hash before submission
    // (pseudo-code - implement with Redis)
    store_pending_tx(tx_hash, receiver_address).await?;
    
    let (result, event_on_success) = if wait_for_transactions {
        (
            client
                .submit_and_wait_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_success",
        )
    } else {
        (
            client
                .submit_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_submitted",
        )
    };

    match result {
        Ok(_) => {
            mark_tx_success(tx_hash).await?;
            info!(
                hash = tx_hash,
                address = receiver_address,
                event = event_on_success,
            );
            Ok(signed_transaction)
        },
        Err(e) => {
            // Check if transaction actually made it to mempool/chain
            // before decrementing sequence number
            if !transaction_exists_in_mempool_or_chain(client, tx_hash).await {
                faucet_account.write().await.decrement_sequence_number();
            }
            mark_tx_failed(tx_hash).await?;
            warn!(
                hash = tx_hash,
                address = receiver_address,
                event = "transaction_failure",
                error_message = format!("{:#}", e)
            );
            Err(e)
        },
    }
}
```

Additionally, implement request deduplication at the endpoint level based on (receiver, amount, recent_timestamp) tuples.

## Proof of Concept

```rust
#[tokio::test]
async fn test_silent_transaction_acceptance_double_funding() {
    // Setup faucet with local account at sequence number N
    let faucet_account = create_test_faucet_account(sequence_number: 100);
    let receiver = AccountAddress::random();
    let amount = 1_000_000;
    
    // Mock REST client that accepts transaction but fails during response read
    let mock_client = MockClient::new()
        .with_submit_behavior(|tx| {
            // Simulate: transaction accepted by mempool (HTTP 202)
            // but network error during response body read
            Err(anyhow!("Network error reading response body"))
        });
    
    // First request - transaction submitted but error returned
    let tx1_builder = create_transfer_transaction(receiver, amount);
    let tx1 = faucet_account.sign_with_transaction_builder(tx1_builder);
    assert_eq!(faucet_account.sequence_number(), 101); // Incremented during signing
    
    let result1 = submit_transaction(
        &mock_client,
        &faucet_account,
        tx1.clone(),
        &receiver,
        false
    ).await;
    
    // Verify error returned and sequence number decremented
    assert!(result1.is_err());
    assert_eq!(faucet_account.sequence_number(), 100); // Decremented on error
    
    // Transaction tx1 is actually in mempool (seq 100)
    assert!(mock_client.mempool_contains(&tx1));
    
    // User retries - sequence number resynchronized from on-chain
    // If tx1 executed, on-chain seq is 101, else still 100
    update_sequence_numbers(&mock_client, &faucet_account, receiver, amount, 30, "apt").await?;
    
    // Create second transaction
    let tx2_builder = create_transfer_transaction(receiver, amount);
    let tx2 = faucet_account.sign_with_transaction_builder(tx2_builder);
    
    let result2 = submit_transaction(
        &mock_client,
        &faucet_account,
        tx2,
        &receiver,
        false
    ).await;
    
    // Second transaction submitted successfully
    assert!(result2.is_ok());
    
    // Verify: Both transactions can execute, causing double funding
    execute_mempool_transactions(&mock_client).await;
    let receiver_balance = get_balance(&mock_client, receiver).await;
    assert_eq!(receiver_balance, 2 * amount); // Double funded!
}
```

**Notes:**
- The vulnerability does NOT enable double submission of the identical transaction due to mempool's duplicate prevention logic
- It DOES enable double funding through separate transactions with different sequence numbers
- The root cause is treating network-level errors the same as transaction validation errors
- Rate limiting based on requests (not successful transactions) does not prevent this
- Impact is limited to faucet fund drainage, not broader consensus or validator vulnerabilities

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L213-224)
```rust
    let (mut funder_seq, mut receiver_seq) =
        get_sequence_numbers(client, funder_account, receiver_address).await?;
    let our_funder_seq = {
        let funder_account = funder_account.write().await;

        // If the onchain sequence_number is greater than what we have, update our
        // sequence_numbers
        if funder_seq > funder_account.sequence_number() {
            funder_account.set_sequence_number(funder_seq);
        }
        funder_account.sequence_number()
    };
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L342-399)
```rust
pub async fn submit_transaction(
    client: &Client,
    faucet_account: &RwLock<LocalAccount>,
    signed_transaction: SignedTransaction,
    receiver_address: &AccountAddress,
    wait_for_transactions: bool,
) -> Result<SignedTransaction, AptosTapError> {
    let (result, event_on_success) = if wait_for_transactions {
        // If this fails, we assume it is the user's fault, e.g. because the
        // account already exists, but it is possible that the transaction
        // timed out. It's hard to tell because this function returns an opaque
        // anyhow error. https://github.com/aptos-labs/aptos-tap/issues/60.
        (
            client
                .submit_and_wait_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_success",
        )
    } else {
        (
            client
                .submit_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_submitted",
        )
    };

    // If there was an issue submitting a transaction we should just reset
    // our sequence numbers to what it was before.
    match result {
        Ok(_) => {
            info!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = event_on_success,
            );
            Ok(signed_transaction)
        },
        Err(e) => {
            faucet_account.write().await.decrement_sequence_number();
            warn!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = "transaction_failure",
                error_message = format!("{:#}", e)
            );
            Err(e)
        },
    }
}
```

**File:** crates/aptos-rest-client/src/lib.rs (L609-624)
```rust
    pub async fn submit_bcs(&self, txn: &SignedTransaction) -> AptosResult<Response<()>> {
        let txn_payload = bcs::to_bytes(txn)?;
        let url = self.build_path("transactions")?;

        let response = self
            .inner
            .post(url)
            .header(CONTENT_TYPE, BCS_SIGNED_TRANSACTION)
            .header(ACCEPT, BCS)
            .body(txn_payload)
            .send()
            .await?;

        let response = self.check_and_parse_bcs_response(response).await?;
        Ok(response.and_then(|bytes| bcs::from_bytes(&bytes))?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1773-1779)
```rust
    async fn check_and_parse_bcs_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<Response<bytes::Bytes>> {
        let (response, state) = self.check_response(response).await?;
        Ok(Response::new(response.bytes().await?, state))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L172-195)
```rust
    pub fn status(&self) -> StatusCode {
        match self {
            AptosTapErrorCode::InvalidRequest
            | AptosTapErrorCode::AccountDoesNotExist
            | AptosTapErrorCode::EndpointNotEnabled => StatusCode::BAD_REQUEST,
            AptosTapErrorCode::Rejected
            | AptosTapErrorCode::SourceIpMissing
            | AptosTapErrorCode::TransactionFailed
            | AptosTapErrorCode::AuthTokenInvalid => StatusCode::FORBIDDEN,
            AptosTapErrorCode::AptosApiError
            | AptosTapErrorCode::TransactionTimedOut
            | AptosTapErrorCode::SerializationError
            | AptosTapErrorCode::BypasserError
            | AptosTapErrorCode::CheckerError
            | AptosTapErrorCode::StorageError
            | AptosTapErrorCode::InternalError => StatusCode::INTERNAL_SERVER_ERROR,
            AptosTapErrorCode::ServerOverloaded | AptosTapErrorCode::FunderAccountProblem => {
                StatusCode::SERVICE_UNAVAILABLE
            },
            AptosTapErrorCode::YeahNahYeahYeahYeahNahYeahNah => StatusCode::IM_A_TEAPOT,
            // We shouldn't get here, this code is only used in error_converter.rs.
            AptosTapErrorCode::WebFrameworkError => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L308-335)
```rust
    async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
        if !data.response_is_500 {
            return Ok(());
        }

        let mut conn = self
            .get_redis_connection()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::StorageError))?;

        // Generate a key corresponding to this identifier and the current day. In the
        // JWT case we re-verify the JWT. This is inefficient, but these failures are
        // extremely rare so I don't refactor for now.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data.checker_data)
            .await?;
        let (key, _) = self.get_key_and_secs_until_next_day(key_prefix, &key_value);

        let _: () = conn.decr(&key, 1).await.map_err(|e| {
            AptosTapError::new_with_error_code(
                format!("Failed to decrement value for redis key {}: {}", key, e),
                AptosTapErrorCode::StorageError,
            )
        })?;
        Ok(())
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L256-293)
```rust
        if let Some(txns) = self.transactions.get_mut(&address) {
            if let Some(current_version) = txns.get_mut(&txn_replay_protector) {
                if current_version.txn.payload() != txn.txn.payload() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different payload".to_string(),
                    );
                } else if current_version.txn.expiration_timestamp_secs()
                    != txn.txn.expiration_timestamp_secs()
                {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different expiration timestamp"
                            .to_string(),
                    );
                } else if current_version.txn.max_gas_amount() != txn.txn.max_gas_amount() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different max gas amount"
                            .to_string(),
                    );
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
                    counters::CORE_MEMPOOL_GAS_UPGRADED_TXNS.inc();
                } else if current_version.get_gas_price() > txn.get_gas_price() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a higher gas price".to_string(),
                    );
                } else {
                    // If the transaction is the same, it's an idempotent call
                    // Updating signers is not supported, the previous submission must fail
                    counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
                    if let Some(acc_seq_num) = account_sequence_number {
                        self.process_ready_seq_num_based_transactions(&address, acc_seq_num);
                    }
                    return MempoolStatus::new(MempoolStatusCode::Accepted);
                }
            }
```
