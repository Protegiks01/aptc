# Audit Report

## Title
Uncoordinated Native Function Deployment Causes Consensus Failure During Protocol Upgrades

## Summary
Protocol upgrades that add new native functions can cause consensus failures when feature flags are enabled before all validators have upgraded their binaries. Validators running older binaries will fail to resolve the new native function and return `MISSING_DEPENDENCY` errors, while validators with newer binaries will successfully execute the same transaction, resulting in different state roots and breaking consensus safety.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Native Function Registration** - Native functions are hardcoded in the Rust binary and registered at VM initialization time: [1](#0-0) 

2. **Function Loading with Native Resolution** - When a Move module declares a native function, the VM attempts to resolve it from the `NativeFunctionTable` during `Function::new()`: [2](#0-1) 

If the native function is not found in the table, `native` is set to `None`. Later, when execution attempts to call it: [3](#0-2) 

The function returns a `MISSING_DEPENDENCY` error.

3. **Feature Flag Activation Without Binary Validation** - Feature flags can be enabled via governance without checking validator binary versions: [4](#0-3) 

The feature flag takes effect at the next epoch: [5](#0-4) 

**Attack Scenario:**

1. Initial state: All validators run binary v1.0 (contains native functions A, B, C)
2. New binary v1.1 is released (adds native function D) 
3. Some validators upgrade to v1.1, others remain on v1.0
4. Governance proposal enables feature flag `NATIVE_D_ENABLED`
5. Feature flag activates at epoch boundary
6. Move module is published declaring `native fun d()`
7. Transaction calls function `d()`

**Execution divergence:**

- **Validators on v1.0:** Native function D is not in their `NativeFunctionTable`. When loading the module, `Function::new()` cannot resolve it, sets `native = None`. During execution, `get_native()` returns `Err(MISSING_DEPENDENCY)`. Transaction fails.

- **Validators on v1.1:** Native function D exists in their `NativeFunctionTable`. When loading the module, `Function::new()` successfully resolves it, sets `native = Some(native_d)`. During execution, `get_native()` returns `Ok(native_d)`, the native checks the feature flag (which is enabled), and executes successfully. Transaction succeeds.

**Result:** Validators produce different transaction outcomes and different state roots, violating the fundamental consensus invariant.

## Impact Explanation

This is a **Critical Severity** vulnerability meeting the Aptos bug bounty criteria for "Consensus/Safety violations" (up to $1,000,000).

**Specific impacts:**

1. **Consensus Safety Violation:** Breaks the critical invariant "All validators must produce identical state roots for identical blocks" [6](#0-5) 

2. **Chain Split:** Validators will fork into two incompatible chains based on their binary version, requiring emergency intervention or hard fork to recover.

3. **Transaction Non-Determinism:** The same transaction produces different results on different validators, fundamentally breaking blockchain determinism guarantees.

4. **Network Partition:** The network effectively partitions into old-binary and new-binary validator sets, unable to reach consensus on any blocks containing the problematic transaction.

The environment hash mechanism that validates configuration consistency cannot detect this issue because the native function table is compiled into the binary, not derived from on-chain state: [7](#0-6) 

## Likelihood Explanation

**Likelihood: High** during any protocol upgrade that adds native functions.

The vulnerability is **highly likely** to occur because:

1. **Common Scenario:** Native functions are frequently added (as evidenced by multiple transient feature flags in the codebase): [8](#0-7) 

2. **No Preventive Mechanism:** There is no validation in the governance proposal system to ensure all validators have upgraded before enabling feature flags.

3. **Realistic Upgrade Timing:** During framework upgrades, validators upgrade asynchronously. The test suite explicitly validates mixed-version operation: [9](#0-8) 

4. **Manual Coordination Required:** The current process relies entirely on manual coordination between releasing binaries and enabling feature flags, with no automated safety checks.

## Recommendation

Implement a **mandatory coordination mechanism** that prevents feature flag activation until validator binary compatibility is confirmed. Specific recommendations:

1. **Binary Version Registry:** Validators should report their binary version (including native function capabilities) in their validator configuration:
   - Add `binary_version` field to `ValidatorConfig`
   - Include hash of `NativeFunctionTable` in version metadata

2. **Feature Flag Activation Guard:** Modify `change_feature_flags_for_next_epoch()` to validate that a supermajority (e.g., >2/3) of validators support the required native functions before allowing activation:

```rust
// In features.move
public fun change_feature_flags_for_next_epoch(
    framework: &signer,
    enable: vector<u64>,
    disable: vector<u64>
) acquires PendingFeatures, Features {
    assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));
    
    // NEW: Validate binary compatibility for native function features
    validate_native_function_compatibility(&enable);
    
    // ... rest of existing code
}

fun validate_native_function_compatibility(enable: &vector<u64>) {
    // Check validator set supports required natives
    // Abort if insufficient support
}
```

3. **Native Function Versioning:** Implement explicit versioning in `NativeFunctionTable` registration:

```rust
// In natives.rs
pub struct VersionedNativeFunctionTable {
    version: u64,
    functions: NativeFunctionTable,
}
```

4. **Soft Launch Period:** Introduce a mandatory waiting period between binary release and feature flag activation, documented in governance procedures.

5. **Automated Validation:** Add CI/CD checks that prevent framework proposals from enabling native function features unless the corresponding binary has been released for a minimum period.

## Proof of Concept

**Scenario Setup:**

```rust
// Step 1: Deploy two validator nodes with different binaries
// Node A: Binary v1.0 (without native function "new_native")
// Node B: Binary v1.1 (with native function "new_native")

// Step 2: Submit governance proposal to enable NEW_NATIVE feature flag
// features::change_feature_flags_for_next_epoch(@std, vector[NEW_NATIVE], vector[])

// Step 3: Wait for epoch boundary (feature activates)

// Step 4: Publish Move module with native function
module 0xCAFE::test {
    native fun new_native(): u64;
    
    public entry fun call_native() {
        let result = new_native();
        // Store result in global storage
    }
}

// Step 5: Submit transaction calling the native function
// Transaction: 0xCAFE::test::call_native()

// Expected outcome:
// - Node A (v1.0): Transaction fails with MISSING_DEPENDENCY (Status: Failed)
// - Node B (v1.1): Transaction succeeds (Status: Success)
// - Nodes produce different state roots
// - Consensus breaks, chain splits
```

**Validation Steps:**

1. Set up local testnet with two validators running different Aptos Core versions
2. Submit governance proposal enabling a new native function feature flag
3. Publish Move module declaring the native function
4. Submit transaction calling the native function
5. Observe different execution results on different validators
6. Confirm state root divergence via validator logs
7. Verify consensus failure and inability to commit blocks

The vulnerability can be reproduced on any testnet where validators run mixed binary versions during a protocol upgrade involving new native functions.

## Notes

This vulnerability highlights a fundamental coordination problem in blockchain protocol upgrades. While feature flags provide runtime control over behavior changes, they cannot protect against differences in the compiled binary itself (i.e., the native function implementations). The current design assumes perfect coordination between binary deployment and feature flag activation, which is unrealistic in a decentralized validator network.

The issue is particularly critical because:
- It affects the core consensus safety guarantee
- It can occur during routine protocol upgrades
- There is no automated detection or prevention mechanism
- Recovery requires emergency coordination or hard fork

Similar issues may exist for other binary-level changes beyond native functions, such as gas parameter changes or VM configuration modifications that aren't fully controlled by on-chain state.

### Citations

**File:** aptos-move/aptos-vm-environment/src/natives.rs (L10-46)
```rust
pub fn aptos_natives_with_builder(
    builder: &mut SafeNativeBuilder,
    inject_create_signer_for_gov_sim: bool,
) -> NativeFunctionTable {
    let vector_bytecode_instruction_methods = HashSet::from([
        "empty",
        "length",
        "borrow",
        "borrow_mut",
        "push_back",
        "pop_back",
        "destroy_empty",
        "swap",
    ]);

    #[allow(unreachable_code)]
    aptos_move_stdlib::natives::all_natives(CORE_CODE_ADDRESS, builder)
        .into_iter()
        .filter(|(_, name, func_name, _)|
            if name.as_str() == "vector" && vector_bytecode_instruction_methods.contains(func_name.as_str()) {
                println!("ERROR: Tried to register as native a vector bytecode_instruction method {}, skipping.", func_name.as_str());
                false
            } else {
                true
            }
        )
        .chain(aptos_framework::natives::all_natives(
            CORE_CODE_ADDRESS,
            builder,
            inject_create_signer_for_gov_sim,
        ))
        .chain(aptos_table_natives::table_natives(
            CORE_CODE_ADDRESS,
            builder,
        ))
        .collect()
}
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L647-656)
```rust
        let (native, is_native) = if def.is_native() {
            let native = natives.resolve(
                module_id.address(),
                module_id.name().as_str(),
                name.as_str(),
            );
            (native, true)
        } else {
            (None, false)
        };
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L772-777)
```rust
    pub(crate) fn get_native(&self) -> PartialVMResult<&UnboxedNativeFunction> {
        self.native.as_deref().ok_or_else(|| {
            PartialVMError::new(StatusCode::MISSING_DEPENDENCY)
                .with_message(format!("Missing Native Function `{}`", self.name))
        })
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L38-44)
```text
    /// Whether validation of package dependencies is enabled, and the related native function is
    /// available. This is needed because of introduction of a new native function.
    /// Lifetime: transient
    const CODE_DEPENDENCY_CHECK: u64 = 1;

    public fun code_dependency_check_enabled(): bool acquires Features {
        is_enabled(CODE_DEPENDENCY_CHECK)
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L834-844)
```text
    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
        ensure_framework_signer(framework);
        if (exists<PendingFeatures>(@std)) {
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            if (exists<Features>(@std)) {
                Features[@std].features = features;
            } else {
                move_to(framework, Features { features })
            }
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L212-318)
```rust
    fn new(
        state_view: &impl StateView,
        inject_create_signer_for_gov_sim: bool,
        gas_hook: Option<Arc<dyn Fn(DynamicExpression) + Send + Sync>>,
    ) -> Self {
        // We compute and store a hash of configs in order to distinguish different environments.
        let mut sha3_256 = Sha3_256::new();
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

        // If no chain ID is in storage, we assume we are in a testing environment.
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
        let timestamp_micros =
            fetch_config_and_update_hash::<ConfigurationResource>(&mut sha3_256, state_view)
                .map(|config| config.last_reconfiguration_time_micros())
                .unwrap_or(0);

        let mut timed_features_builder = TimedFeaturesBuilder::new(chain_id, timestamp_micros);
        if let Some(profile) = get_timed_feature_override() {
            // We need to ensure the override is taken into account for the hash.
            let profile_bytes = bcs::to_bytes(&profile)
                .expect("Timed features override should always be serializable");
            sha3_256.update(&profile_bytes);

            timed_features_builder = timed_features_builder.with_override_profile(profile)
        }
        let timed_features = timed_features_builder.build();

        // TODO(Gas):
        //   Right now, we have to use some dummy values for gas parameters if they are not found
        //   on-chain. This only happens in a edge case that is probably related to write set
        //   transactions or genesis, which logically speaking, shouldn't be handled by the VM at
        //   all. We should clean up the logic here once we get that refactored.
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
        let (native_gas_params, misc_gas_params, ty_builder) = match &gas_params {
            Ok(gas_params) => {
                let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params);
                (
                    gas_params.natives.clone(),
                    gas_params.vm.misc.clone(),
                    ty_builder,
                )
            },
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
        };

        let mut builder = SafeNativeBuilder::new(
            gas_feature_version,
            native_gas_params,
            misc_gas_params,
            timed_features.clone(),
            features.clone(),
            gas_hook,
        );
        let natives = aptos_natives_with_builder(&mut builder, inject_create_signer_for_gov_sim);
        let vm_config = aptos_prod_vm_config(
            chain_id,
            gas_feature_version,
            &features,
            &timed_features,
            ty_builder,
        );
        let verifier_bytes =
            bcs::to_bytes(&vm_config.verifier_config).expect("Verifier config is serializable");
        let runtime_environment = RuntimeEnvironment::new_with_config(natives, vm_config);

        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
        let keyless_configuration =
            Configuration::fetch_keyless_config(state_view).map(|(config, config_bytes)| {
                sha3_256.update(&config_bytes);
                config
            });

        let hash = sha3_256.finalize().into();

        #[allow(deprecated)]
        Self {
            chain_id,
            features,
            timed_features,
            keyless_pvk,
            keyless_configuration,
            gas_feature_version,
            gas_params,
            storage_gas_params,
            runtime_environment,
            inject_create_signer_for_gov_sim,
            hash,
            verifier_bytes,
            async_runtime_checks_enabled: get_async_runtime_checks(),
        }
    }
```

**File:** testsuite/testcases/src/framework_upgrade.rs (L77-82)
```rust
        // Update half the validators to latest version.
        let first_half = &all_validators[..all_validators.len() / 2];
        let msg = format!("Upgrade the nodes to version: {}", new_version);
        info!("{}", msg);
        ctx.report.report_text(msg);
        batch_update(ctx, first_half, &new_version).await?;
```
