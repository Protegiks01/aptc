# Audit Report

## Title
Unverified LedgerInfoWithSignatures in Consensus Observer Enables Denial of Service

## Summary
Consensus observer nodes accept `CommitDecision` messages for future epochs without verifying the cryptographic signatures on the embedded `LedgerInfoWithSignatures`. This allows any malicious peer to send a fake commit decision with an arbitrarily high version number, causing the victim node to become permanently stuck attempting to sync to a non-existent target, resulting in a denial of service.

## Finding Description
The vulnerability exists in the consensus observer's handling of commit decision messages. When a `CommitDecision` is received for a future epoch or future round, the signature verification step is bypassed, and the unverified ledger info is directly used as a state sync target. [1](#0-0) 

The verification at line 470 only executes when `commit_epoch == epoch_state.epoch`. For future epochs or rounds within the same epoch, the code skips verification and proceeds to lines 500-527, where it unconditionally accepts the commit decision and initiates state sync. [2](#0-1) 

The unverified `LedgerInfoWithSignatures` flows through:
1. `sync_to_commit()` extracts the commit proof without verification [3](#0-2) 

2. Eventually reaching `initialize_sync_target_request()` which stores the target without signature verification [4](#0-3) 

3. The `sync_request_satisfied()` function then compares versions using this unverified target [5](#0-4) 

**Attack Scenario:**
1. Attacker crafts a `CommitDecision` with invalid signatures, future epoch (e.g., epoch 999), and arbitrarily high version (e.g., version 999,999,999)
2. Sends this to a consensus observer node via network message
3. Node accepts it without verification (line 468 condition fails)
4. Node sets this as sync target and attempts to sync to version 999,999,999
5. Honest peers only have data up to legitimate version (e.g., version 1,000)
6. Node never reaches the fake target version
7. `sync_request_satisfied()` always returns false
8. Node remains stuck in state sync indefinitely, unable to participate in consensus

## Impact Explanation
This is a **Critical Severity** vulnerability meeting the "Total loss of liveness/network availability" criterion:

- **Targeted DoS**: Any consensus observer node can be individually disabled by a single malicious network message
- **No Recovery**: The node remains stuck until manual intervention (restart or configuration change)
- **Network Impact**: If multiple consensus observer nodes are targeted, network observability and data streaming capabilities are degraded
- **Consensus Disruption**: Affected nodes cannot forward blocks or participate in consensus observation

While consensus validators themselves may not be affected (they use different code paths), consensus observers are critical infrastructure for:
- Block streaming to full nodes
- Network monitoring and observability  
- Data availability for indexers and applications

The attack requires no special privilegesâ€”any peer that can send network messages to the victim node can execute it.

## Likelihood Explanation
**Likelihood: HIGH**

- **Attack Complexity**: Trivial - requires only crafting a single network message with fake values
- **Attacker Requirements**: Ability to send P2P messages to target node (standard network access)
- **Detection Difficulty**: Hard to distinguish from legitimate future epoch messages initially
- **Prevalence**: Affects all consensus observer nodes in the network
- **Exploit Reliability**: 100% success rate once message is delivered

The only barrier is network-level access to send messages to consensus observer nodes, which is standard in P2P networks.

## Recommendation
Add signature verification for commit decisions targeting future epochs before using them as sync targets:

```rust
// In process_commit_decision_message, around line 466:
let epoch_state = self.get_epoch_state();

// For future epochs, we need to verify against known epoch states
// or reject if we cannot verify
if commit_epoch > epoch_state.epoch {
    // Option 1: Reject future epoch commits we cannot verify
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting commit decision for future epoch {:?} (current epoch: {:?})",
            commit_epoch, epoch_state.epoch
        ))
    );
    return;
    
    // Option 2: If epoch change proofs are available, verify against them
    // This would require additional epoch state tracking
}

// Always verify the commit proof before using it
if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
    error!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Failed to verify commit decision! Ignoring: {:?}, Error: {:?}",
            commit_decision.proof_block_info(), error
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}
```

Additionally, add verification in `initialize_sync_target_request`:

```rust
// In initialize_sync_target_request, after line 273:
// Verify the sync target signatures against current epoch state
let epoch_state = utils::fetch_latest_epoch_state(storage.clone())?;
sync_target_notification.get_target()
    .verify_signatures(&epoch_state.verifier)
    .map_err(|e| Error::VerificationError(
        format!("Sync target has invalid signatures: {:?}", e)
    ))?;
```

## Proof of Concept

```rust
// Rust PoC - demonstrates the attack flow
#[test]
fn test_unverified_future_epoch_commit_decision_dos() {
    // Setup: Create a consensus observer node
    let (mut observer, peer_id) = setup_consensus_observer();
    
    // Attacker: Create a fake commit decision with invalid signatures
    // for a non-existent future epoch and very high version
    let fake_epoch = 9999;
    let fake_version = 999_999_999;
    let fake_block_info = BlockInfo::new(
        fake_epoch,
        0, // round
        HashValue::random(),
        HashValue::random(),
        fake_version,
        0, // timestamp
        None,
    );
    
    // Create ledger info with INVALID/EMPTY signatures
    let fake_ledger_info = LedgerInfo::new(
        fake_block_info,
        HashValue::random(),
    );
    let fake_commit_proof = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(), // Invalid signatures!
    );
    
    let malicious_commit_decision = CommitDecision::new(fake_commit_proof);
    
    // Attack: Send the malicious commit decision
    let message = ConsensusObserverDirectSend::CommitDecision(
        malicious_commit_decision
    );
    
    // The observer processes it WITHOUT verification
    observer.process_network_message(
        ConsensusObserverNetworkMessage::new(peer_id, message)
    ).await;
    
    // Verify: The observer is now stuck trying to sync to version 999,999,999
    // It will never reach this target and cannot participate in consensus
    let active_sync = observer.state_sync_manager.is_syncing_to_commit();
    assert!(active_sync); // Observer is stuck syncing
    
    // Even after receiving legitimate data up to version 1000,
    // the observer still thinks it needs to sync to 999,999,999
    advance_to_version(&mut observer, 1000);
    
    let still_syncing = observer.state_sync_manager.is_syncing_to_commit();
    assert!(still_syncing); // Still stuck - DoS successful
}
```

## Notes
The vulnerability specifically affects consensus observer nodes. Regular consensus validators use different code paths that properly verify commit decisions. However, consensus observers are critical infrastructure components, and their compromise impacts network data availability and observability.

The root cause is the assumption that future epoch commit decisions will be verified "later" during state sync, but the verification never actually occurs before the unverified target is used for sync satisfaction checks.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L218-222)
```rust
                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L184-208)
```rust
    pub fn sync_request_satisfied(
        &self,
        latest_synced_ledger_info: &LedgerInfoWithSignatures,
        time_service: TimeService,
    ) -> bool {
        match self {
            ConsensusSyncRequest::SyncDuration(start_time, sync_duration_notification) => {
                // Get the duration and the current time
                let sync_duration = sync_duration_notification.get_duration();
                let current_time = time_service.now();

                // Check if the duration has been reached
                current_time.duration_since(*start_time) >= sync_duration
            },
            ConsensusSyncRequest::SyncTarget(sync_target_notification) => {
                // Get the sync target version and latest synced version
                let sync_target = sync_target_notification.get_target();
                let sync_target_version = sync_target.ledger_info().version();
                let latest_synced_version = latest_synced_ledger_info.ledger_info().version();

                // Check if we've satisfied the target
                latest_synced_version >= sync_target_version
            },
        }
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L262-318)
```rust
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```
