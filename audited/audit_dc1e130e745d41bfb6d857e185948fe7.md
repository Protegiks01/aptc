# Audit Report

## Title
Compromised Validator Keys Remain Valid Until Epoch Boundary Allowing Post-Rotation Consensus Attacks

## Summary
When a validator rotates their consensus key via `rotate_consensus_key`, the old key remains valid and can be used to sign consensus messages (blocks, votes, commits) until the next epoch boundary. An attacker who compromises a validator's old key can continue exploiting it for potentially hours after the validator has rotated to a new key, enabling double-signing attacks and consensus safety violations.

## Finding Description

The vulnerability exists in the delayed application of validator key rotations during epoch transitions. The attack unfolds as follows:

**Key Rotation Flow:**

1. When `rotate_consensus_key` is called, it immediately updates the `ValidatorConfig` at the validator's address with the new public key. [1](#0-0) 

2. However, the `ValidatorSet` stored at `@aptos_framework` (which consensus uses for signature verification) is NOT updated until `on_new_epoch` is called at the epoch boundary. [2](#0-1) 

3. The consensus layer creates its `ValidatorVerifier` from the `ValidatorSet` at epoch boundaries: [3](#0-2) 

4. During the current epoch (after key rotation but before the next epoch), the `ValidatorVerifier` still contains the OLD public key and accepts signatures from it.

**Critical Evidence:**

The `validator_consensus_infos_from_validator_set` function explicitly includes BOTH `active_validators` AND `pending_inactive` validators (those who called `leave_validator_set`) in the consensus set: [4](#0-3) 

Even if a validator attempts emergency exit via `leave_validator_set`, they are moved to `pending_inactive` and remain in the consensus set until the epoch ends: [5](#0-4) 

**Attack Scenario:**

1. Attacker compromises Validator V's consensus private key (via malware, insider threat, etc.)
2. Validator V operator detects the compromise and calls `rotate_consensus_key` with a new key
3. Validator V operator may even call `leave_validator_set` to attempt emergency exit
4. However, during the remaining duration of the current epoch:
   - The `ValidatorSet` still contains Validator V's OLD public key
   - The `ValidatorVerifier` still accepts signatures from the OLD key
   - The attacker can use the compromised OLD key to:
     - Sign conflicting votes (equivocation)
     - Sign malicious blocks if they win leader election  
     - Create divergent consensus quorums
     - Violate BFT consensus safety assumptions
5. The attack window persists until the epoch boundary (potentially several hours in production)

## Impact Explanation

This is a **HIGH severity** vulnerability per the Aptos Bug Bounty criteria because it enables:

1. **Consensus Safety Violations**: An attacker with a compromised old key can double-sign conflicting consensus messages, violating the BFT safety assumption that < 1/3 validators are Byzantine. This breaks the fundamental "Consensus Safety" invariant.

2. **Validator Slashing**: The legitimate validator gets slashed for equivocation caused by the attacker using their old compromised key, resulting in loss of staked funds.

3. **Significant Protocol Violations**: The ability to use revoked keys contradicts the security guarantee that key rotation provides immediate revocation.

While this doesn't directly cause "Loss of Funds" or "Non-recoverable network partition" (Critical severity), it enables "Significant protocol violations" and validator node disruption, qualifying as High Severity (up to $50,000 per bounty guidelines).

The impact is amplified if multiple validators' keys are compromised within the same epoch, as attackers could coordinate to exceed the 1/3 Byzantine threshold.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to be exploited in practice because:

1. **Common Key Compromise Scenarios**: Validator keys can be compromised through various realistic vectors (malware, insider threats, operational errors, cloud security breaches).

2. **Window of Opportunity**: Production Aptos epochs are typically measured in hours, giving attackers a substantial exploitation window after key rotation is initiated.

3. **Operator Misconception**: Validators operators may reasonably expect that calling `rotate_consensus_key` immediately revokes the old key. The delayed revocation is not clearly documented as a security limitation.

4. **No Emergency Override**: There is no mechanism for immediate key revocation - even `leave_validator_set` doesn't provide emergency exit from consensus participation. [6](#0-5) 

5. **Test Evidence**: The smoke test for key rotation demonstrates that validators continue operating with old keys during the transition period: [7](#0-6) 

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Immediate Validator Exclusion (Recommended)**
Add an emergency key revocation mechanism that immediately removes a validator from consensus participation:

```move
/// Emergency function to immediately exclude a validator from consensus
/// due to key compromise. Validator is marked as Byzantine and excluded
/// from current epoch consensus without waiting for epoch boundary.
public entry fun emergency_exclude_validator(
    validator: &signer,
    pool_address: address
) acquires StakePool, ValidatorSet {
    // Verify caller is the validator operator
    let stake_pool = borrow_global<StakePool>(pool_address);
    assert!(signer::address_of(validator) == stake_pool.operator_address, ENOT_OPERATOR);
    
    // Immediately remove from active validators and mark as excluded
    let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
    let maybe_active_index = find_validator(&validator_set.active_validators, pool_address);
    if (option::is_some(&maybe_active_index)) {
        vector::swap_remove(&mut validator_set.active_validators, 
                          option::extract(&mut maybe_active_index));
    };
    
    // Trigger immediate reconfiguration without waiting for epoch boundary
    reconfiguration::reconfigure_for_emergency();
}
```

**Option 2: Two-Key Transition Period**
Require validators to have BOTH old and new keys in storage during transition, with consensus accepting signatures from either key. After epoch transition, validators can safely delete the old key. This is partially implemented via `overriding_identity_blob_paths` but needs formalization: [8](#0-7) 

**Option 3: Clear Documentation and Monitoring**
At minimum, clearly document that:
- Old keys remain valid until the next epoch boundary
- Operators should NOT discard old keys until epoch transition completes
- Compromised keys cannot be immediately revoked
- Add monitoring/alerting for unexpected signatures from rotated keys

## Proof of Concept

```move
#[test_only]
module aptos_framework::consensus_key_rotation_attack_test {
    use aptos_framework::stake;
    use aptos_framework::timestamp;
    use aptos_std::bls12381;
    use std::vector;

    #[test(aptos_framework = @aptos_framework, validator = @0x123)]
    fun test_old_key_remains_valid_after_rotation(
        aptos_framework: &signer,
        validator: &signer
    ) {
        // Setup: Initialize validator with old key
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let (old_sk, old_pk, old_pop) = generate_bls_key();
        let validator_addr = signer::address_of(validator);
        
        stake::initialize_validator(
            validator,
            bls12381::public_key_to_bytes(&old_pk),
            bls12381::proof_of_possession_to_bytes(&old_pop),
            vector::empty(),
            vector::empty()
        );
        stake::join_validator_set(validator, validator_addr);
        stake::end_epoch(); // Activate validator
        
        // Get current validator set with old key
        let validator_set_before = stake::get_validator_set();
        let verifier_before = validator_verifier::from(&validator_set_before);
        
        // Simulate key compromise: attacker has old_sk
        // Validator rotates to new key
        let (new_sk, new_pk, new_pop) = generate_bls_key();
        stake::rotate_consensus_key(
            validator,
            validator_addr,
            bls12381::public_key_to_bytes(&new_pk),
            bls12381::proof_of_possession_to_bytes(&new_pop)
        );
        
        // VULNERABILITY: Get validator set AFTER rotation but BEFORE epoch end
        let validator_set_after_rotation = stake::get_validator_set();
        let verifier_after_rotation = validator_verifier::from(&validator_set_after_rotation);
        
        // PROOF: Old key is still in the validator verifier!
        let old_pk_in_verifier = verifier_after_rotation.get_public_key(&validator_addr);
        assert!(old_pk_in_verifier == old_pk, 1); // Old key still valid!
        
        // Attacker can still sign messages with compromised old_sk
        let test_message = b"malicious_vote";
        let malicious_signature = bls12381::sign(&old_sk, test_message);
        
        // Signature verification succeeds with old key during current epoch
        assert!(
            bls12381::verify(&old_pk, test_message, &malicious_signature),
            2
        ); // Compromised key still works!
        
        // Only after epoch ends does new key take effect
        stake::end_epoch();
        let validator_set_new_epoch = stake::get_validator_set();
        let verifier_new_epoch = validator_verifier::from(&validator_set_new_epoch);
        let pk_in_new_epoch = verifier_new_epoch.get_public_key(&validator_addr);
        assert!(pk_in_new_epoch == new_pk, 3); // Now new key is active
    }
    
    fun generate_bls_key(): (bls12381::PrivateKey, bls12381::PublicKey, bls12381::ProofOfPossession) {
        // Implementation omitted - generates BLS key triple
    }
}
```

## Notes

This vulnerability affects the core security assumption of key rotation mechanisms. While the delayed activation is by design for smooth epoch transitions, it creates a dangerous window where compromised keys remain valid. Validators need either an emergency revocation mechanism or clear operational procedures to handle key compromise scenarios during this grace period.

The issue is exacerbated because the smoke test demonstrates validators must maintain both old and new keys during transition [7](#0-6) , but there's no formal security analysis of this dual-key period or guidance on when operators can safely discard old keys.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L910-952)
```text
    public entry fun rotate_consensus_key(
        operator: &signer,
        pool_address: address,
        new_consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);

        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));

        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_consensus_pubkey = validator_info.consensus_pubkey;
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
        validator_info.consensus_pubkey = new_consensus_pubkey;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                RotateConsensusKey {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.rotate_consensus_key_events,
                RotateConsensusKeyEvent {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1213-1256)
```text
    public entry fun leave_validator_set(
        operator: &signer,
        pool_address: address
    ) acquires StakePool, ValidatorSet {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        let config = staking_config::get();
        assert!(
            staking_config::get_allow_validator_set_change(&config),
            error::invalid_argument(ENO_POST_GENESIS_VALIDATOR_SET_CHANGE_ALLOWED),
        );

        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Account has to be the operator.
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));

        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        // If the validator is still pending_active, directly kick the validator out.
        let maybe_pending_active_index = find_validator(&validator_set.pending_active, pool_address);
        if (option::is_some(&maybe_pending_active_index)) {
            vector::swap_remove(
                &mut validator_set.pending_active, option::extract(&mut maybe_pending_active_index));

            // Decrease the voting power increase as the pending validator's voting power was added when they requested
            // to join. Now that they changed their mind, their voting power should not affect the joining limit of this
            // epoch.
            let validator_stake = (get_next_epoch_voting_power(stake_pool) as u128);
            // total_joining_power should be larger than validator_stake but just in case there has been a small
            // rounding error somewhere that can lead to an underflow, we still want to allow this transaction to
            // succeed.
            if (validator_set.total_joining_power > validator_stake) {
                validator_set.total_joining_power = validator_set.total_joining_power - validator_stake;
            } else {
                validator_set.total_joining_power = 0;
            };
        } else {
            // Validate that the validator is already part of the validator set.
            let maybe_active_index = find_validator(&validator_set.active_validators, pool_address);
            assert!(option::is_some(&maybe_active_index), error::invalid_state(ENOT_VALIDATOR));
            let validator_info = vector::swap_remove(
                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
            vector::push_back(&mut validator_set.pending_inactive, validator_info);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1369-1401)
```text
        // Update active validator set so that network address/public key change takes effect.
        // Moreover, recalculate the total voting power, and deactivate the validator whose
        // voting power is less than the minimum required stake.
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1572-1636)
```text
    fun validator_consensus_infos_from_validator_set(validator_set: &ValidatorSet): vector<ValidatorConsensusInfo> {
        let validator_consensus_infos = vector[];

        let num_active = vector::length(&validator_set.active_validators);
        let num_pending_inactive = vector::length(&validator_set.pending_inactive);
        spec {
            assume num_active + num_pending_inactive <= MAX_U64;
        };
        let total = num_active + num_pending_inactive;

        // Pre-fill the return value with dummy values.
        let idx = 0;
        while ({
            spec {
                invariant idx <= len(validator_set.active_validators) + len(validator_set.pending_inactive);
                invariant len(validator_consensus_infos) == idx;
                invariant len(validator_consensus_infos) <= len(validator_set.active_validators) + len(validator_set.pending_inactive);
            };
            idx < total
        }) {
            vector::push_back(&mut validator_consensus_infos, validator_consensus_info::default());
            idx = idx + 1;
        };
        spec {
            assert len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);
            assert spec_validator_indices_are_valid_config(validator_set.active_validators,
                len(validator_set.active_validators) + len(validator_set.pending_inactive));
        };

        vector::for_each_ref(&validator_set.active_validators, |obj| {
            let vi: &ValidatorInfo = obj;
            spec {
                assume len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);
                assert vi.config.validator_index < len(validator_consensus_infos);
            };
            let vci = vector::borrow_mut(&mut validator_consensus_infos, vi.config.validator_index);
            *vci = validator_consensus_info::new(
                vi.addr,
                vi.config.consensus_pubkey,
                vi.voting_power
            );
            spec {
                assert len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);
            };
        });

        vector::for_each_ref(&validator_set.pending_inactive, |obj| {
            let vi: &ValidatorInfo = obj;
            spec {
                assume len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);
                assert vi.config.validator_index < len(validator_consensus_infos);
            };
            let vci = vector::borrow_mut(&mut validator_consensus_infos, vi.config.validator_index);
            *vci = validator_consensus_info::new(
                vi.addr,
                vi.config.consensus_pubkey,
                vi.voting_power
            );
            spec {
                assert len(validator_consensus_infos) == len(validator_set.active_validators) + len(validator_set.pending_inactive);
            };
        });

        validator_consensus_infos
    }
```

**File:** consensus/src/epoch_manager.rs (L1164-1174)
```rust
    async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
        verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);

        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });
```

**File:** testsuite/smoke-test/src/consensus_key_rotation.rs (L99-116)
```rust
            info!("Updating the node config accordingly.");
            let config_path = validator.config_path();
            let mut validator_override_config =
                OverrideNodeConfig::load_config(config_path.clone()).unwrap();
            validator_override_config
                .override_config_mut()
                .consensus
                .safety_rules
                .initial_safety_rules_config
                .overriding_identity_blob_paths_mut()
                .push(new_identity_path);
            validator_override_config.save_config(config_path).unwrap();

            info!("Restarting the node.");
            validator.start().unwrap();
            info!("Let it bake for 5 secs.");
            tokio::time::sleep(Duration::from_secs(5)).await;
            (operator_addr, new_pk, pop, operator_idx)
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L79-99)
```rust
        // Ensuring all the overriding consensus keys are in the storage.
        let timer = Instant::now();
        for blob in config
            .initial_safety_rules_config
            .overriding_identity_blobs()
            .unwrap_or_default()
        {
            if let Some(sk) = blob.consensus_private_key {
                let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
                let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
                match storage.internal_store().set(storage_key.as_str(), sk) {
                    Ok(_) => {
                        info!("Setting {storage_key} succeeded.");
                    },
                    Err(e) => {
                        warn!("Setting {storage_key} failed with internal store set error: {e}");
                    },
                }
            }
        }
        info!("Overriding key work time: {:?}", timer.elapsed());
```
