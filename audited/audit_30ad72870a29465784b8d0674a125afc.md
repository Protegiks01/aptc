# Audit Report

## Title
Table Metadata Leak: removed_tables Field Ignored During Transaction Execution

## Summary
The `TableChangeSet.removed_tables` field is populated when tables are destroyed but completely ignored during VM execution, causing table metadata to persist indefinitely in the indexer storage even after table destruction.

## Finding Description

The Aptos table extension maintains a `TableChangeSet` structure with three fields to track table lifecycle: [1](#0-0) 

When a table is destroyed via `destroy_empty_box`, the handle is added to `removed_tables`: [2](#0-1) 

When `into_change_set` produces the final TableChangeSet, it includes all three fields: [3](#0-2) 

**However**, during transaction execution in `convert_change_set`, only `table_change_set.changes` is processed: [4](#0-3) 

The `removed_tables` and `new_tables` fields are completely ignored. This means:

1. A table can be in both `removed_tables` AND have entries in `changes` when a user removes entries then destroys the table
2. The destruction is never processed - only the entry deletions are applied
3. Table metadata persists in the indexer indefinitely

The indexer extracts table metadata by parsing Move struct values from write sets, not from `new_tables`: [5](#0-4) 

There is no mechanism to delete table metadata when tables are destroyed.

## Impact Explanation

**Low Severity** - This is a non-critical implementation bug rather than a security vulnerability:

1. **No Consensus Impact**: All validators process transactions identically since `removed_tables` is consistently ignored
2. **No Fund Impact**: Cannot be exploited to steal, create, or freeze funds  
3. **No Availability Impact**: Does not cause crashes, slowdowns, or DoS
4. **Limited State Impact**: Only affects off-chain indexer metadata, not on-chain state

The impact is limited to storage accumulation in the indexer database (metadata for destroyed tables never removed) and potential confusion for applications querying table metadata. This does not meet Medium severity criteria of "State inconsistencies requiring intervention" because the actual blockchain state (table entries) is correct.

## Likelihood Explanation

**High Likelihood**: Any user can trigger this by creating and destroying tables in their transactions. However, the lack of security impact makes this a maintenance issue rather than an exploitable vulnerability.

## Recommendation

Process `removed_tables` in `convert_change_set`:

```rust
// After processing changes, handle table metadata lifecycle
for handle in table_change_set.removed_tables {
    // Add deletion marker for table metadata
    // Implementation depends on how table metadata is tracked
}
```

Alternatively, if table metadata tracking is not needed, remove the unused `new_tables` and `removed_tables` fields entirely.

## Proof of Concept

```move
module test::table_leak {
    use aptos_std::table;
    
    public fun demonstrate_leak() {
        // Create table
        let t = table::new<u64, u64>();
        
        // Add and remove entry
        table::add(&mut t, 1, 100);
        table::remove(&mut t, 1);
        
        // Destroy table - adds to removed_tables but metadata persists
        table::destroy_empty(t);
        
        // Table metadata remains in indexer despite destruction
    }
}
```

---

**Notes**: While this is a valid implementation bug, it does not constitute a security vulnerability per Aptos bug bounty criteria. The impact is limited to off-chain indexer storage accumulation without affecting consensus, execution correctness, or fund safety.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L98-103)
```rust
#[derive(Default)]
pub struct TableChangeSet {
    pub new_tables: BTreeMap<TableHandle, TableInfo>,
    pub removed_tables: BTreeSet<TableHandle>,
    pub changes: BTreeMap<TableHandle, TableChange>,
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L144-204)
```rust
    /// Computes the change set from a NativeTableContext.
    pub fn into_change_set(
        self,
        function_value_extension: &impl FunctionValueExtension,
    ) -> PartialVMResult<TableChangeSet> {
        let NativeTableContext { table_data, .. } = self;
        let TableData {
            new_tables,
            removed_tables,
            tables,
        } = table_data.into_inner();
        let mut changes = BTreeMap::new();
        for (handle, table) in tables {
            let Table {
                value_layout_info,
                content,
                ..
            } = table;
            let mut entries = BTreeMap::new();
            for (key, gv) in content {
                let op = match gv.into_effect() {
                    Some(op) => op,
                    None => continue,
                };

                match op {
                    Op::New(val) => {
                        entries.insert(
                            key,
                            Op::New(serialize_value(
                                function_value_extension,
                                &value_layout_info,
                                &val,
                            )?),
                        );
                    },
                    Op::Modify(val) => {
                        entries.insert(
                            key,
                            Op::Modify(serialize_value(
                                function_value_extension,
                                &value_layout_info,
                                &val,
                            )?),
                        );
                    },
                    Op::Delete => {
                        entries.insert(key, Op::Delete);
                    },
                }
            }
            if !entries.is_empty() {
                changes.insert(handle, TableChange { entries });
            }
        }
        Ok(TableChangeSet {
            new_tables,
            removed_tables,
            changes,
        })
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L621-642)
```rust
fn native_destroy_empty_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 1);

    context.charge(DESTROY_EMPTY_BOX_BASE)?;

    let (extensions, mut loader_context) = context.extensions_with_loader_context();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;
    // TODO: Can the following line be removed?
    table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    assert!(table_data.removed_tables.insert(handle));

    Ok(smallvec![])
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L479-485)
```rust
        for (handle, change) in table_change_set.changes {
            for (key, value_op) in change.entries {
                let state_key = StateKey::table_item(&handle.into(), &key);
                let op = woc.convert_resource(&state_key, value_op, false)?;
                resource_write_set.insert(state_key, op);
            }
        }
```

**File:** storage/indexer/src/lib.rs (L234-248)
```rust
                let struct_tag = &struct_value.ty_tag;
                if Self::is_table(struct_tag) {
                    assert_eq!(struct_tag.type_args.len(), 2);
                    let table_info = TableInfo {
                        key_type: struct_tag.type_args[0].clone(),
                        value_type: struct_tag.type_args[1].clone(),
                    };
                    let table_handle = match &struct_value.value[0] {
                        (name, AnnotatedMoveValue::Address(handle)) => {
                            assert_eq!(name.as_ref(), ident_str!("handle"));
                            TableHandle(*handle)
                        },
                        _ => db_other_bail!("Table struct malformed. {:?}", struct_value),
                    };
                    self.save_table_info(table_handle, table_info)?;
```
