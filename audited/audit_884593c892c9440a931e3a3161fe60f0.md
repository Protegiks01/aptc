# Audit Report

## Title
State Inconsistency Between On-Chain Configuration and Circuit Constants Breaks Keyless Authentication Network-Wide

## Summary
The keyless account `Configuration` struct allows `max_iss_val_bytes` to be set to any value up to 65,535 via governance proposals, without validating that it matches the hardcoded circuit constant `MAX_ISS_VAL_BYTES` (120 bytes). This mismatch causes all keyless account proof verifications to fail network-wide, creating a complete denial of service for keyless authentication.

## Finding Description

The keyless authentication system uses zero-knowledge proofs to verify JWT-based account ownership. The ZK circuit has a hardcoded constant `MAX_ISS_VAL_BYTES = 120` that defines the maximum length of the JWT issuer field that can be processed. [1](#0-0) 

However, the on-chain `Configuration` struct's `max_iss_val_bytes` field can be set to any `u16` value (up to 65,535) through governance proposals without validation. [2](#0-1) 

The Move framework's `new_configuration` function accepts `max_iss_val_bytes` as a parameter with no bounds checking: [3](#0-2) 

When governance proposals update the configuration via `set_configuration_for_next_epoch`, no validation ensures the value stays within circuit bounds: [4](#0-3) 

Unlike the Groth16 verification key which has explicit validation, the Configuration has no such checks: [5](#0-4) 

**Attack Path:**

1. A governance proposal (malicious or mistaken) sets `max_iss_val_bytes` to 200 bytes
2. The proposal passes and is applied at epoch change via `on_new_epoch`
3. The prover service continues generating proofs using the circuit's hardcoded 120-byte constraint
4. Validators compute the public inputs hash using the on-chain config value (200 bytes): [6](#0-5) 
5. The hash computed by validators differs from the hash embedded in the proof
6. Proof verification fails deterministically: [7](#0-6) 
7. All keyless account transactions are rejected with "Proof verification failed"

The root cause is in the hashing function which uses the on-chain config value for padding: [8](#0-7) 

The documentation explicitly states this requires circuit changes but provides no enforcement: [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:

1. **Significant Protocol Violations**: Breaks the cryptographic verification protocol for all keyless accounts network-wide
2. **API Crashes**: All keyless authentication requests fail with verification errors
3. **Validator Node Slowdowns**: Validators waste compute resources attempting to verify invalid proofs

The impact affects:
- All existing keyless accounts become unusable
- No new keyless transactions can be processed
- Requires emergency governance proposal + epoch change to recover
- User funds remain safe but inaccessible until fixed
- Network continues operating for non-keyless accounts

This does not reach Critical severity because:
- No funds are stolen or permanently lost
- Network does not partition or halt entirely
- Recovery is possible through governance
- Traditional accounts remain functional

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can be triggered through:
1. **Unintentional misconfiguration**: Governance participants updating config parameters without understanding circuit constraints
2. **Malicious governance proposal**: Attacker with proposal creation rights intentionally breaking keyless accounts
3. **Miscoordinated upgrades**: Circuit upgrade coordinated incorrectly with on-chain config changes

Attack requirements:
- Governance proposal creation (achievable with sufficient stake)
- Proposal approval by governance (normal process, no collusion needed)
- No special validator access required

The same vulnerability exists for three other circuit constants:
- `max_commited_epk_bytes` (circuit: 93 bytes)
- `max_extra_field_bytes` (circuit: 350 bytes)  
- `max_jwt_header_b64_bytes` (circuit: 300 bytes)

All four parameters lack validation against their respective circuit constants.

## Recommendation

Add validation in the Move framework to enforce circuit constant bounds:

```move
// In keyless_account.move, add error constants:
const E_MAX_ISS_VAL_BYTES_TOO_LARGE: u64 = 4;
const E_MAX_COMMITED_EPK_BYTES_INVALID: u64 = 5;
const E_MAX_EXTRA_FIELD_BYTES_TOO_LARGE: u64 = 6;
const E_MAX_JWT_HEADER_B64_BYTES_TOO_LARGE: u64 = 7;

// Add validation function:
fun validate_configuration(config: &Configuration) {
    assert!(config.max_iss_val_bytes <= 120, E_MAX_ISS_VAL_BYTES_TOO_LARGE);
    assert!(config.max_commited_epk_bytes <= 93, E_MAX_COMMITED_EPK_BYTES_INVALID);
    assert!(config.max_extra_field_bytes <= 350, E_MAX_EXTRA_FIELD_BYTES_TOO_LARGE);
    assert!(config.max_jwt_header_b64_bytes <= 300, E_MAX_JWT_HEADER_B64_BYTES_TOO_LARGE);
}

// Call in new_configuration:
public fun new_configuration(
    override_aud_val: vector<String>,
    max_signatures_per_txn: u16,
    max_exp_horizon_secs: u64,
    training_wheels_pubkey: Option<vector<u8>>,
    max_commited_epk_bytes: u16,
    max_iss_val_bytes: u16,
    max_extra_field_bytes: u16,
    max_jwt_header_b64_bytes: u32
): Configuration {
    let config = Configuration {
        override_aud_vals: override_aud_val,
        max_signatures_per_txn,
        max_exp_horizon_secs,
        training_wheels_pubkey,
        max_commited_epk_bytes,
        max_iss_val_bytes,
        max_extra_field_bytes,
        max_jwt_header_b64_bytes,
    };
    validate_configuration(&config);
    config
}

// Call in set_configuration_for_next_epoch:
public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {
    system_addresses::assert_aptos_framework(fx);
    validate_configuration(&config);
    config_buffer::upsert<Configuration>(config);
}
```

This ensures on-chain configuration values never exceed circuit capabilities.

## Proof of Concept

```move
#[test_only]
module aptos_framework::keyless_config_vulnerability_test {
    use aptos_framework::keyless_account;
    use std::vector;
    
    #[test(aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x10004)] // Should fail with validation error
    fun test_max_iss_val_bytes_exceeds_circuit_constant(aptos_framework: &signer) {
        // Attempt to create config with max_iss_val_bytes > 120 (circuit constant)
        let invalid_config = keyless_account::new_configuration(
            vector::empty(),
            3,
            10_000_000,
            std::option::none(),
            93,    // max_commited_epk_bytes
            200,   // max_iss_val_bytes - EXCEEDS CIRCUIT CONSTANT OF 120!
            350,   // max_extra_field_bytes
            300    // max_jwt_header_b64_bytes
        );
        
        // This should fail if validation is properly implemented
        keyless_account::update_configuration(aptos_framework, invalid_config);
    }
    
    #[test(aptos_framework = @aptos_framework)]
    fun test_valid_configuration_within_circuit_bounds(aptos_framework: &signer) {
        // Create config with values within circuit constants
        let valid_config = keyless_account::new_configuration(
            vector::empty(),
            3,
            10_000_000,
            std::option::none(),
            93,    // max_commited_epk_bytes (circuit constant)
            120,   // max_iss_val_bytes (circuit constant)
            350,   // max_extra_field_bytes (circuit constant)
            300    // max_jwt_header_b64_bytes (circuit constant)
        );
        
        // This should succeed
        keyless_account::update_configuration(aptos_framework, valid_config);
    }
}
```

Without the validation fix, the first test will pass when it should fail, demonstrating the vulnerability. With the fix, it will properly abort with the validation error.

## Notes

The vulnerability also affects `max_commited_epk_bytes`, `max_extra_field_bytes`, and `max_jwt_header_b64_bytes` which should all be validated against their respective circuit constants (93, 350, and 300 bytes). The same validation pattern should be applied to all circuit-constrained parameters to ensure on-chain configuration never exceeds circuit capabilities. This represents a broader class of state inconsistency vulnerabilities where on-chain governance-modifiable parameters must respect off-chain cryptographic system constraints.

### Citations

**File:** types/src/keyless/circuit_constants.rs (L19-19)
```rust
pub(crate) const MAX_ISS_VAL_BYTES: u16 = 120;
```

**File:** types/src/keyless/configuration.rs (L23-32)
```rust
pub struct Configuration {
    pub override_aud_vals: Vec<String>,
    pub max_signatures_per_txn: u16,
    pub max_exp_horizon_secs: u64,
    pub training_wheels_pubkey: Option<Vec<u8>>,
    pub max_commited_epk_bytes: u16,
    pub max_iss_val_bytes: u16,
    pub max_extra_field_bytes: u16,
    pub max_jwt_header_b64_bytes: u32,
}
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L113-118)
```text
        /// The max length of the value of the JWT's `iss` field supported in our circuit (e.g., `"https://accounts.google.com"`)
        ///
        /// If changed: Requires a circuit change because the `iss` field value is hashed inside the circuit as
        ///   `HashBytesToFieldWithLen(MAX_ISS_VALUE_LEN)(iss_value, iss_value_len)` where `MAX_ISS_VALUE_LEN` is a
        ///   circuit constant hard-coded to `max_iss_val_bytes` (i.e., to 120) => prover service redeployment..
        max_iss_val_bytes: u16,
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L160-180)
```text
    public fun new_configuration(
        override_aud_val: vector<String>,
        max_signatures_per_txn: u16,
        max_exp_horizon_secs: u64,
        training_wheels_pubkey: Option<vector<u8>>,
        max_commited_epk_bytes: u16,
        max_iss_val_bytes: u16,
        max_extra_field_bytes: u16,
        max_jwt_header_b64_bytes: u32
    ): Configuration {
        Configuration {
            override_aud_vals: override_aud_val,
            max_signatures_per_txn,
            max_exp_horizon_secs,
            training_wheels_pubkey,
            max_commited_epk_bytes,
            max_iss_val_bytes,
            max_extra_field_bytes,
            max_jwt_header_b64_bytes,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L274-277)
```text
    public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Configuration>(config);
    }
```

**File:** types/src/keyless/bn254_circom.rs (L319-320)
```rust
    // Add the hash of the value of the `iss` field
    let iss_field_hash = cached_pad_and_hash_string(iss, config.max_iss_val_bytes as usize)?;
```

**File:** types/src/keyless/groth16_sig.rs (L229-233)
```rust
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
        // println!("Proof verification time: {:?}", start.elapsed());
        if !verified {
            bail!("groth16 proof verification failed")
        }
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L85-111)
```rust
pub fn pad_and_pack_bytes_to_scalars_with_len(
    bytes: &[u8],
    max_bytes: usize,
) -> anyhow::Result<Vec<ark_bn254::Fr>> {
    let len = bytes.len();
    if max_bytes > MAX_NUM_INPUT_BYTES {
        bail!(
            "Cannot hash more than {} bytes. Was given {} bytes.",
            MAX_NUM_INPUT_BYTES,
            len
        );
    }
    if len > max_bytes {
        bail!(
            "Byte array length of {} is NOT <= max length of {} bytes.",
            bytes.len(),
            max_bytes
        );
    }

    let len_scalar = pack_bytes_to_one_scalar(&len.to_le_bytes())?;
    let scalars = pad_and_pack_bytes_to_scalars_no_len(bytes, max_bytes)?
        .into_iter()
        .chain([len_scalar])
        .collect::<Vec<ark_bn254::Fr>>();
    Ok(scalars)
}
```
