# Audit Report

## Title
Limited DoS Amplification via Oversized WebAuthn Authenticator Data (Not Gigabytes as Claimed)

## Summary
The claim that an attacker can provide "gigabytes" of `authenticator_data` is **FALSE**. However, there is a bounded DoS amplification issue: attackers can submit transactions with up to 8 MB of `authenticator_data` that will be deserialized and allocated in memory before being rejected by VM size validation (64 KB limit), creating temporary memory pressure.

## Finding Description

The `PartialAuthenticatorAssertionResponse` struct contains an unbounded `Vec<u8>` field for `authenticator_data`: [1](#0-0) 

**Critical Clarification:** The claim of "gigabytes" is incorrect due to multiple protection layers:

1. **API Layer Limit (8 MB):** The API enforces a default request body size limit of 8 MB via `PostSizeLimit` middleware: [2](#0-1) [3](#0-2) 

2. **Network Layer Limit (64 MB):** Network messages have a maximum size of 64 MB: [4](#0-3) 

3. **VM Layer Limit (64 KB):** The VM enforces a transaction size limit of 64 KB (or 1 MB for governance): [5](#0-4) 

**The Vulnerability Window:**

The issue occurs in the transaction submission flow:

1. BCS deserialization happens BEFORE size validation: [6](#0-5) 

2. Transaction size validation occurs later in the VM during prologue execution: [7](#0-6) 

During this gap, memory is allocated for the oversized `authenticator_data` Vec, then the transaction is rejected.

**Attack Scenario:**
1. Attacker sends transaction with 7.9 MB of `authenticator_data` via API
2. HTTP request passes PostSizeLimit check (< 8 MB)
3. BCS deserializes, allocating ~8 MB for the Vec
4. Transaction reaches VM validation, gets rejected (exceeds 64 KB limit)
5. Memory is freed, but was temporarily allocated

**Exploitation:** An attacker sending concurrent malicious requests could cause temporary memory pressure and node slowdown, but cannot send "gigabytes" as claimed.

## Impact Explanation

**Severity: Medium (Not High as Claimed)**

This does NOT meet the criteria for High/Critical severity because:
- **NOT "gigabytes"** - Limited to 8 MB per request (API) or 64 MB (network)
- Requires sustained concurrent attack to cause significant impact
- Does not cause consensus violations, fund loss, or permanent network issues
- Temporary DoS amplification, not critical memory exhaustion

Per Aptos bug bounty criteria, this falls under **Medium Severity** as it could cause temporary node slowdown requiring sustained attack, not a single-transaction exploit.

## Likelihood Explanation

**Likelihood: Medium**

- Easy to exploit (anyone can submit malicious transactions)
- Requires multiple concurrent requests for meaningful impact
- Protected by HTTP rate limiting and mempool backpressure
- Node operators can adjust `content_length_limit` to further restrict

## Recommendation

Add explicit size validation for WebAuthn authenticator fields immediately after deserialization:

```rust
// In PartialAuthenticatorAssertionResponse or during validation
pub const MAX_AUTHENTICATOR_DATA_BYTES: usize = 1024; // Typical authenticator data is ~37 bytes
pub const MAX_CLIENT_DATA_JSON_BYTES: usize = 1024; // Typical client data JSON is ~200 bytes

impl PartialAuthenticatorAssertionResponse {
    pub fn validate_sizes(&self) -> Result<(), CryptoMaterialError> {
        if self.authenticator_data.len() > MAX_AUTHENTICATOR_DATA_BYTES {
            return Err(CryptoMaterialError::ValidationError);
        }
        if self.client_data_json.len() > MAX_CLIENT_DATA_JSON_BYTES {
            return Err(CryptoMaterialError::ValidationError);
        }
        Ok(())
    }
}
```

Call this validation immediately after BCS deserialization in the API layer: [8](#0-7) 

## Proof of Concept

```rust
#[test]
fn test_oversized_authenticator_data_rejection() {
    use aptos_types::transaction::{
        webauthn::{AssertionSignature, PartialAuthenticatorAssertionResponse},
        RawTransaction, SignedTransaction, TransactionAuthenticator,
    };
    use aptos_crypto::secp256r1_ecdsa;
    
    // Create a transaction with oversized authenticator_data
    let large_authenticator_data = vec![0u8; 7 * 1024 * 1024]; // 7 MB
    let normal_client_data = vec![0u8; 200];
    let signature = secp256r1_ecdsa::Signature::from_bytes_unchecked(&[0u8; 64]).unwrap();
    
    let assertion_response = PartialAuthenticatorAssertionResponse::new(
        AssertionSignature::Secp256r1Ecdsa { signature },
        large_authenticator_data, // 7 MB - will be allocated during deserialization
        normal_client_data,
    );
    
    // Serialize to BCS
    let bcs_bytes = bcs::to_bytes(&assertion_response).unwrap();
    assert!(bcs_bytes.len() > 7_000_000); // Verify it's actually large
    
    // This would be deserialized by the API, allocating 7 MB
    // Then rejected by VM size validation
    // Demonstrating the memory allocation window
}
```

## Notes

**Critical Correction:** The original claim that attackers can provide "gigabytes" is **factually incorrect**. The actual limits are 8 MB (API) or 64 MB (network), not gigabytes. This significantly reduces the severity from what was claimed.

The real issue is a bounded DoS amplification where memory allocation occurs before size validation, but it's NOT the catastrophic "gigabytes" memory exhaustion described in the security question.

### Citations

**File:** types/src/transaction/webauthn.rs (L90-90)
```rust
    authenticator_data: Vec<u8>,
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/runtime.rs (L255-255)
```rust
            .with(PostSizeLimit::new(size_limit))
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** api/src/transactions.rs (L1223-1225)
```rust
                let signed_transaction: SignedTransaction =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
```

**File:** api/src/transactions.rs (L1233-1234)
```rust
                // Verify the signed transaction
                self.validate_signed_transaction_payload(ledger_info, &signed_transaction)?;
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```
