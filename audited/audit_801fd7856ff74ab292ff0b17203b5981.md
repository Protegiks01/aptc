# Audit Report

## Title
Integer Underflow in MixedPayloadClient::pull_payload() Leading to Consensus Divergence

## Summary
The `MixedPayloadClient::pull_payload()` function uses non-saturating subtraction when updating transaction constraints after pulling validator transactions. When backpressure mechanisms heavily reduce `max_txns_after_filtering` while `max_txns.count()` remains high, the code can pull more validator transactions than the filtering limit allows, causing integer underflow that leads to validator panics (debug mode) or incorrect constraint calculations (release mode), breaking consensus determinism. [1](#0-0) 

## Finding Description

The vulnerability occurs because `max_txns.count()` (total transaction limit) and `max_txns_after_filtering` (unique transaction limit) are adjusted **independently** by backpressure mechanisms, but validator transaction pulling uses only the former constraint while the subtraction operations assume coherence between both values.

**Attack Flow:**

1. **Backpressure creates constraint misalignment**: The proposal generator's `calculate_max_block_sizes()` function applies backpressure independently to `max_block_txns` and `max_block_txns_after_filtering` through separate code paths. [2](#0-1) 

2. **Aggressive backpressure scenarios**: Pipeline backpressure can reduce `max_txns_after_filtering` to as low as 5 transactions, while `max_txns.count()` may remain at 5000. [3](#0-2) 

3. **Validator transaction limit**: The `per_block_limit_txn_count` is governance-controlled and can be set to high values (default 2, but configurable to any u64). [4](#0-3) 

4. **Unconstrained validator pull**: Validator transactions are pulled with limit `min(params.max_txns.count(), per_block_limit_txn_count)`, ignoring `max_txns_after_filtering`. [5](#0-4) 

5. **Integer underflow**: Regular subtraction (not saturating_sub) causes underflow when `validator_txns.len() > max_txns_after_filtering`. [6](#0-5) 

**Concrete Example:**
- Backpressure reduces `max_txns_after_filtering` to 5
- `max_txns.count()` remains at 1000  
- Governance sets `per_block_limit_txn_count` to 100
- Validator pool returns 50 transactions
- Subtraction: `5 - 50` underflows to `u64::MAX - 44` in release mode, or panics in debug mode

## Impact Explanation

**Critical Severity** - This vulnerability violates the **Deterministic Execution** invariant:

1. **Consensus Divergence**: Validators compiled in debug mode will panic and halt, while validators in release mode will continue with corrupted constraints (wrapping to ~u64::MAX). This causes different validators to process blocks differently, breaking consensus safety.

2. **Validator Unavailability**: Debug-compiled validators experiencing this condition will crash, reducing network participation and potentially preventing consensus if enough validators are affected.

3. **Block Size Limit Bypass**: In release mode, the wrapped value (~18 quintillion) allows pulling virtually unlimited user transactions, violating block size constraints and potentially causing downstream execution failures or state divergence.

4. **Non-deterministic Behavior**: Whether a validator panics or wraps depends on compilation profile, creating non-deterministic network behavior that could be exploited to partition the network. [7](#0-6) 

## Likelihood Explanation

**High Likelihood** under specific but realistic conditions:

1. **Backpressure is common**: Pipeline latency frequently triggers backpressure in production networks, especially during high load or execution bottlenecks.

2. **Governance can increase validator limits**: The `per_block_limit_txn_count` is on-chain configurable, and reasonable governance proposals might increase it from the default 2 to higher values (e.g., 10-100) to accommodate validator transaction demand.

3. **No validation prevents misalignment**: There are no assertions or checks ensuring `max_txns.count() <= max_txns_after_filtering` despite them being adjusted independently.

4. **Occurs during normal operation**: This doesn't require malicious actors—just normal backpressure combined with a governance-approved validator transaction limit increase.

## Recommendation

Add saturating subtraction and validation to prevent underflow:

```rust
// Update constraints with validator txn pull results.
let mut user_txn_pull_params = params;
let validator_txn_count = validator_txns.len() as u64;

user_txn_pull_params.max_txns -= vtxn_size;
user_txn_pull_params.max_txns_after_filtering = user_txn_pull_params
    .max_txns_after_filtering
    .saturating_sub(validator_txn_count);
user_txn_pull_params.soft_max_txns_after_filtering = user_txn_pull_params
    .soft_max_txns_after_filtering
    .saturating_sub(validator_txn_count);
```

**Better fix**: Constrain validator transaction pulling by `max_txns_after_filtering`:

```rust
let validator_txn_limit = min(
    params.max_txns.count(),
    params.max_txns_after_filtering, // Add this constraint
    self.validator_txn_config.per_block_limit_txn_count(),
);
```

## Proof of Concept

```rust
#[cfg(test)]
mod underflow_test {
    use super::*;
    use std::time::Duration;
    
    #[tokio::test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    async fn test_validator_txn_underflow() {
        // Simulate backpressure scenario
        let params = PayloadPullParameters {
            max_poll_time: Duration::from_secs(1),
            max_txns: PayloadTxnsSize::new(5000, 5_000_000), // High count
            max_txns_after_filtering: 5, // Reduced by backpressure
            soft_max_txns_after_filtering: 5,
            // ... other fields
        };
        
        // Validator config allows 100 txns per block
        let vtxn_config = ValidatorTxnConfig::V1 {
            per_block_limit_txn_count: 100,
            per_block_limit_total_bytes: 2097152,
        };
        
        // Create 50 validator transactions
        let validator_txns = vec![ValidatorTransaction::dummy(vec![0; 100]); 50];
        
        let mut user_params = params;
        // This will underflow: 5 - 50 = panic in debug, wrap in release
        user_params.max_txns_after_filtering -= validator_txns.len() as u64;
    }
}
```

## Notes

The original question incorrectly states "even with saturating operations"—the code actually uses **regular** `-=` operator, not `saturating_sub()`. While `validator_txns.len()` cannot realistically reach `u64::MAX` due to pool constraints, it can **exceed** `max_txns_after_filtering` through the independent adjustment of these limits by backpressure mechanisms, causing the demonstrated underflow vulnerability.

### Citations

**File:** consensus/src/payload_client/mixed.rs (L65-79)
```rust
        let mut validator_txns = self
            .validator_txn_pool_client
            .pull(
                params.max_poll_time,
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
                ),
                min(
                    params.max_txns.size_in_bytes(),
                    self.validator_txn_config.per_block_limit_total_bytes(),
                ),
                validator_txn_filter,
            )
            .await;
```

**File:** consensus/src/payload_client/mixed.rs (L91-95)
```rust
        // Update constraints with validator txn pull results.
        let mut user_txn_pull_params = params;
        user_txn_pull_params.max_txns -= vtxn_size;
        user_txn_pull_params.max_txns_after_filtering -= validator_txns.len() as u64;
        user_txn_pull_params.soft_max_txns_after_filtering -= validator_txns.len() as u64;
```

**File:** consensus/src/liveness/proposal_generator.rs (L745-816)
```rust
        let mut values_max_block_txns_after_filtering = vec![self.max_block_txns_after_filtering];
        let mut values_max_block = vec![self.max_block_txns];
        let mut values_proposal_delay = vec![Duration::ZERO];
        let mut block_gas_limit_override = None;

        let chain_health_backoff = self
            .chain_health_backoff_config
            .get_backoff(voting_power_ratio);
        if let Some(value) = chain_health_backoff {
            values_max_block_txns_after_filtering
                .push(value.max_sending_block_txns_after_filtering_override);
            values_max_block.push(
                self.max_block_txns
                    .compute_with_bytes(value.max_sending_block_bytes_override),
            );
            values_proposal_delay.push(Duration::from_millis(value.backoff_proposal_delay_ms));
            CHAIN_HEALTH_BACKOFF_TRIGGERED.observe(1.0);
        } else {
            CHAIN_HEALTH_BACKOFF_TRIGGERED.observe(0.0);
        }

        let pipeline_pending_latency = self.block_store.pipeline_pending_latency(timestamp);
        let pipeline_backpressure = self
            .pipeline_backpressure_config
            .get_backoff(pipeline_pending_latency);
        if let Some(value) = pipeline_backpressure {
            values_max_block_txns_after_filtering
                .push(value.max_sending_block_txns_after_filtering_override);
            values_max_block.push(
                self.max_block_txns
                    .compute_with_bytes(value.max_sending_block_bytes_override),
            );
            values_proposal_delay.push(Duration::from_millis(value.backpressure_proposal_delay_ms));
            PIPELINE_BACKPRESSURE_ON_PROPOSAL_TRIGGERED.observe(1.0);
        } else {
            PIPELINE_BACKPRESSURE_ON_PROPOSAL_TRIGGERED.observe(0.0);
        };

        let mut execution_backpressure_applied = false;
        if let Some(num_blocks_to_look_at) =
            self.pipeline_backpressure_config.num_blocks_to_look_at()
        {
            let (txn_limit, gas_limit) = self
                .pipeline_backpressure_config
                .get_execution_block_txn_and_gas_limit_backoff(
                    &self
                        .block_store
                        .get_recent_block_execution_times(num_blocks_to_look_at),
                    self.max_block_txns_after_filtering,
                    self.max_block_gas_limit,
                );
            if let Some(txn_limit) = txn_limit {
                values_max_block_txns_after_filtering.push(txn_limit);
                execution_backpressure_applied = true;
            }
            block_gas_limit_override = gas_limit;
            if gas_limit.is_some() {
                execution_backpressure_applied = true;
            }
        }
        EXECUTION_BACKPRESSURE_ON_PROPOSAL_TRIGGERED.observe(
            if execution_backpressure_applied {
                1.0
            } else {
                0.0
            },
        );

        let max_block_txns_after_filtering = values_max_block_txns_after_filtering
            .into_iter()
            .min()
            .expect("always initialized to at least one value");
```

**File:** config/src/config/consensus_config.rs (L309-318)
```rust
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 6000,
                    // in practice, latencies and delay make it such that ~2 blocks/s is max,
                    // meaning that most aggressively we limit to ~10 TPS
                    // For transactions that are more expensive than that, we should
                    // instead rely on max gas per block to limit latency.
                    max_sending_block_txns_after_filtering_override: 5,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-177)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ValidatorTxnConfig {
    /// Disabled. In Jolteon, it also means to not use `BlockType::ProposalExt`.
    V0,
    /// Enabled. Per-block vtxn count and their total bytes are limited.
    V1 {
        per_block_limit_txn_count: u64,
        per_block_limit_total_bytes: u64,
    },
}

impl ValidatorTxnConfig {
    pub fn default_for_genesis() -> Self {
        Self::V1 {
            per_block_limit_txn_count: VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT,
            per_block_limit_total_bytes: VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT,
        }
    }

    pub fn default_if_missing() -> Self {
        Self::V0
    }

    pub fn default_disabled() -> Self {
        Self::V0
    }

    pub fn default_enabled() -> Self {
        Self::V1 {
            per_block_limit_txn_count: VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT,
            per_block_limit_total_bytes: VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT,
        }
    }

    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
    }

    pub fn per_block_limit_txn_count(&self) -> u64 {
        match self {
            ValidatorTxnConfig::V0 => 0,
            ValidatorTxnConfig::V1 {
                per_block_limit_txn_count,
                ..
            } => *per_block_limit_txn_count,
        }
    }
```

**File:** consensus/consensus-types/src/payload_pull_params.rs (L16-28)
```rust
pub struct PayloadPullParameters {
    pub max_poll_time: Duration,
    pub max_txns: PayloadTxnsSize,
    pub max_txns_after_filtering: u64,
    pub soft_max_txns_after_filtering: u64,
    pub max_inline_txns: PayloadTxnsSize,
    pub user_txn_filter: PayloadFilter,
    pub pending_ordering: bool,
    pub pending_uncommitted_blocks: usize,
    pub recent_max_fill_fraction: f32,
    pub block_timestamp: Duration,
    pub maybe_optqs_payload_pull_params: Option<OptQSPayloadPullParams>,
}
```
