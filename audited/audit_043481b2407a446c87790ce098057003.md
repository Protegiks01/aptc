# Audit Report

## Title
Unbounded Memory Consumption in `/forge_metrics` Endpoint Leading to Denial of Service

## Summary
The `handle_forge_metrics()` function in the Aptos inspection service performs unbounded JSON serialization of all Prometheus metrics without size limits, timeouts, or rate limiting. When metrics accumulate many dimensions (particularly network peer IDs in public-facing nodes), repeated calls to this unauthenticated endpoint can exhaust node memory, causing DoS of the inspection service or complete node crash.

## Finding Description

The inspection service exposes a `/forge_metrics` endpoint at `0.0.0.0:9101` by default without authentication. [1](#0-0) 

The `handle_forge_metrics()` function gathers all Prometheus metrics and serializes them to JSON without any resource constraints: [2](#0-1) 

The metrics gathering process iterates through all metric families and constructs a HashMap with all label combinations: [3](#0-2) 

**The vulnerability breaks the Resource Limits invariant:** "All operations must respect gas, storage, and computational limits." The `/forge_metrics` endpoint has no size limits, memory bounds, or timeouts on its operation.

**How the attack propagates:**

1. **Metric Accumulation Phase**: In public-facing nodes, network metrics accumulate peer IDs as label values. The developers explicitly acknowledge this risk in fuzzing code: [4](#0-3) 

2. **Memory Exhaustion Phase**: An attacker repeatedly calls `GET http://node:9101/forge_metrics`. Each call:
   - Allocates memory to build a HashMap of all metrics (potentially 100k+ entries)
   - Allocates memory for JSON serialization of this HashMap
   - With no rate limiting, requests accumulate faster than garbage collection

3. **DoS Achievement**: Memory exhaustion causes either:
   - Inspection service thread pool exhaustion/hang
   - Out-of-memory crash affecting the entire node process

The inspection service configuration exposes this endpoint by default: [5](#0-4) 

## Impact Explanation

This vulnerability achieves **Medium severity** per the Aptos bug bounty program, potentially reaching **High severity** depending on impact:

- **High Severity** - "API crashes": If memory exhaustion causes the inspection service to crash or hang, diagnostic capabilities are lost
- **High Severity** - "Validator node slowdowns": Memory pressure from repeated serialization can slow down the entire node
- **Medium Severity** - Limited availability impact: The inspection service runs in its own runtime but shares process memory [6](#0-5) 

While the inspection service is not consensus-critical, its failure affects node observability and operational monitoring, which is security-relevant for validator operations.

## Likelihood Explanation

**Likelihood: Medium-High**

1. **Access Requirements**: Low barrier - the endpoint is exposed on `0.0.0.0:9101` by default with no authentication
2. **Trigger Complexity**: Trivial - simple HTTP GET requests
3. **Preconditions**: 
   - Public-facing nodes naturally accumulate many peer connections over time
   - Metrics with peer_id labels grow unboundedly, as acknowledged by developers
4. **Detection**: The attack is difficult to distinguish from legitimate monitoring traffic

The developers' explicit acknowledgment in fuzzing code that this "would eventually OOM in production for public-facing nodes" confirms the realistic exploitability.

## Recommendation

Implement multiple defense layers:

1. **Add size limits** on the metrics HashMap and JSON response:
```rust
const MAX_METRICS_SIZE: usize = 10_000;
const MAX_JSON_SIZE: usize = 10_000_000; // 10MB

pub fn handle_forge_metrics() -> (StatusCode, Body, String) {
    let metrics = utils::get_all_metrics();
    
    // Limit number of metrics
    if metrics.len() > MAX_METRICS_SIZE {
        return (
            StatusCode::PAYLOAD_TOO_LARGE,
            Body::from(format!("Too many metrics: {}", metrics.len())),
            CONTENT_TYPE_TEXT.into(),
        );
    }
    
    let encoded_metrics = match serde_json::to_string(&metrics) {
        Ok(encoded) => {
            if encoded.len() > MAX_JSON_SIZE {
                return (
                    StatusCode::PAYLOAD_TOO_LARGE,
                    Body::from("Metrics response too large"),
                    CONTENT_TYPE_TEXT.into(),
                );
            }
            encoded
        }
        Err(error) => format!("Failed to get forge metrics! Error: {}", error),
    };

    (StatusCode::OK, Body::from(encoded_metrics), CONTENT_TYPE_JSON.into())
}
```

2. **Add rate limiting** on the endpoint using a token bucket or similar mechanism

3. **Consider authentication** for diagnostic endpoints or bind to localhost by default instead of `0.0.0.0`

4. **Add timeout protection** using `tokio::time::timeout` around the serialization operation

5. **Fix unbounded metric labels**: Avoid using peer_id in metric labels for public-facing nodes, or implement cardinality limits in the metrics library itself

## Proof of Concept

```rust
// Test demonstrating memory exhaustion via repeated /forge_metrics calls
#[tokio::test]
async fn test_forge_metrics_dos() {
    use reqwest;
    use std::time::Duration;
    
    // Assumes inspection service running on localhost:9101
    let client = reqwest::Client::new();
    let url = "http://localhost:9101/forge_metrics";
    
    // Simulate attack: rapid repeated requests
    for i in 0..1000 {
        match tokio::time::timeout(
            Duration::from_secs(5),
            client.get(url).send()
        ).await {
            Ok(Ok(response)) => {
                let size = response.content_length().unwrap_or(0);
                println!("Request {}: {} bytes", i, size);
                
                // If response is very large or times out, DoS is occurring
                if size > 50_000_000 { // 50MB
                    println!("ALERT: Response size exceeds 50MB - potential DoS vector");
                }
            }
            Ok(Err(e)) => {
                println!("Request {} failed: {}", i, e);
            }
            Err(_) => {
                println!("Request {} timed out - service likely overwhelmed", i);
                break;
            }
        }
        
        // No delay between requests to maximize memory pressure
    }
}
```

**Notes**

This vulnerability is confirmed by developer acknowledgment in the codebase itself. The fuzzing code explicitly implements workarounds to avoid "unbounded metrics" that would "OOM during fuzzing" and notes this would "eventually OOM in production for public-facing nodes." The lack of any size limits, timeouts, or rate limiting on an unauthenticated diagnostic endpoint exposed to `0.0.0.0` by default represents a clear DoS vector, particularly for public-facing full nodes that accumulate many peer connections over time.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L72-72)
```rust
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L122-126)
```rust
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L51-64)
```rust
pub fn handle_forge_metrics() -> (StatusCode, Body, String) {
    // Get and encode the metrics
    let metrics = utils::get_all_metrics();
    let encoded_metrics = match serde_json::to_string(&metrics) {
        Ok(encoded_metrics) => encoded_metrics,
        Err(error) => format!("Failed to get forge metrics! Error: {}", error),
    };

    (
        StatusCode::OK,
        Body::from(encoded_metrics),
        CONTENT_TYPE_JSON.into(),
    )
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L83-130)
```rust
fn get_metrics_map(metric_families: Vec<MetricFamily>) -> HashMap<String, String> {
    // TODO: use an existing metric encoder (same as used by prometheus/metric-server)
    let mut all_metrics = HashMap::new();

    // Process each metric family
    for metric_family in metric_families {
        let values: Vec<_> = match metric_family.get_field_type() {
            MetricType::COUNTER => metric_family
                .get_metric()
                .iter()
                .map(|m| m.get_counter().get_value().to_string())
                .collect(),
            MetricType::GAUGE => metric_family
                .get_metric()
                .iter()
                .map(|m| m.get_gauge().get_value().to_string())
                .collect(),
            MetricType::SUMMARY => {
                error!("Unsupported Metric 'SUMMARY'");
                vec![]
            },
            MetricType::UNTYPED => {
                error!("Unsupported Metric 'UNTYPED'");
                vec![]
            },
            MetricType::HISTOGRAM => metric_family
                .get_metric()
                .iter()
                .map(|m| m.get_histogram().get_sample_count().to_string())
                .collect(),
        };
        let metric_names = metric_family.get_metric().iter().map(|m| {
            let label_strings: Vec<String> = m
                .get_label()
                .iter()
                .map(|l| format!("{}={}", l.get_name(), l.get_value()))
                .collect();
            let labels_string = format!("{{{}}}", label_strings.join(","));
            format!("{}{}", metric_family.get_name(), labels_string)
        });

        for (name, value) in metric_names.zip(values.into_iter()) {
            all_metrics.insert(name, value);
        }
    }

    all_metrics
}
```

**File:** network/framework/src/peer/fuzzing.rs (L68-74)
```rust
    // We want to choose a constant peer id for _our_ peer id, since we will
    // generate unbounded metrics otherwise and OOM during fuzzing.
    let peer_id = PeerId::ZERO;
    // However, we want to choose a random _remote_ peer id to ensure we _don't_
    // have metrics logging the remote peer id (which would eventually OOM in
    // production for public-facing nodes).
    let remote_peer_id = PeerId::random();
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```
