# Audit Report

## Title
Validation Bypass Allows Function-Level Let Conditions at Module Scope

## Summary
The Move specification system fails to validate `let` and `let post` statements when they are placed in module-level spec blocks. This allows function-level conditions (`LetPre` and `LetPost`) to bypass the `allowed_on_module()` validation check and be added directly to module specifications, creating inconsistent specification states.

## Finding Description
The Move specification language defines strict rules about which condition kinds are allowed at different scopes. The `ConditionKind::allowed_on_module()` function explicitly restricts module-level conditions to only three types: `GlobalInvariant`, `GlobalInvariantUpdate`, and `Axiom`. [1](#0-0) 

However, the `def_ana_let` function in the module builder bypasses this validation entirely. When processing `let` statements in spec blocks, it directly adds `LetPre` or `LetPost` conditions to the target spec without calling `check_condition_is_valid`: [2](#0-1) 

The parser accepts `let` statements in any spec block context without restrictions: [3](#0-2) 

**Attack Path:**
1. Attacker writes a Move module with a module-level spec block containing `let` statements
2. The parser accepts this syntax without validation
3. `def_ana_spec_block_member` processes the `Let` member with Module context
4. `def_ana_let` creates a `ConditionKind::LetPre` or `ConditionKind::LetPost` condition
5. The condition is added directly to `module_spec` bypassing validation
6. Function-level conditions now exist at module scope, violating specification invariants

In contrast, when other conditions are added through schema inclusion, they properly go through validation: [4](#0-3) 

The validation check at line 2016 correctly enforces `allowed_on_module()`: [5](#0-4) 

## Impact Explanation
This is a **Medium severity** issue per the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistencies**: Module specifications contain function-level conditions that violate the specification type system, creating inconsistent states in the Move Model
2. **Verification Tool Failures**: The Move Prover and other formal verification tools may fail, produce incorrect results, or generate misleading verification reports when encountering these malformed specifications
3. **False Security Guarantees**: Developers may believe their code is formally verified when the verification is actually compromised by inconsistent specification states
4. **Specification System Integrity**: Breaks the fundamental invariant that module-level specs should only contain module-level conditions

While this does not directly affect runtime blockchain execution, it corrupts the specification and verification infrastructure that ensures Move code correctness.

## Likelihood Explanation
**High likelihood** of occurrence:
- Any Move developer can write spec blocks in their modules
- The syntax is valid and accepted by the parser
- No error or warning is generated
- Developers experimenting with specifications might naturally try using `let` at various scopes
- The issue exists in production code paths used by all Move compilation

## Recommendation
Add validation in the `def_ana_let` function to check whether the condition kind is valid for the current context before adding it to the spec:

```rust
fn def_ana_let(
    &mut self,
    context: &SpecBlockContext,
    loc: &Loc,
    post_state: bool,
    name: &Name,
    def: &EA::Exp,
) {
    // ... existing code to create the condition ...
    
    let cond = Condition {
        loc: loc.clone(),
        kind,
        properties: Default::default(),
        exp: desugared_exp,
        additional_exps: vec![],
    };
    
    // ADD VALIDATION HERE
    if !self.check_condition_is_valid(context, loc, &cond, "in let binding") {
        return; // Don't add invalid conditions
    }
    
    self.update_spec(context, |spec| {
        spec.conditions.push(cond)
    })
}
```

Alternatively, add parser-level validation to reject `let` statements in module and struct spec blocks where they are not allowed.

## Proof of Concept
Create a Move source file `invalid_module_let.move`:

```move
module 0x1::test {
    spec module {
        let x = 5;  // Function-level condition at module scope
        let post y = old(x) + 1;  // Post-state let at module scope
    }
    
    public fun dummy() {}
}
```

**Expected behavior**: Compilation should fail with an error stating that `let` conditions are not allowed in module spec blocks.

**Actual behavior**: The code compiles successfully, and the `LetPre` and `LetPost` conditions are added to the module specification without validation, violating the specification type system invariants.

To reproduce:
1. Save the above code to a file
2. Compile with `move build` or the Move compiler
3. Observe that no validation error is raised
4. Inspect the generated Move Model to confirm `LetPre`/`LetPost` conditions exist at module scope

## Notes
This vulnerability specifically affects the Move specification and formal verification system, not runtime blockchain execution. However, it represents a critical break in the specification type system that could undermine the entire formal verification infrastructure used to ensure Move code correctness.

### Citations

**File:** third_party/move/move-model/src/ast.rs (L184-190)
```rust
    pub fn allowed_on_module(&self) -> bool {
        use ConditionKind::*;
        matches!(
            self,
            GlobalInvariant(..) | GlobalInvariantUpdate(..) | Axiom(..)
        )
    }
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L1633-1641)
```rust
        self.update_spec(context, |spec| {
            spec.conditions.push(Condition {
                loc: loc.clone(),
                kind,
                properties: Default::default(),
                exp: desugared_exp,
                additional_exps: vec![],
            })
        })
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L2015-2020)
```rust
        let mut ok = match context {
            Module => cond.kind.allowed_on_module(),
            Struct(_) => cond.kind.allowed_on_struct(),
            Function(name) => {
                let entry = self.parent.fun_table.get(name).expect("function defined");
                cond.kind.allowed_on_fun_decl(entry.visibility)
```

**File:** third_party/move/move-model/src/builder/module_builder.rs (L2252-2260)
```rust
                if self.check_condition_is_valid(context, loc, &derived_cond, error_msg)
                    && !self
                        .parent
                        .env
                        .is_property_true(&derived_cond.properties, CONDITION_DEACTIVATED_PROP)
                        .unwrap_or(false)
                {
                    self.update_spec(context, |spec| spec.conditions.push(derived_cond));
                }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs (L4324-4347)
```rust
fn parse_spec_let(context: &mut Context) -> Result<SpecBlockMember, Box<Diagnostic>> {
    let start_loc = context.tokens.start_loc();
    context.tokens.advance()?;
    let post_state =
        if context.tokens.peek() == Tok::Identifier && context.tokens.content() == "post" {
            context.tokens.advance()?;
            true
        } else {
            false
        };
    let name = parse_identifier(context)?;
    consume_token(context.tokens, Tok::Equal)?;
    let def = parse_exp(context)?;
    consume_token(context.tokens, Tok::Semicolon)?;
    Ok(spanned(
        context.tokens.file_hash(),
        start_loc,
        context.tokens.previous_end_loc(),
        SpecBlockMember_::Let {
            name,
            post_state,
            def,
        },
    ))
```
