# Audit Report

## Title
Missing Accumulator Extension Validation in SafetyRules Commit Vote Signing Allows Consensus Safety Violations

## Summary
The `sign_commit_vote()` function in SafetyRules fails to validate that the new accumulator root properly extends from the previous committed state, breaking a critical consensus safety invariant. This defense-in-depth failure could enable consensus splits if any execution non-determinism occurs across validators.

## Finding Description
In the consensus safety rules module, the `guarded_sign_commit_vote()` function is responsible for signing commit votes on executed blocks. This function receives two ledger infos: the ordered ledger info (with placeholder accumulator) and the commit ledger info (with actual execution accumulator root). [1](#0-0) 

The function performs several validations but explicitly acknowledges missing validation with TODO comments at lines 412-413. The validation that occurs through `match_ordered_only()` only checks epoch, round, id, and timestamp - but NOT the accumulator root: [2](#0-1) 

The critical issue is that there is no verification that:
1. The new accumulator root in `new_ledger_info` properly extends from the last committed accumulator state
2. The accumulator version is consistent with the ledger version
3. The accumulator hash matches what this validator actually computed during execution

**Attack Path:**

If execution is non-deterministic (due to any bug in the execution engine, Move VM, or native functions), different validators could honestly execute the same block and produce different accumulator roots:

1. Block B is ordered and sent to all validators
2. Validator V1 executes B and computes accumulator root_A
3. Validator V2 executes B and computes accumulator root_B (due to non-determinism)
4. Both validators call `sign_commit_vote()` with their respective roots
5. SafetyRules signs both without checking accumulator extension
6. If each gets 2f+1 signatures, a consensus split occurs

The codebase has proper accumulator verification infrastructure that should be used: [3](#0-2) [4](#0-3) 

However, these validation methods are never invoked in `sign_commit_vote()`.

## Impact Explanation
This breaks the **Consensus Safety** and **State Consistency** critical invariants. SafetyRules is the final gatekeeper before commit signatures are produced - it must prevent validators from signing commits that could lead to chain splits.

Without accumulator extension validation, any source of non-determinism in block execution would bypass SafetyRules' protection and directly cause consensus safety violations. This represents a defense-in-depth failure in a critical security path.

According to the Aptos bug bounty criteria, this qualifies as **High Severity** because it enables "Significant protocol violations" - SafetyRules is supposed to validate all safety properties before signing, and accumulator extension is a fundamental safety property for state consistency.

While this requires an additional bug (execution non-determinism) to manifest as a consensus split, the missing validation itself violates the security architecture where SafetyRules must be the fail-safe mechanism.

## Likelihood Explanation
**Moderate to High likelihood** because:

1. The TODO comments explicitly acknowledge this check is missing, indicating developers are aware but haven't implemented it
2. Any source of execution non-determinism (floating point operations, timestamp dependencies, race conditions, native function bugs) would trigger this vulnerability
3. As the codebase evolves and new features are added to the Move VM or execution engine, new sources of non-determinism could be inadvertently introduced
4. The proper validation infrastructure already exists but is not being used

## Recommendation
Implement accumulator extension validation in `guarded_sign_commit_vote()` before signing the commit vote. The validation should:

1. Verify that the new accumulator root in `new_ledger_info` extends from the last committed accumulator root
2. Check that the version is consistent between ledger info and accumulator
3. Validate that the accumulator hash matches the expected transaction accumulator hash

Add validation after line 403:

```rust
// Validate accumulator extension
// Get the last committed accumulator root from persistent storage
let last_committed_root = self.persistent_storage
    .last_committed_accumulator_root()?;

// Verify the new accumulator extends from the last committed state
if new_ledger_info.version() > 0 {
    ensure!(
        new_ledger_info.version() > last_committed_root.version(),
        Error::InvalidAccumulatorExtension(
            "New ledger info version must be greater than last committed version"
        )
    );
    
    // Additional validation: ensure accumulator root is not a placeholder
    ensure!(
        new_ledger_info.transaction_accumulator_hash() != *ACCUMULATOR_PLACEHOLDER_HASH,
        Error::InvalidAccumulatorExtension(
            "New ledger info must contain a valid accumulator root"
        )
    );
}
```

## Proof of Concept
The vulnerability can be demonstrated by constructing two different commit votes for the same block with different accumulator roots and showing that both would be signed by SafetyRules:

```rust
#[test]
fn test_missing_accumulator_validation() {
    // Setup SafetyRules with valid epoch
    let mut safety_rules = create_test_safety_rules();
    
    // Create ordered ledger info with placeholder accumulator
    let ordered_block_info = BlockInfo::new(
        1,  // epoch
        10, // round  
        HashValue::random(),
        *ACCUMULATOR_PLACEHOLDER_HASH,  // ordered-only placeholder
        0,  // version
        123456789,
        None,
    );
    let ordered_li = LedgerInfo::new(ordered_block_info, HashValue::zero());
    let ordered_proof = create_li_with_sigs(ordered_li);
    
    // Create commit ledger info with accumulator root A
    let commit_block_info_a = BlockInfo::new(
        1,
        10,
        ordered_proof.ledger_info().consensus_block_id(),
        HashValue::from_hex("AAAA...").unwrap(),  // Accumulator root A
        100,
        123456789,
        None,
    );
    let commit_li_a = LedgerInfo::new(commit_block_info_a, HashValue::zero());
    
    // Create commit ledger info with DIFFERENT accumulator root B
    let commit_block_info_b = BlockInfo::new(
        1,
        10,
        ordered_proof.ledger_info().consensus_block_id(),
        HashValue::from_hex("BBBB...").unwrap(),  // Accumulator root B (different!)
        100,
        123456789,
        None,
    );
    let commit_li_b = LedgerInfo::new(commit_block_info_b, HashValue::zero());
    
    // Both should be signed by SafetyRules (VULNERABILITY)
    let sig_a = safety_rules.sign_commit_vote(ordered_proof.clone(), commit_li_a);
    let sig_b = safety_rules.sign_commit_vote(ordered_proof, commit_li_b);
    
    // Both signatures succeed even though they have different accumulator roots
    assert!(sig_a.is_ok());
    assert!(sig_b.is_ok());
    
    // This demonstrates the vulnerability: SafetyRules signs commits
    // with different accumulator roots without validation
}
```

## Notes
The error type `InvalidAccumulatorExtension` already exists in the error module, indicating the developers planned for this validation: [5](#0-4) 

This confirms the validation is intentionally missing and needs to be implemented as indicated by the TODO comments.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** types/src/proof/definition.rs (L464-480)
```rust
    pub fn verify_consistency(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "ledger info and accumulator must be at the same version: \
             ledger info version={}, accumulator version={}",
            ledger_info.version(),
            self.version(),
        );
        ensure!(
            ledger_info.transaction_accumulator_hash() == self.root_hash(),
            "ledger info root hash and accumulator root hash must match: \
             ledger info root hash={}, accumulator root hash={}",
            ledger_info.transaction_accumulator_hash(),
            self.root_hash(),
        );
        Ok(())
    }
```

**File:** types/src/proof/definition.rs (L1009-1021)
```rust
    pub fn verify(&self, original_root: HashValue) -> anyhow::Result<InMemoryAccumulator<H>> {
        let original_tree =
            InMemoryAccumulator::<H>::new(self.frozen_subtree_roots.clone(), self.num_leaves)?;
        ensure!(
            original_tree.root_hash() == original_root,
            "{}: Root hashes do not match. Actual root hash: {:x}. Expected root hash: {:x}.",
            type_name::<Self>(),
            original_tree.root_hash(),
            original_root
        );

        Ok(original_tree.append(self.leaves.as_slice()))
    }
```

**File:** consensus/safety-rules/src/error.rs (L19-20)
```rust
    #[error("Unable to verify that the new tree extends the parent: {0}")]
    InvalidAccumulatorExtension(String),
```
