# Audit Report

## Title
State Merkle DB Truncation Returns Non-Root Node Versions Leading to Database Corruption

## Summary
The `find_closest_node_version_at_or_before()` function in the state merkle database truncation logic can return versions where only non-root nodes exist (partial commits), without validating root node presence. When `truncate_state_merkle_db()` uses this function in its internal loop, it commits database progress to versions lacking valid state roots, violating state consistency guarantees and potentially leaving the database in a corrupted state if a crash occurs during the truncation window.

## Finding Description

The vulnerability exists in the interaction between `find_closest_node_version_at_or_before()` and `truncate_state_merkle_db()` within the state merkle database recovery process.

**NodeKey Encoding and Lexicographic Ordering:**

The NodeKey encoding uses big-endian format: `[version (8 bytes)][num_nibbles (1 byte)][path_bytes]`. [1](#0-0) 

Root nodes (empty path) encode as `[version][0]`, while non-root nodes encode as `[version][n>0][path_bytes]`. Due to lexicographic ordering: `NodeKey(99, []) < NodeKey(99, [0x1]) < NodeKey(100, [])`.

**The Vulnerability:**

The `find_closest_node_version_at_or_before()` function uses a reverse iterator with `seek_for_prev` to find the closest node version. [2](#0-1) 

When seeking `NodeKey::new_empty_path(version)` and no root exists at that version, RocksDB positions the iterator at the largest key less than the target. This could be a non-root node like `NodeKey(version, [0x1])`. The function returns this version WITHOUT checking if a root node exists.

**Partial Commits Are Acknowledged:**

The codebase explicitly acknowledges that partial commits (versions with nodes but no root) can exist. [3](#0-2) 

Additional confirmation exists in the state merkle database implementation. [4](#0-3) 

**Critical Usage Without Validation:**

In `truncate_state_merkle_db()`, the function iteratively truncates from the current version down to the target version. Within the loop, it calls `find_closest_node_version_at_or_before()` to find intermediate truncation points. [5](#0-4) 

The returned `version_before` is then used to commit database progress without verifying a root exists. [6](#0-5) 

**Correct Implementation Pattern:**

The function `find_tree_root_at_or_before()` demonstrates the correct approach by explicitly validating root existence using `root_exists_at_version()`. [7](#0-6) 

If no root exists, it tries version - 1 and eventually searches for the previous epoch ending. [8](#0-7) 

**Attack Scenario:**

1. Database state after crash during sharded commit: Version 98 (complete with root), Version 99 (partial - only `NodeKey(99, [0x1])` exists, no root), Version 100 (complete with root)
2. System recovery calls `sync_commit_progress()` which invokes `truncate_state_merkle_db()` with target version 98
3. First loop iteration: `current_version` = 100, seeks `version_before` at version 99
4. `find_closest_node_version_at_or_before(99)` finds `NodeKey(99, [0x1])` and returns version 99
5. Database commits progress to version 99 (which has NO root node)
6. If system crashes during this window, database is left with progress marker at version 99 without a valid state root
7. Subsequent operations expecting a root at version 99 will fail, causing operational disruption

## Impact Explanation

This violates the **State Consistency** invariant that state transitions must be atomic and verifiable via Merkle proofs. The database progress marker can point to a version without a valid state root, making the state unverifiable and requiring manual intervention.

**Severity: Medium** (up to $10,000) - "State inconsistencies requiring intervention"

- **Database corruption**: Progress marker references a version without a valid root node
- **Operational disruption**: Node operations attempting to access the state root at the corrupted version will fail
- **Manual intervention required**: Database recovery requires re-running truncation or manual rollback
- **Does not directly cause consensus splits**: Nodes would fail-stop rather than diverge on state
- **Not direct loss of funds**: No immediate fund theft, but significant operational impact

The severity aligns with Medium category in the Aptos bug bounty program, as it causes state inconsistencies requiring intervention but does not result in direct fund loss or consensus violations.

## Likelihood Explanation

**Likelihood: Medium**

Partial commits can occur during:
- **System crashes during sharded commits**: The state merkle commit process splits work across multiple shards that are committed in parallel, creating windows where partial data exists
- **Recovery/truncation operations**: The vulnerability manifests during the truncation loop executed as part of crash recovery
- **Multi-step crash scenario**: Requires crash during initial commit (creating partial state) followed by crash during truncation recovery

The code explicitly acknowledges partial commits are a known system condition, not a theoretical edge case, as evidenced by comments in both `truncation_helper.rs` and `state_merkle_db.rs`. The truncation function is part of the standard crash recovery flow in `sync_commit_progress()`, making this a realistic operational scenario.

## Recommendation

Modify `truncate_state_merkle_db()` to use `find_tree_root_at_or_before()` or implement equivalent root validation when finding intermediate truncation points:

```rust
pub(crate) fn truncate_state_merkle_db(
    state_merkle_db: &StateMerkleDb,
    target_version: Version,
) -> Result<()> {
    let status = StatusLine::new(Progress::new("Truncating State Merkle DB.", target_version));

    loop {
        let current_version = get_current_version_in_state_merkle_db(state_merkle_db)?
            .expect("Current version of state merkle db must exist.");
        status.set_current_version(current_version);
        assert_ge!(current_version, target_version);
        if current_version == target_version {
            break;
        }

        // FIX: Use find_tree_root_at_or_before to ensure we have a valid root
        let version_before = find_tree_root_at_or_before(
            ledger_metadata_db, // Need to pass this parameter
            state_merkle_db,
            current_version - 1,
        )?
        .expect("Must exist.");

        let mut top_levels_batch = SchemaBatch::new();
        delete_nodes_and_stale_indices_at_or_after_version(
            state_merkle_db.metadata_db(),
            current_version,
            None,
            &mut top_levels_batch,
        )?;

        state_merkle_db.commit_top_levels(version_before, top_levels_batch)?;
        truncate_state_merkle_db_shards(state_merkle_db, version_before)?;
    }

    Ok(())
}
```

Alternatively, add explicit root validation after calling `find_closest_node_version_at_or_before()`.

## Proof of Concept

A complete PoC would require setting up a test environment with:
1. A state merkle database with partial commits (version with non-root nodes but no root)
2. Triggering the truncation process
3. Demonstrating that the progress marker is committed to a version without a root

The vulnerability is demonstrated through code analysis showing the divergence between `find_closest_node_version_at_or_before()` (no validation) and `find_tree_root_at_or_before()` (with validation), combined with the explicit acknowledgment in comments that partial commits exist in the system.

### Citations

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L103-109)
```rust
    pub fn encode(&self) -> Result<Vec<u8>> {
        let mut out = vec![];
        out.write_u64::<BigEndian>(self.version())?;
        out.write_u8(self.nibble_path().num_nibbles() as u8)?;
        out.write_all(self.nibble_path().bytes())?;
        Ok(out)
    }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L159-163)
```rust
        let version_before = find_closest_node_version_at_or_before(
            state_merkle_db.metadata_db(),
            current_version - 1,
        )?
        .expect("Must exist.");
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L174-176)
```rust
        state_merkle_db.commit_top_levels(version_before, top_levels_batch)?;

        truncate_state_merkle_db_shards(state_merkle_db, version_before)?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L213-217)
```rust
    if let Some(closest_version) =
        find_closest_node_version_at_or_before(state_merkle_db.metadata_db(), version)?
    {
        if root_exists_at_version(state_merkle_db, closest_version)? {
            return Ok(Some(closest_version));
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L220-221)
```rust
        // It's possible that it's a partial commit when sharding is not enabled,
        // look again for the previous version:
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L225-230)
```rust
        if let Some(closest_version) =
            find_closest_node_version_at_or_before(state_merkle_db.metadata_db(), version - 1)?
        {
            if root_exists_at_version(state_merkle_db, closest_version)? {
                return Ok(Some(closest_version));
            }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L286-293)
```rust
pub(crate) fn find_closest_node_version_at_or_before(
    db: &DB,
    version: Version,
) -> Result<Option<Version>> {
    let mut iter = db.rev_iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek_for_prev(&NodeKey::new_empty_path(version))?;
    Ok(iter.next().transpose()?.map(|item| item.0.version()))
}
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L340-342)
```rust
                // Since we split state merkle commit into multiple batches, it's possible that
                // the root is not committed yet. In this case we need to look at the previous
                // root.
```
