# Audit Report

## Title
Unhandled Error in KeyLevelConsensusManager Initialization Causes Validator JWK Consensus Crash

## Summary
The `KeyLevelConsensusManager::run()` method uses `.unwrap()` on the result of `reset_with_on_chain_state()`, which can panic if on-chain JWK data contains malformed structures. While `None` values are safely handled via `.unwrap_or_default()`, the subsequent error propagation is not handled, causing validator JWK consensus unavailability during epoch transitions.

## Finding Description

The `TConsensusManager` trait defines a `run` method that accepts optional `observed_jwks` and `oidc_providers` parameters. Both implementations (`IssuerLevelConsensusManager` and `KeyLevelConsensusManager`) safely handle `None` values using `.unwrap_or_default()`. [1](#0-0) 

However, in `KeyLevelConsensusManager::run()`, there is a critical `.unwrap()` call after `reset_with_on_chain_state()`: [2](#0-1) 

The `reset_with_on_chain_state()` method calls `.indexed()` which can fail: [3](#0-2) 

The `.indexed()` method attempts JWK conversion which can fail with unknown variant types or unpacking errors: [4](#0-3) [5](#0-4) 

When `JWK::try_from()` fails, it returns an error that propagates through `.indexed()` → `reset_with_on_chain_state()` → causing the `.unwrap()` to panic. This occurs during epoch initialization: [6](#0-5) 

The JWK consensus manager runs in a spawned tokio task. When it panics, the entire JWK consensus subsystem for that validator becomes unavailable.

## Impact Explanation

This is a **High Severity** issue per Aptos bug bounty criteria:
- **Validator node component crash**: The JWK consensus runtime terminates, preventing the validator from participating in JWK consensus
- **Availability impact**: Occurs during epoch transitions, a critical synchronization point
- **Feature enabled by default**: `JWK_CONSENSUS_PER_KEY_MODE` is in default enabled features [7](#0-6) 

This can cause validator rewards loss if JWK consensus participation is required for validator performance scoring.

## Likelihood Explanation

**Medium-High likelihood**:
- Can occur during version mismatches when on-chain framework supports new JWK types but validator nodes haven't updated
- Can occur if on-chain data becomes corrupted (though rare)
- Affects all validators using per-key mode during epoch transitions with incompatible on-chain JWK data
- Not directly exploitable by external attackers, but can occur through legitimate protocol evolution

## Recommendation

Replace the `.unwrap()` call with proper error handling that logs the error and gracefully handles initialization failure:

```rust
async fn run(
    self: Box<Self>,
    oidc_providers: Option<SupportedOIDCProviders>,
    observed_jwks: Option<ObservedJWKs>,
    // ... other parameters
) {
    let mut this = self;
    
    // Replace unwrap() with proper error handling
    if let Err(e) = this.reset_with_on_chain_state(
        observed_jwks.unwrap_or_default().into_providers_jwks()
    ) {
        error!(
            epoch = this.epoch_state.epoch,
            "Failed to initialize KeyLevelConsensusManager with on-chain state: {:#}", 
            e
        );
        // Gracefully handle - either retry or continue with empty state
        // depending on desired behavior
        return;
    }
    
    // ... rest of the function
}
```

The same fix should be applied to `IssuerLevelConsensusManager::run()` for consistency, even though its `reset_with_on_chain_state()` currently cannot fail.

## Proof of Concept

```rust
// This test demonstrates the panic scenario
#[tokio::test]
async fn test_malformed_jwk_causes_panic() {
    use aptos_types::jwks::*;
    use aptos_types::move_any::Any as MoveAny;
    
    // Create a JWKMoveStruct with an unknown variant type
    let malformed_jwk = JWKMoveStruct {
        variant: MoveAny {
            type_name: "0x1::unknown::UnknownJWK".to_string(),
            data: vec![],
        },
    };
    
    let provider_jwks = ProviderJWKs {
        issuer: b"test_issuer".to_vec(),
        version: 1,
        jwks: vec![malformed_jwk],
    };
    
    let observed_jwks = ObservedJWKs {
        jwks: AllProvidersJWKs {
            entries: vec![provider_jwks],
        },
    };
    
    // Attempt to convert - this will fail
    let result = observed_jwks.jwks.indexed();
    
    // This demonstrates the error that causes the unwrap to panic
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("unknown variant"));
}
```

## Notes

While the question specifically asked about `None` option handling, the investigation revealed that `None` values are handled safely via `.unwrap_or_default()`. However, the broader error handling in the same code path is insufficient, creating a validator availability risk when on-chain data contains malformed JWK structures. This affects the `KeyLevelConsensusManager` implementation specifically, which is the default mode in current Aptos deployments.

### Citations

**File:** crates/aptos-jwk-consensus/src/lib.rs (L64-77)
```rust
#[async_trait::async_trait]
trait TConsensusManager: Send + Sync {
    async fn run(
        self: Box<Self>,
        oidc_providers: Option<SupportedOIDCProviders>,
        observed_jwks: Option<ObservedJWKs>,
        mut jwk_updated_rx: aptos_channel::Receiver<(), ObservedJWKsUpdated>,
        mut rpc_req_rx: aptos_channel::Receiver<
            AccountAddress,
            (AccountAddress, IncomingRpcRequest),
        >,
        close_rx: oneshot::Receiver<oneshot::Sender<()>>,
    );
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L240-242)
```rust
        let new_onchain_jwks = on_chain_state.indexed().context(
            "KeyLevelJWKManager::reset_with_on_chain_state failed at onchain state indexing",
        )?;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L377-380)
```rust
    ) {
        let mut this = self;
        this.reset_with_on_chain_state(observed_jwks.unwrap_or_default().into_providers_jwks())
            .unwrap();
```

**File:** types/src/jwks/mod.rs (L139-151)
```rust
    pub fn indexed(&self) -> anyhow::Result<ProviderJWKsIndexed> {
        let mut jwks = HashMap::new();
        for jwk_in_move in self.jwks.iter() {
            let jwk = JWK::try_from(jwk_in_move)
                .context("ProviderJWKs::indexed failed by JWK conversion")?;
            jwks.insert(jwk.id(), jwk);
        }
        Ok(ProviderJWKsIndexed {
            issuer: self.issuer.clone(),
            version: self.version,
            jwks,
        })
    }
```

**File:** types/src/jwks/jwk/mod.rs (L102-122)
```rust
impl TryFrom<&JWKMoveStruct> for JWK {
    type Error = anyhow::Error;

    fn try_from(value: &JWKMoveStruct) -> Result<Self, Self::Error> {
        match value.variant.type_name.as_str() {
            RSA_JWK::MOVE_TYPE_NAME => {
                let rsa_jwk =
                    MoveAny::unpack(RSA_JWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to rsa unpacking error: {e}"))?;
                Ok(Self::RSA(rsa_jwk))
            },
            UnsupportedJWK::MOVE_TYPE_NAME => {
                let unsupported_jwk =
                    MoveAny::unpack(UnsupportedJWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to unsupported unpacking error: {e}"))?;
                Ok(Self::Unsupported(unsupported_jwk))
            },
            _ => Err(anyhow!(
                "converting from jwk move struct to jwk failed with unknown variant"
            )),
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L247-253)
```rust
            tokio::spawn(jwk_consensus_manager.run(
                oidc_providers,
                onchain_observed_jwks,
                jwk_event_rx,
                jwk_rpc_msg_rx,
                jwk_manager_close_rx,
            ));
```

**File:** types/src/on_chain_config/aptos_features.rs (L261-261)
```rust
            FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE,
```
