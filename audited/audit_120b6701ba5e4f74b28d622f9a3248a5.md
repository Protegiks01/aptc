# Audit Report

## Title
False Negative in `in_validator_set()` During Key Mismatch Causes Active Validators to Refuse Voting and Harm Liveness

## Summary
The `in_validator_set()` function can incorrectly return `false` for validators that ARE actually in the active validator set when there is a mismatch between the validator's expected consensus public key (stored in the epoch state) and the private key available in their local persistent storage. This false negative causes affected validators to refuse all voting operations, potentially harming network liveness if multiple validators are affected.

## Finding Description

The vulnerability exists in how `ConsensusState::in_validator_set()` determines validator set membership. The function returns the result of `self.signer().is_ok()` [1](#0-0) , which checks whether a valid `ValidatorSigner` exists, rather than checking if the validator's address is actually present in the epoch state's validator set.

During initialization in `SafetyRules::guarded_initialize()`, the system performs key reconciliation [2](#0-1) . The critical flow is:

1. The validator's address IS present in the validator set, and `epoch_state.verifier.get_public_key(&author)` returns `Some(expected_key)` [3](#0-2) 

2. However, when attempting to retrieve the corresponding private key from storage via `persistent_storage.consensus_sk_by_pk(expected_key)` [4](#0-3) , the operation fails

3. The `consensus_sk_by_pk()` method tries both an explicit key lookup and a default key fallback, but if both fail, it returns `Error::ValidatorKeyNotFound` [5](#0-4) 

4. This error causes `validator_signer` to be set to `None` [6](#0-5) 

5. Subsequently, `in_validator_set()` returns `false` because `signer().is_ok()` evaluates to `false` [7](#0-6) 

When voting is attempted, the validator cannot participate because `guarded_construct_and_sign_vote_two_chain()` immediately calls `self.signer()?` [8](#0-7) , which fails. The `MetricsSafetyRules` wrapper attempts retry with reinitialization on `NotInitialized` errors [9](#0-8) , but if the key mismatch persists, reinitialization fails with `ValidatorKeyNotFound`, which is NOT caught by the retry logic, causing voting to fail permanently.

The test case `test_key_not_in_store` explicitly validates this scenario where a validator IS in the set (same author) but has a different expected public key, resulting in `in_validator_set()` returning false [10](#0-9) .

## Impact Explanation

This issue can cause **High Severity** liveness degradation:

- **Single Validator Impact**: An affected validator cannot participate in consensus voting, reducing the network's fault tolerance by one validator
- **Multiple Validator Impact**: If the number of affected validators exceeds f (where 3f+1 is the total validator count), the network cannot achieve the 2f+1 quorum threshold required for consensus, causing complete liveness failure
- **Categorization**: This falls under "Validator node slowdowns" and "Significant protocol violations" per the High Severity criteria, as it prevents validators from fulfilling their consensus duties

The issue occurs during operational scenarios such as consensus key rotation, where the on-chain registered key and local storage can become temporarily or permanently misaligned.

## Likelihood Explanation

**Likelihood: Medium to High** during key rotation operations:

- Occurs whenever there is a mismatch between the consensus public key registered on-chain (in the validator set) and the private key available in the validator's local persistent storage
- Most commonly triggered during consensus key rotation procedures when timing or configuration issues cause misalignment
- Can also occur from storage corruption or incomplete key migration processes
- The test suite explicitly validates this scenario, indicating it's a known operational concern

## Recommendation

Implement a two-part fix:

**Part 1: Add `ValidatorKeyNotFound` to retry logic in MetricsSafetyRules**

The retry mechanism should also catch `ValidatorKeyNotFound` errors to allow for potential recovery: [9](#0-8) 

Modify the error matching to include:
```rust
Err(Error::NotInitialized(_))
| Err(Error::IncorrectEpoch(_, _))
| Err(Error::WaypointOutOfDate(_, _, _, _))
| Err(Error::ValidatorKeyNotFound(_)) => {
    self.perform_initialize()?;
    f(&mut self.inner)
}
```

**Part 2: Improve `in_validator_set()` accuracy**

The function should check actual validator set membership rather than relying solely on signer availability. Consider adding epoch state information to ConsensusState to enable direct validator set lookup.

**Part 3: Add operational alerts**

Emit high-priority alerts when `ValidatorKeyNotFound` errors occur, as this indicates a critical configuration mismatch requiring immediate operator intervention.

## Proof of Concept

The existing test case demonstrates this vulnerability: [10](#0-9) 

To reproduce:

1. Initialize SafetyRules with a validator's consensus key
2. Create an epoch change where the validator IS in the validator set (same author) but with a DIFFERENT expected consensus public key
3. Attempt to initialize with this epoch proof
4. Observe that initialization fails due to key not being found in storage
5. Call `consensus_state()` and verify that `in_validator_set()` returns `false`
6. Attempt any voting operation - it will fail because the signer is unavailable

This demonstrates that a validator that IS legitimately in the validator set (their address is present) will incorrectly report `in_validator_set() == false` and refuse to vote when there is a key mismatch, harming consensus liveness.

## Notes

While this is a genuine bug causing false negatives in `in_validator_set()`, it primarily manifests as an **operational reliability issue** rather than a directly exploitable security vulnerability by external attackers. The condition requires validator operator misconfiguration or storage issues rather than malicious external manipulation. However, it does violate the liveness invariant of the consensus protocol and should be addressed to improve operational robustness during key rotation procedures.

### Citations

**File:** consensus/safety-rules/src/consensus_state.rs (L75-77)
```rust
    pub fn in_validator_set(&self) -> bool {
        self.in_validator_set
    }
```

**File:** consensus/safety-rules/src/consensus_state.rs (L258-262)
```rust

```

**File:** consensus/safety-rules/src/safety_rules.rs (L312-343)
```rust
        let author = self.persistent_storage.author()?;
        let expected_key = epoch_state.verifier.get_public_key(&author);
        let initialize_result = match expected_key {
            None => Err(Error::ValidatorNotInSet(author.to_string())),
            Some(expected_key) => {
                let current_key = self.signer().ok().map(|s| s.public_key());
                if current_key == Some(expected_key.clone()) {
                    info!(
                        SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Success),
                        "in set",
                    );
                    Ok(())
                } else {
                    // Try to export the consensus key directly from storage.
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
                        },
                        Err(Error::SecureStorageMissingDataError(error)) => {
                            Err(Error::ValidatorKeyNotFound(error))
                        },
                        Err(error) => Err(error),
                    }
                }
            },
        };
        initialize_result.inspect_err(|error| {
            info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
            self.validator_signer = None;
        })
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L118-124)
```rust
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L58-59)
```rust
        // Exit early if we cannot sign
        self.signer()?;
```

**File:** consensus/src/metrics_safety_rules.rs (L71-85)
```rust
    fn retry<T, F: FnMut(&mut Box<dyn TSafetyRules + Send + Sync>) -> Result<T, Error>>(
        &mut self,
        mut f: F,
    ) -> Result<T, Error> {
        let result = f(&mut self.inner);
        match result {
            Err(Error::NotInitialized(_))
            | Err(Error::IncorrectEpoch(_, _))
            | Err(Error::WaypointOutOfDate(_, _, _, _)) => {
                self.perform_initialize()?;
                f(&mut self.inner)
            },
            _ => result,
        }
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L642-676)
```rust
fn test_key_not_in_store(safety_rules: &Callback) {
    let (mut safety_rules, signer) = safety_rules();
    let (mut proof, genesis_qc) = test_utils::make_genesis(&signer);
    let round = genesis_qc.certified_block().round();

    safety_rules.initialize(&proof).unwrap();

    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);

    // Update to an epoch where the validator fails to retrive the respective key
    // from persistent storage
    let mut next_epoch_state = EpochState::empty();
    next_epoch_state.epoch = 1;
    let rand_signer = ValidatorSigner::random([0xFu8; 32]);
    next_epoch_state.verifier =
        ValidatorVerifier::new_single(signer.author(), rand_signer.public_key()).into();
    let a2 = test_utils::make_proposal_with_parent_and_overrides(
        Payload::empty(false, true),
        round + 2,
        &a1,
        Some(&a1),
        &signer,
        Some(1),
        Some(next_epoch_state),
    );
    proof
        .ledger_info_with_sigs
        .push(a2.block().quorum_cert().ledger_info().clone());

    // Expected failure due to validator key not being found.
    safety_rules.initialize(&proof).unwrap_err();

    let state = safety_rules.consensus_state().unwrap();
    assert!(!state.in_validator_set());
}
```
