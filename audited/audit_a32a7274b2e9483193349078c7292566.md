# Audit Report

## Title
Indexer Panic on Token Claim Deletion Due to Missing Table Metadata Causes Permanent Service Disruption

## Summary
The Aptos indexer crashes with a panic when processing token claim deletions if table handle metadata is missing from the current transaction batch. This asymmetric error handling—warnings for writes but panics for deletes—creates a denial-of-service vulnerability where the indexer cannot progress past certain transactions, leaving claims in an "undeletable" state in the indexer database despite being deleted on-chain.

## Finding Description

The vulnerability exists in the indexer's token claim processing logic, specifically in how it handles missing table metadata: [1](#0-0) 

When processing write operations, if table metadata is missing, the indexer logs a warning and gracefully continues by returning `None`.

However, for delete operations, the handling is drastically different: [2](#0-1) 

The delete handler uses `unwrap_or_else` with a panic, causing the entire indexer process to crash when metadata is unavailable.

**Root Cause Analysis:**

The `table_handle_to_owner` mapping is built per-batch from `WriteResource` changes in the current transaction batch: [3](#0-2) [4](#0-3) 

The mapping only contains metadata from resources written in the **current batch**. When a token claim is created in batch N and deleted in batch M (M > N), if batch M contains no `WriteResource` for `PendingClaims`, the table handle metadata is missing.

This scenario is particularly likely when the new event system is enabled. In the Move smart contract: [5](#0-4) 

When `module_event_migration_enabled()` returns true, the `claim()` function emits events via `event::emit()` which does not modify the `PendingClaims` resource fields—only the table is modified via `remove()` at line 173. This generates a `DeleteTableItem` but **no** `WriteResource` for the containing resource.

The panic propagates upward as the call site uses `.unwrap()`: [6](#0-5) 

**Exploitation Path:**

1. Attacker creates token offers in transaction batch N, generating claims
2. Indexer successfully processes batch N (metadata present)
3. In batch M (with new event system enabled), attacker or receiver claims/cancels the offers
4. Batch M contains `DeleteTableItem` operations but no `PendingClaimsResource` writes
5. `table_handle_to_owner` mapping is empty for these table handles
6. Indexer calls `from_delete_table_item()` which panics
7. Indexer crashes and cannot progress past batch M
8. Claims appear "undeletable" - they persist in indexer database despite on-chain deletion

**Comparison with Other Token Models:**

The inconsistency is evident when comparing with `token_ownerships.rs`, which handles missing metadata gracefully: [7](#0-6) 

Even the token delete handler manages missing metadata without panicking: [8](#0-7) 

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria: "State inconsistencies requiring intervention")

This vulnerability creates multiple impacts:

1. **Indexer Denial of Service**: The indexer crashes and stops processing all transactions
2. **Repeatable Crash**: Each restart attempt fails at the same transaction
3. **State Inconsistency**: Indexer database shows claims as existing when they're deleted on-chain
4. **Service Disruption**: Applications relying on indexer APIs receive stale or unavailable data
5. **Manual Intervention Required**: Requires code fix or database surgery to proceed

**Why Not Higher Severity:**

This is an **off-chain indexer issue**, not a consensus or execution layer vulnerability. It does not:
- Affect validator operation or consensus safety
- Cause loss of funds or on-chain state corruption  
- Impact transaction execution or block production
- Require validator-level privileges to exploit

The on-chain state remains correct; only the indexer's view is affected.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has high likelihood of occurrence in production because:

1. **Normal Operations Trigger It**: Any claim deletion when the new event system is enabled can cause the crash if the batch lacks other `PendingClaims` writes
2. **Feature Flag Dependency**: The new event migration is a progressive rollout feature, making the vulnerable code path active
3. **No Attacker Action Required**: This can happen naturally without malicious intent when users legitimately claim or cancel token offers
4. **Batch Isolation**: The per-batch metadata mapping design inherently creates gaps when resources aren't written in every batch

The asymmetry suggests this is an **unintentional coding error** where the delete handler was written with different assumptions than the write handler, likely expecting metadata to always be present.

## Recommendation

**Fix: Align delete handling with write handling to gracefully handle missing metadata**

Modify `CurrentTokenPendingClaim::from_delete_table_item()` to warn instead of panic:

```rust
pub fn from_delete_table_item(
    table_item: &APIDeleteTableItem,
    txn_version: i64,
    txn_timestamp: chrono::NaiveDateTime,
    table_handle_to_owner: &TableHandleToOwner,
) -> anyhow::Result<Option<Self>> {
    let table_item_data = table_item.data.as_ref().unwrap();

    let maybe_offer = match TokenWriteSet::from_table_item_type(
        table_item_data.key_type.as_str(),
        &table_item_data.key,
        txn_version,
    )? {
        Some(TokenWriteSet::TokenOfferId(inner)) => Some(inner),
        _ => None,
    };
    if let Some(offer) = maybe_offer {
        let table_handle = standardize_address(&table_item.handle.to_string());

        // FIXED: Use same pattern as write handler
        let maybe_table_metadata = table_handle_to_owner.get(&table_handle);
        
        if let Some(table_metadata) = maybe_table_metadata {
            let token_id = offer.token_id;
            let token_data_id_struct = token_id.token_data_id;
            // ... rest of the logic
            return Ok(Some(Self { /* ... */ }));
        } else {
            aptos_logger::warn!(
                transaction_version = txn_version,
                table_handle = table_handle,
                "Missing table handle metadata for claim deletion. {:?}",
                table_handle_to_owner
            );
        }
    }
    Ok(None)
}
```

**Alternative Solutions:**

1. **Cumulative Metadata Cache**: Maintain a persistent cache of table handle mappings across batches
2. **Database Lookup**: Query the indexer database for owner information if not in current batch
3. **Lazy Deletion**: Mark claims for deletion and process when metadata becomes available

## Proof of Concept

**Scenario Setup:**

1. Deploy token contract and create collection
2. User A creates token offer to User B (transaction in batch N)
3. Enable new event migration feature flag
4. User B claims the token (transaction in batch M, M > N)
5. Ensure no other `PendingClaims` resource writes occur in batch M

**Indexer Processing:**

```rust
// Batch N processing - SUCCESS
// - WriteResource for PendingClaims (table handle 0xABC123...)
// - WriteTableItem adding claim
// - table_handle_to_owner contains 0xABC123 -> UserA metadata
// - Claim indexed successfully

// Batch M processing - CRASH
// - DeleteTableItem removing claim from table 0xABC123
// - No WriteResource for PendingClaims (new event system active)
// - table_handle_to_owner is EMPTY for 0xABC123
// - from_delete_table_item() calls unwrap_or_else -> PANIC
// - Indexer crashes with:
//   "Missing table handle metadata for claim. Version: M, 
//    table handle for PendingClaims: 0xABC123, all metadata: {}"
```

**Verification:**

After crash, query indexer database:
```sql
SELECT * FROM current_token_pending_claims 
WHERE from_address = 'UserA' AND to_address = 'UserB';
-- Returns the claim row (undeletable in indexer)
```

Query on-chain state:
```move
// Claim does not exist in PendingClaims.pending_claims table
// On-chain state is correct, indexer state is stale
```

## Notes

This vulnerability highlights a critical design issue: **per-batch metadata construction is insufficient for delete operations**. While writes can tolerate missing metadata (by skipping indexing), deletes represent state that must be processed to maintain consistency.

The fix should ensure the indexer remains resilient to metadata gaps while maintaining accurate state. The graceful degradation approach (warn and skip) is preferable to crashing, though ideally the indexer should query historical metadata to process all deletes correctly.

### Citations

**File:** crates/indexer/src/models/token_models/token_claims.rs (L97-102)
```rust
                    aptos_logger::warn!(
                        transaction_version = txn_version,
                        table_handle = table_handle,
                        "Missing table handle metadata for TokenClaim. {:?}",
                        table_handle_to_owner
                    );
```

**File:** crates/indexer/src/models/token_models/token_claims.rs (L135-141)
```rust
            let table_metadata = table_handle_to_owner.get(&table_handle).unwrap_or_else(|| {
                panic!(
                    "Missing table handle metadata for claim. \
                    Version: {}, table handle for PendingClaims: {}, all metadata: {:?}",
                    txn_version, table_handle, table_handle_to_owner
                )
            });
```

**File:** crates/indexer/src/models/token_models/tokens.rs (L156-164)
```rust
                    APIWriteSetChange::DeleteTableItem(delete_table_item) => {
                        CurrentTokenPendingClaim::from_delete_table_item(
                            delete_table_item,
                            txn_version,
                            txn_timestamp,
                            table_handle_to_owner,
                        )
                        .unwrap()
                    },
```

**File:** crates/indexer/src/models/token_models/tokens.rs (L328-339)
```rust
            let (token_ownership, current_token_ownership) = TokenOwnership::from_token(
                &token,
                table_item_data.key_type.as_str(),
                &table_item_data.key,
                BigDecimal::zero(),
                table_item.handle.to_string(),
                table_handle_to_owner,
            )?
            .map(|(token_ownership, current_token_ownership)| {
                (Some(token_ownership), current_token_ownership)
            })
            .unwrap_or((None, None));
```

**File:** crates/indexer/src/models/token_models/tokens.rs (L350-373)
```rust
    pub fn get_table_handle_to_owner_from_transactions(
        transactions: &[APITransaction],
    ) -> TableHandleToOwner {
        let mut table_handle_to_owner: TableHandleToOwner = HashMap::new();
        // Do a first pass to get all the table metadata in the batch.
        for transaction in transactions {
            if let APITransaction::UserTransaction(user_txn) = transaction {
                let txn_version = user_txn.info.version.0 as i64;
                for wsc in &user_txn.info.changes {
                    if let APIWriteSetChange::WriteResource(write_resource) = wsc {
                        let maybe_map = TableMetadataForToken::get_table_handle_to_owner(
                            write_resource,
                            txn_version,
                        )
                        .unwrap();
                        if let Some(map) = maybe_map {
                            table_handle_to_owner.extend(map);
                        }
                    }
                }
            }
        }
        table_handle_to_owner
    }
```

**File:** crates/indexer/src/models/token_models/tokens.rs (L376-412)
```rust
    fn get_table_handle_to_owner(
        write_resource: &APIWriteResource,
        txn_version: i64,
    ) -> anyhow::Result<Option<TableHandleToOwner>> {
        let type_str = format!(
            "{}::{}::{}",
            write_resource.data.typ.address,
            write_resource.data.typ.module,
            write_resource.data.typ.name
        );
        if !TokenResource::is_resource_supported(type_str.as_str()) {
            return Ok(None);
        }
        let resource = MoveResource::from_write_resource(
            write_resource,
            0, // Placeholder, this isn't used anyway
            txn_version,
            0, // Placeholder, this isn't used anyway
        );

        let value = TableMetadataForToken {
            owner_address: standardize_address(&resource.address),
            table_type: write_resource.data.typ.to_string(),
        };
        let table_handle: TableHandle = match TokenResource::from_resource(
            &type_str,
            resource.data.as_ref().unwrap(),
            txn_version,
        )? {
            TokenResource::CollectionResource(collection_resource) => {
                collection_resource.collection_data.get_handle()
            },
            TokenResource::TokenStoreResource(inner) => inner.tokens.get_handle(),
            TokenResource::PendingClaimsResource(inner) => inner.pending_claims.get_handle(),
        };
        Ok(Some(HashMap::from([(table_handle, value)])))
    }
```

**File:** aptos-move/framework/aptos-token/sources/token_transfers.move (L163-196)
```text
    public fun claim(
        receiver: &signer,
        sender: address,
        token_id: TokenId,
    ) acquires PendingClaims {
        assert!(exists<PendingClaims>(sender), ETOKEN_OFFER_NOT_EXIST);
        let pending_claims =
            &mut PendingClaims[sender].pending_claims;
        let token_offer_id = create_token_offer_id(signer::address_of(receiver), token_id);
        assert!(pending_claims.contains(token_offer_id), error::not_found(ETOKEN_OFFER_NOT_EXIST));
        let tokens = pending_claims.remove(token_offer_id);
        let amount = token::get_token_amount(&tokens);
        token::deposit_token(receiver, tokens);

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                Claim {
                    account: sender,
                    to_address: signer::address_of(receiver),
                    token_id,
                    amount,
                }
            )
        } else {
            event::emit_event<TokenClaimEvent>(
                &mut PendingClaims[sender].claim_events,
                TokenClaimEvent {
                    to_address: signer::address_of(receiver),
                    token_id,
                    amount,
                },
            );
        };
    }
```

**File:** crates/indexer/src/models/token_models/token_ownerships.rs (L114-122)
```rust
            None => {
                aptos_logger::warn!(
                    transaction_version = txn_version,
                    table_handle = table_handle,
                    "Missing table handle metadata for TokenStore. {:?}",
                    table_handle_to_owner
                );
                (None, None, None)
            },
```
