# Audit Report

## Title
Indexer Transaction Filter Panic on Invalid Protobuf Enum Values Leading to Denial of Service

## Summary
The transaction filter in the indexer-grpc service uses `.expect()` when converting transaction type enum values, causing the indexer process to panic and crash when encountering an invalid `r#type` field value in a Transaction protobuf message. While the direct attack surface is limited, data corruption in the file store or cache can trigger this vulnerability, resulting in indexer service unavailability.

## Finding Description
The vulnerability exists in the transaction filtering logic where protobuf-deserialized Transaction messages are processed. [1](#0-0) 

When prost deserializes protobuf messages, the `r#type` field is stored as a raw `i32` value without validation. [2](#0-1)  The TransactionType enum only defines specific valid values (0, 1, 2, 3, 4, 20, 21), but protobuf deserialization accepts any i32 value. [3](#0-2) 

The attack path involves:

1. **Transaction Deserialization from File Store**: The indexer reads cached transactions from file store (GCS/S3) and deserializes them using `Transaction::decode()` without validating enum fields. [4](#0-3) 

2. **Filter Application**: Deserialized transactions are passed through the transaction filter. [5](#0-4) 

3. **Panic on Invalid Enum**: The filter attempts to convert the raw i32 value to TransactionType enum and panics on failure, crashing the indexer process.

**How Invalid Values Can Occur:**
- **Storage corruption**: Bit flips, disk errors, or filesystem corruption in GCS/S3 storage
- **Memory corruption**: Hardware errors during caching or processing  
- **Storage system compromise**: If an attacker gains write access to the file store backend
- **Undiscovered encoding bugs**: Though current code appears correct, future changes could introduce issues

The same vulnerability pattern exists in the cache worker. [6](#0-5) 

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program criteria for "API crashes":

- **Availability Impact**: The indexer-grpc-data-service or file store reader crashes immediately upon encountering corrupted data, causing complete service unavailability
- **Downstream Effects**: All downstream indexer processors and applications depending on the transaction stream experience service disruption
- **Recovery**: Requires manual intervention to identify and remove/repair corrupted data before the service can restart
- **Cascading Failures**: If corrupted data persists in file store, the service enters a crash loop

While this is not directly exploitable by an unprivileged external attacker (as transactions are generated by trusted fullnode code), it represents a critical robustness failure that can be triggered by:
1. Natural data corruption events (low but non-zero probability)
2. Storage backend compromise (requires separate security breach)
3. Future code changes that inadvertently write invalid values

## Likelihood Explanation
**Likelihood: MEDIUM-LOW with increasing probability over time**

- **Natural Corruption**: As the file store grows (petabytes of data), the probability of bit flips or storage corruption increases. Storage systems do experience corruption events in production.
- **Attack Complexity**: Direct exploitation requires either compromising cloud storage credentials (high barrier) or exploiting an undiscovered bug in the encoding logic.
- **Production Reality**: Large-scale distributed systems regularly encounter data corruption issues. A single corrupted transaction file can crash the entire indexer.
- **Lack of Defense in Depth**: The code assumes all deserialized data is valid, violating defensive programming principles.

The likelihood increases as:
- Storage volume grows
- System operates longer (increasing exposure to rare corruption events)
- More code paths write to file store (increasing bug surface area)

## Recommendation
Replace `.expect()` with proper error handling that logs the error and skips the invalid transaction rather than panicking:

```rust
fn matches(&self, item: &Transaction) -> bool {
    if !self
        .success
        .matches_opt(&item.info.as_ref().map(|i| i.success))
    {
        return false;
    }

    if let Some(txn_type) = &self.txn_type {
        match TransactionType::try_from(item.r#type) {
            Ok(item_type) => {
                if txn_type != &item_type {
                    return false;
                }
            }
            Err(_) => {
                // Log error and skip invalid transaction instead of panicking
                warn!(
                    "Encountered transaction with invalid type field: {}. Skipping.",
                    item.r#type
                );
                return false;
            }
        }
    }

    true
}
```

Additionally, add validation when deserializing from file store to detect corruption early and add monitoring/alerting for invalid enum values to detect storage corruption issues proactively.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Transaction, TransactionInfo};

    #[test]
    #[should_panic(expected = "Invalid transaction type")]
    fn test_invalid_transaction_type_causes_panic() {
        // Create a filter that checks transaction type
        let filter = TransactionRootFilterBuilder::default()
            .txn_type(transaction::TransactionType::User)
            .build()
            .unwrap();

        // Create a transaction with an invalid type value
        // In real scenario, this would come from corrupted file store data
        let mut txn = Transaction {
            version: 1,
            r#type: 99, // Invalid enum value (not in 0,1,2,3,4,20,21)
            info: Some(TransactionInfo {
                success: true,
                ..Default::default()
            }),
            ..Default::default()
        };

        // This will panic when trying to convert r#type=99 to TransactionType
        let matches = filter.matches(&txn);
        // Should never reach here
    }
}
```

This PoC demonstrates that passing a Transaction with an invalid `r#type` value through the filter causes an immediate panic, crashing the indexer service.

## Notes
While the direct attack surface is limited (attacker cannot easily inject crafted protobuf messages), this represents a production robustness issue that violates defensive programming principles. The fix is straightforward and prevents service crashes from data corruption events that, while unlikely, do occur in large-scale production systems. The vulnerability also applies to similar `.expect()` usages on enum conversions throughout the indexer codebase.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L67-73)
```rust
        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L51-52)
```rust
    #[prost(enumeration="transaction::TransactionType", tag="6")]
    pub r#type: i32,
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L47-56)
```text
  enum TransactionType {
    TRANSACTION_TYPE_UNSPECIFIED = 0;
    TRANSACTION_TYPE_GENESIS = 1;
    TRANSACTION_TYPE_BLOCK_METADATA = 2;
    TRANSACTION_TYPE_STATE_CHECKPOINT = 3;
    TRANSACTION_TYPE_USER = 4;
    // values 5-19 skipped for no reason
    TRANSACTION_TYPE_VALIDATOR = 20;
    TRANSACTION_TYPE_BLOCK_EPILOGUE = 21;
  }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L144-156)
```rust
            CacheEntry::Lz4CompressionProto(bytes) => {
                let mut decompressor = Decoder::new(&bytes[..]).expect("Lz4 decompression failed.");
                let mut decompressed = Vec::new();
                decompressor
                    .read_to_end(&mut decompressed)
                    .expect("Lz4 decompression failed.");
                Transaction::decode(decompressed.as_slice()).expect("proto deserialization failed.")
            },
            CacheEntry::Base64UncompressedProto(bytes) => {
                let bytes: Vec<u8> = base64::decode(bytes).expect("base64 decoding failed.");
                Transaction::decode(bytes.as_slice()).expect("proto deserialization failed.")
            },
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L140-142)
```rust
                if let Some(ref filter) = filter {
                    transactions.retain(|t| filter.matches(t));
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L191-191)
```rust
            match StatusType::try_from(status.r#type).expect("[Indexer Cache] Invalid status type.")
```
