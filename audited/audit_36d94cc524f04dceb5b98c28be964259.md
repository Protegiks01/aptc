# Audit Report

## Title
Missing Epoch Validation in BlockMetadata Execution Allows Epoch Confusion and State Inconsistencies

## Summary
The Move framework's `block_prologue_common` function does not validate that the epoch field in `BlockMetadata` matches the current on-chain epoch from `reconfiguration::Configuration`. This allows blocks with incorrect epoch values to be executed, causing state inconsistencies in the randomness module, incorrect event emissions, and potential confusion during epoch transitions.

## Finding Description

The test at lines 94-102 and 154-162 creates `BlockMetadata` with epoch values that are not validated against the on-chain epoch state: [1](#0-0) [2](#0-1) 

Most critically, Block 3 is created with epoch=2 after two reconfigurations should have moved the chain to epoch 3: [3](#0-2) 

The vulnerability exists because the Move framework's `block_prologue_common` function accepts the epoch parameter from `BlockMetadata` without validating it against the current on-chain epoch: [4](#0-3) 

The proposer validation only checks if the proposer is in the current validator set, not whether the epoch matches: [5](#0-4) 

The validator check uses the current on-chain validator set regardless of the epoch claimed in `BlockMetadata`: [6](#0-5) 

**Critical Impact: Randomness Module Corruption**

The epoch value from `BlockMetadata` is directly stored in the randomness module without validation: [7](#0-6) 

This is called from `block_prologue` with the unvalidated epoch: [8](#0-7) 

**How the Vulnerability Propagates:**

1. Consensus layer creates `BlockMetadata` with epoch value from `Block::epoch()`
2. VM processes the metadata via `process_block_prologue` [9](#0-8) 

3. Move framework executes `block_prologue` which accepts epoch without validation
4. Epoch stored in `PerBlockRandomness` resource and emitted in events
5. No validation against `reconfiguration::current_epoch()` occurs [10](#0-9) 

## Impact Explanation

**Medium Severity** - This vulnerability causes state inconsistencies requiring intervention:

1. **Randomness State Corruption**: The `PerBlockRandomness` resource stores incorrect epoch values, breaking the randomness system's epoch tracking
2. **Event Inconsistency**: `NewBlockEvent` emits incorrect epoch values, confusing off-chain indexers and monitoring systems
3. **Epoch Boundary Confusion**: During epoch transitions, blocks could be executed with mismatched epoch metadata
4. **Performance Tracking Issues**: While `update_performance_statistics` doesn't directly use the epoch, the semantic mismatch could cause confusion in reward distribution systems

This does not cause direct fund loss or consensus safety violations, but creates significant state inconsistencies that could require manual intervention to resolve.

## Likelihood Explanation

**Medium Likelihood** - This could occur in several scenarios:

1. **Consensus Bugs**: Implementation errors in the consensus layer could generate incorrect epoch values during epoch transitions
2. **Byzantine Behavior**: Malicious validators could propose blocks with incorrect epochs (within BFT assumptions)
3. **Network Partitions**: During network healing after partitions, epoch confusion could occur
4. **Race Conditions**: Timing issues during epoch transitions could cause epoch mismatches

The test demonstrates this is already possible - Block 3 executes with epoch=2 when it should be epoch=3.

## Recommendation

Add epoch validation in `block_prologue_common` to ensure the `BlockMetadata` epoch matches the current on-chain epoch:

```move
fun block_prologue_common(
    vm: &signer,
    hash: address,
    epoch: u64,
    round: u64,
    proposer: address,
    failed_proposer_indices: vector<u64>,
    previous_block_votes_bitvec: vector<u8>,
    timestamp: u64
): u64 acquires BlockResource, CommitHistory {
    system_addresses::assert_vm(vm);
    
    // ADD THIS VALIDATION
    let current_epoch = reconfiguration::current_epoch();
    assert!(
        epoch == current_epoch,
        error::invalid_argument(EINVALID_EPOCH),
    );
    
    // ... rest of function
}
```

Also fix the test to use correct epoch values for Block 3:

```rust
let block3_meta = Transaction::BlockMetadata(BlockMetadata::new(
    block3_id,
    3,  // Changed from 2 to 3 (correct epoch after two reconfigurations)
    1,
    signer.author(),
    vec![0],
    vec![],
    3,
));
```

## Proof of Concept

The existing test already demonstrates the vulnerability. To create an explicit PoC:

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = EINVALID_EPOCH)]
public entry fun test_epoch_mismatch_should_fail(aptos_framework: signer) {
    // Initialize with epoch 0
    reconfiguration::initialize_for_test(&aptos_framework);
    block::initialize_for_test(&aptos_framework, 1000000);
    
    // Trigger reconfiguration to move to epoch 1
    reconfiguration::reconfigure_for_test();
    
    // Try to execute block prologue with epoch 0 (should fail)
    block::block_prologue(
        aptos_framework,
        @0x1,
        0,  // Wrong epoch - should be 1
        0,
        @0x1,
        vector::empty(),
        vector::empty(),
        1000000
    );
}
```

Without the recommended fix, this test would pass when it should fail, proving the vulnerability exists.

### Citations

**File:** execution/executor-test-helpers/src/integration_test_impl.rs (L94-102)
```rust
    let block1_meta = Transaction::BlockMetadata(BlockMetadata::new(
        block1_id,
        1,
        0,
        signer.author(),
        vec![0],
        vec![],
        1,
    ));
```

**File:** execution/executor-test-helpers/src/integration_test_impl.rs (L154-162)
```rust
    let block2_meta = Transaction::BlockMetadata(BlockMetadata::new(
        block2_id,
        2,
        0,
        signer.author(),
        vec![0],
        vec![],
        2,
    ));
```

**File:** execution/executor-test-helpers/src/integration_test_impl.rs (L169-177)
```rust
    let block3_meta = Transaction::BlockMetadata(BlockMetadata::new(
        block3_id,
        2,
        1,
        signer.author(),
        vec![0],
        vec![],
        3,
    ));
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L154-199)
```text
    fun block_prologue_common(
        vm: &signer,
        hash: address,
        epoch: u64,
        round: u64,
        proposer: address,
        failed_proposer_indices: vector<u64>,
        previous_block_votes_bitvec: vector<u8>,
        timestamp: u64
    ): u64 acquires BlockResource, CommitHistory {
        // Operational constraint: can only be invoked by the VM.
        system_addresses::assert_vm(vm);

        // Blocks can only be produced by a valid proposer or by the VM itself for Nil blocks (no user txs).
        assert!(
            proposer == @vm_reserved || stake::is_current_epoch_validator(proposer),
            error::permission_denied(EINVALID_PROPOSER),
        );

        let proposer_index = option::none();
        if (proposer != @vm_reserved) {
            proposer_index = option::some(stake::get_validator_index(proposer));
        };

        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);
        block_metadata_ref.height = event::counter(&block_metadata_ref.new_block_events);

        let new_block_event = NewBlockEvent {
            hash,
            epoch,
            round,
            height: block_metadata_ref.height,
            previous_block_votes_bitvec,
            proposer,
            failed_proposer_indices,
            time_microseconds: timestamp,
        };
        emit_new_block_event(vm, &mut block_metadata_ref.new_block_events, new_block_event);

        // Performance scores have to be updated before the epoch transition as the transaction that triggers the
        // transition is the last block in the previous epoch.
        stake::update_performance_statistics(proposer_index, failed_proposer_indices);
        state_storage::on_new_block(reconfiguration::current_epoch());

        block_metadata_ref.epoch_interval
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L203-218)
```text
    fun block_prologue(
        vm: signer,
        hash: address,
        epoch: u64,
        round: u64,
        proposer: address,
        failed_proposer_indices: vector<u64>,
        previous_block_votes_bitvec: vector<u8>,
        timestamp: u64
    ) acquires BlockResource, CommitHistory {
        let epoch_interval = block_prologue_common(&vm, hash, epoch, round, proposer, failed_proposer_indices, previous_block_votes_bitvec, timestamp);
        randomness::on_new_block(&vm, epoch, round, option::none());
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1274-1278)
```text
    public fun is_current_epoch_validator(pool_address: address): bool acquires ValidatorSet {
        assert_stake_pool_exists(pool_address);
        let validator_state = get_validator_state(pool_address);
        validator_state == VALIDATOR_STATUS_ACTIVE || validator_state == VALIDATOR_STATUS_PENDING_INACTIVE
    }
```

**File:** aptos-move/framework/aptos-framework/sources/randomness.move (L64-72)
```text
    public(friend) fun on_new_block(vm: &signer, epoch: u64, round: u64, seed_for_new_block: Option<vector<u8>>) acquires PerBlockRandomness {
        system_addresses::assert_vm(vm);
        if (exists<PerBlockRandomness>(@aptos_framework)) {
            let randomness = borrow_global_mut<PerBlockRandomness>(@aptos_framework);
            randomness.epoch = epoch;
            randomness.round = round;
            randomness.seed = seed_for_new_block;
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2421-2467)
```rust
    fn process_block_prologue(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        block_metadata: BlockMetadata,
        log_context: &AdapterLogSchema,
    ) -> Result<(VMStatus, VMOutput), VMStatus> {
        fail_point!("move_adapter::process_block_prologue", |_| {
            Err(VMStatus::error(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                None,
            ))
        });

        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, SessionId::block_meta(&block_metadata), None);

        let args = serialize_values(
            &block_metadata.get_prologue_move_args(account_config::reserved_vm_address()),
        );

        let traversal_storage = TraversalStorage::new();
        let mut traversal_context = TraversalContext::new(&traversal_storage);

        session
            .execute_function_bypass_visibility(
                &BLOCK_MODULE,
                BLOCK_PROLOGUE,
                vec![],
                args,
                &mut gas_meter,
                &mut traversal_context,
                module_storage,
            )
            .map(|_return_vals| ())
            .or_else(|e| {
                expect_only_successful_execution(e, BLOCK_PROLOGUE.as_str(), log_context)
            })?;
        SYSTEM_TRANSACTIONS_EXECUTED.inc();

        let output = get_system_transaction_output(
            session,
            module_storage,
            &self.storage_gas_params(log_context)?.change_set_configs,
        )?;
        Ok((VMStatus::Executed, output))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L165-167)
```text
    public fun current_epoch(): u64 acquires Configuration {
        borrow_global<Configuration>(@aptos_framework).epoch
    }
```
