# Audit Report

## Title
Lazy Loading Allows Publishing Modules with Circular Dependencies, Violating Dependency Graph Integrity

## Summary
When lazy loading is enabled (default in Aptos), the module publishing system does not detect circular dependencies during the publishing phase. This allows modules with cyclic dependencies to be committed to the blockchain state, violating the fundamental invariant that the dependency graph must be acyclic. While execution of such modules is intended to be prevented, the ability to publish invalid dependency structures creates a potential attack surface for consensus violations and deterministic execution failures.

## Finding Description
The module publishing flow in Aptos has two modes: eager loading and lazy loading. When **lazy loading is enabled** (which is the default configuration), cyclic dependency detection is explicitly skipped during module publishing: [1](#0-0) 

The lazy loading flag is enabled by default in the feature flags: [2](#0-1) 

This behavior is confirmed by the test suite, which explicitly documents that with lazy loading enabled, cyclic dependencies can be published: [3](#0-2) 

**Attack Scenario:**

1. Attacker publishes Module A at address 0xAttacker with no dependencies
2. Attacker publishes Module B at address 0xAttacker that depends on Module A (valid dependency: B → A)
3. Attacker upgrades Module A to add a dependency on Module B, creating a cycle (A → B → A)
4. With lazy loading enabled, this upgrade passes all publishing checks because cyclic dependency verification is skipped
5. The blockchain now contains modules with circular dependencies, violating the acyclic dependency graph invariant

This breaks the **Deterministic Execution** critical invariant because:
- The dependency graph is no longer guaranteed to be acyclic across all nodes
- Different execution contexts or timing may lead to different handling of these modules
- Module loading order becomes ambiguous and potentially non-deterministic

## Impact Explanation
This vulnerability constitutes a **High Severity** issue under the Aptos bug bounty program for the following reasons:

1. **Protocol Invariant Violation**: The dependency graph acyclicity invariant is fundamental to the Move VM design. Allowing cyclic dependencies to exist in the published state violates this core assumption.

2. **Potential Consensus Impact**: While the system intends to prevent execution of cyclic modules, any inconsistency in how different validators handle these modules during execution could lead to consensus divergence. If one validator successfully detects the cycle during execution while another encounters an error in a different code path, they may produce different state roots for the same block.

3. **State Integrity**: The blockchain state contains structurally invalid modules that violate the dependency graph properties that other components may rely upon.

4. **Validator Node Impact**: Attempting to execute or analyze modules with circular dependencies could cause unexpected behavior, crashes, or resource exhaustion in validator nodes.

While this does not immediately lead to fund loss, it represents a **significant protocol violation** that undermines the integrity of the module publishing system and could facilitate other attacks.

## Likelihood Explanation
**Likelihood: High**

The likelihood of exploitation is high because:

1. **Default Configuration**: Lazy loading is enabled by default in production, making all Aptos networks vulnerable.

2. **Low Barrier to Entry**: Any account can publish and upgrade modules, requiring only:
   - Ability to publish packages (available to any funded account)
   - Knowledge of how to create module dependencies in Move code
   - Two transactions to set up the cycle (initial publish + upgrade)

3. **No Special Permissions Required**: The attack does not require validator access, governance privileges, or insider knowledge.

4. **Difficult to Detect**: Since the publishing transaction succeeds, the cyclic dependency may go unnoticed until attempted execution.

## Recommendation
Implement mandatory cyclic dependency detection during module publishing, regardless of lazy loading configuration. The check should occur before modules are committed to state.

**Proposed Fix** in `third_party/move/move-vm/runtime/src/storage/publishing.rs`:

Add cyclic dependency verification for lazy loading mode by calling the cyclic dependency check after linking verification:

```rust
if is_lazy_loading_enabled {
    // Local bytecode verification.
    // ... existing code ...
    
    // Linking checks to immediate dependencies
    let mut verified_dependencies = vec![];
    for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
        let dependency = staged_module_storage.unmetered_get_existing_lazily_verified_module(
            &ModuleId::new(*dep_addr, dep_name.to_owned()),
        )?;
        verified_dependencies.push(dependency);
    }
    staged_runtime_environment.build_verified_module_with_linking_checks(
        locally_verified_code,
        &verified_dependencies,
    )?;
    
    // ADD: Verify no cyclic dependencies even in lazy loading mode
    cyclic_dependencies::verify_module(
        compiled_module.as_ref(),
        |module_id| {
            // Closure to get immediate dependencies
            // This would need access to the staged storage to resolve dependencies
            Ok(staged_module_storage.get_module_dependencies(module_id)?)
        },
        |module_id| {
            // Closure to get immediate friends
            Ok(staged_module_storage.get_module_friends(module_id)?)
        }
    )?;
}
```

Alternatively, enforce eager loading for module publishing while keeping lazy loading for module execution:

```rust
// Always use eager verification during publishing to catch cycles
let module_verification_mode = false; // Force eager loading for publishing
```

## Proof of Concept

The existing test suite already demonstrates this vulnerability: [4](#0-3) 

**To exploit this in practice:**

1. Create a Move package with Module A (no dependencies)
2. Publish Module A
3. Create a Move package with Module B that depends on A
4. Publish Module B  
5. Upgrade Module A to add `use` statement importing Module B
6. Publish the upgraded Module A

With lazy loading enabled (default), step 6 will succeed, creating a circular dependency A → B → A in the published blockchain state.

**Notes:**
The system is designed to prevent **execution** of modules with circular dependencies, but the fact that they can be **published** violates the dependency graph invariant. This creates a gap between the published state (which can contain cycles) and the execution guarantees (which should reject cycles). Any inconsistency in how this gap is handled across different validators or execution contexts could lead to consensus divergence, making this a valid security concern despite the intended runtime protections.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L259-260)
```rust
                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```

**File:** third_party/move/move-vm/integration-tests/src/tests/module_storage_tests.rs (L217-240)
```rust
fn test_cyclic_dependencies(enable_lazy_loading: bool) {
    let mut module_bytes_storage = in_memory_storage(enable_lazy_loading);

    let c_id = ModuleId::new(AccountAddress::ZERO, Identifier::new("c").unwrap());

    add_module_bytes(&mut module_bytes_storage, "a", vec!["b"], vec![]);
    add_module_bytes(&mut module_bytes_storage, "b", vec!["c"], vec![]);
    add_module_bytes(&mut module_bytes_storage, "c", vec!["a"], vec![]);

    let module_storage = module_bytes_storage.into_unsync_module_storage();

    if enable_lazy_loading {
        // With lazy loading, cyclic dependencies are allowed to be published (but not called).
        assert_ok!(module_storage.unmetered_get_lazily_verified_module(&c_id));
        module_storage.assert_cached_state(vec![], vec![&c_id]);
    } else {
        let result =
            module_storage.unmetered_get_eagerly_verified_module(c_id.address(), c_id.name());
        assert_eq!(
            assert_err!(result).major_status(),
            StatusCode::CYCLIC_MODULE_DEPENDENCY
        );
    }
}
```
