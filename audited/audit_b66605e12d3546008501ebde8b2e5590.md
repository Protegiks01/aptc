# Audit Report

## Title
Missing Validation for Groth16 Verification Key Components Allows Identity Element in delta_g2

## Summary
The `validate_groth16_vk` function exists but is never called when setting the Groth16 verification key on-chain, and even if called, it does not check for non-trivial values (identity element) in VK components including `delta_g2`. This allows a malicious governance proposal to set a cryptographically invalid verification key with `delta_g2` as the point at infinity, which would break the Groth16 verification equation and potentially enable authentication bypass in keyless accounts.

## Finding Description

The Aptos keyless authentication system relies on Groth16 zero-knowledge proofs verified using an on-chain verification key. This verification key contains several BN254 elliptic curve points including `delta_g2`.

**Issue 1: Validation Function Never Called**

A validation function `validate_groth16_vk` is defined but never invoked: [1](#0-0) 

However, this function is not called in either VK setting function: [2](#0-1) [3](#0-2) 

**Issue 2: No Check for Non-Trivial Values**

Even if `validate_groth16_vk` were called, it only validates that points can be deserialized (curve membership and subgroup membership), but does NOT check if points are non-trivial (not the identity element). The BN254 deserialization procedure explicitly allows the point at infinity: [4](#0-3) 

Test code confirms identity elements are valid deserializable values: [5](#0-4) 

**Cryptographic Impact**

In Groth16 verification, the equation is:
```
e(A, B) = e(alpha, beta) * e(C, delta) * e(gamma_abc_sum, gamma)
```

If `delta_g2` is the identity element (point at infinity), then `e(C, delta_g2) = 1` (identity in the target group Gt). This fundamentally breaks the verification equation, as the pairing with `delta_g2` contributes nothing to verification. An attacker could potentially craft malicious proofs that bypass authentication by exploiting this weakened verification equation.

**Attack Vector**

A malicious actor could submit a governance proposal to change the verification key: [6](#0-5) 

The warning comment acknowledges the risk but no validation prevents it.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact criteria:

1. **Loss of Funds**: If a malicious VK is set with `delta_g2` as the identity element, attackers could potentially forge Groth16 proofs to authenticate as arbitrary keyless accounts, leading to theft of funds from those accounts.

2. **Consensus Safety Violation**: All validators would accept the invalid VK and process transactions with malformed proofs identically, but the cryptographic security guarantees would be completely broken.

3. **Cryptographic Correctness Invariant Broken**: The system explicitly requires that "BLS signatures, VRF, and hash operations must be secure." A malformed Groth16 VK violates cryptographic correctness.

The comment at line 262 explicitly states "If a malicious key is set, this would lead to stolen funds," acknowledging the critical nature of this attack surface.

## Likelihood Explanation

**Likelihood: Medium-High**

- Requires a successful governance proposal to pass, which has governance safeguards
- However, if governance is compromised or if validators don't understand the cryptographic implications, the attack is straightforward
- No technical barriers exist to prevent setting an invalid VK
- The validation function exists but is simply not called - this appears to be an implementation oversight rather than an intentional design choice
- Social engineering could convince governance participants that a "VK update" is legitimate

## Recommendation

**Fix 1: Call Validation Function**

Modify both VK setting functions to call `validate_groth16_vk`:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}

public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk);  // ADD THIS LINE
    move_to(fx, vk);
}
```

**Fix 2: Add Non-Trivial Value Checks**

Enhance `validate_groth16_vk` to explicitly reject identity elements:

```move
fun validate_groth16_vk(vk: &Groth16VerificationKey) {
    // Existing deserialize checks...
    assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
    
    // NEW: Check alpha_g1 is not identity
    let alpha_g1_elem = option::extract(&mut crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1));
    assert!(!crypto_algebra::eq(&alpha_g1_elem, &crypto_algebra::zero<bn254_algebra::G1>()), E_IDENTITY_ELEMENT_NOT_ALLOWED);
    
    // Similar checks for beta_g2, gamma_g2, delta_g2, and gamma_abc_g1 elements...
}
```

Add new error code:
```move
const E_IDENTITY_ELEMENT_NOT_ALLOWED: u64 = 4;
```

## Proof of Concept

**Step 1: Create Malicious VK with Identity delta_g2**

```move
#[test(fx = @aptos_framework)]
fun test_malicious_vk_with_identity_delta_g2(fx: &signer) {
    use aptos_framework::keyless_account;
    
    // Valid components for other fields (example values)
    let alpha_g1 = x"0100000000000000000000000000000000000000000000000000000000000000";
    let beta_g2 = x"edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e19";
    let gamma_g2 = x"edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e19";
    
    // MALICIOUS: delta_g2 set to identity element (point at infinity)
    let delta_g2 = x"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040";
    
    let gamma_abc_g1 = vector[
        x"0100000000000000000000000000000000000000000000000000000000000000",
        x"0100000000000000000000000000000000000000000000000000000000000000"
    ];
    
    // Create malicious VK
    let malicious_vk = keyless_account::new_groth16_verification_key(
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,  // Identity element!
        gamma_abc_g1
    );
    
    // This should FAIL but currently SUCCEEDS
    keyless_account::set_groth16_verification_key_for_next_epoch(fx, malicious_vk);
    
    // VK is now set with invalid delta_g2, breaking Groth16 security
}
```

**Step 2: Verify Deserialization Allows Identity**

The identity element successfully deserializes as shown in existing tests: [7](#0-6) 

This confirms that the current validation (if it were called) would not reject the identity element in `delta_g2`.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L198-203)
```text
    public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        chain_status::assert_genesis();
        // There should not be a previous resource set here.
        move_to(fx, vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L262-262)
```text
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bn254_algebra.move (L206-207)
```text
    /// 1. Compute the infinity flag as `b[N-1] & 0b0100_0000 != 0`.
    /// 1. If the infinity flag is set, return the point at infinity.
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bn254_algebra.move (L454-456)
```text
    const G2_INF_SERIALIZED_COMP: vector<u8> = x"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040";
    #[test_only]
    const G2_INF_SERIALIZED_UNCOMP: vector<u8> = x"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040";
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bn254_algebra.move (L490-493)
```text
        let inf_from_uncomp = deserialize<G2, FormatG2Uncompr>(&G2_INF_SERIALIZED_UNCOMP).extract();
        let inf_from_comp = deserialize<G2, FormatG2Compr>(&G2_INF_SERIALIZED_COMP).extract();
        assert!(eq(&point_at_infinity, &inf_from_comp), 1);
        assert!(eq(&point_at_infinity, &inf_from_uncomp), 1);
```
