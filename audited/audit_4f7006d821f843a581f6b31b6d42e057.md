# Audit Report

## Title
Encapsulation Violation: External Crates Can Directly Manipulate Quorum Store Database Through Public API Leak

## Summary
The `pub(crate)` visibility modifiers in the quorum_store module are not properly enforced. While `QuorumStoreDB::new()` is correctly marked as `pub(crate)`, the public function `start_consensus()` returns `Arc<QuorumStoreDB>`, leaking instances to external crates. This allows external crates to call public trait methods from `QuorumStoreStorage`, including write operations like `save_batch()` and `delete_batches()`, bypassing all internal consensus validation logic.

## Finding Description

The quorum store module attempts to enforce encapsulation by marking internal components as `pub(crate)`: [1](#0-0) 

The `QuorumStoreDB` struct has a `pub(crate)` constructor to prevent external instantiation: [2](#0-1) 

However, this encapsulation is completely bypassed by the public `start_consensus()` function which returns `Arc<QuorumStoreDB>`: [3](#0-2) 

External crates like `aptos-node` receive this reference: [4](#0-3) 

And `aptos-admin-service` stores and uses it: [5](#0-4) 

Since `QuorumStoreDB` implements the public `QuorumStoreStorage` trait, external crates can call all trait methods: [6](#0-5) 

This includes dangerous write operations like `save_batch()` and `delete_batches()`: [7](#0-6) 

**Attack Path:** A malicious external crate (or compromised dependency) with access to the `Arc<QuorumStoreDB>` can:
1. Call `save_batch()` to inject malicious batches with forged digests and payloads
2. Call `delete_batches()` to remove legitimate batches before they're processed
3. Call `save_batch_id()` to corrupt epoch-to-batch-id mapping
4. Cause consensus nodes to diverge by creating inconsistent quorum store state

## Impact Explanation

**Severity: Medium (up to $10,000)**

This breaks the **State Consistency** invariant: state transitions must be atomic and verifiable. By allowing direct database manipulation outside the coordinated consensus flow, different nodes could end up with inconsistent quorum store states.

Potential impacts:
- **State inconsistencies requiring intervention**: Nodes may disagree on which batches exist, causing consensus failures
- **Consensus liveness issues**: Invalid or missing batches could prevent block formation
- **Database corruption**: Arbitrary writes could corrupt the batch storage schema

This does not directly cause loss of funds or consensus safety violations under the Byzantine fault model, as it requires code execution within a node process (supply chain attack or compromised operator), placing it in the Medium severity category rather than Critical.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable if:
1. An attacker compromises a dependency used by `aptos-node` or `aptos-admin-service` (supply chain attack)
2. An attacker finds a separate code injection vulnerability in these crates
3. A malicious node operator deliberately exploits this access

While requiring code execution within the node process raises the bar, supply chain attacks against blockchain nodes are increasingly common. The fact that the `Arc<QuorumStoreDB>` is explicitly stored in admin service contexts increases the attack surface.

## Recommendation

**Fix 1: Make QuorumStoreDB internal-only by removing it from public return types**

Change `start_consensus()` to NOT return `Arc<QuorumStoreDB>`:

```rust
pub fn start_consensus(
    // ... parameters ...
) -> (Runtime, Arc<StorageWriteProxy>) {  // Remove Arc<QuorumStoreDB>
    let runtime = aptos_runtimes::spawn_named_runtime("consensus".into(), None);
    let storage = Arc::new(StorageWriteProxy::new(node_config, aptos_db.reader.clone()));
    let quorum_store_db = Arc::new(QuorumStoreDB::new(node_config.storage.dir()));
    // ... use quorum_store_db internally but don't return it ...
}
```

**Fix 2: If external access is needed for admin/debugging, create a read-only trait**

```rust
pub trait QuorumStoreReader: Sync + Send {
    fn get_batch(&self, digest: &HashValue) -> Result<Option<PersistedValue<BatchInfo>>, DbError>;
    fn get_all_batches(&self) -> Result<HashMap<HashValue, PersistedValue<BatchInfo>>>;
    // Only read operations, no save_batch or delete_batches
}
```

Return `Arc<dyn QuorumStoreReader>` instead of `Arc<QuorumStoreDB>`.

**Fix 3: Alternatively, make QuorumStoreDB struct itself pub(crate)**

```rust
pub(crate) struct QuorumStoreDB {  // Change from pub to pub(crate)
    db: DB,
}
```

This would prevent compilation of external code that tries to accept `Arc<QuorumStoreDB>`.

## Proof of Concept

This vulnerability can be demonstrated by creating a malicious external crate that receives the `Arc<QuorumStoreDB>` and manipulates it:

```rust
// In a hypothetical malicious crate or compromised dependency
use aptos_consensus::quorum_store::quorum_store_db::{QuorumStoreDB, QuorumStoreStorage};
use aptos_consensus::quorum_store::types::PersistedValue;
use aptos_consensus_types::proof_of_store::BatchInfo;
use std::sync::Arc;

fn exploit_quorum_store_access(db: Arc<QuorumStoreDB>) {
    // Create a malicious batch with forged digest
    let malicious_batch = create_fake_batch();
    
    // Directly write to database, bypassing consensus validation
    db.save_batch(malicious_batch).expect("Should save");
    
    // Delete legitimate batches
    let digests_to_delete = vec![/* legitimate batch digests */];
    db.delete_batches(digests_to_delete).expect("Should delete");
    
    // Result: Quorum store state is now corrupted
}
```

The compilation succeeds because all required types (`QuorumStoreDB`, `QuorumStoreStorage` trait, `PersistedValue`) are public and accessible from external crates, despite the intent to keep them internal as indicated by the `pub(crate)` constructor.

---

**Notes:**

This vulnerability represents an **encapsulation violation** where the intended module boundaries are not properly enforced. While the `pub(crate)` visibility on the constructor suggests internal-only usage, returning the type from a public function defeats this protection. External crates currently have full write access to the quorum store database, which should be strictly controlled by internal consensus logic.

### Citations

**File:** consensus/src/quorum_store/mod.rs (L8-21)
```rust
pub(crate) mod batch_coordinator;
pub(crate) mod batch_generator;
pub(crate) mod batch_proof_queue;
pub(crate) mod batch_requester;
pub(crate) mod batch_store;
pub(crate) mod network_listener;
pub(crate) mod proof_coordinator;
pub(crate) mod proof_manager;
pub(crate) mod quorum_store_builder;
pub(crate) mod quorum_store_coordinator;
pub mod quorum_store_db;
pub(crate) mod tracing;
pub mod types;
pub(crate) mod utils;
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L26-51)
```rust
pub trait QuorumStoreStorage: Sync + Send {
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError>;

    fn get_all_batches(&self) -> Result<HashMap<HashValue, PersistedValue<BatchInfo>>>;

    fn save_batch(&self, batch: PersistedValue<BatchInfo>) -> Result<(), DbError>;

    fn get_batch(&self, digest: &HashValue) -> Result<Option<PersistedValue<BatchInfo>>, DbError>;

    fn delete_batches_v2(&self, digests: Vec<HashValue>) -> Result<(), DbError>;

    fn get_all_batches_v2(&self) -> Result<HashMap<HashValue, PersistedValue<BatchInfoExt>>>;

    fn save_batch_v2(&self, batch: PersistedValue<BatchInfoExt>) -> Result<(), DbError>;

    fn get_batch_v2(
        &self,
        digest: &HashValue,
    ) -> Result<Option<PersistedValue<BatchInfoExt>>, DbError>;

    fn delete_batch_id(&self, epoch: u64) -> Result<(), DbError>;

    fn clean_and_get_batch_id(&self, current_epoch: u64) -> Result<Option<BatchId>, DbError>;

    fn save_batch_id(&self, epoch: u64, batch_id: BatchId) -> Result<(), DbError>;
}
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L56-61)
```rust
pub struct QuorumStoreDB {
    db: DB,
}

impl QuorumStoreDB {
    pub(crate) fn new<P: AsRef<Path> + Clone>(db_root_path: P) -> Self {
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L92-121)
```rust
impl QuorumStoreStorage for QuorumStoreDB {
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchSchema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }

    fn get_all_batches(&self) -> Result<HashMap<HashValue, PersistedValue<BatchInfo>>> {
        let mut iter = self.db.iter::<BatchSchema>()?;
        iter.seek_to_first();
        iter.map(|res| res.map_err(Into::into))
            .collect::<Result<HashMap<HashValue, PersistedValue<BatchInfo>>>>()
    }

    fn save_batch(&self, batch: PersistedValue<BatchInfo>) -> Result<(), DbError> {
        trace!(
            "QS: db persists digest {} expiration {:?}",
            batch.digest(),
            batch.expiration()
        );
        self.put::<BatchSchema>(batch.digest(), &batch)
    }

    fn get_batch(&self, digest: &HashValue) -> Result<Option<PersistedValue<BatchInfo>>, DbError> {
        Ok(self.db.get::<BatchSchema>(digest)?)
    }
```

**File:** consensus/src/consensus_provider.rs (L45-58)
```rust
pub fn start_consensus(
    node_config: &NodeConfig,
    network_client: NetworkClient<ConsensusMsg>,
    network_service_events: NetworkServiceEvents<ConsensusMsg>,
    state_sync_notifier: Arc<dyn ConsensusNotificationSender>,
    consensus_to_mempool_sender: mpsc::Sender<QuorumStoreRequest>,
    aptos_db: DbReaderWriter,
    reconfig_events: ReconfigNotificationListener<DbBackedOnChainConfig>,
    vtxn_pool: VTxnPoolState,
    consensus_publisher: Option<Arc<ConsensusPublisher>>,
) -> (Runtime, Arc<StorageWriteProxy>, Arc<QuorumStoreDB>) {
    let runtime = aptos_runtimes::spawn_named_runtime("consensus".into(), None);
    let storage = Arc::new(StorageWriteProxy::new(node_config, aptos_db.reader.clone()));
    let quorum_store_db = Arc::new(QuorumStoreDB::new(node_config.storage.dir()));
```

**File:** aptos-node/src/services.rs (L152-171)
```rust
) -> (Runtime, Arc<StorageWriteProxy>, Arc<QuorumStoreDB>) {
    let instant = Instant::now();

    let reconfig_subscription = consensus_reconfig_subscription
        .expect("Consensus requires a reconfiguration subscription!");

    let consensus = aptos_consensus::consensus_provider::start_consensus(
        node_config,
        consensus_network_interfaces.network_client,
        consensus_network_interfaces.network_service_events,
        Arc::new(consensus_notifier),
        consensus_to_mempool_sender,
        db_rw,
        reconfig_subscription,
        vtxn_pool,
        consensus_publisher,
    );
    debug!("Consensus started in {} ms", instant.elapsed().as_millis());

    consensus
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L50-56)
```rust
        &self,
        consensus_db: Arc<StorageWriteProxy>,
        quorum_store_db: Arc<QuorumStoreDB>,
    ) {
        *self.consensus_db.write() = Some(consensus_db);
        *self.quorum_store_db.write() = Some(quorum_store_db);
    }
```
