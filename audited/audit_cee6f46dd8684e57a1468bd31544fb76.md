# Audit Report

## Title
Mempool Configuration Allows Premature Transaction Expiration Through Inverted Timing Parameters

## Summary
When `eager_expire_time_ms` is configured to be greater than `eager_expire_threshold_ms`, the mempool's eager expiration mechanism can prematurely expire valid transactions during backlog periods. This configuration error lacks validation and can be exploited by attackers to cause transaction drops through mempool spam.

## Finding Description

The mempool uses two timing parameters for eager expiration during backlog conditions: [1](#0-0) 

The default values are semantically correct: `eager_expire_threshold_ms = 15,000` (15 seconds) and `eager_expire_time_ms = 6,000` (6 seconds). However, there is no validation preventing operators from configuring these values inversely. [2](#0-1) 

The eager expiration logic operates as follows: [3](#0-2) 

When backlog is detected (oldest transaction age exceeds `eager_expire_threshold`), the system adds `eager_expire_time` to the garbage collection time. This makes the GC "pretend" time has moved forward, causing more aggressive transaction expiration.

**Attack Scenario:**
1. Operator misconfigures: `eager_expire_time_ms = 700,000` (11.7 minutes), `eager_expire_threshold_ms = 15,000` (15 seconds)
2. User submits valid transactions with 11-minute expiration timestamps
3. Attacker spams low-fee transactions to create 16-second backlog
4. Eager expiration triggers, adding 700 seconds to GC time
5. Valid user transactions are expired prematurely (11 minutes early vs 6 seconds in correct config)
6. Users must resubmit, causing poor UX and potential DoS

This violates the semantic contract that transactions remain valid until their specified expiration timestamp.

## Impact Explanation

This is a **Low Severity** issue per Aptos bug bounty criteria ("Non-critical implementation bugs"):

- **No consensus violations**: Mempool state doesn't affect consensus safety
- **No fund theft**: Transactions are dropped, not stolen
- **Availability impact**: Legitimate transactions get dropped during backlog periods
- **Configuration-dependent**: Requires operator misconfiguration to be exploitable
- **Recoverable**: Users can resubmit transactions; no permanent state corruption
- **Mempool-local**: Impact limited to individual node's transaction pool

The issue does not meet Critical, High, or Medium severity thresholds as it doesn't cause fund loss, consensus breaks, or require hardfork intervention.

## Likelihood Explanation

**Moderate likelihood** for several reasons:

1. **Configuration simplicity**: The relationship between these parameters is non-obvious
2. **No validation**: The sanitizer contains a TODO comment indicating missing verification
3. **Exploitation requirement**: Attacker must create mempool backlog (achievable via transaction spam)
4. **Operator dependency**: Requires misconfiguration, limiting widespread impact
5. **Bounded damage**: Impact is temporary transaction drops, not permanent system compromise

The lack of configuration validation makes accidental misconfiguration possible, especially for operators tuning performance parameters without full understanding of the eager expiration semantics.

## Recommendation

Add configuration validation in the `ConfigSanitizer::sanitize` method:

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let mempool = &node_config.mempool;
        
        // Validate eager expiration timing parameters
        if let Some(threshold) = mempool.eager_expire_threshold_ms {
            if mempool.eager_expire_time_ms > threshold {
                return Err(Error::ConfigError(format!(
                    "eager_expire_time_ms ({}) must not exceed eager_expire_threshold_ms ({}). \
                     The eager expire time should be smaller to trigger progressive expiration during backlog, \
                     not aggressive clearing of valid transactions.",
                    mempool.eager_expire_time_ms, threshold
                )));
            }
            
            // Ensure eager_expire_time is reasonable (not larger than system timeout)
            let max_reasonable_eager_time = mempool.system_transaction_timeout_secs * 1000 / 2;
            if mempool.eager_expire_time_ms > max_reasonable_eager_time {
                return Err(Error::ConfigError(format!(
                    "eager_expire_time_ms ({}) exceeds safe limit ({}ms, half of system_transaction_timeout_secs). \
                     Large values can cause excessive transaction expiration.",
                    mempool.eager_expire_time_ms, max_reasonable_eager_time
                )));
            }
        }
        
        Ok(())
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_inverted_eager_expiration_timing() {
    use aptos_config::config::{MempoolConfig, NodeConfig};
    use std::time::Duration;
    
    // Create config with inverted timing parameters
    let mut config = NodeConfig::default();
    config.mempool.eager_expire_threshold_ms = Some(15_000); // 15 seconds
    config.mempool.eager_expire_time_ms = 700_000; // 700 seconds (~11.7 minutes)
    
    let mut mempool = CoreMempool::new(&config);
    
    // Add transaction with 11-minute expiration
    let txn = TestTransaction::new(
        1, 
        ReplayProtector::SequenceNumber(0),
        Duration::from_secs(660).as_secs() // 11 minutes
    );
    mempool.add_txn(txn, 0, TimelineState::NotReady, true, None);
    
    // Simulate 16-second old transaction (triggers backlog detection)
    std::thread::sleep(Duration::from_secs(16));
    
    // Trigger GC with current time
    let current_time = aptos_infallible::duration_since_epoch();
    mempool.gc_by_expiration_time(current_time);
    
    // Transaction should still exist with correct config (6s eager time)
    // but gets expired with inverted config (700s eager time)
    // Verify transaction was prematurely expired
    assert_eq!(mempool.get_by_hash(&txn.committed_hash()), None, 
               "Transaction was incorrectly expired due to inverted timing configuration");
}
```

## Notes

This finding validates the security question's premise: `eager_expire_time_ms > eager_expire_threshold_ms` **does** cause logical inconsistencies in expiration timing. The severity is appropriately classified as Low since it requires operator misconfiguration and causes availability issues rather than critical security failures. The missing validation in the configuration sanitizer (line 182 TODO comment) enables this misconfiguration to occur silently.

### Citations

**File:** config/src/config/mempool_config.rs (L88-89)
```rust
    pub eager_expire_threshold_ms: Option<u64>,
    pub eager_expire_time_ms: u64,
```

**File:** config/src/config/mempool_config.rs (L176-184)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L874-901)
```rust
    fn eager_expire_time(&self, gc_time: Duration) -> Duration {
        let eager_expire_threshold = match self.eager_expire_threshold {
            None => {
                return gc_time;
            },
            Some(v) => v,
        };

        let mut oldest_insertion_time = None;
        // Limit the worst-case linear search to 20.
        for key in self.system_ttl_index.iter().take(20) {
            if let Some(txn) = self.get_mempool_txn(&key.address, key.replay_protector) {
                if !txn.was_parked {
                    oldest_insertion_time = Some(txn.insertion_info.insertion_time);
                    break;
                }
            }
        }
        if let Some(insertion_time) = oldest_insertion_time {
            if let Ok(age) = SystemTime::now().duration_since(insertion_time) {
                if age > eager_expire_threshold {
                    counters::CORE_MEMPOOL_GC_EAGER_EXPIRE_EVENT_COUNT.inc();
                    return gc_time.saturating_add(self.eager_expire_time);
                }
            }
        }
        gc_time
    }
```
