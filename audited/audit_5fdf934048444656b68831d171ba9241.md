# Audit Report

## Title
Missing Gas Schedule Validation Allows Network-Wide Denial of Service via Malformed Governance Proposal

## Summary
The `GasScheduleV2` update mechanism in the Aptos Framework lacks validation of gas parameter completeness and correctness. A governance proposal can submit a malformed gas schedule with missing required parameters, passing on-chain validation but causing all validators to fail transaction execution, resulting in complete network halt requiring emergency hardfork recovery.

## Finding Description

The `current_gas_schedule()` function constructs a `GasScheduleV2` without validation of state transitions or parameter completeness. [1](#0-0) 

When this gas schedule is submitted via governance proposal, the on-chain Move validation in `set_for_next_epoch()` and `set_for_next_epoch_check_hash()` only checks that the feature version is greater than or equal to the current version: [2](#0-1) [3](#0-2) 

Critically, there are explicit TODO comments in the code acknowledging this missing validation: [4](#0-3) [5](#0-4) [6](#0-5) 

When the malformed gas schedule is applied at epoch transition via `on_new_epoch()`, it is stored on-chain without validation: [7](#0-6) 

Subsequently, when validators attempt to execute transactions, they load the gas schedule using `from_on_chain_gas_schedule()`, which requires all parameters to exist: [8](#0-7) 

Missing parameters cause an error return, which propagates through the environment initialization: [9](#0-8) 

The error is stored in the environment as a `Result::Err`: [10](#0-9) 

When transactions attempt execution, the error is converted to `VM_STARTUP_FAILURE`: [11](#0-10) 

**Attack Flow:**
1. Attacker crafts governance proposal with `GasScheduleV2` containing `feature_version = current + 1` but missing required parameters for that version (e.g., omitting `storage_io_per_state_slot_read` when upgrading to feature version 10+)
2. Proposal passes Move validation (only checks `feature_version >= old_version`)
3. Governance votes approve and execute the proposal
4. At next epoch boundary, `on_new_epoch()` applies the malformed gas schedule
5. All validators load the new environment, `gas_params` returns `Err`
6. Every transaction execution calls `gas_params()` which returns `VM_STARTUP_FAILURE`
7. **Complete network halt** - no transactions can execute

## Impact Explanation

**Severity: Critical** - Total loss of liveness/network availability requiring hardfork

This vulnerability allows an attacker with governance proposal access to completely halt the Aptos blockchain by submitting a malformed gas schedule. Once applied:

- **All user transactions fail** with `VM_STARTUP_FAILURE` status code
- **No recovery via normal governance** - governance transactions also fail
- **Requires emergency hardfork** - validators must coordinate offline to apply a write set transaction bypassing normal execution
- **Consensus is not directly broken** but the blockchain becomes non-functional as no state transitions can occur
- **Deterministic execution invariant is violated** - all validators consistently fail but the network cannot progress

This meets the Critical severity criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium-High**

While this requires a governance proposal to be approved, the attack has several characteristics making it realistic:

1. **No technical barriers** - Any participant can submit governance proposals with arbitrary gas schedules
2. **Passes validation** - The malformed schedule passes all on-chain Move validation checks
3. **Non-obvious** - The malformation isn't immediately apparent; it only manifests after epoch transition when validators attempt to load the gas parameters
4. **Could be accidental** - Even a well-intentioned but incorrect gas schedule update could trigger this (not just malicious actors)
5. **Testing gaps** - The lack of validation suggests this scenario may not be tested in proposal simulations

The primary barrier is obtaining governance approval, but given that the malformed schedule appears syntactically valid, it could slip through review, especially in a complex multi-parameter update.

## Recommendation

Implement comprehensive gas schedule validation in the Move code before accepting any gas schedule updates:

**Required Validations:**

1. **Parse validation** - Verify the gas schedule can be successfully parsed by calling into a native function that attempts `from_on_chain_gas_schedule()`
2. **Completeness check** - Ensure all required parameters exist for the claimed `feature_version`
3. **Range validation** - Verify parameters are within reasonable bounds (not zero unless explicitly allowed, not exceeding safety thresholds)
4. **Consistency check** - Validate relationships between parameters (e.g., `min_price_per_gas_unit <= max_price_per_gas_unit`)

**Proposed Fix in gas_schedule.move:**

Add a native function:
```move
native fun validate_gas_schedule_v2(gas_schedule_blob: vector<u8>): bool;
```

Then update validation in `set_for_next_epoch()` and `set_for_next_epoch_check_hash()`: [2](#0-1) 

Replace the TODO with actual validation:
```move
let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
assert!(validate_gas_schedule_v2(gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
```

Implement the native function in Rust to call `AptosGasParameters::from_on_chain_gas_schedule()` and return false if it returns `Err`.

## Proof of Concept

```rust
#[test]
fn test_incomplete_gas_schedule_causes_network_halt() {
    use aptos_types::on_chain_config::GasScheduleV2;
    use aptos_gas_schedule::LATEST_GAS_FEATURE_VERSION;
    
    let mut harness = MoveHarness::new();
    
    // Create a malformed gas schedule with higher feature version but missing required params
    let malformed_gas_schedule = GasScheduleV2 {
        feature_version: LATEST_GAS_FEATURE_VERSION + 1,
        entries: vec![
            // Intentionally missing critical parameters that would be required
            // for this feature version, such as storage_io_per_state_slot_read
            (String::from("instr.nop"), 1),
        ],
    };
    
    // This should fail but currently passes - only checks feature_version
    let result = harness.executor.exec(
        "gas_schedule",
        "set_for_next_epoch",
        vec![],
        vec![
            MoveValue::Signer(CORE_CODE_ADDRESS).simple_serialize().unwrap(),
            bcs::to_bytes(&bcs::to_bytes(&malformed_gas_schedule).unwrap()).unwrap(),
        ],
    );
    
    // Proposal execution succeeds (incorrectly)
    assert!(result.success);
    
    // Apply the gas schedule at epoch transition
    harness.executor.exec(
        "reconfiguration_with_dkg",
        "finish",
        vec![],
        vec![MoveValue::Signer(CORE_CODE_ADDRESS).simple_serialize().unwrap()],
    );
    
    // Attempt to execute any transaction - should fail with VM_STARTUP_FAILURE
    let user_txn_result = harness.run_transaction_payload(
        &harness.new_account_at(AccountAddress::random()),
        aptos_stdlib::aptos_coin_transfer(AccountAddress::random(), 1),
    );
    
    // All transactions now fail - network is halted
    assert!(matches!(
        user_txn_result.status(),
        TransactionStatus::Discard(VMStatus { status_code: StatusCode::VM_STARTUP_FAILURE, .. })
    ));
}
```

## Notes

The vulnerability is explicitly acknowledged in the codebase via TODO comments but remains unaddressed. The three TODO comments at lines 47, 67, and 75 of `gas_schedule.move` state "check if gas schedule is consistent", indicating the developers were aware of this validation gap.

The current gas schedule proposal generation in `aptos-release-builder` includes hash verification to prevent race conditions but does not validate parameter completeness, as evidenced by the generation logic that simply serializes the gas schedule without validation: [12](#0-11) 

This vulnerability affects all Aptos networks (mainnet, testnet, devnet) and could be triggered accidentally during legitimate gas schedule updates or maliciously to halt the network.

### Citations

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L116-121)
```rust
pub fn current_gas_schedule(feature_version: u64) -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(feature_version),
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-68)
```text
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-76)
```text
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L108-132)
```text
    public fun set_for_next_epoch_check_hash(
        aptos_framework: &signer,
        old_gas_schedule_hash: vector<u8>,
        new_gas_schedule_blob: vector<u8>
    ) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&new_gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        let new_gas_schedule: GasScheduleV2 = from_bytes(new_gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
            let cur_gas_schedule_bytes = bcs::to_bytes(cur_gas_schedule);
            let cur_gas_schedule_hash = aptos_hash::sha3_512(cur_gas_schedule_bytes);
            assert!(
                cur_gas_schedule_hash == old_gas_schedule_hash,
                error::invalid_argument(EINVALID_GAS_SCHEDULE_HASH)
            );
        };

        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L183-188)
```rust
    /// Gas parameters used in this environment. Error is stored if gas parameters were not found
    /// on-chain.
    gas_params: Result<AptosGasParameters, String>,
    /// Storage gas parameters used in this environment. Error is stored if gas parameters were not
    /// found on-chain.
    storage_gas_params: Result<StorageGasParameters, String>,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L122-150)
```rust
        &["aptos_framework::gas_schedule"],
        |writer| {
            let gas_schedule_blob = bcs::to_bytes(new_gas_schedule).unwrap();
            assert!(gas_schedule_blob.len() < 65536);

            emit!(writer, "let gas_schedule_blob: vector<u8> = ");
            generate_blob_as_hex_string(writer, &gas_schedule_blob);
            emitln!(writer, ";");
            emitln!(writer);

            match old_hash {
                Some(old_hash) => {
                    emitln!(
                        writer,
                        "gas_schedule::set_for_next_epoch_check_hash({}, x\"{}\", gas_schedule_blob);",
                        signer_arg,
                        old_hash,
                    );
                },
                None => {
                    emitln!(
                        writer,
                        "gas_schedule::set_for_next_epoch({}, gas_schedule_blob);",
                        signer_arg
                    );
                },
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
```
