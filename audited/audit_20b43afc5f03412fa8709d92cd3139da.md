# Audit Report

## Title
Gas-Based Transaction Ordering Enables MEV Front-Running in Mempool

## Summary
The Aptos mempool uses `gas_unit_price` as the primary criterion for transaction ordering, allowing attackers to manipulate transaction priority by setting higher gas prices. This design enables Miner Extractable Value (MEV) attacks, including front-running of DeFi trades, NFT purchases, and liquidations.

## Finding Description

The vulnerability exists in how transactions flow through the system:

**1. Transaction Validation & Scoring**
When transactions pass validation, the ranking score is set to the transaction's gas_unit_price: [1](#0-0) 

**2. Mempool Priority Ordering**
The mempool explicitly documents gas-based prioritization: [2](#0-1) 

Transactions are stored in a `PriorityIndex` (BTreeSet) where the ordering is defined by `OrderedQueueKey`: [3](#0-2) 

The `Ord` implementation explicitly prioritizes higher gas prices: [4](#0-3) 

**3. Consensus Transaction Pulling**
When consensus requests transactions via `get_batch()`, it iterates through the priority queue: [5](#0-4) 

The transaction store's `iter_queue()` directly uses the priority index: [6](#0-5) 

**4. Gas Price Bounds**
The system enforces minimum and maximum gas prices: [7](#0-6) 

With configuration values: [8](#0-7) 

This provides a range from 100 to 10,000,000,000 Octas for gas price manipulation.

**Attack Scenario:**
1. Attacker monitors mempool or observes pending transactions
2. Attacker identifies profitable opportunity (e.g., large DEX trade at price X)
3. Attacker submits competing transaction with `gas_unit_price` higher than victim's
4. Attacker's transaction gets priority in mempool's `PriorityIndex`
5. Consensus pulls attacker's transaction first via `get_batch()`
6. Attacker executes front-running attack (e.g., buy before victim, sell after)

## Impact Explanation

This qualifies as **Medium Severity** under Aptos bug bounty criteria for "Limited funds loss or manipulation":

- **MEV Extraction**: Enables systematic value extraction from users through front-running
- **DeFi Impact**: Attackers can sandwich attack DEX trades, causing slippage losses for victims
- **NFT Front-Running**: High-value NFT purchases can be front-run
- **Liquidation Sniping**: Profitable liquidations can be front-run by higher gas payers

The wide gas price range (100 to 10 billion) provides significant room for manipulation. While attackers must pay higher fees, the profit from front-running often exceeds the gas cost.

## Likelihood Explanation

**Likelihood: High**

- **Zero Privileges Required**: Any transaction sender can set arbitrary gas_unit_price within bounds
- **Easy to Execute**: Simple parameter manipulation, no complex exploit needed
- **Observable Mempool**: Transaction ordering in mempool is visible to validators and potentially other network participants
- **Proven Attack Vector**: Front-running via gas price manipulation is a well-documented attack in blockchain systems
- **Economic Incentive**: Profitable for attackers in high-value scenarios (large trades, NFTs, liquidations)

The attack requires no insider access, no cryptographic breaks, and no protocol violations - just setting a higher gas price.

## Recommendation

**Short-term Mitigations:**

1. **Implement Fair Ordering Mechanisms**:
   - Consider time-based ordering (FIFO) for transactions within the same gas price bucket
   - Implement random shuffling within priority bands to reduce predictability

2. **Narrow Gas Price Range**:
   - Reduce the gap between min and max gas prices to limit manipulation impact
   - Consider dynamic gas price caps based on recent transaction history

3. **Transaction Privacy Options**:
   - Implement optional private mempool for sensitive transactions
   - Add delayed transaction execution options

**Long-term Solutions:**

1. **Encrypted Mempool**: Implement transaction encryption until block inclusion (similar to Flashbots/MEV-Boost)
2. **Fair Sequencing Service**: Adopt cryptographic fair ordering protocols
3. **Application-Layer Protections**: Provide SDK tools for front-running-resistant transaction construction (e.g., slippage protection, deadline parameters)

## Proof of Concept

```rust
// Demonstrating gas price-based priority in mempool ordering

use aptos_types::transaction::SignedTransaction;
use mempool::core_mempool::CoreMempool;

#[test]
fn test_gas_price_front_running() {
    let mut mempool = CoreMempool::new(/* config */);
    
    // Victim transaction with normal gas price
    let victim_tx = create_transaction(
        victim_account,
        victim_sequence_num,
        gas_unit_price: 100,  // minimum price
        /* payload: DEX swap */
    );
    
    // Attacker transaction with higher gas price
    let attacker_tx = create_transaction(
        attacker_account,
        attacker_sequence_num,
        gas_unit_price: 1000,  // 10x higher
        /* payload: front-running DEX swap */
    );
    
    // Both transactions added to mempool
    mempool.add_txn(victim_tx, /* ... */);
    mempool.add_txn(attacker_tx, /* ... */);
    
    // Consensus pulls transactions
    let batch = mempool.get_batch(max_txns: 100, /* ... */);
    
    // ASSERTION: Attacker's transaction appears before victim's
    // due to higher gas_ranking_score in PriorityIndex
    assert_eq!(batch[0], attacker_tx);  // Front-runner first
    assert_eq!(batch[1], victim_tx);    // Victim second
}
```

**Notes:**
- This is an intentional design feature that creates a security vulnerability
- The mempool explicitly prioritizes higher gas prices for economic reasons (validator incentives)
- However, this design choice enables front-running attacks that harm users
- The issue affects application-layer security (DeFi, NFTs) more than core protocol security
- Similar vulnerabilities exist in other blockchain systems (Ethereum pre-Flashbots, etc.)

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3296-3299)
```rust
            _ => (
                "success",
                VMValidatorResult::new(None, txn.gas_unit_price()),
            ),
```

**File:** mempool/src/core_mempool/index.rs (L176-184)
```rust
#[derive(Eq, PartialEq, Clone, Debug, Hash)]
pub struct OrderedQueueKey {
    pub gas_ranking_score: u64,
    pub expiration_time: Duration,
    pub insertion_time: SystemTime,
    pub address: AccountAddress,
    pub replay_protector: ReplayProtector,
    pub hash: HashValue,
}
```

**File:** mempool/src/core_mempool/index.rs (L192-215)
```rust
impl Ord for OrderedQueueKey {
    fn cmp(&self, other: &OrderedQueueKey) -> Ordering {
        // Higher gas preferred
        match self.gas_ranking_score.cmp(&other.gas_ranking_score) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Lower insertion time preferred
        match self.insertion_time.cmp(&other.insertion_time).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Higher address preferred
        match self.address.cmp(&other.address) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        match self.replay_protector.cmp(&other.replay_protector).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        self.hash.cmp(&other.hash)
    }
}
```

**File:** mempool/src/core_mempool/index.rs (L391-394)
```rust
/// We use ranking score as a means to prioritize transactions.
/// At the moment, we use gas_unit_price in the transaction as ranking score.
/// Transactions with higher ranking score (gas_unit_price) are given higher priority.
type RankingScore = u64;
```

**File:** mempool/src/core_mempool/mempool.rs (L425-449)
```rust
    pub(crate) fn get_batch(
        &self,
        max_txns: u64,
        max_bytes: u64,
        return_non_full: bool,
        exclude_transactions: BTreeMap<TransactionSummary, TransactionInProgress>,
    ) -> Vec<SignedTransaction> {
        let start_time = Instant::now();
        let exclude_size = exclude_transactions.len();
        let mut inserted = HashSet::new();

        let gas_end_time = start_time.elapsed();

        let mut result = vec![];
        // Helper DS. Helps to mitigate scenarios where account submits several transactions
        // with increasing gas price (e.g. user submits transactions with sequence number 1, 2
        // and gas_price 1, 10 respectively)
        // Later txn has higher gas price and will be observed first in priority index iterator,
        // but can't be executed before first txn. Once observed, such txn will be saved in
        // `skipped` DS and rechecked once it's ancestor becomes available
        let mut skipped = HashSet::new();
        let mut total_bytes = 0;
        let mut txn_walked = 0usize;
        // iterate over the queue of transactions based on gas price
        'main: for txn in self.transactions.iter_queue() {
```

**File:** mempool/src/core_mempool/transaction_store.rs (L1008-1010)
```rust
    pub(crate) fn iter_queue(&self) -> PriorityQueueIter<'_> {
        self.priority_index.iter()
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L59-71)
```rust
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```

**File:** config/global-constants/src/lib.rs (L23-26)
```rust
#[cfg(any(test, feature = "testing"))]
pub const GAS_UNIT_PRICE: u64 = 0;
#[cfg(not(any(test, feature = "testing")))]
pub const GAS_UNIT_PRICE: u64 = 100;
```
