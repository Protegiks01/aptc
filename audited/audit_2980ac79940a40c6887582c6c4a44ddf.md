# Audit Report

## Title
Global Invariant Bypass via Incomplete Exit Point Instrumentation in Move Prover

## Summary
The Move Prover's global invariant instrumentation fails to check global invariants on abort exit paths, only checking them on normal return paths. This verification soundness bug allows code that violates global invariants through abort paths to pass verification, potentially leading to deployment of vulnerable smart contracts.

## Finding Description

The Move Prover's bytecode pipeline processes functions in multiple stages. The `GlobalInvariantInstrumentationProcessor` is responsible for inserting assertion checks for global invariants at function exit points. However, it only instruments `Ret` (return) bytecodes and completely ignores `Abort` bytecodes.

The pipeline order is critical to understanding this bug:

1. **SpecInstrumentationProcessor** runs first and transforms original `Abort` bytecodes into jumps to a unified abort block, which ends with a new `Abort` bytecode [1](#0-0) 

2. The spec instrumenter transforms abort paths: [2](#0-1) 

3. **GlobalInvariantInstrumentationProcessor** runs after spec instrumentation and only checks for `Ret` bytecodes when inserting exit point assertions: [3](#0-2) 

The Move bytecode system defines three types of exit points: [4](#0-3) 

However, the global invariant instrumentation only handles `Ret`, missing `Abort` and `Stop` operations.

**Exploitation Scenario:**

When a Move function uses `pragma disable_invariants_in_body` with suspendable global invariants:
- The invariant can be temporarily violated during function execution
- Invariant checks are deferred to exit points
- If the function modifies global state and then aborts, the invariant check on the abort path is **skipped**
- The prover incorrectly verifies the code as safe

This breaks the verification soundness guarantee: the prover claims code is safe when it actually violates invariants on abort paths.

## Impact Explanation

**Severity: HIGH ($50,000 per Aptos Bug Bounty)**

This vulnerability falls under "Significant protocol violations" because:

1. **Verification Soundness Violation**: The Move Prover is a critical security tool for Aptos smart contract development. A soundness bug means the prover gives false negatives, claiming code is correct when it contains invariant violations.

2. **Security Impact**: Global invariants often encode critical security properties (e.g., "total supply never exceeds maximum", "all accounts have positive balance", "critical resources exist"). Code that passes verification but violates these invariants can lead to:
   - Smart contract vulnerabilities
   - State corruption
   - Protocol violations
   - Potential fund loss

3. **Widespread Effect**: Any Move code using suspendable global invariants with abort paths is affected. This includes Aptos Framework code and all user-deployed modules using this pattern.

4. **Deterministic Execution Risk**: If verified code actually violates invariants at runtime (due to false verification), this could lead to consensus divergence if different validators handle the invariant violation differently.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability is likely to occur in practice because:

1. **Common Pattern**: Using `pragma disable_invariants_in_body` with suspendable invariants is a documented feature for complex functions that need to temporarily violate invariants [5](#0-4) 

2. **Abort is Common**: Abort operations are fundamental to Move programming for error handling and validation failures

3. **Not Obvious**: Developers trust the Move Prover's verification and won't manually check for this specific gap in exit point coverage

4. **Already in Pipeline**: The infrastructure to identify exit points already exists; the bug is just incomplete implementation

## Recommendation

Fix the incomplete exit point check in the global invariant instrumentation by checking ALL exit bytecodes, not just returns:

**File:** `third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs`

**Current code (line 227-230):** [3](#0-2) 

**Fixed code:**
```rust
// for ALL exit bytecodes, the assertion comes before the bytecode
if bc.is_exit() {  // Use the existing is_exit() method
    self.assert_or_assume_translated_invariants(&xlated_exitpoint, PropKind::Assert);
}
```

The `is_exit()` method already correctly identifies all exit bytecodes (Ret, Abort, and Stop operations), so using it ensures complete coverage.

## Proof of Concept

```move
module 0x1::InvariantBypass {
    use std::signer;
    
    struct Counter has key {
        value: u64
    }
    
    spec Counter {
        invariant value > 0;  // Counter value must always be positive
    }
    
    spec module {
        pragma disable_invariants_in_body;  // Makes invariant suspendable
    }
    
    /// Initialize a counter with positive value
    public fun initialize(account: &signer) {
        move_to(account, Counter { value: 1 });
    }
    
    /// This function violates the global invariant on abort path
    /// but INCORRECTLY passes Move Prover verification
    public fun vulnerable_function(addr: address) acquires Counter {
        let counter = borrow_global_mut<Counter>(addr);
        
        // Temporarily violate the invariant
        // This is allowed because pragma disable_invariants_in_body
        // makes the invariant suspendable
        counter.value = 0;  
        
        // Abort without restoring the invariant
        // BUG: The global invariant check should happen here but is MISSING
        abort 99;
        
        // This line would restore the invariant, but we never reach it
        // counter.value = 1;
    }
    
    spec vulnerable_function {
        aborts_if !exists<Counter>(addr);
        aborts_if true;  // Function always aborts
    }
}
```

**To reproduce:**
1. Save the above code to `sources/InvariantBypass.move`
2. Run the Move Prover: `move prove`
3. **Expected result:** Prover should report that the global invariant `Counter.value > 0` is violated on the abort path
4. **Actual result (with bug):** Prover incorrectly reports verification success because the invariant check on the abort path is missing

**Impact:** Any code relying on this global invariant for security properties would be vulnerable, as the invariant can be violated through abort paths without the prover detecting it.

## Notes

- This bug specifically affects functions using `pragma disable_invariants_in_body` with suspendable global invariants
- Functions without this pragma check invariants in-place and are not affected by this specific bug  
- The fix is straightforward: use the existing `is_exit()` method instead of pattern-matching only `Ret`
- The `Stop` operation is also an exit point but is specification-only and unlikely to appear in normal code paths
- While runtime transaction rollback on abort preserves invariants at execution time, the **verifier** must still check all paths for soundness, as it doesn't model rollback semantics

### Citations

**File:** third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs (L50-52)
```rust
        SpecInstrumentationProcessor::new(),
        GlobalInvariantAnalysisProcessor::new(),
        GlobalInvariantInstrumentationProcessor::new(),
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/spec_instrumentation.rs (L439-446)
```rust
            Abort(id, code, _) => {
                self.builder.set_loc_from_attr(id);
                let abort_local = self.abort_local;
                let abort_label = self.abort_label;
                self.builder
                    .emit_with(|id| Assign(id, abort_local, code, AssignKind::Move));
                self.builder.emit_with(|id| Jump(id, abort_label));
                self.can_abort = true;
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs (L227-230)
```rust
            // for the return bytecode, the assertion comes before the bytecode
            if matches!(bc, Bytecode::Ret(..)) {
                self.assert_or_assume_translated_invariants(&xlated_exitpoint, PropKind::Assert);
            }
```

**File:** third_party/move/move-model/bytecode/src/stackless_bytecode.rs (L558-563)
```rust
    pub fn is_exit(&self) -> bool {
        matches!(
            self,
            Bytecode::Ret(..) | Bytecode::Abort(..) | Bytecode::Call(_, _, Operation::Stop, _, _)
        )
    }
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/global_invariant_analysis.rs (L58-61)
```rust
    /// Invariants that needs to be asserted at function exitpoint
    /// - Key: global invariants that needs to be assumed before the first instruction,
    /// - Value: the instantiation information per each related invariant.
    pub exitpoint_assertions: BTreeMap<GlobalId, PerBytecodeRelevance>,
```
