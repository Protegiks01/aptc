# Audit Report

## Title
Non-Recoverable Consensus Halt via Empty Validator Set After Epoch Transition

## Summary
The Aptos staking system lacks validation to prevent an empty validator set from being created during epoch transitions. If all validators fall below the minimum stake threshold, the `on_new_epoch` function produces an empty `active_validators` set, causing permanent consensus halt requiring hardfork recovery. While CommitVote verification correctly rejects votes with `UnknownAuthor` in this state, the chain becomes non-operational.

## Finding Description

The vulnerability exists in the validator set filtering logic during epoch transitions. The `on_new_epoch` function filters validators based on minimum stake requirements without validating that at least one validator remains. [1](#0-0) 

When all validators are filtered out (lines 1390-1397), `next_epoch_validators` becomes an empty vector, which is directly assigned to `validator_set.active_validators` at line 1401 **with no validation preventing this**.

This empty `ValidatorSet` is then converted to a `ValidatorVerifier` with `quorum_voting_power = 0`: [2](#0-1) 

When consensus nodes transition to this new epoch, they attempt to initialize with the empty validator set: [3](#0-2) 

**CommitVote Verification Behavior:**

When a `CommitVote` is verified against an empty `ValidatorVerifier`, the `optimistic_verify` method checks if the author's public key exists: [4](#0-3) 

With an empty validator set, `get_public_key(&author)` returns `None` (line 275), causing verification to fail with `VerifyError::UnknownAuthor`. This means **all CommitVote verifications correctly reject votes**, but the chain is already halted because:

1. No validator can propose blocks (empty set)
2. No validator can vote on proposals (empty set)  
3. No quorum can ever be achieved (quorum_voting_power = 0, but no valid voters exist)
4. The chain cannot progress to the next epoch

**Attack Scenario:**

While not directly exploitable by an unprivileged attacker, this can occur through:
1. Governance proposal raising minimum stake above all current validator stakes
2. Coordinated mass withdrawal or slashing event
3. Economic conditions causing validators to drop below threshold

## Impact Explanation

This is **Critical Severity** under Aptos bug bounty criteria as it causes:
- **Total loss of liveness/network availability**: The chain completely halts with zero validators
- **Non-recoverable network partition (requires hardfork)**: No on-chain mechanism can recover; requires off-chain coordination and hardfork to restore validator set

The chain enters an irrecoverable state where:
- No blocks can be proposed or committed
- No transactions can be processed
- The blockchain is effectively frozen
- Users cannot access or transfer funds
- Requires emergency hardfork with manual validator set restoration

## Likelihood Explanation

**Likelihood: Low to Medium**

While this requires specific economic or governance conditions, it's more likely than initially apparent:

1. **Governance Attack**: A malicious governance proposal could raise `minimum_stake` above all current validators' stake in a single epoch, causing immediate halt
2. **Economic Cascade**: Market volatility could trigger mass validator exits, combined with slashing, pushing all validators below threshold  
3. **Configuration Error**: Accidental misconfiguration of staking parameters during upgrade

The lack of defensive validation means this is a single-point-of-failure in epoch transitions.

## Recommendation

Add validation in `on_new_epoch` to prevent empty validator sets:

```move
// In stake.move, after line 1401:
validator_set.active_validators = next_epoch_validators;

// ADD THIS VALIDATION:
assert!(
    !vector::is_empty(&validator_set.active_validators),
    error::invalid_state(EEMPTY_VALIDATOR_SET)
);

validator_set.total_voting_power = total_voting_power;
```

Define the error constant:
```move
/// Validator set cannot be empty after epoch transition
const EEMPTY_VALIDATOR_SET: u64 = 100; // Choose appropriate error code
```

**Additional safeguards:**

1. Add minimum validator count check (e.g., require at least 4 validators for BFT safety)
2. Implement gradual stake threshold adjustments with multi-epoch transition periods
3. Add governance proposal validation to prevent stake threshold changes that would empty the set

## Proof of Concept

```move
#[test(aptos_framework = @0x1)]
#[expected_failure(abort_code = EEMPTY_VALIDATOR_SET)]
public entry fun test_empty_validator_set_prevention(aptos_framework: &signer) {
    // Setup: Create validator set with validators at minimum stake
    // ... initialization code ...
    
    // Simulate on_new_epoch where all validators fall below minimum
    // by raising minimum_stake above all current validators
    let config = staking_config::get();
    staking_config::update_required_stake(
        aptos_framework,
        new_minimum_stake_higher_than_all_validators,
        max_stake
    );
    
    // Trigger epoch transition - should abort with EEMPTY_VALIDATOR_SET
    stake::on_new_epoch();
}
```

**Rust reproduction:**
The issue manifests when `ValidatorVerifier::new(vec![])` is created during epoch initialization with an empty validator info vector, resulting in `quorum_voting_power = 0` and all consensus operations failing.

## Notes

While CommitVote verification correctly rejects votes from unknown authors when the validator set is empty, the fundamental issue is that the Move contract allows this irrecoverable state to be created. The lack of validation represents a critical defensive programming failure that could cause permanent chain halt requiring emergency intervention.

The test/fuzzing build bypass in `verify_multi_signatures` (lines 366-371 of validator_verifier.rs) is a separate concern for test code hygiene but does not affect production CommitVote verification, which uses the `optimistic_verify` path.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1402)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** consensus/src/epoch_manager.rs (L1164-1174)
```rust
    async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
        verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);

        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });
```
