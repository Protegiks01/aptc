# Audit Report

## Title
Container Name Collision DoS in Local Testnet Docker Management

## Summary
The `delete_container()` function in the local testnet infrastructure does not verify container ownership before deletion, allowing one localnet instance to forcefully remove Docker containers belonging to another concurrent instance on the same host, causing denial of service.

## Finding Description
The local testnet CLI tool uses hardcoded container names without instance-specific identifiers. When `pre_run()` is called during localnet startup, it unconditionally deletes any container matching the hardcoded name, regardless of which process or user created it. [1](#0-0) [2](#0-1) 

The `delete_container()` implementation forcefully removes any container with the given name without ownership verification: [3](#0-2) 

When creating containers, no labels or metadata are added to identify ownership: [4](#0-3) 

The same vulnerability exists in the Postgres container management: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. User A starts a local testnet, creating containers "local-testnet-indexer-api" and "local-testnet-postgres"
2. User B (or User A in a different terminal/directory) starts another localnet instance
3. User B's `pre_run()` calls `delete_container("local-testnet-indexer-api")` with `force: true`
4. User A's running indexer API container is forcefully deleted
5. User A's localnet experiences service disruption

**Contrast with Workspace Server Implementation:**

The `aptos-workspace-server` correctly uses UUID-based unique naming to prevent this issue: [7](#0-6) [8](#0-7) [9](#0-8) 

## Impact Explanation
This is a **Medium severity** issue causing denial of service in development environments. While it doesn't affect production blockchain nodes, it disrupts local development workflows when multiple developers or CI/CD processes run concurrent localnet instances on shared infrastructure. This aligns with Medium severity: state inconsistencies requiring manual intervention to restart affected services.

## Likelihood Explanation
**High likelihood** in environments where:
- Multiple developers share a development machine
- CI/CD pipelines run parallel localnet tests
- Developers run multiple localnet instances for different projects
- Automated testing frameworks spawn concurrent localnets

The issue triggers automatically during normal startup without requiring any malicious intent.

## Recommendation
Adopt the UUID-based naming pattern from `aptos-workspace-server`:

1. Generate a unique instance ID when `RunLocalnet` is created
2. Include this ID in all container names
3. Pass the instance ID to container management functions
4. Optionally add Docker labels for ownership tracking

```rust
// In RunLocalnet struct
pub struct RunLocalnet {
    instance_id: Uuid,
    // ... existing fields
}

// In indexer_api.rs
const INDEXER_API_CONTAINER_PREFIX: &str = "local-testnet-indexer-api";

// When creating container
let container_name = format!("{}-{}", INDEXER_API_CONTAINER_PREFIX, instance_id);
```

## Proof of Concept
```bash
# Terminal 1: Start first localnet instance
aptos node run-localnet --with-indexer-api &
# Wait for "Indexer API is ready" message

# Terminal 2: Immediately start second localnet instance
aptos node run-localnet --with-indexer-api
# Observe: First instance's indexer API container gets deleted during pre_run()
# First instance logs: "Indexer API stopped" unexpectedly

# Verify with Docker
docker ps -a | grep local-testnet-indexer-api
# Shows only containers from the second instance
```

**Notes:**

This vulnerability is specific to the local testnet development tool infrastructure and does not affect production validator nodes or the blockchain protocol itself. The hardcoded container names create a namespace collision when multiple instances run on the same Docker daemon. While the workspace server implementation demonstrates awareness of this issue through UUID-based naming, the CLI-based local testnet has not been updated with the same safeguard.

### Citations

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L29-29)
```rust
const INDEXER_API_CONTAINER_NAME: &str = "local-testnet-indexer-api";
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L109-118)
```rust
    async fn pre_run(&self) -> Result<()> {
        if self.existing_hasura_url.is_some() {
            return Ok(());
        }

        // Confirm Docker is available.
        get_docker().await?;

        // Delete any existing indexer API container we find.
        delete_container(INDEXER_API_CONTAINER_NAME).await?;
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L222-252)
```rust
        let config = Config {
            image: Some(HASURA_IMAGE.to_string()),
            tty: Some(true),
            exposed_ports,
            host_config: Some(host_config),
            env: Some(vec![
                format!("PG_DATABASE_URL={}", postgres_connection_string),
                format!(
                    "HASURA_GRAPHQL_METADATA_DATABASE_URL={}",
                    postgres_connection_string
                ),
                format!("INDEXER_V2_POSTGRES_URL={}", postgres_connection_string),
                "HASURA_GRAPHQL_DEV_MODE=true".to_string(),
                "HASURA_GRAPHQL_ENABLE_CONSOLE=true".to_string(),
                // See the docs for the image, this is a magic path inside the
                // container where they have already bundled in the UI assets.
                "HASURA_GRAPHQL_CONSOLE_ASSETS_DIR=/srv/console-assets".to_string(),
                format!("HASURA_GRAPHQL_SERVER_PORT={}", self.indexer_api_port),
            ]),
            ..Default::default()
        };

        let options = Some(CreateContainerOptions {
            name: INDEXER_API_CONTAINER_NAME,
            ..Default::default()
        });

        info!("Starting indexer API with this config: {:?}", config);

        let id = docker.create_container(options, config).await?.id;

```

**File:** crates/aptos/src/node/local_testnet/docker.rs (L21-47)
```rust
/// Delete a container. If the container doesn't exist, that's fine, just move on.
pub async fn delete_container(container_name: &str) -> Result<()> {
    info!(
        "Removing container with name {} (if it exists)",
        container_name
    );

    let docker = get_docker().await?;

    let options = Some(RemoveContainerOptions {
        force: true,
        ..Default::default()
    });

    // Ignore any error, it'll be because the container doesn't exist.
    let result = docker.remove_container(container_name, options).await;

    match result {
        Ok(_) => info!("Successfully removed container {}", container_name),
        Err(err) => warn!(
            "Failed to remove container {}: {:#} (it probably didn't exist)",
            container_name, err
        ),
    }

    Ok(())
}
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L26-26)
```rust
pub const POSTGRES_CONTAINER_NAME: &str = "local-testnet-postgres";
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L183-194)
```rust
    async fn pre_run(&self) -> Result<()> {
        if self.args.use_host_postgres {
            if self.force_restart {
                // If we're using a DB outside of Docker, drop and recreate the database.
                self.recreate_host_database().await?;
            }
        } else {
            // Confirm Docker is available.
            get_docker().await?;

            // Kill any existing container we find.
            delete_container(POSTGRES_CONTAINER_NAME).await?;
```

**File:** aptos-move/aptos-workspace-server/src/lib.rs (L97-97)
```rust
    let instance_id = Uuid::new_v4();
```

**File:** aptos-move/aptos-workspace-server/src/services/indexer_api.rs (L102-105)
```rust
    let options = CreateContainerOptions {
        name: format!("aptos-workspace-{}-indexer-api", instance_id),
        ..Default::default()
    };
```

**File:** aptos-move/aptos-workspace-server/src/services/postgres.rs (L142-145)
```rust
    let options = CreateContainerOptions {
        name: format!("aptos-workspace-{}-postgres", instance_id),
        ..Default::default()
    };
```
