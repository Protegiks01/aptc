# Audit Report

## Title
Malicious Validator Can Create Invalid Timeout Certificates Through Self-Message Verification Bypass

## Summary
A malicious validator can craft votes with valid vote signatures but invalid timeout signatures. Due to a verification bypass for self-messages in the consensus layer, these invalid timeout signatures can be aggregated into Timeout Certificates (TCs), causing consensus safety violations when honest validators reject the invalid TC while the malicious validator accepts it.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Broadcast with Self-Loopback**: When a validator broadcasts a vote, it sends the message to itself first as a "self-message" before broadcasting to other validators. [1](#0-0) 

2. **Verification Bypass for Self-Messages**: Self-messages skip signature verification because `self_message = peer_id == my_peer_id`. [2](#0-1) [3](#0-2) 

3. **Missing Timeout Signature Verification**: The `Vote::verify()` method verifies both vote and timeout signatures, but this verification is skipped for self-messages. The timeout signature is then extracted and added to the partial TC without verification. [4](#0-3) 

4. **Optimistic Aggregation**: The `aggregate_signatures()` method performs optimistic aggregation without verifying individual signatures. [5](#0-4) 

**Attack Flow:**

1. Malicious validator creates a vote with a valid vote signature (properly signed with their private key) but an **invalid timeout signature** (e.g., dummy signature or incorrectly signed).

2. The malicious validator broadcasts the vote using `broadcast_vote()`, which first sends it to themselves as a self-message.

3. When processing their own vote, verification is skipped because `self_message = true`, so the invalid timeout signature is never verified.

4. The vote reaches `insert_vote()` in `pending_votes.rs` where the invalid timeout signature is extracted and added to `TwoChainTimeoutWithPartialSignatures`. [6](#0-5) 

5. When 2f+1 votes are collected (including the malicious vote), `aggregate_signatures()` is called, which aggregates all signatures including the invalid one.

6. The resulting `TwoChainTimeoutCertificate` contains an invalid aggregated signature because BLS signature aggregation of (valid₁ + valid₂ + ... + **invalid**) = **invalid**.

7. This invalid TC is stored locally without verification. [7](#0-6) 

8. When other honest validators receive this TC (e.g., in a SyncInfo or proposal), they verify it and the verification fails, causing consensus disagreement. [8](#0-7) 

## Impact Explanation

This vulnerability breaks **Consensus Safety** (Critical Invariant #2) and represents a **Critical Severity** issue under the Aptos bug bounty criteria:

- **Consensus Safety Violation**: The malicious validator creates and stores an invalid TC locally, while honest validators reject it. This causes consensus state divergence where validators disagree on valid timeout certificates.

- **Round Progression Disruption**: When the malicious validator becomes a proposer and includes the invalid TC in proposals or SyncInfo messages, honest validators will reject these messages due to TC verification failure, causing proposal rejection and round stalling.

- **Network Partition Risk**: If multiple malicious validators coordinate this attack, they could create a subset of the network that accepts invalid TCs while honest validators reject them, potentially requiring manual intervention or a hardfork to resolve.

The attack requires only a single malicious validator (no collusion needed) and breaks the fundamental assumption that all validators operate on the same valid consensus state.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attacker Requirements**: Requires control of a single validator node, which is feasible for adversarial validators.
- **Technical Complexity**: Low - the attacker only needs to modify their validator to create votes with invalid timeout signatures.
- **Detection**: Difficult to detect initially because the invalid TC is only rejected when other validators try to verify it, which may appear as a network issue rather than a deliberate attack.
- **Prerequisites**: The validator must be active in the validator set and participating in consensus.

The attack is realistic because:
1. The self-message verification bypass is always active
2. No special conditions or timing windows are required
3. The attack can be executed repeatedly in every round

## Recommendation

**Fix: Always verify timeout signatures, even for self-messages**

The root cause is that self-messages skip verification entirely. While this optimization is reasonable for vote signatures (which are verified later during QC aggregation), timeout signatures must be verified immediately because they are aggregated optimistically without verification.

**Option 1: Verify timeout signatures separately for self-messages**

Modify `UnverifiedEvent::verify()` to always verify timeout signatures even for self-messages: [9](#0-8) 

Add timeout signature verification after the self-message check:

```rust
UnverifiedEvent::VoteMsg(v) => {
    if !self_message {
        v.verify(peer_id, validator)?;
        counters::VERIFY_MSG
            .with_label_values(&["vote"])
            .observe(start_time.elapsed().as_secs_f64());
    } else {
        // For self-messages, verify only the timeout signature if present
        if let Some((timeout, signature)) = v.vote().two_chain_timeout() {
            validator.verify(v.vote().author(), &timeout.signing_format(), signature)
                .context("Failed to verify 2-chain timeout signature in self-message")?;
        }
    }
    VerifiedEvent::VoteMsg(v)
},
```

**Option 2: Verify signatures during TC aggregation**

Add signature verification in `TwoChainTimeoutWithPartialSignatures::add()`: [6](#0-5) 

Remove the comment "the timeout should already be verified in upper layer" and add actual verification.

**Recommended: Option 1** is preferred because it maintains the invariant that votes are verified before being processed, and it's clearer that timeout signatures have special verification requirements.

## Proof of Concept

**Test Setup:**
1. Create a modified validator that generates votes with invalid timeout signatures
2. Verify that the invalid TC is created locally
3. Verify that honest validators reject the TC

**Rust PoC (Conceptual):**

```rust
// In a test or malicious validator implementation:

// Step 1: Create a vote with valid vote signature
let vote_data = VoteData::new(block_info, parent_block_info);
let ledger_info = LedgerInfo::new(block_info, vote_data.hash());
let mut vote = Vote::new(vote_data, validator_signer.author(), ledger_info, &validator_signer)?;

// Step 2: Add a timeout with INVALID signature (using dummy signature instead of properly signing)
let timeout = vote.generate_2chain_timeout(qc);
let invalid_signature = bls12381::Signature::dummy_signature(); // Invalid!
vote.add_2chain_timeout(timeout, invalid_signature);

// Step 3: Broadcast the vote (it will be sent to self first as a self-message)
network.broadcast_vote(VoteMsg::new(vote, sync_info)).await;

// Step 4: The vote is processed without verification (self-message bypass)
// Step 5: When 2f+1 votes collected, an invalid TC is created
// Step 6: Honest validators receiving this TC will fail verification:
//   tc.verify(&validator_verifier) => Err(VerifyError::InvalidAggregatedSignature)
```

**Verification Steps:**
1. The malicious validator's `insert_2chain_timeout_certificate()` succeeds (no verification)
2. Honest validators' `TwoChainTimeoutCertificate::verify()` fails with `InvalidAggregatedSignature`
3. Consensus state diverges between malicious and honest validators

This demonstrates the complete attack path from crafted vote to consensus safety violation.

### Citations

**File:** consensus/src/network.rs (L363-370)
```rust
    async fn broadcast(&self, msg: ConsensusMsg) {
        fail_point!("consensus::send::any", |_| ());
        // Directly send the message to ourself without going through network.
        let self_msg = Event::Message(self.author, msg.clone());
        let mut self_sender = self.self_sender.clone();
        if let Err(err) = self_sender.send(self_msg).await {
            error!("Error broadcasting to self: {:?}", err);
        }
```

**File:** consensus/src/epoch_manager.rs (L1591-1599)
```rust
                        unverified_event.clone().verify(
                            peer_id,
                            &epoch_state.verifier,
                            &proof_cache,
                            quorum_store_enabled,
                            peer_id == my_peer_id,
                            max_num_batches,
                            max_batch_expiry_gap_usecs,
                        )
```

**File:** consensus/src/round_manager.rs (L138-145)
```rust
            UnverifiedEvent::VoteMsg(v) => {
                if !self_message {
                    v.verify(peer_id, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["vote"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::VoteMsg(v)
```

**File:** consensus/src/pending_votes.rs (L422-441)
```rust
        if let Some((timeout, signature)) = vote.two_chain_timeout() {
            counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
                .with_label_values(&[&vote.author().to_string()])
                .set(validator_voting_power as f64);
            counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_epoch);
            counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_round);

            let two_chain_votes = self
                .maybe_2chain_timeout_votes
                .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
            two_chain_votes.add(
                vote.author(),
                timeout.clone(),
                signature.clone(),
                RoundTimeoutReason::Unknown,
            );
```

**File:** types/src/validator_verifier.rs (L330-332)
```rust
        // Perform an optimistic aggregation of the signatures without verification.
        let aggregated_sig = bls12381::Signature::aggregate(sigs)
            .map_err(|_| VerifyError::FailedToAggregateSignature)?;
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L141-183)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        let hqc_round = self.timeout.hqc_round();
        // Verify the highest timeout validity.
        let (timeout_result, sig_result) = rayon::join(
            || self.timeout.verify(validators),
            || {
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
        );
        timeout_result?;
        sig_result?;
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L241-263)
```rust
    /// Add a new timeout message from author, the timeout should already be verified in upper layer.
    pub fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
    ) {
        debug_assert_eq!(
            self.timeout.epoch(),
            timeout.epoch(),
            "Timeout should have the same epoch as TimeoutCert"
        );
        debug_assert_eq!(
            self.timeout.round(),
            timeout.round(),
            "Timeout should have the same round as TimeoutCert"
        );
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
    }
```

**File:** consensus/src/block_storage/block_store.rs (L560-574)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
```
