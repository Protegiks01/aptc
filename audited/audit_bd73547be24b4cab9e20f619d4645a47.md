# Audit Report

## Title
Missing Validation on max_partitioning_rounds Enables Configuration-Based Validator Denial of Service

## Summary
The `remove_cross_shard_dependencies()` function in the block partitioner V2 contains a loop bounded by `num_rounds_limit`, but this parameter has no validation against the defined `MAX_ALLOWED_PARTITIONING_ROUNDS` constant. While the default value is safe, an operator could misconfigure this to an arbitrarily large value, causing the validator node to hang during block processing.

## Finding Description
The block partitioner's `partition()` function calls `remove_cross_shard_dependencies()`, which contains a loop that iterates up to `num_rounds_limit - 1` times: [1](#0-0) 

The `num_rounds_limit` parameter is set from `max_partitioning_rounds` configuration without any validation: [2](#0-1) 

The codebase defines `MAX_ALLOWED_PARTITIONING_ROUNDS = 8` as a system-wide constant: [3](#0-2) 

However, this constant is never enforced. The configuration accepts any `usize` value: [4](#0-3) 

The executor benchmark exposes this as a CLI parameter with no bounds checking: [5](#0-4) 

**Security Guarantee Broken**: Resource Limits - All operations must respect computational limits.

**Attack Scenario**: While this cannot be exploited by external attackers, a misconfigured or compromised node operator could set `--max-partitioning-rounds` to an extremely large value (e.g., 2^32). If transactions consistently have cross-shard conflicts preventing early loop exit, the validator would process billions of partitioning rounds, effectively hanging on block processing.

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns". 

If exploited through misconfiguration:
- Validator becomes unable to process blocks in reasonable time
- Loss of liveness for that specific validator node
- Potential consensus participation failures if block processing times out
- No direct fund loss, but operational impact on network health

## Likelihood Explanation
**Low to Medium Likelihood** due to:
- Requires node operator configuration access (trusted role)
- Default value (4) is safe
- The partitioner appears primarily used in benchmarks/testing based on codebase analysis
- Would require both: (1) misconfiguration AND (2) adversarial transaction patterns causing consistent conflicts

However, the lack of defensive validation creates unnecessary operational risk.

## Recommendation
Enforce the `MAX_ALLOWED_PARTITIONING_ROUNDS` constant as an upper bound:

```rust
impl PartitionerV2Config {
    pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
        assert!(
            val > 0 && val <= MAX_ALLOWED_PARTITIONING_ROUNDS,
            "max_partitioning_rounds must be between 1 and {}",
            MAX_ALLOWED_PARTITIONING_ROUNDS
        );
        self.max_partitioning_rounds = val;
        self
    }
}
```

Additionally, validate in `PartitionState::new()`:

```rust
pub fn new(
    thread_pool: Arc<ThreadPool>,
    dashmap_num_shards: usize,
    txns: Vec<AnalyzedTransaction>,
    num_executor_shards: ShardId,
    num_rounds_limit: usize,
    cross_shard_dep_avoid_threshold: f32,
    partition_last_round: bool,
) -> Self {
    assert!(
        num_rounds_limit > 0 && num_rounds_limit <= MAX_ALLOWED_PARTITIONING_ROUNDS,
        "num_rounds_limit must be between 1 and {}",
        MAX_ALLOWED_PARTITIONING_ROUNDS
    );
    // ... rest of implementation
}
```

## Proof of Concept
```rust
// Demonstration of unbounded configuration acceptance
#[test]
fn test_unbounded_partitioning_rounds_accepted() {
    use aptos_block_partitioner::v2::{config::PartitionerV2Config, PartitionerV2};
    use aptos_block_partitioner::pre_partition::connected_component::config::ConnectedComponentPartitionerConfig;
    
    // This should fail but currently succeeds
    let dangerous_config = PartitionerV2Config::default()
        .max_partitioning_rounds(999999999); // No validation!
    
    // If block has many conflicting transactions, this would hang
    let partitioner = dangerous_config.build();
    
    // With adversarial transaction patterns, this processes 999999998 rounds
    // Each round involves parallel processing across shards
    // Result: validator effectively hangs
}
```

## Notes
**Critical Validation Failure**: This issue does NOT meet the strict validation criteria for a bounty-eligible vulnerability because:
- **Not exploitable by unprivileged attackers** - Requires node operator configuration access
- Node operators are listed as "Trusted Roles" in the trust model
- No external attack vector exists

This is a **defensive programming issue** and **operational security concern**, not an exploitable vulnerability per the defined criteria. While it represents poor input validation that should be fixed, it does not constitute a security bug exploitable by untrusted actors.

The finding is documented for completeness and defensive hardening, but according to the strict validation checklist requirement that vulnerabilities must be "exploitable by unprivileged attacker (no validator insider access required)", this fails to qualify as a reportable vulnerability.

**Recommendation**: Fix the missing validation as part of general code hardening, but this should not be considered a security vulnerability under the current threat model.

### Citations

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L37-48)
```rust
        for round_id in 0..(state.num_rounds_limit - 1) {
            let (accepted, discarded) = Self::discarding_round(state, round_id, remaining_txns);
            state.finalized_txn_matrix.push(accepted);
            remaining_txns = discarded;
            num_remaining_txns = remaining_txns.iter().map(|ts| ts.len()).sum();

            if num_remaining_txns
                < ((1.0 - state.cross_shard_dep_avoid_threshold) * state.num_txns() as f32) as usize
            {
                break;
            }
        }
```

**File:** execution/block-partitioner/src/v2/state.rs (L111-161)
```rust
    pub fn new(
        thread_pool: Arc<ThreadPool>,
        dashmap_num_shards: usize,
        txns: Vec<AnalyzedTransaction>,
        num_executor_shards: ShardId,
        num_rounds_limit: usize,
        cross_shard_dep_avoid_threshold: f32,
        partition_last_round: bool,
    ) -> Self {
        let _timer = MISC_TIMERS_SECONDS.timer_with(&["new"]);
        let num_txns = txns.len();
        let sender_counter = AtomicUsize::new(0);
        let key_counter = AtomicUsize::new(0);
        let mut senders: Vec<RwLock<Option<SenderIdx>>> = Vec::with_capacity(num_txns);
        let mut wsets: Vec<RwLock<HashSet<StorageKeyIdx>>> = Vec::with_capacity(num_txns);
        let mut rsets: Vec<RwLock<HashSet<StorageKeyIdx>>> = Vec::with_capacity(num_txns);
        let sender_idx_table: DashMap<Sender, SenderIdx> =
            DashMap::with_shard_amount(dashmap_num_shards);
        let key_idx_table: DashMap<StateKey, StorageKeyIdx> =
            DashMap::with_shard_amount(dashmap_num_shards);
        let trackers: DashMap<StorageKeyIdx, RwLock<ConflictingTxnTracker>> =
            DashMap::with_shard_amount(dashmap_num_shards);
        for txn in txns.iter() {
            senders.push(RwLock::new(None));
            wsets.push(RwLock::new(HashSet::with_capacity(txn.write_hints().len())));
            rsets.push(RwLock::new(HashSet::with_capacity(txn.read_hints().len())));
        }
        let takable_txns = thread_pool.install(|| {
            txns.into_par_iter()
                .map(|txn| RwLock::new(Some(txn)))
                .collect()
        });

        Self {
            dashmap_num_shards,
            partition_last_round,
            thread_pool,
            num_executor_shards,
            pre_partitioned: vec![],
            start_txn_idxs_by_shard: vec![0; num_executor_shards],
            sender_counter,
            storage_key_counter: key_counter,
            sender_idxs: senders,
            write_sets: wsets,
            read_sets: rsets,
            sender_idx_table,
            key_idx_table,
            trackers,
            cross_shard_dep_avoid_threshold,
            num_rounds_limit,
            finalized_txn_matrix: Vec::with_capacity(num_rounds_limit),
```

**File:** types/src/block_executor/partitioner.rs (L20-20)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
```

**File:** execution/block-partitioner/src/v2/config.rs (L28-30)
```rust
    pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
        self.max_partitioning_rounds = val;
        self
```

**File:** execution/executor-benchmark/src/main.rs (L216-217)
```rust
    #[clap(long, default_value = "4")]
    max_partitioning_rounds: usize,
```
