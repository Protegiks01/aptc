# Audit Report

## Title
Missing fsync in OnDiskStorage Enables Double-Voting After Validator Crash

## Summary
The `OnDiskStorage` implementation used for persisting consensus safety rules lacks durability guarantees. The `write()` method does not call `fsync()` before or after file operations, allowing a system crash to leave corrupted or empty storage files. This can cause `last_voted_round` to reset upon validator restart, enabling double-voting and violating BFT consensus safety guarantees.

## Finding Description

The consensus safety rules system relies on persistent storage of `SafetyData` to prevent double-voting across validator restarts. The critical field `last_voted_round` tracks which rounds a validator has already voted on, implementing the "First voting rule" that prevents voting for the same round twice. [1](#0-0) 

When validators use `OnDiskStorage` as their safety rules backend, the write path lacks durability guarantees: [2](#0-1) 

The vulnerability manifests through this attack sequence:

1. **Validator votes on round R**: The validator receives a proposal for round R, verifies it passes safety checks, and calls `verify_and_update_last_vote_round()` to update `safety_data.last_voted_round = R` [3](#0-2) 

2. **Safety data is persisted**: The updated `SafetyData` is written via `PersistentSafetyStorage::set_safety_data()`, which calls `OnDiskStorage::write()` [4](#0-3) 

3. **Vote is broadcast without durable persistence**: The `write()` method writes to a temporary file and renames it atomically, but does NOT call `fsync()`. The data remains in the OS page cache and may not be physically written to disk.

4. **System crashes**: Before the OS flushes the page cache (which can take seconds or minutes), the system experiences a power failure, kernel panic, or other crash.

5. **Storage is corrupted on restart**: The storage file may be empty, partially written, or contain zeroed blocks depending on filesystem behavior. When `OnDiskStorage::read()` attempts to load the data: [5](#0-4) 

   - If empty: Returns empty HashMap, causing `KeyNotSet` errors
   - If corrupted JSON: Returns `SerializationError`

6. **Re-initialization resets last_voted_round**: The validator restart logic detects missing keys and triggers re-initialization with the identity blob, creating fresh `SafetyData` with `last_voted_round = 0` [6](#0-5) 

7. **Double-voting occurs**: The validator can now vote again for round R (or any round < R), because the check `round <= safety_data.last_voted_round` passes when `last_voted_round = 0 < R`.

**Production Deployment Evidence**: Multiple production-like configurations use `OnDiskStorage`: [7](#0-6) [8](#0-7) 

**Config Sanitizer Gap**: The safety rules configuration sanitizer only prevents `InMemoryStorage` on mainnet, but allows `OnDiskStorage`: [9](#0-8) 

## Impact Explanation

This is a **Critical Severity** vulnerability (up to $1,000,000) under the Aptos Bug Bounty program category "Consensus/Safety violations."

**Consensus Safety Violation**: The fundamental safety property of BFT consensus is that no two conflicting blocks can be committed at the same height. This requires that honest validators (< 2/3 of stake) never vote for two different blocks in the same round. By allowing `last_voted_round` to reset, a validator can:

- Vote for block A in round R, crash, then vote for block B in round R after restart
- If Byzantine actors coordinate to collect these conflicting votes, they can create two valid quorum certificates for round R with different blocks
- This breaks the "no two conflicting blocks committed" invariant and can lead to chain splits

**Scope**: This affects any validator deployment using `OnDiskStorage` for safety rules, which includes:
- Docker Compose deployments
- Kubernetes/Helm deployments using default configurations
- Testnet validators
- Any validator not explicitly configured with Vault backend

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Triggers**:
- Power failures (common in data centers)
- Kernel panics or system crashes
- Out-of-memory kills
- Hardware failures
- Emergency shutdowns

**Frequency**: Modern systems with write caching can have unflushed data for 5-30 seconds (Linux default `dirty_writeback_centisecs = 500` means 5 seconds). During high consensus activity, validators vote multiple times per second, creating many opportunities for the vulnerability window.

**Exploitation Requirements**:
- No active attacker needed - this is a latent bug triggered by natural system crashes
- Byzantine validators could intentionally crash their nodes to reset voting state
- Coordinated with network delays, could enable strategic double-voting

**Detection Difficulty**: Double-voting within the same consensus round is detected by `PendingVotes`, but cross-round violations or after network progression may go undetected. [10](#0-9) 

## Recommendation

**Immediate Fix**: Add `fsync()` calls to ensure durability:

```rust
fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut file = File::create(self.temp_path.path())?;
    file.write_all(&contents)?;
    // CRITICAL: Ensure data is flushed to disk before rename
    file.sync_all()?;
    fs::rename(&self.temp_path, &self.file_path)?;
    // CRITICAL: Ensure directory entry is also durable
    File::open(&self.file_path)?.sync_all()?;
    Ok(())
}
```

**Configuration Fix**: Update the config sanitizer to prevent `OnDiskStorage` on mainnet:

```rust
// In safety_rules_config.rs, around line 86:
if chain_id.is_mainnet()
    && node_type.is_validator()
    && (safety_rules_config.backend.is_in_memory() 
        || safety_rules_config.backend.is_on_disk())
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "The secure backend must use Vault storage in mainnet for durability!"
            .to_string(),
    ));
}
```

**Documentation Fix**: Update deployment documentation to strongly warn against using `OnDiskStorage` for production validators and mandate Vault for safety-critical deployments. [11](#0-10) 

## Proof of Concept

```rust
#[test]
fn test_ondisk_storage_loses_data_on_crash_simulation() {
    use aptos_safety_rules::{PersistentSafetyStorage, SafetyRulesManager};
    use aptos_secure_storage::{OnDiskStorage, Storage};
    use aptos_consensus_types::safety_data::SafetyData;
    use aptos_types::validator_signer::ValidatorSigner;
    use tempfile::NamedTempFile;
    use std::fs;

    // Setup: Create validator with OnDiskStorage
    let signer = ValidatorSigner::from_int(0);
    let file_path = NamedTempFile::new().unwrap().into_temp_path().to_path_buf();
    let waypoint = test_utils::validator_signers_to_waypoint(&[&signer]);
    
    let mut storage = PersistentSafetyStorage::initialize(
        Storage::from(OnDiskStorage::new(file_path.clone())),
        signer.author(),
        signer.private_key().clone(),
        waypoint,
        true,
    );

    // Validator votes on round 100
    let mut safety_data = storage.safety_data().unwrap();
    safety_data.last_voted_round = 100;
    storage.set_safety_data(safety_data.clone()).unwrap();

    // Simulate crash by corrupting the file (no fsync means data loss)
    // In reality, this would be OS page cache not flushed
    fs::write(&file_path, "").unwrap(); // Empty file

    // Restart: Load storage again
    let mut storage_after_crash = PersistentSafetyStorage::new(
        Storage::from(OnDiskStorage::new(file_path)),
        true,
    );

    // BUG: last_voted_round should be 100, but empty file causes KeyNotSet
    // This triggers re-initialization with last_voted_round = 0
    let result = storage_after_crash.safety_data();
    
    // Vulnerability: Can now vote on round 100 again, violating safety!
    assert!(result.is_err() || result.unwrap().last_voted_round == 0);
}
```

## Notes

The documentation explicitly states that `OnDiskStorage` should not be used in production, yet multiple deployment configurations default to it. The config sanitizer's failure to enforce this for mainnet validators creates a dangerous gap between documentation and enforcement. Production validators should exclusively use Vault or other properly durable backends with built-in fsync guarantees.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** secure/storage/src/on_disk.rs (L53-62)
```rust
    fn read(&self) -> Result<HashMap<String, Value>, Error> {
        let mut file = File::open(&self.file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        if contents.is_empty() {
            return Ok(HashMap::new());
        }
        let data = serde_json::from_str(&contents)?;
        Ok(data)
    }
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L77-92)
```rust
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L48-77)
```rust
        let mut storage = if storage.author().is_ok() {
            storage
        } else if !matches!(
            config.initial_safety_rules_config,
            InitialSafetyRulesConfig::None
        ) {
            let identity_blob = config
                .initial_safety_rules_config
                .identity_blob()
                .expect("No identity blob in initial safety rules config");
            let waypoint = config.initial_safety_rules_config.waypoint();

            let backend = &config.backend;
            let internal_storage: Storage = backend.into();
            PersistentSafetyStorage::initialize(
                internal_storage,
                identity_blob
                    .account_address
                    .expect("AccountAddress needed for safety rules"),
                identity_blob
                    .consensus_private_key
                    .expect("Consensus key needed for safety rules"),
                waypoint,
                config.enable_cached_safety_data,
            )
        } else {
            panic!(
                "Safety rules storage is not initialized, provide an initial safety rules config"
            )
        };
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-17)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** docker/compose/aptos-node/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```
