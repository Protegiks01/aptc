# Audit Report

## Title
Config Buffer Race Condition Allows Governance Proposal Overwrites During DKG Reconfiguration

## Summary
A logic vulnerability in the epoch reconfiguration mechanism allows subsequently executed governance proposals to silently overwrite configuration changes from earlier approved proposals during Distributed Key Generation (DKG). When multiple consensus configuration governance proposals execute in the same epoch while DKG is in progress, only the last proposal's configuration is applied, violating governance integrity.

## Finding Description

The vulnerability exists in the interaction between the config buffering system and the DKG-based reconfiguration mechanism. The issue occurs through the following code paths:

**Step 1: Config Buffer Overwrite**

When governance proposals execute, they call `consensus_config::set_for_next_epoch()` which buffers the configuration using `config_buffer::upsert()`: [1](#0-0) 

The `config_buffer::upsert()` function uses `simple_map::upsert()` to store the configuration: [2](#0-1) 

The critical issue is that `simple_map::upsert()` replaces any existing buffered value for the same key: [3](#0-2) 

**Step 2: DKG Early Return**

When governance proposals call `aptos_governance::reconfigure()`, if DKG is enabled, it invokes `reconfiguration_with_dkg::try_start()`: [4](#0-3) 

If a DKG session already exists for the current epoch, `try_start()` returns immediately without triggering a new reconfiguration: [5](#0-4) 

This means:
- Proposal 1: Buffers config_A via `upsert()`, calls `reconfigure()` which starts DKG
- Proposal 2: **Overwrites buffer with config_B** via `upsert()`, calls `reconfigure()` but `try_start()` exits early (DKG already in progress)
- DKG completes: Applies **config_B** instead of config_A

**Step 3: Wrong Config Applied**

When DKG finishes, `reconfiguration_with_dkg::finish()` applies all buffered configs: [6](#0-5) 

The `consensus_config::on_new_epoch()` extracts whatever is in the buffer: [7](#0-6) 

The `extract_v2()` retrieves the most recently buffered config (config_B from the second proposal), not config_A from the first approved proposal.

**No Protection Against Concurrent Executions**

Unlike stake operations which check reconfiguration state using `reconfiguration_state::is_in_progress()`: [8](#0-7) 

There is no such guard in the governance execution flow. The `set_for_next_epoch()` and `reconfigure()` functions do not check if a reconfiguration is already in progress.

## Impact Explanation

This is a **HIGH severity** vulnerability representing a significant protocol violation:

1. **Governance Integrity Violation**: The core governance mechanism fails to execute approved proposals as intended. Each proposal is voted on independently and shows as "executed" in the governance system, but the first proposal's configuration is silently discarded with no error or event.

2. **Silent Failure**: There is no indication that the first proposal's configuration was discarded. The blockchain state shows both proposals as "executed," creating an inconsistency between governance records and actual applied configurations.

3. **Potential Consensus Impact**: Consensus configuration parameters control critical security properties of the network. Depending on which parameters are modified, overwriting a security-enhancing configuration with a weaker one could compromise consensus safety, though this requires analysis of specific config parameter interactions.

4. **System Design Flaw**: The vulnerability exists even when all actors (governance participants, validators) are behaving correctly and legitimately. Two independently approved proposals executing in natural succession create the failure condition.

## Likelihood Explanation

**HIGH likelihood** - This can occur through natural network operation:

**Natural Occurrence Scenario:**
- Two legitimate governance proposals for consensus configuration updates are approved through normal voting processes
- The first proposal executes and starts a DKG session (which typically takes several minutes to complete)
- The second proposal executes before the DKG session completes
- Network operators expect both configurations to be applied in sequence, but only the second takes effect
- No indication is given that the first proposal's configuration was discarded

**Feasibility Factors:**
- DKG sessions can take minutes to complete, providing a large timing window
- No technical sophistication required - occurs through standard governance operations
- Can happen with completely legitimate governance activity
- No warning or protection mechanism exists to prevent this scenario

## Recommendation

Implement protection against concurrent governance config updates during reconfiguration:

1. **Add reconfiguration state check in `set_for_next_epoch()`**:
   ```move
   public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
       system_addresses::assert_aptos_framework(account);
       assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
       assert!(!reconfiguration_state::is_in_progress(), 
               error::invalid_state(ERECONFIGURATION_IN_PROGRESS));
       std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
   }
   ```

2. **Alternative: Buffer multiple configs per type** - Modify `config_buffer` to support queuing multiple configs for the same type, applying them in order.

3. **Alternative: Emit event on overwrite** - When `upsert()` replaces an existing config, emit an event to alert operators.

## Proof of Concept

```move
#[test_only]
module test_config_race {
    use aptos_framework::consensus_config;
    use aptos_framework::aptos_governance;
    use aptos_framework::config_buffer;
    use aptos_framework::reconfiguration_with_dkg;
    use std::vector;

    #[test(framework = @aptos_framework)]
    fun test_config_overwrite_during_dkg(framework: &signer) {
        // Setup: Enable DKG
        // ... initialization code ...

        // Proposal 1 executes: Buffer config_A and start DKG
        let config_a = vector[1, 2, 3, 4];
        consensus_config::set_for_next_epoch(framework, config_a);
        aptos_governance::reconfigure(framework); // Starts DKG

        // Proposal 2 executes while DKG in progress: Buffer config_B
        let config_b = vector[5, 6, 7, 8];
        consensus_config::set_for_next_epoch(framework, config_b); // Overwrites config_A
        aptos_governance::reconfigure(framework); // Returns early from try_start()

        // Verify: Only config_B is buffered, config_A is lost
        assert!(config_buffer::does_exist<ConsensusConfig>(), 1);
        // When DKG completes and on_new_epoch() is called,
        // only config_B will be applied, not config_A
    }
}
```

**Notes:**
- This is a logic vulnerability that violates governance integrity even when all participants act legitimately
- The vulnerability stems from the interaction between `simple_map::upsert()` (which replaces values by design) and the DKG early-return logic in `try_start()`
- Unlike stake operations, no reconfiguration state check exists in the governance config update path
- The issue affects any config type using the `config_buffer::upsert()` pattern, not just `ConsensusConfig`

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L59-69)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<ConsensusConfig>();
            if (exists<ConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L115-134)
```text
    /// Insert key/value pair or update an existing key to a new value
    public fun upsert<Key: store, Value: store>(
        self: &mut SimpleMap<Key, Value>,
        key: Key,
        value: Value
    ): (std::option::Option<Key>, std::option::Option<Value>) {
        let data = &mut self.data;
        let len = data.length();
        for (i in 0..len) {
            let element = data.borrow(i);
            if (&element.key == &key) {
                data.push_back(Element { key, value });
                data.swap(i, len);
                let Element { key, value } = data.pop_back();
                return (std::option::some(key), std::option::some(value))
            };
        };
        self.data.push_back(Element { key, value });
        (std::option::none(), std::option::none())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1910-1912)
```text
    fun assert_reconfig_not_in_progress() {
        assert!(!reconfiguration_state::is_in_progress(), error::invalid_state(ERECONFIGURATION_IN_PROGRESS));
    }
```
