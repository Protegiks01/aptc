# Audit Report

## Title
Malicious Peer Can Cause State Sync DoS via False Epoch Range Advertisement

## Summary
A malicious peer can advertise falsely inflated `epoch_ending_ledger_infos` ranges without validation, causing syncing nodes to target unreachable epochs. This results in repeated failed requests, wasted resources, and temporary loss of sync liveness until the malicious peer is eventually ignored.

## Finding Description

In the state sync aggregation logic, when `calculate_global_data_summary()` collects epoch ranges from peers, there is no validation that advertised ranges are consistent with each peer's actual synced state: [1](#0-0) 

The aggregation blindly trusts peer advertisements and pushes all ranges without checking if the advertised `epoch_ending_ledger_infos` range is consistent with the peer's `synced_ledger_info`.

**Attack Scenario:**

1. A malicious peer constructs a `DataSummary` advertising:
   - `synced_ledger_info`: Legitimate ledger info at epoch 50
   - `epoch_ending_ledger_infos`: CompleteDataRange(0, 10000) - falsely claiming epochs 0-10000

2. When honest peers advertise only epochs 0-50, the `highest_epoch_ending_ledger_info()` method returns 10000 from the malicious peer: [2](#0-1) 

3. The `EpochEndingStreamEngine` initializes with `end_epoch = 10000`: [3](#0-2) 

4. The stream engine tries to fetch epochs 51-10000, but these don't exist. Requests to the malicious peer fail validation: [4](#0-3) 

5. The malicious peer is penalized via `ErrorType::NotUseful` (0.95 multiplier), requiring approximately 4 failed requests to drop below the ignore threshold: [5](#0-4) 

6. During this period, the node wastes resources attempting to fetch non-existent data and cannot complete bootstrapping.

Honest peers correctly construct ranges based on their actual highest ended epoch: [6](#0-5) 

However, there is no validation at the aggregation layer to verify this consistency when ranges are received from remote peers.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Syncing nodes experience significant delays trying to fetch non-existent epochs, wasting CPU and network resources on repeated failed requests.

- **Protocol violations**: The state sync protocol's integrity is compromised as nodes commit to unrealistic sync targets based on false peer advertisements.

- **Temporary liveness impact**: During the attack window (multiple request cycles), affected nodes cannot make forward sync progress, remaining stuck at lower epochs.

While the system eventually recovers by ignoring the malicious peer and recreating streams, the recovery process involves:
- Multiple failed request attempts (4+)
- Stream timeout and recreation
- Recalculation of global summary excluding the malicious peer
- Total delay of potentially minutes depending on timeout configurations

## Likelihood Explanation

**High likelihood**:

- **Low attack complexity**: Any network peer can advertise false ranges via storage summary responses
- **No authentication required**: The attack requires no special privileges beyond network connectivity
- **Difficult to detect**: False ranges appear valid until requests fail, and the system treats this as normal peer unavailability rather than malicious behavior
- **Scalable**: Multiple malicious peers can amplify the attack by advertising different false ranges
- **Persistent**: Until ignored, the same malicious peer can be repeatedly selected for requests due to priority-based peer selection

The attack is particularly effective during bootstrapping when nodes rely heavily on epoch ending ledger info streams to catch up to the network.

## Recommendation

Add validation when receiving `StorageServerSummary` to ensure `epoch_ending_ledger_infos` range is consistent with `synced_ledger_info`:

```rust
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Validate epoch range consistency
    if let (Some(synced_ledger_info), Some(epoch_range)) = (
        &storage_summary.data_summary.synced_ledger_info,
        &storage_summary.data_summary.epoch_ending_ledger_infos,
    ) {
        let synced_epoch = synced_ledger_info.ledger_info().epoch();
        let advertised_highest = epoch_range.highest();
        
        // Allow at most one epoch ahead (for epoch boundary edge cases)
        if advertised_highest > synced_epoch + 1 {
            warn!(
                "Rejecting inconsistent storage summary from peer {:?}: \
                 advertised epoch range highest {} exceeds synced epoch {} + 1",
                peer, advertised_highest, synced_epoch
            );
            // Penalize peer for false advertising
            self.peer_to_state
                .get_mut(&peer)
                .map(|mut state| state.update_score_error(ErrorType::Malicious));
            return;
        }
    }
    
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}
```

Additionally, consider adding periodic re-validation of stored summaries against actual request outcomes to detect and evict stale or falsely advertising peers more aggressively.

## Proof of Concept

```rust
#[tokio::test]
async fn test_false_epoch_range_dos_attack() {
    use aptos_config::config::AptosDataClientConfig;
    use aptos_storage_service_types::{
        responses::{CompleteDataRange, DataSummary, ProtocolMetadata, StorageServerSummary},
    };
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use std::sync::Arc;
    
    // Setup peer states
    let config = Arc::new(AptosDataClientConfig::default());
    let peer_states = PeerStates::new(config);
    
    // Honest peer advertises epochs 0-50
    let honest_peer = PeerNetworkId::random();
    let honest_summary = create_storage_summary_with_epochs(50);
    peer_states.update_summary(honest_peer, honest_summary);
    
    // Malicious peer advertises epochs 0-10000 (false)
    let malicious_peer = PeerNetworkId::random();
    let mut malicious_summary = create_storage_summary_with_epochs(50); // Actually at epoch 50
    malicious_summary.data_summary.epoch_ending_ledger_infos = 
        Some(CompleteDataRange::from_genesis(10000)); // But claims 10000
    peer_states.update_summary(malicious_peer, malicious_summary);
    
    // Calculate global summary
    let global_summary = peer_states.calculate_global_data_summary();
    
    // Verify the attack: highest epoch is falsely 10000
    let highest_epoch = global_summary
        .advertised_data
        .highest_epoch_ending_ledger_info()
        .unwrap();
    assert_eq!(highest_epoch, 10000); // Should be 50 if validated!
    
    // This will cause stream engine to target epoch 10000
    // leading to multiple failed requests before malicious peer is ignored
}

fn create_storage_summary_with_epochs(epoch: u64) -> StorageServerSummary {
    let ledger_info = LedgerInfo::new(
        BlockInfo::empty(),
        HashValue::zero(),
    );
    let synced_ledger_info = LedgerInfoWithSignatures::new(
        ledger_info,
        AggregateSignature::empty(),
    );
    
    StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(synced_ledger_info),
            epoch_ending_ledger_infos: Some(CompleteDataRange::from_genesis(epoch)),
            transactions: None,
            transaction_outputs: None,
            states: None,
        },
    }
}
```

This PoC demonstrates how a malicious peer can poison the global summary with false epoch ranges, causing syncing nodes to target unreachable epochs and waste resources.

## Notes

The vulnerability exists because the state sync system optimistically trusts peer advertisements during aggregation, deferring validation to request time. While cryptographic verification eventually catches invalid data, the lack of upfront sanity checking allows malicious peers to manipulate sync targets and cause resource exhaustion. The fix should validate range consistency at advertisement time rather than waiting for request failures.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L365-369)
```rust
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L176-181)
```rust
    pub fn highest_epoch_ending_ledger_info(&self) -> Option<Epoch> {
        self.epoch_ending_ledger_infos
            .iter()
            .map(|epoch_range| epoch_range.highest())
            .max()
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1486-1494)
```rust
    ) -> Result<Self, Error> {
        let end_epoch = advertised_data
            .highest_epoch_ending_ledger_info()
            .ok_or_else(|| {
                Error::DataIsUnavailable(format!(
                    "Unable to find any epoch ending ledger info in the network: {:?}",
                    advertised_data
                ))
            })?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1027-1032)
```rust
        ensure!(
            end_epoch <= latest_epoch,
            "Unable to provide epoch change ledger info for still open epoch. asked upper bound: {}, last sealed epoch: {}",
            end_epoch,
            latest_epoch - 1,  // okay to -1 because genesis LedgerInfo has .next_block_epoch() == 1
        );
```

**File:** state-sync/storage-service/server/src/storage.rs (L1042-1053)
```rust
        let epoch_ending_ledger_infos = if latest_ledger_info.ends_epoch() {
            let highest_ending_epoch = latest_ledger_info.epoch();
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else if latest_ledger_info.epoch() > 0 {
            let highest_ending_epoch =
                latest_ledger_info.epoch().checked_sub(1).ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Highest ending epoch overflowed!".into())
                })?;
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else {
            None // We haven't seen an epoch change yet
        };
```
