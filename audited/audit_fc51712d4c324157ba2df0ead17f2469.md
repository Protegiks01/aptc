# Audit Report

## Title
Type Safety Bypass in Table Item API via Unvalidated Key/Value Types

## Summary
The `table_item()` REST API endpoint accepts user-provided `key_type` and `value_type` parameters without validating them against the actual table's stored `TableInfo`. When combined with the `undecorate()` call that strips type information from keys, this allows attackers to access table items using structurally-equivalent but semantically-different types, breaking Move's type safety guarantees at the API layer. [1](#0-0) 

## Finding Description

The vulnerability exists in the table item retrieval flow within the REST API. When a client requests a table item via POST `/tables/:table_handle/item`, they provide three parameters in the `TableItemRequest`: [2](#0-1) 

The API accepts these user-provided types without validation against the table's actual stored type information. The attack flow proceeds as follows:

1. **Key Conversion**: The user-provided `key` is converted to a Move value using the user-supplied `key_type` [3](#0-2) 

2. **Type Information Loss**: The `undecorate()` method strips field names and structural type information, reducing structs to their runtime representation [4](#0-3) [5](#0-4) 

3. **Structural Type Equivalence**: Two different struct types with identical field layouts serialize to identical byte sequences after undecoration. For example, `struct KeyA { x: u64 }` and `struct KeyB { x: u64 }` produce the same serialized key.

4. **Value Deserialization**: The retrieved value is deserialized using the user-provided `value_type`, not the actual table's value type [6](#0-5) 

**Attack Scenario:**
```
// On-chain: Table<0x1::module_a::KeyType, 0x1::module_a::ValueType> created
// Attacker's API request uses:
//   key_type: "0x1::module_b::FakeKeyType"  (same layout as KeyType)
//   value_type: "0x1::module_b::FakeValueType" (different layout)
// Result: Table value reinterpreted as wrong type
```

The API **should** retrieve and validate the `TableInfo` stored when the table was created: [7](#0-6) 

However, the `table_item()` function never calls `get_table_info()` to perform this validation, despite the converter having access to it: [8](#0-7) 

## Impact Explanation

This vulnerability represents a **Medium Severity** issue based on the following analysis:

**What This Does NOT Affect:**
- **Consensus Layer**: Validator nodes do not use this REST API for execution or state validation
- **On-Chain State**: The blockchain state remains consistent; only the API's interpretation is affected
- **Move VM Execution**: Transaction execution still enforces type safety correctly
- **Write Operations**: Attackers cannot modify table data, only read it with incorrect type interpretation

**Actual Impact:**
- **Type Safety Violation**: Breaks Move's type safety guarantees at the API boundary
- **Information Confusion**: Clients receive structurally-valid but semantically-incorrect data
- **Dependent System Risk**: Applications relying on API-level type validation for security decisions could be compromised
- **Limited Information Disclosure**: Reinterpreting binary data as different types might reveal unintended information patterns

This maps to **Medium Severity** under "State inconsistencies requiring intervention" - while the on-chain state is correct, the API provides an inconsistent view that could require manual investigation and client-side fixes. It does not qualify as High or Critical because it doesn't affect validator operations, consensus, or direct fund access.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially executable:
- No special privileges required (any API user can exploit this)
- No race conditions or timing dependencies
- Simple HTTP POST request with modified type parameters
- Attacker only needs to know: (1) a table handle, (2) struct types with equivalent layouts

The barrier to exploitation is minimal, requiring only:
1. Knowledge of existing table handles (observable on-chain)
2. Understanding of Move struct layouts (publicly available in module ABIs)
3. Basic ability to craft HTTP requests to the REST API

## Recommendation

**Fix: Validate user-provided types against stored TableInfo**

The `table_item()` function should retrieve the table's actual `TableInfo` and validate that the user-provided `key_type` and `value_type` match the stored types:

```rust
pub fn table_item(
    &self,
    accept_type: &AcceptType,
    table_handle: Address,
    table_item_request: TableItemRequest,
    ledger_version: Option<U64>,
) -> BasicResultWith404<MoveValue> {
    // Parse user-provided types
    let requested_key_type: TypeTag = (&table_item_request.key_type)
        .try_into()
        .context("Failed to parse key_type")?;
    let requested_value_type: TypeTag = (&table_item_request.value_type)
        .try_into()
        .context("Failed to parse value_type")?;
    
    let (ledger_info, ledger_version, state_view) = self
        .context
        .state_view(ledger_version.map(|inner| inner.0))?;
    
    let converter = state_view.as_converter(
        self.context.db.clone(), 
        self.context.indexer_reader.clone()
    );
    
    // **ADD VALIDATION HERE**
    let table_info = converter
        .get_table_info(TableHandle(table_handle.into()))
        .context("Failed to retrieve table info")?
        .ok_or_else(|| {
            BasicErrorWith404::not_found_with_code(
                "Table not found",
                AptosErrorCode::TableItemNotFound,
                &ledger_info
            )
        })?;
    
    // Validate types match
    if table_info.key_type != requested_key_type {
        return Err(BasicErrorWith404::bad_request_with_code(
            format!(
                "Key type mismatch: table expects {:?}, but request provided {:?}",
                table_info.key_type, requested_key_type
            ),
            AptosErrorCode::InvalidInput,
            &ledger_info
        ));
    }
    
    if table_info.value_type != requested_value_type {
        return Err(BasicErrorWith404::bad_request_with_code(
            format!(
                "Value type mismatch: table expects {:?}, but request provided {:?}",
                table_info.value_type, requested_value_type
            ),
            AptosErrorCode::InvalidInput,
            &ledger_info
        ));
    }
    
    // Continue with existing logic...
    let vm_key = converter.try_into_vm_value(&requested_key_type, key)?;
    // ... rest of implementation
}
```

## Proof of Concept

```move
// File: test_type_confusion.move
module 0xCAFE::exploit_test {
    use std::table::{Self, Table};
    
    // Legitimate table types
    struct LegitKey has copy, drop, store { id: u64 }
    struct LegitValue has copy, drop, store { balance: u64 }
    
    // Attacker's structurally-identical types
    struct FakeKey has copy, drop, store { id: u64 }  // Same layout
    struct FakeValue has copy, drop, store { data: u64 }  // Different semantic meaning
    
    struct TableHolder has key {
        legitimate_table: Table<LegitKey, LegitValue>
    }
    
    public entry fun create_table(account: &signer) {
        let table = table::new<LegitKey, LegitValue>();
        table::add(&mut table, LegitKey { id: 1 }, LegitValue { balance: 1000 });
        move_to(account, TableHolder { legitimate_table: table });
    }
}
```

**Exploitation Steps:**

1. Deploy the module and create a table:
```bash
aptos move publish --named-addresses exploit_test=0xCAFE
aptos move run --function-id 0xCAFE::exploit_test::create_table
```

2. Get the table handle from the created resource

3. Craft malicious API request:
```bash
curl -X POST http://fullnode:8080/v1/tables/{TABLE_HANDLE}/item \
  -H "Content-Type: application/json" \
  -d '{
    "key_type": "0xCAFE::exploit_test::FakeKey",
    "value_type": "0xCAFE::exploit_test::FakeValue",
    "key": { "id": "1" }
  }'
```

**Expected Result (without fix):** API returns the value reinterpreted as `FakeValue`, bypassing type safety

**Expected Result (with fix):** API returns error: "Key type mismatch: table expects 0xCAFE::exploit_test::LegitKey, but request provided 0xCAFE::exploit_test::FakeKey"

**Notes:**
- The vulnerability exists specifically at line 421 where `undecorate()` strips type information from struct keys
- The root cause is missing validation against `TableInfo` despite having access to it via the indexer
- This breaks the Move type system's invariant that values can only be accessed with their declared types
- Impact is limited to the REST API layer and does not affect on-chain execution or consensus

### Citations

**File:** api/src/state.rs (L381-468)
```rust
    pub fn table_item(
        &self,
        accept_type: &AcceptType,
        table_handle: Address,
        table_item_request: TableItemRequest,
        ledger_version: Option<U64>,
    ) -> BasicResultWith404<MoveValue> {
        // Parse the key and value types for the table
        let key_type = (&table_item_request.key_type)
            .try_into()
            .context("Failed to parse key_type")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        let key = table_item_request.key;
        let value_type = (&table_item_request.value_type)
            .try_into()
            .context("Failed to parse value_type")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;

        // Retrieve local state
        let (ledger_info, ledger_version, state_view) = self
            .context
            .state_view(ledger_version.map(|inner| inner.0))?;

        let converter =
            state_view.as_converter(self.context.db.clone(), self.context.indexer_reader.clone());

        // Convert key to lookup version for DB
        let vm_key = converter
            .try_into_vm_value(&key_type, key.clone())
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &ledger_info,
                )
            })?;
        let raw_key = vm_key.undecorate().simple_serialize().ok_or_else(|| {
            BasicErrorWith404::bad_request_with_code(
                "Failed to serialize table key",
                AptosErrorCode::InvalidInput,
                &ledger_info,
            )
        })?;

        // Retrieve value from the state key
        let state_key = StateKey::table_item(&TableHandle(table_handle.into()), &raw_key);
        let bytes = state_view
            .get_state_value_bytes(&state_key)
            .context(format!(
                "Failed when trying to retrieve table item from the DB with key: {}",
                key
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
            .ok_or_else(|| {
                table_item_not_found(table_handle, &key, ledger_version, &ledger_info)
            })?;

        match accept_type {
            AcceptType::Json => {
                let move_value = converter
                    .try_into_move_value(&value_type, &bytes)
                    .context("Failed to deserialize table item retrieved from DB")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &ledger_info,
                        )
                    })?;

                BasicResponse::try_from_json((move_value, &ledger_info, BasicResponseStatus::Ok))
            },
            AcceptType::Bcs => BasicResponse::try_from_encoded((
                bytes.to_vec(),
                &ledger_info,
                BasicResponseStatus::Ok,
            )),
        }
```

**File:** api/types/src/table.rs (L9-16)
```rust
/// Table Item request for the GetTableItem API
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct TableItemRequest {
    pub key_type: MoveType,
    pub value_type: MoveType,
    /// The value of the table item's key
    pub key: Value,
}
```

**File:** third_party/move/move-core/types/src/value.rs (L467-487)
```rust
    pub fn undecorate(self) -> Self {
        match self {
            MoveStruct::WithFields(fields)
            | MoveStruct::WithTypes {
                _fields: fields, ..
            } => Self::Runtime(
                fields
                    .into_iter()
                    .map(|(_, v)| MoveValue::undecorate(v))
                    .collect(),
            ),
            MoveStruct::WithVariantFields(_, tag, fields) => Self::RuntimeVariant(
                tag,
                fields
                    .into_iter()
                    .map(|(_, v)| MoveValue::undecorate(v))
                    .collect(),
            ),
            _ => self,
        }
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L376-381)
```rust
    let key_type = context.type_to_type_tag(&ty_args[0])?;
    let value_type = context.type_to_type_tag(&ty_args[1])?;
    assert!(table_data
        .new_tables
        .insert(TableHandle(handle), TableInfo::new(key_type, value_type))
        .is_none());
```

**File:** api/types/src/convert.rs (L1060-1065)
```rust
    fn get_table_info(&self, handle: TableHandle) -> Result<Option<TableInfo>> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            return Ok(indexer_reader.get_table_info(handle).unwrap_or(None));
        }
        Ok(None)
    }
```
