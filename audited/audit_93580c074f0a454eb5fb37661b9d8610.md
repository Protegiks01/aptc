# Audit Report

## Title
Mempool DoS via Unbounded Parking Lot Address Iteration Holding Critical Lock

## Summary
The `GetAddressesFromParkingLot` endpoint iterates over all parked transaction addresses without pagination while holding the mempool lock, enabling denial-of-service attacks against nodes with accessible admin services. An attacker who can populate the parking lot with transactions from many addresses and access the admin service endpoint can repeatedly trigger expensive O(n) iterations that block critical mempool operations.

## Finding Description

The vulnerability exists in the parking lot address query mechanism exposed via the admin service. When a client calls the `/debug/mempool/parking-lot/addresses` endpoint, the following execution path occurs:

1. **HTTP Request Handler**: The admin service receives the request and forwards it to the mempool client [1](#0-0) 

2. **Task Spawning**: The coordinator spawns a task via bounded executor to process the request [2](#0-1) 

3. **Lock Acquisition and Iteration**: The task acquires the mempool lock and calls `get_parking_lot_addresses()` [3](#0-2) 

4. **Unbounded Iteration**: The `get_addresses()` method iterates over ALL addresses in the parking lot without any limit or pagination [4](#0-3) 

**Attack Scenario:**

An attacker can exploit this by:

1. **Populating the Parking Lot**: Submit transactions from many different accounts with future sequence numbers (e.g., sequence 100 when account is at sequence 0). These transactions become "non-ready" and are stored in the parking lot. [5](#0-4) 

2. **Triggering Repeated Queries**: With the parking lot containing 10,000+ addresses, repeatedly call the admin endpoint. The mempool has capacity for 2 million transactions with 100 per user, meaning up to 20,000 addresses could be parked. [6](#0-5) 

3. **Lock Contention**: While iterating over addresses, the mempool lock is held, blocking:
   - Transaction submissions from clients
   - Consensus pulling transactions for block proposals
   - Transaction broadcasts to other nodes
   - Mempool garbage collection

The bounded executor limits concurrent processing to 4 tasks by default but still queues requests, meaning repeated calls accumulate: [7](#0-6) [8](#0-7) 

**Access to Admin Service:**

The admin service binds to all network interfaces (0.0.0.0) by default with no authentication configured: [9](#0-8) 

While the service is disabled on mainnet, it's enabled on testnet and devnet where misconfigured nodes may expose it publicly: [10](#0-9) 

The authentication check allows unauthenticated access when `authentication_configs` is empty: [11](#0-10) 

## Impact Explanation

This is a **Medium severity** vulnerability per Aptos bug bounty criteria because it enables node-level denial of service:

- **Validator Node Slowdown**: Repeated queries can cause significant mempool lock contention, degrading transaction processing throughput
- **API Degradation**: Client transaction submissions experience delays or timeouts when the mempool lock is held
- **Consensus Impact**: Quorum store requests to pull transactions for batches may be delayed, affecting block proposal times

The impact is limited to individual nodes rather than network-wide consensus disruption, preventing this from reaching High/Critical severity. However, if multiple validators are targeted simultaneously on testnet/devnet, it could cause observable network degradation.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires two conditions:

1. **Access to Admin Service Endpoint**: 
   - On mainnet: Unlikely (service disabled by default)
   - On testnet/devnet: Moderate (service enabled, but should be firewalled)
   - Misconfigured production nodes: Low but possible

2. **Populated Parking Lot**:
   - Easy to achieve by submitting transactions with future sequence numbers
   - Costs minimal gas as transactions can be crafted to park without execution

The bounded executor provides limited protection (4 concurrent tasks) but doesn't prevent request queueing. An attacker needs sustained access to the endpoint to maintain DoS pressure.

The combination of default insecure configuration and legitimate debugging use case (operators may intentionally expose for monitoring) makes exploitation feasible on testnet/devnet environments.

## Recommendation

Implement multiple defensive layers:

1. **Add Pagination**: Limit addresses returned per request with offset/limit parameters
2. **Release Lock During Collection**: Collect addresses in batches, releasing and reacquiring lock between batches
3. **Rate Limiting**: Implement per-IP rate limiting on admin service endpoints
4. **Authentication by Default**: Require authentication even on non-mainnet networks
5. **Binding Configuration**: Default to localhost binding instead of 0.0.0.0

**Proposed Fix** for `ParkingLotIndex::get_addresses()`:

```rust
pub(crate) fn get_addresses_paginated(&self, offset: usize, limit: usize) -> Vec<(AccountAddress, u64)> {
    self.data
        .iter()
        .skip(offset)
        .take(limit)
        .map(|(addr, txns)| (*addr, txns.len() as u64))
        .collect::<Vec<(AccountAddress, u64)>>()
}

pub(crate) fn get_addresses_count(&self) -> usize {
    self.data.len()
}
```

Update the admin service handler to accept pagination parameters and document maximum result size.

## Proof of Concept

```rust
// Test demonstrating the DoS vector
#[tokio::test]
async fn test_parking_lot_query_dos() {
    use aptos_mempool::*;
    use aptos_types::transaction::*;
    
    // 1. Setup mempool with test configuration
    let mempool = setup_test_mempool();
    
    // 2. Populate parking lot with 10,000 accounts, each with future seq numbers
    for i in 0..10_000 {
        let account = AccountAddress::random();
        // Submit transaction with seq_num = 100 when account is at seq_num = 0
        let txn = create_test_transaction(account, 100);
        mempool.add_txn(txn, 0, None, TimelineState::NotReady, false, None, None);
    }
    
    // 3. Measure lock contention by making repeated queries
    let start = Instant::now();
    let mut durations = vec![];
    
    for _ in 0..100 {
        let query_start = Instant::now();
        let _addresses = mempool.lock().get_parking_lot_addresses();
        durations.push(query_start.elapsed());
    }
    
    let total_time = start.elapsed();
    let avg_duration = durations.iter().sum::<Duration>() / durations.len() as u32;
    
    // With 10,000 addresses, each query takes significant time holding the lock
    println!("Average query time: {:?}", avg_duration);
    println!("Total time for 100 queries: {:?}", total_time);
    
    // Assert that lock is held during entire iteration
    // This blocks other mempool operations
    assert!(avg_duration.as_millis() > 10); // Each iteration is expensive
}
```

To reproduce on a live testnet node:

1. Configure node with admin service exposed (already default on testnet)
2. Submit 10,000 transactions with future sequence numbers to populate parking lot
3. Execute HTTP requests: `curl http://node-ip:9102/debug/mempool/parking-lot/addresses`
4. Observe mempool lock contention and delayed transaction processing

## Notes

This vulnerability represents a defense-in-depth failure where administrative interfaces lack proper resource controls. While the admin service is intended for debugging and should be protected by network-level access controls, the default insecure configuration and absence of pagination/rate limiting create an exploitable attack surface on misconfigured nodes.

The issue is particularly relevant for testnet/devnet infrastructure where operators may prioritize observability over security hardening, potentially exposing these endpoints. The parking lot can legitimately grow large during high load or network issues, making the DoS trigger easier to reach even without malicious parking lot population.

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-157)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L230-240)
```rust
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
```

**File:** mempool/src/shared_mempool/coordinator.rs (L219-223)
```rust
        MempoolClientRequest::GetAddressesFromParkingLot(callback) => {
            bounded_executor
                .spawn(tasks::process_parking_lot_addresses(smp.clone(), callback))
                .await;
        },
```

**File:** mempool/src/shared_mempool/tasks.rs (L168-184)
```rust
pub(crate) async fn process_parking_lot_addresses<NetworkClient, TransactionValidator>(
    smp: SharedMempool<NetworkClient, TransactionValidator>,
    callback: oneshot::Sender<Vec<(AccountAddress, u64)>>,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg>,
    TransactionValidator: TransactionValidation + 'static,
{
    let addresses = smp.mempool.lock().get_parking_lot_addresses();

    if callback.send(addresses).is_err() {
        warn!(LogSchema::event_log(
            LogEntry::JsonRpc,
            LogEvent::CallbackFail
        ));
        counters::CLIENT_CALLBACK_FAIL.inc();
    }
}
```

**File:** mempool/src/core_mempool/index.rs (L652-657)
```rust
    pub(crate) fn get_addresses(&self) -> Vec<(AccountAddress, u64)> {
        self.data
            .iter()
            .map(|(addr, txns)| (*addr, txns.len() as u64))
            .collect::<Vec<(AccountAddress, u64)>>()
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L615-623)
```rust
            for (_, txn) in txns.seq_num_range_mut((Bound::Excluded(min_seq), Bound::Unbounded)) {
                match txn.timeline_state {
                    TimelineState::Ready(_) => {},
                    _ => {
                        self.parking_lot_index.insert(txn);
                        parking_lot_txns += 1;
                    },
                }
            }
```

**File:** config/src/config/mempool_config.rs (L116-116)
```rust
            shared_mempool_max_concurrent_inbound_syncs: 4,
```

**File:** config/src/config/mempool_config.rs (L121-123)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
```

**File:** crates/bounded-executor/src/executor.rs (L41-52)
```rust
    /// Spawn a [`Future`] on the `BoundedExecutor`. This function is async and
    /// will block if the executor is at capacity until one of the other spawned
    /// futures completes. This function returns a [`JoinHandle`] that the caller
    /// can `.await` on for the results of the [`Future`].
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```

**File:** config/src/config/admin_service_config.rs (L45-47)
```rust
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
```

**File:** config/src/config/admin_service_config.rs (L94-100)
```rust
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```
