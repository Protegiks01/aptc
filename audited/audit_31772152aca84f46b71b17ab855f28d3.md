# Audit Report

## Title
Public Exposure of Failpoint Control Endpoint Allows Unauthenticated Remote Consensus Disruption on Non-Mainnet Networks

## Summary
The `/v1/set_failpoint` REST API endpoint lacks IP-based access control, authentication, and authorization mechanisms. When failpoints are enabled on testnet/devnet nodes with public API exposure (`0.0.0.0:8080`), external attackers can remotely configure failpoints to cause consensus liveness failures, execution delays, and network partitioning without any credentials.

## Finding Description

The `/v1/set_failpoint` endpoint is registered in the API routing configuration [1](#0-0)  without any access control middleware. The handler implementation [2](#0-1)  only verifies that `failpoints_enabled` is true in the node configuration—it performs no IP filtering, authentication, or authorization checks.

Production fullnode configurations bind the API to all network interfaces [3](#0-2)  and [4](#0-3) , making the endpoint publicly accessible when failpoints are enabled.

Failpoints are testing mechanisms that inject controlled failures at specific code locations. Critical failpoints include:
- **Consensus message dropping** [5](#0-4)  and [6](#0-5) 
- **Proposal processing errors** [7](#0-6) 
- **Execution delays** as demonstrated in test code [8](#0-7) 

An attacker sending GET requests to `http://<node-ip>:8080/v1/set_failpoint?name=consensus::send::any&actions=100%return` can force validators to drop all consensus messages, causing immediate liveness failure.

While mainnet is protected by config sanitization [9](#0-8) , testnet and devnet nodes commonly enable failpoints for testing, creating a critical attack surface.

## Impact Explanation

**Critical Severity** per Aptos Bug Bounty criteria:

1. **Total Loss of Liveness**: Attackers can configure `consensus::send::any` or `consensus::send::broadcast_proposal` failpoints to prevent block production across the network
2. **Network Partition**: Selective message dropping can create non-recoverable network splits
3. **Consensus Safety Violations**: Injecting errors in proposal processing can cause validators to diverge on committed state

The vulnerability enables unprivileged remote attackers to achieve the same disruption capabilities as Byzantine validator operators without requiring stake, validator keys, or network insider access. This breaks the fundamental security assumption that only validators with 1/3+ stake can disrupt consensus.

## Likelihood Explanation

**High Likelihood** on affected networks:

- Testnet/devnet operators routinely enable failpoints for fault injection testing
- Production deployment templates default to `0.0.0.0:8080` binding for public API access
- No documentation warns operators to restrict failpoint endpoints to localhost
- Attack requires only HTTP client access (curl, browser, or script)
- Zero authentication barrier—any internet user can exploit this

The only mitigation is that `failpoints_enabled=false` by default [10](#0-9) , but this is explicitly overridden when running fault tolerance tests.

## Recommendation

Implement multiple layers of defense:

1. **Add IP allowlist enforcement** in the failpoint handler to restrict access to localhost/trusted IPs
2. **Require authentication** via API key or signature verification
3. **Add explicit warning** in configuration documentation that failpoint endpoints must never be publicly exposed
4. **Consider feature flag separation**: Move failpoint control to a separate admin API on a different port bound to localhost only

**Proposed fix** for `api/src/set_failpoints.rs`:

```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    remote_addr: &RemoteAddr,
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    // SECURITY: Restrict failpoint configuration to localhost only
    if let Some(addr) = remote_addr.as_socket_addr() {
        if !addr.ip().is_loopback() {
            return Err(poem::Error::from(anyhow::anyhow!(
                "Failpoint configuration is only allowed from localhost"
            )));
        }
    }
    
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

## Proof of Concept

**Setup**: Deploy Aptos testnet node with failpoints enabled

**Attack Steps**:
```bash
# Step 1: Verify node is vulnerable (testnet node at 203.0.113.10)
curl -X GET "http://203.0.113.10:8080/v1/set_failpoint?name=consensus::send::any&actions=100%return"

# Expected response if vulnerable: "Set failpoint consensus::send::any"

# Step 2: Observe consensus halts - no new blocks are produced

# Step 3: Alternative attack - execution delay
curl -X GET "http://203.0.113.10:8080/v1/set_failpoint?name=aptos_vm::execution::user_transaction&actions=100%delay(5000)"

# Result: All transaction executions delayed by 5 seconds

# Step 4: Disable failpoint to restore service
curl -X GET "http://203.0.113.10:8080/v1/set_failpoint?name=consensus::send::any&actions=off"
```

**Test validation** (from existing test suite showing failpoint usage): [11](#0-10) 

This demonstrates that the documented failpoint actions (`X%return`, `delay(ms)`) are fully functional and used extensively in testing to simulate Byzantine behavior—capabilities now available to unauthenticated attackers on misconfigured nodes.

### Citations

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L23-40)
```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** docker/compose/aptos-node/fullnode.yaml (L31-33)
```yaml
api:
  enabled: true
  address: "0.0.0.0:8080"
```

**File:** terraform/helm/aptos-node/files/configs/fullnode-base.yaml (L46-48)
```yaml
api:
  enabled: true
  address: "0.0.0.0:8080"
```

**File:** consensus/src/network.rs (L388-388)
```rust
        fail_point!("consensus::send::any", |_| ());
```

**File:** consensus/src/network.rs (L412-412)
```rust
        fail_point!("consensus::send::any", |_| ());
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** testsuite/testcases/src/modifiers.rs (L35-42)
```rust
            .set_failpoint(
                "aptos_vm::execution::user_transaction".to_string(),
                format!(
                    "{}%delay({})",
                    sleep_percentage, config.inject_delay_per_transaction_ms
                ),
            )
            .await
```

**File:** testsuite/testcases/src/modifiers.rs (L152-165)
```rust
            validator
                .set_failpoint(
                    "consensus::send::any".to_string(),
                    format!("{}%return", drop_percentage),
                )
                .await
                .map_err(|e| {
                    anyhow::anyhow!(
                        "set_failpoint to add unreliability on {} failed, {:?}",
                        name,
                        e
                    )
                })?;
        }
```

**File:** config/src/config/api_config.rs (L122-122)
```rust
            failpoints_enabled: default_disabled(),
```

**File:** config/src/config/api_config.rs (L178-184)
```rust
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
```
