# Audit Report

## Title
Unrestricted Network Topology Disclosure Through Inspection Service Peer Information Endpoint

## Summary
The Aptos inspection service exposes a `/peer_information` endpoint that reveals complete network topology information including the full validator set, network addresses, public keys, and trust relationships. This endpoint is enabled by default, publicly accessible, and lacks authentication or rate limiting, allowing any attacker to map the entire Aptos network infrastructure.

## Finding Description

The inspection service provides a `/peer_information` endpoint that is enabled by default and binds to all network interfaces (0.0.0.0:9101). [1](#0-0) 

This endpoint is routed through the main inspection service handler without any authentication checks. [2](#0-1) 

The endpoint exposes comprehensive network topology information including:

1. **Complete list of all connected peers** with their PeerNetworkIds and roles
2. **Trusted peers (validator set and seeds)** including their network addresses, x25519 public keys, and peer roles (Validator, ValidatorFullNode, etc.) [3](#0-2) 

3. **Connection metadata** showing connection states and detailed peer information [4](#0-3) 

4. **State sync metadata** revealing priority peers, regular peers, and data synchronization state [5](#0-4) 

The Peer structure contains sensitive information including network addresses, cryptographic public keys, and peer roles. [6](#0-5) 

**Critical Gap in Security Controls**: While the config sanitizer explicitly prevents mainnet validators from exposing the configuration endpoint, it does NOT prevent exposure of peer information. [7](#0-6) 

**Attack Scenario**:
1. Attacker sends HTTP GET requests to `http://<node-ip>:9101/peer_information` on accessible mainnet nodes
2. From the response, attacker extracts:
   - All validator peer IDs and their roles
   - Network addresses (IPs and ports) of validators
   - x25519 public keys for each validator
   - Connection topology showing which validators connect to which peers
3. Attacker repeats queries across multiple public fullnodes/validators to build a complete network map
4. With this intelligence, attacker can:
   - Launch targeted DDoS attacks on critical validators
   - Plan eclipse attacks by understanding network partitions
   - Identify single points of failure in the validator topology
   - Conduct sophisticated network-layer attacks with full topology knowledge

## Impact Explanation

This vulnerability falls under **High Severity** according to Aptos bug bounty criteria:

- **Significant Protocol Violations**: Exposing the complete validator network topology constitutes a significant breach of network security assumptions. The validator set composition, network addresses, and trust relationships should not be publicly queryable.

- **Enables Validator Node Slowdowns**: With complete network topology information, attackers can orchestrate targeted attacks on critical validators, potentially causing network degradation.

- **Information Disclosure at Scale**: This is not a minor information leak - it exposes the ENTIRE validator infrastructure including:
  - Exact validator count and identities
  - Physical network locations (IPs)
  - Cryptographic public keys
  - Trust hierarchies and connection patterns

The severity is elevated because:
1. **No authentication required** - any external party can access this information
2. **No rate limiting** - attackers can repeatedly query to track network changes
3. **Publicly accessible by default** - binds to 0.0.0.0, not localhost
4. **Affects mainnet validators** - the sanitizer fails to prevent this on production networks

## Likelihood Explanation

**Likelihood: Very High**

This vulnerability is trivially exploitable:
1. **Zero Prerequisites**: Requires only network access to any node exposing the inspection service (port 9101)
2. **Simple HTTP GET Request**: No special tools or sophisticated techniques needed - `curl http://<ip>:9101/peer_information`
3. **Default Configuration**: The endpoint is enabled by default with `expose_peer_information: true`
4. **No Detection**: Simple HTTP requests are difficult to distinguish from legitimate monitoring traffic

The vulnerability is already present on any node running with default configuration, which likely includes many mainnet validators and fullnodes. An attacker can immediately begin mapping the network topology without any technical barriers.

## Recommendation

**Immediate Mitigation**:
1. **Add Sanitizer Check for Mainnet**: Extend the config sanitizer to prevent `expose_peer_information` on mainnet validators, similar to the existing check for `expose_configuration`:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                // Prevent exposure of configuration
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // Prevent exposure of peer information
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                
                // Prevent exposure of identity information
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

2. **Change Default for Production**: Modify the default configuration to disable sensitive endpoints:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(),  // Bind to localhost only by default
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,  // Disable by default
            expose_peer_information: false,      // Disable by default
            expose_system_information: false,    // Disable by default
        }
    }
}
```

**Long-term Solutions**:
1. **Add Authentication**: Implement API key or token-based authentication for inspection endpoints
2. **Add Rate Limiting**: Prevent rapid enumeration of network topology
3. **Implement Access Control Lists**: Allow only specific IPs to access sensitive endpoints
4. **Audit Logging**: Log all access to peer information endpoint for security monitoring
5. **Reduce Exposed Information**: Even when enabled, consider redacting sensitive fields like network addresses and public keys

## Proof of Concept

**Step 1**: Query the peer information endpoint on a default-configured Aptos node:

```bash
# Query the peer information endpoint
curl http://<validator-ip>:9101/peer_information

# The response reveals:
# - All connected peers with their roles (Validator, ValidatorFullNode, etc.)
# - Network addresses (IPs and ports) for each peer
# - x25519 public keys
# - Connection states and trust relationships
# - State sync metadata showing priority peers
```

**Step 2**: Parse the output to extract validator information:

```bash
# Example response contains sections like:
# "Trusted peers (validator set & seeds):"
#   "- Network: Validator"
#     "- Peer: 0x123..., peer information: Peer { 
#         addresses: [/ip4/1.2.3.4/tcp/6180, ...],
#         keys: {...},
#         role: Validator
#       }"
```

**Step 3**: Repeat across multiple accessible nodes to build complete topology map:

```bash
# Query multiple fullnodes/validators
for node in node1.example.com node2.example.com node3.example.com; do
    echo "Querying $node..."
    curl http://$node:9101/peer_information > ${node}_peers.txt
done

# Correlation of responses reveals:
# - Complete validator set
# - Network connectivity patterns
# - Geographic distribution of validators
# - Trust relationships and network architecture
```

**Verification**: Run this on any Aptos testnet or devnet node with default configuration to confirm the vulnerability. The endpoint will return comprehensive network topology information without any authentication.

---

**Notes**

This vulnerability represents a critical oversight in the security hardening of the inspection service. While the developers recognized the need to protect the `expose_configuration` endpoint on mainnet validators, they failed to apply the same protection to `expose_peer_information`, `expose_identity_information`, and `expose_system_information`. The inconsistency in the sanitizer logic suggests this was an incomplete security review rather than an intentional design decision.

The default binding to `0.0.0.0` (all interfaces) rather than `127.0.0.1` (localhost only) further exacerbates the issue, making this information globally accessible rather than restricted to local debugging.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L54-64)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L147-155)
```rust
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L205-271)
```rust
/// Displays state sync metadata for each peer
fn display_state_sync_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    aptos_data_client: AptosDataClient,
) {
    peer_information_output.push("State sync metadata for each peer:".into());

    // Fetch and display the priority and regular peers
    if let Ok((priority_peers, regular_peers)) = aptos_data_client.get_priority_and_regular_peers()
    {
        // Sort the peer lists before displaying them
        let mut priority_peers: Vec<_> = priority_peers.into_iter().collect();
        priority_peers.sort();
        let mut regular_peers: Vec<_> = regular_peers.into_iter().collect();
        regular_peers.sort();

        // Display the priority and regular peers
        peer_information_output.push(format!(
            "\t- Priority peers: {:?}, regular peers: {:?}",
            priority_peers, regular_peers
        ));
    }

    // Fetch and display the global advertised data summary
    let global_data_summary = aptos_data_client.get_global_data_summary();
    peer_information_output.push(format!(
        "\t- Global advertised data summary: {:?}",
        global_data_summary
    ));

    // Fetch and display the state sync metadata for each peer
    let peer_to_state = aptos_data_client.get_peer_states().get_peer_to_states();
    for peer in all_peers {
        if let Some(peer_state_entry) = peer_to_state.get(peer) {
            // Get the peer states
            let peer = *peer_state_entry.key();
            let peer_bucket_id = peer_states::get_bucket_id_for_peer(peer);
            let peer_score = peer_state_entry.get_score();
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));

            // Get the peer's request/response counts
            let sent_requests_by_type = peer_state_entry.get_sent_requests_by_type();
            let received_responses_by_type = peer_state_entry.get_received_responses_by_type();

            // Display the peer's request/response counts
            peer_information_output.push(format!(
                "\t\t- Sent requests by type: {:?}",
                sent_requests_by_type
            ));
            peer_information_output.push(format!(
                "\t\t- Received responses by type: {:?}",
                received_responses_by_type
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** config/src/config/network_config.rs (L460-464)
```rust
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```
