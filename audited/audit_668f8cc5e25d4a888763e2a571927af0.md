# Audit Report

## Title
DKG Transcript Verification Panic Enables Validator DoS via Unbounded Witness Size

## Summary
A malicious validator acting as a DKG dealer can craft a transcript with an oversized `chunked_plaintexts` witness that causes other validators to panic during cryptographic verification. The panic occurs when a flattened witness vector exceeds the fixed MSM basis length, crashing validator nodes processing the malicious DKG result transaction.

## Finding Description

The vulnerability exists in the DKG transcript verification flow where untrusted witness data from a dealer is transformed without size validation, triggering a panic in the cryptographic commitment verification layer.

**Attack Path:**

1. A malicious dealer creates a `HkzgWeightedElgamalWitness` with an excessively large `chunked_plaintexts` field. [1](#0-0) 

2. This witness is embedded in the `SharingProof.SoK.z` field of a DKG transcript. [2](#0-1) 

3. The transcript is submitted as a `ValidatorTransaction::DKGResult` and processed by validator nodes. [3](#0-2) 

4. The VM calls `DefaultDKG::verify_transcript()` which invokes the transcript's sigma protocol verification. [4](#0-3) 

5. During verification, the system calls `hom.verify()` with the SoK proof containing the malicious witness. [5](#0-4) 

6. The verification flow reaches `LiftHomomorphism::msm_terms()` which applies a projection function to transform the witness. [6](#0-5) 

7. The projection function flattens `chunked_plaintexts` into a single vector **without any size validation**. [7](#0-6) 

8. This flattened witness is passed to `CommitmentHomomorphism::msm_terms()` which **panics via assert!()** when the values vector length exceeds the fixed `msm_basis.len()`. [8](#0-7) 

**Root Cause:** The assertion at the cryptographic layer assumes trusted input, but the witness originates from an untrusted dealer. While the `msm_basis` length is bounded by public parameters (typically a few thousand based on validator set size), an attacker can create arbitrarily large nested vectors that deserialize successfully through BCS (which only limits nesting depth, not sequence length) and exceed this bound when flattened.

**Validation Gap:** The transcript verification performs structural checks on array counts but never validates the inner sizes of witness fields before they reach the panic point. [9](#0-8) 

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty category 8: "Validator Node Slowdowns")

This vulnerability enables:
- **Validator Node Crashes**: Any validator processing the malicious transcript will panic and terminate during DKG verification
- **DKG Ceremony Disruption**: If multiple validators crash processing the same malicious transcript, the DKG session may fail
- **Epoch Transition Delays**: Repeated crashes during critical DKG phases can delay validator set updates
- **Protocol Invariant Violation**: Crashes during transaction processing violate the expectation of graceful error handling

The severity is HIGH rather than CRITICAL because:
- Does not directly cause fund loss or consensus safety violations
- Requires a Byzantine validator to act as malicious dealer (within BFT threat model)
- Affects availability of individual validators, not total network liveness
- Validators can restart and continue operation (though the vulnerability persists)

This aligns with the bounty program's HIGH severity category for "DoS through resource exhaustion" affecting validator nodes.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploitable because:

1. **Low Barrier to Entry**: Any validator selected as a DKG dealer can craft the malicious transcript (no additional privileges needed beyond standard dealer role)

2. **Deterministic Trigger**: The panic is guaranteed when the flattened `chunked_plaintexts` length exceeds `msm_basis.len()` - there is no probabilistic element

3. **No Size Validation**: Extensive code analysis reveals no validation of witness field sizes before the panic point, only array count checks

4. **Trivial Construction**: An attacker simply creates a `Vec<Vec<Vec<Scalar>>>` with more total elements than the MSM basis length (e.g., a few thousand elements spread across nested vectors)

5. **BCS Deserialization Permits Large Sequences**: While BCS limits nesting depth to ~128 levels, it does not restrict the length of individual vectors, allowing arbitrarily large flat arrays that exceed the MSM basis bounds when flattened

## Recommendation

Add explicit size validation for witness fields before sigma protocol verification:

```rust
// In Transcript::verify() before calling hom.verify()
fn validate_witness_size(
    witness: &HkzgWeightedElgamalWitness<E::ScalarField>,
    max_allowed_size: usize,
) -> anyhow::Result<()> {
    let total_elements: usize = witness.chunked_plaintexts
        .iter()
        .map(|player| player.iter().map(|chunk| chunk.len()).sum::<usize>())
        .sum();
    
    ensure!(
        total_elements <= max_allowed_size,
        "Witness chunked_plaintexts size {} exceeds maximum allowed {}",
        total_elements,
        max_allowed_size
    );
    Ok(())
}
```

Additionally, replace the panic-inducing `assert!()` with a proper `Result`-based error:

```rust
// In CommitmentHomomorphism::msm_terms()
fn msm_terms(&self, input: &Self::Domain) -> anyhow::Result<Self::CodomainShape<Self::MsmInput>> {
    ensure!(
        self.msm_basis.len() >= input.values.len(),
        "Not enough Lagrange basis elements for univariate hiding KZG: required {}, got {}",
        input.values.len(),
        self.msm_basis.len()
    );
    // ... rest of implementation
}
```

## Proof of Concept

The following demonstrates the vulnerability path (conceptual PoC showing the panic trigger):

```rust
#[test]
fn test_oversized_witness_causes_panic() {
    use aptos_dkg::pvss::chunky::hkzg_chunked_elgamal::HkzgWeightedElgamalWitness;
    
    // Simulate malicious dealer creating oversized witness
    let msm_basis_len = 1000; // Typical basis length from public params
    let malicious_size = msm_basis_len + 1000; // Exceed basis length
    
    let malicious_witness = HkzgWeightedElgamalWitness {
        hkzg_randomness: /* ... */,
        chunked_plaintexts: vec![
            vec![vec![Scalar::rand(&mut rng); malicious_size]] // Oversized vector
        ],
        elgamal_randomness: /* ... */,
    };
    
    // When this witness reaches CommitmentHomomorphism::msm_terms()
    // after projection flattening, it will trigger:
    // assert!(self.msm_basis.len() >= input.values.len())
    // causing validator panic
}
```

The actual exploit requires constructing a full DKG transcript with the malicious witness, serializing it via BCS, and submitting it as a ValidatorTransaction. The panic will occur during `process_dkg_result()` execution in the VM layer.

## Notes

- This vulnerability affects the consensus layer's DKG mechanism, not the network layer (distinct from out-of-scope network DoS attacks)
- The threat model assumes Byzantine validators (<1/3) which is standard for BFT systems
- The fix requires coordinated updates to both add size validation and replace panics with proper error handling
- Until patched, validators processing malicious DKG transcripts will crash, requiring restarts

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L47-51)
```rust
pub struct HkzgWeightedElgamalWitness<F: PrimeField> {
    pub hkzg_randomness: univariate_hiding_kzg::CommitmentRandomness<F>,
    pub chunked_plaintexts: Vec<Vec<Vec<Scalar<F>>>>, // For each player, plaintexts z_i, which are chunked z_{i,j}
    pub elgamal_randomness: Vec<Vec<Scalar<F>>>, // For at most max_weight, for each chunk, a blinding factor
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/hkzg_chunked_elgamal.rs (L210-217)
```rust
                let flattened_chunked_plaintexts: Vec<Scalar<E::ScalarField>> =
                    std::iter::once(Scalar(E::ScalarField::ZERO))
                        .chain(chunked_plaintexts.iter().flatten().flatten().cloned())
                        .collect();
                univariate_hiding_kzg::Witness::<E::ScalarField> {
                    hiding_randomness: hkzg_randomness.clone(),
                    values: flattened_chunked_plaintexts,
                }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L69-72)
```rust
    /// Proof (of knowledge) showing that the s_{i,j}'s in C are base-B representations (of the s_i's in V, but this is not part of the proof), and that the r_j's in R are used in C
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub sharing_proof: SharingProof<E>,
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L133-153)
```rust
        if eks.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} encryption keys, but got {}",
                sc.get_total_num_players(),
                eks.len()
            );
        }
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L178-190)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```

**File:** aptos-move/aptos-vm/src/validator_txns/mod.rs (L24-27)
```rust
        match txn {
            ValidatorTransaction::DKGResult(dkg_node) => {
                self.process_dkg_result(resolver, module_storage, log_context, session_id, dkg_node)
            },
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/fixed_base_msms.rs (L111-114)
```rust
    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
        let projected = (self.projection)(input);
        self.hom.msm_terms(&projected)
    }
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L352-357)
```rust
        assert!(
            self.msm_basis.len() >= input.values.len(),
            "Not enough Lagrange basis elements for univariate hiding KZG: required {}, got {}",
            input.values.len(),
            self.msm_basis.len()
        );
```
