# Audit Report

## Title
Configuration Files Saved with World-Readable Permissions Expose Sensitive Credentials

## Summary
The `write_file` function in `PersistableConfig` trait creates configuration files using `File::create()` without setting restrictive permissions. On Unix systems, this results in files with default permissions (typically 0644), making them world-readable. Since node configuration files can contain sensitive data including network private keys, database credentials, and validator identities, this allows unauthorized local users to access critical secrets.

## Finding Description

The vulnerability exists in the `write_file` function implementation: [1](#0-0) 

This function uses `File::create()` which creates files with default permissions based on the process umask. On Unix systems, this typically results in permissions of 0644 (readable by owner, group, and world), making the configuration files world-readable.

The `save_config` function in `OverrideNodeConfig` calls this vulnerable `write_file` method: [2](#0-1) 

These configuration files are created during production operations such as genesis initialization and node setup: [3](#0-2) 

**Sensitive Data at Risk:**

1. **Network Private Keys** - The `Identity::FromConfig` variant contains `ConfigKey<x25519::PrivateKey>` that gets serialized: [4](#0-3) 

2. **Serializable Private Keys** - `ConfigKey<T>` is marked as serializable, meaning private keys are written to disk: [5](#0-4) 

3. **Database Credentials** - PostgreSQL connection strings with embedded passwords: [6](#0-5) 

4. **Network Configuration** - Contains identity information that may include embedded keys: [7](#0-6) 

**Evidence of Security Awareness:**

The codebase already contains functions that properly set restrictive permissions, demonstrating awareness of this security requirement: [8](#0-7) 

And: [9](#0-8) 

These secure functions explicitly set mode 0o600 for confidential files, but `PersistableConfig::write_file` does not use this protection.

## Impact Explanation

This vulnerability represents **Medium Severity** per Aptos bug bounty criteria:

1. **Information Disclosure**: Allows unauthorized local users to read validator private keys, database credentials, and network topology information
2. **Validator Identity Compromise**: Exposed network private keys could enable impersonation of validator nodes
3. **Database Access**: PostgreSQL credentials in plain text allow unauthorized database access
4. **Limited Scope**: Requires local system access (not remote exploitation)

The impact aligns with "Limited funds loss or manipulation" and "State inconsistencies requiring intervention" categories because:
- Compromised validator keys could enable byzantine behavior
- Database access could allow data manipulation affecting node operation
- Does not directly lead to consensus breaks but weakens overall security posture

## Likelihood Explanation

**High Likelihood** - This vulnerability occurs automatically whenever configuration files are saved in production environments:

1. **Automatic Occurrence**: Every time `save_config()` is called during node setup or genesis, files are created with insecure permissions
2. **Production Usage**: Used in real deployment scenarios, not just testing: [10](#0-9) 
3. **Multi-User Systems**: Common for validators to run on shared systems or systems with multiple administrator accounts
4. **No Authentication Required**: Any local user can read the files without special privileges
5. **Persistent Exposure**: Configuration files remain on disk indefinitely with insecure permissions

## Recommendation

Modify the `write_file` function to set restrictive permissions (0600) on Unix systems:

```rust
fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
    use std::fs::OpenOptions;
    
    let mut options = OpenOptions::new();
    options.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        options.mode(0o600);
    }
    
    let mut file = options.open(output_file.as_ref())
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    file.write_all(&serialized_config)
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

    Ok(())
}
```

This follows the same pattern already used in `write_to_user_only_file` and `save_to_file_confidential` elsewhere in the codebase.

## Proof of Concept

```rust
#[cfg(test)]
mod test_file_permissions {
    use super::*;
    use std::fs;
    use tempfile::TempDir;
    
    #[test]
    #[cfg(unix)]
    fn test_config_file_permissions_vulnerability() {
        use std::os::unix::fs::PermissionsExt;
        
        // Create a test config
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("test_config.yaml");
        
        let config = OverrideNodeConfig::new_default();
        config.save_config(&config_path).unwrap();
        
        // Check file permissions
        let metadata = fs::metadata(&config_path).unwrap();
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // Extract permission bits (last 9 bits)
        let permission_bits = mode & 0o777;
        
        println!("File created with permissions: {:o}", permission_bits);
        
        // VULNERABILITY: File is created with default permissions (likely 0644)
        // which makes it world-readable
        assert!(
            permission_bits & 0o044 != 0,
            "Config file is world/group readable! Permissions: {:o}",
            permission_bits
        );
        
        // Recommended: Permissions should be 0600 (owner read/write only)
        // assert_eq!(permission_bits, 0o600, "Config should have 0600 permissions");
    }
}
```

## Notes

This vulnerability specifically affects Unix-like systems where file permissions are enforced. Windows systems use different access control mechanisms (ACLs) that may not be affected in the same way. The fix should use conditional compilation to apply Unix-specific permission settings while remaining compatible with other platforms.

The vulnerability is particularly concerning because:
1. Validator configuration files legitimately contain private keys in `Identity::FromConfig` variants
2. The codebase already demonstrates awareness of this issue through secure functions
3. Production code paths actively use the vulnerable `save_config` function
4. Files persist on disk indefinitely with insecure permissions

### Citations

**File:** config/src/config/persistable_config.rs (L43-50)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
    }
```

**File:** config/src/config/override_node_config.rs (L142-152)
```rust
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        let yaml_value = self.get_yaml()?;
        let yaml_string = serde_yaml::to_string(&yaml_value).map_err(|e| {
            Error::Yaml(
                "Unable to serialize override config to yaml. Error: {}".to_string(),
                e,
            )
        })?;
        let yaml_bytes = yaml_string.as_bytes().to_vec();
        Self::write_file(yaml_bytes, output_file)
    }
```

**File:** crates/aptos-genesis/src/builder.rs (L263-263)
```rust
        fullnode_config.save_config()?;
```

**File:** crates/aptos-genesis/src/builder.rs (L547-550)
```rust
        // Save configs for validators so they can run
        for validator in validators.iter_mut() {
            validator.save_config()?;
        }
```

**File:** config/src/config/identity_config.rs (L130-139)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** config/src/config/indexer_config.rs (L33-36)
```rust
    /// Postgres database uri, ex: "postgresql://user:pass@localhost/postgres"
    /// Alternatively can set the `INDEXER_DATABASE_URL` env var
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_uri: Option<String>,
```

**File:** config/src/config/network_config.rs (L72-73)
```rust
    /// Identity of this network
    pub identity: Identity,
```

**File:** crates/aptos/src/common/utils.rs (L223-229)
```rust
/// Write a User only read / write file
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```
