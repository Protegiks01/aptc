# Audit Report

## Title
Insufficient Validation in create_merged_with_executed_state() Allows Denial of Service via Mismatched Commit Proofs

## Summary
The `create_merged_with_executed_state()` function in `WrappedLedgerInfo` performs insufficient validation when merging finality proofs with execution decisions. It only validates ordered fields (epoch, round, id, timestamp) using `match_ordered_only()`, without verifying critical execution results (state root hash, transaction version, next epoch state). This enables a race condition where malicious commit decisions can cause validator nodes to panic, resulting in denial of service.

## Finding Description

The vulnerability exists in the proof merging logic within the consensus commit callback path. When a block is committed, two proofs must be merged:

1. **finality_proof** (WrappedLedgerInfo): Contains ordering information with placeholder execution values
2. **commit_decision** (LedgerInfoWithSignatures): Contains actual execution results [1](#0-0) 

The `create_merged_with_executed_state()` function performs the merge with inadequate validation: [2](#0-1) 

The validation uses `match_ordered_only()` which ONLY checks:
- epoch
- round  
- block id
- timestamp [3](#0-2) 

Critically, it does NOT validate:
- `executed_state_id` (state root hash)
- `version` (transaction version)
- `next_epoch_state` (validator set for next epoch)

**Attack Scenario:**

An attacker (malicious validator or network adversary) can exploit a race condition in the buffer management system:

1. A block enters the Ordered state and begins execution
2. Attacker sends a malicious `CommitDecision` with valid signatures but incorrect execution results (wrong state root, version, or epoch state)
3. If the malicious commit decision arrives BEFORE local execution completes, it enters the Ordered state handling path: [4](#0-3) 

4. This path only validates using `match_ordered_only()` (line 277), allowing the malicious proof to be stored
5. When local execution completes, `advance_to_executed_or_aggregated()` is called: [5](#0-4) 

6. Line 149 performs a full equality check via `assert_eq!()` between the stored malicious proof and local execution results
7. Since execution results differ, the assertion FAILS and the validator node **PANICS**

The panic is not gracefully handled, causing the validator to crash and requiring restart.

## Impact Explanation

**High Severity** - This vulnerability enables denial of service attacks against validator nodes:

- **Validator Node Crashes**: Attackers can force validator nodes to panic and crash by sending malicious commit decisions during the execution window
- **Network Liveness Degradation**: If multiple validators are targeted simultaneously, consensus liveness could be severely impacted
- **Repeated Attacks**: The attack can be repeated each time validators process new blocks, causing sustained disruption

According to Aptos bug bounty severity categories, "Validator node slowdowns" and "API crashes" are High Severity issues. This vulnerability causes validator crashes, which is more severe than slowdowns.

**Potential Critical Impact**: If the assertion at line 149 could be bypassed through exception handling or an alternative code path, mismatched execution results could be committed, causing:
- State inconsistency across validators
- Consensus safety violations  
- Potential chain splits

## Likelihood Explanation

**High Likelihood** for the DoS attack:

1. **No Privileged Access Required**: Any network peer can send `CommitMessage::Decision` packets
2. **Signature Verification Present but Insufficient**: While signatures are verified, validators with >2/3 voting power could collude to sign incorrect execution results
3. **Race Condition Window**: The attack window exists during block execution (typically milliseconds to seconds), which is feasible to exploit
4. **Deterministic Trigger**: Once a mismatched commit decision is stored during Ordered state, the panic is guaranteed when execution completes

The attack is particularly effective against:
- Validators with slower execution times
- Validators during network congestion  
- Scenarios with malicious or compromised validators controlling sufficient stake

## Recommendation

**Immediate Fix**: Replace the assertion with graceful error handling that discards mismatched commit decisions instead of panicking:

```rust
// In buffer_item.rs, line 146-157
if let Some(commit_proof) = commit_proof {
    // Replace assert_eq! with proper validation
    if commit_proof.commit_info() != &commit_info {
        warn!(
            "Received commit proof with mismatched execution results. Expected: {:?}, Got: {:?}",
            commit_info,
            commit_proof.commit_info()
        );
        // Discard the mismatched proof and continue with aggregation
        let commit_ledger_info = generate_commit_ledger_info(
            &commit_info,
            &ordered_proof,
            order_vote_enabled,
        );
        // Continue with normal aggregation path...
    } else {
        // Proof matches, proceed to Aggregated state
        debug!(
            "{} advance to aggregated from ordered",
            commit_proof.commit_info()
        );
        return Self::Aggregated(Box::new(AggregatedItem {
            executed_blocks,
            commit_proof,
        }));
    }
}
```

**Defense in Depth**: Add full validation to `create_merged_with_executed_state()`:

```rust
// In wrapped_ledger_info.rs
pub fn create_merged_with_executed_state(
    &self,
    executed_ledger_info: LedgerInfoWithSignatures,
) -> anyhow::Result<WrappedLedgerInfo> {
    let self_commit_info = self.commit_info();
    let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
    
    // Check ordered fields match
    ensure!(
        self_commit_info.match_ordered_only(executed_commit_info),
        "Block info from QC and executed LI need to match on ordered fields, {:?} and {:?}",
        self_commit_info,
        executed_commit_info
    );
    
    // If self is ordered-only, allow any execution results
    // Otherwise, verify full equality
    if !self_commit_info.is_ordered_only() {
        ensure!(
            self_commit_info == executed_commit_info,
            "Block info must match exactly when both have execution results, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
    }
    
    Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
}
```

## Proof of Concept

```rust
// Test demonstrating the panic vulnerability
#[test]
#[should_panic(expected = "assertion failed")]
fn test_mismatched_commit_decision_causes_panic() {
    use aptos_consensus_types::pipelined_block::PipelinedBlock;
    use aptos_crypto::HashValue;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::AggregateSignature,
    };
    
    // Create a block with placeholder execution values (ordered-only)
    let ordered_block_info = BlockInfo::new(
        1, // epoch
        10, // round
        HashValue::random(), // id
        *ACCUMULATOR_PLACEHOLDER_HASH, // ordered-only placeholder
        0, // version = 0 for ordered
        100, // timestamp
        None, // no epoch state
    );
    
    // Create a commit proof with DIFFERENT execution results
    let malicious_block_info = BlockInfo::new(
        1, // epoch - SAME
        10, // round - SAME
        ordered_block_info.id(), // id - SAME
        HashValue::random(), // DIFFERENT state root!
        100, // DIFFERENT version!
        100, // timestamp - SAME
        None, // DIFFERENT epoch state
    );
    
    let malicious_ledger_info = LedgerInfo::new(malicious_block_info, HashValue::zero());
    let malicious_commit_proof = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        AggregateSignature::empty()
    );
    
    // Simulate the buffer item flow
    let ordered_item = OrderedItem {
        unverified_votes: HashMap::new(),
        commit_proof: Some(malicious_commit_proof), // Stored during Ordered state
        ordered_blocks: vec![],
        ordered_proof: LedgerInfoWithSignatures::new(
            LedgerInfo::new(ordered_block_info.clone(), HashValue::zero()),
            AggregateSignature::empty()
        ),
    };
    
    // When execution completes with correct results
    let correct_execution_info = BlockInfo::new(
        1,
        10,
        ordered_block_info.id(),
        HashValue::random(), // Correct state root (different from malicious)
        50, // Correct version (different from malicious)
        100,
        None,
    );
    
    // This will trigger the assertion failure and panic
    // Line 149 in buffer_item.rs: assert_eq!(commit_proof.commit_info().clone(), correct_execution_info);
    // PANIC occurs here!
}
```

**Notes:**
- The validation weakness exists at the final merge point in `commit_callback()`, relying entirely on earlier checks
- Earlier validation has a race condition window exploitable during block execution
- The use of `assert_eq!()` instead of graceful error handling converts a validation issue into a crash vulnerability
- The DoS impact is confirmed and exploitable; potential state inconsistency requires assertion bypass

### Citations

**File:** consensus/src/block_storage/block_tree.rs (L578-580)
```rust
        let commit_proof = finality_proof
            .create_merged_with_executed_state(commit_decision)
            .expect("Inconsistent commit proof and evaluation decision, cannot commit block");
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L110-123)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<WrappedLedgerInfo> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L146-157)
```rust
                if let Some(commit_proof) = commit_proof {
                    // We have already received the commit proof in fast forward sync path,
                    // we can just use that proof and proceed to aggregated
                    assert_eq!(commit_proof.commit_info().clone(), commit_info);
                    debug!(
                        "{} advance to aggregated from ordered",
                        commit_proof.commit_info()
                    );
                    Self::Aggregated(Box::new(AggregatedItem {
                        executed_blocks,
                        commit_proof,
                    }))
```

**File:** consensus/src/pipeline/buffer_item.rs (L272-286)
```rust
            Self::Ordered(ordered_item) => {
                let ordered = *ordered_item;
                assert!(ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(commit_proof.commit_info()));
                // can't aggregate it without execution, only store the signatures
                debug!(
                    "{} received commit decision in ordered stage",
                    commit_proof.commit_info()
                );
                Self::Ordered(Box::new(OrderedItem {
                    commit_proof: Some(commit_proof),
                    ..ordered
                }))
```
