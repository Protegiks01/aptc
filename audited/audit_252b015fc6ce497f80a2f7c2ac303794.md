# Audit Report

## Title
Master Secret Key Shares Stored in Unprotected Memory - Exposure Risk via Memory Dumps

## Summary
The master secret key shares (`msk_share`) used in the consensus randomness beacon are stored in unprotected memory without zeroization, violating Aptos secure coding guidelines and creating exposure risk through memory dumps, core dumps, debug output, and swap files.

## Finding Description

The `WeightedBIBEMasterSecretKeyShare` structure stores threshold cryptography secret shares in plaintext memory without any memory protection mechanisms. [1](#0-0) 

The structure contains sensitive cryptographic material in the `shamir_share_evals: Vec<Fr>` field, which represents the validator's share of the master secret key used for decrypting consensus randomness. This struct derives `Clone`, `Debug`, and `Serialize` traits, all of which can expose the secret material.

The Aptos secure coding guidelines explicitly require zeroization of cryptographic secrets: [2](#0-1)  and [3](#0-2) 

However, no zeroize implementation exists for this type, and the underlying `Fr` field elements (from the arkworks library) are standard memory allocations without protection. [4](#0-3) 

The secret share is used throughout the consensus pipeline: [5](#0-4)  and [6](#0-5) 

In the decryption pipeline, the secret is cloned and held in memory during block processing: [7](#0-6) 

**Exposure Vectors:**

1. **Process Crashes**: Core dumps will contain plaintext secret shares
2. **Memory Inspection**: Debugging tools can read process memory
3. **Debug Output**: The `Debug` trait can expose secrets in logs
4. **Swap Files**: Memory pages containing secrets can be swapped to disk
5. **Clone Operations**: Multiple unprotected copies created in memory
6. **Serialization**: The `Serialize` trait enables persistence to disk/network [8](#0-7) 

## Impact Explanation

**Severity Assessment: HIGH (not Critical)**

While this violates the "Cryptographic Correctness" invariant and the project's secure coding guidelines, it requires **local access to validator infrastructure** to exploit, which downgrades it from Critical to High severity.

If an attacker gains access to validator infrastructure and obtains threshold (t) shares from different validators, they could:
- Reconstruct the master decryption key
- Decrypt randomness beacon outputs
- Potentially manipulate leader election (depending on randomness usage)

However, this requires:
- Physical or network access to validator nodes
- OR compromised validator infrastructure
- OR insider access to debug logs/core dumps

This makes it an **operational security concern** rather than a remotely exploitable protocol vulnerability.

## Likelihood Explanation

**Likelihood: MEDIUM**

Validator nodes can crash due to:
- Software bugs causing panics
- Out-of-memory conditions
- Hardware failures
- Forced termination during maintenance

Core dumps are routinely collected for debugging purposes, and many systems automatically create them on crashes. Additionally:
- Memory forensics tools can inspect running processes
- Swap files persist on disk
- Debug logging might be enabled during troubleshooting

However, exploitation requires:
- Compromised validator infrastructure (insider threat or breach)
- Access to crash dumps or memory snapshots
- Collection of shares from threshold number of validators

## Recommendation

Implement memory protection for all cryptographic secret material:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(Clone, Serialize, Deserialize, PartialEq, Eq)]
#[zeroize(drop)]
pub struct WeightedBIBEMasterSecretKeyShare {
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub(crate) mpk_g2: G2Affine,
    pub(crate) weighted_player: Player,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    #[zeroize(skip)]  // Only zeroize the secret material
    pub(crate) shamir_share_evals: Vec<Fr>,
}

// Remove Debug trait or implement custom Debug that redacts secrets
impl std::fmt::Debug for WeightedBIBEMasterSecretKeyShare {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("WeightedBIBEMasterSecretKeyShare")
            .field("mpk_g2", &self.mpk_g2)
            .field("weighted_player", &self.weighted_player)
            .field("shamir_share_evals", &"<REDACTED>")
            .finish()
    }
}
```

Additional hardening:
1. Consider using `secrecy` crate for secret wrapping
2. Disable core dumps for consensus process (`prctl(PR_SET_DUMPABLE, 0)`)
3. Use memory locking (`mlock`) for pages containing secrets
4. Audit all serialization paths to ensure secrets aren't persisted

## Proof of Concept

```rust
#[test]
fn demonstrate_secret_exposure() {
    use aptos_batch_encryption::schemes::fptx_weighted::FPTXWeighted;
    use aptos_batch_encryption::traits::BatchThresholdEncryption;
    use aptos_crypto::arkworks::shamir::ShamirThresholdConfig;
    
    let tc = ShamirThresholdConfig::new(3, 8);
    let (ek, dk, vks, msk_shares) = 
        FPTXWeighted::setup_for_testing(12345, 8, 1, &tc).unwrap();
    
    // Exposure Vector 1: Debug output exposes secrets
    println!("Debug output: {:?}", msk_shares[0]);
    
    // Exposure Vector 2: Serialization exposes secrets
    let serialized = serde_json::to_string(&msk_shares[0]).unwrap();
    println!("Serialized: {}", serialized);
    
    // Exposure Vector 3: Clone creates unprotected copies
    let cloned_secret = msk_shares[0].clone();
    
    // All these copies remain in memory without zeroization
    // If process crashes here, core dump contains all secrets
    
    // Note: After this test ends, secrets remain in memory
    // until overwritten by other allocations
}
```

This PoC demonstrates that secrets are exposed through debug output and serialization, and remain in memory without protection.

## Notes

While this is a valid security concern that violates Aptos secure coding guidelines, it requires **privileged access to validator infrastructure** to exploit. This makes it an operational security issue rather than a remotely exploitable protocol vulnerability. The finding is reported as **HIGH severity** rather than CRITICAL because:

1. Exploitation requires local/insider access to validator nodes
2. It's not exploitable by external network attackers
3. Falls under operational security hardening rather than protocol bugs

The recommendation should be implemented as part of security hardening, even though it may not qualify for the highest tier of the bug bounty program due to the access requirements for exploitation.

### Citations

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L46-53)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct WeightedBIBEMasterSecretKeyShare {
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub(crate) mpk_g2: G2Affine,
    pub(crate) weighted_player: Player,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub(crate) shamir_share_evals: Vec<Fr>,
}
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L145-145)
```markdown
Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** crates/aptos-batch-encryption/src/group.rs (L3-6)
```rust
pub use ark_bls12_381::{
    g1::Config as G1Config, Bls12_381 as PairingSetting, Config, Fq, Fr, G1Affine, G1Projective,
    G2Affine, G2Projective,
};
```

**File:** consensus/src/rand/secret_sharing/types.rs (L40-50)
```rust
pub struct SecretSharingConfig {
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    // wconfig: WeightedConfig,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: ThresholdConfig,
    encryption_key: EncryptionKey,
}
```

**File:** types/src/secret_sharing.rs (L135-146)
```rust
#[derive(Clone)]
pub struct SecretShareConfig {
    _author: Author,
    _epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
    weights: HashMap<Author, u64>,
}
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L62-66)
```rust
        let msk_share: MasterSecretKeyShare = secret_share_config
            .as_ref()
            .expect("must exist")
            .msk_share()
            .clone();
```

**File:** crates/aptos-batch-encryption/src/tests/fptx_smoke.rs (L74-97)
```rust
fn fptx_serialize_deserialize_setup() {
    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(3, 8);

    let setup = FPTX::setup_for_testing(rng.r#gen(), 8, 2, &tc).unwrap();

    let bytes = bcs::to_bytes(&setup).unwrap();
    let setup2: (
        <FPTX as BatchThresholdEncryption>::EncryptionKey,
        <FPTX as BatchThresholdEncryption>::DigestKey,
        Vec<<FPTX as BatchThresholdEncryption>::VerificationKey>,
        Vec<<FPTX as BatchThresholdEncryption>::MasterSecretKeyShare>,
    ) = bcs::from_bytes(&bytes).unwrap();

    assert_eq!(setup, setup2);

    let json = serde_json::to_string(&setup).unwrap();
    let setup2: (
        <FPTX as BatchThresholdEncryption>::EncryptionKey,
        <FPTX as BatchThresholdEncryption>::DigestKey,
        Vec<<FPTX as BatchThresholdEncryption>::VerificationKey>,
        Vec<<FPTX as BatchThresholdEncryption>::MasterSecretKeyShare>,
    ) = serde_json::from_str(&json).unwrap();
    assert_eq!(setup, setup2);
```
