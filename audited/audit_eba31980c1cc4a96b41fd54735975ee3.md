# Audit Report

## Title
V0 Format Backup Restore Breaks Deterministic Execution for Transactions Using `monotonically_increasing_counter()`

## Summary
When restoring from `TransactionChunkFormat::V0` backups, all transactions receive `PersistedAuxiliaryInfo::None`, causing native functions that depend on `transaction_index` to abort during replay verification. This breaks the deterministic execution invariant as transactions that originally succeeded will abort when replayed, producing different execution results and potentially causing consensus splits or restore failures. [1](#0-0) 

## Finding Description
The vulnerability occurs in the V0 format migration path where historical auxiliary information is lost. When processing `TransactionChunkFormat::V0` backups, the system unconditionally assigns `PersistedAuxiliaryInfo::None` to all transactions because V0 format only stores `(txn, txn_info, events, write_set)` without persisted auxiliary information. [2](#0-1) 

This creates a critical mismatch during replay verification. The `PersistedAuxiliaryInfo::None` is converted to `AuxiliaryInfo` with `TransactionIndexKind::NotAvailable`: [3](#0-2) 

When transactions are replayed with verification enabled via `ReplayVerifyCoordinator`, they are re-executed through the VM: [4](#0-3) [5](#0-4) 

The native function `monotonically_increasing_counter_internal` explicitly checks if `transaction_index` is available and aborts with `ETRANSACTION_INDEX_NOT_AVAILABLE` when it encounters `TransactionIndexKind::NotAvailable`: [6](#0-5) 

This causes deterministic execution to break:
- **Original execution**: Transaction succeeds and returns a counter value
- **Replay execution**: Transaction aborts with error code
- **Result**: Different `TransactionStatus`, breaking consensus invariant #1

## Impact Explanation
This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The impact includes:
1. **Replay verification failures**: Any V0 backup containing transactions that called `monotonically_increasing_counter()` will fail verification during restore
2. **Consensus determinism break**: Different nodes restoring from V0 backups could compute different states if they use different restore modes
3. **Operational disruption**: Validators or archive nodes attempting to restore from V0 backups with verification enabled will encounter failures requiring manual intervention
4. **State divergence risk**: If some nodes restore without verification and others with verification, they will have different states

The function `monotonically_increasing_counter()` is a production feature gated by a feature flag: [7](#0-6) 

## Likelihood Explanation
**Medium Likelihood**:
- Requires V0 format backups (older backup format)
- Requires use of replay/verify mode during restore (not default production mode)
- Requires historical transactions that called `monotonically_increasing_counter()` or other transaction_index-dependent functions
- The `ReplayVerifyCoordinator` is a real tool used for verification purposes
- Archive nodes and testing scenarios commonly use replay verification

While the specific combination of conditions is not the most common restore path, the `monotonically_increasing_counter()` function is a legitimate production feature, making this a realistic scenario for archive replay and verification workflows.

## Recommendation
Implement proper handling for V0 format migrations by either:

**Option 1: Preserve auxiliary info semantics during migration**
For V0 backups where transaction_index was not tracked, consider using `PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { transaction_index: 0 }` instead of `None`, which allows functions to work with a default index rather than aborting.

**Option 2: Skip verification for V0 format transactions**
Detect when transactions originated from V0 format backups and automatically disable execution verification for those transactions, as their auxiliary information is inherently incomplete.

**Option 3: Document and error early**
If V0 backups are known to be incompatible with replay verification, add explicit validation at restore time that rejects V0 format backups when `verify_execution_mode` is not `NoVerify`, with a clear error message explaining the incompatibility.

**Recommended Fix (Option 3 - safest approach):**
Add validation in `LoadedChunk::load()`:

```rust
// After line 130 in restore.rs
if manifest.format == TransactionChunkFormat::V0 && verify_execution_mode.is_enabled() {
    return Err(anyhow!(
        "TransactionChunkFormat::V0 backups are incompatible with execution verification. \
         V0 format does not preserve PersistedAuxiliaryInfo, which is required for \
         deterministic replay. Please use VerifyExecutionMode::NoVerify when restoring V0 backups."
    ));
}
```

## Proof of Concept

**Reproduction Steps:**

1. **Create a Move contract that uses `monotonically_increasing_counter()`:**
```move
module test_addr::counter_test {
    use std::transaction_context;
    
    public entry fun use_counter() {
        let _counter = transaction_context::monotonically_increasing_counter();
        // Transaction succeeds with counter value
    }
}
```

2. **Execute the transaction on a live network** (or test environment with the feature flag enabled)

3. **Create a V0 format backup** containing this transaction

4. **Attempt to restore with replay verification:**
```bash
aptos-db-tool replay-verify \
    --transaction-manifest <v0_backup_manifest> \
    --target-db <restore_path>
```

5. **Observe the failure:**
   - Original transaction: `TransactionStatus::Keep(ExecutionStatus::Success)`
   - Replayed transaction: `TransactionStatus::Keep(ExecutionStatus::MoveAbort)` with abort code `ETRANSACTION_INDEX_NOT_AVAILABLE`
   - Verification fails due to status mismatch

**Expected Result:** Transaction replay succeeds with identical execution results  
**Actual Result:** Transaction replay aborts with `ETRANSACTION_INDEX_NOT_AVAILABLE` error, breaking deterministic execution invariant

## Notes
- This vulnerability only affects V0 format backups, which may be legacy at this point
- Production restore typically uses `VerifyExecutionMode::NoVerify`, reducing real-world impact
- However, archive nodes, debugging tools, and verification workflows commonly enable execution verification
- The issue demonstrates a broader architectural concern about backward compatibility when data formats evolve and new features (like `transaction_index`) are added to execution contexts

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L119-129)
```rust
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
```

**File:** types/src/transaction/mod.rs (L3254-3267)
```rust
    pub fn transaction_index_kind(
        &self,
    ) -> crate::transaction::user_transaction_context::TransactionIndexKind {
        use crate::transaction::user_transaction_context::TransactionIndexKind;
        match self.persisted_info {
            PersistedAuxiliaryInfo::V1 { transaction_index } => {
                TransactionIndexKind::BlockExecution { transaction_index }
            },
            PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { transaction_index } => {
                TransactionIndexKind::ValidationOrSimulation { transaction_index }
            },
            PersistedAuxiliaryInfo::None => TransactionIndexKind::NotAvailable,
        }
    }
```

**File:** types/src/transaction/mod.rs (L3303-3318)
```rust
#[derive(
    Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, CryptoHasher, BCSCryptoHash,
)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum PersistedAuxiliaryInfo {
    None,
    // The index of the transaction in a block (after shuffler, before execution).
    // Note that this would be slightly different from the index of transactions that get committed
    // onchain, as this considers transactions that may get discarded.
    V1 { transaction_index: u32 },
    // When we are doing a simulation or validation of transactions, the transaction is not executed
    // within the context of a block. The timestamp is not yet assigned, but we still track the
    // transaction index for multi-transaction simulations. For single transaction simulation or
    // validation, the transaction index is set to 0.
    TimestampNotYetAssignedV1 { transaction_index: u32 },
}
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L191-205)
```rust
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            transactions
                .into_iter()
                .map(|t| t.manifest)
                .collect::<Vec<_>>(),
            save_start_version,
            Some((next_txn_version, false)), /* replay_from_version */
            None,                            /* epoch_history */
            self.verify_execution_mode.clone(),
            None,
        )
        .run()
        .await?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L592-627)
```rust
    fn verify_execution(
        &self,
        transactions: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        transaction_infos: &[TransactionInfo],
        write_sets: &[WriteSet],
        event_vecs: &[Vec<ContractEvent>],
        begin_version: Version,
        end_version: Version,
        verify_execution_mode: &VerifyExecutionMode,
    ) -> Result<Version> {
        // Execute transactions.
        let parent_state = self.commit_queue.lock().latest_state().clone();
        let state_view = self.state_view(parent_state.latest())?;
        let txns = transactions
            .iter()
            .take((end_version - begin_version) as usize)
            .cloned()
            .map(|t| t.into())
            .collect::<Vec<SignatureVerifiedTransaction>>();

        let auxiliary_info = persisted_aux_info
            .iter()
            .take((end_version - begin_version) as usize)
            .map(|persisted_aux_info| AuxiliaryInfo::new(*persisted_aux_info, None))
            .collect::<Vec<_>>();
        // State sync executor shouldn't have block gas limit.
        let execution_output = DoGetExecutionOutput::by_transaction_execution::<V>(
            &V::new(),
            txns.into(),
            auxiliary_info,
            &parent_state,
            state_view,
            BlockExecutorConfigFromOnchain::new_no_block_limit(),
            TransactionSliceMetadata::chunk(begin_version, end_version),
        )?;
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L192-204)
```rust
        let (reserved_byte, transaction_index) = match transaction_index_kind {
            TransactionIndexKind::BlockExecution { transaction_index } => {
                (0u128, transaction_index)
            },
            TransactionIndexKind::ValidationOrSimulation { transaction_index } => {
                (1u128, transaction_index)
            },
            TransactionIndexKind::NotAvailable => {
                return Err(SafeNativeError::Abort {
                    abort_code: error::invalid_state(abort_codes::ETRANSACTION_INDEX_NOT_AVAILABLE),
                });
            },
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L200-207)
```text
    public fun monotonically_increasing_counter(): u128 {
        if (__COMPILE_FOR_TESTING__) {
            monotonically_increasing_counter_internal_for_test_only()
        } else {
            assert!(features::is_monotonically_increasing_counter_enabled(), error::invalid_state(EMONOTONICALLY_INCREASING_COUNTER_NOT_ENABLED));
            monotonically_increasing_counter_internal(timestamp::now_microseconds())
        }
    }
```
