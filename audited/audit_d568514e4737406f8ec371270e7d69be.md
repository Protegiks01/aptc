# Audit Report

## Title
Missing Validation of Round Count Consistency in Sharded Executor Result Aggregation

## Summary
The sharded block executor assumes all executor shards return the same number of rounds without validation, creating a vulnerability where a malicious or compromised remote executor shard can cause validator node crashes through index-out-of-bounds panics during result aggregation.

## Finding Description

The `ShardedBlockExecutor::execute_block()` method aggregates execution results from multiple executor shards without validating that all shards return consistent round counts. [1](#0-0) 

The aggregation logic:
1. Assumes the number of rounds based solely on shard 0's output length
2. Pre-allocates `ordered_results` with size `num_executor_shards * num_rounds`
3. Iterates through all shard results and calculates indices as `round * num_executor_shards + shard_id`

If any shard returns more rounds than shard 0, the indexing calculation exceeds the bounds of `ordered_results`, causing a panic.

When using `RemoteExecutorClient`, execution results are received from remote executor shards via network communication and deserialized without validation: [2](#0-1) 

The `RemoteExecutionResult` structure contains the raw result without round count constraints: [3](#0-2) 

**Attack Scenario:**
1. Partitioner correctly creates `PartitionedTransactions` with N rounds per shard
2. Remote executor shards receive execution commands via network
3. A compromised remote shard returns N+M rounds instead of N rounds  
4. `RemoteExecutorClient` deserializes results without validation
5. `ShardedBlockExecutor` attempts aggregation:
   - Line 98: `num_rounds = sharded_output[0].len() = N`
   - Line 100: `ordered_results` allocated with size `num_executor_shards * N`
   - Line 104: When processing malicious shard's round N+1, index = `N * num_executor_shards + shard_id >= num_executor_shards * N`
   - **Panic**: Index out of bounds

## Impact Explanation

**High Severity** - This vulnerability enables:

1. **Validator Node Crashes**: Malicious remote executor shards can deterministically crash validator nodes during block execution
2. **Consensus Disruption**: If multiple validators use compromised remote executors, they crash simultaneously, potentially halting consensus
3. **Deterministic Execution Violation**: Validators with different remote executor configurations will crash differently, breaking the requirement that all validators execute blocks identically

The impact is classified as **High** per Aptos bug bounty criteria:
- Validator node crashes/slowdowns
- Significant protocol violations
- Does not require majority stake or validator collusion

## Likelihood Explanation

**Likelihood: Medium-to-High** (conditional on deployment model)

The vulnerability is exploitable if:
1. Remote executor shards are deployed in production (vs. local-only execution)
2. Remote executors communicate over network channels that could be compromised
3. An attacker can control or compromise a remote executor service

The test utilities validate round count consistency but production code does not: [4](#0-3) 

This indicates developers are aware of the requirement but failed to enforce it in production.

## Recommendation

Add validation to ensure all executor shards return consistent round counts before aggregation:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    let _timer = SHARDED_BLOCK_EXECUTION_SECONDS.start_timer();
    let num_executor_shards = self.executor_client.num_shards();
    NUM_EXECUTOR_SHARDS.set(num_executor_shards as i64);
    assert_eq!(
        num_executor_shards,
        transactions.num_shards(),
        "Block must be partitioned into {} sub-blocks",
        num_executor_shards
    );
    let (sharded_output, global_output) = self
        .executor_client
        .execute_block(
            state_view,
            transactions,
            concurrency_level_per_shard,
            onchain_config,
        )?
        .into_inner();
    
    info!("ShardedBlockExecutor Received all results");
    let _aggregation_timer = SHARDED_EXECUTION_RESULT_AGGREGATION_SECONDS.start_timer();
    
    // ADD VALIDATION HERE
    if sharded_output.is_empty() {
        return Err(VMStatus::Error {
            status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            sub_status: None,
            message: Some("No executor shard outputs received".to_string()),
        });
    }
    
    let num_rounds = sharded_output[0].len();
    
    // Validate all shards have the same number of rounds
    for (shard_id, results) in sharded_output.iter().enumerate().skip(1) {
        if results.len() != num_rounds {
            return Err(VMStatus::Error {
                status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                sub_status: None,
                message: Some(format!(
                    "Shard {} returned {} rounds but shard 0 returned {} rounds",
                    shard_id, results.len(), num_rounds
                )),
            });
        }
    }
    
    // ... rest of aggregation logic
}
```

## Proof of Concept

```rust
#[test]
fn test_inconsistent_round_count_causes_panic() {
    // Simulate executor results with inconsistent round counts
    let num_shards = 3;
    let num_rounds_shard_0 = 2;
    let num_rounds_shard_2 = 3; // Malicious shard returns extra round
    
    let mut sharded_output: Vec<Vec<Vec<TransactionOutput>>> = Vec::new();
    
    // Shard 0: 2 rounds with empty results
    sharded_output.push(vec![vec![], vec![]]);
    
    // Shard 1: 2 rounds with empty results  
    sharded_output.push(vec![vec![], vec![]]);
    
    // Shard 2: 3 rounds with empty results (MALICIOUS)
    sharded_output.push(vec![vec![], vec![], vec![]]);
    
    // Attempt aggregation (mimics lines 98-106 of mod.rs)
    let num_rounds = sharded_output[0].len(); // = 2
    let mut ordered_results = vec![vec![]; num_shards * num_rounds]; // size = 6
    
    for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
        for (round, result) in results_from_shard.into_iter().enumerate() {
            let index = round * num_shards + shard_id;
            // When shard_id=2, round=2: index = 2*3+2 = 8, but ordered_results.len()=6
            // This will PANIC with index out of bounds
            ordered_results[index] = result;
        }
    }
}
```

This test demonstrates that when shard 2 returns 3 rounds while shard 0 returns 2 rounds, the indexing calculation `2 * 3 + 2 = 8` exceeds the allocated size of 6, causing a panic.

## Notes

While the partitioner itself correctly guarantees consistent round counts in its output structure [5](#0-4) , the executor fails to validate this invariant when aggregating results from remote executor shards. The vulnerability exploits the gap between partitioner guarantees and executor validation, specifically in distributed execution scenarios where remote shards communicate via network channels.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-106)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** execution/executor-service/src/lib.rs (L32-41)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}

impl RemoteExecutionResult {
    pub fn new(inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>) -> Self {
        Self { inner }
    }
}
```

**File:** execution/block-partitioner/src/test_utils.rs (L165-172)
```rust
    let num_rounds = output
        .sharded_txns()
        .first()
        .map(|sbs| sbs.sub_blocks.len())
        .unwrap_or(0);
    for sub_block_list in output.sharded_txns().iter().take(num_shards).skip(1) {
        assert_eq!(num_rounds, sub_block_list.sub_blocks.len());
    }
```

**File:** execution/block-partitioner/src/v2/build_edge.rs (L73-86)
```rust
        let sharded_txns = (0..state.num_executor_shards)
            .map(|shard_id| {
                let sub_blocks: Vec<SubBlock<AnalyzedTransaction>> = (0..final_num_rounds)
                    .map(|round_id| {
                        state.sub_block_matrix[round_id][shard_id]
                            .lock()
                            .unwrap()
                            .take()
                            .unwrap()
                    })
                    .collect();
                SubBlocksForShard::new(shard_id, sub_blocks)
            })
            .collect();
```
