# Audit Report

## Title
Unhandled PartialVMResult in hash_to_structure Native Function Causes Validator Crash

## Summary
The `suite_from_ty_arg!` macro in the hash_to_structure native function contains an `.unwrap()` call on a `PartialVMResult` return value from `type_to_type_tag()`. This unwrap can panic when converting complex or invalid type arguments, causing validator nodes to crash during transaction execution.

## Finding Description

The vulnerability exists in the `suite_from_ty_arg!` macro which is used to extract type argument information in cryptographic algebra native functions. [1](#0-0) 

This macro calls `context.type_to_type_tag()` which returns a `PartialVMResult<TypeTag>`, but immediately unwraps it without proper error handling. The `type_to_type_tag()` method can fail in multiple scenarios: [2](#0-1) [3](#0-2) 

The macro is invoked during execution of the `hash_to_internal` native function: [4](#0-3) 

When a user calls the public Move function `crypto_algebra::hash_to<S, H>()`, the type arguments flow through to the native implementation: [5](#0-4) [6](#0-5) 

**Attack Vector:**
An attacker can craft a transaction with type arguments that cause `type_to_type_tag()` to fail (e.g., exceeding TYPE_TAG_LIMIT_EXCEEDED by using deeply nested generic types or extremely long struct names). When the native function executes, the unwrap panics, crashing the validator.

The interpreter does not catch panics from native functions, so the entire validator process terminates. This breaks the fundamental invariant that validators must handle all user inputs gracefully without crashing.

**Inconsistency Evidence:**
The codebase shows that other algebra natives properly handle this same call using the `?` operator: [7](#0-6) 

This demonstrates that proper error handling is both possible and implemented elsewhere, making the unwrap in `suite_from_ty_arg!` an obvious oversight.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability enables:
1. **Validator node crashes**: Malicious transactions cause validators to panic and terminate
2. **Liveness degradation**: If multiple validators process the same malicious transaction, network liveness is impacted
3. **Deterministic execution violation**: All validators executing the same malicious transaction will crash identically, but the network cannot make progress until validators restart and skip the transaction

While not causing permanent network partition or fund loss, this qualifies as High severity due to:
- Validator node slowdowns/crashes (explicit High category)
- Protocol violation (validators should never panic from user input)
- Potential for repeated DoS attacks

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
- Crafting a Move transaction with type arguments that exceed type tag conversion limits
- Successfully getting the transaction through mempool and into a block
- The BLS12_381_STRUCTURES feature flag being enabled (required for hash_to functions)

Factors increasing likelihood:
- Public function accessible to any user
- No special permissions required
- Deterministic: same input always triggers the crash
- Move compiler may allow complex generic types that exceed runtime limits

Factors decreasing likelihood:
- Requires understanding of type tag complexity limits
- Move verifier may reject some problematic type constructions
- Feature flag may not be enabled on all networks

## Recommendation

Replace the unwrap with proper error propagation using the `?` operator, matching the pattern used in `structure_from_ty_arg!`:

```rust
macro_rules! suite_from_ty_arg {
    ($context:expr, $typ:expr) => {{
        let type_tag = $context.type_to_type_tag($typ)?;  // Changed from .unwrap()
        HashToStructureSuite::try_from(type_tag).ok()
    }};
}
```

This ensures that if `type_to_type_tag()` fails, the error is properly returned through the `SafeNativeResult`, allowing the VM to handle it gracefully as an abort rather than a panic.

Additional hardening: Consider adding explicit validation of type argument complexity before calling `type_to_type_tag()` in all algebra native functions.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the vulnerability pattern
// In a Move test environment with BLS12_381_STRUCTURES enabled:

module attacker::exploit {
    use aptos_std::crypto_algebra;
    
    // Create a deeply nested generic type to exceed TYPE_TAG_LIMIT_EXCEEDED
    struct Nested<T> { inner: T }
    
    public entry fun trigger_crash() {
        // Attempting to call hash_to with a very complex nested type
        // that exceeds the pseudo-gas limit in type_to_type_tag
        let dst = vector::empty<u8>();
        let msg = vector::empty<u8>();
        
        // This call with sufficiently complex type arguments will cause
        // type_to_type_tag to return an error, which gets unwrapped,
        // panicking the validator
        let _result = crypto_algebra::hash_to<
            Nested<Nested<Nested<Nested<Nested<u64>>>>>,
            SomeHashToStructureSuite
        >(&dst, &msg);
    }
}
```

The actual exploitation would require constructing type arguments that specifically exceed the type tag conversion limits while still passing the Move verifier. The key point is that the unwrap makes this exploitable regardless of the exact type construction needed.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/hash_to_structure.rs (L47-52)
```rust
macro_rules! suite_from_ty_arg {
    ($context:expr, $typ:expr) => {{
        let type_tag = $context.type_to_type_tag($typ).unwrap();
        HashToStructureSuite::try_from(type_tag).ok()
    }};
}
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/hash_to_structure.rs (L81-89)
```rust
pub fn hash_to_internal(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(2, ty_args.len());
    let structure_opt = structure_from_ty_arg!(context, &ty_args[0]);
    let suite_opt = suite_from_ty_arg!(context, &ty_args[1]);
    abort_unless_hash_to_structure_enabled!(context, structure_opt, suite_opt);
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L50-62)
```rust
    fn charge(&mut self, amount: u64) -> PartialVMResult<()> {
        self.cost += amount;
        if self.cost > self.max_cost {
            Err(
                PartialVMError::new(StatusCode::TYPE_TAG_LIMIT_EXCEEDED).with_message(format!(
                    "Exceeded maximum type tag limit of {} when charging {}",
                    self.max_cost, amount
                )),
            )
        } else {
            Ok(())
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L326-333)
```rust
            // References and type parameters cannot be converted to tags.
            Type::Reference(_) | Type::MutableReference(_) | Type::TyParam(_) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message(format!("No type tag for {:?}", ty)),
                );
            },
        })
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move (L258-263)
```text
    public fun hash_to<S, H>(dst: &vector<u8>, msg: &vector<u8>): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element {
            handle: hash_to_internal<S, H>(dst, msg)
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move (L318-318)
```text
    native fun hash_to_internal<S, H>(dst: &vector<u8>, bytes: &vector<u8>): u64;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L95-100)
```rust
macro_rules! structure_from_ty_arg {
    ($context:expr, $typ:expr) => {{
        let type_tag = $context.type_to_type_tag($typ)?;
        Structure::try_from(type_tag).ok()
    }};
}
```
