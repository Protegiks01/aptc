# Audit Report

## Title
Consensus Observer Fails to Detect Version Rollback as Critical Consensus Failure

## Summary
The `check_syncing_progress()` function in the consensus observer subscription manager treats database version rollback (version decreasing) identically to normal no-progress scenarios (version stagnant), delaying detection of critical consensus failures by up to 15 seconds and using misleading error messages.

## Finding Description

The consensus observer's subscription health monitoring uses a `<=` comparison that conflates two fundamentally different failure modes: [1](#0-0) 

When `current_synced_version <= highest_synced_version`, the code treats both scenarios identically:
1. **No progress** (`current_synced_version == highest_synced_version`): Chain is stalled but state is consistent
2. **Version rollback** (`current_synced_version < highest_synced_version`): State has regressed backwards, indicating fork, database corruption, or consensus failure [2](#0-1) 

This violates the critical invariant that ledger versions must be monotonically increasing. The Aptos node health checker explicitly recognizes version rollback as the most severe failure (score 0) versus no progress (score 25): [3](#0-2) 

Version rollback can occur when:
- A consensus observer follows a malicious/compromised validator on a fork
- Database is restored from an earlier backup
- State synchronization bugs cause temporary regression
- Storage corruption due to hardware failures

The storage layer enforces monotonicity for WRITES but cannot prevent READS from seeing rolled-back versions: [4](#0-3) 

By treating rollback as benign "no progress," the observer continues operating in a potentially compromised state for up to `max_subscription_sync_timeout_ms` (default: 15 seconds): [5](#0-4) 

When the timeout finally expires, the error message incorrectly states "not making sync progress" rather than identifying the version rollback: [6](#0-5) 

## Impact Explanation

**High Severity** - This qualifies as a "significant protocol violation" per Aptos bug bounty criteria because:

1. **Delayed Critical Failure Detection**: Version rollback indicates severe consensus or storage issues that should trigger immediate alerts and fallback procedures, not a 15-second timeout grace period.

2. **Misleading Diagnostics**: Operators receive incorrect error messages, hindering incident response during consensus emergencies.

3. **Continued Operation in Unsafe State**: The consensus observer continues accepting and potentially serving blocks/transactions based on rolled-back state during the timeout window.

4. **Affects Production Infrastructure**: Consensus observer is enabled by default on validator fullnodes, making this a widespread issue: [7](#0-6) 

The same vulnerability exists in the fallback manager's version checking: [8](#0-7) 

## Likelihood Explanation

**Medium-High Likelihood** in adversarial scenarios:

1. **Byzantine Validators**: In Aptos's threat model supporting up to 1/3 Byzantine validators, a malicious validator in an observer's subscription set could send crafted consensus messages causing the observer to process blocks out of order or follow a fork.

2. **Operational Errors**: Database restores from backups or snapshot reverts are common operational procedures that would trigger this code path.

3. **State Sync Bugs**: Any bugs in state synchronization could temporarily cause version regression, which should be detected immediately rather than after timeout.

The consensus observer is designed to operate in Byzantine environments, so failure to immediately detect version rollback represents a security gap in its threat model.

## Recommendation

Modify `check_syncing_progress()` to explicitly differentiate version rollback from no progress:

```rust
fn check_syncing_progress(&mut self) -> Result<(), Error> {
    let time_now = self.time_service.now();
    let current_synced_version = self.db_reader
        .get_latest_ledger_info_version()
        .map_err(|error| {
            Error::UnexpectedError(format!(
                "Failed to read highest synced version: {:?}",
                error
            ))
        })?;

    let (highest_synced_version, highest_version_timestamp) =
        self.highest_synced_version_and_time;
    
    // Check for version rollback (critical failure)
    if current_synced_version < highest_synced_version {
        return Err(Error::UnexpectedError(format!(
            "CRITICAL: DB version rolled back! Current: {}, Previous highest: {}. \
             This indicates a fork, database corruption, or consensus failure.",
            current_synced_version, highest_synced_version
        )));
    }
    
    // Check for no progress (timeout-based)
    if current_synced_version == highest_synced_version {
        let duration_since_highest_seen = time_now.duration_since(highest_version_timestamp);
        let timeout_duration = Duration::from_millis(
            self.consensus_observer_config.max_subscription_sync_timeout_ms,
        );
        if duration_since_highest_seen > timeout_duration {
            return Err(Error::SubscriptionProgressStopped(format!(
                "The DB is not making sync progress! Highest synced version: {}, elapsed: {:?}",
                highest_synced_version, duration_since_highest_seen
            )));
        }
        return Ok(());
    }

    // Version increased - update tracking
    self.highest_synced_version_and_time = (current_synced_version, time_now);
    Ok(())
}
```

Apply the same fix to `fallback_manager.rs`: [9](#0-8) 

## Proof of Concept

```rust
#[test]
fn test_version_rollback_detection() {
    // Create observer config
    let consensus_observer_config = ConsensusObserverConfig::default();
    
    // Create mock DB that returns decreasing versions
    let first_version = 100;
    let rolled_back_version = 50;  // Version goes backward!
    let mut mock_db_reader = MockDatabaseReader::new();
    mock_db_reader
        .expect_get_latest_ledger_info_version()
        .returning(move || Ok(first_version))
        .times(1);
    mock_db_reader
        .expect_get_latest_ledger_info_version()
        .returning(move || Ok(rolled_back_version));
    
    // Create subscription
    let time_service = TimeService::mock();
    let peer_network_id = PeerNetworkId::random();
    let mut subscription = ConsensusObserverSubscription::new(
        consensus_observer_config,
        Arc::new(mock_db_reader),
        peer_network_id,
        time_service.clone(),
    );
    
    // First check - establishes baseline at version 100
    assert!(subscription.check_syncing_progress().is_ok());
    assert_eq!(subscription.highest_synced_version_and_time.0, first_version);
    
    // Second check - version rolled back to 50
    // BUG: Currently returns Ok() because rollback is treated as no-progress
    // EXPECTED: Should immediately return error about version rollback
    let result = subscription.check_syncing_progress();
    
    // Current behavior (WRONG): Returns Ok() for up to 15 seconds
    // Expected behavior (CORRECT): Should immediately error on rollback
    assert!(result.is_err(), "Version rollback should be immediately detected!");
    assert!(result.unwrap_err().to_string().contains("rolled back") 
            || result.unwrap_err().to_string().contains("backwards"));
}
```

## Notes

This vulnerability exists in both the subscription manager and fallback manager components of the consensus observer. The fix should be applied consistently across both files to ensure version rollback is immediately detected and reported with accurate error messages that aid in incident response.

### Citations

**File:** consensus/src/consensus_observer/observer/subscription.rs (L198-216)
```rust
        // Verify that the synced version is increasing appropriately
        let (highest_synced_version, highest_version_timestamp) =
            self.highest_synced_version_and_time;
        if current_synced_version <= highest_synced_version {
            // The synced version hasn't increased. Check if we should terminate
            // the subscription based on the last time the highest synced version was seen.
            let duration_since_highest_seen = time_now.duration_since(highest_version_timestamp);
            let timeout_duration = Duration::from_millis(
                self.consensus_observer_config
                    .max_subscription_sync_timeout_ms,
            );
            if duration_since_highest_seen > timeout_duration {
                return Err(Error::SubscriptionProgressStopped(format!(
                    "The DB is not making sync progress! Highest synced version: {}, elapsed: {:?}",
                    highest_synced_version, duration_since_highest_seen
                )));
            }
            return Ok(()); // We haven't timed out yet
        }
```

**File:** ecosystem/node-checker/src/checker/state_sync_version.rs (L45-66)
```rust
        // We convert to i64 to avoid potential overflow if somehow the ledger version went backwards.
        let target_progress = latest_target_version as i64 - previous_target_version as i64;
        match target_progress {
            0 => Self::build_result(
                "Ledger version is not increasing".to_string(),
                25,
                format!(
                    "Successfully pulled ledger version from your node \
                        twice, but the ledger version is not increasing ({} both times).",
                    latest_target_version
                ),
            ),
            target_progress if (target_progress < 0) => Self::build_result(
                "Ledger version went backwards!".to_string(),
                0,
                format!(
                    "Successfully pulled ledger version from your node twice, \
                    but the second time the ledger version went backwards! \
                    First datapoint: {}, second datapoint: {}",
                    previous_target_version, latest_target_version
                ),
            ),
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L525-530)
```rust
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
```

**File:** config/src/config/consensus_observer_config.rs (L12-13)
```rust
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
```

**File:** config/src/config/consensus_observer_config.rs (L75-75)
```rust
            max_subscription_sync_timeout_ms: 15_000, // 15 seconds
```

**File:** consensus/src/consensus_observer/observer/fallback_manager.rs (L89-117)
```rust
    fn verify_increasing_sync_versions(
        &mut self,
        latest_ledger_info_version: Version,
        time_now: Instant,
    ) -> Result<(), Error> {
        // Verify that the synced version is increasing appropriately
        let (highest_synced_version, highest_version_timestamp) =
            self.highest_synced_version_and_time;
        if latest_ledger_info_version <= highest_synced_version {
            // The synced version hasn't increased. Check if we should enter fallback mode.
            let duration_since_highest_seen = time_now.duration_since(highest_version_timestamp);
            let fallback_threshold = Duration::from_millis(
                self.consensus_observer_config
                    .observer_fallback_progress_threshold_ms,
            );
            if duration_since_highest_seen > fallback_threshold {
                Err(Error::ObserverProgressStopped(format!(
                    "Consensus observer is not making progress! Highest synced version: {}, elapsed: {:?}",
                    highest_synced_version, duration_since_highest_seen
                )))
            } else {
                Ok(()) // We haven't passed the fallback threshold yet
            }
        } else {
            // The synced version has increased. Update the highest synced version and time.
            self.highest_synced_version_and_time = (latest_ledger_info_version, time_now);
            Ok(())
        }
    }
```
