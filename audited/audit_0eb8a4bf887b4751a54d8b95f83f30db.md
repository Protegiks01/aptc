# Audit Report

## Title
Missing HTTP Request Timeout in Localnet Indexer API Causes Indefinite Hangs During Startup

## Summary
The `make_hasura_metadata_request()` function in the localnet indexer API creates an HTTP client without timeout configuration, allowing a malicious or unresponsive Hasura instance to cause indefinite hangs and resource exhaustion during localnet startup.

## Finding Description
The `make_hasura_metadata_request()` function creates a reqwest HTTP client using `reqwest::Client::new()` without configuring any timeout. [1](#0-0) 

The HTTP POST request is then made without any timeout configuration. [2](#0-1) 

This function is called during health checks to confirm metadata is applied. [3](#0-2) 

While the health checker has an outer 60-second timeout loop [4](#0-3) , each individual HTTP request within `make_hasura_metadata_request()` can hang indefinitely if the Hasura server accepts the connection but never responds.

**Attack Scenario:**
1. Attacker sets up a malicious Hasura server that accepts TCP connections but never sends HTTP responses
2. Developer starts localnet with `--existing-hasura-url` pointing to the malicious server
3. During startup, the health checker calls `confirm_metadata_applied()` which calls `make_hasura_metadata_request()`
4. The HTTP request hangs indefinitely, blocking the async task
5. Multiple retry attempts accumulate, each consuming resources
6. Localnet fails to start, causing developer frustration and wasted time

Other parts of the codebase properly configure timeouts using `ReqwestClient::builder().timeout(Duration::from_secs(10))`. [5](#0-4) 

## Impact Explanation
This qualifies as **Medium severity** per the bug bounty criteria under "Validator node slowdowns" - although this specifically affects the localnet development environment rather than production validators, it still represents a resource exhaustion vulnerability that can cause service unavailability. The impact includes:

- Indefinite hangs during localnet startup
- Resource exhaustion from accumulated hanging requests
- Denial of service for developers using the localnet tool
- Potential for multiple async tasks to accumulate if retries occur

However, **critical context**: This affects the **localnet development tool only**, not production blockchain infrastructure. It does not impact consensus, state management, or production validator operations.

## Likelihood Explanation
**Moderate likelihood** if a developer:
- Uses the `--existing-hasura-url` flag to point to an external Hasura instance
- The Hasura instance is malicious, misconfigured, or experiencing network issues
- The instance accepts connections but fails to respond

**Low likelihood** in typical usage where developers rely on the default Docker-based Hasura instance managed by the localnet tool itself.

## Recommendation
Configure a reasonable timeout for the HTTP client or individual requests:

**Option 1: Client-level timeout**
```rust
let client = reqwest::Client::builder()
    .timeout(Duration::from_secs(30))
    .build()?;
```

**Option 2: Request-level timeout**
```rust
let response = client.post(url)
    .json(&payload)
    .timeout(Duration::from_secs(30))
    .send()
    .await?;
```

A 30-second timeout is reasonable for metadata operations while preventing indefinite hangs.

## Proof of Concept

```rust
// Reproduction test - simulates a hanging Hasura server
#[tokio::test]
async fn test_hanging_hasura_server() {
    use tokio::net::TcpListener;
    use tokio::time::{timeout, Duration};
    
    // Start a TCP server that accepts connections but never responds
    let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    
    tokio::spawn(async move {
        loop {
            if let Ok((socket, _)) = listener.accept().await {
                // Accept connection but never send response
                tokio::spawn(async move {
                    let _ = socket;
                    tokio::time::sleep(Duration::from_secs(3600)).await;
                });
            }
        }
    });
    
    // Attempt to make request - this will hang without timeout
    let url = Url::parse(&format!("http://{}", addr)).unwrap();
    
    let result = timeout(
        Duration::from_secs(5),
        make_hasura_metadata_request(url, "export_metadata", None)
    ).await;
    
    // Without timeouts in make_hasura_metadata_request, this will timeout
    assert!(result.is_err(), "Request should timeout after 5 seconds");
}
```

## Notes

**Important Clarification**: While this is a valid code quality issue, it has **limited security impact** because:

1. **Scope is localnet only** - This affects the `aptos-localnet` development tool, not production validator nodes or blockchain infrastructure
2. **No production impact** - Does not affect consensus, state management, transaction processing, or any production blockchain operations
3. **Developer-controlled** - Only affects developers who explicitly use `--existing-hasura-url` to point to external Hasura instances
4. **No blockchain security guarantees violated** - Does not break any of the critical invariants related to consensus safety, execution determinism, state consistency, or governance integrity

This should be classified as a **development tool reliability issue** rather than a blockchain security vulnerability. It warrants fixing to improve developer experience and prevent resource leaks, but does not pose a threat to the Aptos blockchain's security or integrity.

### Citations

**File:** crates/aptos-localnet/src/indexer_api.rs (L94-94)
```rust
    let client = reqwest::Client::new();
```

**File:** crates/aptos-localnet/src/indexer_api.rs (L115-115)
```rust
    let response = client.post(url).json(&payload).send().await?;
```

**File:** crates/aptos-localnet/src/health_checker.rs (L119-121)
```rust
            HealthChecker::IndexerApiMetadata(url) => {
                confirm_metadata_applied(url.clone()).await?;
                Ok(())
```

**File:** crates/aptos-localnet/src/health_checker.rs (L187-205)
```rust
    let max_wait = Duration::from_secs(MAX_WAIT_S);
    let wait_interval = Duration::from_millis(WAIT_INTERVAL_MS);

    let start = Instant::now();
    let mut started_successfully = false;

    let mut last_error_message = None;
    while start.elapsed() < max_wait {
        match check_fn().await {
            Ok(_) => {
                started_successfully = true;
                break;
            },
            Err(err) => {
                last_error_message = Some(format!("{:#}", err));
            },
        }
        tokio::time::sleep(wait_interval).await
    }
```

**File:** crates/aptos-rest-client/src/faucet.rs (L25-28)
```rust
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
```
