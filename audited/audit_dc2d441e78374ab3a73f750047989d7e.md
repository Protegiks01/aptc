# Audit Report

## Title
DKG Chunky PVSS Transcript Inner Dimension Validation Bypass Causes Consensus Node Crash

## Summary
The `verify()` function in the chunky weighted PVSS transcript implementation only validates outer array dimensions but fails to check inner dimension consistency between `Cs` and `Vs` arrays. This allows a malicious validator to craft a transcript that passes verification but causes validator nodes to panic during transcript aggregation, resulting in consensus failure.

## Finding Description

The vulnerability exists in the transcript verification logic that validates multi-dimensional array structures without checking per-player dimension consistency.

**Data Structure:**
- `Cs: Vec<Vec<Vec<E::G1>>>` - 3D array where `Cs[player][weight_index][chunk]`
- `Vs: Vec<Vec<E::G2>>` - 2D array where `Vs[player][weight_index]`

**Expected Invariant:**
For each player `i`, both `Cs[i].len()` and `Vs[i].len()` should equal `weight[i]`.

**Insufficient Validation:**
The verification only checks outer dimensions: [1](#0-0) 

These checks ensure `Cs.len() == Vs.len() == num_players`, but do NOT validate that `Cs[i].len() == Vs[i].len()` for each player `i`.

Additional validation only checks the total flattened count: [2](#0-1) 

This ensures total ciphertext count equals total weight, but allows arbitrary distribution across players (e.g., player 0 could have all ciphertexts while player 1 has none, as long as the total matches).

**Exploitation During Aggregation:**
When transcripts are aggregated, the code iterates using `Vs[i].len()` and directly accesses `Cs[i][j]`: [3](#0-2) 

The `debug_assert` checks at lines 388-392 are only enforced in debug builds, not production. If `Cs[i].len() < Vs[i].len()`, accessing `self.Cs[i][j]` when `j >= Cs[i].len()` causes an index out of bounds panic.

**Attack Path:**
1. Malicious validator crafts transcript with mismatched inner dimensions (e.g., `Cs[0].len() = 1` but `Vs[0].len() = 2`)
2. Adjusts other players' dimensions so total flattened count still equals `sc.get_total_weight()`
3. Transcript passes `verify()` since only outer dimensions and total count are checked
4. Honest nodes receive and verify the transcript - it passes all checks
5. During DKG consensus aggregation via `TranscriptAggregationState::add()`: [4](#0-3) 
6. When `aggregate_transcripts()` is called: [5](#0-4) 
7. The `.expect()` propagates the panic from `aggregate_with()`, crashing the validator node

## Impact Explanation

**Critical Severity** - This meets multiple Critical impact categories:

1. **Consensus Safety Violation**: Validators attempting to aggregate transcripts crash, preventing consensus progress. If enough validators crash, the network cannot reach quorum.

2. **Total Loss of Liveness**: A single malicious transcript broadcast to the network causes all honest validators attempting to aggregate it to crash, halting DKG and preventing epoch transitions.

3. **Non-Recoverable Without Intervention**: Once the malicious transcript enters the aggregation state, validators will continuously crash when attempting to process it. Recovery requires manual intervention to remove the malicious transcript or restart nodes with patched code.

The attack requires no special privileges beyond being a validator during DKG, and the impact affects the entire validator set simultaneously.

## Likelihood Explanation

**High Likelihood:**

- **Low Complexity**: Crafting the malicious transcript only requires understanding the expected data structure and deliberately mismatching inner dimensions while maintaining correct outer dimensions and total counts.

- **No Special Access Required**: Any validator participating in DKG can submit such a transcript. No collusion or majority stake is needed.

- **Deterministic Exploitation**: Once the malicious transcript is created, the exploitation is guaranteed - all nodes attempting aggregation will crash.

- **Direct Attack Surface**: DKG transcript submission is a normal protocol operation, making detection difficult without the fix.

The only barrier is that the attacker must be part of the validator set during a DKG session, which is achievable through normal stake-based participation.

## Recommendation

Add validation in the `verify()` function to check inner dimension consistency:

```rust
// After line 152, add:
for i in 0..sc.get_total_num_players() {
    let expected_weight = sc.get_player_weight(&sc.get_player(i));
    if self.subtrs.Cs[i].len() != expected_weight {
        bail!(
            "Expected {} ciphertext arrays for player {}, but got {}",
            expected_weight,
            i,
            self.subtrs.Cs[i].len()
        );
    }
    if self.subtrs.Vs[i].len() != expected_weight {
        bail!(
            "Expected {} commitment arrays for player {}, but got {}",
            expected_weight,
            i,
            self.subtrs.Vs[i].len()
        );
    }
}
```

Additionally, replace `debug_assert_eq!` with runtime assertions in `aggregate_with()`:

```rust
// Replace lines 388-392 with:
assert_eq!(self.Cs.len(), sc.get_total_num_players(), 
    "Self transcript has incorrect number of Cs arrays");
assert_eq!(self.Vs.len(), sc.get_total_num_players(),
    "Self transcript has incorrect number of Vs arrays");
assert_eq!(self.Cs.len(), other.Cs.len(),
    "Transcript Cs length mismatch during aggregation");
assert_eq!(self.Vs.len(), other.Vs.len(),
    "Transcript Vs length mismatch during aggregation");
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_crypto::weighted_config::WeightedConfigArkworks;
    use rand::thread_rng;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_inner_dimension_mismatch_causes_panic() {
        let mut rng = thread_rng();
        
        // Create a weighted config with 2 players: weights [2, 3]
        let sc = WeightedConfigArkworks::new(3, vec![2, 3]).unwrap();
        let pp = PublicParameters::default();
        
        // Create a malicious transcript with mismatched inner dimensions
        let mut malicious_trx = Transcript::generate(&sc, &pp, &mut rng);
        
        // Manipulate inner dimensions while keeping outer dimensions correct
        // Player 0: should have 2 elements, but give only 1
        // Player 1: should have 3 elements, but give 4 to maintain total count
        malicious_trx.subtrs.Cs[0].truncate(1);
        malicious_trx.subtrs.Vs[0].truncate(1);
        
        // Add extra element to player 1 to keep total count correct
        let extra_c = malicious_trx.subtrs.Cs[1][0].clone();
        let extra_v = malicious_trx.subtrs.Vs[1][0];
        malicious_trx.subtrs.Cs[1].push(extra_c);
        malicious_trx.subtrs.Vs[1].push(extra_v);
        
        // Create a legitimate transcript for aggregation
        let legit_trx = Transcript::generate(&sc, &pp, &mut rng);
        
        // Attempt aggregation - this will panic due to index out of bounds
        let mut accumulator = legit_trx.subtrs.clone();
        accumulator.aggregate_with(&sc, &malicious_trx.subtrs).unwrap();
    }
}
```

## Notes

This vulnerability specifically affects the chunky weighted PVSS transcript implementation. The outer dimension validation is correctly implemented, but the missing per-player inner dimension validation creates an exploitable inconsistency. The use of `debug_assert` instead of runtime assertions in the aggregation path further compounds the issue by removing safety checks in production builds.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-152)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L397-406)
```rust
        for i in 0..sc.get_total_num_players() {
            for j in 0..self.Vs[i].len() {
                // Aggregate the V_{i,j}s
                self.Vs[i][j] += other.Vs[i][j];
                for k in 0..self.Cs[i][j].len() {
                    // Aggregate the C_{i,j,k}s
                    self.Cs[i][j][k] += other.Cs[i][j][k];
                }
            }
        }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L408-411)
```rust
        accumulator
            .main
            .aggregate_with(&params.pvss_config.wconfig, &element.main)
            .expect("Transcript aggregation failed");
```
