After extensive analysis of the epoch ending ledger info request/response flow, I've traced through the complete code paths from client request creation to response validation. Here is my finding:

# Audit Report

## Title
Missing Epoch Boundary Validation in Response Processing Allows State Desynchronization via Malicious Peer Responses

## Summary
The `get_epoch_ending_ledger_infos()` function and its response handling in the data streaming service fail to validate that received epoch ending ledger infos match the requested epoch range. A malicious peer can send extra epochs beyond `expected_end_epoch`, causing the stream engine to desynchronize from the actual verified epoch state, leading to subsequent epoch transition verification failures.

## Finding Description

The vulnerability exists in the response validation logic in the epoch ending stream engine. While the client properly creates requests with `start_epoch` and `expected_end_epoch` parameters [1](#0-0) , and the server validates these parameters [2](#0-1) , the client does NOT validate that the response contains only epochs within the requested range.

**Attack Flow:**

1. The stream engine creates a request for epochs 6-10 and maintains `next_stream_epoch = 6` [3](#0-2) 

2. A malicious peer bypasses server-side validation and sends epoch ending ledger infos for epochs 6-13 (7 extra epochs beyond the requested range)

3. The stream engine's response handler extracts the last epoch from the response [4](#0-3)  and bounds it: `bound_by_range(13, 6, 10) = 10`

4. The stream engine updates `next_stream_epoch = 11` and may NOT mark the stream complete if the overall stream `end_epoch` is higher than 10 [5](#0-4) 

5. Meanwhile, the bootstrapper processes ALL ledger infos in the response (6-13) [6](#0-5) , advancing the verified state to epoch 14

6. **State Desynchronization**: Stream engine believes it's at epoch 10, but actual verified state is at epoch 14

7. The stream engine creates a new request for epochs 11-15

8. When processing epoch 11's ledger info, the bootstrapper calls `latest_epoch_state.verify()` [7](#0-6)  using epoch 14's validator set to verify epoch 11's signatures, which fails because epoch 11 should be verified by epoch 10's validators

9. **Epoch Transition Failure**: Verification fails, stream resets with `PayloadProofFailed` feedback [8](#0-7) 

The root cause is that `bound_by_range()` silently clamps out-of-range epochs [9](#0-8)  instead of rejecting invalid responses, while the bootstrapper processes all received ledger infos regardless of the request boundaries.

## Impact Explanation

**Severity: High**

This vulnerability causes **epoch transition verification failures** and **state synchronization disruption**, meeting the High Severity criteria of "significant protocol violations" and "validator node slowdowns" in the Aptos bug bounty program.

**Specific Impacts:**
- Nodes receiving malicious responses become unable to complete epoch synchronization
- State sync process repeatedly fails and resets, preventing nodes from catching up
- Affected nodes may fall behind the network, causing validator performance degradation
- In widespread attacks, network liveness could be impacted if many nodes are affected simultaneously

While this doesn't directly cause consensus safety violations or fund loss, it represents a significant availability attack that can prevent nodes from participating in consensus.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- A malicious peer in the P2P network (low barrier - anyone can run a node)
- Ability to craft responses with valid signatures but extra epochs (requires obtaining valid historical epoch ending ledger infos from the blockchain)
- Target node requesting epoch ranges that allow for continuation after the malicious response

The attack is **moderately easy to execute** because:
- No special privileges required beyond running a network peer
- Historical epoch ending ledger infos are publicly available from the blockchain
- The attacker can repeatedly send malicious responses to disrupt multiple victims

The attack is **likely to occur** in adversarial network conditions where nodes sync from untrusted peers.

## Recommendation

Add strict validation in the epoch ending stream engine to reject responses containing epochs outside the requested range:

```rust
// In stream_engine.rs, EpochEndingStreamEngine::transform_client_response_into_notification
EpochEndingLedgerInfos(request) => {
    // Verify the client request indices
    verify_client_request_indices(
        self.next_stream_epoch,
        request.start_epoch,
        request.end_epoch,
    )?;

    let last_received_epoch = match &client_response_payload {
        ResponsePayload::EpochEndingLedgerInfos(ledger_infos) => {
            if ledger_infos.is_empty() {
                return Err(Error::AptosDataClientResponseIsInvalid(format!(
                    "Received an empty epoch ending ledger info response! Request: {:?}",
                    client_request
                )));
            }

            // NEW: Validate first epoch matches request
            let first_epoch = ledger_infos[0].ledger_info().epoch();
            if first_epoch != request.start_epoch {
                return Err(Error::AptosDataClientResponseIsInvalid(format!(
                    "Response first epoch {} doesn't match request start_epoch {}",
                    first_epoch, request.start_epoch
                )));
            }

            let last_epoch = ledger_infos.last().unwrap().ledger_info().epoch();
            
            // NEW: Validate last epoch doesn't exceed request
            if last_epoch > request.end_epoch {
                return Err(Error::AptosDataClientResponseIsInvalid(format!(
                    "Response last epoch {} exceeds request end_epoch {}",
                    last_epoch, request.end_epoch
                )));
            }

            // NEW: Validate epochs are contiguous
            for i in 1..ledger_infos.len() {
                let prev_epoch = ledger_infos[i-1].ledger_info().epoch();
                let curr_epoch = ledger_infos[i].ledger_info().epoch();
                if curr_epoch != prev_epoch + 1 {
                    return Err(Error::AptosDataClientResponseIsInvalid(format!(
                        "Non-contiguous epochs in response: {} -> {}",
                        prev_epoch, curr_epoch
                    )));
                }
            }

            last_epoch
        },
        _ => invalid_response_type!(client_response_payload),
    };

    // No need for bound_by_range since we validated the range
    self.next_stream_epoch = last_received_epoch.checked_add(1).ok_or_else(|| {
        Error::IntegerOverflow("Next stream epoch has overflown!".into())
    })?;

    if last_received_epoch >= self.end_epoch {
        self.stream_is_complete = true;
    }

    let data_notification = create_data_notification(
        notification_id_generator,
        client_response_payload,
        None,
        self.clone().into(),
    )?;
    Ok(Some(data_notification))
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_malicious_extra_epochs_cause_verification_failure() {
    // Setup: Create a stream requesting epochs 6-10 with overall end_epoch = 15
    let mut stream_engine = EpochEndingStreamEngine {
        request: GetAllEpochEndingLedgerInfosRequest { start_epoch: 6 },
        end_epoch: 15,
        next_stream_epoch: 6,
        next_request_epoch: 6,
        stream_is_complete: false,
    };
    
    // Malicious peer sends epochs 6-13 instead of 6-10
    let malicious_response = create_epoch_ending_ledger_infos(6, 13);
    let request = EpochEndingLedgerInfosRequest {
        start_epoch: 6,
        end_epoch: 10,
    };
    
    // Process the malicious response
    let notification = stream_engine.transform_client_response_into_notification(
        &DataClientRequest::EpochEndingLedgerInfos(request),
        ResponsePayload::EpochEndingLedgerInfos(malicious_response.clone()),
        notification_id_generator.clone(),
    ).unwrap().unwrap();
    
    // Stream engine state after bounding
    assert_eq!(stream_engine.next_stream_epoch, 11); // Bounded to 10, then +1
    assert_eq!(stream_engine.stream_is_complete, false); // 10 < 15
    
    // Bootstrapper processes ALL ledger infos (6-13)
    for ledger_info in malicious_response {
        verified_epoch_states.update_verified_epoch_states(&ledger_info, &waypoint)
            .expect("Should verify successfully");
    }
    
    // Actual state is now at epoch 14
    assert_eq!(verified_epoch_states.latest_epoch_state.epoch, 14);
    
    // Stream creates next request for epoch 11
    let next_request = stream_engine.create_next_request();
    assert_eq!(next_request.start_epoch, 11);
    
    // Processing epoch 11 now FAILS verification
    let epoch_11_ledger_info = create_epoch_ending_ledger_info(11);
    let result = verified_epoch_states.update_verified_epoch_states(
        &epoch_11_ledger_info,
        &waypoint
    );
    
    // Verification fails: trying to verify epoch 11 with epoch 14's validators
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("failed verification"));
}
```

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L935-949)
```rust
    async fn get_epoch_ending_ledger_infos(
        &self,
        start_epoch: Epoch,
        expected_end_epoch: Epoch,
        request_timeout_ms: u64,
    ) -> crate::error::Result<Response<Vec<LedgerInfoWithSignatures>>> {
        let data_request = DataRequest::GetEpochEndingLedgerInfos(EpochEndingLedgerInfoRequest {
            start_epoch,
            expected_end_epoch,
        });
        let response: Response<EpochChangeProof> = self
            .create_and_send_storage_request(request_timeout_ms, data_request)
            .await?;
        Ok(response.map(|epoch_change| epoch_change.ledger_info_with_sigs))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1007-1034)
```rust
    fn check_epoch_ending_ledger_infos_request(
        &self,
        start_epoch: u64,
        end_epoch: u64,
    ) -> Result<()> {
        ensure!(
            start_epoch <= end_epoch,
            "Bad epoch range [{}, {})",
            start_epoch,
            end_epoch,
        );
        // Note that the latest epoch can be the same with the current epoch (in most cases), or
        // current_epoch + 1 (when the latest ledger_info carries next validator set)

        let latest_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info()?
            .ledger_info()
            .next_block_epoch();
        ensure!(
            end_epoch <= latest_epoch,
            "Unable to provide epoch change ledger info for still open epoch. asked upper bound: {}, last sealed epoch: {}",
            end_epoch,
            latest_epoch - 1,  // okay to -1 because genesis LedgerInfo has .next_block_epoch() == 1
        );
        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1614-1623)
```rust
                        // Return the last epoch
                        ledger_infos
                            .last()
                            .map(|ledger_info| ledger_info.ledger_info().epoch())
                            .unwrap_or(request.start_epoch)
                    },
                    _ => invalid_response_type!(client_response_payload),
                };
                let last_received_epoch =
                    bound_by_range(last_received_epoch, request.start_epoch, request.end_epoch);
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1625-1633)
```rust
                // Update the local stream notification tracker
                self.next_stream_epoch = last_received_epoch.checked_add(1).ok_or_else(|| {
                    Error::IntegerOverflow("Next stream epoch has overflown!".into())
                })?;

                // Check if the stream is complete
                if last_received_epoch >= self.end_epoch {
                    self.stream_is_complete = true;
                }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2005-2007)
```rust
pub(crate) fn bound_by_range(number: u64, min: u64, max: u64) -> u64 {
    number.clamp(min, max)
}
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2148-2153)
```rust
        StreamEngine::EpochEndingStreamEngine(_) => {
            EpochEndingLedgerInfos(EpochEndingLedgerInfosRequest {
                start_epoch: start_index,
                end_epoch: end_index,
            })
        },
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L103-108)
```rust
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1092-1106)
```rust
        // Verify the epoch change proofs, update our latest epoch state and
        // verify our waypoint.
        for epoch_ending_ledger_info in epoch_ending_ledger_infos {
            if let Err(error) = self.verified_epoch_states.update_verified_epoch_states(
                &epoch_ending_ledger_info,
                &self.driver_configuration.waypoint,
            ) {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
        }
```
