# Audit Report

## Title
Incomplete Genesis Write Set Validation Allows Malicious State Deletions

## Summary
The genesis validation function `verify_genesis_module_write_set()` only validates that module state keys are creation operations, but does not validate that non-module state keys (resources, tables, events, etc.) do not contain deletion operations. This allows malicious genesis transactions loaded from files to delete critical system resources during blockchain initialization, potentially corrupting the initial state.

## Finding Description

**Note:** The specific file `aptos-core/aptos-move/aptos-vm-profiling/src/bins/run_aptos_p2p.rs` mentioned in the security question does not exist in this repository. However, the underlying security concern about genesis validation is valid and affects the actual genesis processing code.

The genesis validation logic has a critical gap. When genesis transactions are created or executed, the validation only checks module state keys, not other types of state keys. [1](#0-0) 

This function is called during genesis transaction creation: [2](#0-1) 

The problem is that `verify_genesis_module_write_set()` **only validates module paths** using the `if state_key.is_module_path()` condition. Any deletion operations on non-module state keys (resources, tables, events) are **not validated**.

When genesis transactions are executed through `WriteSetPayload::Direct`, the VM does not perform any deletion validation: [3](#0-2) 

The `apply_write_set()` function blindly applies all operations including deletions without validation: [4](#0-3) 

**Attack Path:**

1. Attacker crafts a `Transaction::GenesisTransaction(WriteSetPayload::Direct(malicious_changeset))` where `malicious_changeset` contains deletion operations for critical resources (validator set, stake pools, configuration resources)
2. Attacker serializes this transaction to a file
3. Attacker provides this file to the `aptos-db-bootstrapper` tool: [5](#0-4) 

4. The tool loads and executes the genesis without validating deletions on non-module state keys
5. Critical system resources are deleted, corrupting the blockchain's initial state
6. The node starts with corrupted state, leading to consensus failures or security vulnerabilities

**Evidence the validation is incomplete:**

The test suite explicitly checks that NO deletions should exist in genesis: [6](#0-5) 

This test validates that **all operations** (not just modules) should not be deletions, but the runtime validation function only checks modules.

## Impact Explanation

This vulnerability breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." By allowing deletions of critical resources during genesis, an attacker can create a corrupted initial state that violates fundamental blockchain invariants.

**Severity: High (per Aptos Bug Bounty criteria)**

This qualifies as "Significant protocol violations" and "State inconsistencies requiring intervention" because:

1. **Protocol Violations**: Deleting critical resources like `ValidatorSet`, `ConfigurationResource`, or stake pool resources during genesis violates the protocol's assumption that these resources exist and are properly initialized

2. **Consensus Impact**: If validators initialize with different genesis states (some with deletions, some without), they will produce different state roots and fail to reach consensus, potentially causing network splits

3. **State Inconsistency**: The corrupted genesis creates a state that requires manual intervention or a hard fork to fix, as the blockchain cannot function properly without critical system resources

4. **Validator Node Issues**: Nodes starting with corrupted genesis will experience crashes, assertion failures, or undefined behavior when trying to access deleted resources

While this requires local filesystem access and administrative tool usage (limiting it from "Critical"), the impact on protocol integrity and network health is significant enough to warrant "High" severity.

## Likelihood Explanation

**Likelihood: Medium**

Required conditions for exploitation:
1. Attacker must have local filesystem access to a target node
2. Attacker must be able to run the `aptos-db-bootstrapper` tool (requires admin privileges)
3. Attacker must craft a valid serialized genesis transaction with malicious deletions
4. Target node must not have existing state (fresh installation) or attacker must wipe existing data

**Realistic scenarios:**
- Compromised node operator credentials allowing execution of bootstrap commands
- Supply chain attack where malicious genesis files are distributed to new validators
- Insider threat from malicious node operators intentionally corrupting their own nodes
- Test/development environments where genesis files are loaded from untrusted sources

The likelihood is not "High" because it requires local access rather than remote exploitation, but it's not "Low" because the attack is straightforward once access is obtained and could affect multiple validators if the malicious genesis file is distributed.

## Recommendation

Add comprehensive validation to check for deletion operations on **all** state keys, not just modules:

```rust
fn verify_genesis_write_set(write_set: &WriteSet) {
    for (state_key, write_op) in write_set.write_op_iter() {
        // Validate modules are creations
        if state_key.is_module_path() {
            assert!(
                write_op.is_creation(),
                "Genesis module write operation must be creation, found: {:?} for key: {:?}",
                write_op.write_op_kind(),
                state_key
            );
        }
        
        // Validate NO deletions anywhere in genesis
        assert!(
            !write_op.is_deletion(),
            "Genesis write set must not contain deletion operations, found deletion for key: {:?}",
            state_key
        );
    }
}
```

Update the call sites to use the new comprehensive validation: [7](#0-6) 

Replace line 234 with: `verify_genesis_write_set(change_set.write_set());`

Additionally, add validation in the VM's `process_waypoint_change_set` for `WriteSetPayload::Direct` to catch malicious genesis transactions loaded from external sources.

## Proof of Concept

```rust
#[test]
fn test_malicious_genesis_with_deletion() {
    use aptos_types::transaction::{Transaction, WriteSetPayload, ChangeSet};
    use aptos_types::write_set::{WriteSetMut, WriteOp};
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::account_config::CORE_CODE_ADDRESS;
    use aptos_language_e2e_tests::executor::FakeExecutor;
    
    // Create a malicious genesis with a deletion operation on a critical resource
    let state_key = StateKey::resource_typed::<aptos_types::on_chain_config::ValidatorSet>(
        &CORE_CODE_ADDRESS
    ).unwrap();
    
    // Create a write set with a deletion
    let write_set = WriteSetMut::new(vec![
        (state_key, WriteOp::legacy_deletion())
    ]).freeze().unwrap();
    
    let change_set = ChangeSet::new(write_set, vec![]);
    let malicious_genesis = Transaction::GenesisTransaction(
        WriteSetPayload::Direct(change_set)
    );
    
    // Attempt to execute this malicious genesis
    let executor = FakeExecutor::no_genesis();
    let result = executor.execute_transaction_block(vec![malicious_genesis]);
    
    // The malicious deletion is not validated and would be applied
    // This demonstrates the vulnerability
    assert!(result.is_ok(), "Malicious genesis with deletion was not rejected");
}
```

This PoC demonstrates that a genesis transaction containing deletion operations would be accepted and executed without validation, allowing state corruption.

### Citations

**File:** aptos-move/vm-genesis/src/lib.rs (L233-237)
```rust
    let change_set = assert_ok!(change_set.try_combine_into_storage_change_set(module_write_set));
    verify_genesis_module_write_set(change_set.write_set());
    verify_genesis_events(change_set.events());

    Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set))
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1260-1266)
```rust
fn verify_genesis_module_write_set(write_set: &WriteSet) {
    for (state_key, write_op) in write_set.expect_write_op_iter() {
        if state_key.is_module_path() {
            assert!(write_op.is_creation())
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2274-2296)
```rust
        match write_set_payload {
            WriteSetPayload::Direct(change_set) => {
                // this transaction is never delayed field capable.
                // it requires restarting execution afterwards,
                // which allows it to be used as last transaction in delayed_field_enabled context.
                let (change_set, module_write_set) =
                    create_vm_change_set_with_module_write_set_when_delayed_field_optimization_disabled(
                        change_set.clone(),
                    );

                // validate_waypoint_change_set checks that this is true, so we only log here.
                if !Self::should_restart_execution(change_set.events()) {
                    // This invariant needs to hold irrespectively, so we log error always.
                    // but if we are in delayed_field_optimization_capable context, we cannot execute any transaction after this.
                    // as transaction afterwards would be executed assuming delayed fields are exchanged and
                    // resource groups are split, but WriteSetPayload::Direct has materialized writes,
                    // and so after executing this transaction versioned state is inconsistent.
                    error!(
                        "[aptos_vm] direct write set finished without requiring should_restart_execution");
                }

                Ok((change_set, module_write_set))
            },
```

**File:** aptos-move/aptos-transaction-simulation/src/state_store.rs (L504-522)
```rust
    fn apply_write_set(&self, write_set: &WriteSet) -> Result<()> {
        let mut states = self.states.write();

        for (state_key, write_op) in write_set.write_op_iter() {
            match write_op.as_state_value() {
                None => match states.get_mut(state_key) {
                    Some(val) => *val = None,
                    None => {
                        states.insert(state_key.clone(), None);
                    },
                },
                Some(state_val) => {
                    states.insert(state_key.clone(), Some(state_val));
                },
            }
        }

        Ok(())
    }
```

**File:** storage/db-tool/src/bootstrap.rs (L108-114)
```rust
fn load_genesis_txn(path: &Path) -> Result<Transaction> {
    let mut file = File::open(path)?;
    let mut buffer = vec![];
    file.read_to_end(&mut buffer)?;

    Ok(bcs::from_bytes(&buffer)?)
}
```

**File:** aptos-move/e2e-testsuite/src/tests/genesis.rs (L12-20)
```rust
#[test]
fn no_deletion_in_genesis() {
    let genesis = GENESIS_CHANGE_SET_HEAD.clone();
    assert!(!genesis
        .write_set()
        .as_v0()
        .iter()
        .any(|(_, op)| op.is_deletion()))
}
```
