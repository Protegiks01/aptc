# Audit Report

## Title
Resource Exhaustion via Unbounded Batch Accumulation in BatchGenerator

## Summary
An attacker can bypass per-message batch limits by sending multiple messages that individually pass `ensure_max_limits()` checks but collectively exhaust memory in the `BatchGenerator`. The quota enforcement in `BatchStore` occurs too late—after batches are already stored in the `BatchGenerator`'s unbounded `batches_in_progress` HashMap, allowing memory exhaustion before any quota check can prevent it.

## Finding Description

The vulnerability exists in a critical timing gap between two validation layers:

1. **Per-Message Validation** (Early - Line 178): [1](#0-0) 

   The `ensure_max_limits()` function validates that batches in a SINGLE message don't exceed `receiver_max_total_txns` (2000 txns) and `receiver_max_total_bytes` (~4MB). [2](#0-1) 

2. **Resource Accumulation** (Immediate - No Check): [3](#0-2) 

   After passing validation, batches are sent to `BatchGenerator` via a bounded channel (size: 1000). [4](#0-3) 

3. **Memory Accumulation** (Unbounded): [5](#0-4) 

   The `BatchGenerator` immediately calls `insert_batch()` which stores all transactions in the unbounded `batches_in_progress` HashMap: [6](#0-5) 

   **Critical Finding**: There is NO size limit check on `batches_in_progress`. The HashMap grows unbounded as batches are added.

4. **Quota Check** (Too Late): [7](#0-6) 

   The per-peer quota check only happens when persisting to `BatchStore`, AFTER memory has been consumed in `BatchGenerator`. If quota is exceeded, the batch is rejected, but the memory in `BatchGenerator` has already been allocated. [8](#0-7) 

**Attack Path:**

1. Attacker floods a validator with batch messages at maximum rate
2. Each message contains 20 batches with 2000 total transactions (passing `ensure_max_limits()`)
3. Channel fills with 1000 messages = 2,000,000 transactions queued
4. `BatchGenerator` processes these, storing ~2,000,000 transaction summaries in `batches_in_progress`
5. Memory footprint: ~2,000,000 * 96 bytes/summary = **~192 MB** consumed before any quota check
6. `BatchStore` quota check fails for many batches, but memory already exhausted in `BatchGenerator`
7. Attacker repeats every 500ms (before expiration), sustaining memory pressure

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The per-message limits are bypassed by sending multiple messages, and no global limit exists in `BatchGenerator`.

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria: "Validator node slowdowns"

- **Memory Exhaustion**: An attacker can force validators to consume ~192 MB in `BatchGenerator` memory before any quota enforcement
- **Sustained Attack**: By repeating every 500ms (before expiration cleanup), the attacker maintains continuous memory pressure
- **Network-Wide Impact**: All validators receiving these messages are affected simultaneously
- **Consensus Slowdown**: Memory pressure degrades validator performance, potentially causing missed blocks, timeout issues, and reduced network throughput

The attack does NOT require validator privileges—any network peer can send batch messages.

## Likelihood Explanation

**HIGH Likelihood**:

- **Low Complexity**: Attacker only needs network connectivity to a validator
- **No Privileges Required**: Any peer can send batch messages
- **Easy to Execute**: Script can generate and send batch messages at maximum rate
- **Bounded Channel Provides False Security**: The channel size (1000) creates an illusion of protection, but `BatchGenerator` accumulates all messages before quota checks
- **Configuration Enables Attack**: Default values allow 2,000 txns per message across 1000 queued messages = 2M transactions

## Recommendation

**Immediate Fix**: Add a global limit check in `BatchGenerator` before accumulating batches in `batches_in_progress`:

```rust
// In BatchGenerator struct, add a field:
max_batches_in_progress: usize,

// In insert_batch(), add check BEFORE insertion:
fn insert_batch(
    &mut self,
    author: PeerId,
    batch_id: BatchId,
    txns: Vec<SignedTransaction>,
    expiry_time_usecs: u64,
) {
    // NEW: Check global limit
    if self.batches_in_progress.len() >= self.max_batches_in_progress {
        warn!(
            "Rejecting batch from {}: batches_in_progress limit reached ({})",
            author, self.max_batches_in_progress
        );
        counters::BATCH_IN_PROGRESS_LIMIT_EXCEEDED.inc();
        return;
    }
    
    if self.batches_in_progress.contains_key(&(author, batch_id)) {
        return;
    }
    // ... rest of function
}
```

**Alternative Fix**: Add per-peer limits on batches in progress:

```rust
// Track per-peer batch counts
peer_batch_counts: HashMap<PeerId, usize>,
max_batches_per_peer: usize,

// In insert_batch():
let peer_count = self.peer_batch_counts.entry(author).or_insert(0);
if *peer_count >= self.max_batches_per_peer {
    warn!("Rejecting batch from {}: peer limit reached", author);
    return;
}
*peer_count += 1;
```

Set `max_batches_in_progress` to a reasonable value like 10,000 batches (manageable memory footprint).

## Proof of Concept

```rust
#[tokio::test]
async fn test_batch_generator_memory_exhaustion() {
    use crate::quorum_store::{
        batch_generator::{BatchGenerator, BatchGeneratorCommand},
        batch_store::BatchStore,
        quorum_store_db::MockQuorumStoreDB,
        types::Batch,
    };
    use aptos_config::config::QuorumStoreConfig;
    use aptos_types::{transaction::SignedTransaction, PeerId};
    use std::sync::Arc;
    use tokio::sync::mpsc::channel;

    // Create BatchGenerator with default config
    let config = QuorumStoreConfig::default();
    let (batch_gen_cmd_tx, mut batch_gen_cmd_rx) = channel(1000);
    let db = Arc::new(MockQuorumStoreDB::new());
    
    // Create batch generator
    let mut batch_gen = BatchGenerator::new(
        0,
        PeerId::random(),
        config.clone(),
        db.clone(),
        Arc::new(BatchStore::new(/* params */)),
        /* ... */
    );

    // Attack: Send 1000 messages with 2000 txns each
    let attacker_peer = PeerId::random();
    for msg_id in 0..1000 {
        let mut batches = vec![];
        let txns = create_signed_transactions(2000);
        
        // Create 20 batches with 100 txns each
        for batch_id in 0..20 {
            let batch = Batch::new_v1(
                BatchId::new_for_test(msg_id * 20 + batch_id),
                txns[batch_id * 100..(batch_id + 1) * 100].to_vec(),
                0,
                1000000000,
                attacker_peer,
                0,
            );
            batches.push(batch);
        }

        // Send each batch to generator
        for batch in batches {
            batch_gen_cmd_tx
                .send(BatchGeneratorCommand::RemoteBatch(batch))
                .await
                .unwrap();
        }
    }

    // Process all messages
    for _ in 0..20000 {
        if let Some(cmd) = batch_gen_cmd_rx.recv().await {
            if let BatchGeneratorCommand::RemoteBatch(batch) = cmd {
                // This accumulates in batches_in_progress without limit
                batch_gen.handle_remote_batch(
                    batch.author(),
                    batch.batch_id(),
                    batch.into_transactions(),
                );
            }
        }
    }

    // VULNERABILITY: batches_in_progress now contains ~20,000 batches
    // with 2M transaction summaries (~192 MB) in memory
    // No quota check prevented this accumulation
    assert!(batch_gen.batches_in_progress.len() > 10000);
    println!("Memory exhaustion successful: {} batches accumulated", 
             batch_gen.batches_in_progress.len());
}
```

## Notes

This vulnerability is distinct from the intended per-message limits. The configuration clearly shows `receiver_max_total_txns` is a per-message limit [9](#0-8) , but the absence of global limits in `BatchGenerator` allows accumulation across multiple messages. The quota system in `BatchStore` [10](#0-9)  protects only `BatchStore`'s memory, not `BatchGenerator`'s unbounded `batches_in_progress` HashMap.

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L137-171)
```rust
    fn ensure_max_limits(&self, batches: &[Batch<BatchInfoExt>]) -> anyhow::Result<()> {
        let mut total_txns = 0;
        let mut total_bytes = 0;
        for batch in batches.iter() {
            ensure!(
                batch.num_txns() <= self.max_batch_txns,
                "Exceeds batch txn limit {} > {}",
                batch.num_txns(),
                self.max_batch_txns,
            );
            ensure!(
                batch.num_bytes() <= self.max_batch_bytes,
                "Exceeds batch bytes limit {} > {}",
                batch.num_bytes(),
                self.max_batch_bytes,
            );

            total_txns += batch.num_txns();
            total_bytes += batch.num_bytes();
        }
        ensure!(
            total_txns <= self.max_total_txns,
            "Exceeds total txn limit {} > {}",
            total_txns,
            self.max_total_txns,
        );
        ensure!(
            total_bytes <= self.max_total_bytes,
            "Exceeds total bytes limit: {} > {}",
            total_bytes,
            self.max_total_bytes,
        );

        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L178-182)
```rust
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L232-238)
```rust
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
```

**File:** config/src/config/quorum_store_config.rs (L78-83)
```rust
    /// The maximum number of transactions a BatchMsg received from peers can contain. Each BatchMsg can contain
    /// multiple batches.
    pub receiver_max_total_txns: usize,
    /// The maximum number of bytes a BatchMsg received from peers can contain. Each BatchMsg can contain
    /// multiple batches.
    pub receiver_max_total_bytes: usize,
```

**File:** config/src/config/quorum_store_config.rs (L108-108)
```rust
            channel_size: 1000,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L123-171)
```rust
    fn insert_batch(
        &mut self,
        author: PeerId,
        batch_id: BatchId,
        txns: Vec<SignedTransaction>,
        expiry_time_usecs: u64,
    ) {
        if self.batches_in_progress.contains_key(&(author, batch_id)) {
            return;
        }

        let txns_in_progress: Vec<_> = txns
            .par_iter()
            .with_min_len(optimal_min_len(txns.len(), 32))
            .map(|txn| {
                (
                    TransactionSummary::new(
                        txn.sender(),
                        txn.replay_protector(),
                        txn.committed_hash(),
                    ),
                    TransactionInProgress::new(txn.gas_unit_price()),
                )
            })
            .collect();

        let mut txns = vec![];
        for (summary, info) in txns_in_progress {
            let txn_info = self
                .txns_in_progress_sorted
                .entry(summary)
                .or_insert_with(|| TransactionInProgress::new(info.gas_unit_price));
            txn_info.increment();
            txn_info.gas_unit_price = info.gas_unit_price.max(txn_info.gas_unit_price);
            txns.push(summary);
        }
        let updated_expiry_time_usecs = self
            .batches_in_progress
            .get(&(author, batch_id))
            .map_or(expiry_time_usecs, |batch_in_progress| {
                expiry_time_usecs.max(batch_in_progress.expiry_time_usecs)
            });
        self.batches_in_progress.insert(
            (author, batch_id),
            BatchInProgress::new(txns, updated_expiry_time_usecs),
        );
        self.batch_expirations
            .add_item((author, batch_id), updated_expiry_time_usecs);
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L565-566)
```rust
                        BatchGeneratorCommand::RemoteBatch(batch) => {
                            self.handle_remote_batch(batch.author(), batch.batch_id(), batch.into_transactions());
```

**File:** consensus/src/quorum_store/batch_store.rs (L41-109)
```rust
pub(crate) struct QuotaManager {
    memory_balance: usize,
    db_balance: usize,
    batch_balance: usize,
    // Recording the provided quotas for asserts.
    memory_quota: usize,
    db_quota: usize,
    batch_quota: usize,
}

impl QuotaManager {
    pub(crate) fn new(db_quota: usize, memory_quota: usize, batch_quota: usize) -> Self {
        assert!(db_quota >= memory_quota);
        Self {
            memory_balance: memory_quota,
            db_balance: db_quota,
            batch_balance: batch_quota,
            memory_quota,
            db_quota,
            batch_quota,
        }
    }

    pub(crate) fn update_quota(&mut self, num_bytes: usize) -> anyhow::Result<StorageMode> {
        if self.batch_balance == 0 {
            counters::EXCEEDED_BATCH_QUOTA_COUNT.inc();
            bail!("Batch quota exceeded ");
        }

        if self.db_balance >= num_bytes {
            self.batch_balance -= 1;
            self.db_balance -= num_bytes;

            if self.memory_balance >= num_bytes {
                self.memory_balance -= num_bytes;
                Ok(StorageMode::MemoryAndPersisted)
            } else {
                Ok(StorageMode::PersistedOnly)
            }
        } else {
            counters::EXCEEDED_STORAGE_QUOTA_COUNT.inc();
            bail!("Storage quota exceeded ");
        }
    }

    fn assert_quota(balance: usize, to_free: usize, quota: usize, kind: &str) {
        assert!(
            balance + to_free <= quota,
            "Balance {} + to_free {} more than {} quota {}",
            balance,
            to_free,
            kind,
            quota,
        );
    }

    pub(crate) fn free_quota(&mut self, num_bytes: usize, storage_mode: StorageMode) {
        Self::assert_quota(self.batch_balance, 1, self.batch_quota, "Batch");
        self.batch_balance += 1;

        Self::assert_quota(self.db_balance, num_bytes, self.db_quota, "DB");
        self.db_balance += num_bytes;

        if matches!(storage_mode, StorageMode::MemoryAndPersisted) {
            Self::assert_quota(self.memory_balance, num_bytes, self.memory_quota, "Memory");
            self.memory_balance += num_bytes;
        }
    }
}
```

**File:** consensus/src/quorum_store/batch_store.rs (L383-397)
```rust
            let value_to_be_stored = if self
                .peer_quota
                .entry(author)
                .or_insert(QuotaManager::new(
                    self.db_quota,
                    self.memory_quota,
                    self.batch_quota,
                ))
                .update_quota(value.num_bytes() as usize)?
                == StorageMode::PersistedOnly
            {
                PersistedValue::new(value.batch_info().clone(), None)
            } else {
                value.clone()
            };
```

**File:** consensus/src/quorum_store/batch_store.rs (L523-526)
```rust
            Err(e) => {
                debug!("QS: failed to store to cache {:?}", e);
                None
            },
```
