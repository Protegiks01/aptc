# Audit Report

## Title
Genesis File Resource Exhaustion During Node Bootstrapping

## Summary
The `load_genesis_txn` function in `storage/db-tool/src/bootstrap.rs` performs unbounded file reads and BCS deserialization without size limits, enabling resource exhaustion attacks during node initialization. However, waypoint verification prevents actual state corruption, limiting the impact to temporary denial of service during the bootstrap process.

## Finding Description
The genesis loading mechanism lacks critical input validation that could lead to resource exhaustion: [1](#0-0) 

The `load_genesis_txn` function unconditionally reads the entire genesis file into memory and deserializes it without any size constraints. This contrasts sharply with other parts of the codebase that use bounded deserialization: [2](#0-1) 

The attack path would be:
1. Attacker creates a maliciously large genesis file (multi-GB) or one with deeply nested BCS structures
2. Node operator attempts to bootstrap using this file
3. The tool loads the entire file into memory, causing memory exhaustion
4. The bootstrap process crashes or hangs

However, there is a critical mitigation in place: [3](#0-2) 

The waypoint verification ensures that even if a malicious genesis is processed, it won't be committed unless it produces the expected waypoint hash. This significantly limits the attack's effectiveness to only causing temporary resource exhaustion.

## Impact Explanation
**Severity: LOW to MEDIUM**

While this breaks the "Resource Limits" invariant (Invariant #9), the actual impact is limited:

- **Not Critical**: No consensus violation, no fund loss, no network-wide impact
- **Not High**: Only affects a single node during initialization, not ongoing operations
- **Medium at most**: Could cause "State inconsistencies requiring intervention" if the node operator must restart the bootstrap process multiple times

The key limitation is that this requires local file system access to place the malicious genesis file, which means the attacker has already breached the operational security perimeter.

## Likelihood Explanation
**Likelihood: LOW**

This attack has significant prerequisites:
1. **Local File System Access**: Attacker must be able to place files on the target node's file system
2. **Operational Window**: Only exploitable during initial node setup or hard fork recovery
3. **Trusted Input Assumption**: Genesis files are typically obtained from trusted sources and verified via waypoints
4. **Limited Scope**: Only affects individual nodes, not the network

The lack of integration tests for malicious inputs (as noted in the security question) means this vulnerability hasn't been validated, but the waypoint verification mechanism provides defense-in-depth. [4](#0-3) 

The existing test only validates CLI structure, not actual malicious input handling.

## Recommendation
Implement size limits and validation for genesis file loading:

```rust
fn load_genesis_txn(path: &Path) -> Result<Transaction> {
    const MAX_GENESIS_FILE_SIZE: usize = 100 * 1024 * 1024; // 100 MB limit
    
    let mut file = File::open(path)?;
    let file_size = file.metadata()?.len();
    
    ensure!(
        file_size <= MAX_GENESIS_FILE_SIZE as u64,
        "Genesis file size {} exceeds maximum allowed size {}",
        file_size,
        MAX_GENESIS_FILE_SIZE
    );
    
    let mut buffer = Vec::with_capacity(std::cmp::min(file_size as usize, MAX_GENESIS_FILE_SIZE));
    file.read_to_end(&mut buffer)?;

    // Use bounded deserialization
    let txn = bcs::from_bytes_with_limit(&buffer, MAX_GENESIS_FILE_SIZE)
        .context("Failed to deserialize genesis transaction")?;
    
    Ok(txn)
}
```

Additionally, add integration tests that verify proper handling of:
- Oversized genesis files
- Malformed BCS data
- Deeply nested structures

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Genesis file size")]
fn test_oversized_genesis_file() {
    use std::io::Write;
    use tempfile::NamedTempFile;
    
    // Create a large malicious genesis file
    let mut file = NamedTempFile::new().unwrap();
    let large_data = vec![0u8; 200 * 1024 * 1024]; // 200 MB
    file.write_all(&large_data).unwrap();
    
    // This should fail with size limit error
    let result = load_genesis_txn(file.path());
    assert!(result.is_err());
}

#[test]
fn test_malformed_bcs_genesis() {
    use tempfile::NamedTempFile;
    use std::io::Write;
    
    let mut file = NamedTempFile::new().unwrap();
    // Write invalid BCS data
    file.write_all(&[0xFF; 1024]).unwrap();
    
    // Should fail gracefully, not panic
    let result = load_genesis_txn(file.path());
    assert!(result.is_err());
}
```

## Notes
While this vulnerability exists, its practical exploitability is limited by:
1. The requirement for local file system access (not a remote attack)
2. Waypoint verification preventing actual state corruption
3. The operational context where genesis files are trusted inputs

The security question correctly identifies the lack of test coverage for malicious inputs. However, the actual risk is mitigated by the waypoint verification mechanism that acts as a final safeguard against malicious genesis content.

### Citations

**File:** storage/db-tool/src/bootstrap.rs (L87-93)
```rust
        if let Some(waypoint) = self.waypoint_to_verify {
            ensure!(
                waypoint == committer.waypoint(),
                "Waypoint verification failed. Expected {:?}, got {:?}.",
                waypoint,
                committer.waypoint(),
            );
```

**File:** storage/db-tool/src/bootstrap.rs (L108-114)
```rust
fn load_genesis_txn(path: &Path) -> Result<Transaction> {
    let mut file = File::open(path)?;
    let mut buffer = vec![];
    file.read_to_end(&mut buffer)?;

    Ok(bcs::from_bytes(&buffer)?)
}
```

**File:** storage/db-tool/src/bootstrap.rs (L116-120)
```rust
#[test]
fn verify_tool() {
    use clap::CommandFactory;
    Command::command().debug_assert()
}
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
