# Audit Report

## Title
Database Internal State Disclosure Through Unsanitized Error Messages in Events API

## Summary
The Events API exposes internal database state information through error messages when `internal_with_code` serializes storage layer errors without sanitization. This allows unprivileged API users to obtain sensitive implementation details including database corruption states, index integrity issues, and internal version tracking mechanisms. [1](#0-0) [2](#0-1) 

## Finding Description
The vulnerability exists in the `list()` function where errors from the storage layer are passed directly to `internal_with_code` without sanitization. The error serialization mechanism formats errors using `format!("{:#}", error)`, which includes the complete error chain with all context and source errors. [3](#0-2) 

The storage layer produces detailed error messages that expose internal state: [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

These error messages reveal database schema details, consistency checking mechanisms, and corruption states that should remain internal.

## Impact Explanation
This represents a **Medium severity** information disclosure vulnerability. While it does not directly compromise funds or consensus, it exposes:

1. **Database Schema Intelligence**: Error messages like "Event X of Txn Y" reveal internal storage structure
2. **Corruption Detection Logic**: Messages like "DB corruption: Sequence number not continuous" and "Index broken, expected seq:X, actual:Y" expose integrity checking mechanisms
3. **Implementation Details**: Messages like "Unexpected module event" reveal internal code paths

This information could aid attackers in:
- Understanding database internals to craft targeted attacks
- Identifying exploitable consistency vulnerabilities
- Mapping internal system architecture
- Detecting degraded system states to time attacks

The codebase demonstrates awareness of this issue through explicit error sanitization in other components: [8](#0-7) [9](#0-8) 

## Likelihood Explanation
**High likelihood** - This vulnerability is easily triggered by any unprivileged API user through:
- Requesting events with non-existent event keys
- Querying events at pruned ledger versions
- Accessing events with invalid sequence numbers
- Normal API usage encountering database errors

No special permissions, validator access, or sophisticated attack techniques are required.

## Recommendation
Implement error message sanitization before passing errors to `internal_with_code`. Sanitize database-specific errors to generic messages:

```rust
fn sanitize_storage_error(err: anyhow::Error) -> String {
    // Check if error chain contains database-specific errors
    if let Some(db_err) = err.downcast_ref::<AptosDbError>() {
        match db_err {
            AptosDbError::NotFound(_) => "Resource not found".to_string(),
            AptosDbError::Other(_) => "Internal storage error".to_string(),
            _ => "Internal storage error".to_string(),
        }
    } else {
        "Internal error processing request".to_string()
    }
}

// In events.rs:
.map_err(|err| {
    BasicErrorWith404::internal_with_code(
        sanitize_storage_error(err),
        AptosErrorCode::InternalError,
        &latest_ledger_info,
    )
})?;
```

Apply this pattern consistently across all API endpoints using `internal_with_code`.

## Proof of Concept
```bash
# Request events for a non-existent event key at a specific version
curl -X GET "http://localhost:8080/v1/accounts/0x0/events/999999999?start=0&limit=10" \
  -H "Accept: application/json"

# Expected response exposes internal state:
{
  "message": "Failed to find events by key 0x0000000000000000000000000000000000000000000000000000000000000000000000003b9aca07: Event 0 of seq num 0.",
  "error_code": "internal_error",
  "vm_error_code": null
}

# Request events at a pruned version to trigger DB corruption messages
curl -X GET "http://localhost:8080/v1/accounts/0x1/events/0?start=1&limit=1000" \
  -H "Accept: application/json"

# May expose: "DB corruption: Sequence number not continuous. expected: X, actual: Y"
```

The API returns detailed internal error messages in the JSON response, confirming the information disclosure.

## Notes
This issue affects all API endpoints using `internal_with_code` throughout the codebase, not just the Events API. A comprehensive audit should review all instances: [10](#0-9) [11](#0-10) 

The inconsistency between panic handler sanitization and storage error handling suggests this is an oversight rather than intentional design.

### Citations

**File:** api/src/events.rs (L171-178)
```rust
            .context(format!("Failed to find events by key {}", event_key))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;
```

**File:** api/src/events.rs (L187-194)
```rust
                    .context("Failed to convert events from storage into response")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &latest_ledger_info,
                        )
                    })?;
```

**File:** api/types/src/error.rs (L29-38)
```rust
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L47-50)
```rust
        self.event_db
            .get::<EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L131-137)
```rust
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L153-156)
```rust
            return Err(AptosDbError::NotFound(format!(
                "Event {} of seq num {}.",
                event_key, seq_num
            )));
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1157-1166)
```rust
                let v0 = match &event {
                    ContractEvent::V1(event) => event,
                    ContractEvent::V2(_) => bail!("Unexpected module event"),
                };
                ensure!(
                    seq == v0.sequence_number(),
                    "Index broken, expected seq:{}, actual:{}",
                    seq,
                    v0.sequence_number()
                );
```

**File:** api/src/error_converter.rs (L49-52)
```rust
pub fn panic_handler(err: Box<dyn Any + Send>) -> Response {
    error!("Panic captured: {:?}", err);
    build_panic_response("internal error".into())
}
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L28-44)
```rust
    pub fn new(message: String, error_code: AptosTapErrorCode) -> Self {
        if *USE_HELPFUL_ERRORS.get().unwrap_or(&true) {
            Self {
                message,
                error_code,
                rejection_reasons: vec![],
                txn_hashes: vec![],
            }
        } else {
            Self {
                message: "hah hah hah".to_string(),
                error_code: AptosTapErrorCode::YeahNahYeahYeahYeahNahYeahNah,
                rejection_reasons: vec![],
                txn_hashes: vec![],
            }
        }
    }
```

**File:** api/src/accounts.rs (L269-277)
```rust
            let account_resource: AccountResource = bcs::from_bytes(state_value)
                .context("Internal error deserializing response from DB")
                .map_err(|err| {
                    BasicErrorWith404::internal_with_code(
                        err,
                        AptosErrorCode::InternalError,
                        &self.latest_ledger_info,
                    )
                })?;
```

**File:** api/src/accounts.rs (L328-344)
```rust
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        })?;
                // query coin balance
                let state_value = self.context.get_state_value_poem(
                    &StateKey::resource(&self.address.into(), &coin_store_type_tag).map_err(
                        |err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        },
```
