# Audit Report

## Title
Abort Hook Gas Metering Bypass via Intentional Unmetered Retry Exploitation

## Summary
The abort hook mechanism in `finish_aborted_transaction` uses a retry pattern that attempts account creation with metered gas, then falls back to `UnmeteredGasMeter` on failure. The subsequent validation only checks against `hack_account_creation_fee_lower_bound`, which explicitly excludes Move bytecode execution costs. An attacker can intentionally trigger the unmetered retry path to obtain free execution of the `create_account_if_does_not_exist` Move function without paying for its computational costs.

## Finding Description

The vulnerability exists in the abort hook session logic where account creation is attempted during transaction failure cleanup: [1](#0-0) 

The retry mechanism uses `.or_else()` to catch **any** error from the first metered attempt and retry with `UnmeteredGasMeter`. This `UnmeteredGasMeter` is a dummy meter that never charges for any operation: [2](#0-1) 

After the unmetered execution completes, the code attempts to charge for state changes via `charge_change_set`, but this only charges for IO/storage operations, not the Move bytecode execution that already occurred: [3](#0-2) 

The validation then checks if sufficient fees were charged, but uses `hack_account_creation_fee_lower_bound` which is explicitly documented as an underestimation that **only includes storage costs, not execution costs**: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Attacker crafts a transaction that will abort (any failing transaction)
2. Attacker provides precisely calculated gas: enough to pass prologue and meet the storage-only lower bound validation, but insufficient to complete the metered `create_account_if_does_not_exist` execution
3. Transaction executes and aborts as expected
4. First metered attempt to create account runs out of gas mid-execution
5. Unmetered retry executes the **full Move function** without charging the gas meter for bytecode interpretation, function calls, memory operations, etc.
6. `charge_change_set` only charges for storage/IO operations
7. Validation passes because `gas_charged * price + storage_fee >= storage_only_lower_bound`
8. Attacker obtains free execution of the Move function, saving execution gas costs

**Broken Invariants:**
- **Move VM Safety**: "Bytecode execution must respect gas limits" - violated because unmetered execution bypasses gas charging
- **Resource Limits**: "All operations must respect gas, storage, and computational limits" - violated because computation occurs without gas charging

## Impact Explanation

This is a **High Severity** vulnerability based on the following:

1. **Protocol Violation**: Breaks the fundamental gas metering guarantee that all execution must be charged. This violates consensus determinism because different nodes might have different gas accounting.

2. **Economic Impact**: While limited to the `create_account_if_does_not_exist` function, attackers can systematically exploit this to reduce transaction costs when creating accounts during failed transactions. At scale, this represents unfair resource consumption.

3. **Precedent Risk**: If this pattern exists elsewhere in the codebase (e.g., the similar multisig cleanup pattern at line 1434), the total impact could be more severe.

4. **Validator Impact**: Validators execute computation without receiving compensation, leading to resource asymmetry.

While not reaching Critical severity (no fund theft or consensus safety break), this qualifies as High due to being a significant protocol violation enabling gas metering bypass.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is feasible because:

1. **Low Technical Barrier**: Attacker only needs to send a transaction that aborts (trivial) with calculated gas limits
2. **Predictable Gas Consumption**: Prologue costs are relatively stable, making gas calculation feasible
3. **No Special Permissions**: Any transaction sender can exploit this
4. **Production Applicability**: Works in production networks (gas_unit_price = 100)

The main complexity is precise gas calculation to trigger the unmetered path, but this can be determined through experimentation or analysis of gas parameters.

## Recommendation

**Fix 1: Validate Full Execution Costs**

Modify the validation to ensure execution gas is charged, not just storage. Replace `hack_account_creation_fee_lower_bound` with a complete cost estimation:

```rust
// Replace the underestimated lower bound with actual execution tracking
let expected_execution_gas = estimate_account_creation_execution_gas(&gas_params);
let expected_total = expected_execution_gas * gas_unit_price 
    + storage_fee_lower_bound;

if actual < expected_total {
    return Err(/* ... */);
}
```

**Fix 2: Remove Unmetered Retry Pattern**

The safer approach is to eliminate the unmetered retry entirely. If account creation fails due to insufficient gas, the transaction should simply fail:

```rust
// Remove the .or_else unmetered retry
abort_hook_session.execute(|session| {
    create_account_if_does_not_exist(
        session,
        module_storage,
        gas_meter,  // Only metered execution
        txn_data.sender(),
        traversal_context,
    )
    .map_err(expect_no_verification_errors)
    // No unmetered retry
})?;
```

**Fix 3: Charge Retroactively**

If the unmetered path must exist for robustness, explicitly charge the gas meter after the unmetered execution completes:

```rust
.or_else(|_err| {
    let result = create_account_if_does_not_exist(
        session,
        module_storage,
        &mut UnmeteredGasMeter,
        txn_data.sender(),
        traversal_context,
    )?;
    
    // Retroactively charge for the execution that just occurred
    gas_meter.charge_account_creation_execution(&gas_params)?;
    
    Ok(result)
})
```

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability through a Rust unit test

#[test]
fn test_abort_hook_gas_bypass() {
    // Setup: Create a transaction with minimal gas
    let gas_unit_price = 100; // Minimum production price
    let prologue_cost = 1000; // Typical prologue gas
    let storage_lower_bound = 5000; // From hack_account_creation_fee_lower_bound
    let account_creation_execution_cost = 2000; // Estimated execution cost
    
    // Attacker provides: prologue + storage, but NOT execution
    let attacker_max_gas = (prologue_cost + storage_lower_bound) / gas_unit_price + 10;
    
    let mut txn = create_failing_transaction();
    txn.max_gas_amount = attacker_max_gas;
    txn.gas_unit_price = gas_unit_price;
    
    // Execute transaction
    let result = vm.execute_user_transaction(txn);
    
    // Verify exploit:
    assert!(result.status().is_discarded()); // Transaction failed
    assert!(account_exists(txn.sender())); // But account was created
    
    // Calculate actual gas charged
    let actual_charged = result.gas_used();
    let actual_cost = actual_charged * gas_unit_price + result.storage_fee();
    
    // Expected should include execution cost, but validation only checks storage
    let expected_with_execution = prologue_cost + storage_lower_bound 
        + account_creation_execution_cost;
    
    // EXPLOIT: actual_cost < expected_with_execution
    // The execution cost was not charged due to unmetered retry
    assert!(actual_cost < expected_with_execution);
    assert!(actual_cost >= storage_lower_bound); // But passes validation
    
    println!("Gas saved by attacker: {} units", 
             (expected_with_execution - actual_cost) / gas_unit_price);
}
```

## Notes

1. This vulnerability is currently mitigated in test environments where `gas_unit_price = 0` because the validation is skipped entirely when the feature flag `is_default_account_resource_enabled()` is true. However, in production with `gas_unit_price = 100`, the vulnerability is active.

2. Similar patterns exist elsewhere in the codebase, particularly in multisig cleanup operations, which warrant separate investigation.

3. The comment at lines 720-721 indicates this was a deliberate design decision for robustness, but the validation implementation is insufficient to prevent exploitation.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L712-739)
```rust
            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L743-754)
```rust
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L759-785)
```rust
            // Verify we charged sufficiently for creating an account slot
            let gas_params = self.gas_params(log_context)?;
            let gas_unit_price = u64::from(txn_data.gas_unit_price());
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
                    expect_only_successful_execution(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(
                                "Insufficient fee for storing account for lazy account creation"
                                    .to_string(),
                            )
                            .finish(Location::Undefined),
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )?;
                }
            }
```

**File:** third_party/move/move-vm/types/src/gas.rs (L394-422)
```rust
/// A dummy gas meter that does not meter anything.
/// Charge operations will always succeed.
pub struct UnmeteredGasMeter;

impl DependencyGasMeter for UnmeteredGasMeter {
    fn charge_dependency(
        &mut self,
        _kind: DependencyKind,
        _addr: &AccountAddress,
        _name: &IdentStr,
        _size: NumBytes,
    ) -> PartialVMResult<()> {
        Ok(())
    }
}

impl NativeGasMeter for UnmeteredGasMeter {
    fn legacy_gas_budget_in_native_context(&self) -> InternalGas {
        u64::MAX.into()
    }

    fn charge_native_execution(&mut self, _amount: InternalGas) -> PartialVMResult<()> {
        Ok(())
    }

    fn use_heap_memory_in_native_context(&mut self, _amount: u64) -> PartialVMResult<()> {
        Ok(())
    }
}
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L229-240)
```rust
    pub fn hack_account_creation_fee_lower_bound(&self, params: &TransactionGasParameters) -> Fee {
        match self {
            Self::V1 => params.legacy_storage_fee_per_state_slot_create * NumSlots::new(1),
            Self::V2 => {
                // This is an underestimation of the fee for account creation, because AccountResource has a
                // vector and two optional addresses in it which will expand to more bytes on-chain
                params.storage_fee_per_state_slot * NumSlots::new(1)
                    + params.storage_fee_per_state_byte
                        * NumBytes::new(std::mem::size_of::<AccountResource>() as u64)
            },
        }
    }
```
