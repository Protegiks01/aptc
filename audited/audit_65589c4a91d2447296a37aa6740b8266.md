# Audit Report

## Title
Credential Leakage via Ready Server JSON Serialization in Aptos Localnet

## Summary
The `HealthChecker` enum derives `Serialize` and exposes PostgreSQL connection strings containing plaintext passwords through the ready server HTTP endpoint, allowing unauthorized credential disclosure to any user who can access the endpoint.

## Finding Description

The `HealthChecker` enum is designed to verify the health status of various services in the Aptos localnet environment. [1](#0-0) 

This enum includes variants that store sensitive PostgreSQL connection strings: [2](#0-1) 

When users run the localnet with an external PostgreSQL instance using the `--use-host-postgres` and `--host-postgres-password` flags, the connection string is constructed to include the password in plaintext: [3](#0-2) 

These health checkers are then passed to the Ready Server: [4](#0-3) 

The Ready Server exposes an HTTP endpoint that serializes all `HealthChecker` instances to JSON: [5](#0-4) 

When a client sends a GET request to the ready server endpoint (default: `http://127.0.0.1:8070/`), the response includes the complete connection strings with embedded passwords in JSON format.

## Impact Explanation

This vulnerability represents an **information disclosure** issue that exposes database credentials. However, its impact is limited to the **localnet development environment** rather than production Aptos blockchain infrastructure.

**Impact Scope:**
- Affects only developers running `aptos node run-localnet` with external PostgreSQL
- Does NOT affect production validators, consensus nodes, or mainnet/testnet infrastructure
- Limited to scenarios where `--use-host-postgres` and `--host-postgres-password` are used
- Requires network access to the ready server endpoint

**Severity Classification:**
According to the Aptos bug bounty criteria, this qualifies as **Low Severity** (up to $1,000) under "Minor information leaks" because:
1. It's in a development tool (`aptos-localnet` crate), not core blockchain code
2. No impact on consensus, execution, state management, governance, or staking
3. No funds at risk (localnet uses test tokens with no value)
4. Default binding to `127.0.0.1` limits exposure

The ready server is typically bound to localhost, though if `--bind-to 0.0.0.0` is used (when running inside a container), the exposure increases to network-level access.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Required Conditions:**
1. Developer runs localnet with `--with-indexer-api --use-host-postgres --host-postgres-password <password>`
2. Attacker has network access to the ready server endpoint
3. Ready server must be accessible (localhost by default, or `0.0.0.0` if containerized)

**Mitigating Factors:**
- The containerized PostgreSQL (default setup) uses `POSTGRES_HOST_AUTH_METHOD=trust` with no password [6](#0-5) 
- Most developers use the default containerized setup
- Ready server is localhost-bound by default
- This is a development environment tool, not production infrastructure

## Recommendation

Implement custom serialization for `HealthChecker` to redact sensitive credentials:

```rust
// In health_checker.rs
impl Serialize for HealthChecker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStructVariant;
        match self {
            HealthChecker::Postgres(conn_str) => {
                let mut state = serializer.serialize_struct_variant("HealthChecker", 0, "Postgres", 1)?;
                state.serialize_field("connection_string", &redact_credentials(conn_str))?;
                state.end()
            },
            HealthChecker::Processor(conn_str, name) => {
                let mut state = serializer.serialize_struct_variant("HealthChecker", 1, "Processor", 2)?;
                state.serialize_field("connection_string", &redact_credentials(conn_str))?;
                state.serialize_field("processor_name", name)?;
                state.end()
            },
            // ... handle other variants normally
        }
    }
}

fn redact_credentials(connection_string: &str) -> String {
    // Redact password from connection string
    connection_string
        .split("://")
        .nth(1)
        .and_then(|s| s.split('@').nth(1))
        .map(|host_part| format!("postgres://***@{}", host_part))
        .unwrap_or_else(|| "postgres://***".to_string())
}
```

Alternatively, remove the `Serialize` derive and make `HealthChecker` non-serializable, or exclude sensitive variants from ready server responses.

## Proof of Concept

**Steps to Reproduce:**

1. Start localnet with external PostgreSQL:
```bash
aptos node run-localnet \
  --with-indexer-api \
  --use-host-postgres \
  --host-postgres-password "SecretPassword123"
```

2. Send HTTP request to ready server:
```bash
curl http://127.0.0.1:8070/
```

3. Observe JSON response containing plaintext password:
```json
{
  "ready": [
    {
      "Postgres": "postgres://postgres:SecretPassword123@127.0.0.1:5432/local_testnet"
    }
  ],
  "not_ready": []
}
```

**Notes:**
- This vulnerability exists in the codebase as designed
- The ready server intentionally serializes health checker state for monitoring
- The issue is the lack of credential sanitization before serialization
- While this is a valid security concern for development environments, it does not impact Aptos blockchain consensus, execution, or production infrastructure

### Citations

**File:** crates/aptos-localnet/src/health_checker.rs (L23-23)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
```

**File:** crates/aptos-localnet/src/health_checker.rs (L33-37)
```rust
    Postgres(String),
    /// Check that a processor is successfully processing txns. The first value is the
    /// postgres connection string. The second is the name of the processor. We check
    /// the that last_success_version in the processor_status table is present and > 0.
    Processor(String, String),
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L92-116)
```rust
    pub fn get_connection_string(&self, database: Option<&str>, external: bool) -> String {
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
        let port = self.get_postgres_port(external);
        let database = match database {
            Some(database) => database,
            None => &self.postgres_database,
        };
        let host = match self.use_host_postgres {
            true => &self.host_postgres_host,
            false => match external {
                true => "127.0.0.1",
                false => POSTGRES_CONTAINER_NAME,
            },
        };
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
    }
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L278-280)
```rust
            env: Some(vec![
                // We run postgres without any auth + no password.
                "POSTGRES_HOST_AUTH_METHOD=trust".to_string(),
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L352-363)
```rust
        let health_checkers: HashSet<HealthChecker> = managers
            .iter()
            .flat_map(|m| m.get_health_checkers())
            .collect();

        // The final manager we add is the ready server. This must happen last since
        // it use the health checkers from all the other services.
        managers.push(Box::new(ReadyServerManager::new(
            &self,
            bind_to,
            health_checkers.clone(),
        )?));
```

**File:** crates/aptos/src/node/local_testnet/ready_server.rs (L104-131)
```rust
#[derive(Serialize)]
struct ReadyData {
    pub ready: Vec<HealthChecker>,
    pub not_ready: Vec<HealthChecker>,
}

#[handler]
async fn root(health_checkers: Data<&HealthCheckers>) -> impl IntoResponse + use<> {
    let mut ready = vec![];
    let mut not_ready = vec![];
    for health_checker in &health_checkers.health_checkers {
        // Use timeout since some of these checks can take quite a while if the
        // underlying service is not ready. This is best effort of course, see the docs
        // for tokio::time::timeout for more information.
        match timeout(Duration::from_secs(3), health_checker.check()).await {
            Ok(Ok(())) => ready.push(health_checker.clone()),
            _ => {
                not_ready.push(health_checker.clone());
            },
        }
    }
    let status_code = if not_ready.is_empty() {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    Json(ReadyData { ready, not_ready }).with_status(status_code)
}
```
