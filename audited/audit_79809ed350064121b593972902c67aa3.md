# Audit Report

## Title
Bytecode Verification Bypass via Stale Cache Entries After Verifier Limit Changes

## Summary
Modules verified under older, more permissive bytecode limits can bypass newer stricter limits due to incomplete cache invalidation logic in the verification system. The `VERIFIED_MODULES_CACHE` is not properly flushed when verifier configuration changes occur before gas_feature_version 38, or when limit changes happen independently of gas version upgrades, allowing modules that violate current limits to execute on-chain.

## Finding Description
The Aptos Move VM uses a global `VERIFIED_MODULES_CACHE` to store hashes of already-verified modules to avoid redundant verification passes. [1](#0-0) 

When a module is loaded, the system first checks if its hash exists in this cache. If found, bytecode verification is completely skipped: [2](#0-1) 

The verifier configuration includes various limits that can change via feature flags. For example, when `ENABLE_FUNCTION_VALUES` is enabled, limits become significantly stricter: [3](#0-2) 

The critical flaw is in the cache invalidation logic. The cache is only flushed when verifier config changes **AND** the gas_feature_version is >= 38 (RELEASE_V1_34): [4](#0-3) 

**Attack Scenario:**

1. Attacker publishes Module A when `ENABLE_FUNCTION_VALUES` is disabled (max_type_nodes = 256)
2. Module A contains 200 type nodes - passes verification under old limits
3. Module A's hash is added to `VERIFIED_MODULES_CACHE`
4. Later, `ENABLE_FUNCTION_VALUES` is enabled via governance (max_type_nodes becomes 128)
5. If gas_feature_version < 38: Cache is never flushed, Module A bypasses new limits
6. If gas_feature_version upgrades from 37â†’38 but verifier config was already changed earlier: Cache flush logic checks `verifier_config_bytes` comparison (line 119), finds no change, doesn't flush
7. When Module A is loaded again, verification is skipped due to cached hash
8. Module A with 200 type nodes executes despite violating current 128 limit

This bypasses the security invariant that "**all operations must respect resource limits**" and violates "**deterministic execution**" if different nodes have different cache states.

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: Modules can bypass bytecode verification limits that are designed to prevent resource exhaustion attacks and ensure safe execution bounds

2. **Consensus Risk**: Different validator nodes with different cache states could accept/reject the same module differently, potentially causing consensus splits or non-deterministic execution

3. **DoS Potential**: Verification limits like `max_type_nodes`, `max_function_parameters`, and `max_type_depth` exist to prevent resource exhaustion. Bypassing these could enable denial-of-service attacks that cause validator slowdowns or crashes

4. **Historical Impact**: Before gas_feature_version 38, this was a complete bypass. Even after the partial fix, edge cases exist during version transitions

The impact doesn't reach Critical severity because it doesn't directly enable fund theft or total network unavailability, but it significantly undermines verification security guarantees.

## Likelihood Explanation
**Likelihood: Medium-High**

The vulnerability is exploitable in several scenarios:

1. **Historical Certainty**: Any network that operated with gas_feature_version < 38 while feature flags changed had this vulnerability actively exploitable

2. **Edge Case Exploitability**: Even with current code (gas_feature_version >= 38), there's a window during gas version upgrades where stale cache entries persist if the verifier config changed before the version bump

3. **Attacker Requirements**:
   - Ability to publish modules (standard capability)
   - Timing attack during feature flag or gas version changes
   - Knowledge of the cache invalidation logic

4. **Testnet/Devnet Risk**: Networks running older gas_feature_versions or during upgrade transitions are vulnerable

The attack is feasible because:
- Feature flags are regularly changed via governance
- Gas version upgrades happen separately from feature flag changes
- The cache persists across blocks and validator restarts
- No special privileges required beyond module publishing

## Recommendation
Implement unconditional cache flushing when verifier configuration changes:

```rust
// In code_cache_global_manager.rs, replace lines 117-126:
let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
if environment_requires_update {
    // Check if verifier config changed, regardless of gas_feature_version
    let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
        e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
    });
    if flush_verifier_cache {
        // Always flush verified module cache when verifier config changes
        RuntimeEnvironment::flush_verified_module_cache();
    }
    
    self.environment = Some(storage_environment);
    self.module_cache.flush();
}
```

Additionally, implement a one-time forced cache flush at the next gas version upgrade to clear any stale entries:

```rust
// Add version tracking to detect upgrades
if let Some(prev_env) = self.environment.as_ref() {
    if prev_env.gas_feature_version() < storage_environment.gas_feature_version() {
        // Force flush on gas version upgrade to clear stale entries
        RuntimeEnvironment::flush_verified_module_cache();
    }
}
```

Remove the gas_feature_version gate entirely since cache correctness should not depend on version numbers.

## Proof of Concept

**Setup:**
1. Network running with gas_feature_version 37, ENABLE_FUNCTION_VALUES disabled
2. Publish a module with 200 type nodes (allowed under max_type_nodes=256)

**Rust reproduction steps:**

```rust
// Step 1: Create module with 200 type nodes under old limits
let mut module_with_many_types = basic_test_module();
// ... construct module with 200 type nodes in signatures ...

let old_config = VerifierConfig {
    max_type_nodes: Some(256),
    enable_function_values: false,
    ..VerifierConfig::production()
};

// Verify module under old limits - succeeds
verify_module_with_config(&old_config, &module_with_many_types).unwrap();

// Module hash is now in VERIFIED_MODULES_CACHE
let module_hash = sha3_256(module_bytes);

// Step 2: Simulate feature flag change
let new_config = VerifierConfig {
    max_type_nodes: Some(128),  // Stricter limit
    enable_function_values: true,
    ..VerifierConfig::production()
};

// Step 3: Simulate gas_feature_version < 38 scenario
// Cache flush logic is skipped, module stays in cache

// Step 4: Try to load module again with new limits
// Verification is skipped due to cached hash!
let result = build_locally_verified_module(
    compiled_module, 
    module_size, 
    &module_hash  // Hash is in cache!
);

// Module loads successfully despite violating new 128 type node limit
assert!(result.is_ok());  // VULNERABILITY: Should have failed but passed
```

The module with 200 type nodes bypasses the new 128-node limit because its hash remains in `VERIFIED_MODULES_CACHE` and verification is skipped in `build_locally_verified_module`.

## Notes
- This vulnerability affected all Aptos networks before gas_feature_version 38 deployment
- The partial fix in RELEASE_V1_34 still has edge cases during version transitions
- Mainnet with current gas_feature_version 45 is protected for new limit changes, but may have stale cache entries from historical transitions
- Testnets and private deployments running older versions remain vulnerable
- The fix requires removing the gas_feature_version gate and implementing proper cache invalidation on all verifier config changes

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L9-13)
```rust
/// Cache for already verified modules. Since loader V1 uses such a cache to not perform repeated
/// verifications, possibly even across blocks, for comparative performance we need to have it as
/// well. For now, we keep it as a separate cache to make sure there is no interference between V1
/// and V2 implementations.
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-192)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-126)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }
```
