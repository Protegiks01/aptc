# Audit Report

## Title
Unverified Future Epoch Commit Decisions Allow Premature State Updates and Denial of Service

## Summary
The consensus observer accepts commit decisions from future epochs without cryptographic verification, causing premature updates to `highest_committed_epoch_round` and `root` state. This allows malicious peers to desynchronize observers from the network and cause denial of service by forcing state sync to non-existent epochs.

## Finding Description

The vulnerability exists in the commit decision processing logic where future epoch commit decisions bypass verification before updating critical consensus state.

**Attack Flow:**

1. Observer is at epoch 5, `highest_committed_epoch_round` is (5, 100)
2. Malicious peer sends `CommitDecision` for epoch 999, round 0
3. Check at line 457 passes: (999, 0) > (5, 100) [1](#0-0) 
4. Epoch validation at line 468 **fails**: 999 != 5, so verification is **skipped** [2](#0-1) 
5. Code reaches future epoch handling logic [3](#0-2) 
6. `update_blocks_for_state_sync_commit()` called **without verification** at line 522 [4](#0-3) 
7. This updates `root` to epoch 999 [5](#0-4) 
8. Then calls `remove_blocks_for_commit()` [6](#0-5) 
9. Which updates `highest_committed_epoch_round` to (999, 0) **without verification** [7](#0-6) 

The TODO comment acknowledges this gap: [8](#0-7) 

**Critical Impact:** While `update_commit_decision()` itself is only called for current epoch decisions (protected by the check at line 468), the function `update_highest_committed_epoch_round()` at line 141 can still be reached with unverified future epoch data through the `remove_blocks_for_commit()` path at line 123. [9](#0-8) 

This breaks the invariant that `highest_committed_epoch_round` should only reflect cryptographically verified commits. [10](#0-9) 

## Impact Explanation

**Severity: HIGH** (per Aptos bug bounty criteria)

This vulnerability causes:
- **Significant protocol violations**: Observer maintains incorrect view of consensus state
- **Validator node slowdowns**: Observer becomes stuck trying to state sync to non-existent epoch
- **Denial of Service**: All legitimate commit decisions for epochs 5-998 are dropped because they're < (999, 0), preventing observer from tracking real consensus [1](#0-0) 

The attack effectively bricks the consensus observer, requiring manual intervention to recover.

## Likelihood Explanation

**Likelihood: HIGH**

- **Low complexity**: Single malformed message triggers vulnerability
- **No special privileges**: Any peer the observer subscribes to can send commit decisions
- **No rate limiting**: Attacker can repeatedly attack if observer recovers
- **Persistent impact**: Once `highest_committed_epoch_round` is corrupted, legitimate commits are permanently rejected until manual reset

The subscription manager verifies messages are from subscribed peers, but doesn't prevent subscribed malicious peers from exploiting this. [11](#0-10) 

## Recommendation

**Solution**: Verify all commit decisions regardless of epoch before updating critical state, or reject future epoch commits entirely.

**Option 1 - Verify Future Epoch Commits:**
```rust
// At line 466-495 in consensus_observer.rs
let epoch_state = self.get_epoch_state();

// Verify commit decision for ANY epoch, not just current
if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
    error!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Failed to verify commit decision! Ignoring: {:?}, Error: {:?}",
            commit_decision.proof_block_info(), error
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}

// Only proceed with state sync if verification passes
if commit_epoch == epoch_state.epoch {
    // Process normally
} else {
    // Trigger state sync with VERIFIED future epoch commit
}
```

**Option 2 - Reject Future Epoch Commits (Simpler):**
```rust
// At line 466 in consensus_observer.rs
if commit_epoch != epoch_state.epoch {
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting commit decision from future/past epoch! Current: {}, Commit: {}",
            epoch_state.epoch, commit_epoch
        ))
    );
    return;
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_future_epoch_commit_decision_dos() {
    // Setup observer at epoch 5
    let (mut observer, peer_network_id) = setup_test_observer(5).await;
    
    // Observer's current state
    assert_eq!(observer.get_epoch_state().epoch, 5);
    assert_eq!(
        observer.observer_block_data.lock().get_highest_committed_epoch_round(),
        (5, 100)
    );
    
    // Malicious peer sends commit decision for epoch 999
    let malicious_commit = create_unverified_commit_decision(999, 0);
    observer.process_commit_decision_message(
        peer_network_id,
        Instant::now(),
        malicious_commit,
    );
    
    // VULNERABILITY: highest_committed_epoch_round updated to (999, 0) without verification
    let corrupted_state = observer.observer_block_data.lock()
        .get_highest_committed_epoch_round();
    assert_eq!(corrupted_state, (999, 0)); // State corrupted!
    
    // All legitimate commits for epochs 5-998 are now rejected
    let legitimate_commit = create_verified_commit_decision(6, 0);
    observer.process_commit_decision_message(
        peer_network_id,
        Instant::now(),
        legitimate_commit,
    );
    
    // Commit is dropped because (6, 0) < (999, 0)
    // Observer is now permanently desynchronized
}
```

## Notes

The vulnerability allows malicious peers to corrupt the consensus observer's view of the committed blockchain state without cryptographic proof. The TODO comment at lines 497-498 confirms developers are aware future epoch commits lack proper validation, but no fix has been implemented. This represents a concrete HIGH severity vulnerability enabling denial of service attacks against consensus observer nodes.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L452-461)
```rust
        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L579-580)
```rust
        if let Err(error) = self
            .subscription_manager
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L281-282)
```rust
        // Update the root
        self.update_root(commit_proof.clone());
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L288-290)
```rust
        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L112-124)
```rust
    pub fn remove_blocks_for_commit(&mut self, commit_ledger_info: &LedgerInfoWithSignatures) {
        // Determine the epoch and round to split off
        let split_off_epoch = commit_ledger_info.ledger_info().epoch();
        let split_off_round = commit_ledger_info.commit_info().round().saturating_add(1);

        // Remove the blocks from the ordered blocks
        self.ordered_blocks = self
            .ordered_blocks
            .split_off(&(split_off_epoch, split_off_round));

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_ledger_info);
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L127-142)
```rust
    pub fn update_commit_decision(&mut self, commit_decision: &CommitDecision) {
        // Get the epoch and round of the commit decision
        let commit_decision_epoch = commit_decision.epoch();
        let commit_decision_round = commit_decision.round();

        // Update the commit decision for the ordered blocks
        if let Some((_, existing_commit_decision)) = self
            .ordered_blocks
            .get_mut(&(commit_decision_epoch, commit_decision_round))
        {
            *existing_commit_decision = Some(commit_decision.clone());
        }

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_decision.commit_proof());
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L144-165)
```rust
    /// Updates the highest committed epoch and round based on the commit ledger info
    fn update_highest_committed_epoch_round(
        &mut self,
        commit_ledger_info: &LedgerInfoWithSignatures,
    ) {
        // Get the epoch and round of the commit ledger info
        let commit_epoch = commit_ledger_info.ledger_info().epoch();
        let commit_round = commit_ledger_info.commit_info().round();
        let commit_epoch_round = (commit_epoch, commit_round);

        // Update the highest committed epoch and round (if appropriate)
        match self.highest_committed_epoch_round {
            Some(highest_committed_epoch_round) => {
                if commit_epoch_round > highest_committed_epoch_round {
                    self.highest_committed_epoch_round = Some(commit_epoch_round);
                }
            },
            None => {
                self.highest_committed_epoch_round = Some(commit_epoch_round);
            },
        }
    }
```
