# Audit Report

## Title
Unbounded CPU Profiling Duration Enables Performance Degradation DoS on Validator Nodes

## Summary
The `/profilez` endpoint in the Admin Service lacks validation on the `seconds` parameter, allowing an attacker to trigger CPU profiling sessions of arbitrary duration (hours, days, or even years). While a mutex prevents concurrent profiling, an attacker can trigger sequential profiling sessions to maintain continuous performance overhead on validator nodes, potentially degrading consensus participation on misconfigured or internally-accessible deployments.

## Finding Description
The vulnerability exists in the CPU profiling request handler where user-supplied duration values are accepted without upper bounds validation. [1](#0-0) 

The `seconds` parameter is parsed directly from the query string with no maximum value check. An attacker can specify arbitrarily large values like `seconds=31536000` (one year) or even larger. The profiling runs for the entire specified duration at line 98: [2](#0-1) 

While a mutex prevents concurrent profiling sessions, it does not prevent sequential sessions: [3](#0-2) 

Once a profiling session completes, the mutex is released and an attacker can immediately initiate another session. The endpoint is exposed through the Admin Service: [4](#0-3) 

**Attack Preconditions:**
1. Admin service must be enabled (automatic on testnet/devnet per ConfigOptimizer): [5](#0-4) 

2. Admin port must be exposed (requires misconfiguration or internal network access, as default is disabled): [6](#0-5) 

3. No authentication configured (default on non-mainnet, sanitizer prevents on mainnet): [7](#0-6) 

**Exploitation Path:**
1. Attacker identifies validator node with exposed admin port (misconfigured testnet/devnet or internal access)
2. Attacker sends: `GET /profilez?seconds=86400` (24 hours)
3. CPU profiling runs continuously with sampling overhead
4. After completion, attacker immediately sends another request
5. Alternatively, attacker sends: `GET /profilez?seconds=31536000` (1 year) for single long-duration attack

The profiling overhead (sampling at 99 Hz by default) degrades validator performance, potentially causing missed proposals, late votes, and timeout penalties that could affect consensus participation and validator rewards.

## Impact Explanation
This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria due to "Validator node slowdowns" that can affect consensus participation.

**Resource Limits Invariant Violation:** The lack of maximum duration validation violates the documented invariant that "All operations must respect gas, storage, and computational limits."

**Potential Impact:**
- Continuous CPU sampling overhead (99 Hz) degrades node performance
- Validators may experience late block proposals and votes
- Potential timeout penalties and reduced rewards
- In extreme cases, may contribute to validator being removed from active set
- Affects validator liveness but not consensus safety directly

The impact is limited to performance degradation rather than consensus safety violations or fund theft, justifying Medium severity rather than Critical/High.

## Likelihood Explanation
**Likelihood: Medium (conditional on deployment configuration)**

**Factors Increasing Likelihood:**
- Admin service automatically enabled on testnet/devnet chains
- No authentication required on non-mainnet by default
- No rate limiting on the endpoint
- Attack is simple (single HTTP GET request)

**Factors Decreasing Likelihood:**
- Default Helm configuration does NOT expose admin port externally (`enableAdminPort: false`)
- Mainnet deployments enforce authentication requirement via ConfigSanitizer
- Requires either: (a) explicit misconfiguration to expose port, or (b) internal network access

The vulnerability is most likely to be exploited in:
1. Misconfigured testnet/devnet deployments where operators enable admin port exposure
2. Scenarios where attacker gains internal network access (container escape, VPN compromise, insider threat)
3. Local development environments with network exposure

## Recommendation
Implement maximum duration validation for the `seconds` parameter to prevent unbounded profiling sessions.

**Recommended Fix:**
```rust
// In crates/aptos-system-utils/src/profiling.rs

const MAX_PROFILING_SECONDS: u64 = 300; // 5 minutes maximum

pub async fn handle_cpu_profiling_request(req: Request<Body>) -> hyper::Result<Response<Body>> {
    let query = req.uri().query().unwrap_or("");
    let query_pairs: HashMap<_, _> = url::form_urlencoded::parse(query.as_bytes()).collect();

    let seconds: u64 = match query_pairs.get("seconds") {
        Some(val) => match val.parse() {
            Ok(val) => {
                if val > MAX_PROFILING_SECONDS {
                    return Ok(reply_with_status(
                        StatusCode::BAD_REQUEST,
                        format!("Profiling duration cannot exceed {} seconds", MAX_PROFILING_SECONDS)
                    ));
                }
                val
            },
            Err(err) => return Ok(reply_with_status(StatusCode::BAD_REQUEST, err.to_string())),
        },
        None => 10,
    };
    
    // ... rest of the function
}
```

**Additional Recommendations:**
1. Implement rate limiting on the admin service endpoints to prevent rapid sequential requests
2. Add monitoring/alerting for profiling sessions exceeding expected durations
3. Document security best practices for admin service configuration in deployment guides
4. Consider requiring authentication even on testnet/devnet for production-like deployments

## Proof of Concept
```bash
#!/bin/bash
# PoC: Continuous CPU profiling attack on misconfigured validator

# Prerequisites:
# - Target validator with admin service exposed (testnet/devnet with enableAdminPort: true)
# - No authentication configured

TARGET_HOST="validator.testnet.example.com"
ADMIN_PORT="9202"

echo "[*] Testing unbounded duration attack..."
curl -v "http://${TARGET_HOST}:${ADMIN_PORT}/profilez?seconds=86400"
# Profiling runs for 24 hours with continuous CPU overhead

echo "[*] Testing sequential profiling attack..."
for i in {1..100}; do
    echo "Starting profiling session $i"
    curl "http://${TARGET_HOST}:${ADMIN_PORT}/profilez?seconds=3600" &
    # Wait for completion, then immediately start next session
    sleep 3600
done
# Maintains continuous profiling over extended period

echo "[*] Testing extreme duration attack..."
curl -v "http://${TARGET_HOST}:${ADMIN_PORT}/profilez?seconds=31536000"
# Attempts 1-year profiling session (if validator stays running)
```

**Expected Behavior (Vulnerable):**
- Requests succeed with profiling running for specified durations
- Validator CPU shows elevated usage due to profiling overhead
- Performance metrics show degraded block proposal/voting latency

**Expected Behavior (After Fix):**
- Requests with `seconds > 300` return HTTP 400 Bad Request
- Error message indicates maximum duration limit exceeded

## Notes
This vulnerability demonstrates a classic resource exhaustion pattern where user-controlled input (duration parameter) lacks bounds checking. While the default secure configuration (admin port not exposed) mitigates external exploitation, the underlying code flaw should be addressed to protect against misconfiguration and internal threats. The Medium severity is appropriate given the performance impact on validator operations without direct consensus safety violations.

### Citations

**File:** crates/aptos-system-utils/src/profiling.rs (L23-29)
```rust
    let seconds: u64 = match query_pairs.get("seconds") {
        Some(val) => match val.parse() {
            Ok(val) => val,
            Err(err) => return Ok(reply_with_status(StatusCode::BAD_REQUEST, err.to_string())),
        },
        None => 10,
    };
```

**File:** crates/aptos-system-utils/src/profiling.rs (L91-92)
```rust
    let lock = CPU_PROFILE_MUTEX.try_lock();
    ensure!(lock.is_some(), "A profiling task is already running.");
```

**File:** crates/aptos-system-utils/src/profiling.rs (L98-98)
```rust
    tokio::time::sleep(Duration::from_secs(seconds)).await;
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L184-185)
```rust
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
```

**File:** config/src/config/admin_service_config.rs (L47-47)
```rust
            authentication_configs: vec![],
```

**File:** config/src/config/admin_service_config.rs (L93-100)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```

**File:** terraform/helm/aptos-node/values.yaml (L158-159)
```yaml
    # -- Enable the admin port on the validator
    enableAdminPort: false
```
