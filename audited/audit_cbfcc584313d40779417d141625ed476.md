# Audit Report

## Title
Concurrent OnDiskStorage Access Race Condition in Multi-Component Safety Rules Initialization

## Summary
The Consensus, DKG, and JWK consensus components each create independent `PersistentSafetyStorage` instances that access the same underlying `OnDiskStorage` file without proper synchronization. This creates a race condition during initialization and key storage operations, potentially leading to data corruption and consensus safety violations.

## Finding Description

When a validator node initializes, three separate components are started concurrently in independent runtimes: [1](#0-0) 

Each component creates its own `PersistentSafetyStorage` by calling the `storage()` function with the same `SafetyRulesConfig`: [2](#0-1) [3](#0-2) [4](#0-3) 

The `storage()` function converts the `SecureBackend` configuration into a `Storage` instance: [5](#0-4) 

**Critical Issue**: Each call to `OnDiskStorage::new()` creates a **separate instance** pointing to the same file path. The `OnDiskStorage` implementation explicitly documents it is not thread-safe: [6](#0-5) 

During initialization, the `storage()` function writes overriding consensus keys to the shared storage: [7](#0-6) 

**The Race Condition**: The `set()` operation performs an unprotected read-modify-write sequence: [8](#0-7) 

When three components execute this concurrently:
1. Component A reads entire file → modifies HashMap → writes file
2. Component B reads entire file → modifies HashMap → writes file
3. Component C reads entire file → modifies HashMap → writes file

**Result**: Lost writes and potential data corruption as each component's changes can overwrite others.

## Impact Explanation

**High Severity** - This meets the "Significant protocol violations" category because:

1. **SafetyData Corruption Risk**: The main consensus writes critical voting state (`SafetyData`) to the shared storage. If this gets corrupted due to concurrent access, it could violate consensus safety invariants (e.g., allowing double-voting if `last_voted_round` is lost).

2. **Key Storage Race**: Overriding consensus keys written during initialization can be lost, causing authentication failures or inability to participate in DKG/JWK consensus.

3. **Initialization Failures**: Race conditions during storage initialization can leave the system in an inconsistent state, requiring manual intervention.

While the README states OnDiskStorage "should not be used in production," the codebase does not enforce this at runtime - nodes can be misconfigured to use OnDiskStorage, creating this vulnerability. [9](#0-8) 

## Likelihood Explanation

**Medium-High Likelihood** in misconfigured environments:

- The race window occurs during every node startup when all three components initialize concurrently
- The components run in separate runtimes with independent thread pools
- No explicit synchronization exists between component initializations
- While mainnet validators should use VaultStorage, testnet/devnet nodes or misconfigured validators could use OnDiskStorage

The sanitizer checks for mainnet prevent this on the main chain, but do not prevent the vulnerability in all deployment scenarios: [10](#0-9) 

## Recommendation

**Option 1 - Runtime Enforcement**: Add runtime checks to panic if OnDiskStorage is used when multiple safety-critical components are enabled:

```rust
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    
    // Enforce production-safe storage backends
    if backend.is_on_disk() {
        panic!(
            "OnDiskStorage is not thread-safe and must not be used in production. \
             Multiple components (Consensus, DKG, JWK) access storage concurrently. \
             Use VaultStorage instead."
        );
    }
    
    // ... rest of function
}
```

**Option 2 - Shared Storage Instance**: Create a single shared `PersistentSafetyStorage` instance wrapped in `Arc<RwLock<>>` and pass it to all components instead of having each create their own.

**Option 3 - Namespace Isolation**: Use the `Namespaced` wrapper to give each component its own isolated storage namespace, preventing conflicts.

## Proof of Concept

```rust
// Reproduction test demonstrating the race condition
#[tokio::test]
async fn test_concurrent_safety_storage_race() {
    use std::sync::Arc;
    use aptos_secure_storage::{OnDiskStorage, KVStorage};
    use aptos_temppath::TempPath;
    
    let temp_path = TempPath::new();
    let path = temp_path.path().to_path_buf();
    
    // Simulate three components initializing concurrently
    let handles: Vec<_> = (0..3).map(|i| {
        let p = path.clone();
        tokio::spawn(async move {
            let mut storage = OnDiskStorage::new(p);
            // Each component tries to write its own key
            for j in 0..100 {
                let key = format!("CONSENSUS_KEY_{}", i);
                storage.set(&key, format!("value_{}_{}", i, j)).unwrap();
            }
        })
    }).collect();
    
    for h in handles {
        h.await.unwrap();
    }
    
    // Check for lost writes - many keys will be missing due to race
    let storage = OnDiskStorage::new(path);
    let mut missing = 0;
    for i in 0..3 {
        for j in 0..100 {
            let key = format!("CONSENSUS_KEY_{}", i);
            if storage.get::<String>(&key).is_err() {
                missing += 1;
            }
        }
    }
    
    assert!(missing > 0, "Race condition should cause lost writes");
}
```

## Notes

While this vulnerability requires specific misconfiguration (using OnDiskStorage instead of VaultStorage), it represents a **design flaw** where the system allows unsafe configurations that violate stated requirements. The lack of runtime enforcement means operators could inadvertently deploy vulnerable nodes, especially in testnet/development environments that may later be promoted to production-like settings.

### Citations

**File:** aptos-node/src/lib.rs (L813-822)
```rust
    let (vtxn_pool, dkg_runtime) =
        consensus::create_dkg_runtime(&mut node_config, dkg_subscriptions, dkg_network_interfaces);

    // Create the JWK consensus runtime
    let jwk_consensus_runtime = consensus::create_jwk_consensus_runtime(
        &mut node_config,
        jwk_consensus_subscriptions,
        jwk_consensus_network_interfaces,
        &vtxn_pool,
    );
```

**File:** dkg/src/epoch_manager.rs (L90-90)
```rust
            key_storage: storage(safety_rules_config),
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L80-80)
```rust
            key_storage: storage(safety_rules_config),
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L79-99)
```rust
        // Ensuring all the overriding consensus keys are in the storage.
        let timer = Instant::now();
        for blob in config
            .initial_safety_rules_config
            .overriding_identity_blobs()
            .unwrap_or_default()
        {
            if let Some(sk) = blob.consensus_private_key {
                let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
                let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
                match storage.internal_store().set(storage_key.as_str(), sk) {
                    Ok(_) => {
                        info!("Setting {storage_key} succeeded.");
                    },
                    Err(e) => {
                        warn!("Setting {storage_key} failed with internal store set error: {e}");
                    },
                }
            }
        }
        info!("Overriding key work time: {:?}", timer.elapsed());
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L122-122)
```rust
        let storage = storage(config);
```

**File:** config/src/config/secure_backend_config.rs (L166-173)
```rust
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L85-93)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```
