# Audit Report

## Title
SafetyRules sign_proposal() Lacks Double-Signing Prevention for Same-Round Proposals

## Summary
The `sign_proposal()` function in SafetyRules does not maintain state to prevent signing multiple different proposals at the same round, allowing a malicious or compromised validator to create equivocating blocks that violate AptosBFT consensus safety guarantees.

## Finding Description

The `guarded_sign_proposal()` function in SafetyRules performs validation checks but critically fails to track which rounds have been signed for proposals. [1](#0-0) 

The function only verifies that `block_data.round() > safety_data.last_voted_round`, but it does NOT update `last_voted_round` or persist any record of what was signed. This contrasts sharply with the voting path: [2](#0-1) [3](#0-2) 

In voting, `verify_and_update_last_vote_round()` updates and persists the state to prevent double-voting. However, proposal signing has no equivalent protection.

**Attack Path:**

1. A malicious validator (or compromised validator node with access to SafetyRules) has `last_voted_round = 5`
2. The validator becomes leader for round 10
3. The validator creates two different `BlockData` structures for round 10:
   - `BlockData_A` with one set of transactions/parent
   - `BlockData_B` with different transactions/parent
4. Call `sign_proposal(BlockData_A)`:
   - Check: `10 > 5` ✓ passes
   - Signs and returns signature_A
   - Does NOT update `last_voted_round`
5. Call `sign_proposal(BlockData_B)`:
   - Check: `10 > 5` ✓ passes again (state unchanged)
   - Signs and returns signature_B
   - Does NOT update `last_voted_round`
6. Validator now has two valid BLS signatures for conflicting proposals at round 10

While `ProposalGenerator` has protection via `last_round_generated`: [4](#0-3) 

This only prevents generating proposals through the normal API path. A sophisticated attacker with access to SafetyRules can bypass ProposalGenerator by manually constructing `BlockData` and calling `sign_proposal()` directly.

The `UnequivocalProposerElection` mechanism only detects equivocation on the receiver side: [5](#0-4) 

This detection happens AFTER the attacker has already created the signatures and can send different proposals to different network partitions.

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This violates the fundamental AptosBFT safety guarantee. By creating equivocating proposals:

1. **Network Partition Risk**: The attacker can send different proposals to different validators, potentially causing honest validators to vote on conflicting blocks
2. **Safety Violation**: If both proposals gather sufficient votes in different network partitions, the blockchain could fork
3. **Byzantine Fault Tolerance Compromise**: This reduces the effective Byzantine fault tolerance threshold, as even a single compromised validator can create safety violations

Per the Aptos bug bounty severity categories, this qualifies as Critical because it enables "Consensus/Safety violations" that could lead to chain splits or double-spending scenarios.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Validator node compromise (attacker gains access to SafetyRules module)
- Ability to construct custom `BlockData` structures
- Validator being elected as leader for a round

While validator compromise is not trivial, SafetyRules is specifically designed as a defense-in-depth mechanism to protect against exactly this scenario. The lack of protection at this critical layer is a fundamental security gap.

Defense-in-depth principle dictates that SafetyRules should enforce safety properties independently, not rely on higher-level components like ProposalGenerator. This is especially important because SafetyRules is often intended to be a hardware-backed security module (HSM/SGX) that should be the ultimate authority on what gets signed.

## Recommendation

Add state tracking to `SafetyData` to record the last proposed round, similar to `last_voted_round`: [6](#0-5) 

Modify `guarded_sign_proposal()` to:
1. Add a `last_proposed_round` field to `SafetyData`
2. Check that `block_data.round() > safety_data.last_proposed_round`
3. Update `safety_data.last_proposed_round = block_data.round()`
4. Persist the updated safety_data via `self.persistent_storage.set_safety_data(safety_data)?`

This ensures that even if ProposalGenerator is bypassed, SafetyRules will reject attempts to sign multiple proposals at the same round.

## Proof of Concept

```rust
// Test to demonstrate the vulnerability
// Add to consensus/safety-rules/src/tests/suite.rs

fn test_double_sign_same_round_proposals(safety_rules: &Callback) {
    let (mut safety_rules, signer) = safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    let round = genesis_qc.certified_block().round() + 1;
    
    // Create first proposal for round
    let proposal_a = test_utils::make_proposal_with_qc(round, genesis_qc.clone(), &signer);
    let sig_a = safety_rules.sign_proposal(proposal_a.block().block_data()).unwrap();
    
    // Create DIFFERENT proposal for SAME round with different payload
    let proposal_b_data = BlockData::new_proposal(
        Payload::empty(false, false), // Different payload
        signer.author(),
        vec![],
        round, // Same round!
        proposal_a.block().timestamp_usecs() + 1,
        genesis_qc.clone(),
    );
    
    // This should FAIL but currently SUCCEEDS
    let result = safety_rules.sign_proposal(&proposal_b_data);
    
    // VULNERABILITY: Both signatures succeed for same round
    assert!(result.is_ok(), "Double-signing at same round should be prevented!");
    let sig_b = result.unwrap();
    
    // Attacker now has two valid signatures for different proposals at same round
    assert_ne!(sig_a, sig_b); // Different signatures
    assert_eq!(proposal_a.block().round(), proposal_b_data.round()); // Same round
}
```

**Notes:**

This vulnerability demonstrates that SafetyRules lacks proper equivocation prevention at the proposal signing level. While ProposalGenerator provides some protection at a higher level, SafetyRules as a security-critical component should enforce its own independent guarantees. The separation between proposal generation (voting path updates `last_voted_round`) and proposal signing (does not update any state) creates an exploitable gap in consensus safety enforcement.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L77-80)
```rust
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L92-92)
```rust
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** consensus/src/liveness/proposal_generator.rs (L565-572)
```rust
        {
            let mut last_round_generated = self.last_round_generated.lock();
            if *last_round_generated < round {
                *last_round_generated = round;
            } else {
                bail!("Already proposed in the round {}", round);
            }
        }
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L61-86)
```rust
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
```

**File:** consensus/consensus-types/src/safety_data.rs (L9-21)
```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```
