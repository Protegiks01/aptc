# Audit Report

## Title
Validator Node Crash Due to Empty Weight HashMap Lookup in SecretShareAggregator::retain()

## Summary
The `SecretShareAggregator::retain()` method attempts to recalculate `total_weight` by looking up validator weights in a HashMap that is always empty, causing a panic that crashes the consensus node when shares exist in the aggregator.

## Finding Description

The vulnerability exists in the weight recalculation logic of `SecretShareAggregator::retain()`. [1](#0-0) 

The root cause is a data source inconsistency in `SecretShareConfig`. The `weights` HashMap field is initialized as empty and never populated: [2](#0-1) 

However, `get_peer_weights()` returns a reference to this empty HashMap: [3](#0-2) 

Meanwhile, individual weight queries use `get_peer_weight()` which hardcodes a return value of 1: [4](#0-3) 

**Exploitation Flow:**

1. Other validators' secret shares arrive via network messages and are added to a `SecretShareAggregator` in `PendingMetadata` state using `add_share()` with weight=1 from `get_peer_weight()` [5](#0-4) 

2. These shares accumulate in the aggregator's `shares` HashMap with correctly tracked `total_weight`

3. When the validator's own share is computed and `add_self_share()` is called, it retrieves the empty `peer_weights` HashMap [6](#0-5) 

4. This empty HashMap is passed to `add_share_with_metadata()` which calls `retain()` [7](#0-6) 

5. The `retain()` method filters shares by metadata, and if any shares remain, attempts to look up each author's weight in the empty HashMap, causing a panic with message "Author must exist for weight"

This is NOT a concurrent modification issue (Rust's borrow checker prevents that), but rather a **data source inconsistency** where weight additions use `get_peer_weight()` (returns 1) while weight recalculation uses `get_peer_weights()` (returns empty HashMap).

## Impact Explanation

**Severity: High** - This meets the Aptos bug bounty criteria for "Validator node slowdowns / API crashes"

**Impact:**
- Immediate validator node crash via panic when processing secret shares
- Loss of validator availability during secret sharing rounds
- If multiple validators crash simultaneously (likely since all follow same code path), network liveness could be impacted
- Consensus round delays or failures if insufficient validators remain online

The vulnerability directly affects consensus availability, a critical component of blockchain operation. While it doesn't cause fund loss or consensus safety violations (Critical), it does cause validator crashes and potential network disruption (High).

## Likelihood Explanation

**Likelihood: High**

This vulnerability triggers under normal protocol operation without requiring any malicious behavior:

1. Secret sharing is a standard consensus mechanism in Aptos for randomness generation
2. Network latency naturally causes validators to receive shares at different times
3. It's common for a validator to receive peer shares before computing its own share
4. The bug triggers deterministically when shares exist in the aggregator before `add_self_share()` is called

The crash will occur repeatedly during every epoch where secret sharing is active and shares arrive in the vulnerable order. This is not an edge case but a regular occurrence in distributed consensus protocols.

## Recommendation

**Fix: Populate the weights HashMap or use get_peer_weight() consistently**

**Option 1** - Populate weights HashMap in constructor:
```rust
// In types/src/secret_sharing.rs SecretShareConfig::new()
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    // ... other params
) -> Self {
    // Build weights HashMap from validator set
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .map(|addr| (addr, 1u64))  // Or actual voting weights
        .collect();
    
    Self {
        // ... other fields
        weights,
    }
}
```

**Option 2** - Use `get_peer_weight()` in `retain()` instead of the HashMap:
```rust
// In consensus/src/rand/secret_sharing/secret_share_store.rs
fn retain(&mut self, metadata: &SecretShareMetadata, config: &SecretShareConfig) {
    self.shares.retain(|_, share| share.metadata == *metadata);
    self.total_weight = self
        .shares
        .keys()
        .map(|author| config.get_peer_weight(author))
        .sum();
}
```

Then update the call site to pass `config` instead of `weights`.

**Recommended:** Option 1 is preferable as it properly initializes the weights data structure and maintains consistency.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    use std::collections::HashMap;

    #[test]
    #[should_panic(expected = "Author must exist for weight")]
    fn test_retain_panics_with_empty_weights() {
        let author1 = AccountAddress::random();
        let author2 = AccountAddress::random();
        
        // Create aggregator and add a share
        let mut aggregator = SecretShareAggregator::new(author1);
        let metadata = SecretShareMetadata {
            epoch: 1,
            round: 100,
            timestamp: 12345,
            block_id: HashValue::zero(),
            digest: vec![],
        };
        
        let share = SecretShare {
            author: author2,
            metadata: metadata.clone(),
            share: vec![],  // Mock share data
        };
        
        aggregator.add_share(share, 1);
        
        // Create empty weights HashMap (as initialized in SecretShareConfig)
        let empty_weights: HashMap<Author, u64> = HashMap::new();
        
        // This will panic because author2 is not in empty_weights
        aggregator.retain(&metadata, &empty_weights);
    }
}
```

**Notes:**
While the security question asks about concurrent modifications and stale weight data, the actual vulnerability is a **data source inconsistency** causing a deterministic panic. Rust's ownership system prevents true concurrent modifications to `&mut self`. The real issue is that `SecretShareConfig` maintains two inconsistent weight query methods: `get_peer_weight()` (returns 1) vs `get_peer_weights()` (returns empty HashMap), and `retain()` uses the latter causing a panic when shares exist.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L166-170)
```rust
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
                SecretShareItem::PendingDecision {
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L242-242)
```rust
        let peer_weights = self.secret_share_config.get_peer_weights();
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```

**File:** types/src/secret_sharing.rs (L145-169)
```rust
    weights: HashMap<Author, u64>,
}

impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** types/src/secret_sharing.rs (L200-202)
```rust
    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```
