# Audit Report

## Title
Successful Proposer Index Can Appear in Failed Proposer Indices Due to Multi-Round Assignment

## Summary
When a validator is assigned as proposer for multiple consecutive rounds (via `contiguous_rounds > 1` configuration), they can fail in earlier rounds and succeed in a later round. The resulting block metadata will list the successful proposer while also including their index in `failed_proposer_indices`, creating a logical inconsistency in performance statistics and reputation tracking.

## Finding Description

The vulnerability exists in how block metadata is constructed when the same validator is assigned to multiple consecutive rounds through the proposer election mechanism.

In the RotatingProposer implementation, validators can be assigned to multiple consecutive rounds: [1](#0-0) 

When computing failed authors for a new block, the system identifies all proposers from rounds between the parent block and the current round: [2](#0-1) 

For normal (non-NIL) proposals, `include_cur_round` is `false`, so failed authors include rounds from `previous_round + 1` to `round - 1`: [3](#0-2) 

These failed authors are then converted to validator indices: [4](#0-3) 

And included in the block metadata alongside the successful proposer: [5](#0-4) 

The indexer stores this data without validation: [6](#0-5) 

**Critical Impact:** In the Move framework's performance tracking, the same validator receives BOTH a successful proposal increment AND failed proposal increments in a single block: [7](#0-6) 

This creates incorrect performance statistics used for reputation-based leader selection: [8](#0-7) 

## Impact Explanation

This issue has **Low severity** impact as labeled in the security question, but creates real operational concerns:

1. **Performance Statistics Corruption**: Validators accumulate both successful and failed proposal counts simultaneously, creating inaccurate historical records
2. **Reputation Calculation Skew**: Leader reputation algorithms count the same validator as both successful and failed in the same window
3. **Analytics Confusion**: Downstream monitoring and analytics tools may incorrectly interpret validator performance
4. **Potential Reward Impact**: If performance statistics influence staking rewards or validator selection, the double-counting could create unfair advantages or penalties

However, this does NOT constitute:
- Loss of funds
- Consensus safety violation  
- Network availability impact
- Critical security breach

Therefore, it correctly falls under **Low Severity** ($1,000 category) as a non-critical implementation bug.

## Likelihood Explanation

**Likelihood: Medium to High** in production networks using rotating proposer election with `contiguous_rounds > 1`.

This occurs naturally whenever:
1. The proposer election strategy assigns the same validator to multiple consecutive rounds
2. That validator experiences transient failures (network issues, performance problems)
3. The validator recovers and successfully proposes in a later assigned round
4. All failed rounds fall within the `max_failed_authors_to_store` window

No malicious action is required - this is an emergent consequence of normal consensus operation under validator failures.

## Recommendation

Add validation in the block metadata construction to exclude the current proposer from the failed_proposer_indices:

```rust
// In consensus/consensus-types/src/block.rs, modify new_block_metadata():
pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
    let proposer = self.author().unwrap_or(AccountAddress::ZERO);
    let failed_indices = self.block_data()
        .failed_authors()
        .map_or(vec![], |failed_authors| {
            let indices = Self::failed_authors_to_indices(validators, failed_authors);
            // Filter out current proposer's index to avoid logical inconsistency
            if proposer != AccountAddress::ZERO {
                if let Some(proposer_idx) = validators.iter().position(|&v| v == proposer) {
                    indices.into_iter()
                        .filter(|&idx| idx != proposer_idx as u32)
                        .collect()
                } else {
                    indices
                }
            } else {
                indices
            }
        });
    
    BlockMetadata::new(
        self.id(),
        self.epoch(),
        self.round(),
        proposer,
        self.previous_bitvec().into(),
        failed_indices,
        self.timestamp_usecs(),
    )
}
```

Alternatively, modify `update_performance_statistics` to detect and skip duplicate counting:

```move
// In stake.move, check if proposer_index appears in failed_proposer_indices
public(friend) fun update_performance_statistics(
    proposer_index: Option<u64>,
    failed_proposer_indices: vector<u64>
) acquires ValidatorPerformance {
    let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);
    let validator_len = vector::length(&validator_perf.validators);
    
    if (option::is_some(&proposer_index)) {
        let cur_proposer_index = option::extract(&mut proposer_index);
        if (cur_proposer_index < validator_len) {
            let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
            validator.successful_proposals = validator.successful_proposals + 1;
        };
    };
    
    // Filter failed_proposer_indices to exclude current proposer
    let cur_proposer = if (option::is_some(&proposer_index)) {
        option::some(*option::borrow(&proposer_index))
    } else {
        option::none()
    };
    
    let f = 0;
    let f_len = vector::length(&failed_proposer_indices);
    while (f < f_len) {
        let validator_index = *vector::borrow(&failed_proposer_indices, f);
        // Skip if this is the current proposer
        if (!option::is_some(&cur_proposer) || validator_index != *option::borrow(&cur_proposer)) {
            if (validator_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
                validator.failed_proposals = validator.failed_proposals + 1;
            };
        };
        f = f + 1;
    };
}
```

## Proof of Concept

```rust
// Rust test demonstrating the inconsistency
#[test]
fn test_proposer_in_failed_indices() {
    use aptos_consensus_types::block::Block;
    use aptos_types::account_address::AccountAddress;
    
    // Setup: 4 validators, contiguous_rounds = 3
    let validators = vec![
        AccountAddress::random(),
        AccountAddress::random(), 
        AccountAddress::random(),
        AccountAddress::random(),
    ];
    
    // Validator[0] assigned to rounds 0, 1, 2
    // Validator[0] fails in rounds 0, 1 but succeeds in round 2
    
    // Simulate failed_authors for round 2 block:
    // Should include (round 0, validator[0]) and (round 1, validator[0])
    let failed_authors = vec![
        (0u64, validators[0]),
        (1u64, validators[0]),
    ];
    
    // Create block with validator[0] as proposer
    // Block metadata will show:
    // - proposer = validators[0]  
    // - failed_proposer_indices = [0, 0] (validator[0]'s index appears twice)
    
    // This demonstrates the logical inconsistency:
    // The successful proposer's index (0) appears in failed_proposer_indices
}
```

**Notes:**

This vulnerability represents a logical data consistency issue rather than a critical security flaw. While it doesn't enable direct attacks on consensus safety or fund theft, it corrupts validator performance metrics used for reputation-based leader selection and potentially affects staking economics. The issue is systemic to the current design when using rotating proposer election with multi-round assignments and requires a design-level fix to prevent the successful proposer from being counted as failed within the same block metadata.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L527-532)
```rust
        let failed_authors = self.compute_failed_authors(
            round,
            quorum_cert.certified_block().round(),
            false,
            proposer_election,
        );
```

**File:** consensus/src/liveness/proposal_generator.rs (L884-902)
```rust
    pub fn compute_failed_authors(
        &self,
        round: Round,
        previous_round: Round,
        include_cur_round: bool,
        proposer_election: Arc<dyn ProposerElection>,
    ) -> Vec<(Round, Author)> {
        let end_round = round + u64::from(include_cur_round);
        let mut failed_authors = Vec::new();
        let start = std::cmp::max(
            previous_round + 1,
            end_round.saturating_sub(self.max_failed_authors_to_store as u64),
        );
        for i in start..end_round {
            failed_authors.push((i, proposer_election.get_valid_proposer(i)));
        }

        failed_authors
    }
```

**File:** consensus/consensus-types/src/block.rs (L580-594)
```rust
    pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
        BlockMetadata::new(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
        )
```

**File:** consensus/consensus-types/src/block.rs (L619-638)
```rust
    fn failed_authors_to_indices(
        validators: &[AccountAddress],
        failed_authors: &[(Round, Author)],
    ) -> Vec<u32> {
        failed_authors
            .iter()
            .map(|(_round, failed_author)| {
                validators
                    .iter()
                    .position(|&v| v == *failed_author)
                    .unwrap_or_else(|| {
                        panic!(
                            "Failed author {} not in validator list {:?}",
                            *failed_author, validators
                        )
                    })
            })
            .map(|index| u32::try_from(index).expect("Index is out of bounds for u32"))
            .collect()
    }
```

**File:** crates/indexer/src/models/block_metadata_transactions.rs (L56-71)
```rust
    pub fn from_transaction(txn: &APIBlockMetadataTransaction, block_height: i64) -> Self {
        let txn_version = txn.info.version.0 as i64;
        Self {
            version: txn_version,
            block_height,
            id: txn.id.to_string(),
            epoch: txn.epoch.0 as i64,
            round: txn.round.0 as i64,
            proposer: standardize_address(&txn.proposer.inner().to_hex_literal()),
            failed_proposer_indices: serde_json::to_value(&txn.failed_proposer_indices).unwrap(),
            previous_block_votes_bitvec: serde_json::to_value(&txn.previous_block_votes_bitvec)
                .unwrap(),
            // time is in microseconds
            timestamp: parse_timestamp(txn.timestamp.0, txn_version),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1296-1330)
```text
        if (option::is_some(&proposer_index)) {
            let cur_proposer_index = option::extract(&mut proposer_index);
            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,
            // this ensures that this function doesn't abort if there are out of bounds errors.
            if (cur_proposer_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
                spec {
                    assume validator.successful_proposals + 1 <= MAX_U64;
                };
                validator.successful_proposals = validator.successful_proposals + 1;
            };
        };

        let f = 0;
        let f_len = vector::length(&failed_proposer_indices);
        while ({
            spec {
                invariant len(validator_perf.validators) == validator_len;
                invariant (option::is_some(ghost_proposer_idx) && option::borrow(
                    ghost_proposer_idx
                ) < validator_len) ==>
                    (validator_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals ==
                        ghost_valid_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals + 1);
            };
            f < f_len
        }) {
            let validator_index = *vector::borrow(&failed_proposer_indices, f);
            if (validator_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
                spec {
                    assume validator.failed_proposals + 1 <= MAX_U64;
                };
                validator.failed_proposals = validator.failed_proposals + 1;
            };
            f = f + 1;
```

**File:** consensus/src/liveness/leader_reputation.rs (L399-461)
```rust
    pub fn count_proposals(
        &self,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> HashMap<Author, u32> {
        Self::count_proposals_custom(
            epoch_to_candidates,
            history,
            self.proposer_window_size,
            self.reputation_window_from_stale_end,
        )
    }

    pub fn count_proposals_custom(
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
        window_size: usize,
        from_stale_end: bool,
    ) -> HashMap<Author, u32> {
        Self::history_iter(history, epoch_to_candidates, window_size, from_stale_end).fold(
            HashMap::new(),
            |mut map, meta| {
                let count = map.entry(meta.proposer()).or_insert(0);
                *count += 1;
                map
            },
        )
    }

    pub fn count_failed_proposals(
        &self,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> HashMap<Author, u32> {
        Self::history_iter(
            history,
            epoch_to_candidates,
            self.proposer_window_size,
            self.reputation_window_from_stale_end,
        )
        .fold(HashMap::new(), |mut map, meta| {
            match Self::indices_to_validators(
                &epoch_to_candidates[&meta.epoch()],
                meta.failed_proposer_indices(),
            ) {
                Ok(failed_proposers) => {
                    for &failed_proposer in failed_proposers {
                        let count = map.entry(failed_proposer).or_insert(0);
                        *count += 1;
                    }
                },
                Err(msg) => {
                    error!(
                        "Failed proposer conversion from indices failed at epoch {}, round {}: {}",
                        meta.epoch(),
                        meta.round(),
                        msg
                    )
                },
            }
            map
        })
    }
```
