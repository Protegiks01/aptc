# Audit Report

## Title
Missing Public Key Validation in Outbound Peer Connections Enables Validator Identity Impersonation

## Summary
The outbound peer connection flow does not validate that the authenticated public key matches any key in the trusted peer set for the target peer_id. This allows an attacker to impersonate legitimate validators by providing malicious NetworkAddresses with attacker-controlled public keys while claiming to be a different peer_id.

## Finding Description

The Aptos network stack uses Noise IK protocol for peer authentication, where each peer is identified by a `PeerId` and possesses one or more `x25519::PublicKey`s. The trusted peers set maintains a mapping of `PeerId → Peer{keys: HashSet<PublicKey>, ...}` to enforce authentication.

**Asymmetric Validation in Inbound vs Outbound:**

For **inbound** connections, the authentication is properly implemented: [1](#0-0) 

This validates that the remote peer's authenticated public key exists in their registered key set.

However, for **outbound** connections, this validation is completely missing: [2](#0-1) 

The outbound handshake only calls `extract_peer_role_from_trusted_peers(remote_peer_id)`: [3](#0-2) 

This function merely looks up the `peer_id` in the trusted peer set and returns the role—it does **not** verify that the authenticated `remote_public_key` is in `trusted_peers[peer_id].keys`.

**Attack Flow:**

1. Attacker manipulates discovery mechanism or on-chain validator data to advertise a malicious NetworkAddress for legitimate validator A:
   ```
   /ip4/<attacker-ip>/tcp/6180/noise-ik/<attacker-pubkey>/handshake/0
   ```

2. Victim validator V attempts to dial peer_id=A using this malicious address: [4](#0-3) 

3. The address is parsed, extracting `attacker-pubkey` from the `/noise-ik/` component: [5](#0-4) 

4. Noise handshake succeeds with `attacker-pubkey` (attacker proves ownership of corresponding private key)

5. Connection metadata is created with `remote_peer_id = A` (from input parameter, not derived from authenticated key)

6. **No validation occurs** to check that `attacker-pubkey ∈ trusted_peers[A].keys`

7. Attacker is now connected to V with the identity of validator A

**Broken Invariant:**
This violates the fundamental authentication invariant that "connections should only succeed if the peer's authenticated public key is in their registered key set for that peer_id."

## Impact Explanation

**Severity: Critical**

This vulnerability enables multiple critical attacks:

1. **Consensus Manipulation**: Attacker can send malicious consensus messages (votes, proposals, blocks) while impersonating a legitimate validator, potentially causing:
   - Safety violations (conflicting blocks)
   - Chain splits
   - Byzantine behavior attribution to innocent validators

2. **State Sync Poisoning**: Attacker can provide corrupted state chunks while impersonating trusted validators

3. **Validator Reputation Damage**: Malicious actions are attributed to the impersonated validator's peer_id

4. **Network Partition**: Attacker can manipulate network connectivity by impersonating multiple validators

This qualifies as **Critical Severity** under Aptos Bug Bounty criteria: "Consensus/Safety violations" and "Non-recoverable network partition."

The attack bypasses the entire cryptographic authentication layer by exploiting the asymmetry between inbound and outbound validation.

## Likelihood Explanation

**Likelihood: Medium to High**

The exploitability depends on the attacker's ability to influence NetworkAddresses used for dialing:

**Attack Vectors:**

1. **On-chain Validator Set Manipulation**: If validator address updates don't validate key-address consistency, compromised validator accounts could update addresses with attacker-controlled keys: [6](#0-5) 

2. **Discovery Service Compromise**: Malicious discovery sources can advertise incorrect addresses: [7](#0-6) 

3. **Configuration File Manipulation**: Seed node addresses in configuration files

**Mitigating Factors:**
- On-chain governance controls validator set updates
- Multiple discovery sources provide redundancy
- Mutual authentication mode limits exposure

However, even with these factors, the complete absence of validation creates an exploitable attack surface.

## Recommendation

Add public key validation in the outbound connection flow, matching the inbound validation logic.

**Fix Location:** `network/framework/src/noise/handshake.rs`

Modify `NoiseUpgrader::upgrade_outbound` to validate the authenticated public key:

```rust
pub async fn upgrade_outbound<TSocket, F>(
    &self,
    mut socket: TSocket,
    remote_peer_id: PeerId,
    remote_public_key: x25519::PublicKey,
    time_provider: F,
) -> Result<(NoiseStream<TSocket>, PeerRole), NoiseHandshakeError>
where
    TSocket: AsyncRead + AsyncWrite + Debug + Unpin,
    F: Fn() -> [u8; AntiReplayTimestamps::TIMESTAMP_SIZE],
{
    // ... existing handshake code ...
    
    let (_, session) = self
        .noise_config
        .finalize_connection(initiator_state, &server_response)
        .map_err(NoiseHandshakeError::ClientFinalizeFailed)?;

    // NEW: Validate authenticated public key matches trusted peer set
    let peers_and_metadata = match &self.auth_mode {
        HandshakeAuthMode::Mutual { peers_and_metadata, .. } => peers_and_metadata.clone(),
        HandshakeAuthMode::MaybeMutual(peers_and_metadata) => peers_and_metadata.clone(),
    };
    
    let peer_role = match peers_and_metadata.get_trusted_peers(&self.network_context.network_id()) {
        Ok(trusted_peers) => {
            if let Some(peer) = trusted_peers.get(&remote_peer_id) {
                // Validate that authenticated key is in peer's key set
                if !peer.keys.contains(&remote_public_key) {
                    return Err(NoiseHandshakeError::OutboundPubkeyMismatch(
                        remote_peer_id.short_str(),
                        hex::encode(remote_public_key.as_slice()),
                    ));
                }
                peer.role
            } else {
                // For non-mutual auth, verify peer_id matches derived from public key
                let derived_peer_id = aptos_types::account_address::from_identity_public_key(
                    remote_public_key,
                );
                if derived_peer_id != remote_peer_id {
                    return Err(NoiseHandshakeError::ClientPeerIdMismatch(
                        remote_peer_id.short_str(),
                        remote_peer_id,
                        derived_peer_id,
                    ));
                }
                PeerRole::Unknown
            }
        },
        Err(error) => {
            error!(NetworkSchema::new(&self.network_context).message(format!(
                "Failed to get trusted peers: {:?}", error
            )));
            PeerRole::Unknown
        }
    };

    let noise_stream = NoiseStream::new(socket, session);
    Ok((noise_stream, peer_role))
}
```

**Add new error variant** to `NoiseHandshakeError`:
```rust
#[error("Outbound connection public key mismatch for peer {0}: authenticated key {1} not in trusted key set")]
OutboundPubkeyMismatch(ShortHexStr, String),
```

## Proof of Concept

```rust
#[cfg(test)]
mod outbound_pubkey_validation_test {
    use super::*;
    use aptos_types::account_address::AccountAddress;
    
    #[tokio::test]
    async fn test_outbound_rejects_mismatched_pubkey() {
        // Setup: Create legitimate peer A and attacker
        let mut rng = ::rand::rngs::StdRng::from_seed(TEST_SEED);
        let (peer_a_private_key, peer_a_public_key) = create_key_pair(&mut rng);
        let (attacker_private_key, attacker_public_key) = create_key_pair(&mut rng);
        
        // Create peers and metadata with peer A registered
        let network_ids = vec![NetworkId::Validator];
        let peers_and_metadata = PeersAndMetadata::new(&network_ids);
        let peer_a_id = AccountAddress::from_identity_public_key(peer_a_public_key);
        
        // Register peer A with its legitimate public key
        let peer_a = Peer::new(
            vec![],
            [peer_a_public_key].into_iter().collect(), // Only legitimate key
            PeerRole::Validator,
        );
        let mut trusted_peers = HashMap::new();
        trusted_peers.insert(peer_a_id, peer_a);
        peers_and_metadata.set_trusted_peers(&NetworkId::Validator, trusted_peers).unwrap();
        
        // Attacker node setup
        let attacker_upgrader = NoiseUpgrader::new(
            NetworkContext::mock(),
            attacker_private_key,
            HandshakeAuthMode::mutual(peers_and_metadata.clone()),
        );
        
        // Victim node setup
        let victim_upgrader = NoiseUpgrader::new(
            NetworkContext::mock(),
            peer_a_private_key, // Victim is trying to connect
            HandshakeAuthMode::mutual(peers_and_metadata),
        );
        
        let (dialer_socket, listener_socket) = MemorySocket::new_pair();
        
        // Attack: Victim dials peer_a_id but connects to attacker's socket
        let client_future = victim_upgrader.upgrade_outbound(
            dialer_socket,
            peer_a_id,
            attacker_public_key, // Attacker's key, not peer A's!
            AntiReplayTimestamps::now,
        );
        
        let server_future = attacker_upgrader.upgrade_inbound(listener_socket);
        
        let (client_result, _server_result) = tokio::join!(client_future, server_future);
        
        // Expected: Connection should FAIL with pubkey mismatch error
        // Actual (vulnerable): Connection SUCCEEDS and attacker impersonates peer A
        assert!(client_result.is_err(), "Outbound connection with mismatched pubkey should fail!");
        
        match client_result {
            Err(NoiseHandshakeError::OutboundPubkeyMismatch(..)) => {
                // Correct behavior after fix
            },
            Ok(_) => {
                panic!("VULNERABILITY: Outbound connection succeeded with attacker's pubkey while claiming peer A's identity!");
            },
            Err(e) => {
                panic!("Unexpected error type: {:?}", e);
            }
        }
    }
}
```

**Notes:**

The vulnerability exists in the current codebase because:
- Inbound validation: [1](#0-0) 
- Outbound missing validation: [8](#0-7) 
- Address parsing extracts pubkey: [9](#0-8) 
- No validation that extracted pubkey matches trusted keys for the peer_id

### Citations

**File:** network/framework/src/noise/handshake.rs (L183-263)
```rust
    pub async fn upgrade_outbound<TSocket, F>(
        &self,
        mut socket: TSocket,
        remote_peer_id: PeerId,
        remote_public_key: x25519::PublicKey,
        time_provider: F,
    ) -> Result<(NoiseStream<TSocket>, PeerRole), NoiseHandshakeError>
    where
        TSocket: AsyncRead + AsyncWrite + Debug + Unpin,
        F: Fn() -> [u8; AntiReplayTimestamps::TIMESTAMP_SIZE],
    {
        // buffer to hold prologue + first noise handshake message
        let mut client_message = [0; Self::CLIENT_MESSAGE_SIZE];

        // craft prologue = self_peer_id | expected_public_key
        client_message[..PeerId::LENGTH].copy_from_slice(self.network_context.peer_id().as_ref());
        client_message[PeerId::LENGTH..Self::PROLOGUE_SIZE]
            .copy_from_slice(remote_public_key.as_slice());

        let (prologue_msg, client_noise_msg) = client_message.split_at_mut(Self::PROLOGUE_SIZE);

        // craft 8-byte payload as current timestamp (in milliseconds)
        let payload = time_provider();

        // craft first handshake message  (-> e, es, s, ss)
        let mut rng = rand::rngs::OsRng;
        let initiator_state = self
            .noise_config
            .initiate_connection(
                &mut rng,
                prologue_msg,
                remote_public_key,
                Some(&payload),
                client_noise_msg,
            )
            .map_err(NoiseHandshakeError::BuildClientHandshakeMessageFailed)?;

        // send the first handshake message
        trace!(
            "{} noise client: handshake write: remote_public_key: {}",
            self.network_context,
            remote_public_key,
        );
        socket
            .write_all(&client_message)
            .await
            .map_err(NoiseHandshakeError::ClientWriteFailed)?;
        socket
            .flush()
            .await
            .map_err(NoiseHandshakeError::ClientFlushFailed)?;

        // receive the server's response (<- e, ee, se)
        trace!(
            "{} noise client: handshake read: remote_public_key: {}",
            self.network_context,
            remote_public_key,
        );
        let mut server_response = [0u8; Self::SERVER_MESSAGE_SIZE];
        socket
            .read_exact(&mut server_response)
            .await
            .map_err(NoiseHandshakeError::ClientReadFailed)?;

        // parse the server's response
        trace!(
            "{} noise client: handshake finalize: remote_public_key: {}",
            self.network_context,
            remote_public_key,
        );
        let (_, session) = self
            .noise_config
            .finalize_connection(initiator_state, &server_response)
            .map_err(NoiseHandshakeError::ClientFinalizeFailed)?;

        // finalize the connection
        let noise_stream = NoiseStream::new(socket, session);
        let peer_role = self.extract_peer_role_from_trusted_peers(remote_peer_id);

        Ok((noise_stream, peer_role))
    }
```

**File:** network/framework/src/noise/handshake.rs (L268-303)
```rust
    fn extract_peer_role_from_trusted_peers(&self, remote_peer_id: PeerId) -> PeerRole {
        // Get the peers and metadata struct
        let peers_and_metadata = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => peers_and_metadata.clone(),
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => peers_and_metadata.clone(),
        };

        // Determine the peer role
        match peers_and_metadata.get_trusted_peers(&self.network_context.network_id()) {
            Ok(trusted_peers) => {
                match trusted_peers.get(&remote_peer_id) {
                    Some(trusted_peer) => {
                        return trusted_peer.role; // We've found the peer!
                    },
                    None => {
                        error!(NetworkSchema::new(&self.network_context).message(format!(
                            "{} Outbound connection made with unknown peer (not in the trusted peers set)! Missing peer: {:?}",
                            self.network_context, remote_peer_id

                        )));
                    },
                }
            },
            Err(error) => {
                error!(NetworkSchema::new(&self.network_context).message(format!(
                    "Failed to get trusted peers for network context: {:?}, error: {:?}",
                    self.network_context, error
                )));
            },
        };

        // If we couldn't determine the peer role, return an unknown peer role
        PeerRole::Unknown
    }
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** network/framework/src/transport/mod.rs (L336-407)
```rust
pub async fn upgrade_outbound<T: TSocket>(
    ctxt: Arc<UpgradeContext>,
    fut_socket: impl Future<Output = io::Result<T>>,
    addr: NetworkAddress,
    remote_peer_id: PeerId,
    remote_pubkey: x25519::PublicKey,
) -> io::Result<Connection<NoiseStream<T>>> {
    let origin = ConnectionOrigin::Outbound;
    let socket = fut_socket.await?;

    // noise handshake
    let (mut socket, peer_role) = ctxt
        .noise
        .upgrade_outbound(
            socket,
            remote_peer_id,
            remote_pubkey,
            AntiReplayTimestamps::now,
        )
        .await
        .map_err(|err| {
            if err.should_security_log() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(15)),
                    warn!(
                        SecurityEvent::NoiseHandshake,
                        NetworkSchema::new(&ctxt.noise.network_context)
                            .network_address(&addr)
                            .connection_origin(&origin),
                        error = %err,
                    )
                );
            }
            io::Error::other(err)
        })?;

    // sanity check: Noise IK should always guarantee this is true
    debug_assert_eq!(remote_pubkey, socket.get_remote_static());

    // exchange HandshakeMsg
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket).await?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|e| {
            let e = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id, e
            );
            io::Error::other(e)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
}
```

**File:** network/framework/src/transport/mod.rs (L471-513)
```rust
    fn parse_dial_addr(
        addr: &NetworkAddress,
    ) -> io::Result<(NetworkAddress, x25519::PublicKey, u8)> {
        use aptos_types::network_address::Protocol::*;

        let protos = addr.as_slice();

        // parse out the base transport protocol(s), which we will just ignore
        // and leave for the base_transport to actually parse and dial.
        // TODO(philiphayes): protos[..X] is kinda hacky. `Transport` trait
        // should handle this.
        let (base_transport_protos, base_transport_suffix) = parse_ip_tcp(protos)
            .map(|x| (&protos[..2], x.1))
            .or_else(|| parse_dns_tcp(protos).map(|x| (&protos[..2], x.1)))
            .or_else(|| parse_memory(protos).map(|x| (&protos[..1], x.1)))
            .ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::InvalidInput,
                    format!(
                        "Unexpected dialing network address: '{}', expected: \
                         memory, ip+tcp, or dns+tcp",
                        addr
                    ),
                )
            })?;

        // parse out the aptosnet protocols (noise ik and handshake)
        match base_transport_suffix {
            [NoiseIK(pubkey), Handshake(version)] => {
                let base_addr = NetworkAddress::try_from(base_transport_protos.to_vec())
                    .expect("base_transport_protos is always non-empty");
                Ok((base_addr, *pubkey, *version))
            },
            _ => Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "Unexpected dialing network address: '{}', expected: \
                     '/../noise-ik/<pubkey>/handshake/<version>'",
                    addr
                ),
            )),
        }
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L718-780)
```rust
    fn queue_dial_peer<'a>(
        &'a mut self,
        peer_id: PeerId,
        peer: DiscoveredPeer,
        pending_dials: &'a mut FuturesUnordered<BoxFuture<'static, PeerId>>,
    ) {
        // If we're attempting to dial a Peer we must not be connected to it. This ensures that
        // newly eligible, but not connected to peers, have their counter initialized properly.
        counters::peer_connected(&self.network_context, &peer_id, 0);

        // Get the peer's dial state
        let dial_state = match self.dial_states.get_mut(&peer_id) {
            Some(dial_state) => dial_state,
            None => {
                // The peer should have a dial state! If not, log an error and return.
                error!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    "{} Peer {} does not have a dial state!",
                    self.network_context,
                    peer_id.short_str()
                );
                return;
            },
        };

        // Choose the next addr to dial for this peer. Currently, we just
        // round-robin the selection, i.e., try the sequence:
        // addr[0], .., addr[len-1], addr[0], ..
        let addr = match dial_state.next_addr(&peer.addrs) {
            Some(addr) => addr.clone(),
            None => {
                warn!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    "{} Peer {} does not have any network addresses!",
                    self.network_context,
                    peer_id.short_str()
                );
                return;
            },
        };

        // Using the DialState's backoff strategy, compute the delay until
        // the next dial attempt for this peer.
        let dial_delay = dial_state.next_backoff_delay(self.max_delay);
        let f_delay = self.time_service.sleep(dial_delay);

        let (cancel_tx, cancel_rx) = oneshot::channel();

        let network_context = self.network_context;
        // Create future which completes by either dialing after calculated
        // delay or on cancellation.
        let connection_reqs_tx = self.connection_reqs_tx.clone();
        let f = async move {
            // We dial after a delay. The dial can be canceled by sending to or dropping
            // `cancel_rx`.
            let dial_result = futures::select! {
                _ = f_delay.fuse() => {
                    info!(
                        NetworkSchema::new(&network_context)
                            .remote_peer(&peer_id)
                            .network_address(&addr),
                        "{} Dialing peer {} at {}",
                        network_context,
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-1002)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .discovery_source(&src),
                    "{} pubkey sets updated for peer: {}, pubkeys: {}",
                    self.network_context,
                    peer_id.short_str(),
                    peer.keys
                );
                keys_updated = true;
                peer_updated = true;
            }

            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }

            // If we're currently trying to dial this peer, we reset their
            // dial state. As a result, we will begin our next dial attempt
            // from the first address (which might have changed) and from a
            // fresh backoff (since the current backoff delay might be maxed
            // out if we can't reach any of their previous addresses).
            if peer_updated {
                if let Some(dial_state) = self.dial_states.get_mut(&peer_id) {
                    *dial_state = DialState::new(self.backoff_strategy.clone());
                }
            }
        }

        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
    }
```
