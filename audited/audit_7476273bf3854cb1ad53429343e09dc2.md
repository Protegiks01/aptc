# Audit Report

## Title
Critical Cryptographic Bypass in Transaction Backup Restoration Allows Injection of Fraudulent Transactions

## Summary
The `LoadedChunk::load()` function in the backup restoration system fails to verify the authenticity of `LedgerInfoWithSignatures` when `epoch_history` is `None`, allowing an attacker to inject arbitrary fraudulent transactions into the restored database by providing a malicious backup with crafted ledger info and matching cryptographic proofs.

## Finding Description

The vulnerability exists in the transaction backup restoration flow where cryptographic verification is conditionally bypassed: [1](#0-0) 

When `epoch_history` is `None`, the `verify_ledger_info()` call is skipped, leaving the `LedgerInfoWithSignatures` completely unverified. This is the default configuration when using the db-tool: [2](#0-1) 

The subsequent verification at line 167 only validates internal consistency: [3](#0-2) 

This verification chain checks:
1. Transaction hashes match TransactionInfo hashes
2. TransactionInfo objects are proven by the accumulator range proof
3. The accumulator root matches the ledger_info's transaction accumulator hash [4](#0-3) 

However, this creates a **circular verification loop**: all checks only validate consistency within the provided data, not authenticity of the root trust anchor (the LedgerInfo). The proper verification that should occur via `EpochHistory::verify_ledger_info()` validates signatures from the validator set: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates fraudulent transactions (e.g., minting tokens to their address)
2. Computes correct TransactionInfo objects for these transactions
3. Builds a Merkle accumulator tree from the TransactionInfo hashes
4. Creates a LedgerInfo with the accumulator root hash (no valid signatures needed)
5. Wraps it in LedgerInfoWithSignatures with fake/empty signatures
6. Generates a valid TransactionAccumulatorRangeProof connecting the TransactionInfos to the crafted accumulator root
7. Packages everything in backup format and places it in backup storage

When an operator restores from this backup without epoch_history, all cryptographic checks pass because they only verify internal consistency, not authenticity of the trust root.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables:
- **Consensus/Safety Violation**: Different nodes restoring from different backups will have divergent states, breaking consensus safety invariant #2
- **Loss of Funds**: Attacker can inject transactions that mint tokens, transfer funds, or manipulate balances
- **State Corruption**: Arbitrary state changes can be injected, potentially requiring a hardfork to recover
- **Validator Set Manipulation**: Attacker could inject transactions modifying the active validator set

The attack affects any node performing transaction restoration without epoch_history, which includes:
- Emergency disaster recovery scenarios
- New nodes bootstrapping from backups
- Testing/development environments that become production

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attack Requirements:**
- Compromise backup storage OR man-in-the-middle attack on backup download
- Operator runs transaction restore with `epoch_history = None` (the default in db-tool)
- No validator keys or quorum signatures required

**Why Likely:**
1. The vulnerable code path is the default in db-tool for transaction restoration
2. Operators performing emergency recovery are likely targets who may not verify epoch history setup
3. Backup storage compromise is a realistic threat vector (S3 misconfigurations, credential leaks)
4. No warning or documentation indicates this security requirement

**Complexity:** LOW - Attack requires only:
- Ability to compute Merkle tree hashes (standard cryptographic operations)
- Understanding of backup format (documented in code)
- Access to backup storage or network path

## Recommendation

**Immediate Fix:** Make epoch_history mandatory for transaction restoration and fail fast if not provided:

```rust
// In LoadedChunk::load() around line 152:
let epoch_history = epoch_history.ok_or_else(|| {
    anyhow!(
        "epoch_history is required for secure transaction restoration. \
         Without it, LedgerInfo signatures cannot be verified, allowing \
         injection of fraudulent transactions."
    )
})?;
epoch_history.verify_ledger_info(&ledger_info)?;
```

**Comprehensive Fix:**
1. Remove `Option<>` wrapper from epoch_history parameter in `LoadedChunk::load()`
2. Update `TransactionRestoreController::new()` to require epoch_history
3. Update db-tool to properly initialize epoch_history before transaction restoration
4. Add validation in `TransactionRestoreBatchController::new()` to reject None epoch_history
5. Add integration test that attempts restoration without epoch_history and expects failure

**Defense in Depth:**
- Add checksum verification of backup manifests against trusted sources
- Implement backup signature verification at the storage layer
- Log warnings when processing backups without trusted waypoints
- Add operator documentation emphasizing the security requirement

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_fraudulent_transaction_injection_without_epoch_history() {
    use aptos_crypto::HashValue;
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        transaction::{Transaction, TransactionInfo, TransactionListWithProofV2},
        proof::TransactionAccumulatorRangeProof,
        block_info::BlockInfo,
    };
    use storage::backup::backup_types::transaction::restore::LoadedChunk;
    
    // Step 1: Create fraudulent transaction
    let fraudulent_txn = Transaction::UserTransaction(/* mint 1M tokens */);
    
    // Step 2: Compute TransactionInfo for fraudulent transaction
    let txn_hash = CryptoHash::hash(&fraudulent_txn);
    let fraudulent_txn_info = TransactionInfo::new(
        txn_hash,
        HashValue::zero(), // state_change_hash
        HashValue::zero(), // event_root_hash
        None, // state_checkpoint_hash
        0, // gas_used
        KeptVMStatus::Executed,
    );
    
    // Step 3: Build accumulator and create malicious LedgerInfo
    let txn_info_hash = CryptoHash::hash(&fraudulent_txn_info);
    let accumulator = InMemoryTransactionAccumulator::new(vec![], 0)
        .append(&[txn_info_hash]);
    let malicious_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            0, // epoch
            0, // round
            HashValue::zero(), // block_id
            accumulator.root_hash(), // transaction_accumulator_hash
            0, // version
            0, // timestamp_usecs
            None, // next_epoch_state
        ),
        HashValue::zero(), // consensus_data_hash
    );
    
    // Step 4: Wrap in LedgerInfoWithSignatures WITHOUT valid signatures
    let malicious_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        BTreeMap::new(), // No signatures!
    );
    
    // Step 5: Create valid proof connecting to malicious ledger info
    let range_proof = TransactionAccumulatorRangeProof::new(vec![], vec![]);
    
    // Step 6: Attempt to load - THIS SHOULD FAIL BUT CURRENTLY SUCCEEDS
    let manifest = TransactionChunk {
        first_version: 0,
        last_version: 0,
        transactions: "fake_handle".into(),
        proof: "fake_proof".into(),
        format: TransactionChunkFormat::V1,
    };
    
    // Mock storage that returns our malicious data
    let storage = Arc::new(MockBackupStorage::new(
        malicious_ledger_info_with_sigs,
        range_proof,
        vec![fraudulent_txn],
    ));
    
    // CRITICAL: epoch_history = None means no verification!
    let result = LoadedChunk::load(manifest, &storage, None).await;
    
    // Currently succeeds - demonstrates the vulnerability
    assert!(result.is_ok(), "Fraudulent backup was accepted!");
    
    // With fix, should fail:
    // assert!(result.is_err(), "Should reject backup without epoch_history");
}
```

**Notes:**
- The TODO comment at line 280 of `epoch_ending/restore.rs` acknowledges this issue needs fixing from "upper level"
- No existing tests validate that restoration fails without epoch_history
- The warning logged when epoch is too new (lines 281-287) suggests developers are aware of verification gaps but the fix was incomplete

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L157-167)
```rust
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/db-tool/src/restore.rs (L102-108)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
```

**File:** types/src/transaction/mod.rs (L2317-2336)
```rust
        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```
